{"sha": "d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ZGNiNjM0NWJmYWM0NzFhYWRjMWU2NzRhZWY4ZGRjNzhhZDVjMWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-17T21:43:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-17T21:43:23Z"}, "message": "Auto merge of #67476 - mark-i-m:simplify-borrow_check-5, r=matthewjasper\n\nRegion naming refactoring [6/N]\n\nFollowup to #67474\n\nEDIT: this PR is probably best read commit-by-commit...\n\nThe major changes in this PR include:\n- moving many functions around to modules that better suit them. In particular, a lot of methods were moved from `borrow_check::diagnostics::region_errors` to `borrow_check::region_infer`, and `report_region_errors` was moved from `borrow_check` to `borrow_check::diagnostics::region_errors`.\n- `borrow_check::diagnostics::{region_errors, region_name}` are now most comprised of methods on `MirBorrowckCtxt` instead of `RegionInferenceContext`, allowing us to get rid of the annoying `pub(in crate::borrow_check)` on most of the fields of the latter, along with a number of method arguments on many methods.\n- I renamed `MirBorrowckCtxt.nonlexical_regioncx` to just `regioncx` because their is no lexical lifetimes any more, and the old name was annoyingly verbose, causing many lines to wrap unnecessarily.\n- I got rid of `ErrorRegionNamingContext`. Region naming is implemented as inherent methods on `MirBorrowckCtxt`, so we just move the naming stuff into that struct.\n\nThe PR is rather large, but the commits are fairly self-contained (though they don't all compile). There was one minor output change to one test with `compare-mode=nll`, which I think is acceptable.\n\nBetween this PR and the last one, a net of 200 lines are removed, most of which was function parameters and context structs :tada:\n\nSome samples:\n\n```diff\n-                        self.nonlexical_regioncx.free_region_constraint_info(\n-                            &self.body,\n-                            &self.local_names,\n-                            &self.upvars,\n-                            self.mir_def_id,\n-                            self.infcx,\n-                            borrow_region_vid,\n-                            region,\n-                        );\n+                        self.free_region_constraint_info(borrow_region_vid, region);\n```\n\n```diff\n-            .or_else(|| {\n-                self.give_name_if_anonymous_region_appears_in_yield_ty(\n-                    infcx,\n-                    body,\n-                    *mir_def_id,\n-                    fr,\n-                    renctx,\n-                )\n-            });\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_arguments(fr))\n```\n\nr? @matthewjasper\n\ncc @eddyb", "tree": {"sha": "40593f021b3514fe1148fa210ea167e4fe93918c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40593f021b3514fe1148fa210ea167e4fe93918c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "html_url": "https://github.com/rust-lang/rust/commit/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "689fca01c5a1eac2d240bf08aa728171a28f2285", "url": "https://api.github.com/repos/rust-lang/rust/commits/689fca01c5a1eac2d240bf08aa728171a28f2285", "html_url": "https://github.com/rust-lang/rust/commit/689fca01c5a1eac2d240bf08aa728171a28f2285"}, {"sha": "f05e40eb992fce44db348cfb1e8ecb4699e9cdd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f05e40eb992fce44db348cfb1e8ecb4699e9cdd6", "html_url": "https://github.com/rust-lang/rust/commit/f05e40eb992fce44db348cfb1e8ecb4699e9cdd6"}], "stats": {"total": 1670, "additions": 789, "deletions": 881}, "files": [{"sha": "01b7c5645fe8b2a1c0aaff5baed72ceede5ddb87", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -2,12 +2,13 @@\n \n use std::collections::VecDeque;\n \n+use rustc::infer::NLLRegionVariableOrigin;\n use rustc::mir::{\n     Body, CastKind, ConstraintCategory, FakeReadCause, Local, Location, Operand, Place, Rvalue,\n     Statement, StatementKind, TerminatorKind,\n };\n use rustc::ty::adjustment::PointerCast;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_index::vec::IndexVec;\n@@ -254,6 +255,23 @@ impl BorrowExplanation {\n }\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n+    fn free_region_constraint_info(\n+        &self,\n+        borrow_region: RegionVid,\n+        outlived_region: RegionVid,\n+    ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n+        let (category, from_closure, span) = self.regioncx.best_blame_constraint(\n+            &self.body,\n+            borrow_region,\n+            NLLRegionVariableOrigin::FreeRegion,\n+            |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n+        );\n+\n+        let outlived_fr_name = self.give_region_a_name(outlived_region);\n+\n+        (category, from_closure, span, outlived_fr_name)\n+    }\n+\n     /// Returns structured explanation for *why* the borrow contains the\n     /// point from `location`. This is key for the \"3-point errors\"\n     /// [described in the NLL RFC][d].\n@@ -278,14 +296,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             location, borrow, kind_place\n         );\n \n-        let regioncx = &self.nonlexical_regioncx;\n+        let regioncx = &self.regioncx;\n         let body: &Body<'_> = &self.body;\n         let tcx = self.infcx.tcx;\n \n         let borrow_region_vid = borrow.region;\n         debug!(\"explain_why_borrow_contains_point: borrow_region_vid={:?}\", borrow_region_vid);\n \n-        let region_sub = regioncx.find_sub_region_live_at(borrow_region_vid, location);\n+        let region_sub = self.regioncx.find_sub_region_live_at(borrow_region_vid, location);\n         debug!(\"explain_why_borrow_contains_point: region_sub={:?}\", region_sub);\n \n         match find_use::find(body, regioncx, tcx, region_sub, location) {\n@@ -329,10 +347,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             None => {\n-                if let Some(region) = regioncx.to_error_region_vid(borrow_region_vid) {\n-                    let (category, from_closure, span, region_name) = self\n-                        .nonlexical_regioncx\n-                        .free_region_constraint_info(self, borrow_region_vid, region);\n+                if let Some(region) = self.to_error_region_vid(borrow_region_vid) {\n+                    let (category, from_closure, span, region_name) =\n+                        self.free_region_constraint_info(borrow_region_vid, region);\n                     if let Some(region_name) = region_name {\n                         let opt_place_desc = self.describe_place(borrow.borrowed_place.as_ref());\n                         BorrowExplanation::MustBeValidFor {\n@@ -345,14 +362,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     } else {\n                         debug!(\n                             \"explain_why_borrow_contains_point: \\\n-                                Could not generate a region name\"\n+                             Could not generate a region name\"\n                         );\n                         BorrowExplanation::Unexplained\n                     }\n                 } else {\n                     debug!(\n                         \"explain_why_borrow_contains_point: \\\n-                            Could not generate an error region vid\"\n+                         Could not generate an error region vid\"\n                     );\n                     BorrowExplanation::Unexplained\n                 }"}, {"sha": "0fc73d33f90013475e059f7d9f8003343cdfe071", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -32,7 +32,7 @@ mod region_errors;\n crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n-crate use region_name::{RegionErrorNamingCtx, RegionName, RegionNameSource};\n+crate use region_name::{RegionName, RegionNameSource};\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n "}, {"sha": "ee9489078bdb9ba61d73168d6a419363235f637b", "filename": "src/librustc_mir/borrow_check/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -12,7 +12,7 @@ use smallvec::SmallVec;\n \n use crate::borrow_check::MirBorrowckCtxt;\n \n-use super::{ErrorConstraintInfo, RegionErrorNamingCtx, RegionName, RegionNameSource};\n+use super::{ErrorConstraintInfo, RegionName, RegionNameSource};\n \n /// The different things we could suggest.\n enum SuggestedConstraint {\n@@ -77,19 +77,15 @@ impl OutlivesSuggestionBuilder {\n     fn region_vid_to_name(\n         &self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n-        renctx: &mut RegionErrorNamingCtx,\n         region: RegionVid,\n     ) -> Option<RegionName> {\n-        mbcx.nonlexical_regioncx\n-            .give_region_a_name(mbcx, renctx, region)\n-            .filter(Self::region_name_is_suggestable)\n+        mbcx.give_region_a_name(region).filter(Self::region_name_is_suggestable)\n     }\n \n     /// Compiles a list of all suggestions to be printed in the final big suggestion.\n     fn compile_all_suggestions(\n         &self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> SmallVec<[SuggestedConstraint; 2]> {\n         let mut suggested = SmallVec::new();\n \n@@ -98,7 +94,7 @@ impl OutlivesSuggestionBuilder {\n         let mut unified_already = FxHashSet::default();\n \n         for (fr, outlived) in &self.constraints_to_add {\n-            let fr_name = if let Some(fr_name) = self.region_vid_to_name(mbcx, renctx, *fr) {\n+            let fr_name = if let Some(fr_name) = self.region_vid_to_name(mbcx, *fr) {\n                 fr_name\n             } else {\n                 continue;\n@@ -107,9 +103,7 @@ impl OutlivesSuggestionBuilder {\n             let outlived = outlived\n                 .iter()\n                 // if there is a `None`, we will just omit that constraint\n-                .filter_map(|fr| {\n-                    self.region_vid_to_name(mbcx, renctx, *fr).map(|rname| (fr, rname))\n-                })\n+                .filter_map(|fr| self.region_vid_to_name(mbcx, *fr).map(|rname| (fr, rname)))\n                 .collect::<Vec<_>>();\n \n             // No suggestable outlived lifetimes.\n@@ -173,12 +167,11 @@ impl OutlivesSuggestionBuilder {\n         &mut self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n         errci: &ErrorConstraintInfo,\n-        renctx: &mut RegionErrorNamingCtx,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) {\n         // Emit an intermediate note.\n-        let fr_name = self.region_vid_to_name(mbcx, renctx, errci.fr);\n-        let outlived_fr_name = self.region_vid_to_name(mbcx, renctx, errci.outlived_fr);\n+        let fr_name = self.region_vid_to_name(mbcx, errci.fr);\n+        let outlived_fr_name = self.region_vid_to_name(mbcx, errci.outlived_fr);\n \n         if let (Some(fr_name), Some(outlived_fr_name)) = (fr_name, outlived_fr_name) {\n             if let RegionNameSource::Static = outlived_fr_name.source {\n@@ -194,11 +187,7 @@ impl OutlivesSuggestionBuilder {\n \n     /// If there is a suggestion to emit, add a diagnostic to the buffer. This is the final\n     /// suggestion including all collected constraints.\n-    crate fn add_suggestion(\n-        &self,\n-        mbcx: &mut MirBorrowckCtxt<'_, '_>,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) {\n+    crate fn add_suggestion(&self, mbcx: &mut MirBorrowckCtxt<'_, '_>) {\n         // No constraints to add? Done.\n         if self.constraints_to_add.is_empty() {\n             debug!(\"No constraints to suggest.\");\n@@ -215,7 +204,7 @@ impl OutlivesSuggestionBuilder {\n         }\n \n         // Get all suggestable constraints.\n-        let suggested = self.compile_all_suggestions(mbcx, renctx);\n+        let suggested = self.compile_all_suggestions(mbcx);\n \n         // If there are no suggestable constraints...\n         if suggested.is_empty() {"}, {"sha": "b999dfa3031035f83157f12b37fd2e0a1ea4c2f3", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 193, "deletions": 515, "changes": 708, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -1,27 +1,25 @@\n //! Error reporting machinery for lifetime errors.\n \n use rustc::infer::{\n-    error_reporting::nice_region_error::NiceRegionError, region_constraints::GenericKind,\n-    InferCtxt, NLLRegionVariableOrigin,\n+    error_reporting::nice_region_error::NiceRegionError, opaque_types, NLLRegionVariableOrigin,\n };\n-use rustc::mir::{Body, ConstraintCategory, Location};\n+use rustc::mir::ConstraintCategory;\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::def_id::DefId;\n-use rustc_index::vec::IndexVec;\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n-use std::collections::VecDeque;\n \n use crate::util::borrowck_errors;\n \n use crate::borrow_check::{\n-    constraints::OutlivesConstraint, nll::ConstraintDescription,\n-    region_infer::RegionInferenceContext, type_check::Locations, universal_regions::DefiningTy,\n+    nll::ConstraintDescription,\n+    region_infer::{values::RegionElement, TypeTest},\n+    universal_regions::DefiningTy,\n     MirBorrowckCtxt,\n };\n \n-use super::{OutlivesSuggestionBuilder, RegionErrorNamingCtx, RegionName, RegionNameSource};\n+use super::{OutlivesSuggestionBuilder, RegionName, RegionNameSource};\n \n impl ConstraintDescription for ConstraintCategory {\n     fn description(&self) -> &'static str {\n@@ -46,13 +44,6 @@ impl ConstraintDescription for ConstraintCategory {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum Trace {\n-    StartRegion,\n-    FromOutlivesConstraint(OutlivesConstraint),\n-    NotVisited,\n-}\n-\n /// A collection of errors encountered during region inference. This is needed to efficiently\n /// report errors after borrow checking.\n ///\n@@ -62,23 +53,8 @@ crate type RegionErrors<'tcx> = Vec<RegionErrorKind<'tcx>>;\n \n #[derive(Clone, Debug)]\n crate enum RegionErrorKind<'tcx> {\n-    /// An error for a type test: `T: 'a` does not live long enough.\n-    TypeTestDoesNotLiveLongEnough {\n-        /// The span of the type test.\n-        span: Span,\n-        /// The generic type of the type test.\n-        generic: GenericKind<'tcx>,\n-    },\n-\n-    /// A generic bound failure for a type test.\n-    TypeTestGenericBoundError {\n-        /// The span of the type test.\n-        span: Span,\n-        /// The generic type of the type test.\n-        generic: GenericKind<'tcx>,\n-        /// The lower bound region.\n-        lower_bound_region: ty::Region<'tcx>,\n-    },\n+    /// A generic bound failure for a type test (`T: 'a`).\n+    TypeTestError { type_test: TypeTest<'tcx> },\n \n     /// An unexpected hidden region for an opaque type.\n     UnexpectedHiddenRegion {\n@@ -94,8 +70,8 @@ crate enum RegionErrorKind<'tcx> {\n     BoundUniversalRegionError {\n         /// The placeholder free region.\n         longer_fr: RegionVid,\n-        /// The region that erroneously must be outlived by `longer_fr`.\n-        error_region: RegionVid,\n+        /// The region element that erroneously must be outlived by `longer_fr`.\n+        error_element: RegionElement,\n         /// The origin of the placeholder region.\n         fr_origin: NLLRegionVariableOrigin,\n     },\n@@ -128,297 +104,161 @@ pub struct ErrorConstraintInfo {\n     pub(super) span: Span,\n }\n \n-impl<'tcx> RegionInferenceContext<'tcx> {\n+impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// Converts a region inference variable into a `ty::Region` that\n     /// we can use for error reporting. If `r` is universally bound,\n     /// then we use the name that we have on record for it. If `r` is\n     /// existentially bound, then we check its inferred value and try\n     /// to find a good name from that. Returns `None` if we can't find\n     /// one (e.g., this is just some random part of the CFG).\n-    pub fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n-        self.to_error_region_vid(r).and_then(|r| self.definitions[r].external_name)\n+    pub(super) fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n+        self.to_error_region_vid(r).and_then(|r| self.regioncx.region_definition(r).external_name)\n     }\n \n-    /// Returns the [RegionVid] corresponding to the region returned by\n+    /// Returns the `RegionVid` corresponding to the region returned by\n     /// `to_error_region`.\n-    pub fn to_error_region_vid(&self, r: RegionVid) -> Option<RegionVid> {\n-        if self.universal_regions.is_universal_region(r) {\n+    pub(super) fn to_error_region_vid(&self, r: RegionVid) -> Option<RegionVid> {\n+        if self.regioncx.universal_regions().is_universal_region(r) {\n             Some(r)\n         } else {\n-            let r_scc = self.constraint_sccs.scc(r);\n-            let upper_bound = self.universal_upper_bound(r);\n-            if self.scc_values.contains(r_scc, upper_bound) {\n+            let upper_bound = self.regioncx.universal_upper_bound(r);\n+\n+            if self.regioncx.upper_bound_in_region_scc(r, upper_bound) {\n                 self.to_error_region_vid(upper_bound)\n             } else {\n                 None\n             }\n         }\n     }\n \n-    /// Tries to find the best constraint to blame for the fact that\n-    /// `R: from_region`, where `R` is some region that meets\n-    /// `target_test`. This works by following the constraint graph,\n-    /// creating a constraint path that forces `R` to outlive\n-    /// `from_region`, and then finding the best choices within that\n-    /// path to blame.\n-    fn best_blame_constraint(\n-        &self,\n-        body: &Body<'tcx>,\n-        from_region: RegionVid,\n-        from_region_origin: NLLRegionVariableOrigin,\n-        target_test: impl Fn(RegionVid) -> bool,\n-    ) -> (ConstraintCategory, bool, Span) {\n-        debug!(\n-            \"best_blame_constraint(from_region={:?}, from_region_origin={:?})\",\n-            from_region, from_region_origin\n-        );\n-\n-        // Find all paths\n-        let (path, target_region) =\n-            self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n-        debug!(\n-            \"best_blame_constraint: path={:#?}\",\n-            path.iter()\n-                .map(|&c| format!(\n-                    \"{:?} ({:?}: {:?})\",\n-                    c,\n-                    self.constraint_sccs.scc(c.sup),\n-                    self.constraint_sccs.scc(c.sub),\n-                ))\n-                .collect::<Vec<_>>()\n-        );\n-\n-        // Classify each of the constraints along the path.\n-        let mut categorized_path: Vec<(ConstraintCategory, bool, Span)> = path\n-            .iter()\n-            .map(|constraint| {\n-                if constraint.category == ConstraintCategory::ClosureBounds {\n-                    self.retrieve_closure_constraint_info(body, &constraint)\n-                } else {\n-                    (constraint.category, false, constraint.locations.span(body))\n-                }\n-            })\n-            .collect();\n-        debug!(\"best_blame_constraint: categorized_path={:#?}\", categorized_path);\n-\n-        // To find the best span to cite, we first try to look for the\n-        // final constraint that is interesting and where the `sup` is\n-        // not unified with the ultimate target region. The reason\n-        // for this is that we have a chain of constraints that lead\n-        // from the source to the target region, something like:\n-        //\n-        //    '0: '1 ('0 is the source)\n-        //    '1: '2\n-        //    '2: '3\n-        //    '3: '4\n-        //    '4: '5\n-        //    '5: '6 ('6 is the target)\n-        //\n-        // Some of those regions are unified with `'6` (in the same\n-        // SCC).  We want to screen those out. After that point, the\n-        // \"closest\" constraint we have to the end is going to be the\n-        // most likely to be the point where the value escapes -- but\n-        // we still want to screen for an \"interesting\" point to\n-        // highlight (e.g., a call site or something).\n-        let target_scc = self.constraint_sccs.scc(target_region);\n-        let mut range = 0..path.len();\n-\n-        // As noted above, when reporting an error, there is typically a chain of constraints\n-        // leading from some \"source\" region which must outlive some \"target\" region.\n-        // In most cases, we prefer to \"blame\" the constraints closer to the target --\n-        // but there is one exception. When constraints arise from higher-ranked subtyping,\n-        // we generally prefer to blame the source value,\n-        // as the \"target\" in this case tends to be some type annotation that the user gave.\n-        // Therefore, if we find that the region origin is some instantiation\n-        // of a higher-ranked region, we start our search from the \"source\" point\n-        // rather than the \"target\", and we also tweak a few other things.\n-        //\n-        // An example might be this bit of Rust code:\n-        //\n-        // ```rust\n-        // let x: fn(&'static ()) = |_| {};\n-        // let y: for<'a> fn(&'a ()) = x;\n-        // ```\n-        //\n-        // In MIR, this will be converted into a combination of assignments and type ascriptions.\n-        // In particular, the 'static is imposed through a type ascription:\n-        //\n-        // ```rust\n-        // x = ...;\n-        // AscribeUserType(x, fn(&'static ())\n-        // y = x;\n-        // ```\n-        //\n-        // We wind up ultimately with constraints like\n-        //\n-        // ```rust\n-        // !a: 'temp1 // from the `y = x` statement\n-        // 'temp1: 'temp2\n-        // 'temp2: 'static // from the AscribeUserType\n-        // ```\n-        //\n-        // and here we prefer to blame the source (the y = x statement).\n-        let blame_source = match from_region_origin {\n-            NLLRegionVariableOrigin::FreeRegion\n-            | NLLRegionVariableOrigin::Existential { from_forall: false } => true,\n-            NLLRegionVariableOrigin::Placeholder(_)\n-            | NLLRegionVariableOrigin::Existential { from_forall: true } => false,\n-        };\n-\n-        let find_region = |i: &usize| {\n-            let constraint = path[*i];\n-\n-            let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n-\n-            if blame_source {\n-                match categorized_path[*i].0 {\n-                    ConstraintCategory::OpaqueType\n-                    | ConstraintCategory::Boring\n-                    | ConstraintCategory::BoringNoLocation\n-                    | ConstraintCategory::Internal => false,\n-                    ConstraintCategory::TypeAnnotation\n-                    | ConstraintCategory::Return\n-                    | ConstraintCategory::Yield => true,\n-                    _ => constraint_sup_scc != target_scc,\n-                }\n-            } else {\n-                match categorized_path[*i].0 {\n-                    ConstraintCategory::OpaqueType\n-                    | ConstraintCategory::Boring\n-                    | ConstraintCategory::BoringNoLocation\n-                    | ConstraintCategory::Internal => false,\n-                    _ => true,\n-                }\n-            }\n-        };\n-\n-        let best_choice =\n-            if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n-\n-        debug!(\n-            \"best_blame_constraint: best_choice={:?} blame_source={}\",\n-            best_choice, blame_source\n-        );\n-\n-        if let Some(i) = best_choice {\n-            if let Some(next) = categorized_path.get(i + 1) {\n-                if categorized_path[i].0 == ConstraintCategory::Return\n-                    && next.0 == ConstraintCategory::OpaqueType\n+    /// Returns `true` if a closure is inferred to be an `FnMut` closure.\n+    fn is_closure_fn_mut(&self, fr: RegionVid) -> bool {\n+        if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n+            if let ty::BoundRegion::BrEnv = free_region.bound_region {\n+                if let DefiningTy::Closure(def_id, substs) =\n+                    self.regioncx.universal_regions().defining_ty\n                 {\n-                    // The return expression is being influenced by the return type being\n-                    // impl Trait, point at the return type and not the return expr.\n-                    return *next;\n+                    return substs.as_closure().kind(def_id, self.infcx.tcx)\n+                        == ty::ClosureKind::FnMut;\n                 }\n             }\n-            return categorized_path[i];\n         }\n \n-        // If that search fails, that is.. unusual. Maybe everything\n-        // is in the same SCC or something. In that case, find what\n-        // appears to be the most interesting point to report to the\n-        // user via an even more ad-hoc guess.\n-        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n-        debug!(\"`: sorted_path={:#?}\", categorized_path);\n-\n-        *categorized_path.first().unwrap()\n+        false\n     }\n \n-    /// Walks the graph of constraints (where `'a: 'b` is considered\n-    /// an edge `'a -> 'b`) to find all paths from `from_region` to\n-    /// `to_region`. The paths are accumulated into the vector\n-    /// `results`. The paths are stored as a series of\n-    /// `ConstraintIndex` values -- in other words, a list of *edges*.\n-    ///\n-    /// Returns: a series of constraints as well as the region `R`\n-    /// that passed the target test.\n-    fn find_constraint_paths_between_regions(\n-        &self,\n-        from_region: RegionVid,\n-        target_test: impl Fn(RegionVid) -> bool,\n-    ) -> Option<(Vec<OutlivesConstraint>, RegionVid)> {\n-        let mut context = IndexVec::from_elem(Trace::NotVisited, &self.definitions);\n-        context[from_region] = Trace::StartRegion;\n-\n-        // Use a deque so that we do a breadth-first search. We will\n-        // stop at the first match, which ought to be the shortest\n-        // path (fewest constraints).\n-        let mut deque = VecDeque::new();\n-        deque.push_back(from_region);\n-\n-        while let Some(r) = deque.pop_front() {\n-            debug!(\n-                \"find_constraint_paths_between_regions: from_region={:?} r={:?} value={}\",\n-                from_region,\n-                r,\n-                self.region_value_str(r),\n-            );\n-\n-            // Check if we reached the region we were looking for. If so,\n-            // we can reconstruct the path that led to it and return it.\n-            if target_test(r) {\n-                let mut result = vec![];\n-                let mut p = r;\n-                loop {\n-                    match context[p] {\n-                        Trace::NotVisited => {\n-                            bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n-                        }\n-\n-                        Trace::FromOutlivesConstraint(c) => {\n-                            result.push(c);\n-                            p = c.sup;\n-                        }\n-\n-                        Trace::StartRegion => {\n-                            result.reverse();\n-                            return Some((result, r));\n-                        }\n+    /// Produces nice borrowck error diagnostics for all the errors collected in `nll_errors`.\n+    pub(in crate::borrow_check) fn report_region_errors(&mut self, nll_errors: RegionErrors<'tcx>) {\n+        // Iterate through all the errors, producing a diagnostic for each one. The diagnostics are\n+        // buffered in the `MirBorrowckCtxt`.\n+\n+        let mut outlives_suggestion = OutlivesSuggestionBuilder::default();\n+\n+        for nll_error in nll_errors.into_iter() {\n+            match nll_error {\n+                RegionErrorKind::TypeTestError { type_test } => {\n+                    // Try to convert the lower-bound region into something named we can print for the user.\n+                    let lower_bound_region = self.to_error_region(type_test.lower_bound);\n+\n+                    let type_test_span = type_test.locations.span(&self.body);\n+\n+                    if let Some(lower_bound_region) = lower_bound_region {\n+                        let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n+                        self.infcx\n+                            .construct_generic_bound_failure(\n+                                region_scope_tree,\n+                                type_test_span,\n+                                None,\n+                                type_test.generic_kind,\n+                                lower_bound_region,\n+                            )\n+                            .buffer(&mut self.errors_buffer);\n+                    } else {\n+                        // FIXME. We should handle this case better. It\n+                        // indicates that we have e.g., some region variable\n+                        // whose value is like `'a+'b` where `'a` and `'b` are\n+                        // distinct unrelated univesal regions that are not\n+                        // known to outlive one another. It'd be nice to have\n+                        // some examples where this arises to decide how best\n+                        // to report it; we could probably handle it by\n+                        // iterating over the universal regions and reporting\n+                        // an error that multiple bounds are required.\n+                        self.infcx\n+                            .tcx\n+                            .sess\n+                            .struct_span_err(\n+                                type_test_span,\n+                                &format!(\"`{}` does not live long enough\", type_test.generic_kind),\n+                            )\n+                            .buffer(&mut self.errors_buffer);\n                     }\n                 }\n-            }\n \n-            // Otherwise, walk over the outgoing constraints and\n-            // enqueue any regions we find, keeping track of how we\n-            // reached them.\n-\n-            // A constraint like `'r: 'x` can come from our constraint\n-            // graph.\n-            let fr_static = self.universal_regions.fr_static;\n-            let outgoing_edges_from_graph =\n-                self.constraint_graph.outgoing_edges(r, &self.constraints, fr_static);\n-\n-            // Always inline this closure because it can be hot.\n-            let mut handle_constraint = #[inline(always)]\n-            |constraint: OutlivesConstraint| {\n-                debug_assert_eq!(constraint.sup, r);\n-                let sub_region = constraint.sub;\n-                if let Trace::NotVisited = context[sub_region] {\n-                    context[sub_region] = Trace::FromOutlivesConstraint(constraint);\n-                    deque.push_back(sub_region);\n+                RegionErrorKind::UnexpectedHiddenRegion {\n+                    opaque_type_def_id,\n+                    hidden_ty,\n+                    member_region,\n+                } => {\n+                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n+                    opaque_types::unexpected_hidden_region_diagnostic(\n+                        self.infcx.tcx,\n+                        Some(region_scope_tree),\n+                        opaque_type_def_id,\n+                        hidden_ty,\n+                        member_region,\n+                    )\n+                    .buffer(&mut self.errors_buffer);\n                 }\n-            };\n \n-            // This loop can be hot.\n-            for constraint in outgoing_edges_from_graph {\n-                handle_constraint(constraint);\n-            }\n+                RegionErrorKind::BoundUniversalRegionError {\n+                    longer_fr,\n+                    fr_origin,\n+                    error_element,\n+                } => {\n+                    let error_region = self.regioncx.region_from_element(longer_fr, error_element);\n+\n+                    // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n+                    let (_, span) = self.regioncx.find_outlives_blame_span(\n+                        &self.body,\n+                        longer_fr,\n+                        fr_origin,\n+                        error_region,\n+                    );\n+\n+                    // FIXME: improve this error message\n+                    self.infcx\n+                        .tcx\n+                        .sess\n+                        .struct_span_err(span, \"higher-ranked subtype error\")\n+                        .buffer(&mut self.errors_buffer);\n+                }\n \n-            // Member constraints can also give rise to `'r: 'x` edges that\n-            // were not part of the graph initially, so watch out for those.\n-            // (But they are extremely rare; this loop is very cold.)\n-            for constraint in self.applied_member_constraints(r) {\n-                let p_c = &self.member_constraints[constraint.member_constraint_index];\n-                let constraint = OutlivesConstraint {\n-                    sup: r,\n-                    sub: constraint.min_choice,\n-                    locations: Locations::All(p_c.definition_span),\n-                    category: ConstraintCategory::OpaqueType,\n-                };\n-                handle_constraint(constraint);\n+                RegionErrorKind::RegionError { fr_origin, longer_fr, shorter_fr, is_reported } => {\n+                    if is_reported {\n+                        self.report_region_error(\n+                            longer_fr,\n+                            fr_origin,\n+                            shorter_fr,\n+                            &mut outlives_suggestion,\n+                        );\n+                    } else {\n+                        // We only report the first error, so as not to overwhelm the user. See\n+                        // `RegRegionErrorKind` docs.\n+                        //\n+                        // FIXME: currently we do nothing with these, but perhaps we can do better?\n+                        // FIXME: try collecting these constraints on the outlives suggestion\n+                        // builder. Does it make the suggestions any better?\n+                        debug!(\n+                            \"Unreported region error: can't prove that {:?}: {:?}\",\n+                            longer_fr, shorter_fr\n+                        );\n+                    }\n+                }\n             }\n         }\n \n-        None\n+        // Emit one outlives suggestions for each MIR def we borrowck\n+        outlives_suggestion.add_suggestion(self);\n     }\n \n     /// Report an error because the universal region `fr` was required to outlive\n@@ -429,38 +269,38 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     ///\n     /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n-    pub(in crate::borrow_check) fn report_error<'a>(\n-        &'a self,\n-        mbcx: &MirBorrowckCtxt<'a, 'tcx>,\n+    pub(in crate::borrow_check) fn report_region_error(\n+        &mut self,\n         fr: RegionVid,\n         fr_origin: NLLRegionVariableOrigin,\n         outlived_fr: RegionVid,\n         outlives_suggestion: &mut OutlivesSuggestionBuilder,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'a> {\n-        debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n+    ) {\n+        debug!(\"report_region_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, _, span) = self.best_blame_constraint(&mbcx.body, fr, fr_origin, |r| {\n-            self.provides_universal_region(r, fr, outlived_fr)\n-        });\n+        let (category, _, span) =\n+            self.regioncx.best_blame_constraint(&self.body, fr, fr_origin, |r| {\n+                self.regioncx.provides_universal_region(r, fr, outlived_fr)\n+            });\n \n-        debug!(\"report_error: category={:?} {:?}\", category, span);\n+        debug!(\"report_region_error: category={:?} {:?}\", category, span);\n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n-            let tables = mbcx.infcx.tcx.typeck_tables_of(mbcx.mir_def_id);\n-            let nice = NiceRegionError::new_from_span(mbcx.infcx, span, o, f, Some(tables));\n+            let tables = self.infcx.tcx.typeck_tables_of(self.mir_def_id);\n+            let nice = NiceRegionError::new_from_span(self.infcx, span, o, f, Some(tables));\n             if let Some(diag) = nice.try_report_from_nll() {\n-                return diag;\n+                diag.buffer(&mut self.errors_buffer);\n+                return;\n             }\n         }\n \n         let (fr_is_local, outlived_fr_is_local): (bool, bool) = (\n-            self.universal_regions.is_local_free_region(fr),\n-            self.universal_regions.is_local_free_region(outlived_fr),\n+            self.regioncx.universal_regions().is_local_free_region(fr),\n+            self.regioncx.universal_regions().is_local_free_region(outlived_fr),\n         );\n \n         debug!(\n-            \"report_error: fr_is_local={:?} outlived_fr_is_local={:?} category={:?}\",\n+            \"report_region_error: fr_is_local={:?} outlived_fr_is_local={:?} category={:?}\",\n             fr_is_local, outlived_fr_is_local, category\n         );\n \n@@ -473,52 +313,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             span,\n         };\n \n-        match (category, fr_is_local, outlived_fr_is_local) {\n-            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(mbcx.infcx, fr) => {\n-                self.report_fnmut_error(mbcx, &errci, renctx)\n+        let diag = match (category, fr_is_local, outlived_fr_is_local) {\n+            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(fr) => {\n+                self.report_fnmut_error(&errci)\n             }\n             (ConstraintCategory::Assignment, true, false)\n             | (ConstraintCategory::CallArgument, true, false) => {\n-                let mut db = self.report_escaping_data_error(mbcx, &errci, renctx);\n+                let mut db = self.report_escaping_data_error(&errci);\n \n-                outlives_suggestion.intermediate_suggestion(mbcx, &errci, renctx, &mut db);\n+                outlives_suggestion.intermediate_suggestion(self, &errci, &mut db);\n                 outlives_suggestion.collect_constraint(fr, outlived_fr);\n \n                 db\n             }\n             _ => {\n-                let mut db = self.report_general_error(mbcx, &errci, renctx);\n+                let mut db = self.report_general_error(&errci);\n \n-                outlives_suggestion.intermediate_suggestion(mbcx, &errci, renctx, &mut db);\n+                outlives_suggestion.intermediate_suggestion(self, &errci, &mut db);\n                 outlives_suggestion.collect_constraint(fr, outlived_fr);\n \n                 db\n             }\n-        }\n-    }\n-\n-    /// We have a constraint `fr1: fr2` that is not satisfied, where\n-    /// `fr2` represents some universal region. Here, `r` is some\n-    /// region where we know that `fr1: r` and this function has the\n-    /// job of determining whether `r` is \"to blame\" for the fact that\n-    /// `fr1: fr2` is required.\n-    ///\n-    /// This is true under two conditions:\n-    ///\n-    /// - `r == fr2`\n-    /// - `fr2` is `'static` and `r` is some placeholder in a universe\n-    ///   that cannot be named by `fr1`; in that case, we will require\n-    ///   that `fr1: 'static` because it is the only way to `fr1: r` to\n-    ///   be satisfied. (See `add_incompatible_universe`.)\n-    fn provides_universal_region(&self, r: RegionVid, fr1: RegionVid, fr2: RegionVid) -> bool {\n-        debug!(\"provides_universal_region(r={:?}, fr1={:?}, fr2={:?})\", r, fr1, fr2);\n-        let result = {\n-            r == fr2 || {\n-                fr2 == self.universal_regions.fr_static && self.cannot_name_placeholder(fr1, r)\n-            }\n         };\n-        debug!(\"provides_universal_region: result = {:?}\", result);\n-        result\n+\n+        diag.buffer(&mut self.errors_buffer);\n     }\n \n     /// Report a specialized error when `FnMut` closures return a reference to a captured variable.\n@@ -537,23 +355,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///            executing...\n     ///    = note: ...therefore, returned references to captured variables will escape the closure\n     /// ```\n-    fn report_fnmut_error(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        errci: &ErrorConstraintInfo,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'_> {\n+    fn report_fnmut_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n-        let mut diag = mbcx\n+        let mut diag = self\n             .infcx\n             .tcx\n             .sess\n             .struct_span_err(*span, \"captured variable cannot escape `FnMut` closure body\");\n \n         // We should check if the return type of this closure is in fact a closure - in that\n         // case, we can special case the error further.\n-        let return_type_is_closure = self.universal_regions.unnormalized_output_ty.is_closure();\n+        let return_type_is_closure =\n+            self.regioncx.universal_regions().unnormalized_output_ty.is_closure();\n         let message = if return_type_is_closure {\n             \"returns a closure that contains a reference to a captured variable, which then \\\n              escapes the closure body\"\n@@ -563,7 +377,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         diag.span_label(*span, message);\n \n-        match self.give_region_a_name(mbcx, renctx, *outlived_fr).unwrap().source {\n+        match self.give_region_a_name(*outlived_fr).unwrap().source {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n@@ -598,30 +412,25 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// LL |     ref_obj(x)\n     ///    |     ^^^^^^^^^^ `x` escapes the function body here\n     /// ```\n-    fn report_escaping_data_error(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        errci: &ErrorConstraintInfo,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'_> {\n+    fn report_escaping_data_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo { span, category, .. } = errci;\n \n-        let fr_name_and_span = self.get_var_name_and_span_for_region(\n-            mbcx.infcx.tcx,\n-            &mbcx.body,\n-            &mbcx.local_names,\n-            &mbcx.upvars,\n+        let fr_name_and_span = self.regioncx.get_var_name_and_span_for_region(\n+            self.infcx.tcx,\n+            &self.body,\n+            &self.local_names,\n+            &self.upvars,\n             errci.fr,\n         );\n-        let outlived_fr_name_and_span = self.get_var_name_and_span_for_region(\n-            mbcx.infcx.tcx,\n-            &mbcx.body,\n-            &mbcx.local_names,\n-            &mbcx.upvars,\n+        let outlived_fr_name_and_span = self.regioncx.get_var_name_and_span_for_region(\n+            self.infcx.tcx,\n+            &self.body,\n+            &self.local_names,\n+            &self.upvars,\n             errci.outlived_fr,\n         );\n \n-        let escapes_from = match self.universal_regions.defining_ty {\n+        let escapes_from = match self.regioncx.universal_regions().defining_ty {\n             DefiningTy::Closure(..) => \"closure\",\n             DefiningTy::Generator(..) => \"generator\",\n             DefiningTy::FnDef(..) => \"function\",\n@@ -634,15 +443,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             || (*category == ConstraintCategory::Assignment && escapes_from == \"function\")\n             || escapes_from == \"const\"\n         {\n-            return self.report_general_error(\n-                mbcx,\n-                &ErrorConstraintInfo { fr_is_local: true, outlived_fr_is_local: false, ..*errci },\n-                renctx,\n-            );\n+            return self.report_general_error(&ErrorConstraintInfo {\n+                fr_is_local: true,\n+                outlived_fr_is_local: false,\n+                ..*errci\n+            });\n         }\n \n         let mut diag =\n-            borrowck_errors::borrowed_data_escapes_closure(mbcx.infcx.tcx, *span, escapes_from);\n+            borrowck_errors::borrowed_data_escapes_closure(self.infcx.tcx, *span, escapes_from);\n \n         if let Some((Some(outlived_fr_name), outlived_fr_span)) = outlived_fr_name_and_span {\n             diag.span_label(\n@@ -684,12 +493,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///    |     ^^^^^^^^^^^^^^ function was supposed to return data with lifetime `'a` but it\n     ///    |                    is returning data with lifetime `'b`\n     /// ```\n-    fn report_general_error(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        errci: &ErrorConstraintInfo,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'_> {\n+    fn report_general_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo {\n             fr,\n             fr_is_local,\n@@ -701,14 +505,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         } = errci;\n \n         let mut diag =\n-            mbcx.infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n+            self.infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n \n         let mir_def_name =\n-            if mbcx.infcx.tcx.is_closure(mbcx.mir_def_id) { \"closure\" } else { \"function\" };\n+            if self.infcx.tcx.is_closure(self.mir_def_id) { \"closure\" } else { \"function\" };\n \n-        let fr_name = self.give_region_a_name(mbcx, renctx, *fr).unwrap();\n+        let fr_name = self.give_region_a_name(*fr).unwrap();\n         fr_name.highlight_region_name(&mut diag);\n-        let outlived_fr_name = self.give_region_a_name(mbcx, renctx, *outlived_fr).unwrap();\n+        let outlived_fr_name = self.give_region_a_name(*outlived_fr).unwrap();\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n         match (category, outlived_fr_is_local, fr_is_local) {\n@@ -735,7 +539,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        self.add_static_impl_trait_suggestion(mbcx.infcx, &mut diag, *fr, fr_name, *outlived_fr);\n+        self.add_static_impl_trait_suggestion(&mut diag, *fr, fr_name, *outlived_fr);\n \n         diag\n     }\n@@ -751,8 +555,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn add_static_impl_trait_suggestion(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        diag: &mut DiagnosticBuilder<'_>,\n+        diag: &mut DiagnosticBuilder<'tcx>,\n         fr: RegionVid,\n         // We need to pass `fr_name` - computing it again will label it twice.\n         fr_name: RegionName,\n@@ -761,20 +564,21 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         if let (Some(f), Some(ty::RegionKind::ReStatic)) =\n             (self.to_error_region(fr), self.to_error_region(outlived_fr))\n         {\n-            if let Some((ty::TyS { kind: ty::Opaque(did, substs), .. }, _)) = infcx\n+            if let Some((ty::TyS { kind: ty::Opaque(did, substs), .. }, _)) = self\n+                .infcx\n                 .tcx\n                 .is_suitable_region(f)\n                 .map(|r| r.def_id)\n-                .map(|id| infcx.tcx.return_type_impl_trait(id))\n+                .map(|id| self.infcx.tcx.return_type_impl_trait(id))\n                 .unwrap_or(None)\n             {\n                 // Check whether or not the impl trait return type is intended to capture\n                 // data with the static lifetime.\n                 //\n                 // eg. check for `impl Trait + 'static` instead of `impl Trait`.\n                 let has_static_predicate = {\n-                    let predicates_of = infcx.tcx.predicates_of(*did);\n-                    let bounds = predicates_of.instantiate(infcx.tcx, substs);\n+                    let predicates_of = self.infcx.tcx.predicates_of(*did);\n+                    let bounds = predicates_of.instantiate(self.infcx.tcx, substs);\n \n                     let mut found = false;\n                     for predicate in bounds.predicates {\n@@ -802,8 +606,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     diag.help(&format!(\"consider replacing `{}` with `{}`\", fr_name, static_str));\n                 } else {\n                     // Otherwise, we should suggest adding a constraint on the return type.\n-                    let span = infcx.tcx.def_span(*did);\n-                    if let Ok(snippet) = infcx.tcx.sess.source_map().span_to_snippet(span) {\n+                    let span = self.infcx.tcx.def_span(*did);\n+                    if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         let suggestable_fr_name = if fr_name.was_named() {\n                             fr_name.to_string()\n                         } else {\n@@ -830,130 +634,4 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n     }\n-\n-    crate fn free_region_constraint_info(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        borrow_region: RegionVid,\n-        outlived_region: RegionVid,\n-    ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n-        let (category, from_closure, span) = self.best_blame_constraint(\n-            &mbcx.body,\n-            borrow_region,\n-            NLLRegionVariableOrigin::FreeRegion,\n-            |r| self.provides_universal_region(r, borrow_region, outlived_region),\n-        );\n-\n-        let mut renctx = RegionErrorNamingCtx::new();\n-        let outlived_fr_name = self.give_region_a_name(mbcx, &mut renctx, outlived_region);\n-\n-        (category, from_closure, span, outlived_fr_name)\n-    }\n-\n-    // Finds some region R such that `fr1: R` and `R` is live at\n-    // `elem`.\n-    crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n-        debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n-        self.find_constraint_paths_between_regions(fr1, |r| {\n-            // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n-            debug!(\n-                \"find_sub_region_live_at: liveness_constraints for {:?} are {:?}\",\n-                r,\n-                self.liveness_constraints.region_value_str(r),\n-            );\n-            self.liveness_constraints.contains(r, elem)\n-        })\n-        .or_else(|| {\n-            // If we fail to find that, we may find some `r` such that\n-            // `fr1: r` and `r` is a placeholder from some universe\n-            // `fr1` cannot name. This would force `fr1` to be\n-            // `'static`.\n-            self.find_constraint_paths_between_regions(fr1, |r| {\n-                self.cannot_name_placeholder(fr1, r)\n-            })\n-        })\n-        .or_else(|| {\n-            // If we fail to find THAT, it may be that `fr1` is a\n-            // placeholder that cannot \"fit\" into its SCC. In that\n-            // case, there should be some `r` where `fr1: r`, both\n-            // `fr1` and `r` are in the same SCC, and `fr1` is a\n-            // placeholder that `r` cannot name. We can blame that\n-            // edge.\n-            self.find_constraint_paths_between_regions(fr1, |r| {\n-                self.constraint_sccs.scc(fr1) == self.constraint_sccs.scc(r)\n-                    && self.cannot_name_placeholder(r, fr1)\n-            })\n-        })\n-        .map(|(_path, r)| r)\n-        .unwrap()\n-    }\n-\n-    // Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n-    crate fn find_outlives_blame_span(\n-        &self,\n-        body: &Body<'tcx>,\n-        fr1: RegionVid,\n-        fr1_origin: NLLRegionVariableOrigin,\n-        fr2: RegionVid,\n-    ) -> (ConstraintCategory, Span) {\n-        let (category, _, span) = self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n-            self.provides_universal_region(r, fr1, fr2)\n-        });\n-        (category, span)\n-    }\n-\n-    fn retrieve_closure_constraint_info(\n-        &self,\n-        body: &Body<'tcx>,\n-        constraint: &OutlivesConstraint,\n-    ) -> (ConstraintCategory, bool, Span) {\n-        let loc = match constraint.locations {\n-            Locations::All(span) => return (constraint.category, false, span),\n-            Locations::Single(loc) => loc,\n-        };\n-\n-        let opt_span_category =\n-            self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub));\n-        opt_span_category.map(|&(category, span)| (category, true, span)).unwrap_or((\n-            constraint.category,\n-            false,\n-            body.source_info(loc).span,\n-        ))\n-    }\n-\n-    /// Returns `true` if a closure is inferred to be an `FnMut` closure.\n-    crate fn is_closure_fn_mut(&self, infcx: &InferCtxt<'_, 'tcx>, fr: RegionVid) -> bool {\n-        if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n-            if let ty::BoundRegion::BrEnv = free_region.bound_region {\n-                if let DefiningTy::Closure(def_id, substs) = self.universal_regions.defining_ty {\n-                    let closure_kind_ty = substs.as_closure().kind_ty(def_id, infcx.tcx);\n-                    return Some(ty::ClosureKind::FnMut) == closure_kind_ty.to_opt_closure_kind();\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n-\n-    /// If `r2` represents a placeholder region, then this returns\n-    /// `true` if `r1` cannot name that placeholder in its\n-    /// value; otherwise, returns `false`.\n-    fn cannot_name_placeholder(&self, r1: RegionVid, r2: RegionVid) -> bool {\n-        debug!(\"cannot_name_value_of(r1={:?}, r2={:?})\", r1, r2);\n-\n-        match self.definitions[r2].origin {\n-            NLLRegionVariableOrigin::Placeholder(placeholder) => {\n-                let universe1 = self.definitions[r1].universe;\n-                debug!(\n-                    \"cannot_name_value_of: universe1={:?} placeholder={:?}\",\n-                    universe1, placeholder\n-                );\n-                universe1.cannot_name(placeholder.universe)\n-            }\n-\n-            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential { .. } => {\n-                false\n-            }\n-        }\n-    }\n }"}, {"sha": "47eb2d8940af402c9c0959fffb678e70d902167a", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 81, "deletions": 148, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -2,18 +2,14 @@ use std::fmt::{self, Display};\n \n use rustc::ty::print::RegionHighlightMode;\n use rustc::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc::ty::{self, RegionVid, Ty};\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_span::symbol::kw;\n use rustc_span::{symbol::Symbol, Span, DUMMY_SP};\n \n-use crate::borrow_check::{\n-    nll::ToRegionVid, region_infer::RegionInferenceContext, universal_regions::DefiningTy,\n-    MirBorrowckCtxt,\n-};\n+use crate::borrow_check::{nll::ToRegionVid, universal_regions::DefiningTy, MirBorrowckCtxt};\n \n /// A name for a particular region used in emitting diagnostics. This name could be a generated\n /// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n@@ -55,46 +51,6 @@ crate enum RegionNameSource {\n     AnonRegionFromAsyncFn(Span),\n }\n \n-/// Records region names that have been assigned before so that we can use the same ones in later\n-/// diagnostics.\n-#[derive(Debug, Clone)]\n-crate struct RegionErrorNamingCtx {\n-    /// Record the region names generated for each region in the given\n-    /// MIR def so that we can reuse them later in help/error messages.\n-    renctx: FxHashMap<RegionVid, RegionName>,\n-\n-    /// The counter for generating new region names.\n-    counter: usize,\n-}\n-\n-impl RegionErrorNamingCtx {\n-    crate fn new() -> Self {\n-        Self { counter: 1, renctx: FxHashMap::default() }\n-    }\n-\n-    /// Get the name of `region` if it has previously been named.\n-    crate fn get(&self, region: &RegionVid) -> Option<&RegionName> {\n-        self.renctx.get(region)\n-    }\n-\n-    /// Give `region` the name `name`.\n-    crate fn insert(&mut self, region: RegionVid, name: RegionName) {\n-        self.renctx.insert(region, name);\n-    }\n-\n-    /// Creates a synthetic region named `'N`, where `N` is the next value of the counter. Then,\n-    /// increment the counter.\n-    ///\n-    /// The name is not memoized. A separate call to `insert` should be made later. (Currently,\n-    /// this happens at the end of `give_region_a_name`).\n-    crate fn synthesize_region_name(&mut self) -> Symbol {\n-        let c = self.counter;\n-        self.counter += 1;\n-\n-        Symbol::intern(&format!(\"'{:?}\", c))\n-    }\n-}\n-\n impl RegionName {\n     crate fn was_named(&self) -> bool {\n         match self.source {\n@@ -161,7 +117,16 @@ impl Display for RegionName {\n     }\n }\n \n-impl<'tcx> RegionInferenceContext<'tcx> {\n+impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n+    /// Generate a synthetic region named `'N`, where `N` is the next value of the counter. Then,\n+    /// increment the counter.\n+    ///\n+    /// This is _not_ idempotent. Call `give_region_a_name` when possible.\n+    fn synthesize_region_name(&self) -> Symbol {\n+        let c = self.next_region_name.replace_with(|counter| *counter + 1);\n+        Symbol::intern(&format!(\"'{:?}\", c))\n+    }\n+\n     /// Maps from an internal MIR region vid to something that we can\n     /// report to the user. In some cases, the region vids will map\n     /// directly to lifetimes that the user has a name for (e.g.,\n@@ -170,6 +135,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// that end, this function takes a \"diagnostic\" so that it can\n     /// create auxiliary notes as needed.\n     ///\n+    /// The names are memoized, so this is both cheap to recompute and idempotent.\n+    ///\n     /// Example (function arguments):\n     ///\n     /// Suppose we are trying to give a name to the lifetime of the\n@@ -187,29 +154,28 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     ///\n     /// and then return the name `'1` for us to use.\n-    crate fn give_region_a_name(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        renctx: &mut RegionErrorNamingCtx,\n-        fr: RegionVid,\n-    ) -> Option<RegionName> {\n-        debug!(\"give_region_a_name(fr={:?}, counter={:?})\", fr, renctx.counter);\n+    crate fn give_region_a_name(&self, fr: RegionVid) -> Option<RegionName> {\n+        debug!(\n+            \"give_region_a_name(fr={:?}, counter={:?})\",\n+            fr,\n+            self.next_region_name.try_borrow().unwrap()\n+        );\n \n-        assert!(self.universal_regions.is_universal_region(fr));\n+        assert!(self.regioncx.universal_regions().is_universal_region(fr));\n \n-        if let Some(value) = renctx.get(&fr) {\n+        if let Some(value) = self.region_names.try_borrow_mut().unwrap().get(&fr) {\n             return Some(value.clone());\n         }\n \n         let value = self\n-            .give_name_from_error_region(mbcx, fr, renctx)\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_arguments(mbcx, fr, renctx))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_upvars(mbcx, fr, renctx))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_output(mbcx, fr, renctx))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_yield_ty(mbcx, fr, renctx));\n+            .give_name_from_error_region(fr)\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_arguments(fr))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_upvars(fr))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_output(fr))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_yield_ty(fr));\n \n         if let Some(ref value) = value {\n-            renctx.insert(fr, value.clone());\n+            self.region_names.try_borrow_mut().unwrap().insert(fr, value.clone());\n         }\n \n         debug!(\"give_region_a_name: gave name {:?}\", value);\n@@ -220,15 +186,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// *user* has a name for. In that case, we'll be able to map\n     /// `fr` to a `Region<'tcx>`, and that region will be one of\n     /// named variants.\n-    fn give_name_from_error_region(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> Option<RegionName> {\n+    fn give_name_from_error_region(&self, fr: RegionVid) -> Option<RegionName> {\n         let error_region = self.to_error_region(fr)?;\n \n-        let tcx = mbcx.infcx.tcx;\n+        let tcx = self.infcx.tcx;\n \n         debug!(\"give_region_a_name: error_region = {:?}\", error_region);\n         match error_region {\n@@ -267,7 +228,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         // happen if we have an elided name in an async fn for example: the\n                         // compiler will generate a region named `'_`, but reporting such a name is\n                         // not actually useful, so we synthesize a name for it instead.\n-                        let name = renctx.synthesize_region_name();\n+                        let name = self.synthesize_region_name();\n                         Some(RegionName {\n                             name,\n                             source: RegionNameSource::AnonRegionFromAsyncFn(span),\n@@ -276,13 +237,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id = mbcx\n+                    let mir_hir_id = self\n                         .infcx\n                         .tcx\n                         .hir()\n-                        .as_local_hir_id(mbcx.mir_def_id)\n+                        .as_local_hir_id(self.mir_def_id)\n                         .expect(\"non-local mir\");\n-                    let def_ty = self.universal_regions.defining_ty;\n+                    let def_ty = self.regioncx.universal_regions().defining_ty;\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n                         let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n@@ -292,7 +253,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         } else {\n                             bug!(\"Closure is not defined by a closure expr\");\n                         };\n-                        let region_name = renctx.synthesize_region_name();\n+                        let region_name = self.synthesize_region_name();\n \n                         let closure_kind_ty = substs.as_closure().kind_ty(def_id, tcx);\n                         let note = match closure_kind_ty.to_opt_closure_kind() {\n@@ -346,38 +307,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_anonymous_region_appears_in_arguments(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n-        let argument_index = self.get_argument_index_for_region(mbcx.infcx.tcx, fr)?;\n-\n-        let arg_ty =\n-            self.universal_regions.unnormalized_input_tys[implicit_inputs + argument_index];\n-        if let Some(region_name) = self.give_name_if_we_can_match_hir_ty_from_argument(\n-            mbcx,\n-            fr,\n-            arg_ty,\n-            argument_index,\n-            renctx,\n-        ) {\n+        let implicit_inputs = self.regioncx.universal_regions().defining_ty.implicit_inputs();\n+        let argument_index = self.regioncx.get_argument_index_for_region(self.infcx.tcx, fr)?;\n+\n+        let arg_ty = self.regioncx.universal_regions().unnormalized_input_tys\n+            [implicit_inputs + argument_index];\n+        if let Some(region_name) =\n+            self.give_name_if_we_can_match_hir_ty_from_argument(fr, arg_ty, argument_index)\n+        {\n             return Some(region_name);\n         }\n \n-        self.give_name_if_we_cannot_match_hir_ty(mbcx, fr, arg_ty, renctx)\n+        self.give_name_if_we_cannot_match_hir_ty(fr, arg_ty)\n     }\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let mir_hir_id = mbcx.infcx.tcx.hir().as_local_hir_id(mbcx.mir_def_id)?;\n-        let fn_decl = mbcx.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n+        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id)?;\n+        let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n             // This indicates a variable with no type annotation, like\n@@ -387,13 +340,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // (`give_name_if_anonymous_region_appears_in_arguments`).\n             hir::TyKind::Infer => None,\n \n-            _ => self.give_name_if_we_can_match_hir_ty(\n-                mbcx.infcx.tcx,\n-                needle_fr,\n-                argument_ty,\n-                argument_hir_ty,\n-                renctx,\n-            ),\n+            _ => self.give_name_if_we_can_match_hir_ty(needle_fr, argument_ty, argument_hir_ty),\n         }\n     }\n \n@@ -410,34 +357,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_we_cannot_match_hir_ty(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let counter = renctx.counter;\n+        let counter = *self.next_region_name.try_borrow().unwrap();\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, counter);\n-        let type_name = mbcx.infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n+        let type_name = self.infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n \n         debug!(\n             \"give_name_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n             type_name, needle_fr\n         );\n         let assigned_region_name = if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n-            let argument_index = self.get_argument_index_for_region(mbcx.infcx.tcx, needle_fr)?;\n-            let (_, span) = self.get_argument_name_and_span_for_region(\n-                &mbcx.body,\n-                &mbcx.local_names,\n+            let argument_index =\n+                self.regioncx.get_argument_index_for_region(self.infcx.tcx, needle_fr)?;\n+            let (_, span) = self.regioncx.get_argument_name_and_span_for_region(\n+                &self.body,\n+                &self.local_names,\n                 argument_index,\n             );\n \n             Some(RegionName {\n                 // This counter value will already have been used, so this function will increment\n                 // it so the next value will be used next and return the region name that would\n                 // have been used.\n-                name: renctx.synthesize_region_name(),\n+                name: self.synthesize_region_name(),\n                 source: RegionNameSource::CannotMatchHirTy(span, type_name),\n             })\n         } else {\n@@ -470,11 +416,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// to highlighting that closest type instead.\n     fn give_name_if_we_can_match_hir_ty(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_hir_ty: &hir::Ty<'_>,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty<'_>)> =\n             &mut vec![(argument_ty, argument_hir_ty)];\n@@ -492,10 +436,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     hir::TyKind::Rptr(_lifetime, referent_hir_ty),\n                 ) => {\n                     if region.to_region_vid() == needle_fr {\n-                        let region_name = renctx.synthesize_region_name();\n+                        let region_name = self.synthesize_region_name();\n \n                         // Just grab the first character, the `&`.\n-                        let source_map = tcx.sess.source_map();\n+                        let source_map = self.infcx.tcx.sess.source_map();\n                         let ampersand_span = source_map.start_point(hir_ty.span);\n \n                         return Some(RegionName {\n@@ -525,7 +469,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                                     substs,\n                                     needle_fr,\n                                     last_segment,\n-                                    renctx,\n                                     search_stack,\n                                 ) {\n                                     return Some(name);\n@@ -570,7 +513,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         substs: SubstsRef<'tcx>,\n         needle_fr: RegionVid,\n         last_segment: &'hir hir::PathSegment<'hir>,\n-        renctx: &mut RegionErrorNamingCtx,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty<'hir>)>,\n     ) -> Option<RegionName> {\n         // Did the user give explicit arguments? (e.g., `Foo<..>`)\n@@ -582,7 +524,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             | hir::LifetimeName::Error\n             | hir::LifetimeName::Static\n             | hir::LifetimeName::Underscore => {\n-                let region_name = renctx.synthesize_region_name();\n+                let region_name = self.synthesize_region_name();\n                 let ampersand_span = lifetime.span;\n                 Some(RegionName {\n                     name: region_name,\n@@ -663,16 +605,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///  | let x = Some(&22);\n     ///        - fully elaborated type of `x` is `Option<&'1 u32>`\n     /// ```\n-    fn give_name_if_anonymous_region_appears_in_upvars(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> Option<RegionName> {\n-        let upvar_index = self.get_upvar_index_for_region(mbcx.infcx.tcx, fr)?;\n-        let (upvar_name, upvar_span) =\n-            self.get_upvar_name_and_span_for_region(mbcx.infcx.tcx, &mbcx.upvars, upvar_index);\n-        let region_name = renctx.synthesize_region_name();\n+    fn give_name_if_anonymous_region_appears_in_upvars(&self, fr: RegionVid) -> Option<RegionName> {\n+        let upvar_index = self.regioncx.get_upvar_index_for_region(self.infcx.tcx, fr)?;\n+        let (upvar_name, upvar_span) = self.regioncx.get_upvar_name_and_span_for_region(\n+            self.infcx.tcx,\n+            &self.upvars,\n+            upvar_index,\n+        );\n+        let region_name = self.synthesize_region_name();\n \n         Some(RegionName {\n             name: region_name,\n@@ -684,25 +624,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// must be a closure since, in a free fn, such an argument would\n     /// have to either also appear in an argument (if using elision)\n     /// or be early bound (named, not in argument).\n-    fn give_name_if_anonymous_region_appears_in_output(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> Option<RegionName> {\n-        let tcx = mbcx.infcx.tcx;\n+    fn give_name_if_anonymous_region_appears_in_output(&self, fr: RegionVid) -> Option<RegionName> {\n+        let tcx = self.infcx.tcx;\n \n-        let return_ty = self.universal_regions.unnormalized_output_ty;\n+        let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n         debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n         if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n             return None;\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, renctx.counter);\n-        let type_name = mbcx.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n+        highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n+        let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(mbcx.mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id).expect(\"non-local mir\");\n \n         let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n@@ -719,14 +654,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 kind: hir::ImplItemKind::Method(method_sig, _),\n                 ..\n             }) => (method_sig.decl.output.span(), \"\"),\n-            _ => (mbcx.body.span, \"\"),\n+            _ => (self.body.span, \"\"),\n         };\n \n         Some(RegionName {\n             // This counter value will already have been used, so this function will increment it\n             // so the next value will be used next and return the region name that would have been\n             // used.\n-            name: renctx.synthesize_region_name(),\n+            name: self.synthesize_region_name(),\n             source: RegionNameSource::AnonRegionFromOutput(\n                 return_span,\n                 mir_description.to_string(),\n@@ -737,32 +672,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn give_name_if_anonymous_region_appears_in_yield_ty(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         // Note: generators from `async fn` yield `()`, so we don't have to\n         // worry about them here.\n-        let yield_ty = self.universal_regions.yield_ty?;\n+        let yield_ty = self.regioncx.universal_regions().yield_ty?;\n         debug!(\"give_name_if_anonymous_region_appears_in_yield_ty: yield_ty = {:?}\", yield_ty,);\n \n-        let tcx = mbcx.infcx.tcx;\n+        let tcx = self.infcx.tcx;\n \n         if !tcx.any_free_region_meets(&yield_ty, |r| r.to_region_vid() == fr) {\n             return None;\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, renctx.counter);\n-        let type_name = mbcx.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n+        highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n+        let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(mbcx.mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id).expect(\"non-local mir\");\n \n         let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n                 kind: hir::ExprKind::Closure(_, _, _, span, _), ..\n             }) => (tcx.sess.source_map().end_point(*span)),\n-            _ => mbcx.body.span,\n+            _ => self.body.span,\n         };\n \n         debug!(\n@@ -772,7 +705,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         Some(RegionName {\n-            name: renctx.synthesize_region_name(),\n+            name: self.synthesize_region_name(),\n             source: RegionNameSource::AnonRegionFromYieldTy(yield_span, type_name),\n         })\n     }"}, {"sha": "5f3585ce8b119927ce127559f86994da3963d049", "filename": "src/librustc_mir/borrow_check/diagnostics/var_name.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -16,7 +16,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n         debug!(\"get_var_name_and_span_for_region(fr={:?})\", fr);\n-        assert!(self.universal_regions.is_universal_region(fr));\n+        assert!(self.universal_regions().is_universal_region(fr));\n \n         debug!(\"get_var_name_and_span_for_region: attempting upvar\");\n         self.get_upvar_index_for_region(tcx, fr)\n@@ -35,7 +35,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Search the upvars (if any) to find one that references fr. Return its index.\n     crate fn get_upvar_index_for_region(&self, tcx: TyCtxt<'tcx>, fr: RegionVid) -> Option<usize> {\n         let upvar_index =\n-            self.universal_regions.defining_ty.upvar_tys(tcx).position(|upvar_ty| {\n+            self.universal_regions().defining_ty.upvar_tys(tcx).position(|upvar_ty| {\n                 debug!(\"get_upvar_index_for_region: upvar_ty={:?}\", upvar_ty);\n                 tcx.any_free_region_meets(&upvar_ty, |r| {\n                     let r = r.to_region_vid();\n@@ -44,7 +44,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 })\n             })?;\n \n-        let upvar_ty = self.universal_regions.defining_ty.upvar_tys(tcx).nth(upvar_index);\n+        let upvar_ty = self.universal_regions().defining_ty.upvar_tys(tcx).nth(upvar_index);\n \n         debug!(\n             \"get_upvar_index_for_region: found {:?} in upvar {} which has type {:?}\",\n@@ -85,9 +85,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         fr: RegionVid,\n     ) -> Option<usize> {\n-        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n+        let implicit_inputs = self.universal_regions().defining_ty.implicit_inputs();\n         let argument_index =\n-            self.universal_regions.unnormalized_input_tys.iter().skip(implicit_inputs).position(\n+            self.universal_regions().unnormalized_input_tys.iter().skip(implicit_inputs).position(\n                 |arg_ty| {\n                     debug!(\"get_argument_index_for_region: arg_ty = {:?}\", arg_ty);\n                     tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n@@ -96,7 +96,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         debug!(\n             \"get_argument_index_for_region: found {:?} in argument {} which has type {:?}\",\n-            fr, argument_index, self.universal_regions.unnormalized_input_tys[argument_index],\n+            fr,\n+            argument_index,\n+            self.universal_regions().unnormalized_input_tys[argument_index],\n         );\n \n         Some(argument_index)\n@@ -110,7 +112,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         local_names: &IndexVec<Local, Option<Symbol>>,\n         argument_index: usize,\n     ) -> (Option<Symbol>, Span) {\n-        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n+        let implicit_inputs = self.universal_regions().defining_ty.implicit_inputs();\n         let argument_local = Local::new(implicit_inputs + argument_index + 1);\n         debug!(\"get_argument_name_and_span_for_region: argument_local={:?}\", argument_local);\n "}, {"sha": "90927069242b19e2cf032b2891558178fc642d28", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 19, "deletions": 125, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -1,6 +1,6 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n-use rustc::infer::{opaque_types, InferCtxt};\n+use rustc::infer::InferCtxt;\n use rustc::lint::builtin::MUTABLE_BORROW_RESERVATION_CONFLICT;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::mir::{\n@@ -11,7 +11,8 @@ use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, RegionVid, TyCtxt};\n+\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder};\n@@ -21,6 +22,7 @@ use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n \n use smallvec::SmallVec;\n+use std::cell::RefCell;\n use std::collections::BTreeMap;\n use std::mem;\n use std::rc::Rc;\n@@ -39,9 +41,7 @@ use crate::dataflow::{do_dataflow, DebugFormatted};\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use crate::transform::MirSource;\n \n-use self::diagnostics::{\n-    AccessKind, OutlivesSuggestionBuilder, RegionErrorKind, RegionErrorNamingCtx, RegionErrors,\n-};\n+use self::diagnostics::{AccessKind, RegionName};\n use self::flows::Flows;\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n@@ -285,13 +285,15 @@ fn do_mir_borrowck<'a, 'tcx>(\n         move_error_reported: BTreeMap::new(),\n         uninitialized_error_reported: Default::default(),\n         errors_buffer,\n-        nonlexical_regioncx: regioncx,\n+        regioncx,\n         used_mut: Default::default(),\n         used_mut_upvars: SmallVec::new(),\n         borrow_set,\n         dominators,\n         upvars,\n         local_names,\n+        region_names: RefCell::default(),\n+        next_region_name: RefCell::new(1),\n     };\n \n     // Compute and report region errors, if any.\n@@ -476,10 +478,9 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     /// If the function we're checking is a closure, then we'll need to report back the list of\n     /// mutable upvars that have been used. This field keeps track of them.\n     used_mut_upvars: SmallVec<[Field; 8]>,\n-    /// Non-lexical region inference context, if NLL is enabled. This\n-    /// contains the results from region inference and lets us e.g.\n+    /// Region inference context. This contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n-    nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n+    regioncx: Rc<RegionInferenceContext<'tcx>>,\n \n     /// The set of borrows extracted from the MIR\n     borrow_set: Rc<BorrowSet<'tcx>>,\n@@ -492,6 +493,13 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Names of local (user) variables (extracted from `var_debug_info`).\n     local_names: IndexVec<Local, Option<Name>>,\n+\n+    /// Record the region names generated for each region in the given\n+    /// MIR def so that we can reuse them later in help/error messages.\n+    region_names: RefCell<FxHashMap<RegionVid, RegionName>>,\n+\n+    /// The counter for generating new region names.\n+    next_region_name: RefCell<usize>,\n }\n \n // Check that:\n@@ -631,7 +639,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n \n                 debug!(\n                     \"visit_terminator_drop \\\n-                        loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\",\n+                     loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\",\n                     loc, term, drop_place, drop_place_ty, span\n                 );\n \n@@ -1465,120 +1473,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // initial reservation.\n         }\n     }\n-\n-    /// Produces nice borrowck error diagnostics for all the errors collected in `nll_errors`.\n-    fn report_region_errors(&mut self, nll_errors: RegionErrors<'tcx>) {\n-        // Iterate through all the errors, producing a diagnostic for each one. The diagnostics are\n-        // buffered in the `MirBorrowckCtxt`.\n-\n-        // FIXME(mark-i-m): Would be great to get rid of the naming context.\n-        let mut region_naming = RegionErrorNamingCtx::new();\n-        let mut outlives_suggestion = OutlivesSuggestionBuilder::default();\n-\n-        for nll_error in nll_errors.into_iter() {\n-            match nll_error {\n-                RegionErrorKind::TypeTestDoesNotLiveLongEnough { span, generic } => {\n-                    // FIXME. We should handle this case better. It\n-                    // indicates that we have e.g., some region variable\n-                    // whose value is like `'a+'b` where `'a` and `'b` are\n-                    // distinct unrelated univesal regions that are not\n-                    // known to outlive one another. It'd be nice to have\n-                    // some examples where this arises to decide how best\n-                    // to report it; we could probably handle it by\n-                    // iterating over the universal regions and reporting\n-                    // an error that multiple bounds are required.\n-                    self.infcx\n-                        .tcx\n-                        .sess\n-                        .struct_span_err(span, &format!(\"`{}` does not live long enough\", generic))\n-                        .buffer(&mut self.errors_buffer);\n-                }\n-\n-                RegionErrorKind::TypeTestGenericBoundError {\n-                    span,\n-                    generic,\n-                    lower_bound_region,\n-                } => {\n-                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n-                    self.infcx\n-                        .construct_generic_bound_failure(\n-                            region_scope_tree,\n-                            span,\n-                            None,\n-                            generic,\n-                            lower_bound_region,\n-                        )\n-                        .buffer(&mut self.errors_buffer);\n-                }\n-\n-                RegionErrorKind::UnexpectedHiddenRegion {\n-                    opaque_type_def_id,\n-                    hidden_ty,\n-                    member_region,\n-                } => {\n-                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n-                    opaque_types::unexpected_hidden_region_diagnostic(\n-                        self.infcx.tcx,\n-                        Some(region_scope_tree),\n-                        opaque_type_def_id,\n-                        hidden_ty,\n-                        member_region,\n-                    )\n-                    .buffer(&mut self.errors_buffer);\n-                }\n-\n-                RegionErrorKind::BoundUniversalRegionError {\n-                    longer_fr,\n-                    fr_origin,\n-                    error_region,\n-                } => {\n-                    // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n-                    let (_, span) = self.nonlexical_regioncx.find_outlives_blame_span(\n-                        &self.body,\n-                        longer_fr,\n-                        fr_origin,\n-                        error_region,\n-                    );\n-\n-                    // FIXME: improve this error message\n-                    self.infcx\n-                        .tcx\n-                        .sess\n-                        .struct_span_err(span, \"higher-ranked subtype error\")\n-                        .buffer(&mut self.errors_buffer);\n-                }\n-\n-                RegionErrorKind::RegionError { fr_origin, longer_fr, shorter_fr, is_reported } => {\n-                    if is_reported {\n-                        let db = self.nonlexical_regioncx.report_error(\n-                            self,\n-                            longer_fr,\n-                            fr_origin,\n-                            shorter_fr,\n-                            &mut outlives_suggestion,\n-                            &mut region_naming,\n-                        );\n-\n-                        db.buffer(&mut self.errors_buffer);\n-                    } else {\n-                        // We only report the first error, so as not to overwhelm the user. See\n-                        // `RegRegionErrorKind` docs.\n-                        //\n-                        // FIXME: currently we do nothing with these, but perhaps we can do better?\n-                        // FIXME: try collecting these constraints on the outlives suggestion\n-                        // builder. Does it make the suggestions any better?\n-                        debug!(\n-                            \"Unreported region error: can't prove that {:?}: {:?}\",\n-                            longer_fr, shorter_fr\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Emit one outlives suggestions for each MIR def we borrowck\n-        outlives_suggestion.add_suggestion(self, &mut region_naming);\n-    }\n }\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n@@ -2225,7 +2119,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             let upvar = &self.upvars[field.index()];\n                             debug!(\n                                 \"upvar.mutability={:?} local_mutation_is_allowed={:?} \\\n-                                place={:?}\",\n+                                 place={:?}\",\n                                 upvar, is_local_mutation_allowed, place\n                             );\n                             match (upvar.mutability, is_local_mutation_allowed) {"}, {"sha": "26d9cf2e0450fe02d82d69d73b6154434b672834", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 449, "deletions": 54, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -1,3 +1,4 @@\n+use std::collections::VecDeque;\n use std::rc::Rc;\n \n use rustc::infer::canonical::QueryOutlivesConstraint;\n@@ -43,49 +44,48 @@ pub struct RegionInferenceContext<'tcx> {\n     /// variables are identified by their index (`RegionVid`). The\n     /// definition contains information about where the region came\n     /// from as well as its final inferred value.\n-    pub(in crate::borrow_check) definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n+    definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n \n     /// The liveness constraints added to each region. For most\n     /// regions, these start out empty and steadily grow, though for\n     /// each universally quantified region R they start out containing\n     /// the entire CFG and `end(R)`.\n-    pub(in crate::borrow_check) liveness_constraints: LivenessValues<RegionVid>,\n+    liveness_constraints: LivenessValues<RegionVid>,\n \n     /// The outlives constraints computed by the type-check.\n-    pub(in crate::borrow_check) constraints: Rc<OutlivesConstraintSet>,\n+    constraints: Rc<OutlivesConstraintSet>,\n \n     /// The constraint-set, but in graph form, making it easy to traverse\n     /// the constraints adjacent to a particular region. Used to construct\n     /// the SCC (see `constraint_sccs`) and for error reporting.\n-    pub(in crate::borrow_check) constraint_graph: Rc<NormalConstraintGraph>,\n+    constraint_graph: Rc<NormalConstraintGraph>,\n \n     /// The SCC computed from `constraints` and the constraint\n     /// graph. We have an edge from SCC A to SCC B if `A: B`. Used to\n     /// compute the values of each region.\n-    pub(in crate::borrow_check) constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n+    constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n     /// Reverse of the SCC constraint graph -- i.e., an edge `A -> B`\n     /// exists if `B: A`. Computed lazilly.\n-    pub(in crate::borrow_check) rev_constraint_graph: Option<Rc<VecGraph<ConstraintSccIndex>>>,\n+    rev_constraint_graph: Option<Rc<VecGraph<ConstraintSccIndex>>>,\n \n     /// The \"R0 member of [R1..Rn]\" constraints, indexed by SCC.\n-    pub(in crate::borrow_check) member_constraints:\n-        Rc<MemberConstraintSet<'tcx, ConstraintSccIndex>>,\n+    member_constraints: Rc<MemberConstraintSet<'tcx, ConstraintSccIndex>>,\n \n     /// Records the member constraints that we applied to each scc.\n     /// This is useful for error reporting. Once constraint\n     /// propagation is done, this vector is sorted according to\n     /// `member_region_scc`.\n-    pub(in crate::borrow_check) member_constraints_applied: Vec<AppliedMemberConstraint>,\n+    member_constraints_applied: Vec<AppliedMemberConstraint>,\n \n     /// Map closure bounds to a `Span` that should be used for error reporting.\n-    pub(in crate::borrow_check) closure_bounds_mapping:\n+    closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n     /// Contains the minimum universe of any variable within the same\n     /// SCC. We will ensure that no SCC contains values that are not\n     /// visible from this index.\n-    pub(in crate::borrow_check) scc_universes: IndexVec<ConstraintSccIndex, ty::UniverseIndex>,\n+    scc_universes: IndexVec<ConstraintSccIndex, ty::UniverseIndex>,\n \n     /// Contains a \"representative\" from each SCC. This will be the\n     /// minimal RegionVid belonging to that universe. It is used as a\n@@ -94,23 +94,23 @@ pub struct RegionInferenceContext<'tcx> {\n     /// of its SCC and be sure that -- if they have the same repr --\n     /// they *must* be equal (though not having the same repr does not\n     /// mean they are unequal).\n-    pub(in crate::borrow_check) scc_representatives: IndexVec<ConstraintSccIndex, ty::RegionVid>,\n+    scc_representatives: IndexVec<ConstraintSccIndex, ty::RegionVid>,\n \n     /// The final inferred values of the region variables; we compute\n     /// one value per SCC. To get the value for any given *region*,\n     /// you first find which scc it is a part of.\n-    pub(in crate::borrow_check) scc_values: RegionValues<ConstraintSccIndex>,\n+    scc_values: RegionValues<ConstraintSccIndex>,\n \n     /// Type constraints that we check after solving.\n-    pub(in crate::borrow_check) type_tests: Vec<TypeTest<'tcx>>,\n+    type_tests: Vec<TypeTest<'tcx>>,\n \n     /// Information about the universally quantified regions in scope\n     /// on this function.\n-    pub(in crate::borrow_check) universal_regions: Rc<UniversalRegions<'tcx>>,\n+    universal_regions: Rc<UniversalRegions<'tcx>>,\n \n     /// Information about how the universally quantified regions in\n     /// scope on this function relate to one another.\n-    pub(in crate::borrow_check) universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n+    universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n }\n \n /// Each time that `apply_member_constraint` is successful, it appends\n@@ -225,6 +225,13 @@ enum RegionRelationCheckResult {\n     Error,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum Trace {\n+    StartRegion,\n+    FromOutlivesConstraint(OutlivesConstraint),\n+    NotVisited,\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -838,39 +845,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             // Type-test failed. Report the error.\n-\n-            // Try to convert the lower-bound region into something named we can print for the user.\n-            let lower_bound_region = self.to_error_region(type_test.lower_bound);\n+            let erased_generic_kind = infcx.tcx.erase_regions(&type_test.generic_kind);\n \n             // Skip duplicate-ish errors.\n-            let type_test_span = type_test.locations.span(body);\n-            let erased_generic_kind = tcx.erase_regions(&type_test.generic_kind);\n-            if !deduplicate_errors.insert((\n+            if deduplicate_errors.insert((\n                 erased_generic_kind,\n-                lower_bound_region,\n+                type_test.lower_bound,\n                 type_test.locations,\n             )) {\n-                continue;\n-            } else {\n                 debug!(\n                     \"check_type_test: reporting error for erased_generic_kind={:?}, \\\n                      lower_bound_region={:?}, \\\n                      type_test.locations={:?}\",\n-                    erased_generic_kind, lower_bound_region, type_test.locations,\n+                    erased_generic_kind, type_test.lower_bound, type_test.locations,\n                 );\n-            }\n \n-            if let Some(lower_bound_region) = lower_bound_region {\n-                errors_buffer.push(RegionErrorKind::TypeTestGenericBoundError {\n-                    span: type_test_span,\n-                    generic: type_test.generic_kind,\n-                    lower_bound_region,\n-                });\n-            } else {\n-                errors_buffer.push(RegionErrorKind::TypeTestDoesNotLiveLongEnough {\n-                    span: type_test_span,\n-                    generic: type_test.generic_kind,\n-                });\n+                errors_buffer.push(RegionErrorKind::TypeTestError { type_test: type_test.clone() });\n             }\n         }\n     }\n@@ -1355,7 +1345,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for (longer_fr, shorter_fr) in subset_errors.into_iter() {\n             debug!(\n                 \"check_polonius_subset_errors: subset_error longer_fr={:?},\\\n-                shorter_fr={:?}\",\n+                 shorter_fr={:?}\",\n                 longer_fr, shorter_fr\n             );\n \n@@ -1572,23 +1562,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"check_bound_universal_region: error_element = {:?}\", error_element);\n \n         // Find the region that introduced this `error_element`.\n-        let error_region = match error_element {\n-            RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n-            RegionElement::RootUniversalRegion(r) => r,\n-            RegionElement::PlaceholderRegion(error_placeholder) => self\n-                .definitions\n-                .iter_enumerated()\n-                .filter_map(|(r, definition)| match definition.origin {\n-                    NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n-                    _ => None,\n-                })\n-                .next()\n-                .unwrap(),\n-        };\n-\n         errors_buffer.push(RegionErrorKind::BoundUniversalRegionError {\n             longer_fr,\n-            error_region,\n+            error_element,\n             fr_origin: NLLRegionVariableOrigin::Placeholder(placeholder),\n         });\n     }\n@@ -1628,6 +1604,425 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             });\n         }\n     }\n+\n+    /// We have a constraint `fr1: fr2` that is not satisfied, where\n+    /// `fr2` represents some universal region. Here, `r` is some\n+    /// region where we know that `fr1: r` and this function has the\n+    /// job of determining whether `r` is \"to blame\" for the fact that\n+    /// `fr1: fr2` is required.\n+    ///\n+    /// This is true under two conditions:\n+    ///\n+    /// - `r == fr2`\n+    /// - `fr2` is `'static` and `r` is some placeholder in a universe\n+    ///   that cannot be named by `fr1`; in that case, we will require\n+    ///   that `fr1: 'static` because it is the only way to `fr1: r` to\n+    ///   be satisfied. (See `add_incompatible_universe`.)\n+    crate fn provides_universal_region(\n+        &self,\n+        r: RegionVid,\n+        fr1: RegionVid,\n+        fr2: RegionVid,\n+    ) -> bool {\n+        debug!(\"provides_universal_region(r={:?}, fr1={:?}, fr2={:?})\", r, fr1, fr2);\n+        let result = {\n+            r == fr2 || {\n+                fr2 == self.universal_regions.fr_static && self.cannot_name_placeholder(fr1, r)\n+            }\n+        };\n+        debug!(\"provides_universal_region: result = {:?}\", result);\n+        result\n+    }\n+\n+    /// If `r2` represents a placeholder region, then this returns\n+    /// `true` if `r1` cannot name that placeholder in its\n+    /// value; otherwise, returns `false`.\n+    crate fn cannot_name_placeholder(&self, r1: RegionVid, r2: RegionVid) -> bool {\n+        debug!(\"cannot_name_value_of(r1={:?}, r2={:?})\", r1, r2);\n+\n+        match self.definitions[r2].origin {\n+            NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                let universe1 = self.definitions[r1].universe;\n+                debug!(\n+                    \"cannot_name_value_of: universe1={:?} placeholder={:?}\",\n+                    universe1, placeholder\n+                );\n+                universe1.cannot_name(placeholder.universe)\n+            }\n+\n+            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential { .. } => {\n+                false\n+            }\n+        }\n+    }\n+\n+    crate fn retrieve_closure_constraint_info(\n+        &self,\n+        body: &Body<'tcx>,\n+        constraint: &OutlivesConstraint,\n+    ) -> (ConstraintCategory, bool, Span) {\n+        let loc = match constraint.locations {\n+            Locations::All(span) => return (constraint.category, false, span),\n+            Locations::Single(loc) => loc,\n+        };\n+\n+        let opt_span_category =\n+            self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub));\n+        opt_span_category.map(|&(category, span)| (category, true, span)).unwrap_or((\n+            constraint.category,\n+            false,\n+            body.source_info(loc).span,\n+        ))\n+    }\n+\n+    /// Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n+    crate fn find_outlives_blame_span(\n+        &self,\n+        body: &Body<'tcx>,\n+        fr1: RegionVid,\n+        fr1_origin: NLLRegionVariableOrigin,\n+        fr2: RegionVid,\n+    ) -> (ConstraintCategory, Span) {\n+        let (category, _, span) = self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n+            self.provides_universal_region(r, fr1, fr2)\n+        });\n+        (category, span)\n+    }\n+\n+    /// Walks the graph of constraints (where `'a: 'b` is considered\n+    /// an edge `'a -> 'b`) to find all paths from `from_region` to\n+    /// `to_region`. The paths are accumulated into the vector\n+    /// `results`. The paths are stored as a series of\n+    /// `ConstraintIndex` values -- in other words, a list of *edges*.\n+    ///\n+    /// Returns: a series of constraints as well as the region `R`\n+    /// that passed the target test.\n+    crate fn find_constraint_paths_between_regions(\n+        &self,\n+        from_region: RegionVid,\n+        target_test: impl Fn(RegionVid) -> bool,\n+    ) -> Option<(Vec<OutlivesConstraint>, RegionVid)> {\n+        let mut context = IndexVec::from_elem(Trace::NotVisited, &self.definitions);\n+        context[from_region] = Trace::StartRegion;\n+\n+        // Use a deque so that we do a breadth-first search. We will\n+        // stop at the first match, which ought to be the shortest\n+        // path (fewest constraints).\n+        let mut deque = VecDeque::new();\n+        deque.push_back(from_region);\n+\n+        while let Some(r) = deque.pop_front() {\n+            debug!(\n+                \"find_constraint_paths_between_regions: from_region={:?} r={:?} value={}\",\n+                from_region,\n+                r,\n+                self.region_value_str(r),\n+            );\n+\n+            // Check if we reached the region we were looking for. If so,\n+            // we can reconstruct the path that led to it and return it.\n+            if target_test(r) {\n+                let mut result = vec![];\n+                let mut p = r;\n+                loop {\n+                    match context[p] {\n+                        Trace::NotVisited => {\n+                            bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n+                        }\n+\n+                        Trace::FromOutlivesConstraint(c) => {\n+                            result.push(c);\n+                            p = c.sup;\n+                        }\n+\n+                        Trace::StartRegion => {\n+                            result.reverse();\n+                            return Some((result, r));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Otherwise, walk over the outgoing constraints and\n+            // enqueue any regions we find, keeping track of how we\n+            // reached them.\n+\n+            // A constraint like `'r: 'x` can come from our constraint\n+            // graph.\n+            let fr_static = self.universal_regions.fr_static;\n+            let outgoing_edges_from_graph =\n+                self.constraint_graph.outgoing_edges(r, &self.constraints, fr_static);\n+\n+            // Always inline this closure because it can be hot.\n+            let mut handle_constraint = #[inline(always)]\n+            |constraint: OutlivesConstraint| {\n+                debug_assert_eq!(constraint.sup, r);\n+                let sub_region = constraint.sub;\n+                if let Trace::NotVisited = context[sub_region] {\n+                    context[sub_region] = Trace::FromOutlivesConstraint(constraint);\n+                    deque.push_back(sub_region);\n+                }\n+            };\n+\n+            // This loop can be hot.\n+            for constraint in outgoing_edges_from_graph {\n+                handle_constraint(constraint);\n+            }\n+\n+            // Member constraints can also give rise to `'r: 'x` edges that\n+            // were not part of the graph initially, so watch out for those.\n+            // (But they are extremely rare; this loop is very cold.)\n+            for constraint in self.applied_member_constraints(r) {\n+                let p_c = &self.member_constraints[constraint.member_constraint_index];\n+                let constraint = OutlivesConstraint {\n+                    sup: r,\n+                    sub: constraint.min_choice,\n+                    locations: Locations::All(p_c.definition_span),\n+                    category: ConstraintCategory::OpaqueType,\n+                };\n+                handle_constraint(constraint);\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Finds some region R such that `fr1: R` and `R` is live at `elem`.\n+    crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n+        debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n+        self.find_constraint_paths_between_regions(fr1, |r| {\n+            // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n+            debug!(\n+                \"find_sub_region_live_at: liveness_constraints for {:?} are {:?}\",\n+                r,\n+                self.liveness_constraints.region_value_str(r),\n+            );\n+            self.liveness_constraints.contains(r, elem)\n+        })\n+        .or_else(|| {\n+            // If we fail to find that, we may find some `r` such that\n+            // `fr1: r` and `r` is a placeholder from some universe\n+            // `fr1` cannot name. This would force `fr1` to be\n+            // `'static`.\n+            self.find_constraint_paths_between_regions(fr1, |r| {\n+                self.cannot_name_placeholder(fr1, r)\n+            })\n+        })\n+        .or_else(|| {\n+            // If we fail to find THAT, it may be that `fr1` is a\n+            // placeholder that cannot \"fit\" into its SCC. In that\n+            // case, there should be some `r` where `fr1: r`, both\n+            // `fr1` and `r` are in the same SCC, and `fr1` is a\n+            // placeholder that `r` cannot name. We can blame that\n+            // edge.\n+            self.find_constraint_paths_between_regions(fr1, |r| {\n+                self.constraint_sccs.scc(fr1) == self.constraint_sccs.scc(r)\n+                    && self.cannot_name_placeholder(r, fr1)\n+            })\n+        })\n+        .map(|(_path, r)| r)\n+        .unwrap()\n+    }\n+\n+    /// Get the region outlived by `longer_fr` and live at `element`.\n+    crate fn region_from_element(&self, longer_fr: RegionVid, element: RegionElement) -> RegionVid {\n+        match element {\n+            RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n+            RegionElement::RootUniversalRegion(r) => r,\n+            RegionElement::PlaceholderRegion(error_placeholder) => self\n+                .definitions\n+                .iter_enumerated()\n+                .filter_map(|(r, definition)| match definition.origin {\n+                    NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n+                    _ => None,\n+                })\n+                .next()\n+                .unwrap(),\n+        }\n+    }\n+\n+    /// Get the region definition of `r`.\n+    crate fn region_definition(&self, r: RegionVid) -> &RegionDefinition<'tcx> {\n+        &self.definitions[r]\n+    }\n+\n+    /// Check if the SCC of `r` contains `upper`.\n+    crate fn upper_bound_in_region_scc(&self, r: RegionVid, upper: RegionVid) -> bool {\n+        let r_scc = self.constraint_sccs.scc(r);\n+        self.scc_values.contains(r_scc, upper)\n+    }\n+\n+    crate fn universal_regions(&self) -> &UniversalRegions<'tcx> {\n+        self.universal_regions.as_ref()\n+    }\n+\n+    /// Tries to find the best constraint to blame for the fact that\n+    /// `R: from_region`, where `R` is some region that meets\n+    /// `target_test`. This works by following the constraint graph,\n+    /// creating a constraint path that forces `R` to outlive\n+    /// `from_region`, and then finding the best choices within that\n+    /// path to blame.\n+    crate fn best_blame_constraint(\n+        &self,\n+        body: &Body<'tcx>,\n+        from_region: RegionVid,\n+        from_region_origin: NLLRegionVariableOrigin,\n+        target_test: impl Fn(RegionVid) -> bool,\n+    ) -> (ConstraintCategory, bool, Span) {\n+        debug!(\n+            \"best_blame_constraint(from_region={:?}, from_region_origin={:?})\",\n+            from_region, from_region_origin\n+        );\n+\n+        // Find all paths\n+        let (path, target_region) =\n+            self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n+        debug!(\n+            \"best_blame_constraint: path={:#?}\",\n+            path.iter()\n+                .map(|&c| format!(\n+                    \"{:?} ({:?}: {:?})\",\n+                    c,\n+                    self.constraint_sccs.scc(c.sup),\n+                    self.constraint_sccs.scc(c.sub),\n+                ))\n+                .collect::<Vec<_>>()\n+        );\n+\n+        // Classify each of the constraints along the path.\n+        let mut categorized_path: Vec<(ConstraintCategory, bool, Span)> = path\n+            .iter()\n+            .map(|constraint| {\n+                if constraint.category == ConstraintCategory::ClosureBounds {\n+                    self.retrieve_closure_constraint_info(body, &constraint)\n+                } else {\n+                    (constraint.category, false, constraint.locations.span(body))\n+                }\n+            })\n+            .collect();\n+        debug!(\"best_blame_constraint: categorized_path={:#?}\", categorized_path);\n+\n+        // To find the best span to cite, we first try to look for the\n+        // final constraint that is interesting and where the `sup` is\n+        // not unified with the ultimate target region. The reason\n+        // for this is that we have a chain of constraints that lead\n+        // from the source to the target region, something like:\n+        //\n+        //    '0: '1 ('0 is the source)\n+        //    '1: '2\n+        //    '2: '3\n+        //    '3: '4\n+        //    '4: '5\n+        //    '5: '6 ('6 is the target)\n+        //\n+        // Some of those regions are unified with `'6` (in the same\n+        // SCC).  We want to screen those out. After that point, the\n+        // \"closest\" constraint we have to the end is going to be the\n+        // most likely to be the point where the value escapes -- but\n+        // we still want to screen for an \"interesting\" point to\n+        // highlight (e.g., a call site or something).\n+        let target_scc = self.constraint_sccs.scc(target_region);\n+        let mut range = 0..path.len();\n+\n+        // As noted above, when reporting an error, there is typically a chain of constraints\n+        // leading from some \"source\" region which must outlive some \"target\" region.\n+        // In most cases, we prefer to \"blame\" the constraints closer to the target --\n+        // but there is one exception. When constraints arise from higher-ranked subtyping,\n+        // we generally prefer to blame the source value,\n+        // as the \"target\" in this case tends to be some type annotation that the user gave.\n+        // Therefore, if we find that the region origin is some instantiation\n+        // of a higher-ranked region, we start our search from the \"source\" point\n+        // rather than the \"target\", and we also tweak a few other things.\n+        //\n+        // An example might be this bit of Rust code:\n+        //\n+        // ```rust\n+        // let x: fn(&'static ()) = |_| {};\n+        // let y: for<'a> fn(&'a ()) = x;\n+        // ```\n+        //\n+        // In MIR, this will be converted into a combination of assignments and type ascriptions.\n+        // In particular, the 'static is imposed through a type ascription:\n+        //\n+        // ```rust\n+        // x = ...;\n+        // AscribeUserType(x, fn(&'static ())\n+        // y = x;\n+        // ```\n+        //\n+        // We wind up ultimately with constraints like\n+        //\n+        // ```rust\n+        // !a: 'temp1 // from the `y = x` statement\n+        // 'temp1: 'temp2\n+        // 'temp2: 'static // from the AscribeUserType\n+        // ```\n+        //\n+        // and here we prefer to blame the source (the y = x statement).\n+        let blame_source = match from_region_origin {\n+            NLLRegionVariableOrigin::FreeRegion\n+            | NLLRegionVariableOrigin::Existential { from_forall: false } => true,\n+            NLLRegionVariableOrigin::Placeholder(_)\n+            | NLLRegionVariableOrigin::Existential { from_forall: true } => false,\n+        };\n+\n+        let find_region = |i: &usize| {\n+            let constraint = path[*i];\n+\n+            let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n+\n+            if blame_source {\n+                match categorized_path[*i].0 {\n+                    ConstraintCategory::OpaqueType\n+                    | ConstraintCategory::Boring\n+                    | ConstraintCategory::BoringNoLocation\n+                    | ConstraintCategory::Internal => false,\n+                    ConstraintCategory::TypeAnnotation\n+                    | ConstraintCategory::Return\n+                    | ConstraintCategory::Yield => true,\n+                    _ => constraint_sup_scc != target_scc,\n+                }\n+            } else {\n+                match categorized_path[*i].0 {\n+                    ConstraintCategory::OpaqueType\n+                    | ConstraintCategory::Boring\n+                    | ConstraintCategory::BoringNoLocation\n+                    | ConstraintCategory::Internal => false,\n+                    _ => true,\n+                }\n+            }\n+        };\n+\n+        let best_choice =\n+            if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n+\n+        debug!(\n+            \"best_blame_constraint: best_choice={:?} blame_source={}\",\n+            best_choice, blame_source\n+        );\n+\n+        if let Some(i) = best_choice {\n+            if let Some(next) = categorized_path.get(i + 1) {\n+                if categorized_path[i].0 == ConstraintCategory::Return\n+                    && next.0 == ConstraintCategory::OpaqueType\n+                {\n+                    // The return expression is being influenced by the return type being\n+                    // impl Trait, point at the return type and not the return expr.\n+                    return *next;\n+                }\n+            }\n+            return categorized_path[i];\n+        }\n+\n+        // If that search fails, that is.. unusual. Maybe everything\n+        // is in the same SCC or something. In that case, find what\n+        // appears to be the most interesting point to report to the\n+        // user via an even more ad-hoc guess.\n+        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n+        debug!(\"`: sorted_path={:#?}\", categorized_path);\n+\n+        *categorized_path.first().unwrap()\n+    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {"}, {"sha": "3126d44014b4ea3d0943c3497794c6a38e7dec9b", "filename": "src/librustc_mir/borrow_check/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -114,7 +114,7 @@ rustc_index::newtype_index! {\n \n /// An individual element in a region value -- the value of a\n /// particular region variable consists of a set of these elements.\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n crate enum RegionElement {\n     /// A point in the control-flow graph.\n     Location(Location),"}, {"sha": "89107e799bd2207c4f26a4f62e38ceb0cf27c35a", "filename": "src/test/ui/c-variadic/variadic-ffi-4.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -87,12 +87,12 @@ error[E0597]: `ap1` does not live long enough\n   --> $DIR/variadic-ffi-4.rs:24:11\n    |\n LL | pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                                    - let's call the lifetime of this reference `'1`\n+   |                                                    - let's call the lifetime of this reference `'3`\n LL |     ap0 = &mut ap1;\n    |     ------^^^^^^^^\n    |     |     |\n    |     |     borrowed value does not live long enough\n-   |     assignment requires that `ap1` is borrowed for `'1`\n+   |     assignment requires that `ap1` is borrowed for `'3`\n ...\n LL | }\n    | - `ap1` dropped here while still borrowed"}]}