{"sha": "322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMmQ3ZjdiOTdmMTY3MmJhZGUzMWUxYzQzZDU3NTNlMGU0NWExYTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-25T15:04:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-25T15:04:40Z"}, "message": "Auto merge of #48531 - kennytm:rollup, r=kennytm\n\nRollup of 17 pull requests\n\n- Successful merges: #47964, #47970, #48076, #48115, #48166, #48281, #48297, #48302, #48362, #48369, #48489, #48491, #48494, #48517, #48529, #48235, #48330\n- Failed merges:", "tree": {"sha": "9da99f11e21caf2cb8e83bfa84cff6a2f0c376ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9da99f11e21caf2cb8e83bfa84cff6a2f0c376ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "html_url": "https://github.com/rust-lang/rust/commit/322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "026339e42ba11a559767029d933d1197aefb877a", "url": "https://api.github.com/repos/rust-lang/rust/commits/026339e42ba11a559767029d933d1197aefb877a", "html_url": "https://github.com/rust-lang/rust/commit/026339e42ba11a559767029d933d1197aefb877a"}, {"sha": "1aa103511b6c52943e54f62992551babef9d4526", "url": "https://api.github.com/repos/rust-lang/rust/commits/1aa103511b6c52943e54f62992551babef9d4526", "html_url": "https://github.com/rust-lang/rust/commit/1aa103511b6c52943e54f62992551babef9d4526"}], "stats": {"total": 1379, "additions": 1143, "deletions": 236}, "files": [{"sha": "ca35a896e08c88f07583bc88fe5adc6b4673a2fc", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -61,6 +61,11 @@ fn main() {\n         args.remove(n);\n     }\n \n+    if let Some(s) = env::var_os(\"RUSTC_ERROR_FORMAT\") {\n+        args.push(\"--error-format\".into());\n+        args.push(s);\n+    }\n+\n     // Detect whether or not we're a build script depending on whether --target\n     // is passed (a bit janky...)\n     let target = args.windows(2)"}, {"sha": "5966bb65df9c87ebef767ac64d453f185b9ccd98", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -294,7 +294,7 @@ def default_build_triple():\n             raise ValueError('unknown byteorder: {}'.format(sys.byteorder))\n         # only the n64 ABI is supported, indicate it\n         ostype += 'abi64'\n-    elif cputype == 'sparcv9' or cputype == 'sparc64':\n+    elif cputype == 'sparc' or cputype == 'sparcv9' or cputype == 'sparc64':\n         pass\n     else:\n         err = \"unknown cpu type: {}\".format(cputype)"}, {"sha": "b5946b44e05ef6316ab5881d7250f1e923548b61", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -444,10 +444,11 @@ impl<'a> Builder<'a> {\n \n             fn run(self, builder: &Builder) -> Interned<PathBuf> {\n                 let compiler = self.compiler;\n-                let lib = if compiler.stage >= 1 && builder.build.config.libdir.is_some() {\n-                    builder.build.config.libdir.clone().unwrap()\n+                let config = &builder.build.config;\n+                let lib = if compiler.stage >= 1 && config.libdir_relative().is_some() {\n+                    builder.build.config.libdir_relative().unwrap()\n                 } else {\n-                    PathBuf::from(\"lib\")\n+                    Path::new(\"lib\")\n                 };\n                 let sysroot = builder.sysroot(self.compiler).join(lib)\n                     .join(\"rustlib\").join(self.target).join(\"lib\");\n@@ -598,6 +599,9 @@ impl<'a> Builder<'a> {\n         if let Some(target_linker) = self.build.linker(target) {\n             cargo.env(\"RUSTC_TARGET_LINKER\", target_linker);\n         }\n+        if let Some(ref error_format) = self.config.rustc_error_format {\n+            cargo.env(\"RUSTC_ERROR_FORMAT\", error_format);\n+        }\n         if cmd != \"build\" && cmd != \"check\" {\n             cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(self.compiler(2, self.build.build)));\n         }"}, {"sha": "c85b04ddc02458fb82a63c655ff5db6ebd80ed10", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -516,8 +516,7 @@ fn rustc_cargo_env(build: &Build, cargo: &mut Command) {\n          .env(\"CFG_VERSION\", build.rust_version())\n          .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or_default());\n \n-    let libdir_relative =\n-        build.config.libdir.clone().unwrap_or(PathBuf::from(\"lib\"));\n+    let libdir_relative = build.config.libdir_relative().unwrap_or(Path::new(\"lib\"));\n     cargo.env(\"CFG_LIBDIR_RELATIVE\", libdir_relative);\n \n     // If we're not building a compiler with debugging information then remove"}, {"sha": "6bc20181a0330a5a51eef0ae83defe310cb87e39", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -17,7 +17,7 @@ use std::collections::{HashMap, HashSet};\n use std::env;\n use std::fs::File;\n use std::io::prelude::*;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::process;\n use std::cmp;\n \n@@ -57,6 +57,7 @@ pub struct Config {\n     pub profiler: bool,\n     pub ignore_git: bool,\n     pub exclude: Vec<PathBuf>,\n+    pub rustc_error_format: Option<String>,\n \n     pub run_host_only: bool,\n \n@@ -330,6 +331,7 @@ impl Config {\n         config.test_miri = false;\n         config.rust_codegen_backends = vec![INTERNER.intern_str(\"llvm\")];\n \n+        config.rustc_error_format = flags.rustc_error_format;\n         config.on_fail = flags.on_fail;\n         config.stage = flags.stage;\n         config.src = flags.src;\n@@ -564,6 +566,17 @@ impl Config {\n         config\n     }\n \n+    /// Try to find the relative path of `libdir`.\n+    pub fn libdir_relative(&self) -> Option<&Path> {\n+        let libdir = self.libdir.as_ref()?;\n+        if libdir.is_relative() {\n+            Some(libdir)\n+        } else {\n+            // Try to make it relative to the prefix.\n+            libdir.strip_prefix(self.prefix.as_ref()?).ok()\n+        }\n+    }\n+\n     pub fn verbose(&self) -> bool {\n         self.verbose > 0\n     }"}, {"sha": "8ca5910a11c0d5c8b2f3648992dc1758ce403415", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -43,6 +43,7 @@ pub struct Flags {\n     pub cmd: Subcommand,\n     pub incremental: bool,\n     pub exclude: Vec<PathBuf>,\n+    pub rustc_error_format: Option<String>,\n }\n \n pub enum Subcommand {\n@@ -118,6 +119,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n+        opts.optflag(\"\", \"error-format\", \"rustc error format\");\n \n         // fn usage()\n         let usage = |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n@@ -370,6 +372,7 @@ Arguments:\n             verbose: matches.opt_count(\"verbose\"),\n             stage,\n             on_fail: matches.opt_str(\"on-fail\"),\n+            rustc_error_format: matches.opt_str(\"error-format\"),\n             keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n             build: matches.opt_str(\"build\").map(|s| INTERNER.intern_string(s)),\n             host: split(matches.opt_strs(\"host\"))"}, {"sha": "15dd7fabfa58b5c7303d4170f201f43a3cbdf1ea", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -480,16 +480,19 @@ impl Step for Openssl {\n             \"mips64el-unknown-linux-gnuabi64\" => \"linux64-mips64\",\n             \"mipsel-unknown-linux-gnu\" => \"linux-mips32\",\n             \"powerpc-unknown-linux-gnu\" => \"linux-ppc\",\n+            \"powerpc-unknown-netbsd\" => \"BSD-generic32\",\n             \"powerpc64-unknown-linux-gnu\" => \"linux-ppc64\",\n             \"powerpc64le-unknown-linux-gnu\" => \"linux-ppc64le\",\n             \"s390x-unknown-linux-gnu\" => \"linux64-s390x\",\n+            \"sparc-unknown-linux-gnu\" => \"linux-sparcv9\",\n             \"sparc64-unknown-linux-gnu\" => \"linux64-sparcv9\",\n             \"sparc64-unknown-netbsd\" => \"BSD-sparc64\",\n             \"x86_64-apple-darwin\" => \"darwin64-x86_64-cc\",\n             \"x86_64-linux-android\" => \"linux-x86_64\",\n             \"x86_64-unknown-freebsd\" => \"BSD-x86_64\",\n             \"x86_64-unknown-dragonfly\" => \"BSD-x86_64\",\n             \"x86_64-unknown-linux-gnu\" => \"linux-x86_64\",\n+            \"x86_64-unknown-linux-gnux32\" => \"linux-x32\",\n             \"x86_64-unknown-linux-musl\" => \"linux-x86_64\",\n             \"x86_64-unknown-netbsd\" => \"BSD-x86_64\",\n             _ => panic!(\"don't know how to configure OpenSSL for {}\", target),"}, {"sha": "1280c71e83c922fa2b5e3befe3419f6014aa1dd2", "filename": "src/doc/unstable-book/src/library-features/entry-and-modify.md", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-and-modify.md", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-and-modify.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-and-modify.md?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -1,77 +0,0 @@\n-# `entry_and_modify`\n-\n-The tracking issue for this feature is: [#44733]\n-\n-[#44733]: https://github.com/rust-lang/rust/issues/44733\n-\n-------------------------\n-\n-This introduces a new method for the Entry API of maps\n-(`std::collections::HashMap` and `std::collections::BTreeMap`), so that\n-occupied entries can be modified before any potential inserts into the\n-map.\n-\n-For example:\n-\n-```rust\n-#![feature(entry_and_modify)]\n-# fn main() {\n-use std::collections::HashMap;\n-\n-struct Foo {\n-    new: bool,\n-}\n-\n-let mut map: HashMap<&str, Foo> = HashMap::new();\n-\n-map.entry(\"quux\")\n-   .and_modify(|e| e.new = false)\n-   .or_insert(Foo { new: true });\n-# }\n-```\n-\n-This is not possible with the stable API alone since inserting a default\n-_before_ modifying the `new` field would mean we would lose the default state:\n-\n-```rust\n-# fn main() {\n-use std::collections::HashMap;\n-\n-struct Foo {\n-    new: bool,\n-}\n-\n-let mut map: HashMap<&str, Foo> = HashMap::new();\n-\n-map.entry(\"quux\").or_insert(Foo { new: true }).new = false;\n-# }\n-```\n-\n-In the above code the `new` field will never be `true`, even though we only\n-intended to update that field to `false` for previously extant entries.\n-\n-To achieve the same effect as `and_modify` we would have to manually match\n-against the `Occupied` and `Vacant` variants of the `Entry` enum, which is\n-a little less user-friendly, and much more verbose:\n-\n-```rust\n-# fn main() {\n-use std::collections::HashMap;\n-use std::collections::hash_map::Entry;\n-\n-struct Foo {\n-    new: bool,\n-}\n-\n-let mut map: HashMap<&str, Foo> = HashMap::new();\n-\n-match map.entry(\"quux\") {\n-    Entry::Occupied(entry) => {\n-        entry.into_mut().new = false;\n-    },\n-    Entry::Vacant(entry) => {\n-        entry.insert(Foo { new: true });\n-    },\n-};\n-# }\n-```"}, {"sha": "618ef81fdd98198c71268a8b08eb257f3ca2feb6", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -2114,7 +2114,6 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(entry_and_modify)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n@@ -2129,7 +2128,7 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     ///    .or_insert(42);\n     /// assert_eq!(map[\"poneyland\"], 43);\n     /// ```\n-    #[unstable(feature = \"entry_and_modify\", issue = \"44733\")]\n+    #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n     pub fn and_modify<F>(self, mut f: F) -> Self\n         where F: FnMut(&mut V)\n     {"}, {"sha": "9d8a71250f88ad508c561d08d05d9e45ea1079e5", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -12,7 +12,8 @@ use cmp::Ordering;\n use ops::Try;\n \n use super::{AlwaysOk, LoopState};\n-use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse};\n+use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, Fuse};\n+use super::{Flatten, FlatMap, flatten_compat};\n use super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile, Rev};\n use super::{Zip, Sum, Product};\n use super::{ChainState, FromIterator, ZipImpl};\n@@ -997,11 +998,15 @@ pub trait Iterator {\n     /// an extra layer of indirection. `flat_map()` will remove this extra layer\n     /// on its own.\n     ///\n+    /// You can think of [`flat_map(f)`][flat_map] as the semantic equivalent\n+    /// of [`map`]ping, and then [`flatten`]ing as in `map(f).flatten()`.\n+    ///\n     /// Another way of thinking about `flat_map()`: [`map`]'s closure returns\n     /// one item for each element, and `flat_map()`'s closure returns an\n     /// iterator for each element.\n     ///\n     /// [`map`]: #method.map\n+    /// [`flatten`]: #method.flatten\n     ///\n     /// # Examples\n     ///\n@@ -1021,7 +1026,79 @@ pub trait Iterator {\n     fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>\n         where Self: Sized, U: IntoIterator, F: FnMut(Self::Item) -> U,\n     {\n-        FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n+        FlatMap { inner: flatten_compat(self.map(f)) }\n+    }\n+\n+    /// Creates an iterator that flattens nested structure.\n+    ///\n+    /// This is useful when you have an iterator of iterators or an iterator of\n+    /// things that can be turned into iterators and you want to remove one\n+    /// level of indirection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_flatten)]\n+    ///\n+    /// let data = vec![vec![1, 2, 3, 4], vec![5, 6]];\n+    /// let flattened = data.into_iter().flatten().collect::<Vec<u8>>();\n+    /// assert_eq!(flattened, &[1, 2, 3, 4, 5, 6]);\n+    /// ```\n+    ///\n+    /// Mapping and then flattening:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_flatten)]\n+    ///\n+    /// let words = [\"alpha\", \"beta\", \"gamma\"];\n+    ///\n+    /// // chars() returns an iterator\n+    /// let merged: String = words.iter()\n+    ///                           .map(|s| s.chars())\n+    ///                           .flatten()\n+    ///                           .collect();\n+    /// assert_eq!(merged, \"alphabetagamma\");\n+    /// ```\n+    ///\n+    /// You can also rewrite this in terms of [`flat_map()`] which is preferable\n+    /// in this case since that conveys intent clearer:\n+    ///\n+    /// ```\n+    /// let words = [\"alpha\", \"beta\", \"gamma\"];\n+    ///\n+    /// // chars() returns an iterator\n+    /// let merged: String = words.iter()\n+    ///                           .flat_map(|s| s.chars())\n+    ///                           .collect();\n+    /// assert_eq!(merged, \"alphabetagamma\");\n+    /// ```\n+    ///\n+    /// Flattening once only removes one level of nesting:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_flatten)]\n+    ///\n+    /// let d3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]];\n+    ///\n+    /// let d2 = d3.iter().flatten().collect::<Vec<_>>();\n+    /// assert_eq!(d2, [&[1, 2], &[3, 4], &[5, 6], &[7, 8]]);\n+    ///\n+    /// let d1 = d3.iter().flatten().flatten().collect::<Vec<_>>();\n+    /// assert_eq!(d1, [&1, &2, &3, &4, &5, &6, &7, &8]);\n+    /// ```\n+    ///\n+    /// Here we see that `flatten()` does not perform a \"deep\" flatten.\n+    /// Instead, only one level of nesting is removed. That is, if you\n+    /// `flatten()` a three-dimensional array the result will be\n+    /// two-dimensional and not one-dimensional. To get a one-dimensional\n+    /// structure, you have to `flatten()` again.\n+    #[inline]\n+    #[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+    fn flatten(self) -> Flatten<Self>\n+    where Self: Sized, Self::Item: IntoIterator {\n+        Flatten { inner: flatten_compat(self) }\n     }\n \n     /// Creates an iterator which ends after the first [`None`]."}, {"sha": "623cad754dd7274221efea7a9a7a22c4a9b314ba", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 179, "deletions": 34, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -2410,24 +2410,23 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n /// [`Iterator`]: trait.Iterator.html\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n pub struct FlatMap<I, U: IntoIterator, F> {\n-    iter: I,\n-    f: F,\n-    frontiter: Option<U::IntoIter>,\n-    backiter: Option<U::IntoIter>,\n+    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Clone, U: Clone + IntoIterator, F: Clone> Clone for FlatMap<I, U, F>\n+    where <U as IntoIterator>::IntoIter: Clone\n+{\n+    fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n     where U::IntoIter: fmt::Debug\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"FlatMap\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"frontiter\", &self.frontiter)\n-            .field(\"backiter\", &self.backiter)\n-            .finish()\n+        f.debug_struct(\"FlatMap\").field(\"inner\", &self.inner).finish()\n     }\n }\n \n@@ -2437,17 +2436,173 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n {\n     type Item = U::Item;\n \n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n+          U: IntoIterator,\n+          U::IntoIter: DoubleEndedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n+    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n+\n+/// An iterator that flattens one level of nesting in an iterator of things\n+/// that can be turned into iterators.\n+///\n+/// This `struct` is created by the [`flatten`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`flatten`]: trait.Iterator.html#method.flatten\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+pub struct Flatten<I: Iterator>\n+where I::Item: IntoIterator {\n+    inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+impl<I, U> fmt::Debug for Flatten<I>\n+    where I: Iterator + fmt::Debug, U: Iterator + fmt::Debug,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Flatten\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+impl<I, U> Clone for Flatten<I>\n+    where I: Iterator + Clone, U: Iterator + Clone,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+impl<I, U> Iterator for Flatten<I>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+impl<I, U> DoubleEndedIterator for Flatten<I>\n+    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<I, U> FusedIterator for Flatten<I>\n+    where I: FusedIterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}\n+\n+/// Adapts an iterator by flattening it, for use in `flatten()` and `flat_map()`.\n+fn flatten_compat<I, U>(iter: I) -> FlattenCompat<I, U> {\n+    FlattenCompat { iter, frontiter: None, backiter: None }\n+}\n+\n+/// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n+/// this type.\n+#[derive(Clone, Debug)]\n+struct FlattenCompat<I, U> {\n+    iter: I,\n+    frontiter: Option<U>,\n+    backiter: Option<U>,\n+}\n+\n+impl<I, U> Iterator for FlattenCompat<I, U>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    type Item = U::Item;\n+\n     #[inline]\n     fn next(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.frontiter {\n-                if let Some(x) = inner.by_ref().next() {\n-                    return Some(x)\n-                }\n+                if let elt@Some(_) = inner.next() { return elt }\n             }\n-            match self.iter.next().map(&mut self.f) {\n+            match self.iter.next() {\n                 None => return self.backiter.as_mut().and_then(|it| it.next()),\n-                next => self.frontiter = next.map(IntoIterator::into_iter),\n+                Some(inner) => self.frontiter = Some(inner.into_iter()),\n             }\n         }\n     }\n@@ -2473,10 +2628,9 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n         self.frontiter = None;\n \n         {\n-            let f = &mut self.f;\n             let frontiter = &mut self.frontiter;\n             init = self.iter.try_fold(init, |acc, x| {\n-                let mut mid = f(x).into_iter();\n+                let mut mid = x.into_iter();\n                 let r = mid.try_fold(acc, &mut fold);\n                 *frontiter = Some(mid);\n                 r\n@@ -2497,27 +2651,23 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.frontiter.into_iter()\n-            .chain(self.iter.map(self.f).map(U::into_iter))\n+            .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n             .fold(init, |acc, iter| iter.fold(acc, &mut fold))\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> where\n-    F: FnMut(I::Item) -> U,\n-    U: IntoIterator,\n-    U::IntoIter: DoubleEndedIterator\n+impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n+    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.backiter {\n-                if let Some(y) = inner.next_back() {\n-                    return Some(y)\n-                }\n+                if let elt@Some(_) = inner.next_back() { return elt }\n             }\n-            match self.iter.next_back().map(&mut self.f) {\n+            match self.iter.next_back() {\n                 None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n                 next => self.backiter = next.map(IntoIterator::into_iter),\n             }\n@@ -2534,10 +2684,9 @@ impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> wher\n         self.backiter = None;\n \n         {\n-            let f = &mut self.f;\n             let backiter = &mut self.backiter;\n             init = self.iter.try_rfold(init, |acc, x| {\n-                let mut mid = f(x).into_iter();\n+                let mut mid = x.into_iter();\n                 let r = mid.try_rfold(acc, &mut fold);\n                 *backiter = Some(mid);\n                 r\n@@ -2558,16 +2707,12 @@ impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> wher\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.frontiter.into_iter()\n-            .chain(self.iter.map(self.f).map(U::into_iter))\n+            .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n             .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n-    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n-\n /// An iterator that yields `None` forever after the underlying iterator\n /// yields `None` once.\n ///"}, {"sha": "3dd30ee1c69e235a5ba2ac9685cf4751d0825fa3", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -93,6 +93,7 @@\n #![feature(doc_spotlight)]\n #![feature(rustc_const_unstable)]\n #![feature(iterator_repeat_with)]\n+#![feature(iterator_flatten)]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "69418434ebead36b0ed701744ab61c4ce7d25dfa", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -73,7 +73,8 @@ pub fn parse_decimal(s: &str) -> ParseResult {\n         }\n         Some(&b'.') => {\n             let (fractional, s) = eat_digits(&s[1..]);\n-            if integral.is_empty() && fractional.is_empty() && s.is_empty() {\n+            if integral.is_empty() && fractional.is_empty() {\n+                // We require at least a single digit before or after the point.\n                 return Invalid;\n             }\n "}, {"sha": "7d5aa25016bdd66a8cc24ad33a708b73d517f599", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -2892,7 +2892,7 @@ impl u8 {\n     }\n \n     /// Checks if the value is an ASCII graphic character:\n-    /// U+0021 '@' ... U+007E '~'.\n+    /// U+0021 '!' ... U+007E '~'.\n     ///\n     /// # Examples\n     ///"}, {"sha": "edd75f7795ed7cf18ec33575b142feff40070367", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -874,6 +874,44 @@ fn test_iterator_flat_map_fold() {\n     assert_eq!(i, 0);\n }\n \n+#[test]\n+fn test_iterator_flatten() {\n+    let xs = [0, 3, 6];\n+    let ys = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let it = xs.iter().map(|&x| (x..).step_by(1).take(3)).flatten();\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+/// Test `Flatten::fold` with items already picked off the front and back,\n+/// to make sure all parts of the `Flatten` are folded correctly.\n+#[test]\n+fn test_iterator_flatten_fold() {\n+    let xs = [0, 3, 6];\n+    let ys = [1, 2, 3, 4, 5, 6, 7];\n+    let mut it = xs.iter().map(|&x| x..x+3).flatten();\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.fold(0, |i, x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().map(|&x| x..x+3).flatten();\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.rfold(ys.len(), |i, x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+\n #[test]\n fn test_inspect() {\n     let xs = [1, 2, 3, 4];\n@@ -1287,6 +1325,23 @@ fn test_double_ended_flat_map() {\n     assert_eq!(it.next_back(), None);\n }\n \n+#[test]\n+fn test_double_ended_flatten() {\n+    let u = [0,1];\n+    let v = [5,6,7,8];\n+    let mut it = u.iter().map(|x| &v[*x..v.len()]).flatten();\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(),      &5);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back().unwrap(), &6);\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(),      &6);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(),      None);\n+    assert_eq!(it.next_back(), None);\n+}\n+\n #[test]\n fn test_double_ended_range() {\n     assert_eq!((11..14).rev().collect::<Vec<_>>(), [13, 12, 11]);\n@@ -1978,3 +2033,54 @@ fn test_flat_map_try_folds() {\n     assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n     assert_eq!(iter.next_back(), Some(35));\n }\n+\n+#[test]\n+fn test_flatten_try_folds() {\n+    let f = &|acc, x| i32::checked_add(acc*2/3, x);\n+    let mr = &|x| (5*x)..(5*x + 5);\n+    assert_eq!((0..10).map(mr).flatten().try_fold(7, f), (0..50).try_fold(7, f));\n+    assert_eq!((0..10).map(mr).flatten().try_rfold(7, f), (0..50).try_rfold(7, f));\n+    let mut iter = (0..10).map(mr).flatten();\n+    iter.next(); iter.next_back(); // have front and back iters in progress\n+    assert_eq!(iter.try_rfold(7, f), (1..49).try_rfold(7, f));\n+\n+    let mut iter = (0..10).map(|x| (4*x)..(4*x + 4)).flatten();\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(17));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(35));\n+}\n+\n+#[test]\n+fn test_functor_laws() {\n+    // identity:\n+    fn identity<T>(x: T) -> T { x }\n+    assert_eq!((0..10).map(identity).sum::<usize>(), (0..10).sum());\n+\n+    // composition:\n+    fn f(x: usize) -> usize { x + 3 }\n+    fn g(x: usize) -> usize { x * 2 }\n+    fn h(x: usize) -> usize { g(f(x)) }\n+    assert_eq!((0..10).map(f).map(g).sum::<usize>(), (0..10).map(h).sum());\n+}\n+\n+#[test]\n+fn test_monad_laws_left_identity() {\n+    fn f(x: usize) -> impl Iterator<Item = usize> {\n+        (0..10).map(move |y| x * y)\n+    }\n+    assert_eq!(once(42).flat_map(f.clone()).sum::<usize>(), f(42).sum());\n+}\n+\n+#[test]\n+fn test_monad_laws_right_identity() {\n+    assert_eq!((0..10).flat_map(|x| once(x)).sum::<usize>(), (0..10).sum());\n+}\n+\n+#[test]\n+fn test_monad_laws_associativity() {\n+    fn f(x: usize) -> impl Iterator<Item = usize> { 0..x }\n+    fn g(x: usize) -> impl Iterator<Item = usize> { (0..x).rev() }\n+    assert_eq!((0..10).flat_map(f).flat_map(g).sum::<usize>(),\n+                (0..10).flat_map(|x| f(x).flat_map(g)).sum::<usize>());\n+}"}, {"sha": "7954d52f6b1e368f64b4a309fe08b4baea5f6d15", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -25,6 +25,8 @@\n #![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]\n #![feature(iterator_try_fold)]\n+#![feature(iterator_flatten)]\n+#![feature(conservative_impl_trait)]\n #![feature(iter_rfind)]\n #![feature(iter_rfold)]\n #![feature(iterator_repeat_with)]"}, {"sha": "17b2f59cd4df2814e47e1175eab92b011b3ddd99", "filename": "src/libcore/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -101,6 +101,12 @@ fn lonely_dot() {\n     assert!(\".\".parse::<f64>().is_err());\n }\n \n+#[test]\n+fn exponentiated_dot() {\n+    assert!(\".e0\".parse::<f32>().is_err());\n+    assert!(\".e0\".parse::<f64>().is_err());\n+}\n+\n #[test]\n fn lonely_sign() {\n     assert!(\"+\".parse::<f32>().is_err());"}, {"sha": "a0f84a6ab04959a23980467c0a049506dca2ada7", "filename": "src/librustc_back/target/freebsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -33,6 +33,7 @@ pub fn opts() -> TargetOptions {\n         has_rpath: true,\n         pre_link_args: args,\n         position_independent_executables: true,\n+        eliminate_frame_pointer: false, // FIXME 43575\n         relro_level: RelroLevel::Full,\n         exe_allocation_crate: super::maybe_jemalloc(),\n         .. Default::default()"}, {"sha": "d356105e39314c6aa7d268e67b52a9d9c14ac7e2", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -146,6 +146,7 @@ supported_targets! {\n     (\"powerpc64-unknown-linux-gnu\", powerpc64_unknown_linux_gnu),\n     (\"powerpc64le-unknown-linux-gnu\", powerpc64le_unknown_linux_gnu),\n     (\"s390x-unknown-linux-gnu\", s390x_unknown_linux_gnu),\n+    (\"sparc-unknown-linux-gnu\", sparc_unknown_linux_gnu),\n     (\"sparc64-unknown-linux-gnu\", sparc64_unknown_linux_gnu),\n     (\"arm-unknown-linux-gnueabi\", arm_unknown_linux_gnueabi),\n     (\"arm-unknown-linux-gnueabihf\", arm_unknown_linux_gnueabihf),\n@@ -186,6 +187,7 @@ supported_targets! {\n     (\"x86_64-unknown-openbsd\", x86_64_unknown_openbsd),\n \n     (\"i686-unknown-netbsd\", i686_unknown_netbsd),\n+    (\"powerpc-unknown-netbsd\", powerpc_unknown_netbsd),\n     (\"sparc64-unknown-netbsd\", sparc64_unknown_netbsd),\n     (\"x86_64-unknown-netbsd\", x86_64_unknown_netbsd),\n     (\"x86_64-rumprun-netbsd\", x86_64_rumprun_netbsd),"}, {"sha": "2c78dbd206171a072f64c2ab3d30ef342dd7a8c9", "filename": "src/librustc_back/target/powerpc_unknown_netbsd.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_netbsd.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use LinkerFlavor;\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::netbsd_base::opts();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n+    base.max_atomic_width = Some(32);\n+\n+    // see #36994\n+    base.exe_allocation_crate = None;\n+\n+    Ok(Target {\n+        llvm_target: \"powerpc-unknown-netbsd\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-p:32:32-i64:64-n32\".to_string(),\n+        arch: \"powerpc\".to_string(),\n+        target_os: \"netbsd\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "a03e6937b2ca751d38dd513534941eb42ec76261", "filename": "src/librustc_back/target/sparc_unknown_linux_gnu.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_back%2Ftarget%2Fsparc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_back%2Ftarget%2Fsparc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fsparc_unknown_linux_gnu.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use LinkerFlavor;\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::linux_base::opts();\n+    base.cpu = \"v9\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-mv8plus\".to_string());\n+    base.exe_allocation_crate = None;\n+\n+    Ok(Target {\n+        llvm_target: \"sparc-unknown-linux-gnu\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-p:32:32-i64:64-f128:64-n32-S64\".to_string(),\n+        arch: \"sparc\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "ee0f2415bd80861626584d3e61bb92b7b76eb15c", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 54, "deletions": 52, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -40,7 +40,7 @@ use rustc::ty::layout::{self, Align, Size, TyLayout};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n \n use libc::c_uint;\n-use std::{cmp, iter};\n+use std::cmp;\n \n pub use syntax::abi::Abi;\n pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n@@ -279,30 +279,6 @@ impl Uniform {\n     pub fn align(&self, cx: &CodegenCx) -> Align {\n         self.unit.align(cx)\n     }\n-\n-    pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n-        let llunit = self.unit.llvm_type(cx);\n-\n-        if self.total <= self.unit.size {\n-            return llunit;\n-        }\n-\n-        let count = self.total.bytes() / self.unit.size.bytes();\n-        let rem_bytes = self.total.bytes() % self.unit.size.bytes();\n-\n-        if rem_bytes == 0 {\n-            return Type::array(&llunit, count);\n-        }\n-\n-        // Only integers can be really split further.\n-        assert_eq!(self.unit.kind, RegKind::Integer);\n-\n-        let args: Vec<_> = (0..count).map(|_| llunit)\n-            .chain(iter::once(Type::ix(cx, rem_bytes * 8)))\n-            .collect();\n-\n-        Type::struct_(cx, &args, false)\n-    }\n }\n \n pub trait LayoutExt<'tcx> {\n@@ -405,55 +381,81 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum CastTarget {\n-    Uniform(Uniform),\n-    Pair(Reg, Reg)\n+pub struct CastTarget {\n+    pub prefix: [Option<RegKind>; 8],\n+    pub prefix_chunk: Size,\n+    pub rest: Uniform,\n }\n \n impl From<Reg> for CastTarget {\n     fn from(unit: Reg) -> CastTarget {\n-        CastTarget::Uniform(Uniform::from(unit))\n+        CastTarget::from(Uniform::from(unit))\n     }\n }\n \n impl From<Uniform> for CastTarget {\n     fn from(uniform: Uniform) -> CastTarget {\n-        CastTarget::Uniform(uniform)\n+        CastTarget {\n+            prefix: [None; 8],\n+            prefix_chunk: Size::from_bytes(0),\n+            rest: uniform\n+        }\n     }\n }\n \n impl CastTarget {\n-    pub fn size(&self, cx: &CodegenCx) -> Size {\n-        match *self {\n-            CastTarget::Uniform(u) => u.total,\n-            CastTarget::Pair(a, b) => {\n-                (a.size.abi_align(a.align(cx)) + b.size)\n-                    .abi_align(self.align(cx))\n-            }\n+    pub fn pair(a: Reg, b: Reg) -> CastTarget {\n+        CastTarget {\n+            prefix: [Some(a.kind), None, None, None, None, None, None, None],\n+            prefix_chunk: a.size,\n+            rest: Uniform::from(b)\n         }\n     }\n \n+    pub fn size(&self, cx: &CodegenCx) -> Size {\n+        (self.prefix_chunk * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n+            .abi_align(self.rest.align(cx)) + self.rest.total\n+    }\n+\n     pub fn align(&self, cx: &CodegenCx) -> Align {\n-        match *self {\n-            CastTarget::Uniform(u) => u.align(cx),\n-            CastTarget::Pair(a, b) => {\n-                cx.data_layout().aggregate_align\n-                    .max(a.align(cx))\n-                    .max(b.align(cx))\n-            }\n-        }\n+        self.prefix.iter()\n+            .filter_map(|x| x.map(|kind| Reg { kind: kind, size: self.prefix_chunk }.align(cx)))\n+            .fold(cx.data_layout().aggregate_align.max(self.rest.align(cx)),\n+                |acc, align| acc.max(align))\n     }\n \n     pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n-        match *self {\n-            CastTarget::Uniform(u) => u.llvm_type(cx),\n-            CastTarget::Pair(a, b) => {\n-                Type::struct_(cx, &[\n-                    a.llvm_type(cx),\n-                    b.llvm_type(cx)\n-                ], false)\n+        let rest_ll_unit = self.rest.unit.llvm_type(cx);\n+        let rest_count = self.rest.total.bytes() / self.rest.unit.size.bytes();\n+        let rem_bytes = self.rest.total.bytes() % self.rest.unit.size.bytes();\n+\n+        if self.prefix.iter().all(|x| x.is_none()) {\n+            // Simplify to a single unit when there is no prefix and size <= unit size\n+            if self.rest.total <= self.rest.unit.size {\n+                return rest_ll_unit;\n+            }\n+\n+            // Simplify to array when all chunks are the same size and type\n+            if rem_bytes == 0 {\n+                return Type::array(&rest_ll_unit, rest_count);\n             }\n         }\n+\n+        // Create list of fields in the main structure\n+        let mut args: Vec<_> =\n+            self.prefix.iter().flat_map(|option_kind| option_kind.map(\n+                    |kind| Reg { kind: kind, size: self.prefix_chunk }.llvm_type(cx)))\n+            .chain((0..rest_count).map(|_| rest_ll_unit))\n+            .collect();\n+\n+        // Append final integer\n+        if rem_bytes != 0 {\n+            // Only integers can be really split further.\n+            assert_eq!(self.rest.unit.kind, RegKind::Integer);\n+            args.push(Type::ix(cx, rem_bytes * 8));\n+        }\n+\n+        Type::struct_(cx, &args, false)\n     }\n }\n "}, {"sha": "0bccef1e62a8e186126bd6cc4593d806e3d6064f", "filename": "src/librustc_trans/back/command.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fcommand.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -109,6 +109,10 @@ impl Command {\n \n     // extensions\n \n+    pub fn get_args(&self) -> &[OsString] {\n+        &self.args\n+    }\n+\n     pub fn take_args(&mut self) -> Vec<OsString> {\n         mem::replace(&mut self.args, Vec::new())\n     }"}, {"sha": "d7c75dea8d04eb021275c541018f1c4f727ee4e6", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -700,9 +700,6 @@ fn link_natively(sess: &Session,\n         prog = time(sess.time_passes(), \"running linker\", || {\n             exec_linker(sess, &mut cmd, tmpdir)\n         });\n-        if !retry_on_segfault || i > 3 {\n-            break\n-        }\n         let output = match prog {\n             Ok(ref output) => output,\n             Err(_) => break,\n@@ -713,6 +710,31 @@ fn link_natively(sess: &Session,\n         let mut out = output.stderr.clone();\n         out.extend(&output.stdout);\n         let out = String::from_utf8_lossy(&out);\n+\n+        // Check to see if the link failed with \"unrecognized command line option:\n+        // '-no-pie'\" for gcc or \"unknown argument: '-no-pie'\" for clang. If so,\n+        // reperform the link step without the -no-pie option. This is safe because\n+        // if the linker doesn't support -no-pie then it should not default to\n+        // linking executables as pie. Different versions of gcc seem to use\n+        // different quotes in the error message so don't check for them.\n+        if sess.target.target.options.linker_is_gnu &&\n+           (out.contains(\"unrecognized command line option\") ||\n+            out.contains(\"unknown argument\")) &&\n+           out.contains(\"-no-pie\") &&\n+           cmd.get_args().iter().any(|e| e.to_string_lossy() == \"-no-pie\") {\n+            info!(\"linker output: {:?}\", out);\n+            warn!(\"Linker does not support -no-pie command line option. Retrying without.\");\n+            for arg in cmd.take_args() {\n+                if arg.to_string_lossy() != \"-no-pie\" {\n+                    cmd.arg(arg);\n+                }\n+            }\n+            info!(\"{:?}\", &cmd);\n+            continue;\n+        }\n+        if !retry_on_segfault || i > 3 {\n+            break\n+        }\n         let msg_segv = \"clang: error: unable to execute command: Segmentation fault: 11\";\n         let msg_bus  = \"clang: error: unable to execute command: Bus error: 10\";\n         if !(out.contains(msg_segv) || out.contains(msg_bus)) {\n@@ -949,16 +971,30 @@ fn link_args(cmd: &mut Linker,\n \n     let used_link_args = &trans.crate_info.link_args;\n \n-    if crate_type == config::CrateTypeExecutable &&\n-       t.options.position_independent_executables {\n-        let empty_vec = Vec::new();\n-        let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n-        let more_args = &sess.opts.cg.link_arg;\n-        let mut args = args.iter().chain(more_args.iter()).chain(used_link_args.iter());\n-\n-        if get_reloc_model(sess) == llvm::RelocMode::PIC\n-            && !sess.crt_static() && !args.any(|x| *x == \"-static\") {\n+    if crate_type == config::CrateTypeExecutable {\n+        let mut position_independent_executable = false;\n+\n+        if t.options.position_independent_executables {\n+            let empty_vec = Vec::new();\n+            let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n+            let more_args = &sess.opts.cg.link_arg;\n+            let mut args = args.iter().chain(more_args.iter()).chain(used_link_args.iter());\n+\n+            if get_reloc_model(sess) == llvm::RelocMode::PIC\n+                && !sess.crt_static() && !args.any(|x| *x == \"-static\") {\n+                position_independent_executable = true;\n+            }\n+        }\n+\n+        if position_independent_executable {\n             cmd.position_independent_executable();\n+        } else {\n+            // recent versions of gcc can be configured to generate position\n+            // independent executables by default. We have to pass -no-pie to\n+            // explicitly turn that off.\n+            if sess.target.target.options.linker_is_gnu {\n+                cmd.no_position_independent_executable();\n+            }\n         }\n     }\n "}, {"sha": "7e7811c56c74e39f1b9a476a235637920476cda2", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -105,6 +105,7 @@ pub trait Linker {\n     fn add_object(&mut self, path: &Path);\n     fn gc_sections(&mut self, keep_metadata: bool);\n     fn position_independent_executable(&mut self);\n+    fn no_position_independent_executable(&mut self);\n     fn partial_relro(&mut self);\n     fn full_relro(&mut self);\n     fn optimize(&mut self);\n@@ -179,6 +180,7 @@ impl<'a> Linker for GccLinker<'a> {\n     fn output_filename(&mut self, path: &Path) { self.cmd.arg(\"-o\").arg(path); }\n     fn add_object(&mut self, path: &Path) { self.cmd.arg(path); }\n     fn position_independent_executable(&mut self) { self.cmd.arg(\"-pie\"); }\n+    fn no_position_independent_executable(&mut self) { self.cmd.arg(\"-no-pie\"); }\n     fn partial_relro(&mut self) { self.linker_arg(\"-z,relro\"); }\n     fn full_relro(&mut self) { self.linker_arg(\"-z,relro,-z,now\"); }\n     fn build_static_executable(&mut self) { self.cmd.arg(\"-static\"); }\n@@ -439,6 +441,10 @@ impl<'a> Linker for MsvcLinker<'a> {\n         // noop\n     }\n \n+    fn no_position_independent_executable(&mut self) {\n+        // noop\n+    }\n+\n     fn partial_relro(&mut self) {\n         // noop\n     }\n@@ -647,6 +653,10 @@ impl<'a> Linker for EmLinker<'a> {\n         // noop\n     }\n \n+    fn no_position_independent_executable(&mut self) {\n+        // noop\n+    }\n+\n     fn partial_relro(&mut self) {\n         // noop\n     }"}, {"sha": "94bf53cee1edbd67b90885dccc28d44ecb482268", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 133, "deletions": 23, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -8,50 +8,160 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n+use abi::{ArgAttribute, ArgType, CastTarget, FnType, LayoutExt, PassMode, Reg, RegKind, Uniform};\n use context::CodegenCx;\n+use rustc::ty::layout::{self, Size};\n \n-use rustc::ty::layout::Size;\n+fn extend_integer_width_mips(arg: &mut ArgType, bits: u64) {\n+    // Always sign extend u32 values on 64-bit mips\n+    if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n+        if let layout::Int(i, signed) = scalar.value {\n+            if !signed && i.size().bits() == 32 {\n+                if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                    attrs.set(ArgAttribute::SExt);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    arg.extend_integer_width_to(bits);\n+}\n+\n+fn bits_to_int_reg(bits: u64) -> Reg {\n+    if bits <= 8 {\n+        Reg::i8()\n+    } else if bits <= 16 {\n+        Reg::i16()\n+    } else if bits <= 32 {\n+        Reg::i32()\n+    } else {\n+        Reg::i64()\n+    }\n+}\n \n-fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                             ret: &mut ArgType<'tcx>,\n-                             offset: &mut Size) {\n+fn float_reg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &ArgType<'tcx>, i: usize) -> Option<Reg> {\n+    match ret.layout.field(cx, i).abi {\n+        layout::Abi::Scalar(ref scalar) => match scalar.value {\n+            layout::F32 => Some(Reg::f32()),\n+            layout::F64 => Some(Reg::f64()),\n+            _ => None\n+        },\n+        _ => None\n+    }\n+}\n+\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if !ret.layout.is_aggregate() {\n-        ret.extend_integer_width_to(64);\n+        extend_integer_width_mips(ret, 64);\n+        return;\n+    }\n+\n+    let size = ret.layout.size;\n+    let bits = size.bits();\n+    if bits <= 128 {\n+        // Unlike other architectures which return aggregates in registers, MIPS n64 limits the\n+        // use of float registers to structures (not unions) containing exactly one or two\n+        // float fields.\n+\n+        if let layout::FieldPlacement::Arbitrary { .. } = ret.layout.fields {\n+            if ret.layout.fields.count() == 1 {\n+                if let Some(reg) = float_reg(cx, ret, 0) {\n+                    ret.cast_to(reg);\n+                    return;\n+                }\n+            } else if ret.layout.fields.count() == 2 {\n+                if let Some(reg0) = float_reg(cx, ret, 0) {\n+                    if let Some(reg1) = float_reg(cx, ret, 1) {\n+                        ret.cast_to(CastTarget::pair(reg0, reg1));\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Cast to a uniform int structure\n+        ret.cast_to(Uniform {\n+            unit: bits_to_int_reg(bits),\n+            total: size\n+        });\n     } else {\n         ret.make_indirect();\n-        *offset += cx.tcx.data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n+fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if !arg.layout.is_aggregate() {\n+        extend_integer_width_mips(arg, 64);\n+        return;\n+    }\n+\n     let dl = &cx.tcx.data_layout;\n     let size = arg.layout.size;\n-    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n+    let mut prefix = [None; 8];\n+    let mut prefix_index = 0;\n \n-    if arg.layout.is_aggregate() {\n-        arg.cast_to(Uniform {\n-            unit: Reg::i64(),\n-            total: size\n-        });\n-        if !offset.is_abi_aligned(align) {\n-            arg.pad_with(Reg::i64());\n+    match arg.layout.fields {\n+        layout::FieldPlacement::Array { .. } => {\n+            // Arrays are passed indirectly\n+            arg.make_indirect();\n+            return;\n         }\n-    } else {\n-        arg.extend_integer_width_to(64);\n-    }\n+        layout::FieldPlacement::Union(_) => {\n+            // Unions and are always treated as a series of 64-bit integer chunks\n+        },\n+        layout::FieldPlacement::Arbitrary { .. } => {\n+            // Structures are split up into a series of 64-bit integer chunks, but any aligned\n+            // doubles not part of another aggregate are passed as floats.\n+            let mut last_offset = Size::from_bytes(0);\n+\n+            for i in 0..arg.layout.fields.count() {\n+                let field = arg.layout.field(cx, i);\n+                let offset = arg.layout.fields.offset(i);\n+\n+                // We only care about aligned doubles\n+                if let layout::Abi::Scalar(ref scalar) = field.abi {\n+                    if let layout::F64 = scalar.value {\n+                        if offset.is_abi_aligned(dl.f64_align) {\n+                            // Insert enough integers to cover [last_offset, offset)\n+                            assert!(last_offset.is_abi_aligned(dl.f64_align));\n+                            for _ in 0..((offset - last_offset).bits() / 64)\n+                                .min((prefix.len() - prefix_index) as u64) {\n+\n+                                prefix[prefix_index] = Some(RegKind::Integer);\n+                                prefix_index += 1;\n+                            }\n+\n+                            if prefix_index == prefix.len() {\n+                                break;\n+                            }\n+\n+                            prefix[prefix_index] = Some(RegKind::Float);\n+                            prefix_index += 1;\n+                            last_offset = offset + Reg::f64().size;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    };\n \n-    *offset = offset.abi_align(align) + size.abi_align(align);\n+    // Extract first 8 chunks as the prefix\n+    let rest_size = size - Size::from_bytes(8) * prefix_index as u64;\n+    arg.cast_to(CastTarget {\n+        prefix: prefix,\n+        prefix_chunk: Size::from_bytes(8),\n+        rest: Uniform { unit: Reg::i64(), total: rest_size }\n+    });\n }\n \n pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n-    let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n+        classify_ret_ty(cx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(cx, arg, &mut offset);\n+        classify_arg_ty(cx, arg);\n     }\n }"}, {"sha": "7eadaa7f493a3f52b63c9699123f5e08c478b097", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -171,7 +171,7 @@ fn cast_target(cls: &[Option<Class>], size: Size) -> CastTarget {\n     let mut target = CastTarget::from(lo);\n     if size > offset {\n         if let Some(hi) = reg_component(cls, &mut i, size - offset) {\n-            target = CastTarget::Pair(lo, hi);\n+            target = CastTarget::pair(lo, hi);\n         }\n     }\n     assert_eq!(reg_component(cls, &mut i, Size::from_bytes(0)), None);"}, {"sha": "6271dcdfb2433c42aafb9580a274eca15c44bf77", "filename": "src/librustc_trans/llvm_util.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -75,26 +75,25 @@ unsafe fn configure_llvm(sess: &Session) {\n                                  llvm_args.as_ptr());\n }\n \n-// WARNING: the features must be known to LLVM or the feature\n-// detection code will walk past the end of the feature array,\n-// leading to crashes.\n+// WARNING: the features after applying `to_llvm_feature` must be known\n+// to LLVM or the feature detection code will walk past the end of the feature\n+// array, leading to crashes.\n \n const ARM_WHITELIST: &'static [&'static str] = &[\"neon\", \"v7\", \"vfp2\", \"vfp3\", \"vfp4\"];\n \n const AARCH64_WHITELIST: &'static [&'static str] = &[\"neon\", \"v7\"];\n \n-const X86_WHITELIST: &'static [&'static str] = &[\"avx\", \"avx2\", \"bmi\", \"bmi2\", \"sse\",\n-                                                 \"sse2\", \"sse3\", \"sse4.1\", \"sse4.2\",\n-                                                 \"ssse3\", \"tbm\", \"lzcnt\", \"popcnt\",\n-                                                 \"sse4a\", \"rdrnd\", \"rdseed\", \"fma\",\n-                                                 \"xsave\", \"xsaveopt\", \"xsavec\",\n-                                                 \"xsaves\", \"aes\", \"pclmulqdq\",\n-                                                 \"avx512bw\", \"avx512cd\",\n-                                                 \"avx512dq\", \"avx512er\",\n-                                                 \"avx512f\", \"avx512ifma\",\n-                                                 \"avx512pf\", \"avx512vbmi\",\n-                                                 \"avx512vl\", \"avx512vpopcntdq\",\n-                                                 \"mmx\", \"fxsr\"];\n+const X86_WHITELIST: &'static [&'static str] = &[\"aes\", \"avx\", \"avx2\", \"avx512bw\",\n+                                                 \"avx512cd\", \"avx512dq\", \"avx512er\",\n+                                                 \"avx512f\", \"avx512ifma\", \"avx512pf\",\n+                                                 \"avx512vbmi\", \"avx512vl\", \"avx512vpopcntdq\",\n+                                                 \"bmi\", \"bmi2\", \"fma\", \"fxsr\",\n+                                                 \"lzcnt\", \"mmx\", \"pclmulqdq\",\n+                                                 \"popcnt\", \"rdrand\", \"rdseed\",\n+                                                 \"sse\", \"sse2\", \"sse3\", \"sse4.1\",\n+                                                 \"sse4.2\", \"sse4a\", \"ssse3\",\n+                                                 \"tbm\", \"xsave\", \"xsavec\",\n+                                                 \"xsaveopt\", \"xsaves\"];\n \n const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\", \"hvx-double\"];\n \n@@ -108,6 +107,7 @@ const MIPS_WHITELIST: &'static [&'static str] = &[\"msa\"];\n pub fn to_llvm_feature(s: &str) -> &str {\n     match s {\n         \"pclmulqdq\" => \"pclmul\",\n+        \"rdrand\" => \"rdrnd\",\n         s => s,\n     }\n }"}, {"sha": "430c9df396a5ec4b61d04a53efa5c9df9fa44354", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -245,7 +245,7 @@ pub trait AsciiExt {\n     fn is_ascii_punctuation(&self) -> bool { unimplemented!(); }\n \n     /// Checks if the value is an ASCII graphic character:\n-    /// U+0021 '@' ... U+007E '~'.\n+    /// U+0021 '!' ... U+007E '~'.\n     /// For strings, true if all characters in the string are\n     /// ASCII graphic characters.\n     ///"}, {"sha": "4dfdc23ebee53120ac1d225d6fa10f5d2ca7c950", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -2082,7 +2082,6 @@ impl<'a, K, V> Entry<'a, K, V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(entry_and_modify)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<&str, u32> = HashMap::new();\n@@ -2097,7 +2096,7 @@ impl<'a, K, V> Entry<'a, K, V> {\n     ///    .or_insert(42);\n     /// assert_eq!(map[\"poneyland\"], 43);\n     /// ```\n-    #[unstable(feature = \"entry_and_modify\", issue = \"44733\")]\n+    #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n     pub fn and_modify<F>(self, mut f: F) -> Self\n         where F: FnMut(&mut V)\n     {"}, {"sha": "7931d14ed11662fd9998880ffbc99db88236ec77", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -1545,6 +1545,26 @@ mod tests {\n         drop(listener);\n     }\n \n+    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n+    // when passed zero Durations\n+    #[test]\n+    fn test_timeout_zero_duration() {\n+        let addr = next_test_ip4();\n+\n+        let listener = t!(TcpListener::bind(&addr));\n+        let stream = t!(TcpStream::connect(&addr));\n+\n+        let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n+        let err = result.unwrap_err();\n+        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+        let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n+        let err = result.unwrap_err();\n+        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+        drop(listener);\n+    }\n+\n     #[test]\n     fn nodelay() {\n         let addr = next_test_ip4();"}, {"sha": "b49cc78ac40735de7f5a80190d4dd2fd236681d3", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -1024,6 +1024,23 @@ mod tests {\n         assert!(start.elapsed() > Duration::from_millis(400));\n     }\n \n+    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n+    // when passed zero Durations\n+    #[test]\n+    fn test_timeout_zero_duration() {\n+        let addr = next_test_ip4();\n+\n+        let socket = t!(UdpSocket::bind(&addr));\n+\n+        let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+        let err = result.unwrap_err();\n+        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+        let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+        let err = result.unwrap_err();\n+        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+    }\n+\n     #[test]\n     fn connect_send_recv() {\n         let addr = next_test_ip4();"}, {"sha": "3014283da5b271edc067f78d4c0df488a36e617a", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 214, "deletions": 2, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -14,7 +14,7 @@ use sync::{mutex, MutexGuard, PoisonError};\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n use sys_common::poison::{self, LockResult};\n-use time::Duration;\n+use time::{Duration, Instant};\n \n /// A type indicating whether a timed wait on a condition variable returned\n /// due to a time out or not.\n@@ -221,6 +221,64 @@ impl Condvar {\n         }\n     }\n \n+    /// Blocks the current thread until this condition variable receives a\n+    /// notification and the required condition is met. Spurious wakeups are\n+    /// ignored and this function will only return once the condition has been\n+    /// met.\n+    ///\n+    /// This function will atomically unlock the mutex specified (represented by\n+    /// `guard`) and block the current thread. This means that any calls\n+    /// to [`notify_one`] or [`notify_all`] which happen logically after the\n+    /// mutex is unlocked are candidates to wake this thread up. When this\n+    /// function call returns, the lock specified will have been re-acquired.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return an error if the mutex being waited on is\n+    /// poisoned when this thread re-acquires the lock. For more information,\n+    /// see information about [poisoning] on the [`Mutex`] type.\n+    ///\n+    /// [`notify_one`]: #method.notify_one\n+    /// [`notify_all`]: #method.notify_all\n+    /// [poisoning]: ../sync/struct.Mutex.html#poisoning\n+    /// [`Mutex`]: ../sync/struct.Mutex.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(wait_until)]\n+    ///\n+    /// use std::sync::{Arc, Mutex, Condvar};\n+    /// use std::thread;\n+    ///\n+    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    /// let pair2 = pair.clone();\n+    ///\n+    /// thread::spawn(move|| {\n+    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let mut started = lock.lock().unwrap();\n+    ///     *started = true;\n+    ///     // We notify the condvar that the value has changed.\n+    ///     cvar.notify_one();\n+    /// });\n+    ///\n+    /// // Wait for the thread to start up.\n+    /// let &(ref lock, ref cvar) = &*pair;\n+    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// let _guard = cvar.wait_until(lock.lock().unwrap(), |started| { *started }).unwrap();\n+    /// ```\n+    #[unstable(feature = \"wait_until\", issue = \"47960\")]\n+    pub fn wait_until<'a, T, F>(&self, mut guard: MutexGuard<'a, T>,\n+                                mut condition: F)\n+                                -> LockResult<MutexGuard<'a, T>>\n+                                where F: FnMut(&mut T) -> bool {\n+        while !condition(&mut *guard) {\n+            guard = self.wait(guard)?;\n+        }\n+        Ok(guard)\n+    }\n+\n+\n     /// Waits on this condition variable for a notification, timing out after a\n     /// specified duration.\n     ///\n@@ -295,7 +353,15 @@ impl Condvar {\n     ///\n     /// Note that the best effort is made to ensure that the time waited is\n     /// measured with a monotonic clock, and not affected by the changes made to\n-    /// the system time.\n+    /// the system time.  This function is susceptible to spurious wakeups.\n+    /// Condition variables normally have a boolean predicate associated with\n+    /// them, and the predicate must always be checked each time this function\n+    /// returns to protect against spurious wakeups.  Additionally, it is\n+    /// typically desirable for the time-out to not exceed some duration in\n+    /// spite of spurious wakes, thus the sleep-duration is decremented by the\n+    /// amount slept.  Alternatively, use the `wait_timeout_until` method\n+    /// to wait until a condition is met with a total time-out regardless\n+    /// of spurious wakes.\n     ///\n     /// The returned [`WaitTimeoutResult`] value indicates if the timeout is\n     /// known to have elapsed.\n@@ -304,6 +370,7 @@ impl Condvar {\n     /// returns, regardless of whether the timeout elapsed or not.\n     ///\n     /// [`wait`]: #method.wait\n+    /// [`wait_timeout_until`]: #method.wait_timeout_until\n     /// [`WaitTimeoutResult`]: struct.WaitTimeoutResult.html\n     ///\n     /// # Examples\n@@ -355,6 +422,80 @@ impl Condvar {\n         }\n     }\n \n+    /// Waits on this condition variable for a notification, timing out after a\n+    /// specified duration.  Spurious wakes will not cause this function to\n+    /// return.\n+    ///\n+    /// The semantics of this function are equivalent to [`wait_until`] except\n+    /// that the thread will be blocked for roughly no longer than `dur`. This\n+    /// method should not be used for precise timing due to anomalies such as\n+    /// preemption or platform differences that may not cause the maximum\n+    /// amount of time waited to be precisely `dur`.\n+    ///\n+    /// Note that the best effort is made to ensure that the time waited is\n+    /// measured with a monotonic clock, and not affected by the changes made to\n+    /// the system time.\n+    ///\n+    /// The returned [`WaitTimeoutResult`] value indicates if the timeout is\n+    /// known to have elapsed without the condition being met.\n+    ///\n+    /// Like [`wait_until`], the lock specified will be re-acquired when this\n+    /// function returns, regardless of whether the timeout elapsed or not.\n+    ///\n+    /// [`wait_until`]: #method.wait_until\n+    /// [`wait_timeout`]: #method.wait_timeout\n+    /// [`WaitTimeoutResult`]: struct.WaitTimeoutResult.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(wait_timeout_until)]\n+    ///\n+    /// use std::sync::{Arc, Mutex, Condvar};\n+    /// use std::thread;\n+    /// use std::time::Duration;\n+    ///\n+    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    /// let pair2 = pair.clone();\n+    ///\n+    /// thread::spawn(move|| {\n+    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let mut started = lock.lock().unwrap();\n+    ///     *started = true;\n+    ///     // We notify the condvar that the value has changed.\n+    ///     cvar.notify_one();\n+    /// });\n+    ///\n+    /// // wait for the thread to start up\n+    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let result = cvar.wait_timeout_until(\n+    ///     lock.lock().unwrap(),\n+    ///     Duration::from_millis(100),\n+    ///     |&mut started| started,\n+    /// ).unwrap();\n+    /// if result.1.timed_out() {\n+    ///     // timed-out without the condition ever evaluating to true.\n+    /// }\n+    /// // access the locked mutex via result.0\n+    /// ```\n+    #[unstable(feature = \"wait_timeout_until\", issue = \"47960\")]\n+    pub fn wait_timeout_until<'a, T, F>(&self, mut guard: MutexGuard<'a, T>,\n+                                        dur: Duration, mut condition: F)\n+                                        -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)>\n+                                        where F: FnMut(&mut T) -> bool {\n+        let start = Instant::now();\n+        loop {\n+            if condition(&mut *guard) {\n+                return Ok((guard, WaitTimeoutResult(false)));\n+            }\n+            let timeout = match dur.checked_sub(start.elapsed()) {\n+                Some(timeout) => timeout,\n+                None => return Ok((guard, WaitTimeoutResult(true))),\n+            };\n+            guard = self.wait_timeout(guard, timeout)?.0;\n+        }\n+    }\n+\n     /// Wakes up one blocked thread on this condvar.\n     ///\n     /// If there is a blocked thread on this condition variable, then it will\n@@ -480,6 +621,7 @@ impl Drop for Condvar {\n \n #[cfg(test)]\n mod tests {\n+    /// #![feature(wait_until)]\n     use sync::mpsc::channel;\n     use sync::{Condvar, Mutex, Arc};\n     use sync::atomic::{AtomicBool, Ordering};\n@@ -548,6 +690,29 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n+    fn wait_until() {\n+        let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+        let pair2 = pair.clone();\n+\n+        // Inside of our lock, spawn a new thread, and then wait for it to start.\n+        thread::spawn(move|| {\n+            let &(ref lock, ref cvar) = &*pair2;\n+            let mut started = lock.lock().unwrap();\n+            *started = true;\n+            // We notify the condvar that the value has changed.\n+            cvar.notify_one();\n+        });\n+\n+        // Wait for the thread to start up.\n+        let &(ref lock, ref cvar) = &*pair;\n+        let guard = cvar.wait_until(lock.lock().unwrap(), |started| {\n+            *started\n+        });\n+        assert!(*guard.unwrap());\n+    }\n+\n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn wait_timeout_wait() {\n@@ -567,6 +732,53 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n+    fn wait_timeout_until_wait() {\n+        let m = Arc::new(Mutex::new(()));\n+        let c = Arc::new(Condvar::new());\n+\n+        let g = m.lock().unwrap();\n+        let (_g, wait) = c.wait_timeout_until(g, Duration::from_millis(1), |_| { false }).unwrap();\n+        // no spurious wakeups. ensure it timed-out\n+        assert!(wait.timed_out());\n+    }\n+\n+    #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n+    fn wait_timeout_until_instant_satisfy() {\n+        let m = Arc::new(Mutex::new(()));\n+        let c = Arc::new(Condvar::new());\n+\n+        let g = m.lock().unwrap();\n+        let (_g, wait) = c.wait_timeout_until(g, Duration::from_millis(0), |_| { true }).unwrap();\n+        // ensure it didn't time-out even if we were not given any time.\n+        assert!(!wait.timed_out());\n+    }\n+\n+    #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n+    fn wait_timeout_until_wake() {\n+        let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+        let pair_copy = pair.clone();\n+\n+        let &(ref m, ref c) = &*pair;\n+        let g = m.lock().unwrap();\n+        let _t = thread::spawn(move || {\n+            let &(ref lock, ref cvar) = &*pair_copy;\n+            let mut started = lock.lock().unwrap();\n+            thread::sleep(Duration::from_millis(1));\n+            *started = true;\n+            cvar.notify_one();\n+        });\n+        let (g2, wait) = c.wait_timeout_until(g, Duration::from_millis(u64::MAX), |&mut notified| {\n+            notified\n+        }).unwrap();\n+        // ensure it didn't time-out even if we were not given any time.\n+        assert!(!wait.timed_out());\n+        assert!(*g2);\n+    }\n+\n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn wait_timeout_wake() {"}, {"sha": "b5664908479cfbc342cb3a0dcceeeaa3bc1d581e", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use cmp;\n-use io::{Error, ErrorKind, Result};\n+use io::{self, Error, ErrorKind, Result};\n use mem;\n use net::{SocketAddr, Shutdown};\n use path::Path;\n@@ -130,6 +130,10 @@ impl TcpStream {\n     pub fn set_read_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n         let file = self.0.dup(b\"read_timeout\")?;\n         if let Some(duration) = duration_option {\n+            if duration.as_secs() == 0 && duration.subsec_nanos() == 0 {\n+                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                          \"cannot set a 0 duration timeout\"));\n+            }\n             file.write(&TimeSpec {\n                 tv_sec: duration.as_secs() as i64,\n                 tv_nsec: duration.subsec_nanos() as i32\n@@ -143,6 +147,10 @@ impl TcpStream {\n     pub fn set_write_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n         let file = self.0.dup(b\"write_timeout\")?;\n         if let Some(duration) = duration_option {\n+            if duration.as_secs() == 0 && duration.subsec_nanos() == 0 {\n+                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                          \"cannot set a 0 duration timeout\"));\n+            }\n             file.write(&TimeSpec {\n                 tv_sec: duration.as_secs() as i64,\n                 tv_nsec: duration.subsec_nanos() as i32"}, {"sha": "2ed67bd2836f26fde2dc9006b799c776df7ab3f8", "filename": "src/libstd/sys/redox/net/udp.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -10,7 +10,7 @@\n \n use cell::UnsafeCell;\n use cmp;\n-use io::{Error, ErrorKind, Result};\n+use io::{self, Error, ErrorKind, Result};\n use mem;\n use net::{SocketAddr, Ipv4Addr, Ipv6Addr};\n use path::Path;\n@@ -179,6 +179,10 @@ impl UdpSocket {\n     pub fn set_read_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n         let file = self.0.dup(b\"read_timeout\")?;\n         if let Some(duration) = duration_option {\n+            if duration.as_secs() == 0 && duration.subsec_nanos() == 0 {\n+                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                          \"cannot set a 0 duration timeout\"));\n+            }\n             file.write(&TimeSpec {\n                 tv_sec: duration.as_secs() as i64,\n                 tv_nsec: duration.subsec_nanos() as i32\n@@ -192,6 +196,10 @@ impl UdpSocket {\n     pub fn set_write_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n         let file = self.0.dup(b\"write_timeout\")?;\n         if let Some(duration) = duration_option {\n+            if duration.as_secs() == 0 && duration.subsec_nanos() == 0 {\n+                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                          \"cannot set a 0 duration timeout\"));\n+            }\n             file.write(&TimeSpec {\n                 tv_sec: duration.as_secs() as i64,\n                 tv_nsec: duration.subsec_nanos() as i32"}, {"sha": "ab4aef1a582343dd002c7bfa3007f73b117d6ecb", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -1410,7 +1410,7 @@ impl IntoRawFd for UnixDatagram {\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod test {\n     use thread;\n-    use io;\n+    use io::{self, ErrorKind};\n     use io::prelude::*;\n     use time::Duration;\n     use sys_common::io::test::tmpdir;\n@@ -1613,6 +1613,27 @@ mod test {\n         assert!(kind == io::ErrorKind::WouldBlock || kind == io::ErrorKind::TimedOut);\n     }\n \n+    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n+    // when passed zero Durations\n+    #[test]\n+    fn test_unix_stream_timeout_zero_duration() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+\n+        let listener = or_panic!(UnixListener::bind(&socket_path));\n+        let stream = or_panic!(UnixStream::connect(&socket_path));\n+\n+        let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n+        let err = result.unwrap_err();\n+        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+        let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n+        let err = result.unwrap_err();\n+        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+        drop(listener);\n+    }\n+\n     #[test]\n     fn test_unix_datagram() {\n         let dir = tmpdir();\n@@ -1712,6 +1733,24 @@ mod test {\n         thread.join().unwrap();\n     }\n \n+    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n+    // when passed zero Durations\n+    #[test]\n+    fn test_unix_datagram_timeout_zero_duration() {\n+        let dir = tmpdir();\n+        let path = dir.path().join(\"sock\");\n+\n+        let datagram = or_panic!(UnixDatagram::bind(&path));\n+\n+        let result = datagram.set_write_timeout(Some(Duration::new(0, 0)));\n+        let err = result.unwrap_err();\n+        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+        let result = datagram.set_read_timeout(Some(Duration::new(0, 0)));\n+        let err = result.unwrap_err();\n+        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+    }\n+\n     #[test]\n     fn abstract_namespace_not_allowed() {\n         assert!(UnixStream::connect(\"\\0asdf\").is_err());"}, {"sha": "844ff7a3c12521a3d4447c5a4674e53a42a98a2e", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -1332,7 +1332,7 @@ impl char {\n     }\n \n     /// Checks if the value is an ASCII graphic character:\n-    /// U+0021 '@' ... U+007E '~'.\n+    /// U+0021 '!' ... U+007E '~'.\n     ///\n     /// # Examples\n     ///"}, {"sha": "63b8608afc7638b24ec45d24cae3a230d65ced3a", "filename": "src/test/run-make/atomic-lock-free/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Ftest%2Frun-make%2Fatomic-lock-free%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Ftest%2Frun-make%2Fatomic-lock-free%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fatomic-lock-free%2FMakefile?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -36,6 +36,8 @@ ifeq ($(filter powerpc,$(LLVM_COMPONENTS)),powerpc)\n \tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | $(CGREP) -v __atomic_fetch_add\n \t$(RUSTC) --target=powerpc64le-unknown-linux-gnu atomic_lock_free.rs\n \tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | $(CGREP) -v __atomic_fetch_add\n+endif\n+ifeq ($(filter systemz,$(LLVM_COMPONENTS)),systemz)\n \t$(RUSTC) --target=s390x-unknown-linux-gnu atomic_lock_free.rs\n \tnm \"$(TMPDIR)/libatomic_lock_free.rlib\" | $(CGREP) -v __atomic_fetch_add\n endif"}, {"sha": "a5660f8b41f8da43aeeea29deefa8607dc764bf4", "filename": "src/test/ui/macros/macro-at-most-once-rep-ambig.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "previous_filename": "src/test/compile-fail/macro-at-most-once-rep-ambig.rs"}, {"sha": "67a77e0a481d86319320b6b8a808e89177de7c99", "filename": "src/test/ui/macros/macro-at-most-once-rep-ambig.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -0,0 +1,80 @@\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:40:11\n+   |\n+40 |     foo!(a?a?a); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:41:11\n+   |\n+41 |     foo!(a?a); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:42:11\n+   |\n+42 |     foo!(a?); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:43:11\n+   |\n+43 |     baz!(a?a?a); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:44:11\n+   |\n+44 |     baz!(a?a); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:45:11\n+   |\n+45 |     baz!(a?); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:46:11\n+   |\n+46 |     baz!(a,); //~ ERROR unexpected end of macro invocation\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:47:11\n+   |\n+47 |     baz!(a?a?a,); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:48:11\n+   |\n+48 |     baz!(a?a,); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:49:11\n+   |\n+49 |     baz!(a?,); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:50:5\n+   |\n+50 |     barplus!(); //~ ERROR unexpected end of macro invocation\n+   |     ^^^^^^^^^^^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:51:15\n+   |\n+51 |     barplus!(a?); //~ ERROR unexpected end of macro invocation\n+   |               ^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:52:15\n+   |\n+52 |     barstar!(a?); //~ ERROR unexpected end of macro invocation\n+   |               ^\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "0845179532224f68f7ee66160a6768620c59ea4c", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322d7f7b97f1672bade31e1c43d5753e0e45a1a8/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=322d7f7b97f1672bade31e1c43d5753e0e45a1a8", "patch": "@@ -86,6 +86,7 @@ static TARGETS: &'static [&'static str] = &[\n     \"powerpc64-unknown-linux-gnu\",\n     \"powerpc64le-unknown-linux-gnu\",\n     \"s390x-unknown-linux-gnu\",\n+    \"sparc-unknown-linux-gnu\",\n     \"sparc64-unknown-linux-gnu\",\n     \"sparcv9-sun-solaris\",\n     \"wasm32-unknown-emscripten\","}]}