{"sha": "c3dfeba165e4d13821bba34d21cdc5242ea2fa71", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZGZlYmExNjVlNGQxMzgyMWJiYTM0ZDIxY2RjNTI0MmVhMmZhNzE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-29T10:01:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-29T10:01:26Z"}, "message": "Merge #4204\n\n4204: Use specific pattern when translating if-let-else to match r=matklad a=matklad\n\nWe *probably* should actually use the same machinery here, as we do\nfor fill match arms, but just special-casing options and results seems\nto be a good first step.\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "d9d396b0364238c68d669bd65446deea922dda24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9d396b0364238c68d669bd65446deea922dda24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3dfeba165e4d13821bba34d21cdc5242ea2fa71", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeqVB2CRBK7hj4Ov3rIwAAdHIIAF+ujNFV81588osJqBZIp2g1\najZWq/yw+qnXjJCIQl7ffcxjPIYI89mt6sJNSoSu0/GSW015xNXV0ryb+vE4R+jj\nFssMxTWKKQOyvpISQq15woWTTvg7sNb6Ea0eJ+dy9Y/S/2wnjn7G4SF2qDWpXuMV\nSgnDKErjT0vXG/xwJyO8l7PBIJhdWmtQGQqNDFz/B2OLEMvNxLoKzHf1Og9WsA4J\nDhV88ATaLy7cnwcTSDvvi+S6oQa6rGD8DJj+u/iT4frikPc3l/NkWn/81jo3FWbm\nUp+QE6LAZiVJ8KPll/FrkCwLdQIpfOM+G2jYMewbTumT0yPBhqK6V+msOwgGbEE=\n=nHRP\n-----END PGP SIGNATURE-----\n", "payload": "tree d9d396b0364238c68d669bd65446deea922dda24\nparent b1408271a35372c5e525296de985c266e63d9907\nparent 7c3c289dab46d1dbe9196549c81307f291e631f7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1588154486 +0000\ncommitter GitHub <noreply@github.com> 1588154486 +0000\n\nMerge #4204\n\n4204: Use specific pattern when translating if-let-else to match r=matklad a=matklad\n\nWe *probably* should actually use the same machinery here, as we do\nfor fill match arms, but just special-casing options and results seems\nto be a good first step.\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3dfeba165e4d13821bba34d21cdc5242ea2fa71", "html_url": "https://github.com/rust-lang/rust/commit/c3dfeba165e4d13821bba34d21cdc5242ea2fa71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3dfeba165e4d13821bba34d21cdc5242ea2fa71/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1408271a35372c5e525296de985c266e63d9907", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1408271a35372c5e525296de985c266e63d9907", "html_url": "https://github.com/rust-lang/rust/commit/b1408271a35372c5e525296de985c266e63d9907"}, {"sha": "7c3c289dab46d1dbe9196549c81307f291e631f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c3c289dab46d1dbe9196549c81307f291e631f7", "html_url": "https://github.com/rust-lang/rust/commit/7c3c289dab46d1dbe9196549c81307f291e631f7"}], "stats": {"total": 198, "additions": 144, "deletions": 54}, "files": [{"sha": "9841f6980bc3e01cff360b540e87915027eb9784", "filename": "crates/ra_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 72, "deletions": 6, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c3dfeba165e4d13821bba34d21cdc5242ea2fa71/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3dfeba165e4d13821bba34d21cdc5242ea2fa71/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=c3dfeba165e4d13821bba34d21cdc5242ea2fa71", "patch": "@@ -1,11 +1,10 @@\n use ra_fmt::unwrap_trivial_block;\n use ra_syntax::{\n-    ast::{self, make},\n+    ast::{self, edit::IndentLevel, make},\n     AstNode,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n-use ast::edit::IndentLevel;\n+use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n \n // Assist: replace_if_let_with_match\n //\n@@ -44,15 +43,21 @@ pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n         ast::ElseBranch::IfExpr(_) => return None,\n     };\n \n-    ctx.add_assist(AssistId(\"replace_if_let_with_match\"), \"Replace with match\", |edit| {\n+    let sema = ctx.sema;\n+    ctx.add_assist(AssistId(\"replace_if_let_with_match\"), \"Replace with match\", move |edit| {\n         let match_expr = {\n             let then_arm = {\n                 let then_expr = unwrap_trivial_block(then_block);\n-                make::match_arm(vec![pat], then_expr)\n+                make::match_arm(vec![pat.clone()], then_expr)\n             };\n             let else_arm = {\n+                let pattern = sema\n+                    .type_of_pat(&pat)\n+                    .and_then(|ty| TryEnum::from_ty(sema, &ty))\n+                    .map(|it| it.sad_pattern())\n+                    .unwrap_or_else(|| make::placeholder_pat().into());\n                 let else_expr = unwrap_trivial_block(else_block);\n-                make::match_arm(vec![make::placeholder_pat().into()], else_expr)\n+                make::match_arm(vec![pattern], else_expr)\n             };\n             make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]))\n         };\n@@ -68,6 +73,7 @@ pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+\n     use crate::helpers::{check_assist, check_assist_target};\n \n     #[test]\n@@ -145,4 +151,64 @@ impl VariantData {\n         }\",\n         );\n     }\n+\n+    #[test]\n+    fn special_case_option() {\n+        check_assist(\n+            replace_if_let_with_match,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn foo(x: Option<i32>) {\n+    <|>if let Some(x) = x {\n+        println!(\"{}\", x)\n+    } else {\n+        println!(\"none\")\n+    }\n+}\n+           \"#,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn foo(x: Option<i32>) {\n+    <|>match x {\n+        Some(x) => println!(\"{}\", x),\n+        None => println!(\"none\"),\n+    }\n+}\n+           \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn special_case_result() {\n+        check_assist(\n+            replace_if_let_with_match,\n+            r#\"\n+enum Result<T, E> { Ok(T), Err(E) }\n+use Result::*;\n+\n+fn foo(x: Result<i32, ()>) {\n+    <|>if let Ok(x) = x {\n+        println!(\"{}\", x)\n+    } else {\n+        println!(\"none\")\n+    }\n+}\n+           \"#,\n+            r#\"\n+enum Result<T, E> { Ok(T), Err(E) }\n+use Result::*;\n+\n+fn foo(x: Result<i32, ()>) {\n+    <|>match x {\n+        Ok(x) => println!(\"{}\", x),\n+        Err(_) => println!(\"none\"),\n+    }\n+}\n+           \"#,\n+        );\n+    }\n }"}, {"sha": "0cf23b754e8d635a06f30a509bdbf46327bee3a7", "filename": "crates/ra_assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c3dfeba165e4d13821bba34d21cdc5242ea2fa71/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3dfeba165e4d13821bba34d21cdc5242ea2fa71/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=c3dfeba165e4d13821bba34d21cdc5242ea2fa71", "patch": "@@ -1,6 +1,5 @@\n use std::iter::once;\n \n-use hir::Adt;\n use ra_syntax::{\n     ast::{\n         self,\n@@ -12,6 +11,7 @@ use ra_syntax::{\n \n use crate::{\n     assist_ctx::{Assist, AssistCtx},\n+    utils::TryEnum,\n     AssistId,\n };\n \n@@ -45,20 +45,10 @@ pub(crate) fn replace_let_with_if_let(ctx: AssistCtx) -> Option<Assist> {\n     let init = let_stmt.initializer()?;\n     let original_pat = let_stmt.pat()?;\n     let ty = ctx.sema.type_of_expr(&init)?;\n-    let enum_ = match ty.as_adt() {\n-        Some(Adt::Enum(it)) => it,\n-        _ => return None,\n-    };\n-    let happy_case =\n-        [(\"Result\", \"Ok\"), (\"Option\", \"Some\")].iter().find_map(|(known_type, happy_case)| {\n-            if &enum_.name(ctx.db).to_string() == known_type {\n-                return Some(happy_case);\n-            }\n-            None\n-        });\n+    let happy_variant = TryEnum::from_ty(ctx.sema, &ty).map(|it| it.happy_case());\n \n     ctx.add_assist(AssistId(\"replace_let_with_if_let\"), \"Replace with if-let\", |edit| {\n-        let with_placeholder: ast::Pat = match happy_case {\n+        let with_placeholder: ast::Pat = match happy_variant {\n             None => make::placeholder_pat().into(),\n             Some(var_name) => make::tuple_struct_pat(\n                 make::path_unqualified(make::path_segment(make::name_ref(var_name))),"}, {"sha": "62d4ea5220259f070d026aefdf6f04c13272a1f2", "filename": "crates/ra_assists/src/handlers/replace_unwrap_with_match.rs", "status": "modified", "additions": 18, "deletions": 34, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c3dfeba165e4d13821bba34d21cdc5242ea2fa71/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3dfeba165e4d13821bba34d21cdc5242ea2fa71/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=c3dfeba165e4d13821bba34d21cdc5242ea2fa71", "patch": "@@ -1,12 +1,11 @@\n use std::iter;\n \n use ra_syntax::{\n-    ast::{self, make},\n+    ast::{self, edit::IndentLevel, make},\n     AstNode,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n-use ast::edit::IndentLevel;\n+use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n \n // Assist: replace_unwrap_with_match\n //\n@@ -38,42 +37,27 @@ pub(crate) fn replace_unwrap_with_match(ctx: AssistCtx) -> Option<Assist> {\n     }\n     let caller = method_call.expr()?;\n     let ty = ctx.sema.type_of_expr(&caller)?;\n+    let happy_variant = TryEnum::from_ty(ctx.sema, &ty)?.happy_case();\n \n-    let type_name = ty.as_adt()?.name(ctx.sema.db).to_string();\n+    ctx.add_assist(AssistId(\"replace_unwrap_with_match\"), \"Replace unwrap with match\", |edit| {\n+        let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n+        let it = make::bind_pat(make::name(\"a\")).into();\n+        let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n \n-    for (unwrap_type, variant_name) in [(\"Result\", \"Ok\"), (\"Option\", \"Some\")].iter() {\n-        if &type_name == unwrap_type {\n-            return ctx.add_assist(\n-                AssistId(\"replace_unwrap_with_match\"),\n-                \"Replace unwrap with match\",\n-                |edit| {\n-                    let ok_path =\n-                        make::path_unqualified(make::path_segment(make::name_ref(variant_name)));\n-                    let it = make::bind_pat(make::name(\"a\")).into();\n-                    let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n+        let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n+        let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n \n-                    let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n-                    let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n+        let unreachable_call = make::unreachable_macro_call().into();\n+        let err_arm = make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n \n-                    let unreachable_call = make::unreachable_macro_call().into();\n-                    let err_arm = make::match_arm(\n-                        iter::once(make::placeholder_pat().into()),\n-                        unreachable_call,\n-                    );\n+        let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n+        let match_expr = make::expr_match(caller.clone(), match_arm_list);\n+        let match_expr = IndentLevel::from_node(method_call.syntax()).increase_indent(match_expr);\n \n-                    let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n-                    let match_expr = make::expr_match(caller.clone(), match_arm_list);\n-                    let match_expr =\n-                        IndentLevel::from_node(method_call.syntax()).increase_indent(match_expr);\n-\n-                    edit.target(method_call.syntax().text_range());\n-                    edit.set_cursor(caller.syntax().text_range().start());\n-                    edit.replace_ast::<ast::Expr>(method_call.into(), match_expr);\n-                },\n-            );\n-        }\n-    }\n-    None\n+        edit.target(method_call.syntax().text_range());\n+        edit.set_cursor(caller.syntax().text_range().start());\n+        edit.replace_ast::<ast::Expr>(method_call.into(), match_expr);\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "61f8bd1dcacd6ea004d97ede5aa068924dcace6c", "filename": "crates/ra_assists/src/utils.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c3dfeba165e4d13821bba34d21cdc5242ea2fa71/crates%2Fra_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3dfeba165e4d13821bba34d21cdc5242ea2fa71/crates%2Fra_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils.rs?ref=c3dfeba165e4d13821bba34d21cdc5242ea2fa71", "patch": "@@ -1,7 +1,9 @@\n //! Assorted functions shared by several assists.\n pub(crate) mod insert_use;\n \n-use hir::Semantics;\n+use std::iter;\n+\n+use hir::{Adt, Semantics, Type};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, make, NameOwner},\n@@ -99,3 +101,51 @@ fn invert_special_case(expr: &ast::Expr) -> Option<ast::Expr> {\n         _ => None,\n     }\n }\n+\n+#[derive(Clone, Copy)]\n+pub(crate) enum TryEnum {\n+    Result,\n+    Option,\n+}\n+\n+impl TryEnum {\n+    const ALL: [TryEnum; 2] = [TryEnum::Option, TryEnum::Result];\n+\n+    pub(crate) fn from_ty(sema: &Semantics<RootDatabase>, ty: &Type) -> Option<TryEnum> {\n+        let enum_ = match ty.as_adt() {\n+            Some(Adt::Enum(it)) => it,\n+            _ => return None,\n+        };\n+        TryEnum::ALL.iter().find_map(|&var| {\n+            if &enum_.name(sema.db).to_string() == var.type_name() {\n+                return Some(var);\n+            }\n+            None\n+        })\n+    }\n+\n+    pub(crate) fn happy_case(self) -> &'static str {\n+        match self {\n+            TryEnum::Result => \"Ok\",\n+            TryEnum::Option => \"Some\",\n+        }\n+    }\n+\n+    pub(crate) fn sad_pattern(self) -> ast::Pat {\n+        match self {\n+            TryEnum::Result => make::tuple_struct_pat(\n+                make::path_unqualified(make::path_segment(make::name_ref(\"Err\"))),\n+                iter::once(make::placeholder_pat().into()),\n+            )\n+            .into(),\n+            TryEnum::Option => make::bind_pat(make::name(\"None\")).into(),\n+        }\n+    }\n+\n+    fn type_name(self) -> &'static str {\n+        match self {\n+            TryEnum::Result => \"Result\",\n+            TryEnum::Option => \"Option\",\n+        }\n+    }\n+}"}]}