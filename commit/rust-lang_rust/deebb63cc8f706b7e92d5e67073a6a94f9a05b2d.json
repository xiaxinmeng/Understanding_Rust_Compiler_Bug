{"sha": "deebb63cc8f706b7e92d5e67073a6a94f9a05b2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZWJiNjNjYzhmNzA2YjdlOTJkNWU2NzA3M2E2YTk0ZjlhMDViMmQ=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-18T17:19:38Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-02-23T09:15:51Z"}, "message": "BTree: split off reusable components from range_search", "tree": {"sha": "66893ed4a66c86979a59e66479d49a12e1b7e2cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66893ed4a66c86979a59e66479d49a12e1b7e2cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d", "html_url": "https://github.com/rust-lang/rust/commit/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4e595db8f12f9ee926256745d757004b850703f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4e595db8f12f9ee926256745d757004b850703f", "html_url": "https://github.com/rust-lang/rust/commit/a4e595db8f12f9ee926256745d757004b850703f"}], "stats": {"total": 346, "additions": 228, "deletions": 118}, "files": [{"sha": "c2c99a9360cf1fe02ea6b62bebaf941d3a0be3ca", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 45, "deletions": 97, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=deebb63cc8f706b7e92d5e67073a6a94f9a05b2d", "patch": "@@ -1,11 +1,8 @@\n use core::borrow::Borrow;\n-use core::cmp::Ordering;\n-use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::RangeBounds;\n use core::ptr;\n \n use super::node::{marker, ForceResult::*, Handle, NodeRef};\n-use super::search::SearchResult;\n \n pub struct LeafRange<BorrowType, K, V> {\n     pub front: Option<Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>>,\n@@ -30,100 +27,50 @@ impl<BorrowType, K, V> LeafRange<BorrowType, K, V> {\n     }\n }\n \n-/// Finds the leaf edges delimiting a specified range in or underneath a node.\n-///\n-/// The result is meaningful only if the tree is ordered by key, like the tree\n-/// in a `BTreeMap` is.\n-fn range_search<BorrowType: marker::BorrowType, K, V, Q, R>(\n-    root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-    root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-    range: R,\n-) -> LeafRange<BorrowType, K, V>\n-where\n-    Q: ?Sized + Ord,\n-    K: Borrow<Q>,\n-    R: RangeBounds<Q>,\n-{\n-    // WARNING: Inlining these variables would be unsound (#81138)\n-    // We assume the bounds reported by `range` remain the same, but\n-    // an adversarial implementation could change between calls\n-    let start = range.start_bound();\n-    let end = range.end_bound();\n-    match (start, end) {\n-        (Excluded(s), Excluded(e)) if s == e => {\n-            panic!(\"range start and end are equal and excluded in BTreeMap\")\n-        }\n-        (Included(s) | Excluded(s), Included(e) | Excluded(e)) if s > e => {\n-            panic!(\"range start is greater than range end in BTreeMap\")\n-        }\n-        _ => {}\n-    };\n-\n-    let mut min_node = root1;\n-    let mut max_node = root2;\n-    let mut min_found = false;\n-    let mut max_found = false;\n-\n-    loop {\n-        // Using `range` again would be unsound (#81138)\n-        let front = match (min_found, start) {\n-            (false, Included(key)) => match min_node.search_node(key) {\n-                SearchResult::Found(kv) => {\n-                    min_found = true;\n-                    kv.left_edge()\n-                }\n-                SearchResult::GoDown(edge) => edge,\n-            },\n-            (false, Excluded(key)) => match min_node.search_node(key) {\n-                SearchResult::Found(kv) => {\n-                    min_found = true;\n-                    kv.right_edge()\n-                }\n-                SearchResult::GoDown(edge) => edge,\n-            },\n-            (true, Included(_)) => min_node.last_edge(),\n-            (true, Excluded(_)) => min_node.first_edge(),\n-            (_, Unbounded) => min_node.first_edge(),\n-        };\n-\n-        // Using `range` again would be unsound (#81138)\n-        let back = match (max_found, end) {\n-            (false, Included(key)) => match max_node.search_node(key) {\n-                SearchResult::Found(kv) => {\n-                    max_found = true;\n-                    kv.right_edge()\n-                }\n-                SearchResult::GoDown(edge) => edge,\n-            },\n-            (false, Excluded(key)) => match max_node.search_node(key) {\n-                SearchResult::Found(kv) => {\n-                    max_found = true;\n-                    kv.left_edge()\n+impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    /// Finds the distinct leaf edges delimiting a specified range in a tree.\n+    /// Returns either a pair of different handles into the same tree or a pair\n+    /// of empty options.\n+    /// # Safety\n+    /// Unless `BorrowType` is `Immut`, do not use the duplicate handles to\n+    /// visit the same KV twice.\n+    unsafe fn find_leaf_edges_spanning_range<Q: ?Sized, R>(\n+        self,\n+        range: R,\n+    ) -> LeafRange<BorrowType, K, V>\n+    where\n+        Q: Ord,\n+        K: Borrow<Q>,\n+        R: RangeBounds<Q>,\n+    {\n+        match self.search_tree_for_bifurcation(&range) {\n+            Err(_) => LeafRange::none(),\n+            Ok((\n+                node,\n+                lower_edge_idx,\n+                upper_edge_idx,\n+                mut lower_child_bound,\n+                mut upper_child_bound,\n+            )) => {\n+                let mut lower_edge = unsafe { Handle::new_edge(ptr::read(&node), lower_edge_idx) };\n+                let mut upper_edge = unsafe { Handle::new_edge(node, upper_edge_idx) };\n+                loop {\n+                    match (lower_edge.force(), upper_edge.force()) {\n+                        (Leaf(f), Leaf(b)) => return LeafRange { front: Some(f), back: Some(b) },\n+                        (Internal(f), Internal(b)) => {\n+                            (lower_edge, lower_child_bound) =\n+                                f.descend().find_lower_bound_edge(lower_child_bound);\n+                            (upper_edge, upper_child_bound) =\n+                                b.descend().find_upper_bound_edge(upper_child_bound);\n+                        }\n+                        _ => unreachable!(\"BTreeMap has different depths\"),\n+                    }\n                 }\n-                SearchResult::GoDown(edge) => edge,\n-            },\n-            (true, Included(_)) => max_node.first_edge(),\n-            (true, Excluded(_)) => max_node.last_edge(),\n-            (_, Unbounded) => max_node.last_edge(),\n-        };\n-\n-        if front.partial_cmp(&back) == Some(Ordering::Greater) {\n-            panic!(\"Ord is ill-defined in BTreeMap range\");\n-        }\n-        match (front.force(), back.force()) {\n-            (Leaf(f), Leaf(b)) => {\n-                return LeafRange { front: Some(f), back: Some(b) };\n             }\n-            (Internal(min_int), Internal(max_int)) => {\n-                min_node = min_int.descend();\n-                max_node = max_int.descend();\n-            }\n-            _ => unreachable!(\"BTreeMap has different depths\"),\n-        };\n+        }\n     }\n }\n \n-/// Equivalent to `range_search(root1, root2, ..)` but without the `Ord` bound.\n /// Equivalent to `(root1.first_leaf_edge(), root2.last_leaf_edge())` but more efficient.\n fn full_range<BorrowType: marker::BorrowType, K, V>(\n     root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n@@ -158,7 +105,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n         K: Borrow<Q>,\n         R: RangeBounds<Q>,\n     {\n-        range_search(self, self, range)\n+        // SAFETY: our borrow type is immutable.\n+        unsafe { self.find_leaf_edges_spanning_range(range) }\n     }\n \n     /// Finds the pair of leaf edges delimiting an entire tree.\n@@ -174,16 +122,16 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::ValMut<'a>, K, V, marker::LeafOrInternal>\n     ///\n     /// The result is meaningful only if the tree is ordered by key, like the tree\n     /// in a `BTreeMap` is.\n+    ///\n+    /// # Safety\n+    /// Do not use the duplicate handles to visit the same KV twice.\n     pub fn range_search<Q, R>(self, range: R) -> LeafRange<marker::ValMut<'a>, K, V>\n     where\n         Q: ?Sized + Ord,\n         K: Borrow<Q>,\n         R: RangeBounds<Q>,\n     {\n-        // We duplicate the root NodeRef here -- we will never visit the same KV\n-        // twice, and never end up with overlapping value references.\n-        let self2 = unsafe { ptr::read(&self) };\n-        range_search(self, self2, range)\n+        unsafe { self.find_leaf_edges_spanning_range(range) }\n     }\n \n     /// Splits a unique reference into a pair of leaf edges delimiting the full range of the tree."}, {"sha": "4622fd6cc1c8fbf32a02bd09b5f1497c98e92181", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=deebb63cc8f706b7e92d5e67073a6a94f9a05b2d", "patch": "@@ -31,7 +31,6 @@\n //   since leaf edges are empty and need no data representation. In an internal node,\n //   an edge both identifies a position and contains a pointer to a child node.\n \n-use core::cmp::Ordering;\n use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n use core::ptr::{self, NonNull};\n@@ -742,15 +741,6 @@ impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n     }\n }\n \n-impl<BorrowType, K, V, NodeType, HandleType> PartialOrd\n-    for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n-{\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        let Self { node, idx, _marker } = self;\n-        if node.eq(&other.node) { Some(idx.cmp(&other.idx)) } else { None }\n-    }\n-}\n-\n impl<BorrowType, K, V, NodeType, HandleType>\n     Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n {"}, {"sha": "58e78d99e0a9ec410efdc128d9119329df064495", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=deebb63cc8f706b7e92d5e67073a6a94f9a05b2d", "patch": "@@ -2,7 +2,6 @@ use super::super::navigate;\n use super::*;\n use crate::fmt::Debug;\n use crate::string::String;\n-use core::cmp::Ordering::*;\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n     // Asserts that the back pointer in each reachable node points to its parent.\n@@ -67,7 +66,7 @@ fn test_splitpoint() {\n }\n \n #[test]\n-fn test_partial_cmp_eq() {\n+fn test_partial_eq() {\n     let mut root1 = NodeRef::new_leaf();\n     root1.borrow_mut().push(1, ());\n     let mut root1 = NodeRef::new_internal(root1.forget_type()).forget_type();\n@@ -87,13 +86,6 @@ fn test_partial_cmp_eq() {\n     assert!(top_edge_1 == top_edge_1);\n     assert!(top_edge_1 != top_edge_2);\n \n-    assert_eq!(leaf_edge_1a.partial_cmp(&leaf_edge_1a), Some(Equal));\n-    assert_eq!(leaf_edge_1a.partial_cmp(&leaf_edge_1b), Some(Less));\n-    assert_eq!(leaf_edge_1a.partial_cmp(&top_edge_1), None);\n-    assert_eq!(leaf_edge_1a.partial_cmp(&top_edge_2), None);\n-    assert_eq!(top_edge_1.partial_cmp(&top_edge_1), Some(Equal));\n-    assert_eq!(top_edge_1.partial_cmp(&top_edge_2), None);\n-\n     root1.pop_internal_level();\n     unsafe { root1.into_dying().deallocate_and_ascend() };\n     unsafe { root2.into_dying().deallocate_and_ascend() };"}, {"sha": "f376b3cde02e596523ed3944e76f30aad0717f81", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 181, "deletions": 2, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=deebb63cc8f706b7e92d5e67073a6a94f9a05b2d", "patch": "@@ -1,10 +1,33 @@\n use core::borrow::Borrow;\n use core::cmp::Ordering;\n+use core::ops::{Bound, RangeBounds};\n \n use super::node::{marker, ForceResult::*, Handle, NodeRef};\n \n+use SearchBound::*;\n use SearchResult::*;\n \n+pub enum SearchBound<T> {\n+    /// An inclusive bound to look for, just like `Bound::Included(T)`.\n+    Included(T),\n+    /// An exclusive bound to look for, just like `Bound::Excluded(T)`.\n+    Excluded(T),\n+    /// An unconditional inclusive bound, just like `Bound::Unbounded`.\n+    AllIncluded,\n+    /// An unconditional exclusive bound.\n+    AllExcluded,\n+}\n+\n+impl<T> SearchBound<T> {\n+    pub fn from_range(range_bound: Bound<T>) -> Self {\n+        match range_bound {\n+            Bound::Included(t) => Included(t),\n+            Bound::Excluded(t) => Excluded(t),\n+            Bound::Unbounded => AllIncluded,\n+        }\n+    }\n+}\n+\n pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n     Found(Handle<NodeRef<BorrowType, K, V, FoundType>, marker::KV>),\n     GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>),\n@@ -40,6 +63,112 @@ impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Lea\n             }\n         }\n     }\n+\n+    /// Descends to the nearest node where the edge matching the lower bound\n+    /// of the range is different from the edge matching the upper bound, i.e.,\n+    /// the nearest node that has at least one key contained in the range.\n+    ///\n+    /// If found, returns an `Ok` with that node, the pair of edge indices in it\n+    /// delimiting the range, and the corresponding pair of bounds for\n+    /// continuing the search in the child nodes, in case the node is internal.\n+    ///\n+    /// If not found, returns an `Err` with the leaf edge matching the entire\n+    /// range.\n+    ///\n+    /// The result is meaningful only if the tree is ordered by key.\n+    pub fn search_tree_for_bifurcation<'r, Q: ?Sized, R>(\n+        mut self,\n+        range: &'r R,\n+    ) -> Result<\n+        (\n+            NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+            usize,\n+            usize,\n+            SearchBound<&'r Q>,\n+            SearchBound<&'r Q>,\n+        ),\n+        Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+    >\n+    where\n+        Q: Ord,\n+        K: Borrow<Q>,\n+        R: RangeBounds<Q>,\n+    {\n+        // WARNING: Inlining these variables would be unsound (#81138)\n+        // We assume the bounds reported by `range` remain the same, but\n+        // an adversarial implementation could change between calls\n+        let (start, end) = (range.start_bound(), range.end_bound());\n+        match (start, end) {\n+            (Bound::Excluded(s), Bound::Excluded(e)) if s == e => {\n+                panic!(\"range start and end are equal and excluded in BTreeMap\")\n+            }\n+            (Bound::Included(s) | Bound::Excluded(s), Bound::Included(e) | Bound::Excluded(e))\n+                if s > e =>\n+            {\n+                panic!(\"range start is greater than range end in BTreeMap\")\n+            }\n+            _ => {}\n+        }\n+        let mut lower_bound = SearchBound::from_range(start);\n+        let mut upper_bound = SearchBound::from_range(end);\n+        loop {\n+            let (lower_edge_idx, lower_child_bound) = self.find_lower_bound_index(lower_bound);\n+            let (upper_edge_idx, upper_child_bound) = self.find_upper_bound_index(upper_bound);\n+            if lower_edge_idx > upper_edge_idx {\n+                panic!(\"Ord is ill-defined in BTreeMap range\")\n+            }\n+            if lower_edge_idx < upper_edge_idx {\n+                return Ok((\n+                    self,\n+                    lower_edge_idx,\n+                    upper_edge_idx,\n+                    lower_child_bound,\n+                    upper_child_bound,\n+                ));\n+            }\n+            let common_edge = unsafe { Handle::new_edge(self, lower_edge_idx) };\n+            match common_edge.force() {\n+                Leaf(common_edge) => return Err(common_edge),\n+                Internal(common_edge) => {\n+                    self = common_edge.descend();\n+                    lower_bound = lower_child_bound;\n+                    upper_bound = upper_child_bound;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Finds an edge in the node delimiting the lower bound of a range.\n+    /// Also returns the lower bound to be used for continuing the search in\n+    /// the matching child node, if `self` is an internal node.\n+    ///\n+    /// The result is meaningful only if the tree is ordered by key.\n+    pub fn find_lower_bound_edge<'r, Q>(\n+        self,\n+        bound: SearchBound<&'r Q>,\n+    ) -> (Handle<Self, marker::Edge>, SearchBound<&'r Q>)\n+    where\n+        Q: ?Sized + Ord,\n+        K: Borrow<Q>,\n+    {\n+        let (edge_idx, bound) = self.find_lower_bound_index(bound);\n+        let edge = unsafe { Handle::new_edge(self, edge_idx) };\n+        (edge, bound)\n+    }\n+\n+    /// Clone of `find_lower_bound_edge` for the upper bound.\n+    pub fn find_upper_bound_edge<'r, Q>(\n+        self,\n+        bound: SearchBound<&'r Q>,\n+    ) -> (Handle<Self, marker::Edge>, SearchBound<&'r Q>)\n+    where\n+        Q: ?Sized + Ord,\n+        K: Borrow<Q>,\n+    {\n+        let (edge_idx, bound) = self.find_upper_bound_index(bound);\n+        let edge = unsafe { Handle::new_edge(self, edge_idx) };\n+        (edge, bound)\n+    }\n }\n \n impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n@@ -55,7 +184,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         Q: Ord,\n         K: Borrow<Q>,\n     {\n-        match self.find_index(key) {\n+        match self.find_key_index(key) {\n             IndexResult::KV(idx) => Found(unsafe { Handle::new_kv(self, idx) }),\n             IndexResult::Edge(idx) => GoDown(unsafe { Handle::new_edge(self, idx) }),\n         }\n@@ -66,7 +195,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     ///\n     /// The result is meaningful only if the tree is ordered by key, like the tree\n     /// in a `BTreeMap` is.\n-    fn find_index<Q: ?Sized>(&self, key: &Q) -> IndexResult\n+    fn find_key_index<Q: ?Sized>(&self, key: &Q) -> IndexResult\n     where\n         Q: Ord,\n         K: Borrow<Q>,\n@@ -82,4 +211,54 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         }\n         IndexResult::Edge(keys.len())\n     }\n+\n+    /// Finds an edge index in the node delimiting the lower bound of a range.\n+    /// Also returns the lower bound to be used for continuing the search in\n+    /// the matching child node, if `self` is an internal node.\n+    ///\n+    /// The result is meaningful only if the tree is ordered by key.\n+    fn find_lower_bound_index<'r, Q>(\n+        &self,\n+        bound: SearchBound<&'r Q>,\n+    ) -> (usize, SearchBound<&'r Q>)\n+    where\n+        Q: ?Sized + Ord,\n+        K: Borrow<Q>,\n+    {\n+        match bound {\n+            Included(key) => match self.find_key_index(key) {\n+                IndexResult::KV(idx) => (idx, AllExcluded),\n+                IndexResult::Edge(idx) => (idx, bound),\n+            },\n+            Excluded(key) => match self.find_key_index(key) {\n+                IndexResult::KV(idx) => (idx + 1, AllIncluded),\n+                IndexResult::Edge(idx) => (idx, bound),\n+            },\n+            AllIncluded => (0, AllIncluded),\n+            AllExcluded => (self.len(), AllExcluded),\n+        }\n+    }\n+\n+    /// Clone of `find_lower_bound_index` for the upper bound.\n+    fn find_upper_bound_index<'r, Q>(\n+        &self,\n+        bound: SearchBound<&'r Q>,\n+    ) -> (usize, SearchBound<&'r Q>)\n+    where\n+        Q: ?Sized + Ord,\n+        K: Borrow<Q>,\n+    {\n+        match bound {\n+            Included(key) => match self.find_key_index(key) {\n+                IndexResult::KV(idx) => (idx + 1, AllExcluded),\n+                IndexResult::Edge(idx) => (idx, bound),\n+            },\n+            Excluded(key) => match self.find_key_index(key) {\n+                IndexResult::KV(idx) => (idx, AllIncluded),\n+                IndexResult::Edge(idx) => (idx, bound),\n+            },\n+            AllIncluded => (self.len(), AllIncluded),\n+            AllExcluded => (0, AllExcluded),\n+        }\n+    }\n }"}, {"sha": "c4f05a4d09c510af9f95e5df72eac24f5a7cad00", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deebb63cc8f706b7e92d5e67073a6a94f9a05b2d/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=deebb63cc8f706b7e92d5e67073a6a94f9a05b2d", "patch": "@@ -92,6 +92,7 @@\n #![feature(const_fn)]\n #![feature(cow_is_borrowed)]\n #![feature(const_cow_is_borrowed)]\n+#![feature(destructuring_assignment)]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]"}]}