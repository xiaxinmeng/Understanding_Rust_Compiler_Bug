{"sha": "09eca11805fd523b569047d0ec257cfbf439a73c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZWNhMTE4MDVmZDUyM2I1NjkwNDdkMGVjMjU3Y2ZiZjQzOWE3M2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-25T03:07:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-25T03:07:44Z"}, "message": "auto merge of #10637 : luqmana/rust/nmt, r=cmr\n\nThere's no need for it to be @mut.", "tree": {"sha": "f22ef10e7ad84533e25e0374a39424745376bf53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f22ef10e7ad84533e25e0374a39424745376bf53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09eca11805fd523b569047d0ec257cfbf439a73c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09eca11805fd523b569047d0ec257cfbf439a73c", "html_url": "https://github.com/rust-lang/rust/commit/09eca11805fd523b569047d0ec257cfbf439a73c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09eca11805fd523b569047d0ec257cfbf439a73c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "861cced1193b13be87c6098cca93264e15cac351", "url": "https://api.github.com/repos/rust-lang/rust/commits/861cced1193b13be87c6098cca93264e15cac351", "html_url": "https://github.com/rust-lang/rust/commit/861cced1193b13be87c6098cca93264e15cac351"}, {"sha": "2431ac3080859e158f2a7379f939c40f27081ea7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2431ac3080859e158f2a7379f939c40f27081ea7", "html_url": "https://github.com/rust-lang/rust/commit/2431ac3080859e158f2a7379f939c40f27081ea7"}], "stats": {"total": 294, "additions": 165, "deletions": 129}, "files": [{"sha": "4eac6eada22c5dc0557ead52142a74af5d92fcf1", "filename": "src/libextra/term.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/09eca11805fd523b569047d0ec257cfbf439a73c/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09eca11805fd523b569047d0ec257cfbf439a73c/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=09eca11805fd523b569047d0ec257cfbf439a73c", "patch": "@@ -13,7 +13,7 @@\n #[allow(missing_doc)];\n \n \n-use std::io;\n+use std::io::{Decorator, Writer};\n \n #[cfg(not(target_os = \"win32\"))] use std::os;\n #[cfg(not(target_os = \"win32\"))] use terminfo::*;\n@@ -94,21 +94,21 @@ fn cap_for_attr(attr: attr::Attr) -> &'static str {\n }\n \n #[cfg(not(target_os = \"win32\"))]\n-pub struct Terminal {\n+pub struct Terminal<T> {\n     priv num_colors: u16,\n-    priv out: @mut io::Writer,\n+    priv out: T,\n     priv ti: ~TermInfo\n }\n \n #[cfg(target_os = \"win32\")]\n-pub struct Terminal {\n+pub struct Terminal<T> {\n     priv num_colors: u16,\n-    priv out: @mut io::Writer,\n+    priv out: T,\n }\n \n #[cfg(not(target_os = \"win32\"))]\n-impl Terminal {\n-    pub fn new(out: @mut io::Writer) -> Result<Terminal, ~str> {\n+impl<T: Writer> Terminal<T> {\n+    pub fn new(out: T) -> Result<Terminal<T>, ~str> {\n         let term = os::getenv(\"TERM\");\n         if term.is_none() {\n             return Err(~\"TERM environment variable undefined\");\n@@ -138,7 +138,7 @@ impl Terminal {\n     /// the corresponding normal color will be used instead.\n     ///\n     /// Returns true if the color was set, false otherwise.\n-    pub fn fg(&self, color: color::Color) -> bool {\n+    pub fn fg(&mut self, color: color::Color) -> bool {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setaf\")).unwrap(),\n@@ -158,7 +158,7 @@ impl Terminal {\n     /// the corresponding normal color will be used instead.\n     ///\n     /// Returns true if the color was set, false otherwise.\n-    pub fn bg(&self, color: color::Color) -> bool {\n+    pub fn bg(&mut self, color: color::Color) -> bool {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setab\")).unwrap(),\n@@ -175,7 +175,7 @@ impl Terminal {\n \n     /// Sets the given terminal attribute, if supported.\n     /// Returns true if the attribute was supported, false otherwise.\n-    pub fn attr(&self, attr: attr::Attr) -> bool {\n+    pub fn attr(&mut self, attr: attr::Attr) -> bool {\n         match attr {\n             attr::ForegroundColor(c) => self.fg(c),\n             attr::BackgroundColor(c) => self.bg(c),\n@@ -210,7 +210,7 @@ impl Terminal {\n     }\n \n     /// Resets all terminal attributes and color to the default.\n-    pub fn reset(&self) {\n+    pub fn reset(&mut self) {\n         let mut cap = self.ti.strings.find_equiv(&(\"sgr0\"));\n         if cap.is_none() {\n             // are there any terminals that have color/attrs and not sgr0?\n@@ -242,20 +242,20 @@ impl Terminal {\n }\n \n #[cfg(target_os = \"win32\")]\n-impl Terminal {\n-    pub fn new(out: @mut io::Writer) -> Result<Terminal, ~str> {\n+impl<T: Writer> Terminal<T> {\n+    pub fn new(out: T) -> Result<Terminal<T>, ~str> {\n         return Ok(Terminal {out: out, num_colors: 0});\n     }\n \n-    pub fn fg(&self, _color: color::Color) -> bool {\n+    pub fn fg(&mut self, _color: color::Color) -> bool {\n         false\n     }\n \n-    pub fn bg(&self, _color: color::Color) -> bool {\n+    pub fn bg(&mut self, _color: color::Color) -> bool {\n         false\n     }\n \n-    pub fn attr(&self, _attr: attr::Attr) -> bool {\n+    pub fn attr(&mut self, _attr: attr::Attr) -> bool {\n         false\n     }\n \n@@ -266,3 +266,27 @@ impl Terminal {\n     pub fn reset(&self) {\n     }\n }\n+\n+impl<T: Writer> Decorator<T> for Terminal<T> {\n+    fn inner(self) -> T {\n+        self.out\n+    }\n+\n+    fn inner_ref<'a>(&'a self) -> &'a T {\n+        &self.out\n+    }\n+\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut T {\n+        &mut self.out\n+    }\n+}\n+\n+impl<T: Writer> Writer for Terminal<T> {\n+    fn write(&mut self, buf: &[u8]) {\n+        self.out.write(buf);\n+    }\n+\n+    fn flush(&mut self) {\n+        self.out.flush();\n+    }\n+}"}, {"sha": "b346129d7592f4a392f835d3376e88f9e535a3a9", "filename": "src/libextra/test.rs", "status": "modified", "additions": 84, "deletions": 76, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/09eca11805fd523b569047d0ec257cfbf439a73c/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09eca11805fd523b569047d0ec257cfbf439a73c/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=09eca11805fd523b569047d0ec257cfbf439a73c", "patch": "@@ -32,6 +32,8 @@ use std::clone::Clone;\n use std::comm::{stream, SharedChan, GenericPort, GenericChan};\n use std::io;\n use std::io::File;\n+use std::io::Writer;\n+use std::io::stdio::StdWriter;\n use std::task;\n use std::to_str::ToStr;\n use std::f64;\n@@ -338,10 +340,9 @@ pub enum TestResult {\n     TrBench(BenchSamples),\n }\n \n-struct ConsoleTestState {\n-    out: @mut io::Writer,\n-    log_out: Option<@mut io::Writer>,\n-    term: Option<term::Terminal>,\n+struct ConsoleTestState<T> {\n+    log_out: Option<File>,\n+    out: Either<term::Terminal<T>, T>,\n     use_color: bool,\n     total: uint,\n     passed: uint,\n@@ -353,22 +354,20 @@ struct ConsoleTestState {\n     max_name_len: uint, // number of columns to fill when aligning names\n }\n \n-impl ConsoleTestState {\n-    pub fn new(opts: &TestOpts) -> ConsoleTestState {\n+impl<T: Writer> ConsoleTestState<T> {\n+    pub fn new(opts: &TestOpts, _: Option<T>) -> ConsoleTestState<StdWriter> {\n         let log_out = match opts.logfile {\n-            Some(ref path) => Some(@mut File::create(path) as @mut io::Writer),\n+            Some(ref path) => File::create(path),\n             None => None\n         };\n-        let out = @mut io::stdio::stdout() as @mut io::Writer;\n-        let term = match term::Terminal::new(out) {\n-            Err(_) => None,\n-            Ok(t) => Some(t)\n+        let out = match term::Terminal::new(io::stdout()) {\n+            Err(_) => Right(io::stdout()),\n+            Ok(t) => Left(t)\n         };\n         ConsoleTestState {\n             out: out,\n             log_out: log_out,\n             use_color: use_color(),\n-            term: term,\n             total: 0u,\n             passed: 0u,\n             failed: 0u,\n@@ -380,115 +379,123 @@ impl ConsoleTestState {\n         }\n     }\n \n-    pub fn write_ok(&self) {\n+    pub fn write_ok(&mut self) {\n         self.write_pretty(\"ok\", term::color::GREEN);\n     }\n \n-    pub fn write_failed(&self) {\n+    pub fn write_failed(&mut self) {\n         self.write_pretty(\"FAILED\", term::color::RED);\n     }\n \n-    pub fn write_ignored(&self) {\n+    pub fn write_ignored(&mut self) {\n         self.write_pretty(\"ignored\", term::color::YELLOW);\n     }\n \n-    pub fn write_metric(&self) {\n+    pub fn write_metric(&mut self) {\n         self.write_pretty(\"metric\", term::color::CYAN);\n     }\n \n-    pub fn write_bench(&self) {\n+    pub fn write_bench(&mut self) {\n         self.write_pretty(\"bench\", term::color::CYAN);\n     }\n \n-    pub fn write_added(&self) {\n+    pub fn write_added(&mut self) {\n         self.write_pretty(\"added\", term::color::GREEN);\n     }\n \n-    pub fn write_improved(&self) {\n+    pub fn write_improved(&mut self) {\n         self.write_pretty(\"improved\", term::color::GREEN);\n     }\n \n-    pub fn write_removed(&self) {\n+    pub fn write_removed(&mut self) {\n         self.write_pretty(\"removed\", term::color::YELLOW);\n     }\n \n-    pub fn write_regressed(&self) {\n+    pub fn write_regressed(&mut self) {\n         self.write_pretty(\"regressed\", term::color::RED);\n     }\n \n-    pub fn write_pretty(&self,\n+    pub fn write_pretty(&mut self,\n                         word: &str,\n                         color: term::color::Color) {\n-        match self.term {\n-            None => self.out.write(word.as_bytes()),\n-            Some(ref t) => {\n+        match self.out {\n+            Left(ref mut term) => {\n                 if self.use_color {\n-                    t.fg(color);\n+                    term.fg(color);\n                 }\n-                self.out.write(word.as_bytes());\n+                term.write(word.as_bytes());\n                 if self.use_color {\n-                    t.reset();\n+                    term.reset();\n                 }\n             }\n+            Right(ref mut stdout) => stdout.write(word.as_bytes())\n+        }\n+    }\n+\n+    pub fn write_plain(&mut self, s: &str) {\n+        match self.out {\n+            Left(ref mut term) => term.write(s.as_bytes()),\n+            Right(ref mut stdout) => stdout.write(s.as_bytes())\n         }\n     }\n \n     pub fn write_run_start(&mut self, len: uint) {\n         self.total = len;\n         let noun = if len != 1 { &\"tests\" } else { &\"test\" };\n-        write!(self.out, \"\\nrunning {} {}\\n\", len, noun);\n+        self.write_plain(format!(\"\\nrunning {} {}\\n\", len, noun));\n     }\n \n-    pub fn write_test_start(&self, test: &TestDesc, align: NamePadding) {\n+    pub fn write_test_start(&mut self, test: &TestDesc, align: NamePadding) {\n         let name = test.padded_name(self.max_name_len, align);\n-        write!(self.out, \"test {} ... \", name);\n+        self.write_plain(format!(\"test {} ... \", name));\n     }\n \n-    pub fn write_result(&self, result: &TestResult) {\n+    pub fn write_result(&mut self, result: &TestResult) {\n         match *result {\n             TrOk => self.write_ok(),\n             TrFailed => self.write_failed(),\n             TrIgnored => self.write_ignored(),\n             TrMetrics(ref mm) => {\n                 self.write_metric();\n-                write!(self.out, \": {}\", fmt_metrics(mm));\n+                self.write_plain(format!(\": {}\", fmt_metrics(mm)));\n             }\n             TrBench(ref bs) => {\n                 self.write_bench();\n-                write!(self.out, \": {}\", fmt_bench_samples(bs));\n+                self.write_plain(format!(\": {}\", fmt_bench_samples(bs)));\n             }\n         }\n-        write!(self.out, \"\\n\");\n+        self.write_plain(\"\\n\");\n     }\n \n-    pub fn write_log(&self, test: &TestDesc, result: &TestResult) {\n+    pub fn write_log(&mut self, test: &TestDesc, result: &TestResult) {\n         match self.log_out {\n             None => (),\n-            Some(out) => {\n-                write!(out, \"{} {}\",match *result {\n-                                        TrOk => ~\"ok\",\n-                                        TrFailed => ~\"failed\",\n-                                        TrIgnored => ~\"ignored\",\n-                                        TrMetrics(ref mm) => fmt_metrics(mm),\n-                                        TrBench(ref bs) => fmt_bench_samples(bs)\n-                                    }, test.name.to_str());\n+            Some(ref mut o) => {\n+                let s = format!(\"{} {}\", match *result {\n+                        TrOk => ~\"ok\",\n+                        TrFailed => ~\"failed\",\n+                        TrIgnored => ~\"ignored\",\n+                        TrMetrics(ref mm) => fmt_metrics(mm),\n+                        TrBench(ref bs) => fmt_bench_samples(bs)\n+                    }, test.name.to_str());\n+                o.write(s.as_bytes());\n             }\n         }\n     }\n \n-    pub fn write_failures(&self) {\n-        write!(self.out, \"\\nfailures:\\n\");\n+    pub fn write_failures(&mut self) {\n+        self.write_plain(\"\\nfailures:\\n\");\n         let mut failures = ~[];\n         for f in self.failures.iter() {\n             failures.push(f.name.to_str());\n         }\n         sort::tim_sort(failures);\n         for name in failures.iter() {\n-            writeln!(self.out, \"    {}\", name.to_str());\n+            self.write_plain(format!(\"    {}\\n\", name.to_str()));\n         }\n     }\n \n-    pub fn write_metric_diff(&self, diff: &MetricDiff) {\n+    pub fn write_metric_diff(&mut self, diff: &MetricDiff) {\n         let mut noise = 0;\n         let mut improved = 0;\n         let mut regressed = 0;\n@@ -501,51 +508,51 @@ impl ConsoleTestState {\n                 MetricAdded => {\n                     added += 1;\n                     self.write_added();\n-                    writeln!(self.out, \": {}\", *k);\n+                    self.write_plain(format!(\": {}\\n\", *k));\n                 }\n                 MetricRemoved => {\n                     removed += 1;\n                     self.write_removed();\n-                    writeln!(self.out, \": {}\", *k);\n+                    self.write_plain(format!(\": {}\\n\", *k));\n                 }\n                 Improvement(pct) => {\n                     improved += 1;\n-                    write!(self.out, \"{}: \", *k);\n+                    self.write_plain(format!(\": {}\", *k));\n                     self.write_improved();\n-                    writeln!(self.out, \" by {:.2f}%\", pct as f64);\n+                    self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64));\n                 }\n                 Regression(pct) => {\n                     regressed += 1;\n-                    write!(self.out, \"{}: \", *k);\n+                    self.write_plain(format!(\": {}\", *k));\n                     self.write_regressed();\n-                    writeln!(self.out, \" by {:.2f}%\", pct as f64);\n+                    self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64));\n                 }\n             }\n         }\n-        writeln!(self.out, \"result of ratchet: {} matrics added, {} removed, \\\n-                            {} improved, {} regressed, {} noise\",\n-                            added, removed, improved, regressed, noise);\n+        self.write_plain(format!(\"result of ratchet: {} matrics added, {} removed, \\\n+                                  {} improved, {} regressed, {} noise\\n\",\n+                                 added, removed, improved, regressed, noise));\n         if regressed == 0 {\n-            writeln!(self.out, \"updated ratchet file\");\n+            self.write_plain(\"updated ratchet file\\n\");\n         } else {\n-            writeln!(self.out, \"left ratchet file untouched\");\n+            self.write_plain(\"left ratchet file untouched\\n\");\n         }\n     }\n \n-    pub fn write_run_finish(&self,\n+    pub fn write_run_finish(&mut self,\n                             ratchet_metrics: &Option<Path>,\n                             ratchet_pct: Option<f64>) -> bool {\n         assert!(self.passed + self.failed + self.ignored + self.measured == self.total);\n \n         let ratchet_success = match *ratchet_metrics {\n             None => true,\n             Some(ref pth) => {\n-                write!(self.out, \"\\nusing metrics ratcher: {}\\n\", pth.display());\n+                self.write_plain(format!(\"\\nusing metrics ratcher: {}\\n\", pth.display()));\n                 match ratchet_pct {\n                     None => (),\n                     Some(pct) =>\n-                        writeln!(self.out, \"with noise-tolerance forced to: {}%\",\n-                                 pct)\n+                        self.write_plain(format!(\"with noise-tolerance forced to: {}%\\n\",\n+                                                 pct))\n                 }\n                 let (diff, ok) = self.metrics.ratchet(pth, ratchet_pct);\n                 self.write_metric_diff(&diff);\n@@ -560,15 +567,16 @@ impl ConsoleTestState {\n \n         let success = ratchet_success && test_success;\n \n-        write!(self.out, \"\\ntest result: \");\n+        self.write_plain(\"\\ntest result: \");\n         if success {\n             // There's no parallelism at this point so it's safe to use color\n             self.write_ok();\n         } else {\n             self.write_failed();\n         }\n-        write!(self.out, \". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n-               self.passed, self.failed, self.ignored, self.measured);\n+        let s = format!(\". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n+                        self.passed, self.failed, self.ignored, self.measured);\n+        self.write_plain(s);\n         return success;\n     }\n }\n@@ -599,7 +607,7 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts,\n                          tests: ~[TestDescAndFn]) -> bool {\n-    fn callback(event: &TestEvent, st: &mut ConsoleTestState) {\n+    fn callback<T: Writer>(event: &TestEvent, st: &mut ConsoleTestState<T>) {\n         debug!(\"callback(event={:?})\", event);\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n@@ -632,7 +640,7 @@ pub fn run_tests_console(opts: &TestOpts,\n             }\n         }\n     }\n-    let st = @mut ConsoleTestState::new(opts);\n+    let mut st = ConsoleTestState::new(opts, None::<StdWriter>);\n     fn len_if_padded(t: &TestDescAndFn) -> uint {\n         match t.testfn.padding() {\n             PadNone => 0u,\n@@ -647,26 +655,24 @@ pub fn run_tests_console(opts: &TestOpts,\n         },\n         None => {}\n     }\n-    run_tests(opts, tests, |x| callback(&x, st));\n+    run_tests(opts, tests, |x| callback(&x, &mut st));\n     match opts.save_metrics {\n         None => (),\n         Some(ref pth) => {\n             st.metrics.save(pth);\n-            write!(st.out, \"\\nmetrics saved to: {}\", pth.display());\n+            st.write_plain(format!(\"\\nmetrics saved to: {}\", pth.display()));\n         }\n     }\n     return st.write_run_finish(&opts.ratchet_metrics, opts.ratchet_noise_percent);\n }\n \n #[test]\n fn should_sort_failures_before_printing_them() {\n-    use std::io;\n     use std::io::Decorator;\n     use std::io::mem::MemWriter;\n     use std::str;\n     fn dummy() {}\n \n-    let m = @mut MemWriter::new();\n     let test_a = TestDesc {\n         name: StaticTestName(\"a\"),\n         ignore: false,\n@@ -679,10 +685,9 @@ fn should_sort_failures_before_printing_them() {\n         should_fail: false\n     };\n \n-    let st = @ConsoleTestState {\n-        out: m as @mut io::Writer,\n+    let mut st = ConsoleTestState {\n         log_out: None,\n-        term: None,\n+        out: Right(MemWriter::new()),\n         use_color: false,\n         total: 0u,\n         passed: 0u,\n@@ -695,7 +700,10 @@ fn should_sort_failures_before_printing_them() {\n     };\n \n     st.write_failures();\n-    let s = str::from_utf8(*m.inner_ref());\n+    let s = match st.out {\n+        Right(ref m) => str::from_utf8(*m.inner_ref()),\n+        Left(_) => unreachable!()\n+    };\n \n     let apos = s.find_str(\"a\").unwrap();\n     let bpos = s.find_str(\"b\").unwrap();"}, {"sha": "dbd0ee80f2875bf257fc8610aaeef973ebfc0afe", "filename": "src/librustpkg/messages.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/09eca11805fd523b569047d0ec257cfbf439a73c/src%2Flibrustpkg%2Fmessages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09eca11805fd523b569047d0ec257cfbf439a73c/src%2Flibrustpkg%2Fmessages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fmessages.rs?ref=09eca11805fd523b569047d0ec257cfbf439a73c", "patch": "@@ -12,35 +12,32 @@ use extra::term;\n use std::io;\n \n pub fn note(msg: &str) {\n-    pretty_message(msg, \"note: \", term::color::GREEN,\n-                   @mut io::stdout() as @mut io::Writer)\n+    pretty_message(msg, \"note: \", term::color::GREEN);\n }\n \n pub fn warn(msg: &str) {\n-    pretty_message(msg, \"warning: \", term::color::YELLOW,\n-                   @mut io::stdout() as @mut io::Writer)\n+    pretty_message(msg, \"warning: \", term::color::YELLOW);\n }\n \n pub fn error(msg: &str) {\n-    pretty_message(msg, \"error: \", term::color::RED,\n-                   @mut io::stdout() as @mut io::Writer)\n+    pretty_message(msg, \"error: \", term::color::RED);\n }\n \n fn pretty_message<'a>(msg: &'a str,\n                       prefix: &'a str,\n-                      color: term::color::Color,\n-                      out: @mut io::Writer) {\n-    let term = term::Terminal::new(out);\n+                      color: term::color::Color) {\n+    let mut term = term::Terminal::new(io::stdout());\n+    let mut stdout = io::stdout();\n     match term {\n-        Ok(ref t) => {\n+        Ok(ref mut t) => {\n             t.fg(color);\n-            out.write(prefix.as_bytes());\n+            t.write(prefix.as_bytes());\n             t.reset();\n         },\n         _ => {\n-            out.write(prefix.as_bytes());\n+            stdout.write(prefix.as_bytes());\n         }\n     }\n-    out.write(msg.as_bytes());\n-    out.write(['\\n' as u8]);\n+    stdout.write(msg.as_bytes());\n+    stdout.write(['\\n' as u8]);\n }"}, {"sha": "bb908919678b8f110dacf471af80af79463190dd", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/09eca11805fd523b569047d0ec257cfbf439a73c/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09eca11805fd523b569047d0ec257cfbf439a73c/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=09eca11805fd523b569047d0ec257cfbf439a73c", "patch": "@@ -12,6 +12,7 @@ use codemap::{Pos, Span};\n use codemap;\n \n use std::io;\n+use std::io::stdio::StdWriter;\n use std::local_data;\n use extra::term;\n \n@@ -197,38 +198,44 @@ fn diagnosticcolor(lvl: level) -> term::color::Color {\n }\n \n fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n-    local_data_key!(tls_terminal: @Option<term::Terminal>)\n+    local_data_key!(tls_terminal: ~Option<term::Terminal<StdWriter>>)\n \n-    let stderr = @mut io::stderr() as @mut io::Writer;\n     fn is_stderr_screen() -> bool {\n         use std::libc;\n         unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n     }\n+    fn write_pretty<T: Writer>(term: &mut term::Terminal<T>, s: &str, c: term::attr::Attr) {\n+        term.attr(c);\n+        term.write(s.as_bytes());\n+        term.reset();\n+    }\n \n     if is_stderr_screen() {\n-        let t = match local_data::get(tls_terminal, |v| v.map(|k| *k)) {\n-            None => {\n-                let t = term::Terminal::new(stderr);\n-                let tls = @match t {\n-                    Ok(t) => Some(t),\n-                    Err(_) => None\n-                };\n-                local_data::set(tls_terminal, tls);\n-                &*tls\n+        local_data::get_mut(tls_terminal, |term| {\n+            match term {\n+                Some(term) => {\n+                    match **term {\n+                        Some(ref mut term) => write_pretty(term, msg, color),\n+                        None => io::stderr().write(msg.as_bytes())\n+                    }\n+                }\n+                None => {\n+                    let t = ~match term::Terminal::new(io::stderr()) {\n+                        Ok(mut term) => {\n+                            write_pretty(&mut term, msg, color);\n+                            Some(term)\n+                        }\n+                        Err(_) => {\n+                            io::stderr().write(msg.as_bytes());\n+                            None\n+                        }\n+                    };\n+                    local_data::set(tls_terminal, t);\n+                }\n             }\n-            Some(tls) => &*tls\n-        };\n-\n-        match t {\n-            &Some(ref term) => {\n-                term.attr(color);\n-                write!(stderr, \"{}\", msg);\n-                term.reset();\n-            },\n-            _ => write!(stderr, \"{}\", msg)\n-        }\n+        });\n     } else {\n-        write!(stderr, \"{}\", msg);\n+        io::stderr().write(msg.as_bytes());\n     }\n }\n "}]}