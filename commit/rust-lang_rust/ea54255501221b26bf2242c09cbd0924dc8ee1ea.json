{"sha": "ea54255501221b26bf2242c09cbd0924dc8ee1ea", "node_id": "C_kwDOAAsO6NoAKGVhNTQyNTU1MDEyMjFiMjZiZjIyNDJjMDljYmQwOTI0ZGM4ZWUxZWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-15T22:16:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-15T22:16:50Z"}, "message": "Auto merge of #111221 - compiler-errors:yeet-generalizer, r=lcnr\n\nCombine three generalizer implementations\n\nFixes #111092\nFixes #109505\n\nThis code is a bit delicate and there were subtle changes between them, so I'll leave inline comments where further inspection is needed.\n\nRegarding this comment from #109813 -- \"add tests triggering all codepaths: at least the combine and the const generalizer\", can't really do that now, and I don't really know how we'd get a higher-ranked const error since non-lifetime binders doesn't *really* support `for<const ..>` (it errors out when you try to use it).\n\nr? `@lcnr`", "tree": {"sha": "0090044836e6c0d9045d273e084a7e1879f2b4ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0090044836e6c0d9045d273e084a7e1879f2b4ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea54255501221b26bf2242c09cbd0924dc8ee1ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea54255501221b26bf2242c09cbd0924dc8ee1ea", "html_url": "https://github.com/rust-lang/rust/commit/ea54255501221b26bf2242c09cbd0924dc8ee1ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea54255501221b26bf2242c09cbd0924dc8ee1ea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce5919fcef67103098219e1868f741e56fc90963", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce5919fcef67103098219e1868f741e56fc90963", "html_url": "https://github.com/rust-lang/rust/commit/ce5919fcef67103098219e1868f741e56fc90963"}, {"sha": "a2678e15e559bb7d779fd1e04d73d8ae3b9093e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3", "html_url": "https://github.com/rust-lang/rust/commit/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3"}], "stats": {"total": 1458, "additions": 627, "deletions": 831}, "files": [{"sha": "79fc02c6c7987b1d83f75fea874e7be6d2c44326", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 40, "deletions": 546, "changes": 586, "blob_url": "https://github.com/rust-lang/rust/blob/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=ea54255501221b26bf2242c09cbd0924dc8ee1ea", "patch": "@@ -26,24 +26,17 @@ use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n-use super::type_variable::TypeVariableValue;\n-use super::{DefineOpaqueTypes, InferCtxt, MiscVariable, TypeTrace};\n+use super::{DefineOpaqueTypes, InferCtxt, TypeTrace};\n+use crate::infer::generalize::{self, CombineDelegate, Generalization};\n use crate::traits::{Obligation, PredicateObligations};\n-use rustc_data_structures::sso::SsoHashMap;\n-use rustc_hir::def_id::DefId;\n use rustc_middle::infer::canonical::OriginalQueryValues;\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{\n-    self, AliasKind, FallibleTypeFolder, InferConst, ToPredicate, Ty, TyCtxt, TypeFoldable,\n-    TypeSuperFoldable, TypeVisitableExt,\n-};\n+use rustc_middle::ty::relate::{RelateResult, TypeRelation};\n+use rustc_middle::ty::{self, AliasKind, InferConst, ToPredicate, Ty, TyCtxt, TypeVisitableExt};\n use rustc_middle::ty::{IntType, UintType};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::DUMMY_SP;\n \n #[derive(Clone)]\n pub struct CombineFields<'infcx, 'tcx> {\n@@ -55,13 +48,6 @@ pub struct CombineFields<'infcx, 'tcx> {\n     pub define_opaque_types: DefineOpaqueTypes,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum RelationDir {\n-    SubtypeOf,\n-    SupertypeOf,\n-    EqTo,\n-}\n-\n impl<'tcx> InferCtxt<'tcx> {\n     pub fn super_combine_tys<R>(\n         &self,\n@@ -152,7 +138,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 Ok(a)\n             }\n \n-            _ => ty::relate::super_relate_tys(relation, a, b),\n+            _ => ty::relate::structurally_relate_tys(relation, a, b),\n         }\n     }\n \n@@ -211,11 +197,11 @@ impl<'tcx> InferCtxt<'tcx> {\n             // matching in the solver.\n             let a_error = self.tcx.const_error(a.ty(), guar);\n             if let ty::ConstKind::Infer(InferConst::Var(vid)) = a.kind() {\n-                return self.unify_const_variable(vid, a_error);\n+                return self.unify_const_variable(vid, a_error, relation.param_env());\n             }\n             let b_error = self.tcx.const_error(b.ty(), guar);\n             if let ty::ConstKind::Infer(InferConst::Var(vid)) = b.kind() {\n-                return self.unify_const_variable(vid, b_error);\n+                return self.unify_const_variable(vid, b_error, relation.param_env());\n             }\n \n             return Ok(if relation.a_is_expected() { a_error } else { b_error });\n@@ -237,11 +223,11 @@ impl<'tcx> InferCtxt<'tcx> {\n             }\n \n             (ty::ConstKind::Infer(InferConst::Var(vid)), _) => {\n-                return self.unify_const_variable(vid, b);\n+                return self.unify_const_variable(vid, b, relation.param_env());\n             }\n \n             (_, ty::ConstKind::Infer(InferConst::Var(vid))) => {\n-                return self.unify_const_variable(vid, a);\n+                return self.unify_const_variable(vid, a, relation.param_env());\n             }\n             (ty::ConstKind::Unevaluated(..), _) | (_, ty::ConstKind::Unevaluated(..))\n                 if self.tcx.lazy_normalization() =>\n@@ -252,7 +238,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             _ => {}\n         }\n \n-        ty::relate::super_relate_consts(relation, a, b)\n+        ty::relate::structurally_relate_consts(relation, a, b)\n     }\n \n     /// Unifies the const variable `target_vid` with the given constant.\n@@ -294,24 +280,17 @@ impl<'tcx> InferCtxt<'tcx> {\n         &self,\n         target_vid: ty::ConstVid<'tcx>,\n         ct: ty::Const<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n     ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n-        let (for_universe, span) = {\n-            let mut inner = self.inner.borrow_mut();\n-            let variable_table = &mut inner.const_unification_table();\n-            let var_value = variable_table.probe_value(target_vid);\n-            match var_value.val {\n-                ConstVariableValue::Known { value } => {\n-                    bug!(\"instantiating {:?} which has a known value {:?}\", target_vid, value)\n-                }\n-                ConstVariableValue::Unknown { universe } => (universe, var_value.origin.span),\n-            }\n-        };\n-        let value = ct.try_fold_with(&mut ConstInferUnifier {\n-            infcx: self,\n-            span,\n-            for_universe,\n+        let span =\n+            self.inner.borrow_mut().const_unification_table().probe_value(target_vid).origin.span;\n+        let Generalization { value, needs_wf: _ } = generalize::generalize(\n+            self,\n+            &mut CombineDelegate { infcx: self, span, param_env },\n+            ct,\n             target_vid,\n-        })?;\n+            ty::Variance::Invariant,\n+        )?;\n \n         self.inner.borrow_mut().const_unification_table().union_value(\n             target_vid,\n@@ -392,12 +371,10 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     pub fn instantiate(\n         &mut self,\n         a_ty: Ty<'tcx>,\n-        dir: RelationDir,\n+        ambient_variance: ty::Variance,\n         b_vid: ty::TyVid,\n         a_is_expected: bool,\n     ) -> RelateResult<'tcx, ()> {\n-        use self::RelationDir::*;\n-\n         // Get the actual variable that b_vid has been inferred to\n         debug_assert!(self.infcx.inner.borrow_mut().type_variables().probe(b_vid).is_unknown());\n \n@@ -412,7 +389,18 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // `'?2` and `?3` are fresh region/type inference\n         // variables. (Down below, we will relate `a_ty <: b_ty`,\n         // adding constraints like `'x: '?2` and `?1 <: ?3`.)\n-        let Generalization { ty: b_ty, needs_wf } = self.generalize(a_ty, b_vid, dir)?;\n+        let Generalization { value: b_ty, needs_wf } = generalize::generalize(\n+            self.infcx,\n+            &mut CombineDelegate {\n+                infcx: self.infcx,\n+                param_env: self.param_env,\n+                span: self.trace.span(),\n+            },\n+            a_ty,\n+            b_vid,\n+            ambient_variance,\n+        )?;\n+\n         debug!(?b_ty);\n         self.infcx.inner.borrow_mut().type_variables().instantiate(b_vid, b_ty);\n \n@@ -431,78 +419,23 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // relations wind up attributed to the same spans. We need\n         // to associate causes/spans with each of the relations in\n         // the stack to get this right.\n-        match dir {\n-            EqTo => self.equate(a_is_expected).relate(a_ty, b_ty),\n-            SubtypeOf => self.sub(a_is_expected).relate(a_ty, b_ty),\n-            SupertypeOf => self.sub(a_is_expected).relate_with_variance(\n+        match ambient_variance {\n+            ty::Variance::Invariant => self.equate(a_is_expected).relate(a_ty, b_ty),\n+            ty::Variance::Covariant => self.sub(a_is_expected).relate(a_ty, b_ty),\n+            ty::Variance::Contravariant => self.sub(a_is_expected).relate_with_variance(\n                 ty::Contravariant,\n                 ty::VarianceDiagInfo::default(),\n                 a_ty,\n                 b_ty,\n             ),\n+            ty::Variance::Bivariant => {\n+                unreachable!(\"no code should be generalizing bivariantly (currently)\")\n+            }\n         }?;\n \n         Ok(())\n     }\n \n-    /// Attempts to generalize `ty` for the type variable `for_vid`.\n-    /// This checks for cycle -- that is, whether the type `ty`\n-    /// references `for_vid`. The `dir` is the \"direction\" for which we\n-    /// a performing the generalization (i.e., are we producing a type\n-    /// that can be used as a supertype etc).\n-    ///\n-    /// Preconditions:\n-    ///\n-    /// - `for_vid` is a \"root vid\"\n-    #[instrument(skip(self), level = \"trace\", ret)]\n-    fn generalize(\n-        &self,\n-        ty: Ty<'tcx>,\n-        for_vid: ty::TyVid,\n-        dir: RelationDir,\n-    ) -> RelateResult<'tcx, Generalization<'tcx>> {\n-        // Determine the ambient variance within which `ty` appears.\n-        // The surrounding equation is:\n-        //\n-        //     ty [op] ty2\n-        //\n-        // where `op` is either `==`, `<:`, or `:>`. This maps quite\n-        // naturally.\n-        let ambient_variance = match dir {\n-            RelationDir::EqTo => ty::Invariant,\n-            RelationDir::SubtypeOf => ty::Covariant,\n-            RelationDir::SupertypeOf => ty::Contravariant,\n-        };\n-\n-        trace!(?ambient_variance);\n-\n-        let for_universe = match self.infcx.inner.borrow_mut().type_variables().probe(for_vid) {\n-            v @ TypeVariableValue::Known { .. } => {\n-                bug!(\"instantiating {:?} which has a known value {:?}\", for_vid, v,)\n-            }\n-            TypeVariableValue::Unknown { universe } => universe,\n-        };\n-\n-        trace!(?for_universe);\n-        trace!(?self.trace);\n-\n-        let mut generalize = Generalizer {\n-            infcx: self.infcx,\n-            cause: &self.trace.cause,\n-            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables().sub_root_var(for_vid),\n-            for_universe,\n-            ambient_variance,\n-            needs_wf: false,\n-            root_ty: ty,\n-            param_env: self.param_env,\n-            cache: SsoHashMap::new(),\n-        };\n-\n-        let ty = generalize.relate(ty, ty)?;\n-        let needs_wf = generalize.needs_wf;\n-        Ok(Generalization { ty, needs_wf })\n-    }\n-\n     pub fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.obligations.extend(obligations.into_iter());\n     }\n@@ -514,313 +447,6 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     }\n }\n \n-struct Generalizer<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'tcx>,\n-\n-    /// The span, used when creating new type variables and things.\n-    cause: &'cx ObligationCause<'tcx>,\n-\n-    /// The vid of the type variable that is in the process of being\n-    /// instantiated; if we find this within the type we are folding,\n-    /// that means we would have created a cyclic type.\n-    for_vid_sub_root: ty::TyVid,\n-\n-    /// The universe of the type variable that is in the process of\n-    /// being instantiated. Any fresh variables that we create in this\n-    /// process should be in that same universe.\n-    for_universe: ty::UniverseIndex,\n-\n-    /// Track the variance as we descend into the type.\n-    ambient_variance: ty::Variance,\n-\n-    /// See the field `needs_wf` in `Generalization`.\n-    needs_wf: bool,\n-\n-    /// The root type that we are generalizing. Used when reporting cycles.\n-    root_ty: Ty<'tcx>,\n-\n-    param_env: ty::ParamEnv<'tcx>,\n-\n-    cache: SsoHashMap<Ty<'tcx>, Ty<'tcx>>,\n-}\n-\n-/// Result from a generalization operation. This includes\n-/// not only the generalized type, but also a bool flag\n-/// indicating whether further WF checks are needed.\n-#[derive(Debug)]\n-struct Generalization<'tcx> {\n-    ty: Ty<'tcx>,\n-\n-    /// If true, then the generalized type may not be well-formed,\n-    /// even if the source type is well-formed, so we should add an\n-    /// additional check to enforce that it is. This arises in\n-    /// particular around 'bivariant' type parameters that are only\n-    /// constrained by a where-clause. As an example, imagine a type:\n-    ///\n-    ///     struct Foo<A, B> where A: Iterator<Item = B> {\n-    ///         data: A\n-    ///     }\n-    ///\n-    /// here, `A` will be covariant, but `B` is\n-    /// unconstrained. However, whatever it is, for `Foo` to be WF, it\n-    /// must be equal to `A::Item`. If we have an input `Foo<?A, ?B>`,\n-    /// then after generalization we will wind up with a type like\n-    /// `Foo<?C, ?D>`. When we enforce that `Foo<?A, ?B> <: Foo<?C,\n-    /// ?D>` (or `>:`), we will wind up with the requirement that `?A\n-    /// <: ?C`, but no particular relationship between `?B` and `?D`\n-    /// (after all, we do not know the variance of the normalized form\n-    /// of `A::Item` with respect to `A`). If we do nothing else, this\n-    /// may mean that `?D` goes unconstrained (as in #41677). So, in\n-    /// this scenario where we create a new type variable in a\n-    /// bivariant context, we set the `needs_wf` flag to true. This\n-    /// will force the calling code to check that `WF(Foo<?C, ?D>)`\n-    /// holds, which in turn implies that `?C::Item == ?D`. So once\n-    /// `?C` is constrained, that should suffice to restrict `?D`.\n-    needs_wf: bool,\n-}\n-\n-impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        self.param_env\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"Generalizer\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn binders<T>(\n-        &mut self,\n-        a: ty::Binder<'tcx, T>,\n-        b: ty::Binder<'tcx, T>,\n-    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n-    where\n-        T: Relate<'tcx>,\n-    {\n-        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n-    }\n-\n-    fn relate_item_substs(\n-        &mut self,\n-        item_def_id: DefId,\n-        a_subst: SubstsRef<'tcx>,\n-        b_subst: SubstsRef<'tcx>,\n-    ) -> RelateResult<'tcx, SubstsRef<'tcx>> {\n-        if self.ambient_variance == ty::Variance::Invariant {\n-            // Avoid fetching the variance if we are in an invariant\n-            // context; no need, and it can induce dependency cycles\n-            // (e.g., #41849).\n-            relate::relate_substs(self, a_subst, b_subst)\n-        } else {\n-            let tcx = self.tcx();\n-            let opt_variances = tcx.variances_of(item_def_id);\n-            relate::relate_substs_with_variances(\n-                self,\n-                item_def_id,\n-                &opt_variances,\n-                a_subst,\n-                b_subst,\n-                true,\n-            )\n-        }\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        variance: ty::Variance,\n-        _info: ty::VarianceDiagInfo<'tcx>,\n-        a: T,\n-        b: T,\n-    ) -> RelateResult<'tcx, T> {\n-        let old_ambient_variance = self.ambient_variance;\n-        self.ambient_variance = self.ambient_variance.xform(variance);\n-\n-        let result = self.relate(a, b);\n-        self.ambient_variance = old_ambient_variance;\n-        result\n-    }\n-\n-    fn tys(&mut self, t: Ty<'tcx>, t2: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        assert_eq!(t, t2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n-\n-        if let Some(&result) = self.cache.get(&t) {\n-            return Ok(result);\n-        }\n-        debug!(\"generalize: t={:?}\", t);\n-\n-        // Check to see whether the type we are generalizing references\n-        // any other type variable related to `vid` via\n-        // subtyping. This is basically our \"occurs check\", preventing\n-        // us from creating infinitely sized types.\n-        let result = match *t.kind() {\n-            ty::Infer(ty::TyVar(vid)) => {\n-                let vid = self.infcx.inner.borrow_mut().type_variables().root_var(vid);\n-                let sub_vid = self.infcx.inner.borrow_mut().type_variables().sub_root_var(vid);\n-                if sub_vid == self.for_vid_sub_root {\n-                    // If sub-roots are equal, then `for_vid` and\n-                    // `vid` are related via subtyping.\n-                    Err(TypeError::CyclicTy(self.root_ty))\n-                } else {\n-                    let probe = self.infcx.inner.borrow_mut().type_variables().probe(vid);\n-                    match probe {\n-                        TypeVariableValue::Known { value: u } => {\n-                            debug!(\"generalize: known value {:?}\", u);\n-                            self.relate(u, u)\n-                        }\n-                        TypeVariableValue::Unknown { universe } => {\n-                            match self.ambient_variance {\n-                                // Invariant: no need to make a fresh type variable.\n-                                ty::Invariant => {\n-                                    if self.for_universe.can_name(universe) {\n-                                        return Ok(t);\n-                                    }\n-                                }\n-\n-                                // Bivariant: make a fresh var, but we\n-                                // may need a WF predicate. See\n-                                // comment on `needs_wf` field for\n-                                // more info.\n-                                ty::Bivariant => self.needs_wf = true,\n-\n-                                // Co/contravariant: this will be\n-                                // sufficiently constrained later on.\n-                                ty::Covariant | ty::Contravariant => (),\n-                            }\n-\n-                            let origin =\n-                                *self.infcx.inner.borrow_mut().type_variables().var_origin(vid);\n-                            let new_var_id = self\n-                                .infcx\n-                                .inner\n-                                .borrow_mut()\n-                                .type_variables()\n-                                .new_var(self.for_universe, origin);\n-                            let u = self.tcx().mk_ty_var(new_var_id);\n-\n-                            // Record that we replaced `vid` with `new_var_id` as part of a generalization\n-                            // operation. This is needed to detect cyclic types. To see why, see the\n-                            // docs in the `type_variables` module.\n-                            self.infcx.inner.borrow_mut().type_variables().sub(vid, new_var_id);\n-                            debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n-                            Ok(u)\n-                        }\n-                    }\n-                }\n-            }\n-            ty::Infer(ty::IntVar(_) | ty::FloatVar(_)) => {\n-                // No matter what mode we are in,\n-                // integer/floating-point types must be equal to be\n-                // relatable.\n-                Ok(t)\n-            }\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                let s = self.relate(substs, substs)?;\n-                Ok(if s == substs { t } else { self.infcx.tcx.mk_opaque(def_id, s) })\n-            }\n-            _ => relate::super_relate_tys(self, t, t),\n-        }?;\n-\n-        self.cache.insert(t, result);\n-        Ok(result)\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        r: ty::Region<'tcx>,\n-        r2: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        assert_eq!(r, r2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n-\n-        debug!(\"generalize: regions r={:?}\", r);\n-\n-        match *r {\n-            // Never make variables for regions bound within the type itself,\n-            // nor for erased regions.\n-            ty::ReLateBound(..) | ty::ReErased => {\n-                return Ok(r);\n-            }\n-\n-            ty::ReError(_) => {\n-                return Ok(r);\n-            }\n-\n-            ty::RePlaceholder(..)\n-            | ty::ReVar(..)\n-            | ty::ReStatic\n-            | ty::ReEarlyBound(..)\n-            | ty::ReFree(..) => {\n-                // see common code below\n-            }\n-        }\n-\n-        // If we are in an invariant context, we can re-use the region\n-        // as is, unless it happens to be in some universe that we\n-        // can't name. (In the case of a region *variable*, we could\n-        // use it if we promoted it into our universe, but we don't\n-        // bother.)\n-        if let ty::Invariant = self.ambient_variance {\n-            let r_universe = self.infcx.universe_of_region(r);\n-            if self.for_universe.can_name(r_universe) {\n-                return Ok(r);\n-            }\n-        }\n-\n-        // FIXME: This is non-ideal because we don't give a\n-        // very descriptive origin for this region variable.\n-        Ok(self.infcx.next_region_var_in_universe(MiscVariable(self.cause.span), self.for_universe))\n-    }\n-\n-    fn consts(\n-        &mut self,\n-        c: ty::Const<'tcx>,\n-        c2: ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n-        assert_eq!(c, c2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n-\n-        match c.kind() {\n-            ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                let mut inner = self.infcx.inner.borrow_mut();\n-                let variable_table = &mut inner.const_unification_table();\n-                let var_value = variable_table.probe_value(vid);\n-                match var_value.val {\n-                    ConstVariableValue::Known { value: u } => {\n-                        drop(inner);\n-                        self.relate(u, u)\n-                    }\n-                    ConstVariableValue::Unknown { universe } => {\n-                        if self.for_universe.can_name(universe) {\n-                            Ok(c)\n-                        } else {\n-                            let new_var_id = variable_table.new_key(ConstVarValue {\n-                                origin: var_value.origin,\n-                                val: ConstVariableValue::Unknown { universe: self.for_universe },\n-                            });\n-                            Ok(self.tcx().mk_const(new_var_id, c.ty()))\n-                        }\n-                    }\n-                }\n-            }\n-            ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }) => {\n-                let substs = self.relate_with_variance(\n-                    ty::Variance::Invariant,\n-                    ty::VarianceDiagInfo::default(),\n-                    substs,\n-                    substs,\n-                )?;\n-                Ok(self.tcx().mk_const(ty::UnevaluatedConst { def, substs }, c.ty()))\n-            }\n-            _ => relate::super_relate_consts(self, c, c),\n-        }\n-    }\n-}\n-\n pub trait ObligationEmittingRelation<'tcx>: TypeRelation<'tcx> {\n     /// Register obligations that must hold in order for this relation to hold\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>);\n@@ -873,135 +499,3 @@ fn float_unification_error<'tcx>(\n     let (ty::FloatVarValue(a), ty::FloatVarValue(b)) = v;\n     TypeError::FloatMismatch(ExpectedFound::new(a_is_expected, a, b))\n }\n-\n-struct ConstInferUnifier<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'tcx>,\n-\n-    span: Span,\n-\n-    for_universe: ty::UniverseIndex,\n-\n-    /// The vid of the const variable that is in the process of being\n-    /// instantiated; if we find this within the const we are folding,\n-    /// that means we would have created a cyclic const.\n-    target_vid: ty::ConstVid<'tcx>,\n-}\n-\n-impl<'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for ConstInferUnifier<'_, 'tcx> {\n-    type Error = TypeError<'tcx>;\n-\n-    fn interner(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    #[instrument(level = \"debug\", skip(self), ret)]\n-    fn try_fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, TypeError<'tcx>> {\n-        match t.kind() {\n-            &ty::Infer(ty::TyVar(vid)) => {\n-                let vid = self.infcx.inner.borrow_mut().type_variables().root_var(vid);\n-                let probe = self.infcx.inner.borrow_mut().type_variables().probe(vid);\n-                match probe {\n-                    TypeVariableValue::Known { value: u } => {\n-                        debug!(\"ConstOccursChecker: known value {:?}\", u);\n-                        u.try_fold_with(self)\n-                    }\n-                    TypeVariableValue::Unknown { universe } => {\n-                        if self.for_universe.can_name(universe) {\n-                            return Ok(t);\n-                        }\n-\n-                        let origin =\n-                            *self.infcx.inner.borrow_mut().type_variables().var_origin(vid);\n-                        let new_var_id = self\n-                            .infcx\n-                            .inner\n-                            .borrow_mut()\n-                            .type_variables()\n-                            .new_var(self.for_universe, origin);\n-                        Ok(self.interner().mk_ty_var(new_var_id))\n-                    }\n-                }\n-            }\n-            ty::Infer(ty::IntVar(_) | ty::FloatVar(_)) => Ok(t),\n-            _ => t.try_super_fold_with(self),\n-        }\n-    }\n-\n-    #[instrument(level = \"debug\", skip(self), ret)]\n-    fn try_fold_region(\n-        &mut self,\n-        r: ty::Region<'tcx>,\n-    ) -> Result<ty::Region<'tcx>, TypeError<'tcx>> {\n-        debug!(\"ConstInferUnifier: r={:?}\", r);\n-\n-        match *r {\n-            // Never make variables for regions bound within the type itself,\n-            // nor for erased regions.\n-            ty::ReLateBound(..) | ty::ReErased | ty::ReError(_) => {\n-                return Ok(r);\n-            }\n-\n-            ty::RePlaceholder(..)\n-            | ty::ReVar(..)\n-            | ty::ReStatic\n-            | ty::ReEarlyBound(..)\n-            | ty::ReFree(..) => {\n-                // see common code below\n-            }\n-        }\n-\n-        let r_universe = self.infcx.universe_of_region(r);\n-        if self.for_universe.can_name(r_universe) {\n-            return Ok(r);\n-        } else {\n-            // FIXME: This is non-ideal because we don't give a\n-            // very descriptive origin for this region variable.\n-            Ok(self.infcx.next_region_var_in_universe(MiscVariable(self.span), self.for_universe))\n-        }\n-    }\n-\n-    #[instrument(level = \"debug\", skip(self), ret)]\n-    fn try_fold_const(&mut self, c: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, TypeError<'tcx>> {\n-        match c.kind() {\n-            ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                // Check if the current unification would end up\n-                // unifying `target_vid` with a const which contains\n-                // an inference variable which is unioned with `target_vid`.\n-                //\n-                // Not doing so can easily result in stack overflows.\n-                if self\n-                    .infcx\n-                    .inner\n-                    .borrow_mut()\n-                    .const_unification_table()\n-                    .unioned(self.target_vid, vid)\n-                {\n-                    return Err(TypeError::CyclicConst(c));\n-                }\n-\n-                let var_value =\n-                    self.infcx.inner.borrow_mut().const_unification_table().probe_value(vid);\n-                match var_value.val {\n-                    ConstVariableValue::Known { value: u } => u.try_fold_with(self),\n-                    ConstVariableValue::Unknown { universe } => {\n-                        if self.for_universe.can_name(universe) {\n-                            Ok(c)\n-                        } else {\n-                            let new_var_id =\n-                                self.infcx.inner.borrow_mut().const_unification_table().new_key(\n-                                    ConstVarValue {\n-                                        origin: var_value.origin,\n-                                        val: ConstVariableValue::Unknown {\n-                                            universe: self.for_universe,\n-                                        },\n-                                    },\n-                                );\n-                            Ok(self.interner().mk_const(new_var_id, c.ty()))\n-                        }\n-                    }\n-                }\n-            }\n-            _ => c.try_super_fold_with(self),\n-        }\n-    }\n-}"}, {"sha": "793505e4ab23dec08c3d25e85eef86dfc018e26f", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=ea54255501221b26bf2242c09cbd0924dc8ee1ea", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::DefineOpaqueTypes;\n use crate::traits::PredicateObligations;\n \n-use super::combine::{CombineFields, ObligationEmittingRelation, RelationDir};\n+use super::combine::{CombineFields, ObligationEmittingRelation};\n use super::Subtype;\n \n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n@@ -88,11 +88,11 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n             }\n \n             (&ty::Infer(TyVar(a_id)), _) => {\n-                self.fields.instantiate(b, RelationDir::EqTo, a_id, self.a_is_expected)?;\n+                self.fields.instantiate(b, ty::Invariant, a_id, self.a_is_expected)?;\n             }\n \n             (_, &ty::Infer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n+                self.fields.instantiate(a, ty::Invariant, b_id, self.a_is_expected)?;\n             }\n \n             ("}, {"sha": "ad4f5058b5ecde299b5f8b48838930492e162a3a", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ea54255501221b26bf2242c09cbd0924dc8ee1ea", "patch": "@@ -2723,7 +2723,7 @@ impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n             | (ty::Infer(ty::InferTy::TyVar(_)), _)\n             | (_, ty::Infer(ty::InferTy::TyVar(_))) => Ok(a),\n             (ty::Infer(_), _) | (_, ty::Infer(_)) => Err(TypeError::Mismatch),\n-            _ => relate::super_relate_tys(self, a, b),\n+            _ => relate::structurally_relate_tys(self, a, b),\n         }\n     }\n "}, {"sha": "d4a1dacde1047520cf713ba0201f92f11dd1bbe8", "filename": "compiler/rustc_infer/src/infer/generalize.rs", "status": "added", "additions": 479, "deletions": 0, "changes": 479, "blob_url": "https://github.com/rust-lang/rust/blob/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fgeneralize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fgeneralize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fgeneralize.rs?ref=ea54255501221b26bf2242c09cbd0924dc8ee1ea", "patch": "@@ -0,0 +1,479 @@\n+use rustc_data_structures::sso::SsoHashMap;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::{self, InferConst, Term, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_span::Span;\n+\n+use crate::infer::nll_relate::TypeRelatingDelegate;\n+use crate::infer::type_variable::TypeVariableValue;\n+use crate::infer::{InferCtxt, RegionVariableOrigin};\n+\n+/// Attempts to generalize `term` for the type variable `for_vid`.\n+/// This checks for cycles -- that is, whether the type `term`\n+/// references `for_vid`.\n+pub(super) fn generalize<'tcx, D: GeneralizerDelegate<'tcx>, T: Into<Term<'tcx>> + Relate<'tcx>>(\n+    infcx: &InferCtxt<'tcx>,\n+    delegate: &mut D,\n+    term: T,\n+    for_vid: impl Into<ty::TermVid<'tcx>>,\n+    ambient_variance: ty::Variance,\n+) -> RelateResult<'tcx, Generalization<T>> {\n+    let (for_universe, root_vid) = match for_vid.into() {\n+        ty::TermVid::Ty(ty_vid) => (\n+            infcx.probe_ty_var(ty_vid).unwrap_err(),\n+            ty::TermVid::Ty(infcx.inner.borrow_mut().type_variables().sub_root_var(ty_vid)),\n+        ),\n+        ty::TermVid::Const(ct_vid) => (\n+            infcx.probe_const_var(ct_vid).unwrap_err(),\n+            ty::TermVid::Const(infcx.inner.borrow_mut().const_unification_table().find(ct_vid)),\n+        ),\n+    };\n+\n+    let mut generalizer = Generalizer {\n+        infcx,\n+        delegate,\n+        ambient_variance,\n+        root_vid,\n+        for_universe,\n+        root_term: term.into(),\n+        needs_wf: false,\n+        cache: Default::default(),\n+    };\n+\n+    assert!(!term.has_escaping_bound_vars());\n+    let value = generalizer.relate(term, term)?;\n+    let needs_wf = generalizer.needs_wf;\n+    Ok(Generalization { value, needs_wf })\n+}\n+\n+/// Abstracts the handling of region vars between HIR and MIR/NLL typechecking\n+/// in the generalizer code.\n+pub trait GeneralizerDelegate<'tcx> {\n+    fn param_env(&self) -> ty::ParamEnv<'tcx>;\n+\n+    fn forbid_inference_vars() -> bool;\n+\n+    fn generalize_region(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx>;\n+}\n+\n+pub struct CombineDelegate<'cx, 'tcx> {\n+    pub infcx: &'cx InferCtxt<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    pub span: Span,\n+}\n+\n+impl<'tcx> GeneralizerDelegate<'tcx> for CombineDelegate<'_, 'tcx> {\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+\n+    fn forbid_inference_vars() -> bool {\n+        false\n+    }\n+\n+    fn generalize_region(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n+        // FIXME: This is non-ideal because we don't give a\n+        // very descriptive origin for this region variable.\n+        self.infcx\n+            .next_region_var_in_universe(RegionVariableOrigin::MiscVariable(self.span), universe)\n+    }\n+}\n+\n+impl<'tcx, T> GeneralizerDelegate<'tcx> for T\n+where\n+    T: TypeRelatingDelegate<'tcx>,\n+{\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        <Self as TypeRelatingDelegate<'tcx>>::param_env(self)\n+    }\n+\n+    fn forbid_inference_vars() -> bool {\n+        <Self as TypeRelatingDelegate<'tcx>>::forbid_inference_vars()\n+    }\n+\n+    fn generalize_region(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n+        <Self as TypeRelatingDelegate<'tcx>>::generalize_existential(self, universe)\n+    }\n+}\n+\n+/// The \"generalizer\" is used when handling inference variables.\n+///\n+/// The basic strategy for handling a constraint like `?A <: B` is to\n+/// apply a \"generalization strategy\" to the term `B` -- this replaces\n+/// all the lifetimes in the term `B` with fresh inference variables.\n+/// (You can read more about the strategy in this [blog post].)\n+///\n+/// As an example, if we had `?A <: &'x u32`, we would generalize `&'x\n+/// u32` to `&'0 u32` where `'0` is a fresh variable. This becomes the\n+/// value of `A`. Finally, we relate `&'0 u32 <: &'x u32`, which\n+/// establishes `'0: 'x` as a constraint.\n+///\n+/// [blog post]: https://is.gd/0hKvIr\n+struct Generalizer<'me, 'tcx, D> {\n+    infcx: &'me InferCtxt<'tcx>,\n+\n+    /// This is used to abstract the behaviors of the three previous\n+    /// generalizer-like implementations (`Generalizer`, `TypeGeneralizer`,\n+    /// and `ConstInferUnifier`). See [`GeneralizerDelegate`] for more\n+    /// information.\n+    delegate: &'me mut D,\n+\n+    /// After we generalize this type, we are going to relate it to\n+    /// some other type. What will be the variance at this point?\n+    ambient_variance: ty::Variance,\n+\n+    /// The vid of the type variable that is in the process of being\n+    /// instantiated. If we find this within the value we are folding,\n+    /// that means we would have created a cyclic value.\n+    root_vid: ty::TermVid<'tcx>,\n+\n+    /// The universe of the type variable that is in the process of being\n+    /// instantiated. If we find anything that this universe cannot name,\n+    /// we reject the relation.\n+    for_universe: ty::UniverseIndex,\n+\n+    /// The root term (const or type) we're generalizing. Used for cycle errors.\n+    root_term: Term<'tcx>,\n+\n+    cache: SsoHashMap<Ty<'tcx>, Ty<'tcx>>,\n+\n+    /// See the field `needs_wf` in `Generalization`.\n+    needs_wf: bool,\n+}\n+\n+impl<'tcx, D> Generalizer<'_, 'tcx, D> {\n+    /// Create an error that corresponds to the term kind in `root_term`\n+    fn cyclic_term_error(&self) -> TypeError<'tcx> {\n+        match self.root_term.unpack() {\n+            ty::TermKind::Ty(ty) => TypeError::CyclicTy(ty),\n+            ty::TermKind::Const(ct) => TypeError::CyclicConst(ct),\n+        }\n+    }\n+}\n+\n+impl<'tcx, D> TypeRelation<'tcx> for Generalizer<'_, 'tcx, D>\n+where\n+    D: GeneralizerDelegate<'tcx>,\n+{\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.delegate.param_env()\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"Generalizer\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_item_substs(\n+        &mut self,\n+        item_def_id: DefId,\n+        a_subst: ty::SubstsRef<'tcx>,\n+        b_subst: ty::SubstsRef<'tcx>,\n+    ) -> RelateResult<'tcx, ty::SubstsRef<'tcx>> {\n+        if self.ambient_variance == ty::Variance::Invariant {\n+            // Avoid fetching the variance if we are in an invariant\n+            // context; no need, and it can induce dependency cycles\n+            // (e.g., #41849).\n+            relate::relate_substs(self, a_subst, b_subst)\n+        } else {\n+            let tcx = self.tcx();\n+            let opt_variances = tcx.variances_of(item_def_id);\n+            relate::relate_substs_with_variances(\n+                self,\n+                item_def_id,\n+                opt_variances,\n+                a_subst,\n+                b_subst,\n+                true,\n+            )\n+        }\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, variance, b), ret)]\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n+        a: T,\n+        b: T,\n+    ) -> RelateResult<'tcx, T> {\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n+        debug!(?self.ambient_variance, \"new ambient variance\");\n+        let r = self.relate(a, b)?;\n+        self.ambient_variance = old_ambient_variance;\n+        Ok(r)\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, t2), ret)]\n+    fn tys(&mut self, t: Ty<'tcx>, t2: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        assert_eq!(t, t2); // we are misusing TypeRelation here; both LHS and RHS ought to be ==\n+\n+        if let Some(&result) = self.cache.get(&t) {\n+            return Ok(result);\n+        }\n+\n+        // Check to see whether the type we are generalizing references\n+        // any other type variable related to `vid` via\n+        // subtyping. This is basically our \"occurs check\", preventing\n+        // us from creating infinitely sized types.\n+        let g = match *t.kind() {\n+            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_))\n+                if D::forbid_inference_vars() =>\n+            {\n+                bug!(\"unexpected inference variable encountered in NLL generalization: {t}\");\n+            }\n+\n+            ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+                bug!(\"unexpected infer type: {t}\")\n+            }\n+\n+            ty::Infer(ty::TyVar(vid)) => {\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let vid = inner.type_variables().root_var(vid);\n+                let sub_vid = inner.type_variables().sub_root_var(vid);\n+\n+                if ty::TermVid::Ty(sub_vid) == self.root_vid {\n+                    // If sub-roots are equal, then `root_vid` and\n+                    // `vid` are related via subtyping.\n+                    Err(self.cyclic_term_error())\n+                } else {\n+                    let probe = inner.type_variables().probe(vid);\n+                    match probe {\n+                        TypeVariableValue::Known { value: u } => {\n+                            drop(inner);\n+                            self.relate(u, u)\n+                        }\n+                        TypeVariableValue::Unknown { universe } => {\n+                            match self.ambient_variance {\n+                                // Invariant: no need to make a fresh type variable\n+                                // if we can name the universe.\n+                                ty::Invariant => {\n+                                    if self.for_universe.can_name(universe) {\n+                                        return Ok(t);\n+                                    }\n+                                }\n+\n+                                // Bivariant: make a fresh var, but we\n+                                // may need a WF predicate. See\n+                                // comment on `needs_wf` field for\n+                                // more info.\n+                                ty::Bivariant => self.needs_wf = true,\n+\n+                                // Co/contravariant: this will be\n+                                // sufficiently constrained later on.\n+                                ty::Covariant | ty::Contravariant => (),\n+                            }\n+\n+                            let origin = *inner.type_variables().var_origin(vid);\n+                            let new_var_id =\n+                                inner.type_variables().new_var(self.for_universe, origin);\n+                            let u = self.tcx().mk_ty_var(new_var_id);\n+\n+                            // Record that we replaced `vid` with `new_var_id` as part of a generalization\n+                            // operation. This is needed to detect cyclic types. To see why, see the\n+                            // docs in the `type_variables` module.\n+                            inner.type_variables().sub(vid, new_var_id);\n+                            debug!(\"replacing original vid={:?} with new={:?}\", vid, u);\n+                            Ok(u)\n+                        }\n+                    }\n+                }\n+            }\n+\n+            ty::Infer(ty::IntVar(_) | ty::FloatVar(_)) => {\n+                // No matter what mode we are in,\n+                // integer/floating-point types must be equal to be\n+                // relatable.\n+                Ok(t)\n+            }\n+\n+            ty::Placeholder(placeholder) => {\n+                if self.for_universe.can_name(placeholder.universe) {\n+                    Ok(t)\n+                } else {\n+                    debug!(\n+                        \"root universe {:?} cannot name placeholder in universe {:?}\",\n+                        self.for_universe, placeholder.universe\n+                    );\n+                    Err(TypeError::Mismatch)\n+                }\n+            }\n+\n+            _ => relate::structurally_relate_tys(self, t, t),\n+        }?;\n+\n+        self.cache.insert(t, g);\n+        Ok(g)\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, r2), ret)]\n+    fn regions(\n+        &mut self,\n+        r: ty::Region<'tcx>,\n+        r2: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        assert_eq!(r, r2); // we are misusing TypeRelation here; both LHS and RHS ought to be ==\n+\n+        match *r {\n+            // Never make variables for regions bound within the type itself,\n+            // nor for erased regions.\n+            ty::ReLateBound(..) | ty::ReErased => {\n+                return Ok(r);\n+            }\n+\n+            // It doesn't really matter for correctness if we generalize ReError,\n+            // since we're already on a doomed compilation path.\n+            ty::ReError(_) => {\n+                return Ok(r);\n+            }\n+\n+            ty::RePlaceholder(..)\n+            | ty::ReVar(..)\n+            | ty::ReStatic\n+            | ty::ReEarlyBound(..)\n+            | ty::ReFree(..) => {\n+                // see common code below\n+            }\n+        }\n+\n+        // If we are in an invariant context, we can re-use the region\n+        // as is, unless it happens to be in some universe that we\n+        // can't name.\n+        if let ty::Invariant = self.ambient_variance {\n+            let r_universe = self.infcx.universe_of_region(r);\n+            if self.for_universe.can_name(r_universe) {\n+                return Ok(r);\n+            }\n+        }\n+\n+        Ok(self.delegate.generalize_region(self.for_universe))\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, c2), ret)]\n+    fn consts(\n+        &mut self,\n+        c: ty::Const<'tcx>,\n+        c2: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n+        assert_eq!(c, c2); // we are misusing TypeRelation here; both LHS and RHS ought to be ==\n+\n+        match c.kind() {\n+            ty::ConstKind::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n+                bug!(\"unexpected inference variable encountered in NLL generalization: {:?}\", c);\n+            }\n+            ty::ConstKind::Infer(InferConst::Var(vid)) => {\n+                // If root const vids are equal, then `root_vid` and\n+                // `vid` are related and we'd be inferring an infinitely\n+                // deep const.\n+                if ty::TermVid::Const(\n+                    self.infcx.inner.borrow_mut().const_unification_table().find(vid),\n+                ) == self.root_vid\n+                {\n+                    return Err(self.cyclic_term_error());\n+                }\n+\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let variable_table = &mut inner.const_unification_table();\n+                let var_value = variable_table.probe_value(vid);\n+                match var_value.val {\n+                    ConstVariableValue::Known { value: u } => {\n+                        drop(inner);\n+                        self.relate(u, u)\n+                    }\n+                    ConstVariableValue::Unknown { universe } => {\n+                        if self.for_universe.can_name(universe) {\n+                            Ok(c)\n+                        } else {\n+                            let new_var_id = variable_table.new_key(ConstVarValue {\n+                                origin: var_value.origin,\n+                                val: ConstVariableValue::Unknown { universe: self.for_universe },\n+                            });\n+                            Ok(self.tcx().mk_const(new_var_id, c.ty()))\n+                        }\n+                    }\n+                }\n+            }\n+            // FIXME: remove this branch once `structurally_relate_consts` is fully\n+            // structural.\n+            ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }) => {\n+                let substs = self.relate_with_variance(\n+                    ty::Variance::Invariant,\n+                    ty::VarianceDiagInfo::default(),\n+                    substs,\n+                    substs,\n+                )?;\n+                Ok(self.tcx().mk_const(ty::UnevaluatedConst { def, substs }, c.ty()))\n+            }\n+            ty::ConstKind::Placeholder(placeholder) => {\n+                if self.for_universe.can_name(placeholder.universe) {\n+                    Ok(c)\n+                } else {\n+                    debug!(\n+                        \"root universe {:?} cannot name placeholder in universe {:?}\",\n+                        self.for_universe, placeholder.universe\n+                    );\n+                    Err(TypeError::Mismatch)\n+                }\n+            }\n+            _ => relate::structurally_relate_consts(self, c, c),\n+        }\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn binders<T>(\n+        &mut self,\n+        a: ty::Binder<'tcx, T>,\n+        _: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        let result = self.relate(a.skip_binder(), a.skip_binder())?;\n+        Ok(a.rebind(result))\n+    }\n+}\n+\n+/// Result from a generalization operation. This includes\n+/// not only the generalized type, but also a bool flag\n+/// indicating whether further WF checks are needed.\n+#[derive(Debug)]\n+pub struct Generalization<T> {\n+    pub value: T,\n+\n+    /// If true, then the generalized type may not be well-formed,\n+    /// even if the source type is well-formed, so we should add an\n+    /// additional check to enforce that it is. This arises in\n+    /// particular around 'bivariant' type parameters that are only\n+    /// constrained by a where-clause. As an example, imagine a type:\n+    ///\n+    ///     struct Foo<A, B> where A: Iterator<Item = B> {\n+    ///         data: A\n+    ///     }\n+    ///\n+    /// here, `A` will be covariant, but `B` is\n+    /// unconstrained. However, whatever it is, for `Foo` to be WF, it\n+    /// must be equal to `A::Item`. If we have an input `Foo<?A, ?B>`,\n+    /// then after generalization we will wind up with a type like\n+    /// `Foo<?C, ?D>`. When we enforce that `Foo<?A, ?B> <: Foo<?C,\n+    /// ?D>` (or `>:`), we will wind up with the requirement that `?A\n+    /// <: ?C`, but no particular relationship between `?B` and `?D`\n+    /// (after all, we do not know the variance of the normalized form\n+    /// of `A::Item` with respect to `A`). If we do nothing else, this\n+    /// may mean that `?D` goes unconstrained (as in #41677). So, in\n+    /// this scenario where we create a new type variable in a\n+    /// bivariant context, we set the `needs_wf` flag to true. This\n+    /// will force the calling code to check that `WF(Foo<?C, ?D>)`\n+    /// holds, which in turn implies that `?C::Item == ?D`. So once\n+    /// `?C` is constrained, that should suffice to restrict `?D`.\n+    pub needs_wf: bool,\n+}"}, {"sha": "e53319e3b86be7102b0233fae0be1547859034b4", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=ea54255501221b26bf2242c09cbd0924dc8ee1ea", "patch": "@@ -58,6 +58,7 @@ pub mod error_reporting;\n pub mod free_regions;\n mod freshen;\n mod fudge;\n+mod generalize;\n mod glb;\n mod higher_ranked;\n pub mod lattice;"}, {"sha": "4ae6af5f5be750ee41442446a2f264b7862b0a00", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 16, "deletions": 260, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=ea54255501221b26bf2242c09cbd0924dc8ee1ea", "patch": "@@ -21,21 +21,20 @@\n //!   thing we relate in chalk are basically domain goals and their\n //!   constituents)\n \n-use crate::infer::InferCtxt;\n-use crate::infer::{ConstVarValue, ConstVariableValue};\n-use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::traits::{Obligation, PredicateObligations};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::traits::ObligationCause;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::FnMutDelegate;\n-use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n use rustc_span::{Span, Symbol};\n use std::fmt::Debug;\n \n-use super::combine::ObligationEmittingRelation;\n+use crate::infer::combine::ObligationEmittingRelation;\n+use crate::infer::generalize::{self, Generalization};\n+use crate::infer::InferCtxt;\n+use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::traits::{Obligation, PredicateObligations};\n \n pub struct TypeRelating<'me, 'tcx, D>\n where\n@@ -198,7 +197,7 @@ where\n             _ => (),\n         }\n \n-        let generalized_ty = self.generalize_value(value_ty, vid)?;\n+        let generalized_ty = self.generalize(value_ty, vid)?;\n         debug!(\"relate_ty_var: generalized_ty = {:?}\", generalized_ty);\n \n         if D::forbid_inference_vars() {\n@@ -217,26 +216,15 @@ where\n         result\n     }\n \n-    fn generalize_value<T: Relate<'tcx>>(\n-        &mut self,\n-        value: T,\n-        for_vid: ty::TyVid,\n-    ) -> RelateResult<'tcx, T> {\n-        let universe = self.infcx.probe_ty_var(for_vid).unwrap_err();\n-\n-        if value.has_escaping_bound_vars() {\n-            bug!(\"trying to instantiate {for_vid:?} with escaping bound vars: {value:?}\");\n-        }\n-\n-        let mut generalizer = TypeGeneralizer {\n-            infcx: self.infcx,\n-            delegate: &mut self.delegate,\n-            ambient_variance: self.ambient_variance,\n-            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables().sub_root_var(for_vid),\n-            universe,\n-        };\n-\n-        generalizer.relate(value, value)\n+    fn generalize(&mut self, ty: Ty<'tcx>, for_vid: ty::TyVid) -> RelateResult<'tcx, Ty<'tcx>> {\n+        let Generalization { value: ty, needs_wf: _ } = generalize::generalize(\n+            self.infcx,\n+            &mut self.delegate,\n+            ty,\n+            for_vid,\n+            self.ambient_variance,\n+        )?;\n+        Ok(ty)\n     }\n \n     fn relate_opaques(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n@@ -716,235 +704,3 @@ where\n         })]);\n     }\n }\n-\n-/// The \"type generalizer\" is used when handling inference variables.\n-///\n-/// The basic strategy for handling a constraint like `?A <: B` is to\n-/// apply a \"generalization strategy\" to the type `B` -- this replaces\n-/// all the lifetimes in the type `B` with fresh inference\n-/// variables. (You can read more about the strategy in this [blog\n-/// post].)\n-///\n-/// As an example, if we had `?A <: &'x u32`, we would generalize `&'x\n-/// u32` to `&'0 u32` where `'0` is a fresh variable. This becomes the\n-/// value of `A`. Finally, we relate `&'0 u32 <: &'x u32`, which\n-/// establishes `'0: 'x` as a constraint.\n-///\n-/// [blog post]: https://is.gd/0hKvIr\n-struct TypeGeneralizer<'me, 'tcx, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n-    infcx: &'me InferCtxt<'tcx>,\n-\n-    delegate: &'me mut D,\n-\n-    /// After we generalize this type, we are going to relate it to\n-    /// some other type. What will be the variance at this point?\n-    ambient_variance: ty::Variance,\n-\n-    /// The vid of the type variable that is in the process of being\n-    /// instantiated. If we find this within the value we are folding,\n-    /// that means we would have created a cyclic value.\n-    for_vid_sub_root: ty::TyVid,\n-\n-    /// The universe of the type variable that is in the process of being\n-    /// instantiated. If we find anything that this universe cannot name,\n-    /// we reject the relation.\n-    universe: ty::UniverseIndex,\n-}\n-\n-impl<'tcx, D> TypeRelation<'tcx> for TypeGeneralizer<'_, 'tcx, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        self.delegate.param_env()\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"nll::generalizer\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        variance: ty::Variance,\n-        _info: ty::VarianceDiagInfo<'tcx>,\n-        a: T,\n-        b: T,\n-    ) -> RelateResult<'tcx, T> {\n-        debug!(\n-            \"TypeGeneralizer::relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n-            variance, a, b\n-        );\n-\n-        let old_ambient_variance = self.ambient_variance;\n-        self.ambient_variance = self.ambient_variance.xform(variance);\n-\n-        debug!(\n-            \"TypeGeneralizer::relate_with_variance: ambient_variance = {:?}\",\n-            self.ambient_variance\n-        );\n-\n-        let r = self.relate(a, b)?;\n-\n-        self.ambient_variance = old_ambient_variance;\n-\n-        debug!(\"TypeGeneralizer::relate_with_variance: r={:?}\", r);\n-\n-        Ok(r)\n-    }\n-\n-    fn tys(&mut self, a: Ty<'tcx>, _: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        use crate::infer::type_variable::TypeVariableValue;\n-\n-        debug!(\"TypeGeneralizer::tys(a={:?})\", a);\n-\n-        match *a.kind() {\n-            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_))\n-                if D::forbid_inference_vars() =>\n-            {\n-                bug!(\"unexpected inference variable encountered in NLL generalization: {:?}\", a);\n-            }\n-\n-            ty::Infer(ty::TyVar(vid)) => {\n-                let mut inner = self.infcx.inner.borrow_mut();\n-                let variables = &mut inner.type_variables();\n-                let vid = variables.root_var(vid);\n-                let sub_vid = variables.sub_root_var(vid);\n-                if sub_vid == self.for_vid_sub_root {\n-                    // If sub-roots are equal, then `for_vid` and\n-                    // `vid` are related via subtyping.\n-                    debug!(\"TypeGeneralizer::tys: occurs check failed\");\n-                    Err(TypeError::Mismatch)\n-                } else {\n-                    match variables.probe(vid) {\n-                        TypeVariableValue::Known { value: u } => {\n-                            drop(inner);\n-                            self.relate(u, u)\n-                        }\n-                        TypeVariableValue::Unknown { universe: _universe } => {\n-                            if self.ambient_variance == ty::Bivariant {\n-                                // FIXME: we may need a WF predicate (related to #54105).\n-                            }\n-\n-                            let origin = *variables.var_origin(vid);\n-\n-                            // Replacing with a new variable in the universe `self.universe`,\n-                            // it will be unified later with the original type variable in\n-                            // the universe `_universe`.\n-                            let new_var_id = variables.new_var(self.universe, origin);\n-\n-                            let u = self.tcx().mk_ty_var(new_var_id);\n-                            debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n-                            Ok(u)\n-                        }\n-                    }\n-                }\n-            }\n-\n-            ty::Infer(ty::IntVar(_) | ty::FloatVar(_)) => {\n-                // No matter what mode we are in,\n-                // integer/floating-point types must be equal to be\n-                // relatable.\n-                Ok(a)\n-            }\n-\n-            ty::Placeholder(placeholder) => {\n-                if self.universe.cannot_name(placeholder.universe) {\n-                    debug!(\n-                        \"TypeGeneralizer::tys: root universe {:?} cannot name\\\n-                         placeholder in universe {:?}\",\n-                        self.universe, placeholder.universe\n-                    );\n-                    Err(TypeError::Mismatch)\n-                } else {\n-                    Ok(a)\n-                }\n-            }\n-\n-            _ => relate::super_relate_tys(self, a, a),\n-        }\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        a: ty::Region<'tcx>,\n-        _: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\"TypeGeneralizer::regions(a={:?})\", a);\n-\n-        if let ty::ReLateBound(..) = *a {\n-            return Ok(a);\n-        }\n-\n-        // For now, we just always create a fresh region variable to\n-        // replace all the regions in the source type. In the main\n-        // type checker, we special case the case where the ambient\n-        // variance is `Invariant` and try to avoid creating a fresh\n-        // region variable, but since this comes up so much less in\n-        // NLL (only when users use `_` etc) it is much less\n-        // important.\n-        //\n-        // As an aside, since these new variables are created in\n-        // `self.universe` universe, this also serves to enforce the\n-        // universe scoping rules.\n-        //\n-        // FIXME(#54105) -- if the ambient variance is bivariant,\n-        // though, we may however need to check well-formedness or\n-        // risk a problem like #41677 again.\n-        let replacement_region_vid = self.delegate.generalize_existential(self.universe);\n-\n-        Ok(replacement_region_vid)\n-    }\n-\n-    fn consts(\n-        &mut self,\n-        a: ty::Const<'tcx>,\n-        _: ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n-        match a.kind() {\n-            ty::ConstKind::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n-                bug!(\"unexpected inference variable encountered in NLL generalization: {:?}\", a);\n-            }\n-            ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                let mut inner = self.infcx.inner.borrow_mut();\n-                let variable_table = &mut inner.const_unification_table();\n-                let var_value = variable_table.probe_value(vid);\n-                match var_value.val.known() {\n-                    Some(u) => self.relate(u, u),\n-                    None => {\n-                        let new_var_id = variable_table.new_key(ConstVarValue {\n-                            origin: var_value.origin,\n-                            val: ConstVariableValue::Unknown { universe: self.universe },\n-                        });\n-                        Ok(self.tcx().mk_const(new_var_id, a.ty()))\n-                    }\n-                }\n-            }\n-            ty::ConstKind::Unevaluated(..) if self.tcx().lazy_normalization() => Ok(a),\n-            _ => relate::super_relate_consts(self, a, a),\n-        }\n-    }\n-\n-    fn binders<T>(\n-        &mut self,\n-        a: ty::Binder<'tcx, T>,\n-        _: ty::Binder<'tcx, T>,\n-    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n-    where\n-        T: Relate<'tcx>,\n-    {\n-        debug!(\"TypeGeneralizer::binders(a={:?})\", a);\n-        let result = self.relate(a.skip_binder(), a.skip_binder())?;\n-        Ok(a.rebind(result))\n-    }\n-}"}, {"sha": "cd2462d3c31232b9c09b35b67be415a0870e7562", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=ea54255501221b26bf2242c09cbd0924dc8ee1ea", "patch": "@@ -187,7 +187,7 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         } else if pattern == value {\n             Ok(pattern)\n         } else {\n-            relate::super_relate_tys(self, pattern, value)\n+            relate::structurally_relate_tys(self, pattern, value)\n         }\n     }\n \n@@ -201,7 +201,7 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         if pattern == value {\n             Ok(pattern)\n         } else {\n-            relate::super_relate_consts(self, pattern, value)\n+            relate::structurally_relate_consts(self, pattern, value)\n         }\n     }\n "}, {"sha": "e0f29a8de8fc823fef77096c8f46b4bd2403572a", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=ea54255501221b26bf2242c09cbd0924dc8ee1ea", "patch": "@@ -1,4 +1,4 @@\n-use super::combine::{CombineFields, RelationDir};\n+use super::combine::CombineFields;\n use super::{DefineOpaqueTypes, ObligationEmittingRelation, SubregionOrigin};\n \n use crate::traits::{Obligation, PredicateObligations};\n@@ -108,11 +108,11 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n                 Ok(a)\n             }\n             (&ty::Infer(TyVar(a_id)), _) => {\n-                self.fields.instantiate(b, RelationDir::SupertypeOf, a_id, !self.a_is_expected)?;\n+                self.fields.instantiate(b, ty::Contravariant, a_id, !self.a_is_expected)?;\n                 Ok(a)\n             }\n             (_, &ty::Infer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, RelationDir::SubtypeOf, b_id, self.a_is_expected)?;\n+                self.fields.instantiate(a, ty::Covariant, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n "}, {"sha": "cbc68fde9d905aac64e90396bd25ddeef9b6c1c2", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=ea54255501221b26bf2242c09cbd0924dc8ee1ea", "patch": "@@ -83,7 +83,7 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n \n             (&ty::Error(guar), _) | (_, &ty::Error(guar)) => Ok(self.tcx().ty_error(guar)),\n \n-            _ => relate::super_relate_tys(self, a, b),\n+            _ => relate::structurally_relate_tys(self, a, b),\n         }\n     }\n \n@@ -109,7 +109,7 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n             _ => {}\n         }\n \n-        relate::super_relate_consts(self, a, b)\n+        relate::structurally_relate_consts(self, a, b)\n     }\n \n     fn binders<T>("}, {"sha": "df324bcc52c4b4cdff6d86e60446a1a87942fac1", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=ea54255501221b26bf2242c09cbd0924dc8ee1ea", "patch": "@@ -1072,6 +1072,24 @@ impl ParamTerm {\n     }\n }\n \n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+pub enum TermVid<'tcx> {\n+    Ty(ty::TyVid),\n+    Const(ty::ConstVid<'tcx>),\n+}\n+\n+impl From<ty::TyVid> for TermVid<'_> {\n+    fn from(value: ty::TyVid) -> Self {\n+        TermVid::Ty(value)\n+    }\n+}\n+\n+impl<'tcx> From<ty::ConstVid<'tcx>> for TermVid<'tcx> {\n+    fn from(value: ty::ConstVid<'tcx>) -> Self {\n+        TermVid::Const(value)\n+    }\n+}\n+\n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n ///"}, {"sha": "3bbe6a23b66281ff924ed45101c60b1c9dd350ca", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea54255501221b26bf2242c09cbd0924dc8ee1ea/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=ea54255501221b26bf2242c09cbd0924dc8ee1ea", "patch": "@@ -388,24 +388,24 @@ impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n     }\n }\n \n-/// The main \"type relation\" routine. Note that this does not handle\n-/// inference artifacts, so you should filter those out before calling\n-/// it.\n-pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n+/// Relates `a` and `b` structurally, calling the relation for all nested values.\n+/// Any semantic equality, e.g. of projections, and inference variables have to be\n+/// handled by the caller.\n+pub fn structurally_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n     relation: &mut R,\n     a: Ty<'tcx>,\n     b: Ty<'tcx>,\n ) -> RelateResult<'tcx, Ty<'tcx>> {\n     let tcx = relation.tcx();\n-    debug!(\"super_relate_tys: a={:?} b={:?}\", a, b);\n+    debug!(\"structurally_relate_tys: a={:?} b={:?}\", a, b);\n     match (a.kind(), b.kind()) {\n         (&ty::Infer(_), _) | (_, &ty::Infer(_)) => {\n             // The caller should handle these cases!\n-            bug!(\"var types encountered in super_relate_tys\")\n+            bug!(\"var types encountered in structurally_relate_tys\")\n         }\n \n         (ty::Bound(..), _) | (_, ty::Bound(..)) => {\n-            bug!(\"bound types encountered in super_relate_tys\")\n+            bug!(\"bound types encountered in structurally_relate_tys\")\n         }\n \n         (&ty::Error(guar), _) | (_, &ty::Error(guar)) => Ok(tcx.ty_error(guar)),\n@@ -575,15 +575,18 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n     }\n }\n \n-/// The main \"const relation\" routine. Note that this does not handle\n-/// inference artifacts, so you should filter those out before calling\n-/// it.\n-pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n+/// Relates `a` and `b` structurally, calling the relation for all nested values.\n+/// Any semantic equality, e.g. of unevaluated consts, and inference variables have\n+/// to be handled by the caller.\n+///\n+/// FIXME: This is not totally structual, which probably should be fixed.\n+/// See the HACKs below.\n+pub fn structurally_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     relation: &mut R,\n     mut a: ty::Const<'tcx>,\n     mut b: ty::Const<'tcx>,\n ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n-    debug!(\"{}.super_relate_consts(a = {:?}, b = {:?})\", relation.tag(), a, b);\n+    debug!(\"{}.structurally_relate_consts(a = {:?}, b = {:?})\", relation.tag(), a, b);\n     let tcx = relation.tcx();\n \n     // HACK(const_generics): We still need to eagerly evaluate consts when\n@@ -602,15 +605,15 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n         b = tcx.expand_abstract_consts(b);\n     }\n \n-    debug!(\"{}.super_relate_consts(normed_a = {:?}, normed_b = {:?})\", relation.tag(), a, b);\n+    debug!(\"{}.structurally_relate_consts(normed_a = {:?}, normed_b = {:?})\", relation.tag(), a, b);\n \n     // Currently, the values that can be unified are primitive types,\n     // and those that derive both `PartialEq` and `Eq`, corresponding\n     // to structural-match types.\n     let is_match = match (a.kind(), b.kind()) {\n         (ty::ConstKind::Infer(_), _) | (_, ty::ConstKind::Infer(_)) => {\n             // The caller should handle these cases!\n-            bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n+            bug!(\"var types encountered in structurally_relate_consts: {:?} {:?}\", a, b)\n         }\n \n         (ty::ConstKind::Error(_), _) => return Ok(a),"}, {"sha": "eadee6b711e52be7a844d82b9ce721153d2b3f81", "filename": "tests/ui/traits/non_lifetime_binders/universe-error1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ea54255501221b26bf2242c09cbd0924dc8ee1ea/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Funiverse-error1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea54255501221b26bf2242c09cbd0924dc8ee1ea/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Funiverse-error1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Funiverse-error1.rs?ref=ea54255501221b26bf2242c09cbd0924dc8ee1ea", "patch": "@@ -0,0 +1,18 @@\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+trait Other<U: ?Sized> {}\n+\n+impl<U: ?Sized> Other<U> for U {}\n+\n+#[rustfmt::skip]\n+fn foo<U: ?Sized>()\n+where\n+    for<T> T: Other<U> {}\n+\n+fn bar() {\n+    foo::<_>();\n+    //~^ ERROR the trait bound `T: Other<_>` is not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "bfcad72e35278535296cbdd00ee97cf7e1096e1e", "filename": "tests/ui/traits/non_lifetime_binders/universe-error1.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ea54255501221b26bf2242c09cbd0924dc8ee1ea/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Funiverse-error1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea54255501221b26bf2242c09cbd0924dc8ee1ea/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Funiverse-error1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Funiverse-error1.stderr?ref=ea54255501221b26bf2242c09cbd0924dc8ee1ea", "patch": "@@ -0,0 +1,27 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/universe-error1.rs:1:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #108185 <https://github.com/rust-lang/rust/issues/108185> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0277]: the trait bound `T: Other<_>` is not satisfied\n+  --> $DIR/universe-error1.rs:14:11\n+   |\n+LL |     foo::<_>();\n+   |           ^ the trait `Other<_>` is not implemented for `T`\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/universe-error1.rs:11:15\n+   |\n+LL | fn foo<U: ?Sized>()\n+   |    --- required by a bound in this function\n+LL | where\n+LL |     for<T> T: Other<U> {}\n+   |               ^^^^^^^^ required by this bound in `foo`\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}]}