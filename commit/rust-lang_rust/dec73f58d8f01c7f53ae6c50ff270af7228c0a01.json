{"sha": "dec73f58d8f01c7f53ae6c50ff270af7228c0a01", "node_id": "C_kwDOAAsO6NoAKGRlYzczZjU4ZDhmMDFjN2Y1M2FlNmM1MGZmMjcwYWY3MjI4YzBhMDE", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-04-03T19:50:11Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-04-09T03:28:31Z"}, "message": "Remove ptr-int transmute in std::sync::mpsc\n\nSince https://github.com/rust-lang/rust/pull/95340 landed, Miri with\n-Zmiri-check-number-validity produces an error on the test suites of\nsome crates which implement concurrency tools, because it seems like\nsuch crates tend to use std::sync::mpsc in their tests. This fixes the\nproblem by storing pointer bytes in a pointer.", "tree": {"sha": "023bc8372bbffc9de5b003538ce1373bb86e082f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/023bc8372bbffc9de5b003538ce1373bb86e082f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dec73f58d8f01c7f53ae6c50ff270af7228c0a01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dec73f58d8f01c7f53ae6c50ff270af7228c0a01", "html_url": "https://github.com/rust-lang/rust/commit/dec73f58d8f01c7f53ae6c50ff270af7228c0a01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dec73f58d8f01c7f53ae6c50ff270af7228c0a01/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "340f6491bed3525acfabbdbd1545b6aee2fca62b", "url": "https://api.github.com/repos/rust-lang/rust/commits/340f6491bed3525acfabbdbd1545b6aee2fca62b", "html_url": "https://github.com/rust-lang/rust/commit/340f6491bed3525acfabbdbd1545b6aee2fca62b"}], "stats": {"total": 99, "additions": 50, "deletions": 49}, "files": [{"sha": "021df7b096cbc0670155fa63fcc65d8798544147", "filename": "library/std/src/sync/mpsc/blocking.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dec73f58d8f01c7f53ae6c50ff270af7228c0a01/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dec73f58d8f01c7f53ae6c50ff270af7228c0a01/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fblocking.rs?ref=dec73f58d8f01c7f53ae6c50ff270af7228c0a01", "patch": "@@ -1,6 +1,5 @@\n //! Generic support for building blocking abstractions.\n \n-use crate::mem;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sync::Arc;\n use crate::thread::{self, Thread};\n@@ -47,18 +46,18 @@ impl SignalToken {\n         wake\n     }\n \n-    /// Converts to an unsafe usize value. Useful for storing in a pipe's state\n+    /// Converts to an unsafe raw pointer. Useful for storing in a pipe's state\n     /// flag.\n     #[inline]\n-    pub unsafe fn cast_to_usize(self) -> usize {\n-        mem::transmute(self.inner)\n+    pub unsafe fn to_raw(self) -> *mut u8 {\n+        Arc::into_raw(self.inner) as *mut u8\n     }\n \n-    /// Converts from an unsafe usize value. Useful for retrieving a pipe's state\n+    /// Converts from an unsafe raw pointer. Useful for retrieving a pipe's state\n     /// flag.\n     #[inline]\n-    pub unsafe fn cast_from_usize(signal_ptr: usize) -> SignalToken {\n-        SignalToken { inner: mem::transmute(signal_ptr) }\n+    pub unsafe fn from_raw(signal_ptr: *mut u8) -> SignalToken {\n+        SignalToken { inner: Arc::from_raw(signal_ptr as *mut Inner) }\n     }\n }\n "}, {"sha": "0e259b8aecb9a35744ae9225ab33a41d4c7ac83d", "filename": "library/std/src/sync/mpsc/oneshot.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dec73f58d8f01c7f53ae6c50ff270af7228c0a01/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dec73f58d8f01c7f53ae6c50ff270af7228c0a01/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Foneshot.rs?ref=dec73f58d8f01c7f53ae6c50ff270af7228c0a01", "patch": "@@ -27,15 +27,15 @@ pub use self::UpgradeResult::*;\n \n use crate::cell::UnsafeCell;\n use crate::ptr;\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::sync::atomic::{AtomicPtr, Ordering};\n use crate::sync::mpsc::blocking::{self, SignalToken};\n use crate::sync::mpsc::Receiver;\n use crate::time::Instant;\n \n // Various states you can find a port in.\n-const EMPTY: usize = 0; // initial state: no data, no blocked receiver\n-const DATA: usize = 1; // data ready for receiver to take\n-const DISCONNECTED: usize = 2; // channel is disconnected OR upgraded\n+const EMPTY: *mut u8 = ptr::invalid_mut::<u8>(0); // initial state: no data, no blocked receiver\n+const DATA: *mut u8 = ptr::invalid_mut::<u8>(1); // data ready for receiver to take\n+const DISCONNECTED: *mut u8 = ptr::invalid_mut::<u8>(2); // channel is disconnected OR upgraded\n // Any other value represents a pointer to a SignalToken value. The\n // protocol ensures that when the state moves *to* a pointer,\n // ownership of the token is given to the packet, and when the state\n@@ -44,7 +44,7 @@ const DISCONNECTED: usize = 2; // channel is disconnected OR upgraded\n \n pub struct Packet<T> {\n     // Internal state of the chan/port pair (stores the blocked thread as well)\n-    state: AtomicUsize,\n+    state: AtomicPtr<u8>,\n     // One-shot data slot location\n     data: UnsafeCell<Option<T>>,\n     // when used for the second time, a oneshot channel must be upgraded, and\n@@ -75,7 +75,7 @@ impl<T> Packet<T> {\n         Packet {\n             data: UnsafeCell::new(None),\n             upgrade: UnsafeCell::new(NothingSent),\n-            state: AtomicUsize::new(EMPTY),\n+            state: AtomicPtr::new(EMPTY),\n         }\n     }\n \n@@ -108,7 +108,7 @@ impl<T> Packet<T> {\n                 // There is a thread waiting on the other end. We leave the 'DATA'\n                 // state inside so it'll pick it up on the other end.\n                 ptr => {\n-                    SignalToken::cast_from_usize(ptr).signal();\n+                    SignalToken::from_raw(ptr).signal();\n                     Ok(())\n                 }\n             }\n@@ -126,7 +126,7 @@ impl<T> Packet<T> {\n         // like we're not empty, then immediately go through to `try_recv`.\n         if self.state.load(Ordering::SeqCst) == EMPTY {\n             let (wait_token, signal_token) = blocking::tokens();\n-            let ptr = unsafe { signal_token.cast_to_usize() };\n+            let ptr = unsafe { signal_token.to_raw() };\n \n             // race with senders to enter the blocking state\n             if self.state.compare_exchange(EMPTY, ptr, Ordering::SeqCst, Ordering::SeqCst).is_ok() {\n@@ -142,7 +142,7 @@ impl<T> Packet<T> {\n                 }\n             } else {\n                 // drop the signal token, since we never blocked\n-                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n+                drop(unsafe { SignalToken::from_raw(ptr) });\n             }\n         }\n \n@@ -218,7 +218,7 @@ impl<T> Packet<T> {\n                 }\n \n                 // If someone's waiting, we gotta wake them up\n-                ptr => UpWoke(SignalToken::cast_from_usize(ptr)),\n+                ptr => UpWoke(SignalToken::from_raw(ptr)),\n             }\n         }\n     }\n@@ -229,7 +229,7 @@ impl<T> Packet<T> {\n \n             // If someone's waiting, we gotta wake them up\n             ptr => unsafe {\n-                SignalToken::cast_from_usize(ptr).signal();\n+                SignalToken::from_raw(ptr).signal();\n             },\n         }\n     }\n@@ -301,7 +301,7 @@ impl<T> Packet<T> {\n \n             // We woke ourselves up from select.\n             ptr => unsafe {\n-                drop(SignalToken::cast_from_usize(ptr));\n+                drop(SignalToken::from_raw(ptr));\n                 Ok(false)\n             },\n         }"}, {"sha": "51917bd96bd60a46bd7f1b96df4a0e0bbc0d9a34", "filename": "library/std/src/sync/mpsc/shared.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/dec73f58d8f01c7f53ae6c50ff270af7228c0a01/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dec73f58d8f01c7f53ae6c50ff270af7228c0a01/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs?ref=dec73f58d8f01c7f53ae6c50ff270af7228c0a01", "patch": "@@ -15,7 +15,7 @@ use core::intrinsics::abort;\n \n use crate::cell::UnsafeCell;\n use crate::ptr;\n-use crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicUsize, Ordering};\n+use crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicPtr, AtomicUsize, Ordering};\n use crate::sync::mpsc::blocking::{self, SignalToken};\n use crate::sync::mpsc::mpsc_queue as mpsc;\n use crate::sync::{Mutex, MutexGuard};\n@@ -29,12 +29,13 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n const MAX_STEALS: isize = 5;\n #[cfg(not(test))]\n const MAX_STEALS: isize = 1 << 20;\n+const EMPTY: *mut u8 = ptr::null_mut(); // initial state: no data, no blocked receiver\n \n pub struct Packet<T> {\n     queue: mpsc::Queue<T>,\n     cnt: AtomicIsize,          // How many items are on this channel\n     steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n-    to_wake: AtomicUsize,      // SignalToken for wake up\n+    to_wake: AtomicPtr<u8>,    // SignalToken for wake up\n \n     // The number of channels which are currently using this packet.\n     channels: AtomicUsize,\n@@ -68,7 +69,7 @@ impl<T> Packet<T> {\n             queue: mpsc::Queue::new(),\n             cnt: AtomicIsize::new(0),\n             steals: UnsafeCell::new(0),\n-            to_wake: AtomicUsize::new(0),\n+            to_wake: AtomicPtr::new(EMPTY),\n             channels: AtomicUsize::new(2),\n             port_dropped: AtomicBool::new(false),\n             sender_drain: AtomicIsize::new(0),\n@@ -93,8 +94,8 @@ impl<T> Packet<T> {\n     pub fn inherit_blocker(&self, token: Option<SignalToken>, guard: MutexGuard<'_, ()>) {\n         if let Some(token) = token {\n             assert_eq!(self.cnt.load(Ordering::SeqCst), 0);\n-            assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n-            self.to_wake.store(unsafe { token.cast_to_usize() }, Ordering::SeqCst);\n+            assert_eq!(self.to_wake.load(Ordering::SeqCst), EMPTY);\n+            self.to_wake.store(unsafe { token.to_raw() }, Ordering::SeqCst);\n             self.cnt.store(-1, Ordering::SeqCst);\n \n             // This store is a little sketchy. What's happening here is that\n@@ -250,10 +251,10 @@ impl<T> Packet<T> {\n         unsafe {\n             assert_eq!(\n                 self.to_wake.load(Ordering::SeqCst),\n-                0,\n+                EMPTY,\n                 \"This is a known bug in the Rust standard library. See https://github.com/rust-lang/rust/issues/39364\"\n             );\n-            let ptr = token.cast_to_usize();\n+            let ptr = token.to_raw();\n             self.to_wake.store(ptr, Ordering::SeqCst);\n \n             let steals = ptr::replace(self.steals.get(), 0);\n@@ -272,8 +273,8 @@ impl<T> Packet<T> {\n                 }\n             }\n \n-            self.to_wake.store(0, Ordering::SeqCst);\n-            drop(SignalToken::cast_from_usize(ptr));\n+            self.to_wake.store(EMPTY, Ordering::SeqCst);\n+            drop(SignalToken::from_raw(ptr));\n             Abort\n         }\n     }\n@@ -415,9 +416,9 @@ impl<T> Packet<T> {\n     // Consumes ownership of the 'to_wake' field.\n     fn take_to_wake(&self) -> SignalToken {\n         let ptr = self.to_wake.load(Ordering::SeqCst);\n-        self.to_wake.store(0, Ordering::SeqCst);\n-        assert!(ptr != 0);\n-        unsafe { SignalToken::cast_from_usize(ptr) }\n+        self.to_wake.store(EMPTY, Ordering::SeqCst);\n+        assert!(ptr != EMPTY);\n+        unsafe { SignalToken::from_raw(ptr) }\n     }\n \n     ////////////////////////////////////////////////////////////////////////////\n@@ -462,15 +463,15 @@ impl<T> Packet<T> {\n         let prev = self.bump(steals + 1);\n \n         if prev == DISCONNECTED {\n-            assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n+            assert_eq!(self.to_wake.load(Ordering::SeqCst), EMPTY);\n             true\n         } else {\n             let cur = prev + steals + 1;\n             assert!(cur >= 0);\n             if prev < 0 {\n                 drop(self.take_to_wake());\n             } else {\n-                while self.to_wake.load(Ordering::SeqCst) != 0 {\n+                while self.to_wake.load(Ordering::SeqCst) != EMPTY {\n                     thread::yield_now();\n                 }\n             }\n@@ -494,7 +495,7 @@ impl<T> Drop for Packet<T> {\n         // `to_wake`, so this assert cannot be removed with also removing\n         // the `to_wake` assert.\n         assert_eq!(self.cnt.load(Ordering::SeqCst), DISCONNECTED);\n-        assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n+        assert_eq!(self.to_wake.load(Ordering::SeqCst), EMPTY);\n         assert_eq!(self.channels.load(Ordering::SeqCst), 0);\n     }\n }"}, {"sha": "4c3812c79f619f4dcb3a103136042f4fb6d23852", "filename": "library/std/src/sync/mpsc/stream.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/dec73f58d8f01c7f53ae6c50ff270af7228c0a01/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dec73f58d8f01c7f53ae6c50ff270af7228c0a01/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs?ref=dec73f58d8f01c7f53ae6c50ff270af7228c0a01", "patch": "@@ -17,7 +17,7 @@ use crate::ptr;\n use crate::thread;\n use crate::time::Instant;\n \n-use crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicUsize, Ordering};\n+use crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicPtr, Ordering};\n use crate::sync::mpsc::blocking::{self, SignalToken};\n use crate::sync::mpsc::spsc_queue as spsc;\n use crate::sync::mpsc::Receiver;\n@@ -27,15 +27,16 @@ const DISCONNECTED: isize = isize::MIN;\n const MAX_STEALS: isize = 5;\n #[cfg(not(test))]\n const MAX_STEALS: isize = 1 << 20;\n+const EMPTY: *mut u8 = ptr::null_mut(); // initial state: no data, no blocked receiver\n \n pub struct Packet<T> {\n     // internal queue for all messages\n     queue: spsc::Queue<Message<T>, ProducerAddition, ConsumerAddition>,\n }\n \n struct ProducerAddition {\n-    cnt: AtomicIsize,     // How many items are on this channel\n-    to_wake: AtomicUsize, // SignalToken for the blocked thread to wake up\n+    cnt: AtomicIsize,       // How many items are on this channel\n+    to_wake: AtomicPtr<u8>, // SignalToken for the blocked thread to wake up\n \n     port_dropped: AtomicBool, // flag if the channel has been destroyed.\n }\n@@ -71,7 +72,7 @@ impl<T> Packet<T> {\n                     128,\n                     ProducerAddition {\n                         cnt: AtomicIsize::new(0),\n-                        to_wake: AtomicUsize::new(0),\n+                        to_wake: AtomicPtr::new(EMPTY),\n \n                         port_dropped: AtomicBool::new(false),\n                     },\n@@ -147,17 +148,17 @@ impl<T> Packet<T> {\n     // Consumes ownership of the 'to_wake' field.\n     fn take_to_wake(&self) -> SignalToken {\n         let ptr = self.queue.producer_addition().to_wake.load(Ordering::SeqCst);\n-        self.queue.producer_addition().to_wake.store(0, Ordering::SeqCst);\n-        assert!(ptr != 0);\n-        unsafe { SignalToken::cast_from_usize(ptr) }\n+        self.queue.producer_addition().to_wake.store(EMPTY, Ordering::SeqCst);\n+        assert!(ptr != EMPTY);\n+        unsafe { SignalToken::from_raw(ptr) }\n     }\n \n     // Decrements the count on the channel for a sleeper, returning the sleeper\n     // back if it shouldn't sleep. Note that this is the location where we take\n     // steals into account.\n     fn decrement(&self, token: SignalToken) -> Result<(), SignalToken> {\n-        assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), 0);\n-        let ptr = unsafe { token.cast_to_usize() };\n+        assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), EMPTY);\n+        let ptr = unsafe { token.to_raw() };\n         self.queue.producer_addition().to_wake.store(ptr, Ordering::SeqCst);\n \n         let steals = unsafe { ptr::replace(self.queue.consumer_addition().steals.get(), 0) };\n@@ -176,8 +177,8 @@ impl<T> Packet<T> {\n             }\n         }\n \n-        self.queue.producer_addition().to_wake.store(0, Ordering::SeqCst);\n-        Err(unsafe { SignalToken::cast_from_usize(ptr) })\n+        self.queue.producer_addition().to_wake.store(EMPTY, Ordering::SeqCst);\n+        Err(unsafe { SignalToken::from_raw(ptr) })\n     }\n \n     pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n@@ -376,7 +377,7 @@ impl<T> Packet<T> {\n         // of time until the data is actually sent.\n         if was_upgrade {\n             assert_eq!(unsafe { *self.queue.consumer_addition().steals.get() }, 0);\n-            assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), 0);\n+            assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), EMPTY);\n             return Ok(true);\n         }\n \n@@ -389,7 +390,7 @@ impl<T> Packet<T> {\n         // If we were previously disconnected, then we know for sure that there\n         // is no thread in to_wake, so just keep going\n         let has_data = if prev == DISCONNECTED {\n-            assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), 0);\n+            assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), EMPTY);\n             true // there is data, that data is that we're disconnected\n         } else {\n             let cur = prev + steals + 1;\n@@ -412,7 +413,7 @@ impl<T> Packet<T> {\n             if prev < 0 {\n                 drop(self.take_to_wake());\n             } else {\n-                while self.queue.producer_addition().to_wake.load(Ordering::SeqCst) != 0 {\n+                while self.queue.producer_addition().to_wake.load(Ordering::SeqCst) != EMPTY {\n                     thread::yield_now();\n                 }\n             }\n@@ -451,6 +452,6 @@ impl<T> Drop for Packet<T> {\n         // `to_wake`, so this assert cannot be removed with also removing\n         // the `to_wake` assert.\n         assert_eq!(self.queue.producer_addition().cnt.load(Ordering::SeqCst), DISCONNECTED);\n-        assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), 0);\n+        assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), EMPTY);\n     }\n }"}]}