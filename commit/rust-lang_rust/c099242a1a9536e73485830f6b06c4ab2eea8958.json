{"sha": "c099242a1a9536e73485830f6b06c4ab2eea8958", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwOTkyNDJhMWE5NTM2ZTczNDg1ODMwZjZiMDZjNGFiMmVlYTg5NTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-20T06:41:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-20T06:41:55Z"}, "message": "auto merge of #8548 : catamorphism/rust/unignore-rustpkg-tests, r=catamorphism\n\nr? @brson This necessitated some cleanup to how we parse library filenames\r\nwhen searching for libraries, since rustpkg may now create filenames\r\nthat contain '-' characters. Also cleaned up how rustpkg passes the\r\nsysroot to a custom build script.", "tree": {"sha": "5a7f088f06d1c040a711232d3e2574ec605d7127", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a7f088f06d1c040a711232d3e2574ec605d7127"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c099242a1a9536e73485830f6b06c4ab2eea8958", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c099242a1a9536e73485830f6b06c4ab2eea8958", "html_url": "https://github.com/rust-lang/rust/commit/c099242a1a9536e73485830f6b06c4ab2eea8958", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c099242a1a9536e73485830f6b06c4ab2eea8958/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5034792c88a33e4bc7597d9103faf1eaaec7f0ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/5034792c88a33e4bc7597d9103faf1eaaec7f0ee", "html_url": "https://github.com/rust-lang/rust/commit/5034792c88a33e4bc7597d9103faf1eaaec7f0ee"}, {"sha": "d9293d1d87a6afa1999ad6aa7b6af5e09c4a4729", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9293d1d87a6afa1999ad6aa7b6af5e09c4a4729", "html_url": "https://github.com/rust-lang/rust/commit/d9293d1d87a6afa1999ad6aa7b6af5e09c4a4729"}], "stats": {"total": 179, "additions": 86, "deletions": 93}, "files": [{"sha": "93e0789dcb0c9548d52822e0f8b4e7b07d2cd39d", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=c099242a1a9536e73485830f6b06c4ab2eea8958", "patch": "@@ -33,6 +33,17 @@ impl Ctx {\n             Some(p) => p.to_str()\n         }\n     }\n+\n+    // Hack so that rustpkg can run either out of a rustc target dir,\n+    // or the host dir\n+    pub fn sysroot_to_use(&self) -> Option<@Path> {\n+        if !in_target(self.sysroot_opt) {\n+            self.sysroot_opt\n+        }\n+        else {\n+            self.sysroot_opt.map(|p| { @p.pop().pop().pop() })\n+        }\n+    }\n }\n \n /// We assume that if ../../rustc exists, then we're running"}, {"sha": "42f33592aaaead2a5b7cb1f2174943969d398d4f", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=c099242a1a9536e73485830f6b06c4ab2eea8958", "patch": "@@ -54,7 +54,7 @@ impl PkgSrc {\n         debug!(\"Pushing onto root: %s | %s\", self.id.path.to_str(), self.root.to_str());\n \n         let dirs = pkgid_src_in_workspace(&self.id, &self.root);\n-        debug!(\"Checking dirs: %?\", dirs);\n+        debug!(\"Checking dirs: %?\", dirs.map(|s| s.to_str()).connect(\":\"));\n         let path = dirs.iter().find(|&d| os::path_exists(d));\n \n         let dir = match path {"}, {"sha": "2dbd054ef60bcbae27d49a3dedc30eca2b3201c3", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=c099242a1a9536e73485830f6b06c4ab2eea8958", "patch": "@@ -12,7 +12,7 @@\n \n pub use package_id::PkgId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n-pub use version::{Version, NoVersion, split_version_general};\n+pub use version::{Version, NoVersion, split_version_general, try_parsing_version};\n pub use rustc::metadata::filesearch::rust_path;\n \n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n@@ -153,21 +153,19 @@ fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Opt\n /// Figure out what the library name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n-    library_in_workspace(&pkgid.path, pkgid.short_name, Build, workspace, \"build\")\n+    library_in_workspace(&pkgid.path, pkgid.short_name, Build, workspace, \"build\", &pkgid.version)\n }\n \n /// Does the actual searching stuff\n pub fn installed_library_in_workspace(short_name: &str, workspace: &Path) -> Option<Path> {\n-    library_in_workspace(&Path(short_name), short_name, Install, workspace, \"lib\")\n+    // NOTE: this could break once we're handling multiple versions better... want a test for it\n+    library_in_workspace(&Path(short_name), short_name, Install, workspace, \"lib\", &NoVersion)\n }\n \n-\n-/// This doesn't take a PkgId, so we can use it for `extern mod` inference, where we\n-/// don't know the entire package ID.\n /// `workspace` is used to figure out the directory to search.\n /// `short_name` is taken as the link name of the library.\n pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n-                        workspace: &Path, prefix: &str) -> Option<Path> {\n+                        workspace: &Path, prefix: &str, version: &Version) -> Option<Path> {\n     debug!(\"library_in_workspace: checking whether a library named %s exists\",\n            short_name);\n \n@@ -209,36 +207,37 @@ pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n     for p_path in libraries {\n         // Find a filename that matches the pattern: (lib_prefix)-hash-(version)(lib_suffix)\n         // and remember what the hash was\n-        let f_name = match p_path.filename() {\n+        let mut f_name = match p_path.filestem() {\n             Some(s) => s, None => loop\n         };\n-\n-        let mut hash = None;\n-        let mut which = 0;\n-        for piece in f_name.split_iter('-') {\n-            debug!(\"a piece = %s\", piece);\n-            if which == 0 && piece != lib_prefix {\n-                break;\n-            }\n-            else if which == 0 {\n-                which += 1;\n-            }\n-            else if which == 1 {\n-                hash = Some(piece.to_owned());\n-                break;\n-            }\n-            else {\n-                // something went wrong\n-                hash = None;\n-                break;\n-            }\n-        }\n-\n-        if hash.is_some() {\n-            result_filename = Some(p_path);\n-            break;\n-        }\n-    }\n+        // Already checked the filetype above\n+\n+         // This is complicated because library names and versions can both contain dashes\n+         loop {\n+            if f_name.is_empty() { break; }\n+            match f_name.rfind('-') {\n+                Some(i) => {\n+                    debug!(\"Maybe %s is a version\", f_name.slice(i + 1, f_name.len()));\n+                    match try_parsing_version(f_name.slice(i + 1, f_name.len())) {\n+                       Some(ref found_vers) if version == found_vers => {\n+                           match f_name.slice(0, i).rfind('-') {\n+                               Some(j) => {\n+                                   debug!(\"Maybe %s equals %s\", f_name.slice(0, j), lib_prefix);\n+                                   if f_name.slice(0, j) == lib_prefix {\n+                                       result_filename = Some(p_path);\n+                                   }\n+                                   break;\n+                               }\n+                               None => break\n+                           }\n+                       }\n+                       _ => { f_name = f_name.slice(0, i).to_owned(); }\n+                 }\n+               }\n+               None => break\n+         } // match\n+       } // loop\n+    } // for\n \n     if result_filename.is_none() {\n         warn(fmt!(\"library_in_workspace didn't find a library in %s for %s\","}, {"sha": "198cad90166d4e2b4758d57a7b094f4d5c7e5974", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=c099242a1a9536e73485830f6b06c4ab2eea8958", "patch": "@@ -94,15 +94,18 @@ impl<'self> PkgScript<'self> {\n     /// Given the path name for a package script\n     /// and a package ID, parse the package script into\n     /// a PkgScript that we can then execute\n-    fn parse<'a>(script: Path, workspace: &Path, id: &'a PkgId) -> PkgScript<'a> {\n+    fn parse<'a>(sysroot: @Path,\n+                 script: Path,\n+                 workspace: &Path,\n+                 id: &'a PkgId) -> PkgScript<'a> {\n         // Get the executable name that was invoked\n         let binary = os::args()[0].to_managed();\n         // Build the rustc session data structures to pass\n         // to the compiler\n-    debug!(\"pkgscript parse: %?\", os::self_exe_path());\n+        debug!(\"pkgscript parse: %s\", sysroot.to_str());\n         let options = @session::options {\n             binary: binary,\n-            maybe_sysroot: Some(@os::self_exe_path().unwrap().pop()),\n+            maybe_sysroot: Some(sysroot),\n             crate_type: session::bin_crate,\n             .. (*session::basic_options()).clone()\n         };\n@@ -113,7 +116,7 @@ impl<'self> PkgScript<'self> {\n         let crate = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n         let work_dir = build_pkg_id_in_workspace(id, workspace);\n \n-        debug!(\"Returning package script with id %?\", id);\n+        debug!(\"Returning package script with id %s\", id.to_str());\n \n         PkgScript {\n             id: id,\n@@ -138,24 +141,22 @@ impl<'self> PkgScript<'self> {\n         let crate = util::ready_crate(sess, self.crate);\n         debug!(\"Building output filenames with script name %s\",\n                driver::source_name(&self.input));\n-        let root = filesearch::get_or_default_sysroot().pop().pop(); // :-\\\n-        debug!(\"Root is %s, calling compile_rest\", root.to_str());\n         let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n         util::compile_crate_from_input(&self.input,\n                                        &self.build_dir,\n                                        sess,\n                                        crate);\n-        debug!(\"Running program: %s %s %s %s\", exe.to_str(),\n-               sysroot.to_str(), root.to_str(), \"install\");\n+        debug!(\"Running program: %s %s %s\", exe.to_str(),\n+               sysroot.to_str(), \"install\");\n         // FIXME #7401 should support commands besides `install`\n         let status = run::process_status(exe.to_str(), [sysroot.to_str(), ~\"install\"]);\n         if status != 0 {\n             return (~[], status);\n         }\n         else {\n             debug!(\"Running program (configs): %s %s %s\",\n-                   exe.to_str(), root.to_str(), \"configs\");\n-            let output = run::process_output(exe.to_str(), [root.to_str(), ~\"configs\"]);\n+                   exe.to_str(), sysroot.to_str(), \"configs\");\n+            let output = run::process_output(exe.to_str(), [sysroot.to_str(), ~\"configs\"]);\n             // Run the configs() function to get the configs\n             let cfgs = str::from_bytes_slice(output.output).word_iter()\n                 .map(|w| w.to_owned()).collect();\n@@ -350,10 +351,11 @@ impl CtxMethods for Ctx {\n         debug!(\"Package source directory = %?\", pkg_src_dir);\n         let cfgs = match pkg_src_dir.chain_ref(|p| src.package_script_option(p)) {\n             Some(package_script_path) => {\n-                let pscript = PkgScript::parse(package_script_path,\n+                let sysroot = self.sysroot_to_use().expect(\"custom build needs a sysroot\");\n+                let pscript = PkgScript::parse(sysroot,\n+                                               package_script_path,\n                                                workspace,\n                                                pkgid);\n-                let sysroot = self.sysroot_opt.expect(\"custom build needs a sysroot\");\n                 let (cfgs, hook_result) = pscript.run_custom(sysroot);\n                 debug!(\"Command return code = %?\", hook_result);\n                 if hook_result != 0 {"}, {"sha": "1ff45aeb833f841fe31a38611efaef7d8d79774e", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=c099242a1a9536e73485830f6b06c4ab2eea8958", "patch": "@@ -222,7 +222,7 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n     assert!(os::path_is_dir(&*cwd));\n     let cwd = (*cwd).clone();\n     let mut prog = run::Process::new(cmd, args, run::ProcessOptions {\n-        env: env,\n+        env: env.map(|e| e + os::env()),\n         dir: Some(&cwd),\n         in_fd: None,\n         out_fd: None,\n@@ -358,7 +358,8 @@ fn lib_output_file_name(workspace: &Path, parent: &str, short_name: &str) -> Pat\n                          short_name,\n                          Build,\n                          workspace,\n-                         \"build\").expect(\"lib_output_file_name\")\n+                         \"build\",\n+                         &NoVersion).expect(\"lib_output_file_name\")\n }\n \n fn output_file_name(workspace: &Path, short_name: &str) -> Path {\n@@ -405,10 +406,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId) {\n     }\n }\n \n-// FIXME(#7249): these tests fail on multi-platform builds, so for now they're\n-//               only run one x86\n-\n-#[test] #[ignore(cfg(target_arch = \"x86\"))]\n+#[test]\n fn test_make_dir_rwx() {\n     let temp = &os::tmpdir();\n     let dir = temp.push(\"quux\");\n@@ -421,7 +419,7 @@ fn test_make_dir_rwx() {\n     assert!(os::remove_dir_recursive(&dir));\n }\n \n-#[test] #[ignore(cfg(target_arch = \"x86\"))]\n+#[test]\n fn test_install_valid() {\n     use path_util::installed_library_in_workspace;\n \n@@ -451,7 +449,7 @@ fn test_install_valid() {\n     assert!(!os::path_exists(&bench));\n }\n \n-#[test] #[ignore(cfg(target_arch = \"x86\"))]\n+#[test]\n fn test_install_invalid() {\n     use conditions::nonexistent_package::cond;\n     use cond1 = conditions::missing_pkg_files::cond;\n@@ -476,8 +474,6 @@ fn test_install_invalid() {\n \n // Tests above should (maybe) be converted to shell out to rustpkg, too\n \n-// FIXME: #7956: temporarily disabled\n-#[ignore(cfg(target_arch = \"x86\"))]\n fn test_install_git() {\n     let sysroot = test_sysroot();\n     debug!(\"sysroot = %s\", sysroot.to_str());\n@@ -526,7 +522,7 @@ fn test_install_git() {\n     assert!(!os::path_exists(&bench));\n }\n \n-#[test] #[ignore(cfg(target_arch = \"x86\"))]\n+#[test]\n fn test_package_ids_must_be_relative_path_like() {\n     use conditions::bad_pkg_id::cond;\n \n@@ -567,8 +563,6 @@ fn test_package_ids_must_be_relative_path_like() {\n \n }\n \n-// FIXME: #7956: temporarily disabled\n-#[ignore(cfg(target_arch = \"x86\"))]\n fn test_package_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n     let repo = init_git_repo(&Path(local_path));\n@@ -655,7 +649,6 @@ fn rustpkg_install_url_2() {\n                      &temp_dir);\n }\n \n-// FIXME: #7956: temporarily disabled\n #[test]\n fn rustpkg_library_target() {\n     let foo_repo = init_git_repo(&Path(\"foo\"));\n@@ -683,23 +676,20 @@ fn rustpkg_local_pkg() {\n     assert_executable_exists(&dir, \"foo\");\n }\n \n-// FIXME: #7956: temporarily disabled\n-//  Failing on dist-linux bot\n #[test]\n-#[ignore]\n fn package_script_with_default_build() {\n     let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n     debug!(\"dir = %s\", dir.to_str());\n     let source = test_sysroot().pop().pop().pop().push(\"src\").push(\"librustpkg\").\n         push(\"testsuite\").push(\"pass\").push(\"src\").push(\"fancy-lib\").push(\"pkg.rs\");\n     debug!(\"package_script_with_default_build: %s\", source.to_str());\n     if !os::copy_file(&source,\n-                      & dir.push(\"src\").push(\"fancy_lib-0.1\").push(\"pkg.rs\")) {\n+                      & dir.push(\"src\").push(\"fancy-lib-0.1\").push(\"pkg.rs\")) {\n         fail!(\"Couldn't copy file\");\n     }\n     command_line_test([~\"install\", ~\"fancy-lib\"], &dir);\n     assert_lib_exists(&dir, \"fancy-lib\", NoVersion);\n-    assert!(os::path_exists(&dir.push(\"build\").push(\"fancy_lib\").push(\"generated.rs\")));\n+    assert!(os::path_exists(&dir.push(\"build\").push(\"fancy-lib\").push(\"generated.rs\")));\n }\n \n #[test]\n@@ -718,7 +708,7 @@ fn rustpkg_build_no_arg() {\n #[test]\n fn rustpkg_install_no_arg() {\n     let tmp = mkdtemp(&os::tmpdir(),\n-                      \"rustpkg_install_no_arg\").expect(\"rustpkg_build_no_arg failed\");\n+                      \"rustpkg_install_no_arg\").expect(\"rustpkg_install_no_arg failed\");\n     let package_dir = tmp.push(\"src\").push(\"foo\");\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     writeFile(&package_dir.push(\"lib.rs\"),\n@@ -745,7 +735,6 @@ fn rustpkg_clean_no_arg() {\n }\n \n #[test]\n-#[ignore (reason = \"Specifying env doesn't work -- see #8028\")]\n fn rust_path_test() {\n     let dir_for_path = mkdtemp(&os::tmpdir(), \"more_rust\").expect(\"rust_path_test failed\");\n     let dir = mk_workspace(&dir_for_path, &Path(\"foo\"), &NoVersion);\n@@ -755,20 +744,9 @@ fn rust_path_test() {\n     let cwd = os::getcwd();\n     debug!(\"cwd = %s\", cwd.to_str());\n                                      // use command_line_test_with_env\n-    let mut prog = run::Process::new(\"rustpkg\",\n-                                     [~\"install\", ~\"foo\"],\n-// This should actually extend the environment; then we can probably\n-// un-ignore it\n-                                     run::ProcessOptions { env: Some(~[(~\"RUST_LOG\",\n-                                                                        ~\"rustpkg\"),\n-                                                                       (~\"RUST_PATH\",\n-                                                                       dir_for_path.to_str())]),\n-                                                          dir: Some(&cwd),\n-                                                          in_fd: None,\n-                                                          out_fd: None,\n-                                                          err_fd: None\n-                                                         });\n-    prog.finish_with_output();\n+    command_line_test_with_env([~\"install\", ~\"foo\"],\n+                               &cwd,\n+                               Some(~[(~\"RUST_PATH\", dir_for_path.to_str())]));\n     assert_executable_exists(&dir_for_path, \"foo\");\n }\n "}, {"sha": "27818dea1a6996d300a11f085e4da12fc5b3104b", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=c099242a1a9536e73485830f6b06c4ab2eea8958", "patch": "@@ -38,7 +38,7 @@ pub fn main() {\n         return;\n     }\n \n-    let out_path = Path(\"build/fancy_lib\");\n+    let out_path = Path(\"build/fancy-lib\");\n     if !os::path_exists(&out_path) {\n         assert!(os::make_dir(&out_path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n     }"}, {"sha": "f8658517cdff4d84b2590edb5bb618553cf711ad", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c099242a1a9536e73485830f6b06c4ab2eea8958/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=c099242a1a9536e73485830f6b06c4ab2eea8958", "patch": "@@ -27,6 +27,10 @@ pub enum Version {\n     NoVersion // user didn't specify a version -- prints as 0.1\n }\n \n+// Equality on versions is non-symmetric: if self is NoVersion, it's equal to\n+// anything; but if self is a precise version, it's not equal to NoVersion.\n+// We should probably make equality symmetric, and use less-than and greater-than\n+// where we currently use eq\n impl Eq for Version {\n     fn eq(&self, other: &Version) -> bool {\n         match (self, other) {\n@@ -176,7 +180,7 @@ enum ParseState {\n     SawDot\n }\n \n-fn try_parsing_version(s: &str) -> Option<Version> {\n+pub fn try_parsing_version(s: &str) -> Option<Version> {\n     let s = s.trim();\n     debug!(\"Attempting to parse: %s\", s);\n     let mut parse_state = Start;\n@@ -207,17 +211,16 @@ fn is_url_like(p: &Path) -> bool {\n /// number, return the prefix before the # and the version.\n /// Otherwise, return None.\n pub fn split_version<'a>(s: &'a str) -> Option<(&'a str, Version)> {\n-    split_version_general(s, '#')\n+    // Check for extra '#' characters separately\n+    if s.split_iter('#').len() > 2 {\n+        None\n+    }\n+    else {\n+        split_version_general(s, '#')\n+    }\n }\n \n pub fn split_version_general<'a>(s: &'a str, sep: char) -> Option<(&'a str, Version)> {\n-    // reject strings with multiple '#'s\n-    for st in s.split_iter(sep) {\n-        debug!(\"whole = %s part = %s\", s, st);\n-    }\n-    if s.split_iter(sep).len() > 2 {\n-        return None;\n-    }\n     match s.rfind(sep) {\n         Some(i) => {\n             debug!(\"in %s, i = %?\", s, i);"}]}