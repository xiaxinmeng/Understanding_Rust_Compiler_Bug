{"sha": "326443105b897171424c6efde15198cd7a25bc61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNjQ0MzEwNWI4OTcxNzE0MjRjNmVmZGUxNTE5OGNkN2EyNWJjNjE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-01-27T17:12:34Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-01-27T17:12:34Z"}, "message": "trans: When coercing to `Box<Trait>` or `Box<[T]>`, leave datum in its original L-/R-value state.\n\nThis fixes a subtle issue where temporaries were being allocated (but\nnot necessarily initialized) to the (parent) terminating scope of a\nmatch expression; in particular, the code to zero out the temporary\nemitted by `datum.store_to` is only attached to the particular\nmatch-arm for that temporary, but when going down other arms of the\nmatch expression, the temporary may falsely appear to have been\ninitialized, depending on what the stack held at that location, and\nthus may have its destructor erroneously run at the end of the\nterminating scope.\n\nTest cases to appear in a follow-up commit.\n\nFix #20055", "tree": {"sha": "47b3d1eeace292b32b0a9fa31d02e0c2bce9e5a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47b3d1eeace292b32b0a9fa31d02e0c2bce9e5a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/326443105b897171424c6efde15198cd7a25bc61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/326443105b897171424c6efde15198cd7a25bc61", "html_url": "https://github.com/rust-lang/rust/commit/326443105b897171424c6efde15198cd7a25bc61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/326443105b897171424c6efde15198cd7a25bc61/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e365e4c05454d94131d14d0207c12bb895a4c186", "url": "https://api.github.com/repos/rust-lang/rust/commits/e365e4c05454d94131d14d0207c12bb895a4c186", "html_url": "https://github.com/rust-lang/rust/commit/e365e4c05454d94131d14d0207c12bb895a4c186"}], "stats": {"total": 23, "additions": 16, "deletions": 7}, "files": [{"sha": "3e60c0c541ad288c252506d8dae1b60ecffe92f9", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/326443105b897171424c6efde15198cd7a25bc61/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/326443105b897171424c6efde15198cd7a25bc61/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=326443105b897171424c6efde15198cd7a25bc61", "patch": "@@ -420,9 +420,15 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let tcx = bcx.tcx();\n \n         let datum_ty = datum.ty;\n-        // Arrange cleanup\n-        let lval = unpack_datum!(bcx,\n-                                 datum.to_lvalue_datum(bcx, \"unsize_unique_vec\", expr.id));\n+\n+        debug!(\"unsize_unique_vec expr.id={} datum_ty={} len={}\",\n+               expr.id, datum_ty.repr(tcx), len);\n+\n+        // We do not arrange cleanup ourselves; if we already are an\n+        // L-value, then cleanup will have already been scheduled (and\n+        // the `datum.store_to` call below will emit code to zero the\n+        // drop flag when moving out of the L-value). If we are an R-value,\n+        // then we do not need to schedule cleanup.\n \n         let ll_len = C_uint(bcx.ccx(), len);\n         let unit_ty = ty::sequence_element_type(tcx, ty::type_content(datum_ty));\n@@ -433,7 +439,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let base = PointerCast(bcx,\n                                base,\n                                type_of::type_of(bcx.ccx(), datum_ty).ptr_to());\n-        bcx = lval.store_to(bcx, base);\n+        bcx = datum.store_to(bcx, base);\n \n         Store(bcx, ll_len, get_len(bcx, scratch.val));\n         DatumBlock::new(bcx, scratch.to_expr_datum())\n@@ -455,13 +461,16 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         };\n         let result_ty = ty::mk_uniq(tcx, ty::unsize_ty(tcx, unboxed_ty, k, expr.span));\n \n-        let lval = unpack_datum!(bcx,\n-                                 datum.to_lvalue_datum(bcx, \"unsize_unique_expr\", expr.id));\n+        // We do not arrange cleanup ourselves; if we already are an\n+        // L-value, then cleanup will have already been scheduled (and\n+        // the `datum.store_to` call below will emit code to zero the\n+        // drop flag when moving out of the L-value). If we are an R-value,\n+        // then we do not need to schedule cleanup.\n \n         let scratch = rvalue_scratch_datum(bcx, result_ty, \"__uniq_fat_ptr\");\n         let llbox_ty = type_of::type_of(bcx.ccx(), datum_ty);\n         let base = PointerCast(bcx, get_dataptr(bcx, scratch.val), llbox_ty.ptr_to());\n-        bcx = lval.store_to(bcx, base);\n+        bcx = datum.store_to(bcx, base);\n \n         let info = unsized_info(bcx, k, expr.id, unboxed_ty, |t| ty::mk_uniq(tcx, t));\n         Store(bcx, info, get_len(bcx, scratch.val));"}]}