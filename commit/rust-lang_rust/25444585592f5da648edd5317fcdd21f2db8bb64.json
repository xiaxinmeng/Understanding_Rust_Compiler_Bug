{"sha": "25444585592f5da648edd5317fcdd21f2db8bb64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1NDQ0NTg1NTkyZjVkYTY0OGVkZDUzMTdmY2RkMjFmMmRiOGJiNjQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-09-03T21:15:15Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-09-03T21:15:18Z"}, "message": "Run rustfmt", "tree": {"sha": "742b5bf7dbe00537a4f9aeabf5816145c6447b4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/742b5bf7dbe00537a4f9aeabf5816145c6447b4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25444585592f5da648edd5317fcdd21f2db8bb64", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEKEMXbnGOy4KpaPA5O79NPi73n5gFAlmscOYACgkQO79NPi73\nn5h+Zw//XcL5ABu/dwyqitNSw4mbISgTGTbO5qBrCnH8Lup4rR5W3+eLRuRs9BaW\nIfiGLlMAit9f2ESog79vFzXuE57y6wAD/aYgy+vZ9No26PHytyyXIR4TId8OD2QG\n6YIx+9aqiks8taS2f5+3RFbrLJKIhZLDZEbGK5i4Oa3RN3FqXUTtXD39UE1NGBQn\n+IBkqCTvbKgpR1HkfPSkZFeTZfzaf3erCt/8n8vlc9AEbkeNou8atUXKa3gTkgQb\ntZTuSAULGQ+RqsrWKJjrloIu0prvvaxXWqH1J0a8OAdpXbTCNq2+Hpee3gLhh8E8\nGD9v0y7C23N95oPRGHQchl9CQsOYRmaCqJhaPgFZzrCNABv1dDq6UGwNq8ReEpZo\nlrLdF08W8ULwSgVbFI3NpFLj3e1VjhV0Bbsu15X4insAV0J/dTOf/qXlXDnQkQ0d\n9xwfBeW9SNQY5Rjcrg0BHHZtEnvzjTmmq7Y8t/GjLUbCUe6qWTsXIMDyOK9BiTkd\nlV8GaRZWnZopeYa9PoJ1xRXiYzHUZPTPUhts3yfx3oJLN0QCXEYMKD8v8aA4GKEk\nU3HBMfZtwjBAXGkpmmm9G2+xfrbqrD5wH8BFOpb/YsIDVkxWebWzhCCQZS3EDZAH\nnLiaC/QN4DVGRF6PS54hlDLGDXe/LScckbndOEth7omw+yGAvME=\n=TitK\n-----END PGP SIGNATURE-----", "payload": "tree 742b5bf7dbe00537a4f9aeabf5816145c6447b4e\nparent 35eda0531a51115cdae893fac68b6fae976cab1f\nauthor Manish Goregaokar <manishsmail@gmail.com> 1504473315 -0700\ncommitter Manish Goregaokar <manishsmail@gmail.com> 1504473318 -0700\n\nRun rustfmt\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25444585592f5da648edd5317fcdd21f2db8bb64", "html_url": "https://github.com/rust-lang/rust/commit/25444585592f5da648edd5317fcdd21f2db8bb64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25444585592f5da648edd5317fcdd21f2db8bb64/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35eda0531a51115cdae893fac68b6fae976cab1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/35eda0531a51115cdae893fac68b6fae976cab1f", "html_url": "https://github.com/rust-lang/rust/commit/35eda0531a51115cdae893fac68b6fae976cab1f"}], "stats": {"total": 306, "additions": 175, "deletions": 131}, "files": [{"sha": "1d7afbe084dd6e912a001cf446765ae5d0bd9f3d", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -97,19 +97,25 @@ fn get_pat_name(pat: &Pat) -> Option<Name> {\n     match pat.node {\n         PatKind::Binding(_, _, ref spname, _) => Some(spname.node),\n         PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.name),\n-        PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n-        _ => None\n+        PatKind::Box(ref p) |\n+        PatKind::Ref(ref p, _) => get_pat_name(&*p),\n+        _ => None,\n     }\n }\n \n fn get_path_name(expr: &Expr) -> Option<Name> {\n     match expr.node {\n-        ExprBox(ref e) | ExprAddrOf(_, ref e) | ExprUnary(UnOp::UnDeref, ref e) => get_path_name(e),\n-        ExprBlock(ref b) => if b.stmts.is_empty() {\n-            b.expr.as_ref().and_then(|p| get_path_name(p))\n-        } else { None },\n+        ExprBox(ref e) |\n+        ExprAddrOf(_, ref e) |\n+        ExprUnary(UnOp::UnDeref, ref e) => get_path_name(e),\n+        ExprBlock(ref b) => {\n+            if b.stmts.is_empty() {\n+                b.expr.as_ref().and_then(|p| get_path_name(p))\n+            } else {\n+                None\n+            }\n+        },\n         ExprPath(ref qpath) => single_segment_path(qpath).map(|ps| ps.name),\n-        _ => None\n+        _ => None,\n     }\n }\n-"}, {"sha": "f9e11d06882d793c4f997aabe584cb4e66891e1e", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -67,7 +67,8 @@ declare_lint! {\n /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n ///\n /// **Known problems:** False positive possible with order dependent `match`\n-/// (see issue [#860](https://github.com/rust-lang-nursery/rust-clippy/issues/860)).\n+/// (see issue\n+/// [#860](https://github.com/rust-lang-nursery/rust-clippy/issues/860)).\n ///\n /// **Example:**\n /// ```rust,ignore"}, {"sha": "8977ea437d141c3d78c5c3270172b31eaf044f38", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -94,10 +94,7 @@ pub fn strip_doc_comment_decoration(comment: &str, span: Span) -> (String, Vec<(\n             return (\n                 doc.to_owned(),\n                 vec![\n-                    (\n-                        doc.len(),\n-                        span.with_lo(span.lo() + BytePos(prefix.len() as u32)),\n-                    ),\n+                    (doc.len(), span.with_lo(span.lo() + BytePos(prefix.len() as u32))),\n                 ],\n             );\n         }\n@@ -112,10 +109,7 @@ pub fn strip_doc_comment_decoration(comment: &str, span: Span) -> (String, Vec<(\n             debug_assert_eq!(offset as u32 as usize, offset);\n             contains_initial_stars |= line.trim_left().starts_with('*');\n             // +1 for the newline\n-            sizes.push((\n-                line.len() + 1,\n-                span.with_lo(span.lo() + BytePos(offset as u32)),\n-            ));\n+            sizes.push((line.len() + 1, span.with_lo(span.lo() + BytePos(offset as u32))));\n         }\n         if !contains_initial_stars {\n             return (doc.to_string(), sizes);"}, {"sha": "3e2cfc033fc6d35972d488ec37eb59910b136b11", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -50,9 +50,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         let (lint, msg) = match complete_infinite_iter(cx, expr) {\n             Infinite => (INFINITE_ITER, \"infinite iteration detected\"),\n-            MaybeInfinite => (MAYBE_INFINITE_ITER,\n-                        \"possible infinite iteration detected\"),\n-            Finite => { return; }\n+            MaybeInfinite => (MAYBE_INFINITE_ITER, \"possible infinite iteration detected\"),\n+            Finite => {\n+                return;\n+            },\n         };\n         span_lint(cx, lint, expr.span, msg)\n     }\n@@ -62,7 +63,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n enum Finiteness {\n     Infinite,\n     MaybeInfinite,\n-    Finite\n+    Finite,\n }\n \n use self::Finiteness::{Infinite, MaybeInfinite, Finite};\n@@ -71,16 +72,18 @@ impl Finiteness {\n     fn and(self, b: Self) -> Self {\n         match (self, b) {\n             (Finite, _) | (_, Finite) => Finite,\n-            (MaybeInfinite, _) | (_, MaybeInfinite) => MaybeInfinite,\n-            _ => Infinite\n+            (MaybeInfinite, _) |\n+            (_, MaybeInfinite) => MaybeInfinite,\n+            _ => Infinite,\n         }\n     }\n \n     fn or(self, b: Self) -> Self {\n         match (self, b) {\n             (Infinite, _) | (_, Infinite) => Infinite,\n-            (MaybeInfinite, _) | (_, MaybeInfinite) => MaybeInfinite,\n-            _ => Finite\n+            (MaybeInfinite, _) |\n+            (_, MaybeInfinite) => MaybeInfinite,\n+            _ => Finite,\n         }\n     }\n }\n@@ -102,7 +105,7 @@ enum Heuristic {\n     /// infinite if any of the supplied arguments is\n     Any,\n     /// infinite if all of the supplied arguments are\n-    All\n+    All,\n }\n \n use self::Heuristic::{Always, First, Any, All};\n@@ -112,7 +115,7 @@ use self::Heuristic::{Always, First, Any, All};\n /// returns an infinite or possibly infinite iterator. The finiteness\n /// is an upper bound, e.g. some methods can return a possibly\n /// infinite iterator at worst, e.g. `take_while`.\n-static HEURISTICS : &[(&str, usize, Heuristic, Finiteness)] = &[\n+static HEURISTICS: &[(&str, usize, Heuristic, Finiteness)] = &[\n     (\"zip\", 2, All, Infinite),\n     (\"chain\", 2, Any, Infinite),\n     (\"cycle\", 1, Always, Infinite),\n@@ -131,7 +134,7 @@ static HEURISTICS : &[(&str, usize, Heuristic, Finiteness)] = &[\n     (\"flat_map\", 2, First, Infinite),\n     (\"unzip\", 1, First, Infinite),\n     (\"take_while\", 2, First, MaybeInfinite),\n-    (\"scan\", 3, First, MaybeInfinite)\n+    (\"scan\", 3, First, MaybeInfinite),\n ];\n \n fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n@@ -140,11 +143,11 @@ fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n             for &(name, len, heuristic, cap) in HEURISTICS.iter() {\n                 if method.name == name && args.len() == len {\n                     return (match heuristic {\n-                        Always => Infinite,\n-                        First => is_infinite(cx, &args[0]),\n-                        Any => is_infinite(cx, &args[0]).or(is_infinite(cx, &args[1])),\n-                        All => is_infinite(cx, &args[0]).and(is_infinite(cx, &args[1])),\n-                    }).and(cap);\n+                                Always => Infinite,\n+                                First => is_infinite(cx, &args[0]),\n+                                Any => is_infinite(cx, &args[0]).or(is_infinite(cx, &args[1])),\n+                                All => is_infinite(cx, &args[0]).and(is_infinite(cx, &args[1])),\n+                            }).and(cap);\n                 }\n             }\n             if method.name == \"flat_map\" && args.len() == 2 {\n@@ -155,35 +158,39 @@ fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n             }\n             Finite\n         },\n-        ExprBlock(ref block) =>\n-            block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n-        ExprBox(ref e) | ExprAddrOf(_, ref e) => is_infinite(cx, e),\n+        ExprBlock(ref block) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n+        ExprBox(ref e) |\n+        ExprAddrOf(_, ref e) => is_infinite(cx, e),\n         ExprCall(ref path, _) => {\n             if let ExprPath(ref qpath) = path.node {\n                 match_qpath(qpath, &paths::REPEAT).into()\n-            } else { Finite }\n+            } else {\n+                Finite\n+            }\n         },\n         ExprStruct(..) => {\n-            higher::range(expr).map_or(false, |r| r.end.is_none()).into()\n+            higher::range(expr)\n+                .map_or(false, |r| r.end.is_none())\n+                .into()\n         },\n-        _ => Finite\n+        _ => Finite,\n     }\n }\n \n /// the names and argument lengths of methods that *may* exhaust their\n /// iterators\n-static POSSIBLY_COMPLETING_METHODS : &[(&str, usize)] = &[\n+static POSSIBLY_COMPLETING_METHODS: &[(&str, usize)] = &[\n     (\"find\", 2),\n     (\"rfind\", 2),\n     (\"position\", 2),\n     (\"rposition\", 2),\n     (\"any\", 2),\n-    (\"all\", 2)\n+    (\"all\", 2),\n ];\n \n /// the names and argument lengths of methods that *always* exhaust\n /// their iterators\n-static COMPLETING_METHODS : &[(&str, usize)] = &[\n+static COMPLETING_METHODS: &[(&str, usize)] = &[\n     (\"count\", 1),\n     (\"collect\", 1),\n     (\"fold\", 3),\n@@ -196,7 +203,7 @@ static COMPLETING_METHODS : &[(&str, usize)] = &[\n     (\"min_by\", 2),\n     (\"min_by_key\", 2),\n     (\"sum\", 1),\n-    (\"product\", 1)\n+    (\"product\", 1),\n ];\n \n fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> Finiteness {\n@@ -213,20 +220,24 @@ fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> Finiteness {\n                 }\n             }\n             if method.name == \"last\" && args.len() == 1 &&\n-                    get_trait_def_id(cx, &paths::DOUBLE_ENDED_ITERATOR).map_or(false,\n-                        |id| !implements_trait(cx,\n-                                               cx.tables.expr_ty(&args[0]),\n-                                               id,\n-                                               &[])) {\n+                get_trait_def_id(cx, &paths::DOUBLE_ENDED_ITERATOR).map_or(\n+                    false,\n+                    |id| {\n+                        !implements_trait(cx, cx.tables.expr_ty(&args[0]), id, &[])\n+                    },\n+                )\n+            {\n                 return is_infinite(cx, &args[0]);\n             }\n         },\n         ExprBinary(op, ref l, ref r) => {\n             if op.node.is_comparison() {\n-                return is_infinite(cx, l).and(is_infinite(cx, r)).and(MaybeInfinite)\n+                return is_infinite(cx, l).and(is_infinite(cx, r)).and(\n+                    MaybeInfinite,\n+                );\n             }\n         }, //TODO: ExprLoop + Match\n-        _ => ()\n+        _ => (),\n     }\n     Finite\n }"}, {"sha": "5939cd36bf861d9b47890d3f2e9188d1d7892a8a", "filename": "clippy_lints/src/is_unit_expr.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fis_unit_expr.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -42,7 +42,7 @@ impl EarlyLintPass for UnitExpr {\n                     cx,\n                     UNIT_EXPR,\n                     expr.span,\n-                        \"This expression evaluates to the Unit type ()\",\n+                    \"This expression evaluates to the Unit type ()\",\n                     span,\n                     \"Consider removing the trailing semicolon\",\n                 );\n@@ -100,10 +100,12 @@ impl EarlyLintPass for UnitExpr {\n }\n fn is_unit_expr(expr: &Expr) -> Option<Span> {\n     match expr.node {\n-        ExprKind::Block(ref block) => if check_last_stmt_in_block(block) {\n-            Some(block.stmts[block.stmts.len() - 1].span)\n-        } else {\n-            None\n+        ExprKind::Block(ref block) => {\n+            if check_last_stmt_in_block(block) {\n+                Some(block.stmts[block.stmts.len() - 1].span)\n+            } else {\n+                None\n+            }\n         },\n         ExprKind::If(_, ref then, ref else_) => {\n             let check_then = check_last_stmt_in_block(then);\n@@ -113,11 +115,7 @@ fn is_unit_expr(expr: &Expr) -> Option<Span> {\n                     return Some(*expr_else);\n                 }\n             }\n-            if check_then {\n-                Some(expr.span)\n-            } else {\n-                None\n-            }\n+            if check_then { Some(expr.span) } else { None }\n         },\n         ExprKind::Match(ref _pattern, ref arms) => {\n             for arm in arms {\n@@ -135,12 +133,16 @@ fn check_last_stmt_in_block(block: &Block) -> bool {\n     let final_stmt = &block.stmts[block.stmts.len() - 1];\n \n \n-    //Made a choice here to risk false positives on divergent macro invocations like `panic!()`\n+    // Made a choice here to risk false positives on divergent macro invocations\n+    // like `panic!()`\n     match final_stmt.node {\n         StmtKind::Expr(_) => false,\n-        StmtKind::Semi(ref expr) => match expr.node {\n-            ExprKind::Break(_, _) | ExprKind::Ret(_) => false,\n-            _ => true,\n+        StmtKind::Semi(ref expr) => {\n+            match expr.node {\n+                ExprKind::Break(_, _) |\n+                ExprKind::Ret(_) => false,\n+                _ => true,\n+            }\n         },\n         _ => true,\n     }"}, {"sha": "798d48f177d356a2eb0aa45bf35254641098e42a", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -121,11 +121,7 @@ fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[Trai\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.id) &&\n-        trait_items\n-            .iter()\n-            .any(|i| is_named_self(cx, i, \"len\"))\n-    {\n+    if cx.access_levels.is_exported(visited_trait.id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n         let mut current_and_super_traits = HashSet::new();\n         fill_trait_set(visited_trait, &mut current_and_super_traits, cx);\n "}, {"sha": "cfaa9f698e0a57e84d0631e4d30a8da0646e7fe9", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -1463,14 +1463,15 @@ fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Gener\n                     if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n                         let path = &ptr.trait_ref.path;\n                         match_path(path, name) &&\n-                            path.segments.last().map_or(false, |s| {\n-                                if s.parameters.parenthesized {\n+                            path.segments.last().map_or(\n+                                false,\n+                                |s| if s.parameters.parenthesized {\n                                     false\n                                 } else {\n                                     s.parameters.types.len() == 1 &&\n                                         (is_self_ty(&s.parameters.types[0]) || is_ty(&*s.parameters.types[0], self_ty))\n-                                }\n-                            })\n+                                },\n+                            )\n                     } else {\n                         false\n                     }"}, {"sha": "9ce7df474a3da0c7172e4f2a29a2907d90417a64", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -23,6 +23,7 @@\n //\n //\n //\n+//\n // rs#L246\n //\n "}, {"sha": "0aa741db0762be05411b14d9f773f485f6079889", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -8,7 +8,8 @@ use utils::{span_lint_and_then, in_macro, snippet};\n \n /// **What it does:** Checks for useless borrowed references.\n ///\n-/// **Why is this bad?** It is mostly useless and make the code look more complex than it\n+/// **Why is this bad?** It is mostly useless and make the code look more\n+/// complex than it\n /// actually is.\n ///\n /// **Known problems:** It seems that the `&ref` pattern is sometimes useful.\n@@ -21,12 +22,14 @@ use utils::{span_lint_and_then, in_macro, snippet};\n ///\n /// fn foo(a: &Animal, b: &Animal) {\n ///     match (a, b) {\n-///         (&Animal::Cat(v), k) | (k, &Animal::Cat(v)) => (), // lifetime mismatch error\n+/// (&Animal::Cat(v), k) | (k, &Animal::Cat(v)) => (), // lifetime\n+/// mismatch error\n ///         (&Animal::Dog(ref c), &Animal::Dog(_)) => ()\n ///     }\n /// }\n /// ```\n-/// There is a lifetime mismatch error for `k` (indeed a and b have distinct lifetime).\n+/// There is a lifetime mismatch error for `k` (indeed a and b have distinct\n+/// lifetime).\n /// This can be fixed by using the `&ref` pattern.\n /// However, the code can also be fixed by much cleaner ways\n ///\n@@ -77,4 +80,3 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrowedRef {\n         }}\n     }\n }\n-"}, {"sha": "c1011168c529689da721bde95a7a2c459ef7ecbf", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -139,11 +139,7 @@ fn str_span(base: Span, s: &str, c: usize) -> Span {\n \n     match (si.next(), si.next()) {\n         (Some((l, _)), Some((h, _))) => {\n-            Span::new(\n-                base.lo() + BytePos(l as u32),\n-                base.lo() + BytePos(h as u32),\n-                base.ctxt(),\n-            )\n+            Span::new(base.lo() + BytePos(l as u32), base.lo() + BytePos(h as u32), base.ctxt())\n         },\n         _ => base,\n     }"}, {"sha": "5649847b33495d3de69c305de537fa4d13bfb3ec", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -390,4 +390,3 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n fn path_eq_name(name: Name, path: &Path) -> bool {\n     !path.is_global() && path.segments.len() == 1 && path.segments[0].name.as_str() == name.as_str()\n }\n-"}, {"sha": "05a498ff2622cf565503168e233ee4904790d8ff", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 67, "deletions": 35, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -182,12 +182,18 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n             match *qpath {\n                 QPath::Resolved(Some(ref ty), ref p) => {\n                     check_ty(cx, ty, is_local);\n-                    for ty in p.segments.iter().flat_map(|seg| seg.parameters.types.iter()) {\n+                    for ty in p.segments.iter().flat_map(\n+                        |seg| seg.parameters.types.iter(),\n+                    )\n+                    {\n                         check_ty(cx, ty, is_local);\n                     }\n                 },\n                 QPath::Resolved(None, ref p) => {\n-                    for ty in p.segments.iter().flat_map(|seg| seg.parameters.types.iter()) {\n+                    for ty in p.segments.iter().flat_map(\n+                        |seg| seg.parameters.types.iter(),\n+                    )\n+                    {\n                         check_ty(cx, ty, is_local);\n                     }\n                 },\n@@ -523,21 +529,25 @@ declare_lint! {\n /// Will return 0 if the type is not an int or uint variant\n fn int_ty_to_nbits(typ: Ty, tcx: TyCtxt) -> u64 {\n     match typ.sty {\n-        ty::TyInt(i) => match i {\n-            IntTy::Is => tcx.data_layout.pointer_size.bits(),\n-            IntTy::I8 => 8,\n-            IntTy::I16 => 16,\n-            IntTy::I32 => 32,\n-            IntTy::I64 => 64,\n-            IntTy::I128 => 128,\n+        ty::TyInt(i) => {\n+            match i {\n+                IntTy::Is => tcx.data_layout.pointer_size.bits(),\n+                IntTy::I8 => 8,\n+                IntTy::I16 => 16,\n+                IntTy::I32 => 32,\n+                IntTy::I64 => 64,\n+                IntTy::I128 => 128,\n+            }\n         },\n-        ty::TyUint(i) => match i {\n-            UintTy::Us => tcx.data_layout.pointer_size.bits(),\n-            UintTy::U8 => 8,\n-            UintTy::U16 => 16,\n-            UintTy::U32 => 32,\n-            UintTy::U64 => 64,\n-            UintTy::U128 => 128,\n+        ty::TyUint(i) => {\n+            match i {\n+                UintTy::Us => tcx.data_layout.pointer_size.bits(),\n+                UintTy::U8 => 8,\n+                UintTy::U16 => 16,\n+                UintTy::U32 => 32,\n+                UintTy::U64 => 64,\n+                UintTy::U128 => 128,\n+            }\n         },\n         _ => 0,\n     }\n@@ -583,14 +593,14 @@ fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_t\n }\n \n fn span_lossless_lint(cx: &LateContext, expr: &Expr, op: &Expr, cast_from: Ty, cast_to: Ty) {\n-    span_lint_and_sugg(cx,\n-                       CAST_LOSSLESS,\n-                       expr.span,\n-                       &format!(\"casting {} to {} may become silently lossy if types change\",\n-                               cast_from,\n-                               cast_to),\n-                       \"try\",\n-                       format!(\"{}::from({})\", cast_to, &snippet(cx, op.span, \"..\")));\n+    span_lint_and_sugg(\n+        cx,\n+        CAST_LOSSLESS,\n+        expr.span,\n+        &format!(\"casting {} to {} may become silently lossy if types change\", cast_from, cast_to),\n+        \"try\",\n+        format!(\"{}::from({})\", cast_to, &snippet(cx, op.span, \"..\")),\n+    );\n }\n \n enum ArchSuffix {\n@@ -680,8 +690,9 @@ fn check_lossless(cx: &LateContext, expr: &Expr, op: &Expr, cast_from: Ty, cast_\n     let cast_signed_to_unsigned = cast_from.is_signed() && !cast_to.is_signed();\n     let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n     let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n-    if !is_isize_or_usize(cast_from) && !is_isize_or_usize(cast_to) &&\n-       from_nbits < to_nbits && !cast_signed_to_unsigned {\n+    if !is_isize_or_usize(cast_from) && !is_isize_or_usize(cast_to) && from_nbits < to_nbits &&\n+        !cast_signed_to_unsigned\n+    {\n         span_lossless_lint(cx, expr, op, cast_from, cast_to);\n     }\n }\n@@ -776,7 +787,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                             );\n                         }\n                         if let (&ty::TyFloat(FloatTy::F32), &ty::TyFloat(FloatTy::F64)) =\n-                            (&cast_from.sty, &cast_to.sty) {\n+                            (&cast_from.sty, &cast_to.sty)\n+                        {\n                             span_lossless_lint(cx, expr, ex, cast_from, cast_to);\n                         }\n                     },\n@@ -1011,7 +1023,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n /// **Known problems:** For `usize` the size of the current compile target will\n /// be assumed (e.g. 64 bits on 64 bit systems). This means code that uses such\n /// a comparison to detect target pointer width will trigger this lint. One can\n-/// use `mem::sizeof` and compare its value or conditional compilation attributes\n+/// use `mem::sizeof` and compare its value or conditional compilation\n+/// attributes\n /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n ///\n /// **Example:**\n@@ -1209,7 +1222,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n /// will mistakenly imply that it is possible for `x` to be outside the range of\n /// `u8`.\n ///\n-/// **Known problems:** https://github.com/rust-lang-nursery/rust-clippy/issues/886\n+/// **Known problems:**\n+/// https://github.com/rust-lang-nursery/rust-clippy/issues/886\n ///\n /// **Example:**\n /// ```rust\n@@ -1290,19 +1304,37 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n             ty::TyInt(int_ty) => {\n                 Some(match int_ty {\n                     IntTy::I8 => (FullInt::S(i128::from(i8::min_value())), FullInt::S(i128::from(i8::max_value()))),\n-                    IntTy::I16 => (FullInt::S(i128::from(i16::min_value())), FullInt::S(i128::from(i16::max_value()))),\n-                    IntTy::I32 => (FullInt::S(i128::from(i32::min_value())), FullInt::S(i128::from(i32::max_value()))),\n-                    IntTy::I64 => (FullInt::S(i128::from(i64::min_value())), FullInt::S(i128::from(i64::max_value()))),\n+                    IntTy::I16 => (\n+                        FullInt::S(i128::from(i16::min_value())),\n+                        FullInt::S(i128::from(i16::max_value())),\n+                    ),\n+                    IntTy::I32 => (\n+                        FullInt::S(i128::from(i32::min_value())),\n+                        FullInt::S(i128::from(i32::max_value())),\n+                    ),\n+                    IntTy::I64 => (\n+                        FullInt::S(i128::from(i64::min_value())),\n+                        FullInt::S(i128::from(i64::max_value())),\n+                    ),\n                     IntTy::I128 => (FullInt::S(i128::min_value() as i128), FullInt::S(i128::max_value() as i128)),\n                     IntTy::Is => (FullInt::S(isize::min_value() as i128), FullInt::S(isize::max_value() as i128)),\n                 })\n             },\n             ty::TyUint(uint_ty) => {\n                 Some(match uint_ty {\n                     UintTy::U8 => (FullInt::U(u128::from(u8::min_value())), FullInt::U(u128::from(u8::max_value()))),\n-                    UintTy::U16 => (FullInt::U(u128::from(u16::min_value())), FullInt::U(u128::from(u16::max_value()))),\n-                    UintTy::U32 => (FullInt::U(u128::from(u32::min_value())), FullInt::U(u128::from(u32::max_value()))),\n-                    UintTy::U64 => (FullInt::U(u128::from(u64::min_value())), FullInt::U(u128::from(u64::max_value()))),\n+                    UintTy::U16 => (\n+                        FullInt::U(u128::from(u16::min_value())),\n+                        FullInt::U(u128::from(u16::max_value())),\n+                    ),\n+                    UintTy::U32 => (\n+                        FullInt::U(u128::from(u32::min_value())),\n+                        FullInt::U(u128::from(u32::max_value())),\n+                    ),\n+                    UintTy::U64 => (\n+                        FullInt::U(u128::from(u64::min_value())),\n+                        FullInt::U(u128::from(u64::max_value())),\n+                    ),\n                     UintTy::U128 => (FullInt::U(u128::min_value() as u128), FullInt::U(u128::max_value() as u128)),\n                     UintTy::Us => (FullInt::U(usize::min_value() as u128), FullInt::U(usize::max_value() as u128)),\n                 })"}, {"sha": "9f75ed2717b2448a70d04cb0684b01417da513fb", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -8,7 +8,8 @@ use syntax_pos::symbol::keywords::SelfType;\n /// **What it does:** Checks for unnecessary repetition of structure name when a\n /// replacement with `Self` is applicable.\n ///\n-/// **Why is this bad?** Unnecessary repetition. Mixed use of `Self` and struct name\n+/// **Why is this bad?** Unnecessary repetition. Mixed use of `Self` and struct\n+/// name\n /// feels inconsistent.\n ///\n /// **Known problems:** None.\n@@ -78,11 +79,7 @@ struct UseSelfVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {\n     fn visit_path(&mut self, path: &'tcx Path, _id: NodeId) {\n-        if self.item_path.def == path.def &&\n-           path.segments\n-            .last()\n-            .expect(SEGMENTS_MSG)\n-            .name != SelfType.name() {\n+        if self.item_path.def == path.def && path.segments.last().expect(SEGMENTS_MSG).name != SelfType.name() {\n             span_lint_and_then(self.cx, USE_SELF, path.span, \"unnecessary structure name repetition\", |db| {\n                 db.span_suggestion(path.span, \"use the applicable keyword\", \"Self\".to_owned());\n             });"}, {"sha": "d9a454aaf7e3a24d581d7b628d599994263cabdd", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -92,7 +92,9 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n                     end: get_field(\"end\", fields),\n                     limits: ast::RangeLimits::HalfOpen,\n                 })\n-            } else if match_qpath(path, &paths::RANGE_TO_INCLUSIVE_STD) || match_qpath(path, &paths::RANGE_TO_INCLUSIVE) {\n+            } else if match_qpath(path, &paths::RANGE_TO_INCLUSIVE_STD) ||\n+                       match_qpath(path, &paths::RANGE_TO_INCLUSIVE)\n+            {\n                 Some(Range {\n                     start: None,\n                     end: get_field(\"end\", fields),"}, {"sha": "0b3f409adf44dda5493c0e7133e5b5c052ff0739", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -196,12 +196,16 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n     fn eq_path_parameters(&self, left: &PathParameters, right: &PathParameters) -> bool {\n         if !(left.parenthesized || right.parenthesized) {\n-                over(&left.lifetimes, &right.lifetimes, |l, r| self.eq_lifetime(l, r)) &&\n-                    over(&left.types, &right.types, |l, r| self.eq_ty(l, r)) &&\n-                    over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n+            over(&left.lifetimes, &right.lifetimes, |l, r| self.eq_lifetime(l, r)) &&\n+                over(&left.types, &right.types, |l, r| self.eq_ty(l, r)) &&\n+                over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n         } else if left.parenthesized && right.parenthesized {\n-                over(left.inputs(), right.inputs(), |l, r| self.eq_ty(l, r)) &&\n-                    both(&Some(&left.bindings[0].ty), &Some(&right.bindings[0].ty), |l, r| self.eq_ty(l, r))\n+            over(left.inputs(), right.inputs(), |l, r| self.eq_ty(l, r)) &&\n+                both(\n+                    &Some(&left.bindings[0].ty),\n+                    &Some(&right.bindings[0].ty),\n+                    |l, r| self.eq_ty(l, r),\n+                )\n         } else {\n             false\n         }"}, {"sha": "315f498707113a6dd9e3ce2c75df8ccb67ce9c6c", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444585592f5da648edd5317fcdd21f2db8bb64/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=25444585592f5da648edd5317fcdd21f2db8bb64", "patch": "@@ -252,7 +252,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n         hir::ExprYield(ref sub) => {\n             println!(\"{}Yield\", ind);\n             print_expr(cx, sub, indent + 1);\n-        }\n+        },\n         hir::ExprBlock(_) => {\n             println!(\"{}Block\", ind);\n         },"}]}