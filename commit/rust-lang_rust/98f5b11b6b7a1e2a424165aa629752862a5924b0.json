{"sha": "98f5b11b6b7a1e2a424165aa629752862a5924b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZjViMTFiNmI3YTFlMmE0MjQxNjVhYTYyOTc1Mjg2MmE1OTI0YjA=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-10-17T08:54:37Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-10-25T12:52:07Z"}, "message": "Migrate from `#[structural_match]` attribute a lang-item trait.\n\n(Or more precisely, a pair of such traits: one for `derive(PartialEq)` and one\nfor `derive(Eq)`.)\n\n((The addition of the second marker trait, `StructuralEq`, is largely a hack to\nwork-around `fn (&T)` not implementing `PartialEq` and `Eq`; see also issue\nrust-lang/rust#46989; otherwise I would just check if `Eq` is implemented.))\n\nNote: this does not use trait fulfillment error-reporting machinery; it just\nuses the trait system to determine if the ADT was tagged or not. (Nonetheless, I\nhave kept an `on_unimplemented` message on the new trait for structural_match\ncheck, even though it is currently not used.)\n\nNote also: this does *not* resolve the ICE from rust-lang/rust#65466, as noted\nin a comment added in this commit. Further work is necessary to resolve that and\nother problems with the structural match checking, especially to do so without\nbreaking stable code (adapted from test fn-ptr-is-structurally-matchable.rs):\n\n```rust\nfn r_sm_to(_: &SM) {}\n\nfn main() {\n    const CFN6: Wrap<fn(&SM)> = Wrap(r_sm_to);\n    let input: Wrap<fn(&SM)> = Wrap(r_sm_to);\n    match Wrap(input) {\n        Wrap(CFN6) => {}\n        Wrap(_) => {}\n    };\n}\n```\n\nwhere we would hit a problem with the strategy of unconditionally checking for\n`PartialEq` because the type `for <'a> fn(&'a SM)` does not currently even\n*implement* `PartialEq`.\n\n----\n\nadded review feedback:\n* use an or-pattern\n* eschew `return` when tail position will do.\n* don't need fresh_expansion; just add `structural_match` to appropriate `allow_internal_unstable` attributes.\n\nalso fixed example in doc comment so that it actually compiles.", "tree": {"sha": "6b48f5ea6d987bc490eca61fb3af48545f97f4ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b48f5ea6d987bc490eca61fb3af48545f97f4ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98f5b11b6b7a1e2a424165aa629752862a5924b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98f5b11b6b7a1e2a424165aa629752862a5924b0", "html_url": "https://github.com/rust-lang/rust/commit/98f5b11b6b7a1e2a424165aa629752862a5924b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98f5b11b6b7a1e2a424165aa629752862a5924b0/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "620083ad16d02686c3af2fb78ea65dc5b2d4584c", "url": "https://api.github.com/repos/rust-lang/rust/commits/620083ad16d02686c3af2fb78ea65dc5b2d4584c", "html_url": "https://github.com/rust-lang/rust/commit/620083ad16d02686c3af2fb78ea65dc5b2d4584c"}], "stats": {"total": 680, "additions": 508, "deletions": 172}, "files": [{"sha": "1ac51291b93d790b8bfaa76c3b6a358da43254e5", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -211,7 +211,7 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// Derive macro generating an impl of the trait `PartialEq`.\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-#[allow_internal_unstable(core_intrinsics)]\n+#[allow_internal_unstable(core_intrinsics, structural_match)]\n pub macro PartialEq($item:item) { /* compiler built-in */ }\n \n /// Trait for equality comparisons which are [equivalence relations](\n@@ -273,7 +273,7 @@ pub trait Eq: PartialEq<Self> {\n /// Derive macro generating an impl of the trait `Eq`.\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-#[allow_internal_unstable(core_intrinsics, derive_eq)]\n+#[allow_internal_unstable(core_intrinsics, derive_eq, structural_match)]\n pub macro Eq($item:item) { /* compiler built-in */ }\n \n // FIXME: this struct is used solely by #[derive] to"}, {"sha": "a25573feabb2bb02b7366d52d04f886b39ac56cd", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -126,6 +126,85 @@ pub trait Unsize<T: ?Sized> {\n     // Empty.\n }\n \n+/// Required trait for constants used in pattern matches.\n+///\n+/// Any type that derives `PartialEq` automatically implements this trait,\n+/// *regardless* of whether its type-parameters implement `Eq`.\n+///\n+/// If a `const` item contains some type that does not implement this trait,\n+/// then that type either (1.) does not implement `PartialEq` (which means the\n+/// constant will not provide that comparison method, which code generation\n+/// assumes is available), or (2.) it implements *its own* version of\n+/// `PartialEq` (which we assume does not conform to a structural-equality\n+/// comparison).\n+///\n+/// In either of the two scenarios above, we reject usage of such a constant in\n+/// a pattern match.\n+///\n+/// See also the [structural match RFC][RFC1445], and [issue 63438][] which\n+/// motivated migrating from attribute-based design to this trait.\n+///\n+/// [RFC1445]: https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md\n+/// [issue 63438]: https://github.com/rust-lang/rust/issues/63438\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"structural_match\", issue = \"31434\")]\n+#[rustc_on_unimplemented(message=\"the type `{Self}` does not `#[derive(PartialEq)]`\")]\n+#[lang = \"structural_peq\"]\n+pub trait StructuralPartialEq {\n+    // Empty.\n+}\n+\n+/// Required trait for constants used in pattern matches.\n+///\n+/// Any type that derives `Eq` automatically implements this trait, *regardless*\n+/// of whether its type-parameters implement `Eq`.\n+///\n+/// This is a hack to workaround a limitation in our type-system.\n+///\n+/// Background:\n+///\n+/// We want to require that types of consts used in pattern matches\n+/// have the attribute `#[derive(PartialEq, Eq)]`.\n+///\n+/// In a more ideal world, we could check that requirement by just checking that\n+/// the given type implements both (1.) the `StructuralPartialEq` trait *and*\n+/// (2.) the `Eq` trait. However, you can have ADTs that *do* `derive(PartialEq, Eq)`,\n+/// and be a case that we want the compiler to accept, and yet the constant's\n+/// type fails to implement `Eq`.\n+///\n+/// Namely, a case like this:\n+///\n+/// ```rust\n+/// #[derive(PartialEq, Eq)]\n+/// struct Wrap<X>(X);\n+/// fn higher_order(_: &()) { }\n+/// const CFN: Wrap<fn(&())> = Wrap(higher_order);\n+/// fn main() {\n+///     match CFN {\n+///         CFN => {}\n+///         _ => {}\n+///     }\n+/// }\n+/// ```\n+///\n+/// (The problem in the above code is that `Wrap<fn(&())>` does not implement\n+/// `PartialEq`, nor `Eq`, because `for<'a> fn(&'a _)` does not implement those\n+/// traits.)\n+///\n+/// Therefore, we cannot rely on naive check for `StructuralPartialEq` and\n+/// mere `Eq`.\n+///\n+/// As a hack to work around this, we use two separate traits injected by each\n+/// of the two derives (`#[derive(PartialEq)]` and `#[derive(Eq)]`) and check\n+/// that both of them are present as part of structural-match checking.\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"structural_match\", issue = \"31434\")]\n+#[rustc_on_unimplemented(message=\"the type `{Self}` does not `#[derive(Eq)]`\")]\n+#[lang = \"structural_teq\"]\n+pub trait StructuralEq {\n+    // Empty.\n+}\n+\n /// Types whose values can be duplicated simply by copying bits.\n ///\n /// By default, variable bindings have 'move semantics.' In other\n@@ -437,6 +516,14 @@ macro_rules! impls{\n                 $t\n             }\n         }\n+\n+        #[cfg(not(bootstrap))]\n+        #[unstable(feature = \"structural_match\", issue = \"31434\")]\n+        impl<T: ?Sized> StructuralPartialEq for $t<T> { }\n+\n+        #[cfg(not(bootstrap))]\n+        #[unstable(feature = \"structural_match\", issue = \"31434\")]\n+        impl<T: ?Sized> StructuralEq for $t<T> { }\n         )\n }\n "}, {"sha": "0db79785282a3e986f3d75e83c5ba8e937321039", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -297,6 +297,10 @@ language_item_table! {\n \n     SizedTraitLangItem,          \"sized\",              sized_trait,             Target::Trait;\n     UnsizeTraitLangItem,         \"unsize\",             unsize_trait,            Target::Trait;\n+    // trait injected by #[derive(PartialEq)], (i.e. \"Partial EQ\").\n+    StructuralPeqTraitLangItem,  \"structural_peq\",     structural_peq_trait,    Target::Trait;\n+    // trait injected by #[derive(Eq)], (i.e. \"Total EQ\"; no, I will not apologize).\n+    StructuralTeqTraitLangItem,  \"structural_teq\",     structural_teq_trait,    Target::Trait;\n     CopyTraitLangItem,           \"copy\",               copy_trait,              Target::Trait;\n     CloneTraitLangItem,          \"clone\",              clone_trait,             Target::Trait;\n     SyncTraitLangItem,           \"sync\",               sync_trait,              Target::Trait;"}, {"sha": "e827ccf7d674199c2fe627cba0ec82a1ad43fd8e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -2151,6 +2151,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             ObligationCauseCode::ConstSized => {\n                 err.note(\"constant expressions must have a statically known size\");\n             }\n+            ObligationCauseCode::ConstPatternStructural => {\n+                err.note(\"constants used for pattern-matching must derive `PartialEq` and `Eq`\");\n+            }\n             ObligationCauseCode::SharedStatic => {\n                 err.note(\"shared static variables must have a type that implements `Sync`\");\n             }"}, {"sha": "134a8050d70f6e000a7f2ac5e5b51874dda1b677", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -239,6 +239,9 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Computing common supertype in the pattern guard for the arms of a match expression\n     MatchExpressionArmPattern { span: Span, ty: Ty<'tcx> },\n \n+    /// Constants in patterns must have `Structural` type.\n+    ConstPatternStructural,\n+\n     /// Computing common supertype in an if expression\n     IfExpression(Box<IfExpressionCause>),\n "}, {"sha": "e9411be6fc1f750738b9a4344668f651a91338c8", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -497,6 +497,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::RepeatVec => Some(super::RepeatVec),\n             super::FieldSized { adt_kind, last } => Some(super::FieldSized { adt_kind, last }),\n             super::ConstSized => Some(super::ConstSized),\n+            super::ConstPatternStructural => Some(super::ConstPatternStructural),\n             super::SharedStatic => Some(super::SharedStatic),\n             super::BuiltinDerivedObligation(ref cause) => {\n                 tcx.lift(cause).map(super::BuiltinDerivedObligation)"}, {"sha": "089443905dc53f293c34f7d0a1a0f8a5e955b0f6", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -84,7 +84,9 @@ pub use self::context::{\n \n pub use self::instance::{Instance, InstanceDef};\n \n-pub use self::structural_match::{search_for_structural_match_violation, NonStructuralMatchTy};\n+pub use self::structural_match::search_for_structural_match_violation;\n+pub use self::structural_match::type_marked_structural;\n+pub use self::structural_match::NonStructuralMatchTy;\n \n pub use self::trait_def::TraitDef;\n "}, {"sha": "86b047e2963a264078fb8a4d149dbdfd4399fc1c", "filename": "src/librustc/ty/structural_match.rs", "status": "modified", "additions": 138, "deletions": 76, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc%2Fty%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc%2Fty%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_match.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -1,11 +1,16 @@\n use crate::hir;\n+use rustc::infer::InferCtxt;\n+use rustc::traits::{self, ConstPatternStructural, TraitEngine};\n+use rustc::traits::ObligationCause;\n+\n use rustc_data_structures::fx::{FxHashSet};\n \n-use syntax::symbol::{sym};\n+use syntax_pos::Span;\n \n use crate::ty::{self, AdtDef, Ty, TyCtxt};\n use crate::ty::fold::{TypeFoldable, TypeVisitor};\n \n+#[derive(Debug)]\n pub enum NonStructuralMatchTy<'tcx> {\n     Adt(&'tcx AdtDef),\n     Param,\n@@ -37,95 +42,152 @@ pub enum NonStructuralMatchTy<'tcx> {\n /// that arose when the requirement was not enforced completely, see\n /// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n pub fn search_for_structural_match_violation<'tcx>(\n+    id: hir::HirId,\n+    span: Span,\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<NonStructuralMatchTy<'tcx>> {\n-    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n-    ty.visit_with(&mut search);\n-    return search.found;\n+    // FIXME: we should instead pass in an `infcx` from the outside.\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let mut search = Search { id, span, infcx, found: None, seen: FxHashSet::default() };\n+        ty.visit_with(&mut search);\n+        search.found\n+    })\n+}\n+\n+/// This method returns true if and only if `adt_ty` itself has been marked as\n+/// eligible for structural-match: namely, if it implements both\n+/// `StructuralPartialEq` and `StructuralEq` (which are respectively injected by\n+/// `#[derive(PartialEq)]` and `#[derive(Eq)]`).\n+///\n+/// Note that this does *not* recursively check if the substructure of `adt_ty`\n+/// implements the traits.\n+pub fn type_marked_structural(id: hir::HirId,\n+                              span: Span,\n+                              infcx: &InferCtxt<'_, 'tcx>,\n+                              adt_ty: Ty<'tcx>)\n+                              -> bool\n+{\n+    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+    let cause = ObligationCause::new(span, id, ConstPatternStructural);\n+    // require `#[derive(PartialEq)]`\n+    let structural_peq_def_id = infcx.tcx.lang_items().structural_peq_trait().unwrap();\n+    fulfillment_cx.register_bound(\n+        infcx, ty::ParamEnv::empty(), adt_ty, structural_peq_def_id, cause);\n+    // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n+    // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n+    let cause = ObligationCause::new(span, id, ConstPatternStructural);\n+    let structural_teq_def_id = infcx.tcx.lang_items().structural_teq_trait().unwrap();\n+    fulfillment_cx.register_bound(\n+        infcx, ty::ParamEnv::empty(), adt_ty, structural_teq_def_id, cause);\n+\n+    // We deliberately skip *reporting* fulfillment errors (via\n+    // `report_fulfillment_errors`), for two reasons:\n+    //\n+    // 1. The error messages would mention `std::marker::StructuralPartialEq`\n+    //    (a trait which is solely meant as an implementation detail\n+    //    for now), and\n+    //\n+    // 2. We are sometimes doing future-incompatibility lints for\n+    //    now, so we do not want unconditional errors here.\n+    fulfillment_cx.select_all_or_error(infcx).is_ok()\n+}\n+\n+struct Search<'a, 'tcx> {\n+    id: hir::HirId,\n+    span: Span,\n \n-    struct Search<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n+    infcx: InferCtxt<'a, 'tcx>,\n \n-        // Records the first ADT or type parameter we find without `#[structural_match`.\n-        found: Option<NonStructuralMatchTy<'tcx>>,\n+    // records the first ADT we find that does not implement `Structural`.\n+    found: Option<NonStructuralMatchTy<'tcx>>,\n \n-        // Tracks ADTs previously encountered during search, so that\n-        // we will not recurse on them again.\n-        seen: FxHashSet<hir::def_id::DefId>,\n+    // tracks ADT's previously encountered during search, so that\n+    // we will not recur on them again.\n+    seen: FxHashSet<hir::def_id::DefId>,\n+}\n+\n+impl Search<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n     }\n \n-    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n-        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-            debug!(\"Search visiting ty: {:?}\", ty);\n-\n-            let (adt_def, substs) = match ty.kind {\n-                ty::Adt(adt_def, substs) => (adt_def, substs),\n-                ty::Param(_) => {\n-                    self.found = Some(NonStructuralMatchTy::Param);\n-                    return true; // Stop visiting.\n-                }\n-                ty::RawPtr(..) => {\n-                    // `#[structural_match]` ignores substructure of\n-                    // `*const _`/`*mut _`, so skip super_visit_with\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::FnDef(..) | ty::FnPtr(..) => {\n-                    // types of formals and return in `fn(_) -> _` are also irrelevant\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::Array(_, n) if n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0)\n-                => {\n-                    // rust-lang/rust#62336: ignore type of contents\n-                    // for empty array.\n-                    return false;\n-                }\n-                _ => {\n-                    ty.super_visit_with(self);\n-                    return false;\n-                }\n-            };\n-\n-            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n-                self.found = Some(NonStructuralMatchTy::Adt(&adt_def));\n-                debug!(\"Search found adt_def: {:?}\", adt_def);\n+    fn type_marked_structural(&self, adt_ty: Ty<'tcx>) -> bool {\n+        type_marked_structural(self.id, self.span, &self.infcx, adt_ty)\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        debug!(\"Search visiting ty: {:?}\", ty);\n+\n+        let (adt_def, substs) = match ty.kind {\n+            ty::Adt(adt_def, substs) => (adt_def, substs),\n+            ty::Param(_) => {\n+                self.found = Some(NonStructuralMatchTy::Param);\n                 return true; // Stop visiting.\n             }\n-\n-            if !self.seen.insert(adt_def.did) {\n-                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n-                // let caller continue its search\n+            ty::RawPtr(..) => {\n+                // structural-match ignores substructure of\n+                // `*const _`/`*mut _`, so skip super_visit_with\n+                //\n+                // (But still tell caller to continue search.)\n                 return false;\n             }\n-\n-            // `#[structural_match]` does not care about the\n-            // instantiation of the generics in an ADT (it\n-            // instead looks directly at its fields outside\n-            // this match), so we skip super_visit_with.\n-            //\n-            // (Must not recur on substs for `PhantomData<T>` cf\n-            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n-            // want to skip substs when only uses of generic are\n-            // behind unsafe pointers `*const T`/`*mut T`.)\n-\n-            // even though we skip super_visit_with, we must recur on\n-            // fields of ADT.\n-            let tcx = self.tcx;\n-            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n-                if field_ty.visit_with(self) {\n-                    // found an ADT without `#[structural_match]`; halt visiting!\n-                    assert!(self.found.is_some());\n-                    return true;\n-                }\n+            ty::FnDef(..) | ty::FnPtr(..) => {\n+                // types of formals and return in `fn(_) -> _` are also irrelevant\n+                //\n+                // (But still tell caller to continue search.)\n+                return false;\n+            }\n+            ty::Array(_, n) if {\n+                n.try_eval_usize(self.tcx(), ty::ParamEnv::reveal_all()) == Some(0)\n+            } => {\n+                // rust-lang/rust#62336: ignore type of contents\n+                // for empty array.\n+                return false;\n             }\n+            _ => {\n+                ty.super_visit_with(self);\n+                return false;\n+            }\n+        };\n \n-            // Even though we do not want to recur on substs, we do\n-            // want our caller to continue its own search.\n-            false\n+        if !self.seen.insert(adt_def.did) {\n+            debug!(\"Search already seen adt_def: {:?}\", adt_def);\n+            // let caller continue its search\n+            return false;\n         }\n+\n+        if !self.type_marked_structural(ty) {\n+            debug!(\"Search found ty: {:?}\", ty);\n+            self.found = Some(NonStructuralMatchTy::Adt(&adt_def));\n+            return true; // Halt visiting!\n+        }\n+\n+        // structural-match does not care about the\n+        // instantiation of the generics in an ADT (it\n+        // instead looks directly at its fields outside\n+        // this match), so we skip super_visit_with.\n+        //\n+        // (Must not recur on substs for `PhantomData<T>` cf\n+        // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n+        // want to skip substs when only uses of generic are\n+        // behind unsafe pointers `*const T`/`*mut T`.)\n+\n+        // even though we skip super_visit_with, we must recur on\n+        // fields of ADT.\n+        let tcx = self.tcx();\n+        for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n+            if field_ty.visit_with(self) {\n+                // found an ADT without structural-match; halt visiting!\n+                assert!(self.found.is_some());\n+                return true;\n+            }\n+        }\n+\n+        // Even though we do not want to recur on substs, we do\n+        // want our caller to continue its own search.\n+        false\n     }\n }"}, {"sha": "bfc539639db1ec7ad7aeca51510be3f1d1503f84", "filename": "src/librustc_mir/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 139, "deletions": 73, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -3,14 +3,17 @@ use crate::const_eval::const_variant_index;\n use rustc::hir;\n use rustc::lint;\n use rustc::mir::Field;\n+use rustc::infer::InferCtxt;\n use rustc::traits::{ObligationCause, PredicateObligation};\n-use rustc::ty;\n+use rustc::ty::{self, Ty, TyCtxt};\n \n use rustc_index::vec::Idx;\n \n-use syntax::symbol::sym;\n use syntax_pos::Span;\n \n+\n+use std::cell::Cell;\n+\n use super::{FieldPat, Pat, PatCtxt, PatKind};\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n@@ -19,97 +22,148 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// to a pattern that matches the value (as if you'd compared via structural equality).\n     pub(super) fn const_to_pat(\n         &self,\n-        instance: ty::Instance<'tcx>,\n         cv: &'tcx ty::Const<'tcx>,\n         id: hir::HirId,\n         span: Span,\n     ) -> Pat<'tcx> {\n-        // This method is just a warpper handling a validity check; the heavy lifting is\n-        // performed by the recursive const_to_pat_inner method, which is not meant to be\n+        debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n+        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n+\n+        self.tcx.infer_ctxt().enter(|infcx| {\n+            let mut convert = ConstToPat::new(self, id, span, infcx);\n+            convert.to_pat(cv)\n+        })\n+    }\n+}\n+\n+struct ConstToPat<'a, 'tcx> {\n+    id: hir::HirId,\n+    span: Span,\n+    param_env: ty::ParamEnv<'tcx>,\n+\n+    // This tracks if we signal some hard error for a given const value, so that\n+    // we will not subsequently issue an irrelevant lint for the same const\n+    // value.\n+    saw_const_match_error: Cell<bool>,\n+\n+    // inference context used for checking `T: Structural` bounds.\n+    infcx: InferCtxt<'a, 'tcx>,\n+\n+    include_lint_checks: bool,\n+}\n+\n+impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n+    fn new(pat_ctxt: &PatCtxt<'_, 'tcx>,\n+                      id: hir::HirId,\n+                      span: Span,\n+                      infcx: InferCtxt<'a, 'tcx>) -> Self {\n+        ConstToPat {\n+            id, span, infcx,\n+            param_env: pat_ctxt.param_env,\n+            include_lint_checks: pat_ctxt.include_lint_checks,\n+            saw_const_match_error: Cell::new(false),\n+        }\n+    }\n+\n+    fn tcx(&self) -> TyCtxt<'tcx> { self.infcx.tcx }\n+\n+    fn search_for_structural_match_violation(&self,\n+                                             ty: Ty<'tcx>)\n+                                             -> Option<ty::NonStructuralMatchTy<'tcx>>\n+    {\n+        ty::search_for_structural_match_violation(self.id, self.span, self.tcx(), ty)\n+    }\n+\n+    fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {\n+        ty::type_marked_structural(self.id, self.span, &self.infcx, ty)\n+    }\n+\n+    fn to_pat(&mut self, cv: &'tcx ty::Const<'tcx>) -> Pat<'tcx> {\n+        // This method is just a wrapper handling a validity check; the heavy lifting is\n+        // performed by the recursive `recur` method, which is not meant to be\n         // invoked except by this method.\n         //\n         // once indirect_structural_match is a full fledged error, this\n         // level of indirection can be eliminated\n \n-        debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n-        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n+        let inlined_const_as_pat = self.recur(cv);\n+\n+        if self.include_lint_checks && !self.saw_const_match_error.get() {\n+            // If we were able to successfully convert the const to some pat,\n+            // double-check that all types in the const implement `Structural`.\n \n-        let mut saw_error = false;\n-        let inlined_const_as_pat = self.const_to_pat_inner(instance, cv, id, span, &mut saw_error);\n-\n-        if self.include_lint_checks && !saw_error {\n-            // If we were able to successfully convert the const to some pat, double-check\n-            // that the type of the const obeys `#[structural_match]` constraint.\n-            if let Some(non_sm_ty) = ty::search_for_structural_match_violation(self.tcx, cv.ty) {\n-                let msg = match non_sm_ty {\n-                    ty::NonStructuralMatchTy::Adt(adt_def) => {\n-                        let path = self.tcx.def_path_str(adt_def.did);\n-                        format!(\n-                            \"to use a constant of type `{}` in a pattern, \\\n-                             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                            path,\n-                            path,\n-                        )\n-                    }\n-                    ty::NonStructuralMatchTy::Param => {\n-                        bug!(\"use of constant whose type is a parameter inside a pattern\");\n-                    }\n+            let structural = self.search_for_structural_match_violation(cv.ty);\n+            debug!(\"search_for_structural_match_violation cv.ty: {:?} returned: {:?}\",\n+                   cv.ty, structural);\n+            if let Some(non_sm_ty) = structural {\n+                let adt_def = match non_sm_ty {\n+                    ty::NonStructuralMatchTy::Adt(adt_def) => adt_def,\n+                    ty::NonStructuralMatchTy::Param =>\n+                        bug!(\"use of constant whose type is a parameter inside a pattern\"),\n                 };\n+                let path = self.tcx().def_path_str(adt_def.did);\n+                let msg = format!(\n+                    \"to use a constant of type `{}` in a pattern, \\\n+                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                    path,\n+                    path,\n+                );\n \n-                // before issuing lint, double-check there even *is* a\n-                // semantic PartialEq for us to dispatch to.\n+                // double-check there even *is* a semantic `PartialEq` to dispatch to.\n                 //\n                 // (If there isn't, then we can safely issue a hard\n                 // error, because that's never worked, due to compiler\n-                // using PartialEq::eq in this scenario in the past.)\n-\n+                // using `PartialEq::eq` in this scenario in the past.)\n+                //\n+                // Note: To fix rust-lang/rust#65466, one could lift this check\n+                // *before* any structural-match checking, and unconditionally error\n+                // if `PartialEq` is not implemented. However, that breaks stable\n+                // code at the moment, because types like `for <'a> fn(&'a ())` do\n+                // not *yet* implement `PartialEq`. So for now we leave this here.\n                 let ty_is_partial_eq: bool = {\n-                    let partial_eq_trait_id = self.tcx.lang_items().eq_trait().unwrap();\n+                    let partial_eq_trait_id = self.tcx().lang_items().eq_trait().unwrap();\n                     let obligation: PredicateObligation<'_> =\n-                        self.tcx.predicate_for_trait_def(self.param_env,\n-                                                         ObligationCause::misc(span, id),\n-                                                         partial_eq_trait_id,\n-                                                         0,\n-                                                         cv.ty,\n-                                                         &[]);\n-                    self.tcx\n-                        .infer_ctxt()\n-                        .enter(|infcx| infcx.predicate_may_hold(&obligation))\n+                        self.tcx().predicate_for_trait_def(\n+                            self.param_env,\n+                            ObligationCause::misc(self.span, self.id),\n+                            partial_eq_trait_id,\n+                            0,\n+                            cv.ty,\n+                            &[]);\n+                    // FIXME: should this call a `predicate_must_hold` variant instead?\n+                    self.infcx.predicate_may_hold(&obligation)\n                 };\n \n                 if !ty_is_partial_eq {\n                     // span_fatal avoids ICE from resolution of non-existent method (rare case).\n-                    self.tcx.sess.span_fatal(span, &msg);\n+                    self.tcx().sess.span_fatal(self.span, &msg);\n                 } else {\n-                    self.tcx.lint_hir(lint::builtin::INDIRECT_STRUCTURAL_MATCH, id, span, &msg);\n+                    self.tcx().lint_hir(lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n+                                        self.id,\n+                                        self.span,\n+                                        &msg);\n                 }\n             }\n         }\n \n         inlined_const_as_pat\n     }\n \n-    /// Recursive helper for `const_to_pat`; invoke that (instead of calling this directly).\n-    fn const_to_pat_inner(\n-        &self,\n-        instance: ty::Instance<'tcx>,\n-        cv: &'tcx ty::Const<'tcx>,\n-        id: hir::HirId,\n-        span: Span,\n-        // This tracks if we signal some hard error for a given const\n-        // value, so that we will not subsequently issue an irrelevant\n-        // lint for the same const value.\n-        saw_const_match_error: &mut bool,\n-    ) -> Pat<'tcx> {\n+    // Recursive helper for `to_pat`; invoke that (instead of calling this directly).\n+    fn recur(&self, cv: &'tcx ty::Const<'tcx>) -> Pat<'tcx> {\n+        let id = self.id;\n+        let span = self.span;\n+        let tcx = self.tcx();\n+        let param_env = self.param_env;\n \n-        let mut adt_subpattern = |i, variant_opt| {\n+        let adt_subpattern = |i, variant_opt| {\n             let field = Field::new(i);\n             let val = crate::const_eval::const_field(\n-                self.tcx, self.param_env, variant_opt, field, cv\n+                tcx, param_env, variant_opt, field, cv\n             );\n-            self.const_to_pat_inner(instance, val, id, span, saw_const_match_error)\n+            self.recur(val)\n         };\n-        let mut adt_subpatterns = |n, variant_opt| {\n+        let adt_subpatterns = |n, variant_opt| {\n             (0..n).map(|i| {\n                 let field = Field::new(i);\n                 FieldPat {\n@@ -122,7 +176,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n         let kind = match cv.ty.kind {\n             ty::Float(_) => {\n-                self.tcx.lint_hir(\n+                tcx.lint_hir(\n                     ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                     id,\n                     span,\n@@ -134,41 +188,53 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n-                *saw_const_match_error = true;\n-                self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n+                self.saw_const_match_error.set(true);\n+                tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n                 PatKind::Wild\n             }\n             // keep old code until future-compat upgraded to errors.\n-            ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n-                let path = self.tcx.def_path_str(adt_def.did);\n+            ty::Adt(adt_def, _) if !self.type_marked_structural(cv.ty) => {\n+                debug!(\"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\",\n+                       adt_def, cv.ty);\n+                let path = tcx.def_path_str(adt_def.did);\n                 let msg = format!(\n                     \"to use a constant of type `{}` in a pattern, \\\n                      `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n                     path,\n                     path,\n                 );\n-                *saw_const_match_error = true;\n-                self.tcx.sess.span_err(span, &msg);\n+                self.saw_const_match_error.set(true);\n+                tcx.sess.span_err(span, &msg);\n                 PatKind::Wild\n             }\n             // keep old code until future-compat upgraded to errors.\n-            ty::Ref(_, ty::TyS { kind: ty::Adt(adt_def, _), .. }, _)\n-            if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n+            ty::Ref(_, adt_ty @ ty::TyS { kind: ty::Adt(_, _), .. }, _)\n+                if !self.type_marked_structural(adt_ty) =>\n+            {\n+                let adt_def = if let ty::Adt(adt_def, _) = adt_ty.kind {\n+                    adt_def\n+                } else {\n+                    unreachable!()\n+                };\n+\n+                debug!(\"adt_def {:?} has !type_marked_structural for adt_ty: {:?}\",\n+                       adt_def, adt_ty);\n+\n                 // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n                 // would be wrong. Returnging `PatKind::Wild` is not technically correct.\n-                let path = self.tcx.def_path_str(adt_def.did);\n+                let path = tcx.def_path_str(adt_def.did);\n                 let msg = format!(\n                     \"to use a constant of type `{}` in a pattern, \\\n                      `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n                     path,\n                     path,\n                 );\n-                *saw_const_match_error = true;\n-                self.tcx.sess.span_err(span, &msg);\n+                self.saw_const_match_error.set(true);\n+                tcx.sess.span_err(span, &msg);\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n-                let variant_index = const_variant_index(self.tcx, self.param_env, cv);\n+                let variant_index = const_variant_index(tcx, self.param_env, cv);\n                 let subpatterns = adt_subpatterns(\n                     adt_def.variants[variant_index].fields.len(),\n                     Some(variant_index),\n@@ -193,7 +259,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n             ty::Array(_, n) => {\n                 PatKind::Array {\n-                    prefix: (0..n.eval_usize(self.tcx, self.param_env))\n+                    prefix: (0..n.eval_usize(tcx, self.param_env))\n                         .map(|i| adt_subpattern(i as usize, None))\n                         .collect(),\n                     slice: None,"}, {"sha": "1ecc78ba227ceb487afda3c15b26ec7344664904", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -863,7 +863,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                         };\n                         match self.tcx.at(span).const_eval(self.param_env.and(cid)) {\n                             Ok(value) => {\n-                                let pattern = self.const_to_pat(instance, value, id, span);\n+                                let pattern = self.const_to_pat(value, id, span);\n                                 if !is_associated_const {\n                                     return pattern;\n                                 }\n@@ -930,11 +930,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let ty = self.tables.expr_ty(expr);\n                 match lit_to_const(&lit.node, self.tcx, ty, false) {\n                     Ok(val) => {\n-                        let instance = ty::Instance::new(\n-                            self.tables.local_id_root.expect(\"literal outside any scope\"),\n-                            self.substs,\n-                        );\n-                        *self.const_to_pat(instance, val, expr.hir_id, lit.span).kind\n+                        *self.const_to_pat(val, expr.hir_id, lit.span).kind\n                     },\n                     Err(LitToConstError::UnparseableFloat) => {\n                         self.errors.push(PatternError::FloatBug);\n@@ -952,11 +948,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 };\n                 match lit_to_const(&lit.node, self.tcx, ty, true) {\n                     Ok(val) => {\n-                        let instance = ty::Instance::new(\n-                            self.tables.local_id_root.expect(\"literal outside any scope\"),\n-                            self.substs,\n-                        );\n-                        *self.const_to_pat(instance, val, expr.hir_id, lit.span).kind\n+                        *self.const_to_pat(val, expr.hir_id, lit.span).kind\n                     },\n                     Err(LitToConstError::UnparseableFloat) => {\n                         self.errors.push(PatternError::FloatBug);"}, {"sha": "2395cb7495df4c49e24f632fdab22eecb664d100", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -1532,7 +1532,9 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                         );\n                     };\n                 }\n-                if ty::search_for_structural_match_violation(tcx, ty).is_some() {\n+                if ty::search_for_structural_match_violation(\n+                    param.hir_id, param.span, tcx, ty).is_some()\n+                {\n                     struct_span_err!(\n                         tcx.sess,\n                         hir_ty.span,"}, {"sha": "162aaedafea325c9fd04eda006887657375c0894", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -42,6 +42,12 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt<'_>,\n                       }],\n         associated_types: Vec::new(),\n     };\n+\n+    super::inject_impl_of_structural_trait(\n+        cx, span, item,\n+        path_std!(cx, marker::StructuralEq),\n+        push);\n+\n     trait_def.expand_ext(cx, mitem, item, push, true)\n }\n "}, {"sha": "c3e2b78bbe506ccf27c211c95a62e12a355168e7", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -6,7 +6,7 @@ use syntax::ast::{BinOpKind, Expr, MetaItem};\n use syntax_expand::base::{Annotatable, ExtCtxt, SpecialDerives};\n use syntax::ptr::P;\n use syntax::symbol::sym;\n-use syntax_pos::Span;\n+use syntax_pos::{self, Span};\n \n pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n                                   span: Span,\n@@ -81,6 +81,11 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n         } }\n     }\n \n+    super::inject_impl_of_structural_trait(\n+        cx, span, item,\n+        path_std!(cx, marker::StructuralPartialEq),\n+        push);\n+\n     // avoid defining `ne` if we can\n     // c-like enums, enums without any fields and structs without fields\n     // can safely define only `eq`."}, {"sha": "a98cce1fd61c14deb6a4a60096b5e810516fd61e", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -1,6 +1,6 @@\n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n-use syntax::ast::{self, MetaItem};\n+use syntax::ast::{self, ItemKind, MetaItem};\n use syntax_expand::base::{Annotatable, ExtCtxt, MultiItemModifier};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, sym};\n@@ -74,3 +74,85 @@ fn call_intrinsic(cx: &ExtCtxt<'_>,\n         span,\n     }))\n }\n+\n+\n+// Injects `impl<...> Structural for ItemType<...> { }`. In particular,\n+// does *not* add `where T: Structural` for parameters `T` in `...`.\n+// (That's the main reason we cannot use TraitDef here.)\n+fn inject_impl_of_structural_trait(cx: &mut ExtCtxt<'_>,\n+                                   span: Span,\n+                                   item: &Annotatable,\n+                                   structural_path: generic::ty::Path<'_>,\n+                                   push: &mut dyn FnMut(Annotatable)) {\n+    let item = match *item {\n+        Annotatable::Item(ref item) => item,\n+        _ => {\n+            // Non-Item derive is an error, but it should have been\n+            // set earlier; see\n+            // libsyntax/ext/expand.rs:MacroExpander::expand()\n+            return;\n+        }\n+    };\n+\n+    let generics = match item.kind {\n+        ItemKind::Struct(_, ref generics) |\n+        ItemKind::Enum(_, ref generics) => generics,\n+        // Do not inject `impl Structural for Union`. (`PartialEq` does not\n+        // support unions, so we will see error downstream.)\n+        ItemKind::Union(..) => return,\n+        _ => unreachable!(),\n+    };\n+\n+    // Create generics param list for where clauses and impl headers\n+    let mut generics = generics.clone();\n+\n+    // Create the type of `self`.\n+    //\n+    // in addition, remove defaults from type params (impls cannot have them).\n+    let self_params: Vec<_> = generics.params.iter_mut().map(|param| match &mut param.kind {\n+        ast::GenericParamKind::Lifetime => {\n+            ast::GenericArg::Lifetime(cx.lifetime(span, param.ident))\n+        }\n+        ast::GenericParamKind::Type { default } => {\n+            *default = None;\n+            ast::GenericArg::Type(cx.ty_ident(span, param.ident))\n+        }\n+        ast::GenericParamKind::Const { ty: _ } => {\n+            ast::GenericArg::Const(cx.const_ident(span, param.ident))\n+        }\n+    }).collect();\n+\n+    let type_ident = item.ident;\n+\n+    let trait_ref = cx.trait_ref(structural_path.to_path(cx, span, type_ident, &generics));\n+    let self_type = cx.ty_path(cx.path_all(span, false, vec![type_ident], self_params));\n+\n+    // It would be nice to also encode constraint `where Self: Eq` (by adding it\n+    // onto `generics` cloned above). Unfortunately, that strategy runs afoul of\n+    // rust-lang/rust#48214. So we perform that additional check in the compiler\n+    // itself, instead of encoding it here.\n+\n+    // Keep the lint and stability attributes of the original item, to control\n+    // how the generated implementation is linted.\n+    let mut attrs = Vec::new();\n+    attrs.extend(item.attrs\n+                 .iter()\n+                 .filter(|a| {\n+                     [sym::allow, sym::warn, sym::deny, sym::forbid, sym::stable, sym::unstable]\n+                         .contains(&a.name_or_empty())\n+                 })\n+                 .cloned());\n+\n+    let newitem = cx.item(span,\n+                          ast::Ident::invalid(),\n+                          attrs,\n+                          ItemKind::Impl(ast::Unsafety::Normal,\n+                                         ast::ImplPolarity::Positive,\n+                                         ast::Defaultness::Final,\n+                                         generics,\n+                                         Some(trait_ref),\n+                                         self_type,\n+                                         Vec::new()));\n+\n+    push(Annotatable::Item(newitem));\n+}"}, {"sha": "42b81cd43000f446754f271532457dc8e2e1c7ed", "filename": "src/test/ui/rfc1445/feature-gate.no_gate.stderr", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.no_gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.no_gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.no_gate.stderr?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -1,12 +1,21 @@\n-error[E0658]: the semantics of constant patterns is not yet settled\n-  --> $DIR/feature-gate.rs:13:1\n+error[E0658]: use of unstable library feature 'structural_match'\n+  --> $DIR/feature-gate.rs:29:6\n    |\n-LL | #[structural_match]\n-   | ^^^^^^^^^^^^^^^^^^^\n+LL | impl std::marker::StructuralPartialEq for Foo { }\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/31434\n    = help: add `#![feature(structural_match)]` to the crate attributes to enable\n \n-error: aborting due to previous error\n+error[E0658]: use of unstable library feature 'structural_match'\n+  --> $DIR/feature-gate.rs:31:6\n+   |\n+LL | impl std::marker::StructuralEq for Foo { }\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/31434\n+   = help: add `#![feature(structural_match)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "38d6406efa50d2a6199e1ad7548daf36f48a5164", "filename": "src/test/ui/rfc1445/feature-gate.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5b11b6b7a1e2a424165aa629752862a5924b0/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.rs?ref=98f5b11b6b7a1e2a424165aa629752862a5924b0", "patch": "@@ -10,7 +10,7 @@\n #![feature(rustc_attrs)]\n #![cfg_attr(with_gate, feature(structural_match))]\n \n-#[structural_match] //[no_gate]~ ERROR semantics of constant patterns is not yet settled\n+\n struct Foo {\n     x: u32\n }\n@@ -25,3 +25,15 @@ fn main() { //[with_gate]~ ERROR compilation successful\n         _ => { }\n     }\n }\n+\n+impl std::marker::StructuralPartialEq for Foo { }\n+//[no_gate]~^ ERROR use of unstable library feature 'structural_match'\n+impl std::marker::StructuralEq for Foo { }\n+//[no_gate]~^ ERROR use of unstable library feature 'structural_match'\n+\n+impl PartialEq<Foo> for Foo {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.x == other.x\n+    }\n+}\n+impl Eq for Foo { }"}]}