{"sha": "84086c464f537591f0e4629676b3fc75517492ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0MDg2YzQ2NGY1Mzc1OTFmMGU0NjI5Njc2YjNmYzc1NTE3NDkyYWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-18T07:02:47Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-19T16:58:10Z"}, "message": "Register new snapshots\n\nThis does not yet start the movement to rustc-serialize. That detail is left to\na future PR.", "tree": {"sha": "7226ef61282962ff5be4772db3b1e849d6ba5cbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7226ef61282962ff5be4772db3b1e849d6ba5cbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84086c464f537591f0e4629676b3fc75517492ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84086c464f537591f0e4629676b3fc75517492ab", "html_url": "https://github.com/rust-lang/rust/commit/84086c464f537591f0e4629676b3fc75517492ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84086c464f537591f0e4629676b3fc75517492ab/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "html_url": "https://github.com/rust-lang/rust/commit/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05"}], "stats": {"total": 844, "additions": 9, "deletions": 835}, "files": [{"sha": "ef7b3fbf5996deb7b38bb96d04868ab4a45ebdd2", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=84086c464f537591f0e4629676b3fc75517492ab", "patch": "@@ -448,30 +448,6 @@ impl<T: Ord> Default for BTreeSet<T> {\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> Sub<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n-    /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let a: BTreeSet<int> = vec![1,2,3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![3,4,5].into_iter().collect();\n-    ///\n-    /// let result: BTreeSet<int> = a - b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1,2]);\n-    /// ```\n-    fn sub(&self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        self.difference(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -493,30 +469,6 @@ impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> BitXor<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n-    /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let a: BTreeSet<int> = vec![1,2,3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![2,3,4].into_iter().collect();\n-    ///\n-    /// let result: BTreeSet<int> = a ^ b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1,4]);\n-    /// ```\n-    fn bitxor(&self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        self.symmetric_difference(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -538,30 +490,6 @@ impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeS\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> BitAnd<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n-    /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let a: BTreeSet<int> = vec![1,2,3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![2,3,4].into_iter().collect();\n-    ///\n-    /// let result: BTreeSet<int> = a & b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![2,3]);\n-    /// ```\n-    fn bitand(&self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        self.intersection(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -583,30 +511,6 @@ impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeS\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> BitOr<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n-    /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let a: BTreeSet<int> = vec![1,2,3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![3,4,5].into_iter().collect();\n-    ///\n-    /// let result: BTreeSet<int> = a | b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1,2,3,4,5]);\n-    /// ```\n-    fn bitor(&self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        self.union(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///"}, {"sha": "554d642c638c8c5166e804ab98bc93bc83ff3733", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=84086c464f537591f0e4629676b3fc75517492ab", "patch": "@@ -183,60 +183,24 @@ impl<E:CLike> EnumSet<E> {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<E:CLike> Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn sub(&self, e: &EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & !e.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<E:CLike> Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn sub(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & !e.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<E:CLike> BitOr<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn bitor(&self, e: &EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits | e.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<E:CLike> BitOr<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn bitor(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits | e.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn bitand(&self, e: &EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & e.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn bitand(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & e.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<E:CLike> BitXor<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn bitxor(&self, e: &EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits ^ e.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<E:CLike> BitXor<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits ^ e.bits}"}, {"sha": "b897f9b8df3bf61597813a2197b4083f51f338bb", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=84086c464f537591f0e4629676b3fc75517492ab", "patch": "@@ -856,36 +856,14 @@ impl<'a, S: Str> Equiv<S> for String {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n #[experimental = \"waiting on Add stabilization\"]\n-impl<S: Str> Add<S, String> for String {\n-    /// Concatenates `self` and `other` as a new mutable `String`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let string1 = \"foo\".to_string();\n-    /// let string2 = \"bar\".to_string();\n-    /// let string3 = string1 + string2;\n-    /// assert_eq!(string3, \"foobar\".to_string());\n-    /// ```\n-    fn add(&self, other: &S) -> String {\n-        let mut s = String::from_str(self.as_slice());\n-        s.push_str(other.as_slice());\n-        return s;\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a> Add<&'a str, String> for String {\n     fn add(mut self, other: &str) -> String {\n         self.push_str(other);\n         self\n     }\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a> Add<String, String> for &'a str {\n     fn add(self, mut other: String) -> String {\n         other.push_str(self);"}, {"sha": "ffb4955c8fdec27cb26716b708b8545a396a0c08", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=84086c464f537591f0e4629676b3fc75517492ab", "patch": "@@ -1313,20 +1313,6 @@ impl<T> AsSlice<T> for Vec<T> {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Clone, Sized? V: AsSlice<T>> Add<V, Vec<T>> for Vec<T> {\n-    #[inline]\n-    fn add(&self, rhs: &V) -> Vec<T> {\n-        let mut res = Vec::with_capacity(self.len() + rhs.as_slice().len());\n-        res.push_all(self.as_slice());\n-        res.push_all(rhs.as_slice());\n-        res\n-    }\n-}\n-\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove impl after a snapshot\n impl<'a, T: Clone> Add<&'a [T], Vec<T>> for Vec<T> {\n     #[inline]\n     fn add(mut self, rhs: &[T]) -> Vec<T> {\n@@ -1335,7 +1321,6 @@ impl<'a, T: Clone> Add<&'a [T], Vec<T>> for Vec<T> {\n     }\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove impl after a snapshot\n impl<'a, T: Clone> Add<Vec<T>, Vec<T>> for &'a [T] {\n     #[inline]\n     fn add(self, mut rhs: Vec<T>) -> Vec<T> {"}, {"sha": "dd5cffeab03ef6e42878d69e724e68acf27d4977", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 437, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=84086c464f537591f0e4629676b3fc75517492ab", "patch": "@@ -93,46 +93,6 @@ pub trait Drop {\n /// impl Copy for Foo {}\n ///\n /// impl Add<Foo, Foo> for Foo {\n-///     fn add(&self, _rhs: &Foo) -> Foo {\n-///       println!(\"Adding!\");\n-///       *self\n-///   }\n-/// }\n-///\n-/// fn main() {\n-///   Foo + Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"add\"]\n-pub trait Add<Sized? RHS,Result> for Sized? {\n-    /// The method for the `+` operator\n-    fn add(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! add_impl {\n-    ($($t:ty)*) => ($(\n-        impl Add<$t, $t> for $t {\n-            #[inline]\n-            fn add(&self, other: &$t) -> $t { (*self) + (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Add` trait is used to specify the functionality of `+`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Add`. When `Foo + Foo` happens, it ends up\n-/// calling `add`, and therefore, `main` prints `Adding!`.\n-///\n-/// ```rust\n-/// struct Foo;\n-///\n-/// impl Add<Foo, Foo> for Foo {\n ///     fn add(self, _rhs: Foo) -> Foo {\n ///       println!(\"Adding!\");\n ///       self\n@@ -143,14 +103,12 @@ macro_rules! add_impl {\n ///   Foo + Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"add\"]\n pub trait Add<RHS, Result> {\n     /// The method for the `+` operator\n     fn add(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n         impl Add<$t, $t> for $t {\n@@ -175,46 +133,6 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// impl Copy for Foo {}\n ///\n /// impl Sub<Foo, Foo> for Foo {\n-///     fn sub(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Subtracting!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo - Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"sub\"]\n-pub trait Sub<Sized? RHS, Result> for Sized? {\n-    /// The method for the `-` operator\n-    fn sub(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! sub_impl {\n-    ($($t:ty)*) => ($(\n-        impl Sub<$t, $t> for $t {\n-            #[inline]\n-            fn sub(&self, other: &$t) -> $t { (*self) - (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Sub` trait is used to specify the functionality of `-`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Sub`. When `Foo - Foo` happens, it ends up\n-/// calling `sub`, and therefore, `main` prints `Subtracting!`.\n-///\n-/// ```rust\n-/// struct Foo;\n-///\n-/// impl Sub<Foo, Foo> for Foo {\n ///     fn sub(self, _rhs: Foo) -> Foo {\n ///         println!(\"Subtracting!\");\n ///         self\n@@ -225,14 +143,12 @@ macro_rules! sub_impl {\n ///     Foo - Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"sub\"]\n pub trait Sub<RHS, Result> {\n     /// The method for the `-` operator\n     fn sub(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n         impl Sub<$t, $t> for $t {\n@@ -257,46 +173,6 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// impl Copy for Foo {}\n ///\n /// impl Mul<Foo, Foo> for Foo {\n-///     fn mul(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Multiplying!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo * Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"mul\"]\n-pub trait Mul<Sized? RHS, Result>  for Sized? {\n-    /// The method for the `*` operator\n-    fn mul(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! mul_impl {\n-    ($($t:ty)*) => ($(\n-        impl Mul<$t, $t> for $t {\n-            #[inline]\n-            fn mul(&self, other: &$t) -> $t { (*self) * (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Mul` trait is used to specify the functionality of `*`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Mul`. When `Foo * Foo` happens, it ends up\n-/// calling `mul`, and therefore, `main` prints `Multiplying!`.\n-///\n-/// ```rust\n-/// struct Foo;\n-///\n-/// impl Mul<Foo, Foo> for Foo {\n ///     fn mul(self, _rhs: Foo) -> Foo {\n ///         println!(\"Multiplying!\");\n ///         self\n@@ -307,14 +183,12 @@ macro_rules! mul_impl {\n ///     Foo * Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"mul\"]\n pub trait Mul<RHS, Result> {\n     /// The method for the `*` operator\n     fn mul(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n         impl Mul<$t, $t> for $t {\n@@ -339,46 +213,6 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// impl Copy for Foo {}\n ///\n /// impl Div<Foo, Foo> for Foo {\n-///     fn div(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Dividing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo / Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"div\"]\n-pub trait Div<Sized? RHS, Result> for Sized? {\n-    /// The method for the `/` operator\n-    fn div(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! div_impl {\n-    ($($t:ty)*) => ($(\n-        impl Div<$t, $t> for $t {\n-            #[inline]\n-            fn div(&self, other: &$t) -> $t { (*self) / (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Div` trait is used to specify the functionality of `/`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Div`. When `Foo / Foo` happens, it ends up\n-/// calling `div`, and therefore, `main` prints `Dividing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl Div<Foo, Foo> for Foo {\n ///     fn div(self, _rhs: Foo) -> Foo {\n ///         println!(\"Dividing!\");\n ///         self\n@@ -389,14 +223,12 @@ macro_rules! div_impl {\n ///     Foo / Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"div\"]\n pub trait Div<RHS, Result> {\n     /// The method for the `/` operator\n     fn div(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! div_impl {\n     ($($t:ty)*) => ($(\n         impl Div<$t, $t> for $t {\n@@ -421,60 +253,6 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// impl Copy for Foo {}\n ///\n /// impl Rem<Foo, Foo> for Foo {\n-///     fn rem(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Remainder-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo % Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"rem\"]\n-pub trait Rem<Sized? RHS, Result>  for Sized? {\n-    /// The method for the `%` operator\n-    fn rem(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! rem_impl {\n-    ($($t:ty)*) => ($(\n-        impl Rem<$t, $t> for $t {\n-            #[inline]\n-            fn rem(&self, other: &$t) -> $t { (*self) % (*other) }\n-        }\n-    )*)\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! rem_float_impl {\n-    ($t:ty, $fmod:ident) => {\n-        impl Rem<$t, $t> for $t {\n-            #[inline]\n-            fn rem(&self, other: &$t) -> $t {\n-                extern { fn $fmod(a: $t, b: $t) -> $t; }\n-                unsafe { $fmod(*self, *other) }\n-            }\n-        }\n-    }\n-}\n-\n-/// The `Rem` trait is used to specify the functionality of `%`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Rem`. When `Foo % Foo` happens, it ends up\n-/// calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl Rem<Foo, Foo> for Foo {\n ///     fn rem(self, _rhs: Foo) -> Foo {\n ///         println!(\"Remainder-ing!\");\n ///         self\n@@ -485,14 +263,12 @@ macro_rules! rem_float_impl {\n ///     Foo % Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"rem\"]\n pub trait Rem<RHS, Result> {\n     /// The method for the `%` operator\n     fn rem(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n         impl Rem<$t, $t> for $t {\n@@ -502,7 +278,6 @@ macro_rules! rem_impl {\n     )*)\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! rem_float_impl {\n     ($t:ty, $fmod:ident) => {\n         impl Rem<$t, $t> for $t {\n@@ -729,46 +504,6 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// impl Copy for Foo {}\n ///\n /// impl BitAnd<Foo, Foo> for Foo {\n-///     fn bitand(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Bitwise And-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo & Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"bitand\"]\n-pub trait BitAnd<Sized? RHS, Result> for Sized? {\n-    /// The method for the `&` operator\n-    fn bitand(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! bitand_impl {\n-    ($($t:ty)*) => ($(\n-        impl BitAnd<$t, $t> for $t {\n-            #[inline]\n-            fn bitand(&self, rhs: &$t) -> $t { (*self) & (*rhs) }\n-        }\n-    )*)\n-}\n-\n-/// The `BitAnd` trait is used to specify the functionality of `&`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `BitAnd`. When `Foo & Foo` happens, it ends up\n-/// calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl BitAnd<Foo, Foo> for Foo {\n ///     fn bitand(self, _rhs: Foo) -> Foo {\n ///         println!(\"Bitwise And-ing!\");\n ///         self\n@@ -779,14 +514,12 @@ macro_rules! bitand_impl {\n ///     Foo & Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"bitand\"]\n pub trait BitAnd<RHS, Result> {\n     /// The method for the `&` operator\n     fn bitand(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n         impl BitAnd<$t, $t> for $t {\n@@ -811,46 +544,6 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// impl Copy for Foo {}\n ///\n /// impl BitOr<Foo, Foo> for Foo {\n-///     fn bitor(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Bitwise Or-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo | Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"bitor\"]\n-pub trait BitOr<Sized? RHS, Result> for Sized? {\n-    /// The method for the `|` operator\n-    fn bitor(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! bitor_impl {\n-    ($($t:ty)*) => ($(\n-        impl BitOr<$t,$t> for $t {\n-            #[inline]\n-            fn bitor(&self, rhs: &$t) -> $t { (*self) | (*rhs) }\n-        }\n-    )*)\n-}\n-\n-/// The `BitOr` trait is used to specify the functionality of `|`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `BitOr`. When `Foo | Foo` happens, it ends up\n-/// calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl BitOr<Foo, Foo> for Foo {\n ///     fn bitor(self, _rhs: Foo) -> Foo {\n ///         println!(\"Bitwise Or-ing!\");\n ///         self\n@@ -861,14 +554,12 @@ macro_rules! bitor_impl {\n ///     Foo | Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"bitor\"]\n pub trait BitOr<RHS, Result> {\n     /// The method for the `|` operator\n     fn bitor(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n         impl BitOr<$t,$t> for $t {\n@@ -893,46 +584,6 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// impl Copy for Foo {}\n ///\n /// impl BitXor<Foo, Foo> for Foo {\n-///     fn bitxor(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Bitwise Xor-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo ^ Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"bitxor\"]\n-pub trait BitXor<Sized? RHS, Result> for Sized? {\n-    /// The method for the `^` operator\n-    fn bitxor(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! bitxor_impl {\n-    ($($t:ty)*) => ($(\n-        impl BitXor<$t, $t> for $t {\n-            #[inline]\n-            fn bitxor(&self, other: &$t) -> $t { (*self) ^ (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `BitXor` trait is used to specify the functionality of `^`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `BitXor`. When `Foo ^ Foo` happens, it ends up\n-/// calling `bitxor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl BitXor<Foo, Foo> for Foo {\n ///     fn bitxor(self, _rhs: Foo) -> Foo {\n ///         println!(\"Bitwise Xor-ing!\");\n ///         self\n@@ -943,14 +594,12 @@ macro_rules! bitxor_impl {\n ///     Foo ^ Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"bitxor\"]\n pub trait BitXor<RHS, Result> {\n     /// The method for the `^` operator\n     fn bitxor(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n         impl BitXor<$t, $t> for $t {\n@@ -975,48 +624,6 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// impl Copy for Foo {}\n ///\n /// impl Shl<Foo, Foo> for Foo {\n-///     fn shl(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Shifting left!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo << Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"shl\"]\n-pub trait Shl<Sized? RHS, Result> for Sized? {\n-    /// The method for the `<<` operator\n-    fn shl(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! shl_impl {\n-    ($($t:ty)*) => ($(\n-        impl Shl<uint, $t> for $t {\n-            #[inline]\n-            fn shl(&self, other: &uint) -> $t {\n-                (*self) << (*other)\n-            }\n-        }\n-    )*)\n-}\n-\n-/// The `Shl` trait is used to specify the functionality of `<<`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Shl`. When `Foo << Foo` happens, it ends up\n-/// calling `shl`, and therefore, `main` prints `Shifting left!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl Shl<Foo, Foo> for Foo {\n ///     fn shl(self, _rhs: Foo) -> Foo {\n ///         println!(\"Shifting left!\");\n ///         self\n@@ -1027,14 +634,12 @@ macro_rules! shl_impl {\n ///     Foo << Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"shl\"]\n pub trait Shl<RHS, Result> {\n     /// The method for the `<<` operator\n     fn shl(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! shl_impl {\n     ($($t:ty)*) => ($(\n         impl Shl<uint, $t> for $t {\n@@ -1061,46 +666,6 @@ shl_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// impl Copy for Foo {}\n ///\n /// impl Shr<Foo, Foo> for Foo {\n-///     fn shr(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Shifting right!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo >> Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"shr\"]\n-pub trait Shr<Sized? RHS, Result> for Sized? {\n-    /// The method for the `>>` operator\n-    fn shr(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! shr_impl {\n-    ($($t:ty)*) => ($(\n-        impl Shr<uint, $t> for $t {\n-            #[inline]\n-            fn shr(&self, other: &uint) -> $t { (*self) >> (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Shr` trait is used to specify the functionality of `>>`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Shr`. When `Foo >> Foo` happens, it ends up\n-/// calling `shr`, and therefore, `main` prints `Shifting right!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl Shr<Foo, Foo> for Foo {\n ///     fn shr(self, _rhs: Foo) -> Foo {\n ///         println!(\"Shifting right!\");\n ///         self\n@@ -1111,14 +676,12 @@ macro_rules! shr_impl {\n ///     Foo >> Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"shr\"]\n pub trait Shr<RHS, Result> {\n     /// The method for the `>>` operator\n     fn shr(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! shr_impl {\n     ($($t:ty)*) => ($(\n         impl Shr<uint, $t> for $t {"}, {"sha": "ab3a959d9a79eef5d4a234fd0309262d65937ebf", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=84086c464f537591f0e4629676b3fc75517492ab", "patch": "@@ -2922,45 +2922,18 @@ impl TypeContents {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl ops::BitOr<TypeContents,TypeContents> for TypeContents {\n-    fn bitor(&self, other: &TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits | other.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl ops::BitOr<TypeContents,TypeContents> for TypeContents {\n     fn bitor(self, other: TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits | other.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl ops::BitAnd<TypeContents,TypeContents> for TypeContents {\n-    fn bitand(&self, other: &TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits & other.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl ops::BitAnd<TypeContents, TypeContents> for TypeContents {\n     fn bitand(self, other: TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits & other.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n-    fn sub(&self, other: &TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits & !other.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl ops::Sub<TypeContents, TypeContents> for TypeContents {\n     fn sub(self, other: TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits & !other.bits}"}, {"sha": "89aa4b3c9e940ce92a4719ef4254ce9fae3a758b", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=84086c464f537591f0e4629676b3fc75517492ab", "patch": "@@ -205,17 +205,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl BitOr<$BitFlags, $BitFlags> for $BitFlags {\n-            /// Returns the union of the two sets of flags.\n-            #[inline]\n-            fn bitor(&self, other: &$BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits | other.bits }\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl BitOr<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the union of the two sets of flags.\n             #[inline]\n@@ -224,17 +213,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl BitXor<$BitFlags, $BitFlags> for $BitFlags {\n-            /// Returns the left flags, but with all the right flags toggled.\n-            #[inline]\n-            fn bitxor(&self, other: &$BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits ^ other.bits }\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl BitXor<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the left flags, but with all the right flags toggled.\n             #[inline]\n@@ -243,17 +221,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl BitAnd<$BitFlags, $BitFlags> for $BitFlags {\n-            /// Returns the intersection between the two sets of flags.\n-            #[inline]\n-            fn bitand(&self, other: &$BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits & other.bits }\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl BitAnd<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the intersection between the two sets of flags.\n             #[inline]\n@@ -262,17 +229,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl Sub<$BitFlags, $BitFlags> for $BitFlags {\n-            /// Returns the set difference of the two sets of flags.\n-            #[inline]\n-            fn sub(&self, other: &$BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits & !other.bits }\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl Sub<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the set difference of the two sets of flags.\n             #[inline]"}, {"sha": "1d4fd38d48ad016d6476470949a0b6ede5d84329", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=84086c464f537591f0e4629676b3fc75517492ab", "patch": "@@ -290,21 +290,6 @@ impl Neg<Duration> for Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<Duration,Duration> for Duration {\n-    fn add(&self, rhs: &Duration) -> Duration {\n-        let mut secs = self.secs + rhs.secs;\n-        let mut nanos = self.nanos + rhs.nanos;\n-        if nanos >= NANOS_PER_SEC {\n-            nanos -= NANOS_PER_SEC;\n-            secs += 1;\n-        }\n-        Duration { secs: secs, nanos: nanos }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<Duration, Duration> for Duration {\n     fn add(self, rhs: Duration) -> Duration {\n         let mut secs = self.secs + rhs.secs;\n@@ -317,21 +302,6 @@ impl Add<Duration, Duration> for Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Sub<Duration,Duration> for Duration {\n-    fn sub(&self, rhs: &Duration) -> Duration {\n-        let mut secs = self.secs - rhs.secs;\n-        let mut nanos = self.nanos - rhs.nanos;\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs -= 1;\n-        }\n-        Duration { secs: secs, nanos: nanos }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Sub<Duration, Duration> for Duration {\n     fn sub(self, rhs: Duration) -> Duration {\n         let mut secs = self.secs - rhs.secs;\n@@ -344,19 +314,6 @@ impl Sub<Duration, Duration> for Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Mul<i32,Duration> for Duration {\n-    fn mul(&self, rhs: &i32) -> Duration {\n-        // Multiply nanoseconds as i64, because it cannot overflow that way.\n-        let total_nanos = self.nanos as i64 * *rhs as i64;\n-        let (extra_secs, nanos) = div_mod_floor_64(total_nanos, NANOS_PER_SEC as i64);\n-        let secs = self.secs * *rhs as i64 + extra_secs;\n-        Duration { secs: secs, nanos: nanos as i32 }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Mul<i32, Duration> for Duration {\n     fn mul(self, rhs: i32) -> Duration {\n         // Multiply nanoseconds as i64, because it cannot overflow that way.\n@@ -367,27 +324,6 @@ impl Mul<i32, Duration> for Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Div<i32,Duration> for Duration {\n-    fn div(&self, rhs: &i32) -> Duration {\n-        let mut secs = self.secs / *rhs as i64;\n-        let carry = self.secs - secs * *rhs as i64;\n-        let extra_nanos = carry * NANOS_PER_SEC as i64 / *rhs as i64;\n-        let mut nanos = self.nanos / *rhs + extra_nanos as i32;\n-        if nanos >= NANOS_PER_SEC {\n-            nanos -= NANOS_PER_SEC;\n-            secs += 1;\n-        }\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs -= 1;\n-        }\n-        Duration { secs: secs, nanos: nanos }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Div<i32, Duration> for Duration {\n     fn div(self, rhs: i32) -> Duration {\n         let mut secs = self.secs / rhs as i64;"}, {"sha": "eae41a21e7d084169446b9be0e8f059360bc4e96", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=84086c464f537591f0e4629676b3fc75517492ab", "patch": "@@ -52,30 +52,12 @@ impl Pos for BytePos {\n     fn to_uint(&self) -> uint { let BytePos(n) = *self; n as uint }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<BytePos, BytePos> for BytePos {\n-    fn add(&self, rhs: &BytePos) -> BytePos {\n-        BytePos((self.to_uint() + rhs.to_uint()) as u32)\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<BytePos, BytePos> for BytePos {\n     fn add(self, rhs: BytePos) -> BytePos {\n         BytePos((self.to_uint() + rhs.to_uint()) as u32)\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Sub<BytePos, BytePos> for BytePos {\n-    fn sub(&self, rhs: &BytePos) -> BytePos {\n-        BytePos((self.to_uint() - rhs.to_uint()) as u32)\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Sub<BytePos, BytePos> for BytePos {\n     fn sub(self, rhs: BytePos) -> BytePos {\n         BytePos((self.to_uint() - rhs.to_uint()) as u32)\n@@ -87,30 +69,12 @@ impl Pos for CharPos {\n     fn to_uint(&self) -> uint { let CharPos(n) = *self; n }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<CharPos,CharPos> for CharPos {\n-    fn add(&self, rhs: &CharPos) -> CharPos {\n-        CharPos(self.to_uint() + rhs.to_uint())\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<CharPos, CharPos> for CharPos {\n     fn add(self, rhs: CharPos) -> CharPos {\n         CharPos(self.to_uint() + rhs.to_uint())\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Sub<CharPos,CharPos> for CharPos {\n-    fn sub(&self, rhs: &CharPos) -> CharPos {\n-        CharPos(self.to_uint() - rhs.to_uint())\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Sub<CharPos, CharPos> for CharPos {\n     fn sub(self, rhs: CharPos) -> CharPos {\n         CharPos(self.to_uint() - rhs.to_uint())"}, {"sha": "378dbba07fa69536e43976a896cba1a51983506f", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=84086c464f537591f0e4629676b3fc75517492ab", "patch": "@@ -106,30 +106,6 @@ enum LockstepIterSize {\n     LisContradiction(String),\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<LockstepIterSize, LockstepIterSize> for LockstepIterSize {\n-    fn add(&self, other: &LockstepIterSize) -> LockstepIterSize {\n-        match *self {\n-            LisUnconstrained => other.clone(),\n-            LisContradiction(_) => self.clone(),\n-            LisConstraint(l_len, l_id) => match *other {\n-                LisUnconstrained => self.clone(),\n-                LisContradiction(_) => other.clone(),\n-                LisConstraint(r_len, _) if l_len == r_len => self.clone(),\n-                LisConstraint(r_len, r_id) => {\n-                    let l_n = token::get_ident(l_id);\n-                    let r_n = token::get_ident(r_id);\n-                    LisContradiction(format!(\"inconsistent lockstep iteration: \\\n-                                              '{}' has {} items, but '{}' has {}\",\n-                                              l_n, l_len, r_n, r_len).to_string())\n-                }\n-            },\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<LockstepIterSize, LockstepIterSize> for LockstepIterSize {\n     fn add(self, other: LockstepIterSize) -> LockstepIterSize {\n         match self {"}, {"sha": "bbeddcd263bb58be212f8a95b03a58beef773c18", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84086c464f537591f0e4629676b3fc75517492ab/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=84086c464f537591f0e4629676b3fc75517492ab", "patch": "@@ -99,29 +99,6 @@ impl Timespec {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<Duration, Timespec> for Timespec {\n-    fn add(&self, other: &Duration) -> Timespec {\n-        let d_sec = other.num_seconds();\n-        // It is safe to unwrap the nanoseconds, because there cannot be\n-        // more than one second left, which fits in i64 and in i32.\n-        let d_nsec = (*other - Duration::seconds(d_sec))\n-                     .num_nanoseconds().unwrap() as i32;\n-        let mut sec = self.sec + d_sec;\n-        let mut nsec = self.nsec + d_nsec;\n-        if nsec >= NSEC_PER_SEC {\n-            nsec -= NSEC_PER_SEC;\n-            sec += 1;\n-        } else if nsec < 0 {\n-            nsec += NSEC_PER_SEC;\n-            sec -= 1;\n-        }\n-        Timespec::new(sec, nsec)\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<Duration, Timespec> for Timespec {\n     fn add(self, other: Duration) -> Timespec {\n         let d_sec = other.num_seconds();\n@@ -142,17 +119,6 @@ impl Add<Duration, Timespec> for Timespec {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Sub<Timespec, Duration> for Timespec {\n-    fn sub(&self, other: &Timespec) -> Duration {\n-        let sec = self.sec - other.sec;\n-        let nsec = self.nsec - other.nsec;\n-        Duration::seconds(sec) + Duration::nanoseconds(nsec as i64)\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Sub<Timespec, Duration> for Timespec {\n     fn sub(self, other: Timespec) -> Duration {\n         let sec = self.sec - other.sec;"}, {"sha": "b85ff194c7cda636f950b859f00f98c82d32c594", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84086c464f537591f0e4629676b3fc75517492ab/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/84086c464f537591f0e4629676b3fc75517492ab/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=84086c464f537591f0e4629676b3fc75517492ab", "patch": "@@ -1,3 +1,12 @@\n+S 2014-12-17 22a9f25\n+  freebsd-x86_64 c6a13ad985e8464fef0fc7cb7e0d221cbb4815a9\n+  linux-i386 03109a02e2ed6cd2bb982e93814ef555d54b55a6\n+  linux-x86_64 0cdf84d5f2fa7cd6b9e321150c6cfc7334206163\n+  macos-i386 384406ebaa2a2065a801733f4cb3f53d96a0a73d\n+  macos-x86_64 b00e10f44b348da454ad602a921213d8170148b3\n+  winnt-i386 3d6b0f333d142d99f21506dcea5f03d428ddec12\n+  winnt-x86_64 f8cbf77146d7ddcc5f8388c58c090f31e78de317\n+\n S 2014-12-15 1b97cd3\n   freebsd-x86_64 a5d7ff81ec04e01e64dc201c7aa2d875ebd0cbbb\n   linux-i386 47e13c2f1d26a0d13e593e0881a80ca103aa7b2e"}]}