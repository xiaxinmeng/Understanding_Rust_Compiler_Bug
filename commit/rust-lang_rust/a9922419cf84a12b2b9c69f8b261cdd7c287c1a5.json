{"sha": "a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5OTIyNDE5Y2Y4NGExMmIyYjljNjlmOGIyNjFjZGQ3YzI4N2MxYTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-03T00:58:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-03T00:58:37Z"}, "message": "Auto merge of #31370 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #27499, #31220, #31329, #31332, #31347, #31351, #31352, #31366\n- Failed merges:", "tree": {"sha": "892a71c2d529580445b468a47d1b627ee5b8fbca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/892a71c2d529580445b468a47d1b627ee5b8fbca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "html_url": "https://github.com/rust-lang/rust/commit/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dea183aa8461e8520b08864ec81ad2985be36d34", "url": "https://api.github.com/repos/rust-lang/rust/commits/dea183aa8461e8520b08864ec81ad2985be36d34", "html_url": "https://github.com/rust-lang/rust/commit/dea183aa8461e8520b08864ec81ad2985be36d34"}, {"sha": "1a21dabf27232c5c9281a6bf7a8b83afb3efa201", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a21dabf27232c5c9281a6bf7a8b83afb3efa201", "html_url": "https://github.com/rust-lang/rust/commit/1a21dabf27232c5c9281a6bf7a8b83afb3efa201"}], "stats": {"total": 228, "additions": 210, "deletions": 18}, "files": [{"sha": "a5259e9ca4c422867f5f1611238b0f948d4bae8b", "filename": "src/doc/book/guessing-game.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Fdoc%2Fbook%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Fdoc%2Fbook%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fguessing-game.md?ref=a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "patch": "@@ -276,7 +276,7 @@ it\u2019s called on, and if it isn\u2019t a successful one, [`panic!`][panic]s with a\n message you passed it. A `panic!` like this will cause our program to crash,\n displaying the message.\n \n-[expect]: ../std/option/enum.Option.html#method.expect\n+[expect]: ../std/result/enum.Result.html#method.expect\n [panic]: error-handling.html\n \n If we leave off calling this method, our program will compile, but"}, {"sha": "6fd7f4cd4755a3e3f775e4937deb542ce030d554", "filename": "src/doc/book/patterns.md", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Fdoc%2Fbook%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Fdoc%2Fbook%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fpatterns.md?ref=a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "patch": "@@ -173,7 +173,39 @@ let (x, _, z) = coordinate();\n Here, we bind the first and last element of the tuple to `x` and `z`, but\n ignore the middle element.\n \n-Similarly, you can use `..` in a pattern to disregard multiple values.\n+It\u2019s worth noting that using `_` never binds the value in the first place,\n+which means a value may not move:\n+\n+```rust\n+let tuple: (u32, String) = (5, String::from(\"five\"));\n+\n+// Here, tuple is moved, because the String moved:\n+let (x, _s) = tuple;\n+\n+// The next line would give \"error: use of partially moved value: `tuple`\"\n+// println!(\"Tuple is: {:?}\", tuple);\n+\n+// However,\n+\n+let tuple = (5, String::from(\"five\"));\n+\n+// Here, tuple is _not_ moved, as the String was never moved, and u32 is Copy:\n+let (x, _) = tuple;\n+\n+// That means this works:\n+println!(\"Tuple is: {:?}\", tuple);\n+```\n+\n+This also means that any temporary variables will be dropped at the end of the\n+statement:\n+\n+```rust\n+// Here, the String created will be dropped immediately, as it\u2019s not bound:\n+\n+let _ = String::from(\"  hello  \").trim();\n+```\n+\n+You can also use `..` in a pattern to disregard multiple values:\n \n ```rust\n enum OptionalTuple {"}, {"sha": "1f5f3784ac61d0c3c92d2f75c83a6349c17187fc", "filename": "src/etc/errorck.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Fetc%2Ferrorck.py", "raw_url": "https://github.com/rust-lang/rust/raw/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Fetc%2Ferrorck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ferrorck.py?ref=a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "patch": "@@ -114,7 +114,7 @@ def check_unused_error_codes(error_codes, check_error_codes, filenames, dirnames\n         if errcode in errcode_checked:\n             continue\n         all_errors.append(errcode)\n-        print(\"error: unused error code: \" + errcode)\n+        print(\"error: unused error code: {0} ({1}:{2})\".format(*errcode_map[errcode][0]))\n         errors = True\n \n "}, {"sha": "3f1808a03967d82d4ec39479d3745a547e0e2cde", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "patch": "@@ -1050,6 +1050,30 @@ pub trait Iterator {\n     /// // got a false, take_while() isn't used any more\n     /// assert_eq!(iter.next(), None);\n     /// ```\n+    ///\n+    /// Because `take_while()` needs to look at the value in order to see if it\n+    /// should be included or not, consuming iterators will see that it is\n+    /// removed:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3, 4];\n+    /// let mut iter = a.into_iter();\n+    ///\n+    /// let result: Vec<i32> = iter.by_ref()\n+    ///                            .take_while(|n| **n != 3)\n+    ///                            .cloned()\n+    ///                            .collect();\n+    ///\n+    /// assert_eq!(result, &[1, 2]);\n+    ///\n+    /// let result: Vec<i32> = iter.cloned().collect();\n+    ///\n+    /// assert_eq!(result, &[4]);\n+    /// ```\n+    ///\n+    /// The `3` is no longer there, because it was consumed in order to see if\n+    /// the iteration should stop, but wasn't placed back into the iterator or\n+    /// some similar thing.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where\n@@ -3258,6 +3282,49 @@ impl<A, B> DoubleEndedIterator for Zip<A, B> where\n ///\n /// [`map()`]: trait.Iterator.html#method.map\n /// [`Iterator`]: trait.Iterator.html\n+///\n+/// # Notes about side effects\n+///\n+/// The [`map()`] iterator implements [`DoubleEndedIterator`], meaning that\n+/// you can also [`map()`] backwards:\n+///\n+/// ```rust\n+/// let v: Vec<i32> = vec![1, 2, 3].into_iter().rev().map(|x| x + 1).collect();\n+///\n+/// assert_eq!(v, [4, 3, 2]);\n+/// ```\n+///\n+/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n+///\n+/// But if your closure has state, iterating backwards may act in a way you do\n+/// not expect. Let's go through an example. First, in the forward direction:\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) }) {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+///\n+/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n+///\n+/// Now consider this twist where we add a call to `rev`. This version will\n+/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n+/// but the values of the counter still go in order. This is because `map()` is\n+/// still being called lazilly on each item, but we are popping items off the\n+/// back of the vector now, instead of shifting them from the front.\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) })\n+///                                .rev() {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]"}, {"sha": "fb257f0e673288fe44c87dd0c453c13bbd586bfe", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "patch": "@@ -209,9 +209,12 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                         return;\n                     }\n                     _ => {\n-                        span_err!(self.tcx.sess, item.span, E0118,\n-                                  \"no base type found for inherent implementation; \\\n-                                   implement a trait or new type instead\");\n+                        struct_span_err!(self.tcx.sess, item.span, E0118,\n+                                         \"no base type found for inherent implementation\")\n+                        .span_help(item.span,\n+                                   \"either implement a trait on it or create a newtype to wrap it \\\n+                                    instead\")\n+                        .emit();\n                         return;\n                     }\n                 }"}, {"sha": "f138b997f4cc32767e0191e19fa91a1ee454f444", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "patch": "@@ -1489,22 +1489,46 @@ For information on the design of the orphan rules, see [RFC 1023].\n \"##,\n \n E0118: r##\"\n-Rust can't find a base type for an implementation you are providing, or the type\n-cannot have an implementation. For example, only a named type or a trait can\n-have an implementation:\n+You're trying to write an inherent implementation for something which isn't a\n+struct nor an enum. Erroneous code example:\n \n ```\n-type NineString = [char, ..9] // This isn't a named type (struct, enum or trait)\n-impl NineString {\n-    // Some code here\n+impl (u8, u8) { // error: no base type found for inherent implementation\n+    fn get_state(&self) -> String {\n+        // ...\n+    }\n+}\n+```\n+\n+To fix this error, please implement a trait on the type or wrap it in a struct.\n+Example:\n+\n+```\n+// we create a trait here\n+trait LiveLongAndProsper {\n+    fn get_state(&self) -> String;\n+}\n+\n+// and now you can implement it on (u8, u8)\n+impl LiveLongAndProsper for (u8, u8) {\n+    fn get_state(&self) -> String {\n+        \"He's dead, Jim!\".to_owned()\n+    }\n }\n ```\n \n-In the other, simpler case, Rust just can't find the type you are providing an\n-impelementation for:\n+Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct.\n+For example, `NewType` is a newtype over `Foo` in `struct NewType(Foo)`.\n+Example:\n \n ```\n-impl SomeTypeThatDoesntExist {  }\n+struct TypeWrapper((u8, u8));\n+\n+impl TypeWrapper {\n+    fn get_state(&self) -> String {\n+        \"Fascinating!\".to_owned()\n+    }\n+}\n ```\n \"##,\n "}, {"sha": "dfbe08a0e423d2d204914dbb69cc5185d4a2224b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "patch": "@@ -54,10 +54,12 @@ use externalfiles::ExternalHtml;\n \n use serialize::json::{self, ToJson};\n use syntax::{abi, ast};\n+use syntax::feature_gate::UnstableFeatures;\n use rustc::middle::cstore::LOCAL_CRATE;\n use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n+use rustc::session::config::get_unstable_features_setting;\n use rustc_front::hir;\n \n use clean::{self, SelfTy};\n@@ -1897,10 +1899,14 @@ fn item_static(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n+    let vis_constness = match get_unstable_features_setting() {\n+        UnstableFeatures::Allow => f.constness,\n+        _ => hir::Constness::NotConst\n+    };\n     try!(write!(w, \"<pre class='rust fn'>{vis}{constness}{unsafety}{abi}fn \\\n                     {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(it.visibility),\n-           constness = ConstnessSpace(f.constness),\n+           constness = ConstnessSpace(vis_constness),\n            unsafety = UnsafetySpace(f.unsafety),\n            abi = AbiSpace(f.abi),\n            name = it.name.as_ref().unwrap(),\n@@ -2122,9 +2128,13 @@ fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n                 href(did).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n             }\n         };\n+        let vis_constness = match get_unstable_features_setting() {\n+            UnstableFeatures::Allow => constness,\n+            _ => hir::Constness::NotConst\n+        };\n         write!(w, \"{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n-               ConstnessSpace(constness),\n+               ConstnessSpace(vis_constness),\n                UnsafetySpace(unsafety),\n                match abi {\n                    Abi::Rust => String::new(),"}, {"sha": "b7afd12d8e527bcc0c440c3015c059273cf093be", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "patch": "@@ -365,6 +365,9 @@ pub mod builtin {\n     /// stringification of all the tokens passed to the macro. No restrictions\n     /// are placed on the syntax of the macro invocation itself.\n     ///\n+    /// Note that the expanded results of the input tokens may change in the\n+    /// future. You should be careful if you rely on the output.\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "088f911ed8c446a2e0473962cce640fea291225d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "patch": "@@ -1174,14 +1174,28 @@ impl TokenTree {\n             }\n             (&TokenTree::Token(sp, token::DocComment(name)), _) => {\n                 let stripped = strip_doc_comment_decoration(&name.as_str());\n+\n+                // Searches for the occurrences of `\"#*` and returns the minimum number of `#`s\n+                // required to wrap the text.\n+                let num_of_hashes = stripped.chars().scan(0, |cnt, x| {\n+                    *cnt = if x == '\"' {\n+                        1\n+                    } else if *cnt != 0 && x == '#' {\n+                        *cnt + 1\n+                    } else {\n+                        0\n+                    };\n+                    Some(*cnt)\n+                }).max().unwrap_or(0);\n+\n                 TokenTree::Delimited(sp, Rc::new(Delimited {\n                     delim: token::Bracket,\n                     open_span: sp,\n                     tts: vec![TokenTree::Token(sp, token::Ident(token::str_to_ident(\"doc\"),\n                                                                 token::Plain)),\n                               TokenTree::Token(sp, token::Eq),\n                               TokenTree::Token(sp, token::Literal(\n-                                  token::StrRaw(token::intern(&stripped), 0), None))],\n+                                  token::StrRaw(token::intern(&stripped), num_of_hashes), None))],\n                     close_span: sp,\n                 }))\n             }"}, {"sha": "ffbe237b74e60a1a55ded10444bd81a1dba1e6fb", "filename": "src/test/run-pass/macro-doc-raw-str-hashes.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Ftest%2Frun-pass%2Fmacro-doc-raw-str-hashes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9922419cf84a12b2b9c69f8b261cdd7c287c1a5/src%2Ftest%2Frun-pass%2Fmacro-doc-raw-str-hashes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-doc-raw-str-hashes.rs?ref=a9922419cf84a12b2b9c69f8b261cdd7c287c1a5", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The number of `#`s used to wrap the documentation comment should differ regarding the content.\n+//\n+// Related issue: #27489\n+\n+macro_rules! homura {\n+    ($x:expr, #[$y:meta]) => (assert_eq!($x, stringify!($y)))\n+}\n+\n+fn main() {\n+    homura! {\n+        r#\"doc = r\" Madoka\"\"#,\n+        /// Madoka\n+    };\n+\n+    homura! {\n+        r##\"doc = r#\" One quote mark: [\"]\"#\"##,\n+        /// One quote mark: [\"]\n+    };\n+\n+    homura! {\n+        r##\"doc = r#\" Two quote marks: [\"\"]\"#\"##,\n+        /// Two quote marks: [\"\"]\n+    };\n+\n+    homura! {\n+        r#####\"doc = r####\" Raw string ending sequences: [\"###]\"####\"#####,\n+        /// Raw string ending sequences: [\"###]\n+    };\n+}"}]}