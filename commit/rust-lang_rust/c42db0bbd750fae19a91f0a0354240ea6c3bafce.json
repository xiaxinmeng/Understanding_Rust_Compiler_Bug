{"sha": "c42db0bbd750fae19a91f0a0354240ea6c3bafce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MmRiMGJiZDc1MGZhZTE5YTkxZjBhMDM1NDI0MGVhNmMzYmFmY2U=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-24T22:56:13Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-24T22:56:13Z"}, "message": "Merge #623\n\n623: WIP: module id is not def id r=matklad a=matklad\n\nThis achieves two things:\r\n\r\n* makes module_tree & item_map per crate, not per source_root\r\n* begins the refactoring to remove universal `DefId` in favor of having separate ids for each kind of `Def`. Currently, only modules get a differnt ID though. \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "beb7030248280fd8c67eb2b2c9cc4b19c6074c17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/beb7030248280fd8c67eb2b2c9cc4b19c6074c17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c42db0bbd750fae19a91f0a0354240ea6c3bafce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c42db0bbd750fae19a91f0a0354240ea6c3bafce", "html_url": "https://github.com/rust-lang/rust/commit/c42db0bbd750fae19a91f0a0354240ea6c3bafce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c42db0bbd750fae19a91f0a0354240ea6c3bafce/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "b308375b82a33687f93468d75c7cc628b83a1351", "url": "https://api.github.com/repos/rust-lang/rust/commits/b308375b82a33687f93468d75c7cc628b83a1351", "html_url": "https://github.com/rust-lang/rust/commit/b308375b82a33687f93468d75c7cc628b83a1351"}, {"sha": "31d3a56b1865c33ef54e5d76e606965c87676695", "url": "https://api.github.com/repos/rust-lang/rust/commits/31d3a56b1865c33ef54e5d76e606965c87676695", "html_url": "https://github.com/rust-lang/rust/commit/31d3a56b1865c33ef54e5d76e606965c87676695"}], "stats": {"total": 1916, "additions": 939, "deletions": 977}, "files": [{"sha": "9825d52cfcc119fae8c27509cb93f12d806873ed", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -160,6 +160,7 @@ pub trait FilesDatabase: salsa::Database {\n     /// Contents of the source root.\n     #[salsa::input]\n     fn source_root(&self, id: SourceRootId) -> Arc<SourceRoot>;\n+    fn source_root_crates(&self, id: SourceRootId) -> Arc<Vec<CrateId>>;\n     /// The set of \"local\" (that is, from the current workspace) roots.\n     /// Files in local roots are assumed to change frequently.\n     #[salsa::input]\n@@ -173,6 +174,17 @@ pub trait FilesDatabase: salsa::Database {\n     fn crate_graph(&self) -> Arc<CrateGraph>;\n }\n \n+fn source_root_crates(db: &impl FilesDatabase, id: SourceRootId) -> Arc<Vec<CrateId>> {\n+    let root = db.source_root(id);\n+    let graph = db.crate_graph();\n+    let res = root\n+        .files\n+        .values()\n+        .filter_map(|&it| graph.crate_id_for_crate_root(it))\n+        .collect::<Vec<_>>();\n+    Arc::new(res)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::{CrateGraph, FileId, SmolStr};"}, {"sha": "84759c75afe14c381d2fccdc8950d397afff41ce", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -13,7 +13,7 @@ pub use crate::{\n     cancellation::Canceled,\n     input::{\n         FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph, Dependency,\n-        FileTextQuery, FileSourceRootQuery, SourceRootQuery, LocalRootsQuery, LibraryRootsQuery, CrateGraphQuery,\n+        FileTextQuery, FileSourceRootQuery, SourceRootQuery, SourceRootCratesQuery, LocalRootsQuery, LibraryRootsQuery, CrateGraphQuery,\n         FileRelativePathQuery\n     },\n     loc2id::LocationIntener,"}, {"sha": "6b13b464d24ed633e7967323c294f039fb3bdd70", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 42, "deletions": 67, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -3,25 +3,35 @@\n \n use std::sync::Arc;\n \n-use ra_syntax::{\n-    SyntaxNode,\n-    ast::{self, NameOwner, StructFlavor, AstNode}\n-};\n+use ra_syntax::ast::{self, NameOwner, StructFlavor};\n \n use crate::{\n-    DefId, DefLoc, Name, AsName, Struct, Enum, EnumVariant,\n-    HirDatabase, DefKind,\n-    SourceItemId,\n+    Name, AsName, Struct, Enum, EnumVariant, Crate,\n+    HirDatabase,\n     type_ref::TypeRef,\n+    ids::LocationCtx,\n };\n \n-impl Struct {\n-    pub(crate) fn new(def_id: DefId) -> Self {\n-        Struct { def_id }\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum AdtDef {\n+    Struct(Struct),\n+    Enum(Enum),\n+}\n+impl_froms!(AdtDef: Struct, Enum);\n+\n+impl AdtDef {\n+    pub(crate) fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n+        match self {\n+            AdtDef::Struct(s) => s.module(db),\n+            AdtDef::Enum(e) => e.module(db),\n+        }\n+        .krate(db)\n     }\n+}\n \n+impl Struct {\n     pub(crate) fn variant_data(&self, db: &impl HirDatabase) -> Arc<VariantData> {\n-        db.struct_data(self.def_id).variant_data.clone()\n+        db.struct_data((*self).into()).variant_data.clone()\n     }\n }\n \n@@ -39,38 +49,12 @@ impl StructData {\n         StructData { name, variant_data }\n     }\n \n-    pub(crate) fn struct_data_query(db: &impl HirDatabase, def_id: DefId) -> Arc<StructData> {\n-        let def_loc = def_id.loc(db);\n-        assert!(def_loc.kind == DefKind::Struct);\n-        let syntax = db.file_item(def_loc.source_item_id);\n-        let struct_def =\n-            ast::StructDef::cast(&syntax).expect(\"struct def should point to StructDef node\");\n-        Arc::new(StructData::new(struct_def))\n+    pub(crate) fn struct_data_query(db: &impl HirDatabase, struct_: Struct) -> Arc<StructData> {\n+        let (_, struct_def) = struct_.source(db);\n+        Arc::new(StructData::new(&*struct_def))\n     }\n }\n \n-fn get_def_id(\n-    db: &impl HirDatabase,\n-    same_file_loc: &DefLoc,\n-    node: &SyntaxNode,\n-    expected_kind: DefKind,\n-) -> DefId {\n-    let file_id = same_file_loc.source_item_id.file_id;\n-    let file_items = db.file_items(file_id);\n-\n-    let item_id = file_items.id_of(file_id, node);\n-    let source_item_id = SourceItemId {\n-        item_id: Some(item_id),\n-        ..same_file_loc.source_item_id\n-    };\n-    let loc = DefLoc {\n-        kind: expected_kind,\n-        source_item_id,\n-        ..*same_file_loc\n-    };\n-    loc.id(db)\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n     pub(crate) name: Option<Name>,\n@@ -83,27 +67,24 @@ impl EnumData {\n         EnumData { name, variants }\n     }\n \n-    pub(crate) fn enum_data_query(db: &impl HirDatabase, def_id: DefId) -> Arc<EnumData> {\n-        let def_loc = def_id.loc(db);\n-        assert!(def_loc.kind == DefKind::Enum);\n-        let syntax = db.file_item(def_loc.source_item_id);\n-        let enum_def = ast::EnumDef::cast(&syntax).expect(\"enum def should point to EnumDef node\");\n+    pub(crate) fn enum_data_query(db: &impl HirDatabase, e: Enum) -> Arc<EnumData> {\n+        let (file_id, enum_def) = e.source(db);\n+        let module = e.module(db);\n+        let ctx = LocationCtx::new(db, module, file_id);\n         let variants = if let Some(vl) = enum_def.variant_list() {\n             vl.variants()\n                 .filter_map(|variant_def| {\n-                    let name = variant_def.name().map(|n| n.as_name());\n-\n-                    name.map(|n| {\n-                        let def_id =\n-                            get_def_id(db, &def_loc, variant_def.syntax(), DefKind::EnumVariant);\n-                        (n, EnumVariant::new(def_id))\n-                    })\n+                    let name = variant_def.name()?.as_name();\n+                    let var = EnumVariant {\n+                        id: ctx.to_def(variant_def),\n+                    };\n+                    Some((name, var))\n                 })\n                 .collect()\n         } else {\n             Vec::new()\n         };\n-        Arc::new(EnumData::new(enum_def, variants))\n+        Arc::new(EnumData::new(&*enum_def, variants))\n     }\n }\n \n@@ -128,21 +109,15 @@ impl EnumVariantData {\n \n     pub(crate) fn enum_variant_data_query(\n         db: &impl HirDatabase,\n-        def_id: DefId,\n+        var: EnumVariant,\n     ) -> Arc<EnumVariantData> {\n-        let def_loc = def_id.loc(db);\n-        assert!(def_loc.kind == DefKind::EnumVariant);\n-        let syntax = db.file_item(def_loc.source_item_id);\n-        let variant_def = ast::EnumVariant::cast(&syntax)\n-            .expect(\"enum variant def should point to EnumVariant node\");\n-        let enum_node = syntax\n-            .parent()\n-            .expect(\"enum variant should have enum variant list ancestor\")\n-            .parent()\n-            .expect(\"enum variant list should have enum ancestor\");\n-        let enum_def_id = get_def_id(db, &def_loc, enum_node, DefKind::Enum);\n-\n-        Arc::new(EnumVariantData::new(variant_def, Enum::new(enum_def_id)))\n+        let (file_id, variant_def) = var.source(db);\n+        let enum_def = variant_def.parent_enum();\n+        let ctx = LocationCtx::new(db, var.module(db), file_id);\n+        let e = Enum {\n+            id: ctx.to_def(enum_def),\n+        };\n+        Arc::new(EnumVariantData::new(&*variant_def, e))\n     }\n }\n "}, {"sha": "6739627b4ed3c194b2df4178e68efe63c760a8a1", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 90, "deletions": 97, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -5,22 +5,23 @@ use ra_db::{CrateId, FileId};\n use ra_syntax::{ast::self, TreeArc, SyntaxNode};\n \n use crate::{\n-    Name, DefId, Path, PerNs, ScopesWithSyntaxMapping, Ty, HirFileId,\n+    Name, Path, PerNs, ScopesWithSyntaxMapping, Ty, HirFileId,\n     type_ref::TypeRef,\n     nameres::{ModuleScope, lower::ImportId},\n     db::HirDatabase,\n     expr::BodySyntaxMapping,\n-    ty::InferenceResult,\n+    ty::{InferenceResult, VariantDef},\n     adt::VariantData,\n     generics::GenericParams,\n-    code_model_impl::def_id_to_ast,\n-    docs::{Documentation, Docs, docs_from_ast}\n+    docs::{Documentation, Docs, docs_from_ast},\n+    module_tree::ModuleId,\n+    ids::{FunctionId, StructId, EnumId, EnumVariantId, AstItemDef, ConstId, StaticId, TraitId, TypeId},\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n /// a crate's dependencies interact. Mostly, it should be just a proxy for the\n /// root module.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Crate {\n     pub(crate) crate_id: CrateId,\n }\n@@ -45,22 +46,40 @@ impl Crate {\n \n #[derive(Debug)]\n pub enum Def {\n+    Item,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Module {\n+    pub(crate) krate: CrateId,\n+    pub(crate) module_id: ModuleId,\n+}\n+\n+/// The defs which can be visible in the module.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ModuleDef {\n     Module(Module),\n+    Function(Function),\n     Struct(Struct),\n     Enum(Enum),\n+    // Can't be directly declared, but can be imported.\n     EnumVariant(EnumVariant),\n-    Function(Function),\n     Const(Const),\n     Static(Static),\n     Trait(Trait),\n     Type(Type),\n-    Item,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Module {\n-    pub(crate) def_id: DefId,\n }\n+impl_froms!(\n+    ModuleDef: Module,\n+    Function,\n+    Struct,\n+    Enum,\n+    EnumVariant,\n+    Const,\n+    Static,\n+    Trait,\n+    Type\n+);\n \n pub enum ModuleSource {\n     SourceFile(TreeArc<ast::SourceFile>),\n@@ -149,7 +168,7 @@ impl Module {\n         self.scope_impl(db)\n     }\n \n-    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<DefId> {\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<ModuleDef> {\n         self.resolve_path_impl(db, path)\n     }\n \n@@ -160,7 +179,7 @@ impl Module {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct StructField {\n-    parent: DefId,\n+    parent: VariantDef,\n     name: Name,\n }\n \n@@ -174,38 +193,38 @@ impl StructField {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Struct {\n-    pub(crate) def_id: DefId,\n+    pub(crate) id: StructId,\n }\n \n impl Struct {\n-    pub fn def_id(&self) -> DefId {\n-        self.def_id\n+    pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::StructDef>) {\n+        self.id.source(db)\n+    }\n+\n+    pub fn module(&self, db: &impl HirDatabase) -> Module {\n+        self.id.module(db)\n     }\n \n     pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n-        db.struct_data(self.def_id).name.clone()\n+        db.struct_data(*self).name.clone()\n     }\n \n     pub fn fields(&self, db: &impl HirDatabase) -> Vec<StructField> {\n-        db.struct_data(self.def_id)\n+        db.struct_data(*self)\n             .variant_data\n             .fields()\n             .iter()\n             .map(|it| StructField {\n-                parent: self.def_id,\n+                parent: (*self).into(),\n                 name: it.name.clone(),\n             })\n             .collect()\n     }\n \n-    pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::StructDef>) {\n-        def_id_to_ast(db, self.def_id)\n-    }\n-\n     pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n-        db.generic_params(self.def_id)\n+        db.generic_params((*self).into())\n     }\n }\n \n@@ -215,34 +234,30 @@ impl Docs for Struct {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Enum {\n-    pub(crate) def_id: DefId,\n+    pub(crate) id: EnumId,\n }\n \n impl Enum {\n-    pub(crate) fn new(def_id: DefId) -> Self {\n-        Enum { def_id }\n+    pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::EnumDef>) {\n+        self.id.source(db)\n     }\n \n-    pub fn def_id(&self) -> DefId {\n-        self.def_id\n+    pub fn module(&self, db: &impl HirDatabase) -> Module {\n+        self.id.module(db)\n     }\n \n     pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n-        db.enum_data(self.def_id).name.clone()\n+        db.enum_data(*self).name.clone()\n     }\n \n     pub fn variants(&self, db: &impl HirDatabase) -> Vec<(Name, EnumVariant)> {\n-        db.enum_data(self.def_id).variants.clone()\n-    }\n-\n-    pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::EnumDef>) {\n-        def_id_to_ast(db, self.def_id)\n+        db.enum_data(*self).variants.clone()\n     }\n \n     pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n-        db.generic_params(self.def_id)\n+        db.generic_params((*self).into())\n     }\n }\n \n@@ -252,46 +267,40 @@ impl Docs for Enum {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct EnumVariant {\n-    pub(crate) def_id: DefId,\n+    pub(crate) id: EnumVariantId,\n }\n \n impl EnumVariant {\n-    pub(crate) fn new(def_id: DefId) -> Self {\n-        EnumVariant { def_id }\n+    pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::EnumVariant>) {\n+        self.id.source(db)\n     }\n-\n-    pub fn def_id(&self) -> DefId {\n-        self.def_id\n+    pub fn module(&self, db: &impl HirDatabase) -> Module {\n+        self.id.module(db)\n     }\n-\n     pub fn parent_enum(&self, db: &impl HirDatabase) -> Enum {\n-        db.enum_variant_data(self.def_id).parent_enum.clone()\n+        db.enum_variant_data(*self).parent_enum.clone()\n     }\n \n     pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n-        db.enum_variant_data(self.def_id).name.clone()\n+        db.enum_variant_data(*self).name.clone()\n     }\n \n     pub fn variant_data(&self, db: &impl HirDatabase) -> Arc<VariantData> {\n-        db.enum_variant_data(self.def_id).variant_data.clone()\n+        db.enum_variant_data(*self).variant_data.clone()\n     }\n \n     pub fn fields(&self, db: &impl HirDatabase) -> Vec<StructField> {\n         self.variant_data(db)\n             .fields()\n             .iter()\n             .map(|it| StructField {\n-                parent: self.def_id,\n+                parent: (*self).into(),\n                 name: it.name.clone(),\n             })\n             .collect()\n     }\n-\n-    pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::EnumVariant>) {\n-        def_id_to_ast(db, self.def_id)\n-    }\n }\n \n impl Docs for EnumVariant {\n@@ -300,9 +309,9 @@ impl Docs for EnumVariant {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Function {\n-    pub(crate) def_id: DefId,\n+    pub(crate) id: FunctionId,\n }\n \n pub use crate::code_model_impl::function::ScopeEntryWithSyntax;\n@@ -339,37 +348,37 @@ impl FnSignature {\n }\n \n impl Function {\n-    pub fn def_id(&self) -> DefId {\n-        self.def_id\n+    pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::FnDef>) {\n+        self.id.source(db)\n     }\n \n-    pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::FnDef>) {\n-        def_id_to_ast(db, self.def_id)\n+    pub fn module(&self, db: &impl HirDatabase) -> Module {\n+        self.id.module(db)\n     }\n \n     pub fn body_syntax_mapping(&self, db: &impl HirDatabase) -> Arc<BodySyntaxMapping> {\n-        db.body_syntax_mapping(self.def_id)\n+        db.body_syntax_mapping(*self)\n     }\n \n     pub fn scopes(&self, db: &impl HirDatabase) -> ScopesWithSyntaxMapping {\n-        let scopes = db.fn_scopes(self.def_id);\n-        let syntax_mapping = db.body_syntax_mapping(self.def_id);\n+        let scopes = db.fn_scopes(*self);\n+        let syntax_mapping = db.body_syntax_mapping(*self);\n         ScopesWithSyntaxMapping {\n             scopes,\n             syntax_mapping,\n         }\n     }\n \n     pub fn signature(&self, db: &impl HirDatabase) -> Arc<FnSignature> {\n-        db.fn_signature(self.def_id)\n+        db.fn_signature(*self)\n     }\n \n     pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.def_id)\n+        db.infer(*self)\n     }\n \n     pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n-        db.generic_params(self.def_id)\n+        db.generic_params((*self).into())\n     }\n }\n \n@@ -379,18 +388,14 @@ impl Docs for Function {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Const {\n-    pub(crate) def_id: DefId,\n+    pub(crate) id: ConstId,\n }\n \n impl Const {\n-    pub(crate) fn new(def_id: DefId) -> Const {\n-        Const { def_id }\n-    }\n-\n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::ConstDef>) {\n-        def_id_to_ast(db, self.def_id)\n+        self.id.source(db)\n     }\n }\n \n@@ -400,18 +405,14 @@ impl Docs for Const {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Static {\n-    pub(crate) def_id: DefId,\n+    pub(crate) id: StaticId,\n }\n \n impl Static {\n-    pub(crate) fn new(def_id: DefId) -> Static {\n-        Static { def_id }\n-    }\n-\n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::StaticDef>) {\n-        def_id_to_ast(db, self.def_id)\n+        self.id.source(db)\n     }\n }\n \n@@ -421,22 +422,18 @@ impl Docs for Static {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Trait {\n-    pub(crate) def_id: DefId,\n+    pub(crate) id: TraitId,\n }\n \n impl Trait {\n-    pub(crate) fn new(def_id: DefId) -> Trait {\n-        Trait { def_id }\n-    }\n-\n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::TraitDef>) {\n-        def_id_to_ast(db, self.def_id)\n+        self.id.source(db)\n     }\n \n     pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n-        db.generic_params(self.def_id)\n+        db.generic_params((*self).into())\n     }\n }\n \n@@ -446,22 +443,18 @@ impl Docs for Trait {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Type {\n-    pub(crate) def_id: DefId,\n+    pub(crate) id: TypeId,\n }\n \n impl Type {\n-    pub(crate) fn new(def_id: DefId) -> Type {\n-        Type { def_id }\n-    }\n-\n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::TypeDef>) {\n-        def_id_to_ast(db, self.def_id)\n+        self.id.source(db)\n     }\n \n     pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n-        db.generic_params(self.def_id)\n+        db.generic_params((*self).into())\n     }\n }\n "}, {"sha": "1f28fab74825986055d337f546d1daa7daa78568", "filename": "crates/ra_hir/src/code_model_impl.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -1,18 +1,3 @@\n mod krate; // `crate` is invalid ident :(\n mod module;\n pub(crate) mod function;\n-\n-use ra_syntax::{AstNode, TreeArc};\n-\n-use crate::{HirDatabase, DefId, HirFileId};\n-\n-pub(crate) fn def_id_to_ast<N: AstNode>(\n-    db: &impl HirDatabase,\n-    def_id: DefId,\n-) -> (HirFileId, TreeArc<N>) {\n-    let (file_id, syntax) = def_id.source(db);\n-    let ast = N::cast(&syntax)\n-        .unwrap_or_else(|| panic!(\"def points to wrong source {:?} {:?}\", def_id, syntax))\n-        .to_owned();\n-    (file_id, ast)\n-}"}, {"sha": "e0dd4d6290bebfa70fb4daeb7185a83a6df3b670", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -2,41 +2,32 @@ mod scope;\n \n use std::sync::Arc;\n \n-use ra_syntax::{TreeArc, ast::{self, NameOwner}};\n+use ra_syntax::ast::{self, NameOwner};\n \n use crate::{\n-    DefId, HirDatabase, Name, AsName, Function, FnSignature, Module,\n+    HirDatabase, Name, AsName, Function, FnSignature,\n     type_ref::{TypeRef, Mutability},\n     expr::Body,\n     impl_block::ImplBlock,\n-    code_model_impl::def_id_to_ast,\n };\n \n pub use self::scope::{FnScopes, ScopesWithSyntaxMapping, ScopeEntryWithSyntax};\n \n impl Function {\n-    pub(crate) fn new(def_id: DefId) -> Function {\n-        Function { def_id }\n-    }\n-\n     pub(crate) fn body(&self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body_hir(self.def_id)\n-    }\n-\n-    pub(crate) fn module(&self, db: &impl HirDatabase) -> Module {\n-        self.def_id.module(db)\n+        db.body_hir(*self)\n     }\n \n     /// The containing impl block, if this is a method.\n     pub(crate) fn impl_block(&self, db: &impl HirDatabase) -> Option<ImplBlock> {\n-        self.def_id.impl_block(db)\n+        let module_impls = db.impls_in_module(self.module(db));\n+        ImplBlock::containing(module_impls, (*self).into())\n     }\n }\n \n impl FnSignature {\n-    pub(crate) fn fn_signature_query(db: &impl HirDatabase, def_id: DefId) -> Arc<FnSignature> {\n-        // FIXME: we're using def_id_to_ast here to avoid returning Cancelable... this is a bit hacky\n-        let node: TreeArc<ast::FnDef> = def_id_to_ast(db, def_id).1;\n+    pub(crate) fn fn_signature_query(db: &impl HirDatabase, func: Function) -> Arc<FnSignature> {\n+        let (_, node) = func.source(db);\n         let name = node\n             .name()\n             .map(|n| n.as_name())"}, {"sha": "cdd30b402cf336bf48f891d7cc6c032b09ad862a", "filename": "crates/ra_hir/src/code_model_impl/krate.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -1,7 +1,7 @@\n use ra_db::CrateId;\n \n use crate::{\n-    HirFileId, Crate, CrateDependency, AsName, DefLoc, DefKind, Module, SourceItemId,\n+    Crate, CrateDependency, AsName, Module,\n     db::HirDatabase,\n };\n \n@@ -21,27 +21,13 @@ impl Crate {\n             .collect()\n     }\n     pub(crate) fn root_module_impl(&self, db: &impl HirDatabase) -> Option<Module> {\n-        let crate_graph = db.crate_graph();\n-        let file_id = crate_graph.crate_root(self.crate_id);\n-        let source_root_id = db.file_source_root(file_id);\n-        let file_id = HirFileId::from(file_id);\n-        let module_tree = db.module_tree(source_root_id);\n-        // FIXME: teach module tree about crate roots instead of guessing\n-        let source = SourceItemId {\n-            file_id,\n-            item_id: None,\n-        };\n-        let module_id = module_tree.find_module_by_source(source)?;\n+        let module_tree = db.module_tree(self.crate_id);\n+        let module_id = module_tree.modules().next()?;\n \n-        let def_loc = DefLoc {\n-            kind: DefKind::Module,\n-            source_root_id,\n+        let module = Module {\n+            krate: self.crate_id,\n             module_id,\n-            source_item_id: module_id.source(&module_tree),\n         };\n-        let def_id = def_loc.id(db);\n-\n-        let module = Module::new(def_id);\n         Some(module)\n     }\n }"}, {"sha": "6419d3934cd2ce4ced80a908622868a1556c2e0e", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 54, "deletions": 92, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -1,62 +1,42 @@\n-use ra_db::{SourceRootId, FileId};\n-use ra_syntax::{ast, SyntaxNode, AstNode, TreeArc};\n+use ra_db::FileId;\n+use ra_syntax::{ast, SyntaxNode, TreeArc};\n \n use crate::{\n-    Module, ModuleSource, Problem,\n-    Crate, DefId, DefLoc, DefKind, Name, Path, PathKind, PerNs, Def,\n+    Module, ModuleSource, Problem, ModuleDef,\n+    Crate, Name, Path, PathKind, PerNs,\n     module_tree::ModuleId,\n     nameres::{ModuleScope, lower::ImportId},\n     db::HirDatabase,\n };\n \n impl Module {\n-    pub(crate) fn new(def_id: DefId) -> Self {\n-        crate::code_model_api::Module { def_id }\n-    }\n-\n-    pub(crate) fn from_module_id(\n-        db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Self {\n-        let module_tree = db.module_tree(source_root_id);\n-        let def_loc = DefLoc {\n-            kind: DefKind::Module,\n-            source_root_id,\n+    fn with_module_id(&self, module_id: ModuleId) -> Module {\n+        Module {\n             module_id,\n-            source_item_id: module_id.source(&module_tree),\n-        };\n-        let def_id = def_loc.id(db);\n-        Module::new(def_id)\n+            krate: self.krate,\n+        }\n     }\n \n     pub(crate) fn name_impl(&self, db: &impl HirDatabase) -> Option<Name> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        let link = loc.module_id.parent_link(&module_tree)?;\n+        let module_tree = db.module_tree(self.krate);\n+        let link = self.module_id.parent_link(&module_tree)?;\n         Some(link.name(&module_tree).clone())\n     }\n \n     pub(crate) fn definition_source_impl(&self, db: &impl HirDatabase) -> (FileId, ModuleSource) {\n-        let loc = self.def_id.loc(db);\n-        let file_id = loc.source_item_id.file_id.as_original_file();\n-        let syntax_node = db.file_item(loc.source_item_id);\n-        let module_source = if let Some(source_file) = ast::SourceFile::cast(&syntax_node) {\n-            ModuleSource::SourceFile(source_file.to_owned())\n-        } else {\n-            let module = ast::Module::cast(&syntax_node).unwrap();\n-            ModuleSource::Module(module.to_owned())\n-        };\n+        let module_tree = db.module_tree(self.krate);\n+        let source = self.module_id.source(&module_tree);\n+        let module_source = ModuleSource::from_source_item_id(db, source);\n+        let file_id = source.file_id.as_original_file();\n         (file_id, module_source)\n     }\n \n     pub(crate) fn declaration_source_impl(\n         &self,\n         db: &impl HirDatabase,\n     ) -> Option<(FileId, TreeArc<ast::Module>)> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        let link = loc.module_id.parent_link(&module_tree)?;\n+        let module_tree = db.module_tree(self.krate);\n+        let link = self.module_id.parent_link(&module_tree)?;\n         let file_id = link\n             .owner(&module_tree)\n             .source(&module_tree)\n@@ -71,85 +51,67 @@ impl Module {\n         db: &impl HirDatabase,\n         import: ImportId,\n     ) -> TreeArc<ast::PathSegment> {\n-        let loc = self.def_id.loc(db);\n-        let source_map = db.lower_module_source_map(loc.source_root_id, loc.module_id);\n+        let source_map = db.lower_module_source_map(self.clone());\n         let (_, source) = self.definition_source(db);\n         source_map.get(&source, import)\n     }\n \n-    pub(crate) fn krate_impl(&self, db: &impl HirDatabase) -> Option<Crate> {\n-        let root = self.crate_root(db);\n-        let loc = root.def_id.loc(db);\n-        let file_id = loc.source_item_id.file_id.as_original_file();\n-\n-        let crate_graph = db.crate_graph();\n-        let crate_id = crate_graph.crate_id_for_crate_root(file_id)?;\n-        Some(Crate::new(crate_id))\n+    pub(crate) fn krate_impl(&self, _db: &impl HirDatabase) -> Option<Crate> {\n+        Some(Crate::new(self.krate))\n     }\n \n     pub(crate) fn crate_root_impl(&self, db: &impl HirDatabase) -> Module {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        let module_id = loc.module_id.crate_root(&module_tree);\n-        Module::from_module_id(db, loc.source_root_id, module_id)\n+        let module_tree = db.module_tree(self.krate);\n+        let module_id = self.module_id.crate_root(&module_tree);\n+        self.with_module_id(module_id)\n     }\n \n     /// Finds a child module with the specified name.\n     pub(crate) fn child_impl(&self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        let child_id = loc.module_id.child(&module_tree, name)?;\n-        Some(Module::from_module_id(db, loc.source_root_id, child_id))\n+        let module_tree = db.module_tree(self.krate);\n+        let child_id = self.module_id.child(&module_tree, name)?;\n+        Some(self.with_module_id(child_id))\n     }\n \n     /// Iterates over all child modules.\n     pub(crate) fn children_impl(&self, db: &impl HirDatabase) -> impl Iterator<Item = Module> {\n-        // FIXME this should be implementable without collecting into a vec, but\n-        // it's kind of hard since the iterator needs to keep a reference to the\n-        // module tree.\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        let children = loc\n+        let module_tree = db.module_tree(self.krate);\n+        let children = self\n             .module_id\n             .children(&module_tree)\n-            .map(|(_, module_id)| Module::from_module_id(db, loc.source_root_id, module_id))\n+            .map(|(_, module_id)| self.with_module_id(module_id))\n             .collect::<Vec<_>>();\n         children.into_iter()\n     }\n \n     pub(crate) fn parent_impl(&self, db: &impl HirDatabase) -> Option<Module> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        let parent_id = loc.module_id.parent(&module_tree)?;\n-        Some(Module::from_module_id(db, loc.source_root_id, parent_id))\n+        let module_tree = db.module_tree(self.krate);\n+        let parent_id = self.module_id.parent(&module_tree)?;\n+        Some(self.with_module_id(parent_id))\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n     pub(crate) fn scope_impl(&self, db: &impl HirDatabase) -> ModuleScope {\n-        let loc = self.def_id.loc(db);\n-        let item_map = db.item_map(loc.source_root_id);\n-        item_map.per_module[&loc.module_id].clone()\n+        let item_map = db.item_map(self.krate);\n+        item_map.per_module[&self.module_id].clone()\n     }\n \n-    pub(crate) fn resolve_path_impl(&self, db: &impl HirDatabase, path: &Path) -> PerNs<DefId> {\n-        let mut curr_per_ns = PerNs::types(\n-            match path.kind {\n-                PathKind::Crate => self.crate_root(db),\n-                PathKind::Self_ | PathKind::Plain => self.clone(),\n-                PathKind::Super => {\n-                    if let Some(p) = self.parent(db) {\n-                        p\n-                    } else {\n-                        return PerNs::none();\n-                    }\n-                }\n-                PathKind::Abs => {\n-                    // TODO: absolute use is not supported\n+    pub(crate) fn resolve_path_impl(&self, db: &impl HirDatabase, path: &Path) -> PerNs<ModuleDef> {\n+        let mut curr_per_ns: PerNs<ModuleDef> = PerNs::types(match path.kind {\n+            PathKind::Crate => self.crate_root(db).into(),\n+            PathKind::Self_ | PathKind::Plain => self.clone().into(),\n+            PathKind::Super => {\n+                if let Some(p) = self.parent(db) {\n+                    p.into()\n+                } else {\n                     return PerNs::none();\n                 }\n             }\n-            .def_id,\n-        );\n+            PathKind::Abs => {\n+                // TODO: absolute use is not supported\n+                return PerNs::none();\n+            }\n+        });\n \n         for segment in path.segments.iter() {\n             let curr = match curr_per_ns.as_ref().take_types() {\n@@ -164,23 +126,24 @@ impl Module {\n                 }\n             };\n             // resolve segment in curr\n-            curr_per_ns = match curr.resolve(db) {\n-                Def::Module(m) => {\n+\n+            curr_per_ns = match curr {\n+                ModuleDef::Module(m) => {\n                     let scope = m.scope(db);\n                     match scope.get(&segment.name) {\n-                        Some(r) => r.def_id,\n+                        Some(r) => r.def_id.clone(),\n                         None => PerNs::none(),\n                     }\n                 }\n-                Def::Enum(e) => {\n+                ModuleDef::Enum(e) => {\n                     // enum variant\n                     let matching_variant = e\n                         .variants(db)\n                         .into_iter()\n                         .find(|(n, _variant)| n == &segment.name);\n \n                     match matching_variant {\n-                        Some((_n, variant)) => PerNs::both(variant.def_id(), e.def_id()),\n+                        Some((_n, variant)) => PerNs::both(variant.into(), (*e).into()),\n                         None => PerNs::none(),\n                     }\n                 }\n@@ -199,8 +162,7 @@ impl Module {\n         &self,\n         db: &impl HirDatabase,\n     ) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        loc.module_id.problems(&module_tree, db)\n+        let module_tree = db.module_tree(self.krate);\n+        self.module_id.problems(&module_tree, db)\n     }\n }"}, {"sha": "5304f5d31348ab7415eb9936c780e3de5ca40b30", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 25, "deletions": 40, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -1,20 +1,21 @@\n use std::sync::Arc;\n \n use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n-use ra_db::{SourceRootId, SyntaxDatabase, salsa};\n+use ra_db::{SyntaxDatabase, CrateId, salsa};\n \n use crate::{\n-    HirInterner, DefId, MacroCallId, Name, HirFileId,\n-    SourceFileItems, SourceItemId, Crate,\n+    MacroCallId, Name, HirFileId,\n+    SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n     query_definitions,\n-    FnSignature, FnScopes,\n+    Function, FnSignature, FnScopes,\n+    Struct, Enum, EnumVariant,\n     macros::MacroExpansion,\n-    module_tree::{ModuleId, ModuleTree},\n+    module_tree::ModuleTree,\n     nameres::{ItemMap, lower::{LoweredModule, ImportSourceMap}},\n-    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks},\n+    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, VariantDef},\n     adt::{StructData, EnumData, EnumVariantData},\n     impl_block::ModuleImplBlocks,\n-    generics::GenericParams,\n+    generics::{GenericParams, GenericDef},\n };\n \n #[salsa::query_group]\n@@ -26,25 +27,25 @@ pub trait HirDatabase: SyntaxDatabase + AsRef<HirInterner> {\n     fn expand_macro_invocation(&self, invoc: MacroCallId) -> Option<Arc<MacroExpansion>>;\n \n     #[salsa::invoke(query_definitions::fn_scopes)]\n-    fn fn_scopes(&self, def_id: DefId) -> Arc<FnScopes>;\n+    fn fn_scopes(&self, func: Function) -> Arc<FnScopes>;\n \n     #[salsa::invoke(crate::adt::StructData::struct_data_query)]\n-    fn struct_data(&self, def_id: DefId) -> Arc<StructData>;\n+    fn struct_data(&self, s: Struct) -> Arc<StructData>;\n \n     #[salsa::invoke(crate::adt::EnumData::enum_data_query)]\n-    fn enum_data(&self, def_id: DefId) -> Arc<EnumData>;\n+    fn enum_data(&self, e: Enum) -> Arc<EnumData>;\n \n     #[salsa::invoke(crate::adt::EnumVariantData::enum_variant_data_query)]\n-    fn enum_variant_data(&self, def_id: DefId) -> Arc<EnumVariantData>;\n+    fn enum_variant_data(&self, var: EnumVariant) -> Arc<EnumVariantData>;\n \n     #[salsa::invoke(crate::ty::infer)]\n-    fn infer(&self, def_id: DefId) -> Arc<InferenceResult>;\n+    fn infer(&self, func: Function) -> Arc<InferenceResult>;\n \n     #[salsa::invoke(crate::ty::type_for_def)]\n-    fn type_for_def(&self, def_id: DefId) -> Ty;\n+    fn type_for_def(&self, def: TypableDef) -> Ty;\n \n     #[salsa::invoke(crate::ty::type_for_field)]\n-    fn type_for_field(&self, def_id: DefId, field: Name) -> Option<Ty>;\n+    fn type_for_field(&self, def: VariantDef, field: Name) -> Option<Ty>;\n \n     #[salsa::invoke(query_definitions::file_items)]\n     fn file_items(&self, file_id: HirFileId) -> Arc<SourceFileItems>;\n@@ -56,51 +57,35 @@ pub trait HirDatabase: SyntaxDatabase + AsRef<HirInterner> {\n     fn submodules(&self, source: SourceItemId) -> Arc<Vec<crate::module_tree::Submodule>>;\n \n     #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_query)]\n-    fn lower_module(\n-        &self,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> (Arc<LoweredModule>, Arc<ImportSourceMap>);\n+    fn lower_module(&self, module: Module) -> (Arc<LoweredModule>, Arc<ImportSourceMap>);\n \n     #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_module_query)]\n-    fn lower_module_module(\n-        &self,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Arc<LoweredModule>;\n+    fn lower_module_module(&self, module: Module) -> Arc<LoweredModule>;\n \n     #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_source_map_query)]\n-    fn lower_module_source_map(\n-        &self,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Arc<ImportSourceMap>;\n+    fn lower_module_source_map(&self, module: Module) -> Arc<ImportSourceMap>;\n \n     #[salsa::invoke(query_definitions::item_map)]\n-    fn item_map(&self, source_root_id: SourceRootId) -> Arc<ItemMap>;\n+    fn item_map(&self, crate_id: CrateId) -> Arc<ItemMap>;\n \n     #[salsa::invoke(crate::module_tree::ModuleTree::module_tree_query)]\n-    fn module_tree(&self, source_root_id: SourceRootId) -> Arc<ModuleTree>;\n+    fn module_tree(&self, crate_id: CrateId) -> Arc<ModuleTree>;\n \n     #[salsa::invoke(crate::impl_block::impls_in_module)]\n-    fn impls_in_module(\n-        &self,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Arc<ModuleImplBlocks>;\n+    fn impls_in_module(&self, module: Module) -> Arc<ModuleImplBlocks>;\n \n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n     fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n \n     #[salsa::invoke(crate::expr::body_hir)]\n-    fn body_hir(&self, def_id: DefId) -> Arc<crate::expr::Body>;\n+    fn body_hir(&self, func: Function) -> Arc<crate::expr::Body>;\n \n     #[salsa::invoke(crate::expr::body_syntax_mapping)]\n-    fn body_syntax_mapping(&self, def_id: DefId) -> Arc<crate::expr::BodySyntaxMapping>;\n+    fn body_syntax_mapping(&self, func: Function) -> Arc<crate::expr::BodySyntaxMapping>;\n \n     #[salsa::invoke(crate::generics::GenericParams::generic_params_query)]\n-    fn generic_params(&self, def_id: DefId) -> Arc<GenericParams>;\n+    fn generic_params(&self, def: GenericDef) -> Arc<GenericParams>;\n \n     #[salsa::invoke(crate::FnSignature::fn_signature_query)]\n-    fn fn_signature(&self, def_id: DefId) -> Arc<FnSignature>;\n+    fn fn_signature(&self, func: Function) -> Arc<FnSignature>;\n }"}, {"sha": "29469af2cf3021f87bf0183f52f3fea10c6b9d6c", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -9,7 +9,11 @@ use ra_syntax::{\n     ast::{self, LoopBodyOwner, ArgListOwner, NameOwner, LiteralFlavor}\n };\n \n-use crate::{Path, type_ref::{Mutability, TypeRef}, Name, HirDatabase, DefId, Def, name::AsName};\n+use crate::{\n+    Path, Name, HirDatabase, Function,\n+    name::AsName,\n+    type_ref::{Mutability, TypeRef},\n+};\n use crate::ty::primitive::{UintTy, UncertainIntTy, UncertainFloatTy};\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -435,8 +439,8 @@ impl Pat {\n \n // Queries\n \n-pub(crate) fn body_hir(db: &impl HirDatabase, def_id: DefId) -> Arc<Body> {\n-    Arc::clone(&body_syntax_mapping(db, def_id).body)\n+pub(crate) fn body_hir(db: &impl HirDatabase, func: Function) -> Arc<Body> {\n+    Arc::clone(&body_syntax_mapping(db, func).body)\n }\n \n struct ExprCollector {\n@@ -955,14 +959,8 @@ pub(crate) fn collect_fn_body_syntax(node: &ast::FnDef) -> BodySyntaxMapping {\n     collector.into_body_syntax_mapping(params, body)\n }\n \n-pub(crate) fn body_syntax_mapping(db: &impl HirDatabase, def_id: DefId) -> Arc<BodySyntaxMapping> {\n-    let def = def_id.resolve(db);\n-\n-    let body_syntax_mapping = match def {\n-        Def::Function(f) => collect_fn_body_syntax(&f.source(db).1),\n-        // TODO: consts, etc.\n-        _ => panic!(\"Trying to get body for item type without body\"),\n-    };\n-\n+pub(crate) fn body_syntax_mapping(db: &impl HirDatabase, func: Function) -> Arc<BodySyntaxMapping> {\n+    let (_, fn_def) = func.source(db);\n+    let body_syntax_mapping = collect_fn_body_syntax(&fn_def);\n     Arc::new(body_syntax_mapping)\n }"}, {"sha": "64c20a462229342f7f678799cea13ad9b5b0c711", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -5,9 +5,9 @@\n \n use std::sync::Arc;\n \n-use ra_syntax::ast::{TypeParamList, AstNode, NameOwner};\n+use ra_syntax::ast::{self, NameOwner, TypeParamsOwner};\n \n-use crate::{db::HirDatabase, DefId, Name, AsName};\n+use crate::{db::HirDatabase, Name, AsName, Function, Struct, Enum, Trait, Type};\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -22,26 +22,53 @@ pub struct GenericParams {\n     pub(crate) params: Vec<GenericParam>,\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n+pub enum GenericDef {\n+    Function(Function),\n+    Struct(Struct),\n+    Enum(Enum),\n+    Trait(Trait),\n+    Type(Type),\n+}\n+impl_froms!(GenericDef: Function, Struct, Enum, Trait, Type);\n+\n impl GenericParams {\n-    pub(crate) fn generic_params_query(db: &impl HirDatabase, def_id: DefId) -> Arc<GenericParams> {\n-        let (_file_id, node) = def_id.source(db);\n+    pub(crate) fn generic_params_query(\n+        db: &impl HirDatabase,\n+        def: GenericDef,\n+    ) -> Arc<GenericParams> {\n         let mut generics = GenericParams::default();\n-        if let Some(type_param_list) = node.children().find_map(TypeParamList::cast) {\n-            for (idx, type_param) in type_param_list.type_params().enumerate() {\n-                let name = type_param\n-                    .name()\n-                    .map(AsName::as_name)\n-                    .unwrap_or_else(Name::missing);\n-                let param = GenericParam {\n-                    idx: idx as u32,\n-                    name,\n-                };\n-                generics.params.push(param);\n-            }\n+        match def {\n+            GenericDef::Function(it) => generics.fill(&*it.source(db).1),\n+            GenericDef::Struct(it) => generics.fill(&*it.source(db).1),\n+            GenericDef::Enum(it) => generics.fill(&*it.source(db).1),\n+            GenericDef::Trait(it) => generics.fill(&*it.source(db).1),\n+            GenericDef::Type(it) => generics.fill(&*it.source(db).1),\n         }\n+\n         Arc::new(generics)\n     }\n \n+    fn fill(&mut self, node: &impl TypeParamsOwner) {\n+        if let Some(params) = node.type_param_list() {\n+            self.fill_params(params)\n+        }\n+    }\n+\n+    fn fill_params(&mut self, params: &ast::TypeParamList) {\n+        for (idx, type_param) in params.type_params().enumerate() {\n+            let name = type_param\n+                .name()\n+                .map(AsName::as_name)\n+                .unwrap_or_else(Name::missing);\n+            let param = GenericParam {\n+                idx: idx as u32,\n+                name,\n+            };\n+            self.params.push(param);\n+        }\n+    }\n+\n     pub(crate) fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n         self.params.iter().find(|p| &p.name == name)\n     }"}, {"sha": "b125a151840aaf50bd32c62f3dae32f654528887", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 164, "deletions": 102, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -1,22 +1,41 @@\n-use ra_db::{SourceRootId, LocationIntener, FileId};\n+use std::{\n+    marker::PhantomData,\n+    hash::{Hash, Hasher},\n+};\n+\n+use ra_db::{LocationIntener, FileId};\n use ra_syntax::{TreeArc, SyntaxNode, SourceFile, AstNode, ast};\n-use ra_arena::{Arena, RawId, impl_arena_id};\n+use ra_arena::{Arena, RawId, ArenaId, impl_arena_id};\n \n use crate::{\n-    HirDatabase, Def, Function, Struct, Enum, EnumVariant, ImplBlock, Crate,\n-    Module, Trait, Type, Static, Const,\n-    module_tree::ModuleId,\n+    HirDatabase,\n+    Module,\n };\n \n #[derive(Debug, Default)]\n pub struct HirInterner {\n-    defs: LocationIntener<DefLoc, DefId>,\n     macros: LocationIntener<MacroCallLoc, MacroCallId>,\n+    fns: LocationIntener<ItemLoc<ast::FnDef>, FunctionId>,\n+    structs: LocationIntener<ItemLoc<ast::StructDef>, StructId>,\n+    enums: LocationIntener<ItemLoc<ast::EnumDef>, EnumId>,\n+    enum_variants: LocationIntener<ItemLoc<ast::EnumVariant>, EnumVariantId>,\n+    consts: LocationIntener<ItemLoc<ast::ConstDef>, ConstId>,\n+    statics: LocationIntener<ItemLoc<ast::StaticDef>, StaticId>,\n+    traits: LocationIntener<ItemLoc<ast::TraitDef>, TraitId>,\n+    types: LocationIntener<ItemLoc<ast::TypeDef>, TypeId>,\n }\n \n impl HirInterner {\n     pub fn len(&self) -> usize {\n-        self.defs.len() + self.macros.len()\n+        self.macros.len()\n+            + self.fns.len()\n+            + self.structs.len()\n+            + self.enums.len()\n+            + self.enum_variants.len()\n+            + self.consts.len()\n+            + self.statics.len()\n+            + self.traits.len()\n+            + self.types.len()\n     }\n }\n \n@@ -110,10 +129,9 @@ impl From<MacroCallId> for HirFileId {\n pub struct MacroCallId(RawId);\n impl_arena_id!(MacroCallId);\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCallLoc {\n-    pub(crate) source_root_id: SourceRootId,\n-    pub(crate) module_id: ModuleId,\n+    pub(crate) module: Module,\n     pub(crate) source_item_id: SourceItemId,\n }\n \n@@ -130,117 +148,161 @@ impl MacroCallLoc {\n     }\n }\n \n-/// Def's are a core concept of hir. A `Def` is an Item (function, module, etc)\n-/// in a specific module.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct DefId(RawId);\n-impl_arena_id!(DefId);\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct DefLoc {\n-    pub(crate) kind: DefKind,\n-    pub(crate) source_root_id: SourceRootId,\n-    pub(crate) module_id: ModuleId,\n-    pub(crate) source_item_id: SourceItemId,\n+#[derive(Debug)]\n+pub struct ItemLoc<N: AstNode> {\n+    pub(crate) module: Module,\n+    raw: SourceItemId,\n+    _ty: PhantomData<N>,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub(crate) enum DefKind {\n-    Module,\n-    Function,\n-    Struct,\n-    Enum,\n-    EnumVariant,\n-    Const,\n-    Static,\n-    Trait,\n-    Type,\n-    Item,\n-\n-    /// The constructor of a struct. E.g. if we have `struct Foo(usize)`, the\n-    /// name `Foo` needs to resolve to different types depending on whether we\n-    /// are in the types or values namespace: As a type, `Foo` of course refers\n-    /// to the struct `Foo`; as a value, `Foo` is a callable type with signature\n-    /// `(usize) -> Foo`. The cleanest approach to handle this seems to be to\n-    /// have different defs in the two namespaces.\n-    ///\n-    /// rustc does the same; note that it even creates a struct constructor if\n-    /// the struct isn't a tuple struct (see `CtorKind::Fictive` in rustc).\n-    StructCtor,\n+impl<N: AstNode> PartialEq for ItemLoc<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.module == other.module && self.raw == other.raw\n+    }\n+}\n+impl<N: AstNode> Eq for ItemLoc<N> {}\n+impl<N: AstNode> Hash for ItemLoc<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        self.module.hash(hasher);\n+        self.raw.hash(hasher);\n+    }\n }\n \n-impl DefId {\n-    pub(crate) fn loc(self, db: &impl AsRef<HirInterner>) -> DefLoc {\n-        db.as_ref().defs.id2loc(self)\n+impl<N: AstNode> Clone for ItemLoc<N> {\n+    fn clone(&self) -> ItemLoc<N> {\n+        ItemLoc {\n+            module: self.module,\n+            raw: self.raw,\n+            _ty: PhantomData,\n+        }\n     }\n+}\n \n-    pub fn resolve(self, db: &impl HirDatabase) -> Def {\n-        let loc = self.loc(db);\n-        match loc.kind {\n-            DefKind::Module => {\n-                let module = Module::from_module_id(db, loc.source_root_id, loc.module_id);\n-                Def::Module(module)\n-            }\n-            DefKind::Function => {\n-                let function = Function::new(self);\n-                Def::Function(function)\n-            }\n-            DefKind::Struct => {\n-                let struct_def = Struct::new(self);\n-                Def::Struct(struct_def)\n-            }\n-            DefKind::Enum => Def::Enum(Enum::new(self)),\n-            DefKind::EnumVariant => Def::EnumVariant(EnumVariant::new(self)),\n-            DefKind::Const => {\n-                let def = Const::new(self);\n-                Def::Const(def)\n-            }\n-            DefKind::Static => {\n-                let def = Static::new(self);\n-                Def::Static(def)\n-            }\n-            DefKind::Trait => {\n-                let def = Trait::new(self);\n-                Def::Trait(def)\n-            }\n-            DefKind::Type => {\n-                let def = Type::new(self);\n-                Def::Type(def)\n-            }\n+#[derive(Clone, Copy)]\n+pub(crate) struct LocationCtx<DB> {\n+    db: DB,\n+    module: Module,\n+    file_id: HirFileId,\n+}\n \n-            DefKind::StructCtor => Def::Item,\n-            DefKind::Item => Def::Item,\n+impl<'a, DB: HirDatabase> LocationCtx<&'a DB> {\n+    pub(crate) fn new(db: &'a DB, module: Module, file_id: HirFileId) -> LocationCtx<&'a DB> {\n+        LocationCtx {\n+            db,\n+            module,\n+            file_id,\n         }\n     }\n+    pub(crate) fn to_def<N, DEF>(self, ast: &N) -> DEF\n+    where\n+        N: AstNode,\n+        DEF: AstItemDef<N>,\n+    {\n+        DEF::from_ast(self, ast)\n+    }\n+}\n+\n+pub(crate) trait AstItemDef<N: AstNode>: ArenaId + Clone {\n+    fn interner(interner: &HirInterner) -> &LocationIntener<ItemLoc<N>, Self>;\n+    fn from_ast(ctx: LocationCtx<&impl HirDatabase>, ast: &N) -> Self {\n+        let items = ctx.db.file_items(ctx.file_id);\n+        let raw = SourceItemId {\n+            file_id: ctx.file_id,\n+            item_id: Some(items.id_of(ctx.file_id, ast.syntax())),\n+        };\n+        let loc = ItemLoc {\n+            module: ctx.module,\n+            raw,\n+            _ty: PhantomData,\n+        };\n+\n+        Self::interner(ctx.db.as_ref()).loc2id(&loc)\n+    }\n+    fn source(self, db: &impl HirDatabase) -> (HirFileId, TreeArc<N>) {\n+        let int = Self::interner(db.as_ref());\n+        let loc = int.id2loc(self);\n+        let syntax = db.file_item(loc.raw);\n+        let ast = N::cast(&syntax)\n+            .unwrap_or_else(|| panic!(\"invalid ItemLoc: {:?}\", loc.raw))\n+            .to_owned();\n+        (loc.raw.file_id, ast)\n+    }\n+    fn module(self, db: &impl HirDatabase) -> Module {\n+        let int = Self::interner(db.as_ref());\n+        let loc = int.id2loc(self);\n+        loc.module\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct FunctionId(RawId);\n+impl_arena_id!(FunctionId);\n+impl AstItemDef<ast::FnDef> for FunctionId {\n+    fn interner(interner: &HirInterner) -> &LocationIntener<ItemLoc<ast::FnDef>, Self> {\n+        &interner.fns\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct StructId(RawId);\n+impl_arena_id!(StructId);\n+impl AstItemDef<ast::StructDef> for StructId {\n+    fn interner(interner: &HirInterner) -> &LocationIntener<ItemLoc<ast::StructDef>, Self> {\n+        &interner.structs\n+    }\n+}\n \n-    pub(crate) fn source(self, db: &impl HirDatabase) -> (HirFileId, TreeArc<SyntaxNode>) {\n-        let loc = self.loc(db);\n-        let syntax = db.file_item(loc.source_item_id);\n-        (loc.source_item_id.file_id, syntax)\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct EnumId(RawId);\n+impl_arena_id!(EnumId);\n+impl AstItemDef<ast::EnumDef> for EnumId {\n+    fn interner(interner: &HirInterner) -> &LocationIntener<ItemLoc<ast::EnumDef>, Self> {\n+        &interner.enums\n     }\n+}\n \n-    /// For a module, returns that module; for any other def, returns the containing module.\n-    pub fn module(self, db: &impl HirDatabase) -> Module {\n-        let loc = self.loc(db);\n-        Module::from_module_id(db, loc.source_root_id, loc.module_id)\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct EnumVariantId(RawId);\n+impl_arena_id!(EnumVariantId);\n+impl AstItemDef<ast::EnumVariant> for EnumVariantId {\n+    fn interner(interner: &HirInterner) -> &LocationIntener<ItemLoc<ast::EnumVariant>, Self> {\n+        &interner.enum_variants\n     }\n+}\n \n-    /// Returns the containing crate.\n-    pub fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ConstId(RawId);\n+impl_arena_id!(ConstId);\n+impl AstItemDef<ast::ConstDef> for ConstId {\n+    fn interner(interner: &HirInterner) -> &LocationIntener<ItemLoc<ast::ConstDef>, Self> {\n+        &interner.consts\n     }\n+}\n \n-    /// Returns the containing impl block, if this is an impl item.\n-    pub fn impl_block(self, db: &impl HirDatabase) -> Option<ImplBlock> {\n-        let loc = self.loc(db);\n-        let module_impls = db.impls_in_module(loc.source_root_id, loc.module_id);\n-        ImplBlock::containing(module_impls, self)\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct StaticId(RawId);\n+impl_arena_id!(StaticId);\n+impl AstItemDef<ast::StaticDef> for StaticId {\n+    fn interner(interner: &HirInterner) -> &LocationIntener<ItemLoc<ast::StaticDef>, Self> {\n+        &interner.statics\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TraitId(RawId);\n+impl_arena_id!(TraitId);\n+impl AstItemDef<ast::TraitDef> for TraitId {\n+    fn interner(interner: &HirInterner) -> &LocationIntener<ItemLoc<ast::TraitDef>, Self> {\n+        &interner.traits\n     }\n }\n \n-impl DefLoc {\n-    pub(crate) fn id(&self, db: &impl AsRef<HirInterner>) -> DefId {\n-        db.as_ref().defs.loc2id(&self)\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TypeId(RawId);\n+impl_arena_id!(TypeId);\n+impl AstItemDef<ast::TypeDef> for TypeId {\n+    fn interner(interner: &HirInterner) -> &LocationIntener<ItemLoc<ast::TypeDef>, Self> {\n+        &interner.types\n     }\n }\n "}, {"sha": "222e4734916423ae1ee0a64cd8505653d9ceaf27", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 30, "deletions": 54, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -3,14 +3,13 @@ use rustc_hash::FxHashMap;\n \n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_syntax::ast::{self, AstNode};\n-use ra_db::{SourceRootId};\n \n use crate::{\n-    DefId, DefLoc, DefKind, SourceItemId, SourceFileItems,\n-    Function, HirInterner,\n+    Const, Type,\n+    Function, HirFileId,\n     db::HirDatabase,\n     type_ref::TypeRef,\n-    module_tree::ModuleId,\n+    ids::LocationCtx,\n };\n \n use crate::code_model_api::{Module, ModuleSource};\n@@ -24,9 +23,9 @@ pub struct ImplBlock {\n impl ImplBlock {\n     pub(crate) fn containing(\n         module_impl_blocks: Arc<ModuleImplBlocks>,\n-        def_id: DefId,\n+        item: ImplItem,\n     ) -> Option<ImplBlock> {\n-        let impl_id = *module_impl_blocks.impls_by_def.get(&def_id)?;\n+        let impl_id = *module_impl_blocks.impls_by_def.get(&item)?;\n         Some(ImplBlock {\n             module_impl_blocks,\n             impl_id,\n@@ -66,39 +65,25 @@ pub struct ImplData {\n \n impl ImplData {\n     pub(crate) fn from_ast(\n-        db: &impl AsRef<HirInterner>,\n-        file_items: &SourceFileItems,\n-        module: &Module,\n+        db: &impl HirDatabase,\n+        file_id: HirFileId,\n+        module: Module,\n         node: &ast::ImplBlock,\n     ) -> Self {\n         let target_trait = node.target_trait().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(node.target_type());\n-        let module_loc = module.def_id.loc(db);\n+        let ctx = LocationCtx::new(db, module, file_id);\n         let items = if let Some(item_list) = node.item_list() {\n             item_list\n                 .impl_items()\n-                .map(|item_node| {\n-                    let kind = match item_node.kind() {\n-                        ast::ImplItemKind::FnDef(..) => DefKind::Function,\n-                        ast::ImplItemKind::ConstDef(..) => DefKind::Item,\n-                        ast::ImplItemKind::TypeDef(..) => DefKind::Item,\n-                    };\n-                    let item_id = file_items.id_of_unchecked(item_node.syntax());\n-                    let source_item_id = SourceItemId {\n-                        file_id: module_loc.source_item_id.file_id,\n-                        item_id: Some(item_id),\n-                    };\n-                    let def_loc = DefLoc {\n-                        kind,\n-                        source_item_id,\n-                        ..module_loc\n-                    };\n-                    let def_id = def_loc.id(db);\n-                    match item_node.kind() {\n-                        ast::ImplItemKind::FnDef(..) => ImplItem::Method(Function::new(def_id)),\n-                        ast::ImplItemKind::ConstDef(..) => ImplItem::Const(def_id),\n-                        ast::ImplItemKind::TypeDef(..) => ImplItem::Type(def_id),\n+                .map(|item_node| match item_node.kind() {\n+                    ast::ImplItemKind::FnDef(it) => {\n+                        ImplItem::Method(Function { id: ctx.to_def(it) })\n                     }\n+                    ast::ImplItemKind::ConstDef(it) => {\n+                        ImplItem::Const(Const { id: ctx.to_def(it) })\n+                    }\n+                    ast::ImplItemKind::TypeDef(it) => ImplItem::Type(Type { id: ctx.to_def(it) }),\n                 })\n                 .collect()\n         } else {\n@@ -124,22 +109,19 @@ impl ImplData {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+//TODO: rename to ImplDef?\n pub enum ImplItem {\n     Method(Function),\n-    // these don't have their own types yet\n-    Const(DefId),\n-    Type(DefId),\n+    Const(Const),\n+    Type(Type),\n     // Existential\n }\n+impl_froms!(ImplItem: Const, Type);\n \n-impl ImplItem {\n-    pub fn def_id(&self) -> DefId {\n-        match self {\n-            ImplItem::Method(f) => f.def_id(),\n-            ImplItem::Const(def_id) => *def_id,\n-            ImplItem::Type(def_id) => *def_id,\n-        }\n+impl From<Function> for ImplItem {\n+    fn from(func: Function) -> ImplItem {\n+        ImplItem::Method(func)\n     }\n }\n \n@@ -155,7 +137,7 @@ impl_arena_id!(ImplId);\n #[derive(Debug, PartialEq, Eq)]\n pub struct ModuleImplBlocks {\n     pub(crate) impls: Arena<ImplId, ImplData>,\n-    impls_by_def: FxHashMap<DefId, ImplId>,\n+    impls_by_def: FxHashMap<ImplItem, ImplId>,\n }\n \n impl ModuleImplBlocks {\n@@ -168,6 +150,7 @@ impl ModuleImplBlocks {\n \n     fn collect(&mut self, db: &impl HirDatabase, module: Module) {\n         let (file_id, module_source) = module.definition_source(db);\n+        let file_id: HirFileId = file_id.into();\n         let node = match &module_source {\n             ModuleSource::SourceFile(node) => node.syntax(),\n             ModuleSource::Module(node) => node\n@@ -176,25 +159,18 @@ impl ModuleImplBlocks {\n                 .syntax(),\n         };\n \n-        let source_file_items = db.file_items(file_id.into());\n-\n         for impl_block_ast in node.children().filter_map(ast::ImplBlock::cast) {\n-            let impl_block = ImplData::from_ast(db, &source_file_items, &module, impl_block_ast);\n+            let impl_block = ImplData::from_ast(db, file_id, module, impl_block_ast);\n             let id = self.impls.alloc(impl_block);\n-            for impl_item in &self.impls[id].items {\n-                self.impls_by_def.insert(impl_item.def_id(), id);\n+            for &impl_item in &self.impls[id].items {\n+                self.impls_by_def.insert(impl_item, id);\n             }\n         }\n     }\n }\n \n-pub(crate) fn impls_in_module(\n-    db: &impl HirDatabase,\n-    source_root_id: SourceRootId,\n-    module_id: ModuleId,\n-) -> Arc<ModuleImplBlocks> {\n+pub(crate) fn impls_in_module(db: &impl HirDatabase, module: Module) -> Arc<ModuleImplBlocks> {\n     let mut result = ModuleImplBlocks::new();\n-    let module = Module::from_module_id(db, source_root_id, module_id);\n     result.collect(db, module);\n     Arc::new(result)\n }"}, {"sha": "596f9c38c38eaac4b8cea7839cddc6c85f929f97", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -5,6 +5,18 @@\n //! to a particular crate instance. That is, it has cfg flags and features\n //! applied. So, the relation between syntax and HIR is many-to-one.\n \n+macro_rules! impl_froms {\n+    ($e:ident: $($v:ident), *) => {\n+        $(\n+            impl From<$v> for $e {\n+                fn from(it: $v) -> $e {\n+                    $e::$v(it)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n pub mod db;\n #[cfg(test)]\n mod mock;\n@@ -34,25 +46,26 @@ mod marks;\n use crate::{\n     db::HirDatabase,\n     name::{AsName, KnownName},\n-    ids::{DefKind, SourceItemId, SourceFileItems},\n+    ids::{SourceItemId, SourceFileItems},\n };\n \n pub use self::{\n     path::{Path, PathKind},\n     name::Name,\n-    ids::{HirFileId, DefId, DefLoc, MacroCallId, MacroCallLoc, HirInterner},\n+    ids::{HirFileId, MacroCallId, MacroCallLoc, HirInterner},\n     macros::{MacroDef, MacroInput, MacroExpansion},\n     nameres::{ItemMap, PerNs, Namespace, Resolution},\n     ty::Ty,\n     impl_block::{ImplBlock, ImplItem},\n     code_model_impl::function::{FnScopes, ScopesWithSyntaxMapping},\n-    docs::{Docs, Documentation}\n+    docs::{Docs, Documentation},\n+    adt::AdtDef,\n };\n \n pub use self::code_model_api::{\n     Crate, CrateDependency,\n     Def,\n-    Module, ModuleSource, Problem,\n+    Module, ModuleDef, ModuleSource, Problem,\n     Struct, Enum, EnumVariant,\n     Function, FnSignature, ScopeEntryWithSyntax,\n     StructField,"}, {"sha": "361366f6a1d462961192f0b21e49e64fc4915162", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -35,10 +35,6 @@ impl MockDatabase {\n         let file_id = db.add_file(WORKSPACE, &mut source_root, \"/main.rs\", text);\n         db.query_mut(ra_db::SourceRootQuery)\n             .set(WORKSPACE, Arc::new(source_root.clone()));\n-\n-        let mut crate_graph = CrateGraph::default();\n-        crate_graph.add_crate_root(file_id);\n-        db.set_crate_graph(crate_graph);\n         (db, source_root, file_id)\n     }\n \n@@ -97,6 +93,8 @@ impl MockDatabase {\n         text: &str,\n     ) -> FileId {\n         assert!(path.starts_with('/'));\n+        let is_crate_root = path == \"/lib.rs\" || path == \"/main.rs\";\n+\n         let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n         let file_id = FileId(self.file_counter);\n         self.file_counter += 1;\n@@ -107,6 +105,12 @@ impl MockDatabase {\n         self.query_mut(ra_db::FileSourceRootQuery)\n             .set(file_id, source_root_id);\n         source_root.files.insert(path, file_id);\n+\n+        if is_crate_root {\n+            let mut crate_graph = CrateGraph::default();\n+            crate_graph.add_crate_root(file_id);\n+            self.set_crate_graph(crate_graph);\n+        }\n         file_id\n     }\n \n@@ -202,6 +206,7 @@ salsa::database_storage! {\n             fn file_relative_path() for ra_db::FileRelativePathQuery;\n             fn file_source_root() for ra_db::FileSourceRootQuery;\n             fn source_root() for ra_db::SourceRootQuery;\n+            fn source_root_crates() for ra_db::SourceRootCratesQuery;\n             fn local_roots() for ra_db::LocalRootsQuery;\n             fn library_roots() for ra_db::LibraryRootsQuery;\n             fn crate_graph() for ra_db::CrateGraphQuery;"}, {"sha": "c00834c4c1206887eaf11204348a867883df9a90", "filename": "crates/ra_hir/src/module_tree.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n use rustc_hash::{FxHashMap, FxHashSet};\n use arrayvec::ArrayVec;\n use relative_path::RelativePathBuf;\n-use ra_db::{FileId, SourceRootId, SourceRoot};\n+use ra_db::{FileId, SourceRoot, CrateId};\n use ra_syntax::{\n     SyntaxNode, TreeArc,\n     algo::generate,\n@@ -126,13 +126,10 @@ struct LinkData {\n }\n \n impl ModuleTree {\n-    pub(crate) fn module_tree_query(\n-        db: &impl HirDatabase,\n-        source_root: SourceRootId,\n-    ) -> Arc<ModuleTree> {\n+    pub(crate) fn module_tree_query(db: &impl HirDatabase, crate_id: CrateId) -> Arc<ModuleTree> {\n         db.check_canceled();\n         let mut res = ModuleTree::default();\n-        res.init(db, source_root);\n+        res.init_crate(db, crate_id);\n         Arc::new(res)\n     }\n \n@@ -145,24 +142,21 @@ impl ModuleTree {\n         Some(res)\n     }\n \n-    fn init(&mut self, db: &impl HirDatabase, source_root: SourceRootId) {\n+    fn init_crate(&mut self, db: &impl HirDatabase, crate_id: CrateId) {\n+        let crate_graph = db.crate_graph();\n+        let file_id = crate_graph.crate_root(crate_id);\n+        let source_root_id = db.file_source_root(file_id);\n+\n         let mut roots = FxHashMap::default();\n         let mut visited = FxHashSet::default();\n \n-        let source_root = db.source_root(source_root);\n-        for &file_id in source_root.files.values() {\n-            let source = SourceItemId {\n-                file_id: file_id.into(),\n-                item_id: None,\n-            };\n-            if visited.contains(&source) {\n-                continue; // TODO: use explicit crate_roots here\n-            }\n-            assert!(!roots.contains_key(&file_id));\n-            let module_id =\n-                self.init_subtree(db, &source_root, &mut visited, &mut roots, None, source);\n-            roots.insert(file_id, module_id);\n-        }\n+        let source_root = db.source_root(source_root_id);\n+        let source = SourceItemId {\n+            file_id: file_id.into(),\n+            item_id: None,\n+        };\n+        let module_id = self.init_subtree(db, &source_root, &mut visited, &mut roots, None, source);\n+        roots.insert(file_id, module_id);\n     }\n \n     fn init_subtree("}, {"sha": "a3bc989580ad1cedbef59a74fdfb5b302a57ccaf", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -16,19 +16,19 @@\n //! structure itself is modified.\n pub(crate) mod lower;\n \n-use crate::nameres::lower::*;\n-\n use std::sync::Arc;\n \n+use ra_db::CrateId;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use ra_db::SourceRootId;\n \n use crate::{\n-    DefId, DefLoc, DefKind,\n+    Module, ModuleDef,\n     Path, PathKind,\n     HirDatabase, Crate,\n     Name,\n     module_tree::{ModuleId, ModuleTree},\n+//FIXME: deglobify\n+    nameres::lower::*,\n };\n \n /// `ItemMap` is the result of name resolution. It contains, for each\n@@ -58,7 +58,7 @@ impl ModuleScope {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Resolution {\n     /// None for unresolved\n-    pub def_id: PerNs<DefId>,\n+    pub def_id: PerNs<ModuleDef>,\n     /// ident by which this is imported into local scope.\n     pub import: Option<ImportId>,\n }\n@@ -152,7 +152,7 @@ impl<T> PerNs<T> {\n pub(crate) struct Resolver<'a, DB> {\n     db: &'a DB,\n     input: &'a FxHashMap<ModuleId, Arc<LoweredModule>>,\n-    source_root: SourceRootId,\n+    krate: CrateId,\n     module_tree: Arc<ModuleTree>,\n     processed_imports: FxHashSet<(ModuleId, ImportId)>,\n     result: ItemMap,\n@@ -165,13 +165,13 @@ where\n     pub(crate) fn new(\n         db: &'a DB,\n         input: &'a FxHashMap<ModuleId, Arc<LoweredModule>>,\n-        source_root: SourceRootId,\n-        module_tree: Arc<ModuleTree>,\n+        krate: CrateId,\n     ) -> Resolver<'a, DB> {\n+        let module_tree = db.module_tree(krate);\n         Resolver {\n             db,\n             input,\n-            source_root,\n+            krate,\n             module_tree,\n             processed_imports: FxHashSet::default(),\n             result: ItemMap::default(),\n@@ -210,7 +210,7 @@ where\n                 let krate = Crate::new(crate_id);\n                 for dep in krate.dependencies(self.db) {\n                     if let Some(module) = dep.krate.root_module(self.db) {\n-                        let def_id = module.def_id;\n+                        let def_id = module.into();\n                         self.add_module_item(\n                             &mut module_items,\n                             dep.name.clone(),\n@@ -244,20 +244,22 @@ where\n \n         // Populate modules\n         for (name, module_id) in module_id.children(&self.module_tree) {\n-            let def_loc = DefLoc {\n-                kind: DefKind::Module,\n-                source_root_id: self.source_root,\n+            let module = Module {\n                 module_id,\n-                source_item_id: module_id.source(&self.module_tree),\n+                krate: self.krate,\n             };\n-            let def_id = def_loc.id(self.db);\n-            self.add_module_item(&mut module_items, name, PerNs::types(def_id));\n+            self.add_module_item(&mut module_items, name, PerNs::types(module.into()));\n         }\n \n         self.result.per_module.insert(module_id, module_items);\n     }\n \n-    fn add_module_item(&self, module_items: &mut ModuleScope, name: Name, def_id: PerNs<DefId>) {\n+    fn add_module_item(\n+        &self,\n+        module_items: &mut ModuleScope,\n+        name: Name,\n+        def_id: PerNs<ModuleDef>,\n+    ) {\n         let resolution = Resolution {\n             def_id,\n             import: None,\n@@ -329,17 +331,11 @@ where\n                     );\n                     return false;\n                 };\n-                curr = match type_def_id.loc(self.db) {\n-                    DefLoc {\n-                        kind: DefKind::Module,\n-                        module_id: target_module_id,\n-                        source_root_id,\n-                        ..\n-                    } => {\n-                        if source_root_id == self.source_root {\n-                            target_module_id\n+                curr = match type_def_id {\n+                    ModuleDef::Module(module) => {\n+                        if module.krate == self.krate {\n+                            module.module_id\n                         } else {\n-                            let module = crate::code_model_api::Module::new(type_def_id);\n                             let path = Path {\n                                 segments: import.path.segments[i + 1..].iter().cloned().collect(),\n                                 kind: PathKind::Crate,\n@@ -359,7 +355,7 @@ where\n                                     \"resolved import {:?} ({:?}) cross-source root to {:?}\",\n                                     last_segment.name,\n                                     import,\n-                                    def_id.map(|did| did.loc(self.db))\n+                                    def_id,\n                                 );\n                                 return true;\n                             } else {\n@@ -372,7 +368,7 @@ where\n                         log::debug!(\n                             \"path segment {:?} resolved to non-module {:?}, but is not last\",\n                             segment.name,\n-                            type_def_id.loc(self.db)\n+                            type_def_id,\n                         );\n                         return true; // this resolved to a non-module, so the path won't ever resolve\n                     }\n@@ -382,7 +378,7 @@ where\n                     \"resolved import {:?} ({:?}) within source root to {:?}\",\n                     segment.name,\n                     import,\n-                    def_id.map(|did| did.loc(self.db))\n+                    def_id,\n                 );\n                 self.update(module_id, |items| {\n                     let res = Resolution {"}, {"sha": "b4fe99ea7085340b29519ec748cd7338eee8537f", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 71, "deletions": 107, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -1,17 +1,17 @@\n use std::sync::Arc;\n \n use ra_syntax::{\n-    SyntaxKind, AstNode, SourceFile, TreeArc, AstPtr,\n+    AstNode, SourceFile, TreeArc, AstPtr,\n     ast::{self, ModuleItemOwner, NameOwner},\n };\n-use ra_db::SourceRootId;\n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    SourceItemId, Path, ModuleSource, HirDatabase, Name, SourceFileItems,\n-    HirFileId, MacroCallLoc, AsName, PerNs, DefId, DefKind, DefLoc,\n-    module_tree::ModuleId\n+    SourceItemId, Path, ModuleSource, HirDatabase, Name,\n+    HirFileId, MacroCallLoc, AsName, PerNs, Function,\n+    ModuleDef, Module, Struct, Enum, Const, Static, Trait, Type,\n+    ids::LocationCtx,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -32,7 +32,7 @@ pub(super) struct ImportData {\n /// can avoid redoing name resolution.\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct LoweredModule {\n-    pub(crate) declarations: FxHashMap<Name, PerNs<DefId>>,\n+    pub(crate) declarations: FxHashMap<Name, PerNs<ModuleDef>>,\n     pub(super) imports: Arena<ImportId, ImportData>,\n }\n \n@@ -59,37 +59,31 @@ impl ImportSourceMap {\n impl LoweredModule {\n     pub(crate) fn lower_module_module_query(\n         db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n+        module: Module,\n     ) -> Arc<LoweredModule> {\n-        db.lower_module(source_root_id, module_id).0\n+        db.lower_module(module).0\n     }\n \n     pub(crate) fn lower_module_source_map_query(\n         db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n+        module: Module,\n     ) -> Arc<ImportSourceMap> {\n-        db.lower_module(source_root_id, module_id).1\n+        db.lower_module(module).1\n     }\n \n     pub(crate) fn lower_module_query(\n         db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n+        module: Module,\n     ) -> (Arc<LoweredModule>, Arc<ImportSourceMap>) {\n-        let module_tree = db.module_tree(source_root_id);\n-        let source = module_id.source(&module_tree);\n-        let file_id = source.file_id;\n-        let source = ModuleSource::from_source_item_id(db, source);\n+        let (file_id, source) = module.definition_source(db);\n+        let file_id: HirFileId = file_id.into();\n         let mut source_map = ImportSourceMap::default();\n         let mut res = LoweredModule::default();\n         match source {\n             ModuleSource::SourceFile(it) => res.fill(\n                 &mut source_map,\n                 db,\n-                source_root_id,\n-                module_id,\n+                module,\n                 file_id,\n                 &mut it.items_with_macros(),\n             ),\n@@ -98,8 +92,7 @@ impl LoweredModule {\n                     res.fill(\n                         &mut source_map,\n                         db,\n-                        source_root_id,\n-                        module_id,\n+                        module,\n                         file_id,\n                         &mut item_list.items_with_macros(),\n                     )\n@@ -113,8 +106,7 @@ impl LoweredModule {\n         &mut self,\n         source_map: &mut ImportSourceMap,\n         db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n+        module: Module,\n         file_id: HirFileId,\n         items: &mut Iterator<Item = ast::ItemOrMacro>,\n     ) {\n@@ -123,40 +115,22 @@ impl LoweredModule {\n         for item in items {\n             match item {\n                 ast::ItemOrMacro::Item(it) => {\n-                    self.add_def_id(\n-                        source_map,\n-                        db,\n-                        source_root_id,\n-                        module_id,\n-                        file_id,\n-                        &file_items,\n-                        it,\n-                    );\n+                    self.add_def_id(source_map, db, module, file_id, it);\n                 }\n                 ast::ItemOrMacro::Macro(macro_call) => {\n                     let item_id = file_items.id_of_unchecked(macro_call.syntax());\n                     let loc = MacroCallLoc {\n-                        source_root_id,\n-                        module_id,\n+                        module,\n                         source_item_id: SourceItemId {\n                             file_id,\n                             item_id: Some(item_id),\n                         },\n                     };\n                     let id = loc.id(db);\n                     let file_id = HirFileId::from(id);\n-                    let file_items = db.file_items(file_id);\n                     //FIXME: expand recursively\n                     for item in db.hir_source_file(file_id).items() {\n-                        self.add_def_id(\n-                            source_map,\n-                            db,\n-                            source_root_id,\n-                            module_id,\n-                            file_id,\n-                            &file_items,\n-                            item,\n-                        );\n+                        self.add_def_id(source_map, db, module, file_id, item);\n                     }\n                 }\n             }\n@@ -167,41 +141,74 @@ impl LoweredModule {\n         &mut self,\n         source_map: &mut ImportSourceMap,\n         db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n+        module: Module,\n         file_id: HirFileId,\n-        file_items: &SourceFileItems,\n         item: &ast::ModuleItem,\n     ) {\n-        let name = match item.kind() {\n-            ast::ModuleItemKind::StructDef(it) => it.name(),\n-            ast::ModuleItemKind::EnumDef(it) => it.name(),\n-            ast::ModuleItemKind::FnDef(it) => it.name(),\n-            ast::ModuleItemKind::TraitDef(it) => it.name(),\n-            ast::ModuleItemKind::TypeDef(it) => it.name(),\n+        let ctx = LocationCtx::new(db, module, file_id);\n+        match item.kind() {\n+            ast::ModuleItemKind::StructDef(it) => {\n+                if let Some(name) = it.name() {\n+                    let s = Struct { id: ctx.to_def(it) };\n+                    let s: ModuleDef = s.into();\n+                    self.declarations.insert(name.as_name(), PerNs::both(s, s));\n+                }\n+            }\n+            ast::ModuleItemKind::EnumDef(it) => {\n+                if let Some(name) = it.name() {\n+                    let e = Enum { id: ctx.to_def(it) };\n+                    let e: ModuleDef = e.into();\n+                    self.declarations.insert(name.as_name(), PerNs::types(e));\n+                }\n+            }\n+            ast::ModuleItemKind::FnDef(it) => {\n+                if let Some(name) = it.name() {\n+                    let func = Function { id: ctx.to_def(it) };\n+                    self.declarations\n+                        .insert(name.as_name(), PerNs::values(func.into()));\n+                }\n+            }\n+            ast::ModuleItemKind::TraitDef(it) => {\n+                if let Some(name) = it.name() {\n+                    let t = Trait { id: ctx.to_def(it) };\n+                    self.declarations\n+                        .insert(name.as_name(), PerNs::types(t.into()));\n+                }\n+            }\n+            ast::ModuleItemKind::TypeDef(it) => {\n+                if let Some(name) = it.name() {\n+                    let t = Type { id: ctx.to_def(it) };\n+                    self.declarations\n+                        .insert(name.as_name(), PerNs::types(t.into()));\n+                }\n+            }\n             ast::ModuleItemKind::ImplBlock(_) => {\n                 // impls don't define items\n-                return;\n             }\n             ast::ModuleItemKind::UseItem(it) => {\n                 self.add_use_item(source_map, it);\n-                return;\n             }\n             ast::ModuleItemKind::ExternCrateItem(_) => {\n                 // TODO\n-                return;\n             }\n-            ast::ModuleItemKind::ConstDef(it) => it.name(),\n-            ast::ModuleItemKind::StaticDef(it) => it.name(),\n+            ast::ModuleItemKind::ConstDef(it) => {\n+                if let Some(name) = it.name() {\n+                    let c = Const { id: ctx.to_def(it) };\n+                    self.declarations\n+                        .insert(name.as_name(), PerNs::values(c.into()));\n+                }\n+            }\n+            ast::ModuleItemKind::StaticDef(it) => {\n+                if let Some(name) = it.name() {\n+                    let s = Static { id: ctx.to_def(it) };\n+                    self.declarations\n+                        .insert(name.as_name(), PerNs::values(s.into()));\n+                }\n+            }\n             ast::ModuleItemKind::Module(_) => {\n                 // modules are handled separately direclty by nameres\n-                return;\n             }\n         };\n-        if let Some(name) = name {\n-            let def_id = assign_def_id(db, source_root_id, module_id, file_id, file_items, item);\n-            self.declarations.insert(name.as_name(), def_id);\n-        }\n     }\n \n     fn add_use_item(&mut self, source_map: &mut ImportSourceMap, item: &ast::UseItem) {\n@@ -216,46 +223,3 @@ impl LoweredModule {\n         })\n     }\n }\n-\n-fn assign_def_id(\n-    db: &impl HirDatabase,\n-    source_root_id: SourceRootId,\n-    module_id: ModuleId,\n-    file_id: HirFileId,\n-    file_items: &SourceFileItems,\n-    item: &ast::ModuleItem,\n-) -> PerNs<DefId> {\n-    // depending on the item kind, the location can define something in\n-    // the values namespace, the types namespace, or both\n-    let kind = DefKind::for_syntax_kind(item.syntax().kind());\n-    let def_id = kind.map(|k| {\n-        let item_id = file_items.id_of_unchecked(item.syntax());\n-        let def_loc = DefLoc {\n-            kind: k,\n-            source_root_id,\n-            module_id,\n-            source_item_id: SourceItemId {\n-                file_id,\n-                item_id: Some(item_id),\n-            },\n-        };\n-        def_loc.id(db)\n-    });\n-    def_id\n-}\n-\n-impl DefKind {\n-    fn for_syntax_kind(kind: SyntaxKind) -> PerNs<DefKind> {\n-        match kind {\n-            SyntaxKind::FN_DEF => PerNs::values(DefKind::Function),\n-            SyntaxKind::MODULE => PerNs::types(DefKind::Module),\n-            SyntaxKind::STRUCT_DEF => PerNs::both(DefKind::Struct, DefKind::StructCtor),\n-            SyntaxKind::ENUM_DEF => PerNs::types(DefKind::Enum),\n-            SyntaxKind::TRAIT_DEF => PerNs::types(DefKind::Trait),\n-            SyntaxKind::TYPE_DEF => PerNs::types(DefKind::Type),\n-            SyntaxKind::CONST_DEF => PerNs::values(DefKind::Const),\n-            SyntaxKind::STATIC_DEF => PerNs::values(DefKind::Static),\n-            _ => PerNs::none(),\n-        }\n-    }\n-}"}, {"sha": "9322bf08ce9735c4528fa5eae37bfb0c1f32348e", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -1,6 +1,6 @@\n use std::sync::Arc;\n \n-use ra_db::{FilesDatabase, CrateGraph, SourceRootId, salsa::Database};\n+use ra_db::{CrateGraph, SourceRootId, salsa::Database};\n use relative_path::RelativePath;\n use test_utils::{assert_eq_text, covers};\n \n@@ -13,10 +13,10 @@ use crate::{\n \n fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n     let (db, pos) = MockDatabase::with_position(fixture);\n-    let source_root = db.file_source_root(pos.file_id);\n     let module = crate::source_binder::module_from_position(&db, pos).unwrap();\n-    let module_id = module.def_id.loc(&db).module_id;\n-    (db.item_map(source_root), module_id)\n+    let krate = module.krate(&db).unwrap();\n+    let module_id = module.module_id;\n+    (db.item_map(krate.crate_id), module_id)\n }\n \n fn check_module_item_map(map: &ItemMap, module_id: ModuleId, expected: &str) {\n@@ -238,14 +238,13 @@ fn item_map_across_crates() {\n \n     db.set_crate_graph(crate_graph);\n \n-    let source_root = db.file_source_root(main_id);\n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let module_id = module.def_id.loc(&db).module_id;\n-    let item_map = db.item_map(source_root);\n+    let krate = module.krate(&db).unwrap();\n+    let item_map = db.item_map(krate.crate_id);\n \n     check_module_item_map(\n         &item_map,\n-        module_id,\n+        module.module_id,\n         \"\n             Baz: t v\n             test_crate: t\n@@ -292,12 +291,12 @@ fn import_across_source_roots() {\n     db.set_crate_graph(crate_graph);\n \n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let module_id = module.def_id.loc(&db).module_id;\n-    let item_map = db.item_map(source_root);\n+    let krate = module.krate(&db).unwrap();\n+    let item_map = db.item_map(krate.crate_id);\n \n     check_module_item_map(\n         &item_map,\n-        module_id,\n+        module.module_id,\n         \"\n             C: t v\n             test_crate: t\n@@ -333,14 +332,13 @@ fn reexport_across_crates() {\n \n     db.set_crate_graph(crate_graph);\n \n-    let source_root = db.file_source_root(main_id);\n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let module_id = module.def_id.loc(&db).module_id;\n-    let item_map = db.item_map(source_root);\n+    let krate = module.krate(&db).unwrap();\n+    let item_map = db.item_map(krate.crate_id);\n \n     check_module_item_map(\n         &item_map,\n-        module_id,\n+        module.module_id,\n         \"\n             Baz: t v\n             test_crate: t\n@@ -350,10 +348,11 @@ fn reexport_across_crates() {\n \n fn check_item_map_is_not_recomputed(initial: &str, file_change: &str) {\n     let (mut db, pos) = MockDatabase::with_position(initial);\n-    let source_root = db.file_source_root(pos.file_id);\n+    let module = crate::source_binder::module_from_file_id(&db, pos.file_id).unwrap();\n+    let krate = module.krate(&db).unwrap();\n     {\n         let events = db.log_executed(|| {\n-            db.item_map(source_root);\n+            db.item_map(krate.crate_id);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n     }\n@@ -362,7 +361,7 @@ fn check_item_map_is_not_recomputed(initial: &str, file_change: &str) {\n \n     {\n         let events = db.log_executed(|| {\n-            db.item_map(source_root);\n+            db.item_map(krate.crate_id);\n         });\n         assert!(\n             !format!(\"{:?}\", events).contains(\"item_map\"),"}, {"sha": "cf8c7e4354580e53d6264c0675903813be0cecf3", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -7,17 +7,17 @@ use rustc_hash::FxHashMap;\n use ra_syntax::{\n     AstNode, SyntaxNode, TreeArc,\n };\n-use ra_db::SourceRootId;\n+use ra_db::{CrateId};\n \n use crate::{\n-    SourceFileItems, SourceItemId, DefId, HirFileId,\n-    FnScopes,\n+    SourceFileItems, SourceItemId, HirFileId,\n+    Function, FnScopes, Module,\n     db::HirDatabase,\n     nameres::{ItemMap, Resolver},\n };\n \n-pub(super) fn fn_scopes(db: &impl HirDatabase, def_id: DefId) -> Arc<FnScopes> {\n-    let body = db.body_hir(def_id);\n+pub(super) fn fn_scopes(db: &impl HirDatabase, func: Function) -> Arc<FnScopes> {\n+    let body = db.body_hir(func);\n     let res = FnScopes::new(body);\n     Arc::new(res)\n }\n@@ -41,15 +41,23 @@ pub(super) fn file_item(\n     }\n }\n \n-pub(super) fn item_map(db: &impl HirDatabase, source_root: SourceRootId) -> Arc<ItemMap> {\n+pub(super) fn item_map(db: &impl HirDatabase, crate_id: CrateId) -> Arc<ItemMap> {\n     let start = Instant::now();\n-    let module_tree = db.module_tree(source_root);\n+    let module_tree = db.module_tree(crate_id);\n     let input = module_tree\n         .modules()\n-        .map(|id| (id, db.lower_module_module(source_root, id)))\n+        .map(|module_id| {\n+            (\n+                module_id,\n+                db.lower_module_module(Module {\n+                    krate: crate_id,\n+                    module_id,\n+                }),\n+            )\n+        })\n         .collect::<FxHashMap<_, _>>();\n \n-    let resolver = Resolver::new(db, &input, source_root, module_tree);\n+    let resolver = Resolver::new(db, &input, crate_id);\n     let res = resolver.resolve();\n     let elapsed = start.elapsed();\n     log::info!(\"item_map: {:?}\", elapsed);"}, {"sha": "dbe040805e8cee5bb3430d58c2e9d51c53985f66", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -13,8 +13,9 @@ use ra_syntax::{\n };\n \n use crate::{\n-    HirDatabase, Function, SourceItemId,\n-    DefKind, DefLoc, AsName, Module,\n+    HirDatabase, Function, SourceItemId, ModuleDef,\n+    AsName, Module,\n+    ids::LocationCtx,\n };\n \n /// Locates the module by `FileId`. Picks topmost module in the file.\n@@ -84,9 +85,13 @@ pub fn module_from_child_node(\n \n fn module_from_source(db: &impl HirDatabase, source: SourceItemId) -> Option<Module> {\n     let source_root_id = db.file_source_root(source.file_id.as_original_file());\n-    let module_tree = db.module_tree(source_root_id);\n-    let module_id = module_tree.find_module_by_source(source)?;\n-    Some(Module::from_module_id(db, source_root_id, module_id))\n+    db.source_root_crates(source_root_id)\n+        .iter()\n+        .find_map(|&krate| {\n+            let module_tree = db.module_tree(krate);\n+            let module_id = module_tree.find_module_by_source(source)?;\n+            Some(Module { krate, module_id })\n+        })\n }\n \n pub fn function_from_position(db: &impl HirDatabase, position: FilePosition) -> Option<Function> {\n@@ -101,30 +106,21 @@ pub fn function_from_source(\n     fn_def: &ast::FnDef,\n ) -> Option<Function> {\n     let module = module_from_child_node(db, file_id, fn_def.syntax())?;\n-    let res = function_from_module(db, &module, fn_def);\n+    let res = function_from_module(db, module, fn_def);\n     Some(res)\n }\n \n pub fn function_from_module(\n     db: &impl HirDatabase,\n-    module: &Module,\n+    module: Module,\n     fn_def: &ast::FnDef,\n ) -> Function {\n-    let loc = module.def_id.loc(db);\n-    let file_id = loc.source_item_id.file_id;\n-    let file_items = db.file_items(file_id);\n-    let item_id = file_items.id_of(file_id, fn_def.syntax());\n-    let source_item_id = SourceItemId {\n-        file_id,\n-        item_id: Some(item_id),\n-    };\n-    let def_loc = DefLoc {\n-        kind: DefKind::Function,\n-        source_root_id: loc.source_root_id,\n-        module_id: loc.module_id,\n-        source_item_id,\n-    };\n-    Function::new(def_loc.id(db))\n+    let (file_id, _) = module.definition_source(db);\n+    let file_id = file_id.into();\n+    let ctx = LocationCtx::new(db, module, file_id);\n+    Function {\n+        id: ctx.to_def(fn_def),\n+    }\n }\n \n pub fn function_from_child_node(\n@@ -141,15 +137,18 @@ pub fn macro_symbols(db: &impl HirDatabase, file_id: FileId) -> Vec<(SmolStr, Te\n         Some(it) => it,\n         None => return Vec::new(),\n     };\n-    let loc = module.def_id.loc(db);\n-    let items = db.lower_module_module(loc.source_root_id, loc.module_id);\n+    let items = db.lower_module_module(module);\n     let mut res = Vec::new();\n \n     for macro_call_id in items\n         .declarations\n         .iter()\n-        .filter_map(|(_, it)| it.take_types())\n-        .filter_map(|it| it.loc(db).source_item_id.file_id.as_macro_call_id())\n+        .filter_map(|(_, it)| it.clone().take_types())\n+        .filter_map(|it| match it {\n+            ModuleDef::Trait(it) => Some(it),\n+            _ => None,\n+        })\n+        .filter_map(|it| it.source(db).0.as_macro_call_id())\n     {\n         if let Some(exp) = db.expand_macro_invocation(macro_call_id) {\n             let loc = macro_call_id.loc(db);"}, {"sha": "c7f77e7a3986ef83728cade3d89e05e9763ed476", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 117, "deletions": 101, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -24,15 +24,14 @@ use std::ops::Index;\n use std::sync::Arc;\n use std::{fmt, mem};\n \n-use log;\n use ena::unify::{InPlaceUnificationTable, UnifyKey, UnifyValue, NoError};\n use ra_arena::map::ArenaMap;\n use join_to_string::join;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    Def, DefId, Module, Function, Struct, StructField, Enum, EnumVariant, Path, Name, ImplBlock,\n-    FnSignature, FnScopes,\n+    Module, Function, Struct, StructField, Enum, EnumVariant, Path, Name, ImplBlock,\n+    FnSignature, FnScopes, ModuleDef, AdtDef,\n     db::HirDatabase,\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n@@ -184,7 +183,7 @@ pub enum Ty {\n     /// Structures, enumerations and unions.\n     Adt {\n         /// The DefId of the struct/enum.\n-        def_id: DefId,\n+        def_id: AdtDef,\n         /// The name, for displaying.\n         name: Name,\n         /// Substitutions for the generic parameters of the type.\n@@ -381,12 +380,16 @@ impl Ty {\n         }\n \n         // Resolve in module (in type namespace)\n-        let resolved = match module.resolve_path(db, path).take_types() {\n-            Some(r) => r,\n+        let typable: TypableDef = match module\n+            .resolve_path(db, path)\n+            .take_types()\n+            .and_then(|it| it.into())\n+        {\n             None => return Ty::Unknown,\n+            Some(it) => it,\n         };\n-        let ty = db.type_for_def(resolved);\n-        let substs = Ty::substs_from_path(db, module, impl_block, generics, path, resolved);\n+        let ty = db.type_for_def(typable);\n+        let substs = Ty::substs_from_path(db, module, impl_block, generics, path, typable);\n         ty.apply_substs(substs)\n     }\n \n@@ -399,20 +402,18 @@ impl Ty {\n         impl_block: Option<&ImplBlock>,\n         outer_generics: &GenericParams,\n         path: &Path,\n-        resolved: DefId,\n+        resolved: TypableDef,\n     ) -> Substs {\n         let mut substs = Vec::new();\n-        let def = resolved.resolve(db);\n         let last = path\n             .segments\n             .last()\n             .expect(\"path should have at least one segment\");\n-        let (def_generics, segment) = match def {\n-            Def::Struct(s) => (s.generic_params(db), last),\n-            Def::Enum(e) => (e.generic_params(db), last),\n-            Def::Function(f) => (f.generic_params(db), last),\n-            Def::Trait(t) => (t.generic_params(db), last),\n-            Def::EnumVariant(ev) => {\n+        let (def_generics, segment) = match resolved {\n+            TypableDef::Function(func) => (func.generic_params(db), last),\n+            TypableDef::Struct(s) => (s.generic_params(db), last),\n+            TypableDef::Enum(e) => (e.generic_params(db), last),\n+            TypableDef::EnumVariant(var) => {\n                 // the generic args for an enum variant may be either specified\n                 // on the segment referring to the enum, or on the segment\n                 // referring to the variant. So `Option::<T>::None` and\n@@ -426,9 +427,8 @@ impl Ty {\n                     // Option::None::<T>\n                     last\n                 };\n-                (ev.parent_enum(db).generic_params(db), segment)\n+                (var.parent_enum(db).generic_params(db), segment)\n             }\n-            _ => return Substs::empty(),\n         };\n         // substs_from_path\n         if let Some(generic_args) = &segment.args_and_bindings {\n@@ -639,7 +639,7 @@ fn make_substs(generics: &GenericParams) -> Substs {\n fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n     let generics = s.generic_params(db);\n     Ty::Adt {\n-        def_id: s.def_id(),\n+        def_id: s.into(),\n         name: s.name(db).unwrap_or_else(Name::missing),\n         substs: make_substs(&generics),\n     }\n@@ -648,7 +648,7 @@ fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n pub(crate) fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n     let generics = s.generic_params(db);\n     Ty::Adt {\n-        def_id: s.def_id(),\n+        def_id: s.into(),\n         name: s.name(db).unwrap_or_else(Name::missing),\n         substs: make_substs(&generics),\n     }\n@@ -660,66 +660,74 @@ pub(crate) fn type_for_enum_variant(db: &impl HirDatabase, ev: EnumVariant) -> T\n     type_for_enum(db, enum_parent)\n }\n \n-pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Ty {\n-    let def = def_id.resolve(db);\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum TypableDef {\n+    Function(Function),\n+    Struct(Struct),\n+    Enum(Enum),\n+    EnumVariant(EnumVariant),\n+}\n+impl_froms!(TypableDef: Function, Struct, Enum, EnumVariant);\n+\n+impl From<ModuleDef> for Option<TypableDef> {\n+    fn from(def: ModuleDef) -> Option<TypableDef> {\n+        let res = match def {\n+            ModuleDef::Function(f) => f.into(),\n+            ModuleDef::Struct(s) => s.into(),\n+            ModuleDef::Enum(e) => e.into(),\n+            ModuleDef::EnumVariant(v) => v.into(),\n+            ModuleDef::Const(_)\n+            | ModuleDef::Static(_)\n+            | ModuleDef::Module(_)\n+            | ModuleDef::Trait(_)\n+            | ModuleDef::Type(_) => return None,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+pub(super) fn type_for_def(db: &impl HirDatabase, def: TypableDef) -> Ty {\n     match def {\n-        Def::Module(..) => {\n-            log::debug!(\"trying to get type for module {:?}\", def_id);\n-            Ty::Unknown\n-        }\n-        Def::Function(f) => type_for_fn(db, f),\n-        Def::Struct(s) => type_for_struct(db, s),\n-        Def::Enum(e) => type_for_enum(db, e),\n-        Def::EnumVariant(ev) => type_for_enum_variant(db, ev),\n-        _ => {\n-            log::debug!(\n-                \"trying to get type for item of unknown type {:?} {:?}\",\n-                def_id,\n-                def\n-            );\n-            Ty::Unknown\n-        }\n+        TypableDef::Function(f) => type_for_fn(db, f),\n+        TypableDef::Struct(s) => type_for_struct(db, s),\n+        TypableDef::Enum(e) => type_for_enum(db, e),\n+        TypableDef::EnumVariant(v) => type_for_enum_variant(db, v),\n     }\n }\n \n-pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name) -> Option<Ty> {\n-    let def = def_id.resolve(db);\n-    let (variant_data, generics) = match def {\n-        Def::Struct(s) => (s.variant_data(db), s.generic_params(db)),\n-        Def::EnumVariant(ev) => (ev.variant_data(db), ev.parent_enum(db).generic_params(db)),\n-        // TODO: unions\n-        Def::Enum(_) => {\n-            // this can happen in (invalid) code, but enums don't have fields themselves\n-            return None;\n-        }\n-        _ => panic!(\n-            \"trying to get type for field {:?} in non-struct/variant {:?}\",\n-            field, def_id\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum VariantDef {\n+    Struct(Struct),\n+    EnumVariant(EnumVariant),\n+}\n+impl_froms!(VariantDef: Struct, EnumVariant);\n+\n+pub(super) fn type_for_field(db: &impl HirDatabase, def: VariantDef, field: Name) -> Option<Ty> {\n+    let (variant_data, generics, module) = match def {\n+        VariantDef::Struct(s) => (s.variant_data(db), s.generic_params(db), s.module(db)),\n+        VariantDef::EnumVariant(var) => (\n+            var.variant_data(db),\n+            var.parent_enum(db).generic_params(db),\n+            var.module(db),\n         ),\n     };\n-    let module = def_id.module(db);\n-    let impl_block = def_id.impl_block(db);\n+    // We can't have an impl block ere, right?\n+    // let impl_block = def_id.impl_block(db);\n     let type_ref = variant_data.get_field_type_ref(&field)?;\n-    Some(Ty::from_hir(\n-        db,\n-        &module,\n-        impl_block.as_ref(),\n-        &generics,\n-        &type_ref,\n-    ))\n+    Some(Ty::from_hir(db, &module, None, &generics, &type_ref))\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n     /// For each method call expr, record the function it resolved to.\n-    method_resolutions: FxHashMap<ExprId, DefId>,\n+    method_resolutions: FxHashMap<ExprId, Function>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n }\n \n impl InferenceResult {\n-    pub fn method_resolution(&self, expr: ExprId) -> Option<DefId> {\n+    pub fn method_resolution(&self, expr: ExprId) -> Option<Function> {\n         self.method_resolutions.get(&expr).map(|it| *it)\n     }\n }\n@@ -749,7 +757,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     module: Module,\n     impl_block: Option<ImplBlock>,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n-    method_resolutions: FxHashMap<ExprId, DefId>,\n+    method_resolutions: FxHashMap<ExprId, Function>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n     /// The return type of the function being inferred.\n@@ -875,8 +883,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.type_of_expr.insert(expr, ty);\n     }\n \n-    fn write_method_resolution(&mut self, expr: ExprId, def_id: DefId) {\n-        self.method_resolutions.insert(expr, def_id);\n+    fn write_method_resolution(&mut self, expr: ExprId, func: Function) {\n+        self.method_resolutions.insert(expr, func);\n     }\n \n     fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n@@ -1063,20 +1071,30 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n \n         // resolve in module\n-        let resolved = self.module.resolve_path(self.db, &path).take_values()?;\n-        let ty = self.db.type_for_def(resolved);\n+        let typable: Option<TypableDef> = self\n+            .module\n+            .resolve_path(self.db, &path)\n+            .take_values()?\n+            .into();\n+        let typable = typable?;\n+        let ty = self.db.type_for_def(typable);\n         let ty = self.insert_type_vars(ty);\n         Some(ty)\n     }\n \n-    fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<DefId>) {\n+    fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantDef>) {\n         let path = match path {\n             Some(path) => path,\n             None => return (Ty::Unknown, None),\n         };\n-        let def_id = match self.module.resolve_path(self.db, &path).take_types() {\n-            Some(def_id) => def_id,\n-            _ => return (Ty::Unknown, None),\n+        let typable: Option<TypableDef> = self\n+            .module\n+            .resolve_path(self.db, &path)\n+            .take_types()\n+            .and_then(|it| it.into());\n+        let def = match typable {\n+            None => return (Ty::Unknown, None),\n+            Some(it) => it,\n         };\n         // TODO remove the duplication between here and `Ty::from_path`?\n         // TODO provide generics of function\n@@ -1087,38 +1105,34 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             self.impl_block.as_ref(),\n             &generics,\n             path,\n-            def_id,\n+            def,\n         );\n-        match def_id.resolve(self.db) {\n-            Def::Struct(s) => {\n+        match def {\n+            TypableDef::Struct(s) => {\n                 let ty = type_for_struct(self.db, s);\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                (ty, Some(def_id))\n+                (ty, Some(s.into()))\n             }\n-            Def::EnumVariant(ev) => {\n-                let ty = type_for_enum_variant(self.db, ev);\n+            TypableDef::EnumVariant(var) => {\n+                let ty = type_for_enum_variant(self.db, var);\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                (ty, Some(def_id))\n+                (ty, Some(var.into()))\n             }\n-            _ => (Ty::Unknown, None),\n+            TypableDef::Enum(_) | TypableDef::Function(_) => (Ty::Unknown, None),\n         }\n     }\n \n     fn resolve_fields(&mut self, path: Option<&Path>) -> Option<(Ty, Vec<StructField>)> {\n-        let (ty, def_id) = self.resolve_variant(path);\n-        let def_id = def_id?;\n-        let def = def_id.resolve(self.db);\n-\n-        match def {\n-            Def::Struct(s) => {\n+        let (ty, def) = self.resolve_variant(path);\n+        match def? {\n+            VariantDef::Struct(s) => {\n                 let fields = s.fields(self.db);\n                 Some((ty, fields))\n             }\n-            Def::EnumVariant(ev) => {\n-                let fields = ev.fields(self.db);\n+            VariantDef::EnumVariant(var) => {\n+                let fields = var.fields(self.db);\n                 Some((ty, fields))\n             }\n-            _ => None,\n         }\n     }\n \n@@ -1216,6 +1230,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .module\n                 .resolve_path(self.db, &path)\n                 .take_values()\n+                .and_then(|module_def| module_def.into())\n                 .map_or(Ty::Unknown, |resolved| self.db.type_for_def(resolved)),\n             Pat::Bind {\n                 mode,\n@@ -1336,9 +1351,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let receiver_ty = self.infer_expr(*receiver, &Expectation::none());\n                 let resolved = receiver_ty.clone().lookup_method(self.db, method_name);\n                 let method_ty = match resolved {\n-                    Some(def_id) => {\n-                        self.write_method_resolution(expr, def_id);\n-                        self.db.type_for_def(def_id)\n+                    Some(func) => {\n+                        self.write_method_resolution(expr, func);\n+                        self.db.type_for_def(func.into())\n                     }\n                     None => Ty::Unknown,\n                 };\n@@ -1407,7 +1422,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 for field in fields {\n                     let field_ty = if let Some(def_id) = def_id {\n                         self.db\n-                            .type_for_field(def_id, field.name.clone())\n+                            .type_for_field(def_id.into(), field.name.clone())\n                             .unwrap_or(Ty::Unknown)\n                             .subst(&substs)\n                     } else {\n@@ -1431,10 +1446,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             i.and_then(|i| fields.get(i).cloned())\n                         }\n                         Ty::Adt {\n-                            def_id, ref substs, ..\n+                            def_id: AdtDef::Struct(s),\n+                            ref substs,\n+                            ..\n                         } => self\n                             .db\n-                            .type_for_field(def_id, name.clone())\n+                            .type_for_field(s.into(), name.clone())\n                             .map(|ty| ty.subst(substs)),\n                         _ => None,\n                     })\n@@ -1607,16 +1624,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n }\n \n-pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Arc<InferenceResult> {\n+pub fn infer(db: &impl HirDatabase, func: Function) -> Arc<InferenceResult> {\n     db.check_canceled();\n-    let function = Function::new(def_id); // TODO: consts also need inference\n-    let body = function.body(db);\n-    let scopes = db.fn_scopes(def_id);\n-    let module = function.module(db);\n-    let impl_block = function.impl_block(db);\n+    let body = func.body(db);\n+    let scopes = db.fn_scopes(func);\n+    let module = func.module(db);\n+    let impl_block = func.impl_block(db);\n     let mut ctx = InferenceContext::new(db, body, scopes, module, impl_block);\n \n-    let signature = function.signature(db);\n+    let signature = func.signature(db);\n     ctx.collect_fn_signature(&signature);\n \n     ctx.infer_body();"}, {"sha": "9a571c2aaf51a826ef03aa7def0db243be2c6656", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -6,19 +6,17 @@ use std::sync::Arc;\n \n use rustc_hash::FxHashMap;\n \n-use ra_db::SourceRootId;\n-\n use crate::{\n-    HirDatabase, DefId, module_tree::ModuleId, Module, Crate, Name, Function,\n+    HirDatabase, module_tree::ModuleId, Module, Crate, Name, Function,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n-    generics::GenericParams\n+    generics::GenericParams,\n+    ty::{AdtDef, Ty}\n };\n-use super::Ty;\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum TyFingerprint {\n-    Adt(DefId),\n+    Adt(AdtDef),\n     // we'll also want to index impls for primitive types etc.\n }\n \n@@ -37,7 +35,7 @@ impl TyFingerprint {\n #[derive(Debug, PartialEq, Eq)]\n pub struct CrateImplBlocks {\n     /// To make sense of the ModuleIds, we need the source root.\n-    source_root_id: SourceRootId,\n+    krate: Crate,\n     impls: FxHashMap<TyFingerprint, Vec<(ModuleId, ImplId)>>,\n }\n \n@@ -53,14 +51,17 @@ impl CrateImplBlocks {\n             .into_iter()\n             .flat_map(|i| i.iter())\n             .map(move |(module_id, impl_id)| {\n-                let module_impl_blocks = db.impls_in_module(self.source_root_id, *module_id);\n+                let module = Module {\n+                    krate: self.krate.crate_id,\n+                    module_id: *module_id,\n+                };\n+                let module_impl_blocks = db.impls_in_module(module);\n                 ImplBlock::from_id(module_impl_blocks, *impl_id)\n             })\n     }\n \n-    fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) {\n-        let module_id = module.def_id.loc(db).module_id;\n-        let module_impl_blocks = db.impls_in_module(self.source_root_id, module_id);\n+    fn collect_recursive(&mut self, db: &impl HirDatabase, module: &Module) {\n+        let module_impl_blocks = db.impls_in_module(module.clone());\n \n         for (impl_id, impl_data) in module_impl_blocks.impls.iter() {\n             let impl_block = ImplBlock::from_id(Arc::clone(&module_impl_blocks), impl_id);\n@@ -81,29 +82,26 @@ impl CrateImplBlocks {\n                     self.impls\n                         .entry(target_ty_fp)\n                         .or_insert_with(Vec::new)\n-                        .push((module_id, impl_id));\n+                        .push((module.module_id, impl_id));\n                 }\n             }\n         }\n \n         for child in module.children(db) {\n-            self.collect_recursive(db, child);\n+            self.collect_recursive(db, &child);\n         }\n     }\n \n     pub(crate) fn impls_in_crate_query(\n         db: &impl HirDatabase,\n         krate: Crate,\n     ) -> Arc<CrateImplBlocks> {\n-        let crate_graph = db.crate_graph();\n-        let file_id = crate_graph.crate_root(krate.crate_id);\n-        let source_root_id = db.file_source_root(file_id);\n         let mut crate_impl_blocks = CrateImplBlocks {\n-            source_root_id,\n+            krate: krate.clone(),\n             impls: FxHashMap::default(),\n         };\n         if let Some(module) = krate.root_module(db) {\n-            crate_impl_blocks.collect_recursive(db, module);\n+            crate_impl_blocks.collect_recursive(db, &module);\n         }\n         Arc::new(crate_impl_blocks)\n     }\n@@ -120,11 +118,11 @@ impl Ty {\n     // TODO: cache this as a query?\n     // - if so, what signature? (TyFingerprint, Name)?\n     // - or maybe cache all names and def_ids of methods per fingerprint?\n-    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Option<DefId> {\n+    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Option<Function> {\n         self.iterate_methods(db, |f| {\n             let sig = f.signature(db);\n             if sig.name() == name && sig.has_self_param() {\n-                Some(f.def_id())\n+                Some(f)\n             } else {\n                 None\n             }"}, {"sha": "8747fae1814d9e1932b7855ad08b58a03128e50f", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_struct.snap", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_struct.snap", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_struct.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_struct.snap?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -1,19 +1,19 @@\n ---\n-created: \"2019-01-22T14:45:00.058678600+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-24T14:51:32.808861856+00:00\"\n+creator: insta@0.5.2\n expression: \"&result\"\n-source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n+source: crates/ra_hir/src/ty/tests.rs\n ---\n [72; 154) '{     ...a.c; }': ()\n [82; 83) 'c': [unknown]\n-[86; 87) 'C': [unknown]\n+[86; 87) 'C': C\n [86; 90) 'C(1)': [unknown]\n [88; 89) '1': i32\n-[96; 97) 'B': [unknown]\n+[96; 97) 'B': B\n [107; 108) 'a': A\n [114; 133) 'A { b:...C(1) }': A\n [121; 122) 'B': B\n-[127; 128) 'C': [unknown]\n+[127; 128) 'C': C\n [127; 131) 'C(1)': C\n [129; 130) '1': i32\n [139; 140) 'a': A"}, {"sha": "6a9358d333317bf1a5dccd7cb71d7fa08263d185", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -1,4 +1,4 @@\n-use hir::{Ty, Def};\n+use hir::{Ty, AdtDef};\n \n use crate::completion::{CompletionContext, Completions, CompletionItem, CompletionItemKind};\n use crate::completion::completion_item::CompletionKind;\n@@ -28,8 +28,8 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n             Ty::Adt {\n                 def_id, ref substs, ..\n             } => {\n-                match def_id.resolve(ctx.db) {\n-                    Def::Struct(s) => {\n+                match def_id {\n+                    AdtDef::Struct(s) => {\n                         for field in s.fields(ctx.db) {\n                             CompletionItem::new(\n                                 CompletionKind::Reference,\n@@ -41,8 +41,9 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n                             .add_to(acc);\n                         }\n                     }\n+\n                     // TODO unions\n-                    _ => {}\n+                    AdtDef::Enum(_) => (),\n                 }\n             }\n             Ty::Tuple(fields) => {"}, {"sha": "e72586e2e5426821ef2e3f7a8bf2ade5221b49ce", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -13,8 +13,8 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n         Some(it) => it,\n         None => return,\n     };\n-    match def_id.resolve(ctx.db) {\n-        hir::Def::Module(module) => {\n+    match def_id {\n+        hir::ModuleDef::Module(module) => {\n             let module_scope = module.scope(ctx.db);\n             for (name, res) in module_scope.entries() {\n                 CompletionItem::new(\n@@ -26,7 +26,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 .add_to(acc);\n             }\n         }\n-        hir::Def::Enum(e) => {\n+        hir::ModuleDef::Enum(e) => {\n             e.variants(ctx.db)\n                 .into_iter()\n                 .for_each(|(variant_name, variant)| {"}, {"sha": "578af6e5b3b839043f19dbda25b59e8053ecb54a", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -127,7 +127,7 @@ impl<'a> CompletionContext<'a> {\n             .ancestors()\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::FnDef::cast);\n-        match (&self.module, self.function_syntax) {\n+        match (self.module, self.function_syntax) {\n             (Some(module), Some(fn_def)) => {\n                 let function = source_binder::function_from_module(self.db, module, fn_def);\n                 self.function = Some(function);"}, {"sha": "3ba6c33ee606f2e0cd4c07f20ae12eae7ef51b46", "filename": "crates/ra_ide_api/src/completion/completion_item.rs", "status": "modified", "additions": 21, "deletions": 38, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -1,13 +1,13 @@\n-use hir::{Docs, Documentation, PerNs};\n-\n-use crate::completion::completion_context::CompletionContext;\n+use hir::{Docs, Documentation};\n use ra_syntax::{\n     ast::{self, AstNode},\n     TextRange,\n };\n use ra_text_edit::TextEdit;\n use test_utils::tested_by;\n \n+use crate::completion::completion_context::CompletionContext;\n+\n /// `CompletionItem` describes a single completion variant in the editor pop-up.\n /// It is basically a POD with various properties. To construct a\n /// `CompletionItem`, use `new` method and the `Builder` struct.\n@@ -209,41 +209,24 @@ impl Builder {\n         ctx: &CompletionContext,\n         resolution: &hir::Resolution,\n     ) -> Builder {\n-        let resolved = resolution.def_id.map(|d| d.resolve(ctx.db));\n-        let (kind, docs) = match resolved {\n-            PerNs {\n-                types: Some(hir::Def::Module(..)),\n-                ..\n-            } => (CompletionItemKind::Module, None),\n-            PerNs {\n-                types: Some(hir::Def::Struct(s)),\n-                ..\n-            } => (CompletionItemKind::Struct, s.docs(ctx.db)),\n-            PerNs {\n-                types: Some(hir::Def::Enum(e)),\n-                ..\n-            } => (CompletionItemKind::Enum, e.docs(ctx.db)),\n-            PerNs {\n-                types: Some(hir::Def::Trait(t)),\n-                ..\n-            } => (CompletionItemKind::Trait, t.docs(ctx.db)),\n-            PerNs {\n-                types: Some(hir::Def::Type(t)),\n-                ..\n-            } => (CompletionItemKind::TypeAlias, t.docs(ctx.db)),\n-            PerNs {\n-                values: Some(hir::Def::Const(c)),\n-                ..\n-            } => (CompletionItemKind::Const, c.docs(ctx.db)),\n-            PerNs {\n-                values: Some(hir::Def::Static(s)),\n-                ..\n-            } => (CompletionItemKind::Static, s.docs(ctx.db)),\n-            PerNs {\n-                values: Some(hir::Def::Function(function)),\n-                ..\n-            } => return self.from_function(ctx, function),\n-            _ => return self,\n+        let def = resolution\n+            .def_id\n+            .take_types()\n+            .or(resolution.def_id.take_values());\n+        let def = match def {\n+            None => return self,\n+            Some(it) => it,\n+        };\n+        let (kind, docs) = match def {\n+            hir::ModuleDef::Module(_) => (CompletionItemKind::Module, None),\n+            hir::ModuleDef::Function(func) => return self.from_function(ctx, func),\n+            hir::ModuleDef::Struct(it) => (CompletionItemKind::Struct, it.docs(ctx.db)),\n+            hir::ModuleDef::Enum(it) => (CompletionItemKind::Enum, it.docs(ctx.db)),\n+            hir::ModuleDef::EnumVariant(it) => (CompletionItemKind::EnumVariant, it.docs(ctx.db)),\n+            hir::ModuleDef::Const(it) => (CompletionItemKind::Const, it.docs(ctx.db)),\n+            hir::ModuleDef::Static(it) => (CompletionItemKind::Static, it.docs(ctx.db)),\n+            hir::ModuleDef::Trait(it) => (CompletionItemKind::Trait, it.docs(ctx.db)),\n+            hir::ModuleDef::Type(it) => (CompletionItemKind::TypeAlias, it.docs(ctx.db)),\n         };\n         self.kind = Some(kind);\n         self.documentation = docs;"}, {"sha": "bff6b7237ac68e2c19687f3eec418661fc7365f9", "filename": "crates/ra_ide_api/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdb.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -72,6 +72,7 @@ salsa::database_storage! {\n             fn file_relative_path() for ra_db::FileRelativePathQuery;\n             fn file_source_root() for ra_db::FileSourceRootQuery;\n             fn source_root() for ra_db::SourceRootQuery;\n+            fn source_root_crates() for ra_db::SourceRootCratesQuery;\n             fn local_roots() for ra_db::LocalRootsQuery;\n             fn library_roots() for ra_db::LibraryRootsQuery;\n             fn crate_graph() for ra_db::CrateGraphQuery;"}, {"sha": "46bdde00d73339cd98388bd70d1da4539c9f5578", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -63,13 +63,11 @@ pub(crate) fn reference_definition(\n             let infer_result = function.infer(db);\n             let syntax_mapping = function.body_syntax_mapping(db);\n             let expr = ast::Expr::cast(method_call.syntax()).unwrap();\n-            if let Some(def_id) = syntax_mapping\n+            if let Some(func) = syntax_mapping\n                 .node_expr(expr)\n                 .and_then(|it| infer_result.method_resolution(it))\n             {\n-                if let Some(target) = NavigationTarget::from_def(db, def_id.resolve(db)) {\n-                    return Exact(target);\n-                }\n+                return Exact(NavigationTarget::from_function(db, func));\n             };\n         }\n     }\n@@ -84,7 +82,7 @@ pub(crate) fn reference_definition(\n         {\n             let resolved = module.resolve_path(db, &path);\n             if let Some(def_id) = resolved.take_types().or(resolved.take_values()) {\n-                if let Some(target) = NavigationTarget::from_def(db, def_id.resolve(db)) {\n+                if let Some(target) = NavigationTarget::from_def(db, def_id) {\n                     return Exact(target);\n                 }\n             }"}, {"sha": "c5be8e01be3995d847b9db9b1352b4b04fe0ad6d", "filename": "crates/ra_ide_api/src/navigation_target.rs", "status": "modified", "additions": 55, "deletions": 31, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     SyntaxNode, AstNode, SmolStr, TextRange, ast,\n     SyntaxKind::{self, NAME},\n };\n-use hir::{Def, ModuleSource};\n+use hir::{ModuleSource};\n \n use crate::{FileSymbol, db::RootDatabase};\n \n@@ -96,45 +96,69 @@ impl NavigationTarget {\n         NavigationTarget::from_module(db, module)\n     }\n \n+    pub(crate) fn from_function(db: &RootDatabase, func: hir::Function) -> NavigationTarget {\n+        let (file_id, fn_def) = func.source(db);\n+        NavigationTarget::from_named(file_id.original_file(db), &*fn_def)\n+    }\n+\n     // TODO once Def::Item is gone, this should be able to always return a NavigationTarget\n-    pub(crate) fn from_def(db: &RootDatabase, def: Def) -> Option<NavigationTarget> {\n-        let res = match def {\n-            Def::Struct(s) => {\n+    pub(crate) fn from_def(\n+        db: &RootDatabase,\n+        module_def: hir::ModuleDef,\n+    ) -> Option<NavigationTarget> {\n+        match module_def {\n+            hir::ModuleDef::Module(module) => Some(NavigationTarget::from_module(db, module)),\n+            hir::ModuleDef::Function(func) => Some(NavigationTarget::from_function(db, func)),\n+            hir::ModuleDef::Struct(s) => {\n                 let (file_id, node) = s.source(db);\n-                NavigationTarget::from_named(file_id.original_file(db), &*node)\n+                Some(NavigationTarget::from_named(\n+                    file_id.original_file(db),\n+                    &*node,\n+                ))\n             }\n-            Def::Enum(e) => {\n-                let (file_id, node) = e.source(db);\n-                NavigationTarget::from_named(file_id.original_file(db), &*node)\n-            }\n-            Def::EnumVariant(ev) => {\n-                let (file_id, node) = ev.source(db);\n-                NavigationTarget::from_named(file_id.original_file(db), &*node)\n+            hir::ModuleDef::Const(s) => {\n+                let (file_id, node) = s.source(db);\n+                Some(NavigationTarget::from_named(\n+                    file_id.original_file(db),\n+                    &*node,\n+                ))\n             }\n-            Def::Function(f) => {\n-                let (file_id, node) = f.source(db);\n-                NavigationTarget::from_named(file_id.original_file(db), &*node)\n+            hir::ModuleDef::Static(s) => {\n+                let (file_id, node) = s.source(db);\n+                Some(NavigationTarget::from_named(\n+                    file_id.original_file(db),\n+                    &*node,\n+                ))\n             }\n-            Def::Trait(f) => {\n-                let (file_id, node) = f.source(db);\n-                NavigationTarget::from_named(file_id.original_file(db), &*node)\n+            hir::ModuleDef::Enum(e) => {\n+                let (file_id, node) = e.source(db);\n+                Some(NavigationTarget::from_named(\n+                    file_id.original_file(db),\n+                    &*node,\n+                ))\n             }\n-            Def::Type(f) => {\n-                let (file_id, node) = f.source(db);\n-                NavigationTarget::from_named(file_id.original_file(db), &*node)\n+            hir::ModuleDef::EnumVariant(var) => {\n+                let (file_id, node) = var.source(db);\n+                Some(NavigationTarget::from_named(\n+                    file_id.original_file(db),\n+                    &*node,\n+                ))\n             }\n-            Def::Static(f) => {\n-                let (file_id, node) = f.source(db);\n-                NavigationTarget::from_named(file_id.original_file(db), &*node)\n+            hir::ModuleDef::Trait(e) => {\n+                let (file_id, node) = e.source(db);\n+                Some(NavigationTarget::from_named(\n+                    file_id.original_file(db),\n+                    &*node,\n+                ))\n             }\n-            Def::Const(f) => {\n-                let (file_id, node) = f.source(db);\n-                NavigationTarget::from_named(file_id.original_file(db), &*node)\n+            hir::ModuleDef::Type(e) => {\n+                let (file_id, node) = e.source(db);\n+                Some(NavigationTarget::from_named(\n+                    file_id.original_file(db),\n+                    &*node,\n+                ))\n             }\n-            Def::Module(m) => NavigationTarget::from_module(db, m),\n-            Def::Item => return None,\n-        };\n-        Some(res)\n+        }\n     }\n \n     #[cfg(test)]"}, {"sha": "5b767addd3c38d6e7494df37a7cea1946fabe53b", "filename": "crates/ra_ide_api/src/rename.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frename.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -57,7 +57,6 @@ fn rename_mod(\n ) -> Option<SourceChange> {\n     let mut source_file_edits = Vec::new();\n     let mut file_system_edits = Vec::new();\n-\n     if let Some(module) = module_from_declaration(db, position.file_id, &ast_module) {\n         let (file_id, module_source) = module.definition_source(db);\n         match module_source {\n@@ -223,11 +222,15 @@ mod tests {\n     fn test_rename_mod() {\n         let (analysis, position) = analysis_and_position(\n             \"\n-        //- /bar.rs\n-        mod fo<|>o;\n-        //- /bar/foo.rs\n-        // emtpy\n-    \",\n+            //- /lib.rs\n+            mod bar;\n+\n+            //- /bar.rs\n+            mod foo<|>;\n+\n+            //- /bar/foo.rs\n+            // emtpy\n+            \",\n         );\n         let new_name = \"foo2\";\n         let source_change = analysis.rename(position, new_name).unwrap();\n@@ -238,11 +241,11 @@ mod tests {\n     fn test_rename_mod_in_dir() {\n         let (analysis, position) = analysis_and_position(\n             \"\n-        //- /lib.rs\n-        mod fo<|>o;\n-        //- /foo/mod.rs\n-        // emtpy\n-    \",\n+            //- /lib.rs\n+            mod fo<|>o;\n+            //- /foo/mod.rs\n+            // emtpy\n+            \",\n         );\n         let new_name = \"foo2\";\n         let source_change = analysis.rename(position, new_name).unwrap();"}, {"sha": "890426db77192a79cf390fe6b24e0e4ca679c35d", "filename": "crates/ra_ide_api/src/snapshots/tests__rename_mod.snap", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Ftests__rename_mod.snap", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Ftests__rename_mod.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Ftests__rename_mod.snap?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -1,16 +1,16 @@\n ---\n-created: \"2019-01-22T14:45:00.975229300+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-24T08:39:53.759318522+00:00\"\n+creator: insta@0.5.2\n expression: \"&source_change\"\n-source: \"crates\\\\ra_ide_api\\\\src\\\\rename.rs\"\n+source: crates/ra_ide_api/src/rename.rs\n ---\n Some(\n     SourceChange {\n         label: \"rename\",\n         source_file_edits: [\n             SourceFileEdit {\n                 file_id: FileId(\n-                    1\n+                    2\n                 ),\n                 edit: TextEdit {\n                     atoms: [\n@@ -25,7 +25,7 @@ Some(\n         file_system_edits: [\n             MoveFile {\n                 src: FileId(\n-                    2\n+                    3\n                 ),\n                 dst_source_root: SourceRootId(\n                     0"}, {"sha": "fd65264b27478e2b8afb0ee5c08ae948ddae9595", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -430,6 +430,13 @@ impl StructDef {\n }\n \n impl EnumVariant {\n+    pub fn parent_enum(&self) -> &EnumDef {\n+        self.syntax()\n+            .parent()\n+            .and_then(|it| it.parent())\n+            .and_then(EnumDef::cast)\n+            .expect(\"EnumVariants are always nested in Enums\")\n+    }\n     pub fn flavor(&self) -> StructFlavor {\n         StructFlavor::from_node(self)\n     }"}, {"sha": "a207f8429f39329757cd82c2fe8426c18881c02a", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -3229,6 +3229,7 @@ impl ast::VisibilityOwner for TraitDef {}\n impl ast::NameOwner for TraitDef {}\n impl ast::AttrsOwner for TraitDef {}\n impl ast::DocCommentsOwner for TraitDef {}\n+impl ast::TypeParamsOwner for TraitDef {}\n impl TraitDef {}\n \n // TrueKw"}, {"sha": "dedefea591dd05099bdeb9cf264d4cb40037852d", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/c42db0bbd750fae19a91f0a0354240ea6c3bafce/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=c42db0bbd750fae19a91f0a0354240ea6c3bafce", "patch": "@@ -280,7 +280,7 @@ Grammar(\n         ], options: [[\"variant_list\", \"EnumVariantList\"]] ),\n         \"EnumVariantList\": ( collections: [[\"variants\", \"EnumVariant\"]] ),\n         \"EnumVariant\": ( traits: [\"NameOwner\", \"DocCommentsOwner\"], options: [\"Expr\"] ),\n-        \"TraitDef\": ( traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\"] ),\n+        \"TraitDef\": ( traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\", \"TypeParamsOwner\"] ),\n         \"Module\": (\n             traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\" ],\n             options: [ \"ItemList\" ]\n@@ -489,7 +489,7 @@ Grammar(\n         ),\n \n         \"RefPat\": ( options: [ \"Pat\" ]),\n-        \"BindPat\": ( \n+        \"BindPat\": (\n             options: [ \"Pat\" ],\n             traits: [\"NameOwner\"]\n         ),"}]}