{"sha": "2a40d9b7a07f9a770455de26e46b766bdb395206", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNDBkOWI3YTA3ZjlhNzcwNDU1ZGUyNmU0NmI3NjZiZGIzOTUyMDY=", "commit": {"author": {"name": "JCTyBlaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-11-06T17:29:54Z"}, "committer": {"name": "JCTyBlaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-11-06T17:29:54Z"}, "message": "More aggressive vector index re-use, and added some tests.", "tree": {"sha": "ab03d7ef835269faa6ccda3ed0793a213c71a4e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab03d7ef835269faa6ccda3ed0793a213c71a4e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a40d9b7a07f9a770455de26e46b766bdb395206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a40d9b7a07f9a770455de26e46b766bdb395206", "html_url": "https://github.com/rust-lang/rust/commit/2a40d9b7a07f9a770455de26e46b766bdb395206", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a40d9b7a07f9a770455de26e46b766bdb395206/comments", "author": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c70bbea257d43242fa9f700d099c4a8a8eae2971", "url": "https://api.github.com/repos/rust-lang/rust/commits/c70bbea257d43242fa9f700d099c4a8a8eae2971", "html_url": "https://github.com/rust-lang/rust/commit/c70bbea257d43242fa9f700d099c4a8a8eae2971"}], "stats": {"total": 316, "additions": 254, "deletions": 62}, "files": [{"sha": "57f09146d6f827271790a3518859c9aaafc0c93c", "filename": "src/data_race.rs", "status": "modified", "additions": 129, "deletions": 61, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/2a40d9b7a07f9a770455de26e46b766bdb395206/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a40d9b7a07f9a770455de26e46b766bdb395206/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=2a40d9b7a07f9a770455de26e46b766bdb395206", "patch": "@@ -20,7 +20,7 @@ use std::{\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_target::abi::Size;\n use rustc_middle::ty::layout::TyAndLayout;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use crate::{\n     MiriEvalContext, MiriEvalContextExt,\n@@ -662,7 +662,7 @@ impl VClockAlloc {\n             let (index, clocks) = self.global.current_thread_state();\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (_,range) in alloc_ranges.iter_mut(pointer.offset, len) {\n-                if range.read_race_detect(&*clocks, index) == Err(DataRace) {\n+                if let Err(DataRace) = range.read_race_detect(&*clocks, index) {\n                     // Report data-race\n                     return Self::report_data_race(\n                         &self.global,range, \"READ\", false, pointer, len\n@@ -674,18 +674,17 @@ impl VClockAlloc {\n             Ok(())\n         }\n     }\n-    /// Detect data-races for an unsychronized write operation, will not perform\n-    ///  data-race threads if `multi-threaded` is false, either due to no threads\n-    ///  being created or if it is temporarily disabled during a racy read or write\n-    ///  operation\n-    pub fn write<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n+\n+\n+    // Shared code for detecting data-races on unique access to a section of memory\n+    fn unique_access<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size, action: &str) -> InterpResult<'tcx> {\n         if self.global.multi_threaded.get() {\n             let (index, clocks) = self.global.current_thread_state();\n             for (_,range) in self.alloc_ranges.get_mut().iter_mut(pointer.offset, len) {\n-                if range.write_race_detect(&*clocks, index) == Err(DataRace) {\n+                if let Err(DataRace) = range.write_race_detect(&*clocks, index) {\n                     // Report data-race\n                     return Self::report_data_race(\n-                        &self.global, range, \"WRITE\", false, pointer, len\n+                        &self.global, range, action, false, pointer, len\n                     );\n                 }\n             }\n@@ -694,25 +693,20 @@ impl VClockAlloc {\n             Ok(())\n         }\n     }\n+\n+    /// Detect data-races for an unsychronized write operation, will not perform\n+    ///  data-race threads if `multi-threaded` is false, either due to no threads\n+    ///  being created or if it is temporarily disabled during a racy read or write\n+    ///  operation\n+    pub fn write<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n+        self.unique_access(pointer, len, \"Write\")\n+    }\n     /// Detect data-races for an unsychronized deallocate operation, will not perform\n     ///  data-race threads if `multi-threaded` is false, either due to no threads\n     ///  being created or if it is temporarily disabled during a racy read or write\n     ///  operation\n     pub fn deallocate<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n-        if self.global.multi_threaded.get() {\n-            let (index, clocks) = self.global.current_thread_state();\n-            for (_,range) in self.alloc_ranges.get_mut().iter_mut(pointer.offset, len) {\n-                if range.write_race_detect(&*clocks, index) == Err(DataRace) {\n-                    // Report data-race\n-                    return Self::report_data_race(\n-                        &self.global, range, \"DEALLOCATE\", false, pointer, len\n-                    );\n-                }\n-            }\n-           Ok(())\n-        }else{\n-            Ok(())\n-        }\n+        self.unique_access(pointer, len, \"Deallocate\")\n     }\n }\n \n@@ -773,6 +767,8 @@ struct ThreadExtraState {\n     /// The current vector index in use by the\n     ///  thread currently, this is set to None\n     ///  after the vector index has been re-used\n+    ///  and hence the value will never need to be\n+    ///  read during data-race reporting\n     vector_index: Option<VectorIdx>,\n \n     /// The name of the thread, updated for better\n@@ -782,10 +778,8 @@ struct ThreadExtraState {\n     \n     /// Thread termination vector clock, this\n     ///  is set on thread termination and is used\n-    ///  for joining on threads that have already\n-    ///  terminated. This should be used first\n-    ///  on joining as there is the possibility\n-    ///  that `vector_index` is None in some cases\n+    ///  for joining on threads since the vector_index\n+    ///  may be re-used when the join operation occurs\n     termination_vector_clock: Option<VClock>,\n }\n \n@@ -820,10 +814,26 @@ pub struct GlobalState {\n     current_index: Cell<VectorIdx>,\n \n     /// Potential vector indices that could be re-used on thread creation\n-    ///  values are inserted here on thread termination, vector index values\n-    ///  are then re-used once all the termination event happens-before all\n-    ///  existing thread-clocks\n+    ///  values are inserted here on after the thread has terminated and\n+    ///  been joined with, and hence may potentially become free\n+    ///  for use as the index for a new thread.\n+    /// Elements in this set may still require the vector index to\n+    ///  report data-races, and can only be re-used after all\n+    ///  active vector-clocks catch up with the threads timestamp.\n     reuse_candidates: RefCell<FxHashSet<VectorIdx>>,\n+\n+    /// Counts the number of threads that are currently active\n+    ///  if the number of active threads reduces to 1 and then\n+    ///  a join operation occures with the remaining main thread\n+    ///  then multi-threaded execution may be disabled\n+    active_thread_count: Cell<usize>, \n+\n+    /// This contains threads that have terminated, but not yet joined\n+    ///  and so cannot become re-use candidates until a join operation\n+    ///  occurs.\n+    /// The associated vector index will be moved into re-use candidates\n+    ///  after the join operation occurs\n+    terminated_threads: RefCell<FxHashMap<ThreadId, VectorIdx>>,\n }\n impl GlobalState {\n \n@@ -836,7 +846,9 @@ impl GlobalState {\n             vector_info: RefCell::new(IndexVec::new()),\n             thread_info: RefCell::new(IndexVec::new()),\n             current_index: Cell::new(VectorIdx::new(0)),\n+            active_thread_count: Cell::new(1),\n             reuse_candidates: RefCell::new(FxHashSet::default()),\n+            terminated_threads: RefCell::new(FxHashMap::default())\n         };\n \n         // Setup the main-thread since it is not explicitly created:\n@@ -860,10 +872,24 @@ impl GlobalState {\n     fn find_vector_index_reuse_candidate(&self) -> Option<VectorIdx> {\n         let mut reuse = self.reuse_candidates.borrow_mut();\n         let vector_clocks = self.vector_clocks.borrow();\n+        let vector_info = self.vector_info.borrow();\n+        let terminated_threads = self.terminated_threads.borrow();\n         for  &candidate in reuse.iter() {\n             let target_timestamp = vector_clocks[candidate].clock[candidate];\n-            if vector_clocks.iter().all(|clock| {\n-                clock.clock[candidate] == target_timestamp\n+            if vector_clocks.iter_enumerated().all(|(clock_idx, clock)| {\n+                // The thread happens before the clock, and hence cannot report\n+                //  a data-race with this the candidate index\n+                let no_data_race = clock.clock[candidate] >= target_timestamp;\n+\n+                // The vector represents a thread that has terminated and hence cannot\n+                //  report a data-race with the candidate index\n+                let thread_id = vector_info[clock_idx];\n+                let vector_terminated = reuse.contains(&clock_idx)\n+                    || terminated_threads.contains_key(&thread_id);\n+\n+                // The vector index cannot report a race with the candidate index\n+                //  and hence allows the candidate index to be re-used\n+                no_data_race || vector_terminated\n             }) {\n                 // All vector clocks for each vector index are equal to\n                 //  the target timestamp, and the thread is known to have\n@@ -882,6 +908,10 @@ impl GlobalState {\n     pub fn thread_created(&self, thread: ThreadId) {\n         let current_index = self.current_index();\n \n+        // Increment the number of active threads\n+        let active_threads = self.active_thread_count.get();\n+        self.active_thread_count.set(active_threads + 1);\n+\n         // Enable multi-threaded execution, there are now two threads\n         //  so data-races are now possible.\n         self.multi_threaded.set(true);\n@@ -946,51 +976,90 @@ impl GlobalState {\n     ///  between the joined thead and the current thread.\n     #[inline]\n     pub fn thread_joined(&self, current_thread: ThreadId, join_thread: ThreadId) {\n-        let (current_index, join_index) = {\n-            let thread_info = self.thread_info.borrow();\n-            let current_index = thread_info[current_thread].vector_index\n-                .expect(\"Joining into thread with no assigned vector\");\n-            let join_index = thread_info[join_thread].vector_index\n-                .expect(\"Joining thread with no assigned vector\");\n-            (current_index, join_index)\n-        };\n         let mut clocks_vec = self.vector_clocks.borrow_mut();\n-        let (current, join) = clocks_vec.pick2_mut(current_index, join_index);\n+        let thread_info = self.thread_info.borrow();\n+\n+        // Load the vector clock of the current thread\n+        let current_index = thread_info[current_thread].vector_index\n+            .expect(\"Performed thread join on thread with no assigned vector\");\n+        let current = &mut clocks_vec[current_index];\n+\n+        // Load the associated vector clock for the terminated thread\n+        let join_clock = thread_info[join_thread].termination_vector_clock\n+            .as_ref().expect(\"Joined with thread but thread has not terminated\");\n \n         // Pre increment clocks before atomic operation\n         current.increment_clock(current_index);\n-        join.increment_clock(join_index);\n \n         // The join thread happens-before the current thread\n         //   so update the current vector clock\n-        current.join_with(join);\n+        current.clock.join(join_clock);\n \n         // Post increment clocks after atomic operation\n-        //  the join clock is not incremented, since there will\n-        //  be no future events, also if it was incremented\n-        //  the thread re-use condition would never pass\n         current.increment_clock(current_index);\n+\n+        // Check the number of active threads, if the value is 1\n+        //  then test for potentially disabling multi-threaded execution\n+        let active_threads = self.active_thread_count.get();\n+        if active_threads == 1 {\n+            // May potentially be able to disable multi-threaded execution\n+            let current_clock = &clocks_vec[current_index];\n+            if clocks_vec.iter_enumerated().all(|(idx, clocks)| {\n+                clocks.clock[idx] <= current_clock.clock[idx]\n+            }) {\n+                // The all thread termations happen-before the current clock\n+                //  therefore no data-races can be reported until a new thread\n+                //  is created, so disable multi-threaded execution\n+                self.multi_threaded.set(false);\n+            }\n+        }\n+\n+        // If the thread is marked as terminated but not joined\n+        //  then move the thread to the re-use set\n+        let mut termination = self.terminated_threads.borrow_mut();\n+        if let Some(index) = termination.remove(&join_thread) {\n+            let mut reuse = self.reuse_candidates.borrow_mut();\n+            reuse.insert(index);\n+        }\n     }\n \n     /// On thread termination, the vector-clock may re-used\n     ///  in the future once all remaining thread-clocks catch\n-    ///  up with the time index of the terminated thread\n+    ///  up with the time index of the terminated thread.\n+    /// This assiges thread termination with a unique index\n+    ///  which will be used to join the thread\n+    /// This should be called strictly before any calls to\n+    ///   `thread_joined`\n     #[inline]\n-    pub fn thread_terminated(&self, terminated_thread: ThreadId) {\n-        let mut thread_info = self.thread_info.borrow_mut();\n-        let termination_meta = &mut thread_info[terminated_thread];\n+    pub fn thread_terminated(&self) {\n+        let current_index = self.current_index();\n+        \n+        // Increment the clock to a unique termination timestamp\n+        let mut vector_clocks = self.vector_clocks.borrow_mut();\n+        let current_clocks = &mut vector_clocks[current_index];\n+        current_clocks.increment_clock(current_index);\n \n-        // Find the terminated index & setup the termination vector-clock\n-        //  in case thread join is called in the future after the thread\n-        //  has been re-used\n-        let terminated_index = termination_meta.vector_index\n-            .expect(\"Joining into thread with no assigned vector\");\n-        let vector_clocks = self.vector_clocks.borrow();\n-        termination_meta.termination_vector_clock = Some(vector_clocks[terminated_index].clock.clone());\n+        // Load the current thread id for the executing vector\n+        let vector_info = self.vector_info.borrow();\n+        let current_thread = vector_info[current_index];\n \n-        // Add this thread as a candidate for re-use\n-        let mut reuse = self.reuse_candidates.borrow_mut();\n-        reuse.insert(terminated_index);\n+        // Load the current thread metadata, and move to a terminated\n+        //  vector state. Setting up the vector clock all join operations\n+        //  will use.\n+        let mut thread_info = self.thread_info.borrow_mut();\n+        let current = &mut thread_info[current_thread];\n+        current.termination_vector_clock = Some(current_clocks.clock.clone());\n+\n+        // Add this thread as a candidate for re-use after a thread join\n+        //  occurs\n+        let mut termination = self.terminated_threads.borrow_mut();\n+        termination.insert(current_thread, current_index);\n+            \n+        // Reduce the number of active threads, now that a thread has\n+        //  terminated\n+        let mut active_threads = self.active_thread_count.get();\n+        active_threads -= 1;\n+        self.active_thread_count.set(active_threads);\n     }\n \n     /// Hook for updating the local tracker of the currently\n@@ -1118,4 +1187,3 @@ impl GlobalState {\n         self.current_index.get()\n     }\n }\n-"}, {"sha": "40cfd04d7923eb382928f2161294d0df801dfb1e", "filename": "src/thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a40d9b7a07f9a770455de26e46b766bdb395206/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a40d9b7a07f9a770455de26e46b766bdb395206/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=2a40d9b7a07f9a770455de26e46b766bdb395206", "patch": "@@ -443,6 +443,8 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n                 return false;\n             });\n         }\n+        // Set the thread into a terminated state in the data-race detector\n+        data_race.thread_terminated();\n         // Check if we need to unblock any threads.\n         for (i, thread) in self.threads.iter_enumerated_mut() {\n             if thread.state == ThreadState::BlockedOnJoin(self.active_thread) {\n@@ -452,7 +454,6 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n                 thread.state = ThreadState::Enabled;\n             }\n         }\n-        data_race.thread_terminated(self.active_thread);\n         return free_tls_statics;\n     }\n "}, {"sha": "6af5706835e365770265e1626ee07e2d6ed2fa54", "filename": "tests/compile-fail/data_race/dangling_thread_async_race.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2a40d9b7a07f9a770455de26e46b766bdb395206/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_async_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a40d9b7a07f9a770455de26e46b766bdb395206/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_async_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_async_race.rs?ref=2a40d9b7a07f9a770455de26e46b766bdb395206", "patch": "@@ -0,0 +1,44 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::time::Duration;\n+use std::mem;\n+\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+\n+fn main() {\n+    let mut a = 0u32;\n+    let b = &mut a as *mut u32;\n+    let c = EvilSend(b);\n+\n+    let join = unsafe {\n+        spawn(move || {\n+            *c.0 = 32;\n+        })\n+    };\n+\n+    // Detatch the thread and sleep until it terminates\n+    mem::drop(join);\n+    sleep(Duration::from_millis(100));\n+\n+    // Spawn and immediately join a thread\n+    //  to execute the join code-path\n+    //  and ensure that data-race detection\n+    //  remains enabled\n+    spawn(|| ()).join().unwrap();\n+\n+    let join2 = unsafe {\n+        spawn(move || {\n+            *c.0 = 64; //~ ERROR Data race      \n+        })\n+    };\n+\n+    join2.join().unwrap();\n+}"}, {"sha": "c37f303bbab27e62b566376dcf5f862e105fac05", "filename": "tests/compile-fail/data_race/dangling_thread_race.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2a40d9b7a07f9a770455de26e46b766bdb395206/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a40d9b7a07f9a770455de26e46b766bdb395206/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_race.rs?ref=2a40d9b7a07f9a770455de26e46b766bdb395206", "patch": "@@ -0,0 +1,41 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::time::Duration;\n+use std::mem;\n+\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+\n+fn main() {\n+    let mut a = 0u32;\n+    let b = &mut a as *mut u32;\n+    let c = EvilSend(b);\n+\n+    let join = unsafe {\n+        spawn(move || {\n+            *c.0 = 32;\n+        })\n+    };\n+\n+    // Detatch the thread and sleep until it terminates\n+    mem::drop(join);\n+    sleep(Duration::from_millis(100));\n+\n+    // Spawn and immediately join a thread\n+    //  to execute the join code-path\n+    //  and ensure that data-race detection\n+    //  remains enabled\n+    spawn(|| ()).join().unwrap();\n+\n+\n+    unsafe {\n+        *c.0 = 64; //~ ERROR Data race\n+    }\n+}"}, {"sha": "fba7ba4841ccdce461c5230329e995e09784b8c1", "filename": "tests/compile-fail/data_race/enable_after_join_to_main.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2a40d9b7a07f9a770455de26e46b766bdb395206/tests%2Fcompile-fail%2Fdata_race%2Fenable_after_join_to_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a40d9b7a07f9a770455de26e46b766bdb395206/tests%2Fcompile-fail%2Fdata_race%2Fenable_after_join_to_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fenable_after_join_to_main.rs?ref=2a40d9b7a07f9a770455de26e46b766bdb395206", "patch": "@@ -0,0 +1,38 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Enable and the join with multiple threads\n+    let t1 = spawn(|| ());\n+    let t2 = spawn(|| ());\n+    let t3 = spawn(|| ());\n+    let t4 = spawn(|| ());\n+    t1.join().unwrap();\n+    t2.join().unwrap();\n+    t3.join().unwrap();\n+    t4.join().unwrap();\n+\n+    // Perform write-write data race detection\n+    let mut a = 0u32;\n+    let b = &mut a as *mut u32;\n+    let c = EvilSend(b);\n+    unsafe {\n+        let j1 = spawn(move || {\n+            *c.0 = 32;\n+        });\n+\n+        let j2 = spawn(move || {\n+            *c.0 = 64; //~ ERROR Data race\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}]}