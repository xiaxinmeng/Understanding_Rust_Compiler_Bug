{"sha": "cc43abcde87ed4a834f3b56a96ef165d8e4f0d86", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNDNhYmNkZTg3ZWQ0YTgzNGYzYjU2YTk2ZWYxNjVkOGU0ZjBkODY=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-09-07T21:00:00Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-09-09T22:42:20Z"}, "message": "Less false positive completion candidates", "tree": {"sha": "bc99f40aeaf59042bbd64da1c002e6bcbf5ca198", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc99f40aeaf59042bbd64da1c002e6bcbf5ca198"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc43abcde87ed4a834f3b56a96ef165d8e4f0d86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc43abcde87ed4a834f3b56a96ef165d8e4f0d86", "html_url": "https://github.com/rust-lang/rust/commit/cc43abcde87ed4a834f3b56a96ef165d8e4f0d86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc43abcde87ed4a834f3b56a96ef165d8e4f0d86/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fd6f451417fee0e8d95d06fb298c94b22bca917", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fd6f451417fee0e8d95d06fb298c94b22bca917", "html_url": "https://github.com/rust-lang/rust/commit/3fd6f451417fee0e8d95d06fb298c94b22bca917"}], "stats": {"total": 103, "additions": 59, "deletions": 44}, "files": [{"sha": "c5757a31097d7dc74cfe234a87777f7a9d981d5e", "filename": "crates/ide/src/completion/complete_mod.rs", "status": "modified", "additions": 59, "deletions": 44, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/cc43abcde87ed4a834f3b56a96ef165d8e4f0d86/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc43abcde87ed4a834f3b56a96ef165d8e4f0d86/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_mod.rs?ref=cc43abcde87ed4a834f3b56a96ef165d8e4f0d86", "patch": "@@ -3,91 +3,106 @@\n use base_db::{SourceDatabaseExt, VfsPath};\n use hir::{Module, ModuleSource};\n use ide_db::RootDatabase;\n+use rustc_hash::FxHashSet;\n \n use super::{completion_context::CompletionContext, completion_item::Completions};\n \n /// Complete mod declaration, i.e. `mod <|> ;`\n pub(super) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n     let current_module = ctx.scope.module()?;\n \n-    // TODO kb filter out declarations in possible_sudmobule_names\n-    // let declaration_source = current_module.declaration_source(ctx.db);\n-    let module_definition_source_file =\n+    let module_definition_file =\n         current_module.definition_source(ctx.db).file_id.original_file(ctx.db);\n-    let source_root = ctx.db.source_root(ctx.db.file_source_root(module_definition_source_file));\n+    let source_root = ctx.db.source_root(ctx.db.file_source_root(module_definition_file));\n     let directory_to_look_for_submodules = directory_to_look_for_submodules(\n         current_module,\n         ctx.db,\n-        source_root.path_for_file(&module_definition_source_file)?,\n+        source_root.path_for_file(&module_definition_file)?,\n     )?;\n \n+    let existing_mod_declarations = current_module\n+        .children(ctx.db)\n+        .filter_map(|module| Some(module.name(ctx.db)?.to_string()))\n+        .collect::<FxHashSet<_>>();\n+\n+    let module_declaration_file =\n+        current_module.declaration_source(ctx.db).map(|module_declaration_source_file| {\n+            module_declaration_source_file.file_id.original_file(ctx.db)\n+        });\n+\n     let mod_declaration_candidates = source_root\n         .iter()\n-        .filter(|submodule_file| submodule_file != &module_definition_source_file)\n+        .filter(|submodule_candidate_file| submodule_candidate_file != &module_definition_file)\n+        .filter(|submodule_candidate_file| {\n+            Some(submodule_candidate_file) != module_declaration_file.as_ref()\n+        })\n         .filter_map(|submodule_file| {\n             let submodule_path = source_root.path_for_file(&submodule_file)?;\n-            if submodule_path.parent()? == directory_to_look_for_submodules {\n+            if !is_special_rust_file_path(&submodule_path)\n+                && submodule_path.parent()? == directory_to_look_for_submodules\n+            {\n                 submodule_path.file_name_and_extension()\n             } else {\n                 None\n             }\n         })\n-        .filter_map(|file_name_and_extension| {\n-            match file_name_and_extension {\n-                // TODO kb in src/bin when a module is included into another,\n-                // the included file gets \"moved\" into a directory below and now cannot add any other modules\n-                (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => None,\n-                (file_name, Some(\"rs\")) => Some(file_name.to_owned()),\n-                (subdirectory_name, None) => {\n-                    let mod_rs_path =\n-                        directory_to_look_for_submodules.join(subdirectory_name)?.join(\"mod.rs\")?;\n-                    if source_root.file_for_path(&mod_rs_path).is_some() {\n-                        Some(subdirectory_name.to_owned())\n-                    } else {\n-                        None\n-                    }\n+        .filter_map(|submodule_file_name_and_extension| match submodule_file_name_and_extension {\n+            (file_name, Some(\"rs\")) => Some(file_name.to_owned()),\n+            (subdirectory_name, None) => {\n+                let mod_rs_path =\n+                    directory_to_look_for_submodules.join(subdirectory_name)?.join(\"mod.rs\")?;\n+                if source_root.file_for_path(&mod_rs_path).is_some() {\n+                    Some(subdirectory_name.to_owned())\n+                } else {\n+                    None\n                 }\n-                _ => None,\n             }\n+            _ => None,\n         })\n+        .filter(|name| !existing_mod_declarations.contains(name))\n         .collect::<Vec<_>>();\n     dbg!(mod_declaration_candidates);\n \n     // TODO kb exlude existing children from the candidates\n-    let existing_children = current_module.children(ctx.db).collect::<Vec<_>>();\n \n     Some(())\n }\n \n+fn is_special_rust_file_path(path: &VfsPath) -> bool {\n+    matches!(\n+        path.file_name_and_extension(),\n+        Some((\"mod\", Some(\"rs\"))) | Some((\"lib\", Some(\"rs\"))) | Some((\"main\", Some(\"rs\")))\n+    )\n+}\n+\n fn directory_to_look_for_submodules(\n     module: Module,\n     db: &RootDatabase,\n     module_file_path: &VfsPath,\n ) -> Option<VfsPath> {\n     let module_directory_path = module_file_path.parent()?;\n-\n-    let base_directory = match module_file_path.file_name_and_extension()? {\n-        (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => {\n+    let base_directory = if is_special_rust_file_path(module_file_path) {\n+        Some(module_directory_path)\n+    } else if let (regular_rust_file_name, Some(\"rs\")) =\n+        module_file_path.file_name_and_extension()?\n+    {\n+        if matches!(\n+            (\n+                module_directory_path\n+                    .parent()\n+                    .as_ref()\n+                    .and_then(|path| path.file_name_and_extension()),\n+                module_directory_path.file_name_and_extension(),\n+            ),\n+            (Some((\"src\", None)), Some((\"bin\", None)))\n+        ) {\n+            // files in /src/bin/ can import each other directly\n             Some(module_directory_path)\n+        } else {\n+            module_directory_path.join(regular_rust_file_name)\n         }\n-        (regular_rust_file_name, Some(\"rs\")) => {\n-            if matches!(\n-                (\n-                    module_directory_path\n-                        .parent()\n-                        .as_ref()\n-                        .and_then(|path| path.file_name_and_extension()),\n-                    module_directory_path.file_name_and_extension(),\n-                ),\n-                (Some((\"src\", None)), Some((\"bin\", None)))\n-            ) {\n-                // files in /src/bin/ can import each other directly\n-                Some(module_directory_path)\n-            } else {\n-                module_directory_path.join(regular_rust_file_name)\n-            }\n-        }\n-        _ => None,\n+    } else {\n+        None\n     }?;\n \n     let mut resulting_path = base_directory;"}]}