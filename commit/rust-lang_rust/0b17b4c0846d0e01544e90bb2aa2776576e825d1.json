{"sha": "0b17b4c0846d0e01544e90bb2aa2776576e825d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMTdiNGMwODQ2ZDBlMDE1NDRlOTBiYjJhYTI3NzY1NzZlODI1ZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-04T05:44:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-04T05:44:39Z"}, "message": "Auto merge of #42265 - Zoxc:for-sugar, r=eddyb\n\nChange for-loop desugar to not borrow the iterator during the loop\n\nThis is enables the use of suspend points inside for-loops in movable generators. This is illegal in the current desugaring as `iter` is borrowed across the body.", "tree": {"sha": "0e280de282d4988b39ab3ef4a08fe188f6e70561", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e280de282d4988b39ab3ef4a08fe188f6e70561"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b17b4c0846d0e01544e90bb2aa2776576e825d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b17b4c0846d0e01544e90bb2aa2776576e825d1", "html_url": "https://github.com/rust-lang/rust/commit/0b17b4c0846d0e01544e90bb2aa2776576e825d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b17b4c0846d0e01544e90bb2aa2776576e825d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b5a923001c481627d7b1d19d0fe1d3f86e5c5a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b5a923001c481627d7b1d19d0fe1d3f86e5c5a6", "html_url": "https://github.com/rust-lang/rust/commit/1b5a923001c481627d7b1d19d0fe1d3f86e5c5a6"}, {"sha": "cfdbff7c125cbdd5a2b75e526717413718d16111", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfdbff7c125cbdd5a2b75e526717413718d16111", "html_url": "https://github.com/rust-lang/rust/commit/cfdbff7c125cbdd5a2b75e526717413718d16111"}], "stats": {"total": 221, "additions": 138, "deletions": 83}, "files": [{"sha": "ee81151348772e2456e597b7bacb918904d28648", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=0b17b4c0846d0e01544e90bb2aa2776576e825d1", "patch": "@@ -191,10 +191,11 @@\n //! {\n //!     let result = match IntoIterator::into_iter(values) {\n //!         mut iter => loop {\n-//!             match iter.next() {\n-//!                 Some(x) => { println!(\"{}\", x); },\n+//!             let x = match iter.next() {\n+//!                 Some(val) => val,\n //!                 None => break,\n-//!             }\n+//!             };\n+//!             let () = { println!(\"{}\", x); };\n //!         },\n //!     };\n //!     result"}, {"sha": "4c436fb640f01797f22a08ea489f9c6fdcc04402", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0b17b4c0846d0e01544e90bb2aa2776576e825d1", "patch": "@@ -891,6 +891,7 @@ impl<'a> LoweringContext<'a> {\n             init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n             span: l.span,\n             attrs: l.attrs.clone(),\n+            source: hir::LocalSource::Normal,\n         })\n     }\n \n@@ -2167,10 +2168,11 @@ impl<'a> LoweringContext<'a> {\n                 //     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n                 //       mut iter => {\n                 //         [opt_ident]: loop {\n-                //           match ::std::iter::Iterator::next(&mut iter) {\n-                //             ::std::option::Option::Some(<pat>) => <body>,\n+                //           let <pat> = match ::std::iter::Iterator::next(&mut iter) {\n+                //             ::std::option::Option::Some(val) => val,\n                 //             ::std::option::Option::None => break\n-                //           }\n+                //           };\n+                //           SemiExpr(<body>);\n                 //         }\n                 //       }\n                 //     };\n@@ -2182,15 +2184,13 @@ impl<'a> LoweringContext<'a> {\n \n                 let iter = self.str_to_ident(\"iter\");\n \n-                // `::std::option::Option::Some(<pat>) => <body>`\n+                // `::std::option::Option::Some(val) => val`\n                 let pat_arm = {\n-                    let body_block = self.with_loop_scope(e.id,\n-                                                          |this| this.lower_block(body, false));\n-                    let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n-                    let pat = self.lower_pat(pat);\n-                    let some_pat = self.pat_some(e.span, pat);\n-\n-                    self.arm(hir_vec![some_pat], body_expr)\n+                    let val_ident = self.str_to_ident(\"val\");\n+                    let val_pat = self.pat_ident(e.span, val_ident);\n+                    let val_expr = P(self.expr_ident(e.span, val_ident, val_pat.id));\n+                    let some_pat = self.pat_some(e.span, val_pat);\n+                    self.arm(hir_vec![some_pat], val_expr)\n                 };\n \n                 // `::std::option::Option::None => break`\n@@ -2221,8 +2221,20 @@ impl<'a> LoweringContext<'a> {\n                                 ThinVec::new()))\n                 };\n \n+                let pat = self.lower_pat(pat);\n+                let pat_let = self.stmt_let_pat(e.span,\n+                    match_expr,\n+                    pat,\n+                    hir::LocalSource::ForLoopDesugar);\n+\n+                let body_block = self.with_loop_scope(e.id,\n+                                                        |this| this.lower_block(body, false));\n+                let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n+                let body_stmt = respan(e.span, hir::StmtExpr(body_expr, self.next_id()));\n+\n+                let loop_block = P(self.block_all(e.span, hir_vec![pat_let, body_stmt], None));\n+\n                 // `[opt_ident]: loop { ... }`\n-                let loop_block = P(self.block_expr(match_expr));\n                 let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident),\n                                               hir::LoopSource::ForLoop);\n                 let loop_expr = P(hir::Expr {\n@@ -2585,24 +2597,34 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn stmt_let(&mut self, sp: Span, mutbl: bool, ident: Name, ex: P<hir::Expr>)\n-                -> (hir::Stmt, NodeId) {\n-        let pat = if mutbl {\n-            self.pat_ident_binding_mode(sp, ident, hir::BindByValue(hir::MutMutable))\n-        } else {\n-            self.pat_ident(sp, ident)\n-        };\n-        let pat_id = pat.id;\n+    fn stmt_let_pat(&mut self,\n+                    sp: Span,\n+                    ex: P<hir::Expr>,\n+                    pat: P<hir::Pat>,\n+                    source: hir::LocalSource)\n+                    -> hir::Stmt {\n         let local = P(hir::Local {\n             pat: pat,\n             ty: None,\n             init: Some(ex),\n             id: self.next_id(),\n             span: sp,\n             attrs: ThinVec::new(),\n+            source,\n         });\n         let decl = respan(sp, hir::DeclLocal(local));\n-        (respan(sp, hir::StmtDecl(P(decl), self.next_id())), pat_id)\n+        respan(sp, hir::StmtDecl(P(decl), self.next_id()))\n+    }\n+\n+    fn stmt_let(&mut self, sp: Span, mutbl: bool, ident: Name, ex: P<hir::Expr>)\n+                -> (hir::Stmt, NodeId) {\n+        let pat = if mutbl {\n+            self.pat_ident_binding_mode(sp, ident, hir::BindByValue(hir::MutMutable))\n+        } else {\n+            self.pat_ident(sp, ident)\n+        };\n+        let pat_id = pat.id;\n+        (self.stmt_let_pat(sp, ex, pat, hir::LocalSource::Normal), pat_id)\n     }\n \n     fn block_expr(&mut self, expr: P<hir::Expr>) -> hir::Block {"}, {"sha": "3f2977cc503df5558d615a3afbf371d571193360", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0b17b4c0846d0e01544e90bb2aa2776576e825d1", "patch": "@@ -872,6 +872,7 @@ pub struct Local {\n     pub id: NodeId,\n     pub span: Span,\n     pub attrs: ThinVec<Attribute>,\n+    pub source: LocalSource,\n }\n \n pub type Decl = Spanned<Decl_>;\n@@ -1080,6 +1081,15 @@ pub enum QPath {\n     TypeRelative(P<Ty>, P<PathSegment>)\n }\n \n+/// Hints at the original code for a let statement\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum LocalSource {\n+    /// A `match _ { .. }`\n+    Normal,\n+    /// A desugared `for _ in _ { .. }` loop\n+    ForLoopDesugar,\n+}\n+\n /// Hints at the original code for a `match _ { .. }`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum MatchSource {"}, {"sha": "c582cac67e22b508e43dd5dd6e4c542da0a32518", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=0b17b4c0846d0e01544e90bb2aa2776576e825d1", "patch": "@@ -490,7 +490,8 @@ impl_stable_hash_for!(struct hir::Local {\n     init,\n     id,\n     span,\n-    attrs\n+    attrs,\n+    source\n });\n \n impl_stable_hash_for_spanned!(hir::Decl_);\n@@ -640,6 +641,11 @@ impl_stable_hash_for!(enum hir::Expr_ {\n     ExprRepeat(val, times)\n });\n \n+impl_stable_hash_for!(enum hir::LocalSource {\n+    Normal,\n+    ForLoopDesugar\n+});\n+\n impl_stable_hash_for!(enum hir::LoopSource {\n     Loop,\n     WhileLet,"}, {"sha": "7c3076fda4fe1f31d7b51fda097a5a68b51e244e", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 32, "deletions": 56, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=0b17b4c0846d0e01544e90bb2aa2776576e825d1", "patch": "@@ -91,7 +91,10 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n     fn visit_local(&mut self, loc: &'tcx hir::Local) {\n         intravisit::walk_local(self, loc);\n \n-        self.check_irrefutable(&loc.pat, false);\n+        self.check_irrefutable(&loc.pat, match loc.source {\n+            hir::LocalSource::Normal => \"local binding\",\n+            hir::LocalSource::ForLoopDesugar => \"`for` loop binding\",\n+        });\n \n         // Check legality of move bindings and `@` patterns.\n         self.check_patterns(false, slice::ref_slice(&loc.pat));\n@@ -101,7 +104,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n         intravisit::walk_body(self, body);\n \n         for arg in &body.arguments {\n-            self.check_irrefutable(&arg.pat, true);\n+            self.check_irrefutable(&arg.pat, \"function argument\");\n             self.check_patterns(false, slice::ref_slice(&arg.pat));\n         }\n     }\n@@ -210,7 +213,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 .map(|pat| vec![pat.0])\n                 .collect();\n             let scrut_ty = self.tables.node_id_to_type(scrut.id);\n-            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, source);\n+            check_exhaustive(cx, scrut_ty, scrut.span, &matrix);\n         })\n     }\n \n@@ -223,13 +226,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_irrefutable(&self, pat: &Pat, is_fn_arg: bool) {\n-        let origin = if is_fn_arg {\n-            \"function argument\"\n-        } else {\n-            \"local binding\"\n-        };\n-\n+    fn check_irrefutable(&self, pat: &Pat, origin: &str) {\n         let module = self.tcx.hir.get_module_parent(pat.id);\n         MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx, self.tables);\n@@ -395,8 +392,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                               scrut_ty: Ty<'tcx>,\n                               sp: Span,\n-                              matrix: &Matrix<'a, 'tcx>,\n-                              source: hir::MatchSource) {\n+                              matrix: &Matrix<'a, 'tcx>) {\n     let wild_pattern = Pattern {\n         ty: scrut_ty,\n         span: DUMMY_SP,\n@@ -409,52 +405,32 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             } else {\n                 pats.iter().map(|w| w.single_pattern()).collect()\n             };\n-            match source {\n-                hir::MatchSource::ForLoopDesugar => {\n-                    // `witnesses[0]` has the form `Some(<head>)`, peel off the `Some`\n-                    let witness = match *witnesses[0].kind {\n-                        PatternKind::Variant { ref subpatterns, .. } => match &subpatterns[..] {\n-                            &[ref pat] => &pat.pattern,\n-                            _ => bug!(),\n-                        },\n-                        _ => bug!(),\n-                    };\n-                    let pattern_string = witness.to_string();\n-                    struct_span_err!(cx.tcx.sess, sp, E0297,\n-                        \"refutable pattern in `for` loop binding: \\\n-                                `{}` not covered\",\n-                                pattern_string)\n-                        .span_label(sp, format!(\"pattern `{}` not covered\", pattern_string))\n-                        .emit();\n+\n+            const LIMIT: usize = 3;\n+            let joined_patterns = match witnesses.len() {\n+                0 => bug!(),\n+                1 => format!(\"`{}`\", witnesses[0]),\n+                2...LIMIT => {\n+                    let (tail, head) = witnesses.split_last().unwrap();\n+                    let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n+                    format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail)\n                 },\n                 _ => {\n-                    const LIMIT: usize = 3;\n-                    let joined_patterns = match witnesses.len() {\n-                        0 => bug!(),\n-                        1 => format!(\"`{}`\", witnesses[0]),\n-                        2...LIMIT => {\n-                            let (tail, head) = witnesses.split_last().unwrap();\n-                            let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n-                            format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail)\n-                        },\n-                        _ => {\n-                            let (head, tail) = witnesses.split_at(LIMIT);\n-                            let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n-                            format!(\"`{}` and {} more\", head.join(\"`, `\"), tail.len())\n-                        }\n-                    };\n-\n-                    let label_text = match witnesses.len() {\n-                        1 => format!(\"pattern {} not covered\", joined_patterns),\n-                        _ => format!(\"patterns {} not covered\", joined_patterns)\n-                    };\n-                    create_e0004(cx.tcx.sess, sp,\n-                                 format!(\"non-exhaustive patterns: {} not covered\",\n-                                         joined_patterns))\n-                        .span_label(sp, label_text)\n-                        .emit();\n-                },\n-            }\n+                    let (head, tail) = witnesses.split_at(LIMIT);\n+                    let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n+                    format!(\"`{}` and {} more\", head.join(\"`, `\"), tail.len())\n+                }\n+            };\n+\n+            let label_text = match witnesses.len() {\n+                1 => format!(\"pattern {} not covered\", joined_patterns),\n+                _ => format!(\"patterns {} not covered\", joined_patterns)\n+            };\n+            create_e0004(cx.tcx.sess, sp,\n+                            format!(\"non-exhaustive patterns: {} not covered\",\n+                                    joined_patterns))\n+                .span_label(sp, label_text)\n+                .emit();\n         }\n         NotUseful => {\n             // This is good, wildcard pattern isn't reachable"}, {"sha": "4fc7ef8035eb54d777351cb8cc2745957a5a1f69", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=0b17b4c0846d0e01544e90bb2aa2776576e825d1", "patch": "@@ -452,12 +452,14 @@ enum Method { GET, POST }\n \n \n E0297: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n Patterns used to bind names must be irrefutable. That is, they must guarantee\n that a name will be extracted in all cases. Instead of pattern matching the\n loop variable, consider using a `match` or `if let` inside the loop body. For\n instance:\n \n-```compile_fail,E0297\n+```compile_fail,E0005\n let xs : Vec<Option<i32>> = vec![Some(1), None];\n \n // This fails because `None` is not covered."}, {"sha": "436e4c1f9d22e6b5c047e4e08046f0fdfddc9293", "filename": "src/test/compile-fail/E0297.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Ftest%2Fcompile-fail%2FE0297.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Ftest%2Fcompile-fail%2FE0297.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0297.rs?ref=0b17b4c0846d0e01544e90bb2aa2776576e825d1", "patch": "@@ -12,6 +12,6 @@ fn main() {\n     let xs : Vec<Option<i32>> = vec![Some(1), None];\n \n     for Some(x) in xs {}\n-    //~^ ERROR E0297\n+    //~^ ERROR E0005\n     //~| NOTE pattern `None` not covered\n }"}, {"sha": "8c61fc602e09e7432845ce35afe008b3771af1d6", "filename": "src/test/compile-fail/for-loop-has-unit-body.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Ftest%2Fcompile-fail%2Ffor-loop-has-unit-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Ftest%2Fcompile-fail%2Ffor-loop-has-unit-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-has-unit-body.rs?ref=0b17b4c0846d0e01544e90bb2aa2776576e825d1", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    for x in 0..3 {\n+        x //~ ERROR mismatched types\n+        //~| NOTE expected ()\n+        //~| NOTE expected type `()`\n+    }\n+}"}, {"sha": "4036fc8480067ad1222bc0ce4031d7a019a80f10", "filename": "src/test/run-pass/for-loop-has-unit-body.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Ftest%2Frun-pass%2Ffor-loop-has-unit-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b17b4c0846d0e01544e90bb2aa2776576e825d1/src%2Ftest%2Frun-pass%2Ffor-loop-has-unit-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-has-unit-body.rs?ref=0b17b4c0846d0e01544e90bb2aa2776576e825d1", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    // Check that the tail statement in the body unifies with something\n+    for _ in 0..3 {\n+        unsafe { std::mem::uninitialized() }\n+    }\n+\n+    // Check that the tail statement in the body can be unit\n+    for _ in 0..3 {\n+        ()\n+    }\n+}"}]}