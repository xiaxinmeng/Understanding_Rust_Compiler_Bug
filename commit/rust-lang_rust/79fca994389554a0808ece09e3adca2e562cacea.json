{"sha": "79fca994389554a0808ece09e3adca2e562cacea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZmNhOTk0Mzg5NTU0YTA4MDhlY2UwOWUzYWRjYTJlNTYyY2FjZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-17T04:46:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-17T04:46:26Z"}, "message": "auto merge of #14947 : zwarich/rust/check-loans-not-restrictions, r=nikomatsakis\n\nNow that features like `const` are gone, we can remove the concept of restrictions from borrowck and just track loans and their restricted paths.", "tree": {"sha": "8804a9274e05388740f08e407b836c756443be96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8804a9274e05388740f08e407b836c756443be96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79fca994389554a0808ece09e3adca2e562cacea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79fca994389554a0808ece09e3adca2e562cacea", "html_url": "https://github.com/rust-lang/rust/commit/79fca994389554a0808ece09e3adca2e562cacea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79fca994389554a0808ece09e3adca2e562cacea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "html_url": "https://github.com/rust-lang/rust/commit/09967665eaa5ca3d259f0f59ef26c8d236bf47a7"}, {"sha": "480cd6fb9052e3db33e01c94e1193f80801b292f", "url": "https://api.github.com/repos/rust-lang/rust/commits/480cd6fb9052e3db33e01c94e1193f80801b292f", "html_url": "https://github.com/rust-lang/rust/commit/480cd6fb9052e3db33e01c94e1193f80801b292f"}], "stats": {"total": 431, "additions": 107, "deletions": 324}, "files": [{"sha": "166d069880f9fa7fd189aa11feb74937ac7faf96", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 82, "deletions": 207, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/79fca994389554a0808ece09e3adca2e562cacea/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fca994389554a0808ece09e3adca2e562cacea/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=79fca994389554a0808ece09e3adca2e562cacea", "patch": "@@ -155,6 +155,12 @@ enum UseError {\n     UseWhileBorrowed(/*loan*/Rc<LoanPath>, /*loan*/Span)\n }\n \n+fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n+                           borrow_kind2: ty::BorrowKind)\n+                           -> bool {\n+    borrow_kind1 == ty::ImmBorrow && borrow_kind2 == ty::ImmBorrow\n+}\n+\n impl<'a> CheckLoanCtxt<'a> {\n     pub fn tcx(&self) -> &'a ty::ctxt { self.bccx.tcx }\n \n@@ -189,29 +195,75 @@ impl<'a> CheckLoanCtxt<'a> {\n         })\n     }\n \n-    pub fn each_in_scope_restriction(&self,\n-                                     scope_id: ast::NodeId,\n-                                     loan_path: &LoanPath,\n-                                     op: |&Loan, &Restriction| -> bool)\n-                                     -> bool {\n-        //! Iterates through all the in-scope restrictions for the\n-        //! given `loan_path`\n+    fn each_in_scope_loan_affecting_path(&self,\n+                                         scope_id: ast::NodeId,\n+                                         loan_path: &LoanPath,\n+                                         op: |&Loan| -> bool)\n+                                         -> bool {\n+        //! Iterates through all of the in-scope loans affecting `loan_path`,\n+        //! calling `op`, and ceasing iteration if `false` is returned.\n \n-        self.each_in_scope_loan(scope_id, |loan| {\n-            debug!(\"each_in_scope_restriction found loan: {:?}\",\n-                   loan.repr(self.tcx()));\n+        // First, we check for a loan restricting the path P being used. This\n+        // accounts for borrows of P but also borrows of subpaths, like P.a.b.\n+        // Consider the following example:\n+        //\n+        //     let x = &mut a.b.c; // Restricts a, a.b, and a.b.c\n+        //     let y = a;          // Conflicts with restriction\n \n+        let cont = self.each_in_scope_loan(scope_id, |loan| {\n             let mut ret = true;\n-            for restr in loan.restrictions.iter() {\n-                if *restr.loan_path == *loan_path {\n-                    if !op(loan, restr) {\n+            for restr_path in loan.restricted_paths.iter() {\n+                if **restr_path == *loan_path {\n+                    if !op(loan) {\n                         ret = false;\n                         break;\n                     }\n                 }\n             }\n             ret\n-        })\n+        });\n+\n+        if !cont {\n+            return false;\n+        }\n+\n+        // Next, we must check for *loans* (not restrictions) on the path P or\n+        // any base path. This rejects examples like the following:\n+        //\n+        //     let x = &mut a.b;\n+        //     let y = a.b.c;\n+        //\n+        // Limiting this search to *loans* and not *restrictions* means that\n+        // examples like the following continue to work:\n+        //\n+        //     let x = &mut a.b;\n+        //     let y = a.c;\n+\n+        let mut loan_path = loan_path;\n+        loop {\n+            match *loan_path {\n+                LpVar(_) => {\n+                    break;\n+                }\n+                LpExtend(ref lp_base, _, _) => {\n+                    loan_path = &**lp_base;\n+                }\n+            }\n+\n+            let cont = self.each_in_scope_loan(scope_id, |loan| {\n+                if *loan.loan_path == *loan_path {\n+                    op(loan)\n+                } else {\n+                    true\n+                }\n+            });\n+\n+            if !cont {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n     }\n \n     pub fn loans_generated_by(&self, scope_id: ast::NodeId) -> Vec<uint> {\n@@ -288,26 +340,12 @@ impl<'a> CheckLoanCtxt<'a> {\n                loan1.repr(self.tcx()),\n                loan2.repr(self.tcx()));\n \n-        // Restrictions that would cause the new loan to be illegal:\n-        let illegal_if = match loan2.kind {\n-            // Look for restrictions against mutation. These are\n-            // generated by all other borrows.\n-            ty::MutBorrow => RESTR_MUTATE,\n-\n-            // Look for restrictions against freezing (immutable borrows).\n-            // These are generated by `&mut` borrows.\n-            ty::ImmBorrow => RESTR_FREEZE,\n-\n-            // No matter how the data is borrowed (as `&`, as `&mut`,\n-            // or as `&unique imm`) it will always generate a\n-            // restriction against mutating the data. So look for those.\n-            ty::UniqueImmBorrow => RESTR_MUTATE,\n-        };\n-        debug!(\"illegal_if={:?}\", illegal_if);\n+        if compatible_borrow_kinds(loan1.kind, loan2.kind) {\n+            return true;\n+        }\n \n-        for restr in loan1.restrictions.iter() {\n-            if !restr.set.intersects(illegal_if) { continue; }\n-            if restr.loan_path != loan2.loan_path { continue; }\n+        for restr_path in loan1.restricted_paths.iter() {\n+            if *restr_path != loan2.loan_path { continue; }\n \n             let old_pronoun = if new_loan.loan_path == old_loan.loan_path {\n                 \"it\".to_string()\n@@ -534,63 +572,16 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         let mut ret = UseOk;\n \n-        // First, we check for a restriction on the path P being used. This\n-        // accounts for borrows of P but also borrows of subpaths, like P.a.b.\n-        // Consider the following example:\n-        //\n-        //     let x = &mut a.b.c; // Restricts a, a.b, and a.b.c\n-        //     let y = a;          // Conflicts with restriction\n-\n-        self.each_in_scope_restriction(expr_id, use_path, |loan, _restr| {\n-            if incompatible(loan.kind, borrow_kind) {\n+        self.each_in_scope_loan_affecting_path(expr_id, use_path, |loan| {\n+            if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n                 ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n                 false\n             } else {\n                 true\n             }\n         });\n \n-        // Next, we must check for *loans* (not restrictions) on the path P or\n-        // any base path. This rejects examples like the following:\n-        //\n-        //     let x = &mut a.b;\n-        //     let y = a.b.c;\n-        //\n-        // Limiting this search to *loans* and not *restrictions* means that\n-        // examples like the following continue to work:\n-        //\n-        //     let x = &mut a.b;\n-        //     let y = a.c;\n-\n-        let mut loan_path = use_path;\n-        loop {\n-            self.each_in_scope_loan(expr_id, |loan| {\n-                if *loan.loan_path == *loan_path &&\n-                   incompatible(loan.kind, borrow_kind) {\n-                    ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n-                    false\n-                } else {\n-                    true\n-                }\n-            });\n-\n-            match *loan_path {\n-                LpVar(_) => {\n-                    break;\n-                }\n-                LpExtend(ref lp_base, _, _) => {\n-                    loan_path = &**lp_base;\n-                }\n-            }\n-        }\n-\n         return ret;\n-\n-        fn incompatible(borrow_kind1: ty::BorrowKind,\n-                        borrow_kind2: ty::BorrowKind)\n-                        -> bool {\n-            borrow_kind1 != ty::ImmBorrow || borrow_kind2 != ty::ImmBorrow\n-        }\n     }\n \n     fn check_if_path_is_moved(&self,\n@@ -668,11 +659,9 @@ impl<'a> CheckLoanCtxt<'a> {\n         // and aliasing restrictions:\n         if assignee_cmt.mutbl.is_mutable() {\n             if check_for_aliasable_mutable_writes(self, assignment_span, assignee_cmt.clone()) {\n-                if mode != euv::Init &&\n-                    check_for_assignment_to_restricted_or_frozen_location(\n-                        self, assignment_id, assignment_span, assignee_cmt.clone())\n-                {\n-                    // Safe, but record for lint pass later:\n+                if mode != euv::Init {\n+                    check_for_assignment_to_borrowed_path(\n+                        self, assignment_id, assignment_span, assignee_cmt.clone());\n                     mark_variable_as_used_mut(self, assignee_cmt);\n                 }\n             }\n@@ -807,138 +796,24 @@ impl<'a> CheckLoanCtxt<'a> {\n             }\n         }\n \n-        fn check_for_assignment_to_restricted_or_frozen_location(\n+        fn check_for_assignment_to_borrowed_path(\n             this: &CheckLoanCtxt,\n             assignment_id: ast::NodeId,\n             assignment_span: Span,\n-            assignee_cmt: mc::cmt) -> bool\n+            assignee_cmt: mc::cmt)\n         {\n             //! Check for assignments that violate the terms of an\n             //! outstanding loan.\n \n             let loan_path = match opt_loan_path(&assignee_cmt) {\n                 Some(lp) => lp,\n-                None => { return true; /* no loan path, can't be any loans */ }\n+                None => { return; /* no loan path, can't be any loans */ }\n             };\n \n-            // Start by searching for an assignment to a *restricted*\n-            // location. Here is one example of the kind of error caught\n-            // by this check:\n-            //\n-            //    let mut v = ~[1, 2, 3];\n-            //    let p = &v;\n-            //    v = ~[4];\n-            //\n-            // In this case, creating `p` triggers a RESTR_MUTATE\n-            // restriction on the path `v`.\n-            //\n-            // Here is a second, more subtle example:\n-            //\n-            //    let mut v = ~[1, 2, 3];\n-            //    let p = &const v[0];\n-            //    v[0] = 4;                   // OK\n-            //    v[1] = 5;                   // OK\n-            //    v = ~[4, 5, 3];             // Error\n-            //\n-            // In this case, `p` is pointing to `v[0]`, and it is a\n-            // `const` pointer in any case. So the first two\n-            // assignments are legal (and would be permitted by this\n-            // check). However, the final assignment (which is\n-            // logically equivalent) is forbidden, because it would\n-            // cause the existing `v` array to be freed, thus\n-            // invalidating `p`. In the code, this error results\n-            // because `gather_loans::restrictions` adds a\n-            // `RESTR_MUTATE` restriction whenever the contents of an\n-            // owned pointer are borrowed, and hence while `v[*]` is not\n-            // restricted from being written, `v` is.\n-            let cont = this.each_in_scope_restriction(assignment_id,\n-                                                      &*loan_path,\n-                                                      |loan, restr| {\n-                if restr.set.intersects(RESTR_MUTATE) {\n-                    this.report_illegal_mutation(assignment_span, &*loan_path, loan);\n-                    false\n-                } else {\n-                    true\n-                }\n+            this.each_in_scope_loan_affecting_path(assignment_id, &*loan_path, |loan| {\n+                this.report_illegal_mutation(assignment_span, &*loan_path, loan);\n+                false\n             });\n-\n-            if !cont { return false }\n-\n-            // The previous code handled assignments to paths that\n-            // have been restricted. This covers paths that have been\n-            // directly lent out and their base paths, but does not\n-            // cover random extensions of those paths. For example,\n-            // the following program is not declared illegal by the\n-            // previous check:\n-            //\n-            //    let mut v = ~[1, 2, 3];\n-            //    let p = &v;\n-            //    v[0] = 4; // declared error by loop below, not code above\n-            //\n-            // The reason that this passes the previous check whereas\n-            // an assignment like `v = ~[4]` fails is because the assignment\n-            // here is to `v[*]`, and the existing restrictions were issued\n-            // for `v`, not `v[*]`.\n-            //\n-            // So in this loop, we walk back up the loan path so long\n-            // as the mutability of the path is dependent on a super\n-            // path, and check that the super path was not lent out as\n-            // mutable or immutable (a const loan is ok).\n-            //\n-            // Mutability of a path can be dependent on the super path\n-            // in two ways. First, it might be inherited mutability.\n-            // Second, the pointee of an `&mut` pointer can only be\n-            // mutated if it is found in an unaliased location, so we\n-            // have to check that the owner location is not borrowed.\n-            //\n-            // Note that we are *not* checking for any and all\n-            // restrictions.  We are only interested in the pointers\n-            // that the user created, whereas we add restrictions for\n-            // all kinds of paths that are not directly aliased. If we checked\n-            // for all restrictions, and not just loans, then the following\n-            // valid program would be considered illegal:\n-            //\n-            //    let mut v = ~[1, 2, 3];\n-            //    let p = &const v[0];\n-            //    v[1] = 5; // ok\n-            //\n-            // Here the restriction that `v` not be mutated would be misapplied\n-            // to block the subpath `v[1]`.\n-            let full_loan_path = loan_path.clone();\n-            let mut loan_path = loan_path;\n-            loop {\n-                loan_path = match *loan_path {\n-                    // Peel back one layer if, for `loan_path` to be\n-                    // mutable, `lp_base` must be mutable. This occurs\n-                    // with inherited mutability, owned pointers and\n-                    // `&mut` pointers.\n-                    LpExtend(ref lp_base, mc::McInherited, _) |\n-                    LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) |\n-                    LpExtend(ref lp_base, _, LpDeref(mc::GcPtr)) |\n-                    LpExtend(ref lp_base, _, LpDeref(mc::BorrowedPtr(ty::MutBorrow, _))) => {\n-                        lp_base.clone()\n-                    }\n-\n-                    // Otherwise stop iterating\n-                    LpExtend(_, mc::McDeclared, _) |\n-                    LpExtend(_, mc::McImmutable, _) |\n-                    LpVar(_) => {\n-                        return true;\n-                    }\n-                };\n-\n-                // Check for a non-const loan of `loan_path`\n-                let cont = this.each_in_scope_loan(assignment_id, |loan| {\n-                    if loan.loan_path == loan_path {\n-                        this.report_illegal_mutation(assignment_span, &*full_loan_path, loan);\n-                        false\n-                    } else {\n-                        true\n-                    }\n-                });\n-\n-                if !cont { return false }\n-            }\n         }\n     }\n "}, {"sha": "89f304513ffb315580607438d55c03a7af2a07a5", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/79fca994389554a0808ece09e3adca2e562cacea/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fca994389554a0808ece09e3adca2e562cacea/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=79fca994389554a0808ece09e3adca2e562cacea", "patch": "@@ -259,7 +259,7 @@ impl<'a> GatherLoanCtxt<'a> {\n         // loan is safe.\n         let restr = restrictions::compute_restrictions(\n             self.bccx, borrow_span, cause,\n-            cmt.clone(), loan_region, self.restriction_set(req_kind));\n+            cmt.clone(), loan_region);\n \n         // Create the loan record (if needed).\n         let loan = match restr {\n@@ -268,7 +268,7 @@ impl<'a> GatherLoanCtxt<'a> {\n                 return;\n             }\n \n-            restrictions::SafeIf(loan_path, restrictions) => {\n+            restrictions::SafeIf(loan_path, restricted_paths) => {\n                 let loan_scope = match loan_region {\n                     ty::ReScope(id) => id,\n                     ty::ReFree(ref fr) => fr.scope_id,\n@@ -314,7 +314,7 @@ impl<'a> GatherLoanCtxt<'a> {\n                     gen_scope: gen_scope,\n                     kill_scope: kill_scope,\n                     span: borrow_span,\n-                    restrictions: restrictions,\n+                    restricted_paths: restricted_paths,\n                     cause: cause,\n                 }\n             }\n@@ -390,21 +390,6 @@ impl<'a> GatherLoanCtxt<'a> {\n         }\n     }\n \n-    fn restriction_set(&self, req_kind: ty::BorrowKind) -> RestrictionSet {\n-        match req_kind {\n-            // If borrowing data as immutable, no mutation allowed:\n-            ty::ImmBorrow => RESTR_MUTATE,\n-\n-            // If borrowing data as mutable, no mutation nor other\n-            // borrows allowed:\n-            ty::MutBorrow => RESTR_MUTATE | RESTR_FREEZE,\n-\n-            // If borrowing data as unique imm, no mutation nor other\n-            // borrows allowed:\n-            ty::UniqueImmBorrow => RESTR_MUTATE | RESTR_FREEZE,\n-        }\n-    }\n-\n     pub fn mark_loan_path_as_mutated(&self, loan_path: &LoanPath) {\n         //! For mutable loans of content whose mutability derives\n         //! from a local variable, mark the mutability decl as necessary."}, {"sha": "5b3e1ac0b2c74ab42f30f927c10d2a57234ee243", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/79fca994389554a0808ece09e3adca2e562cacea/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fca994389554a0808ece09e3adca2e562cacea/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=79fca994389554a0808ece09e3adca2e562cacea", "patch": "@@ -23,23 +23,22 @@ use std::rc::Rc;\n \n pub enum RestrictionResult {\n     Safe,\n-    SafeIf(Rc<LoanPath>, Vec<Restriction>)\n+    SafeIf(Rc<LoanPath>, Vec<Rc<LoanPath>>)\n }\n \n pub fn compute_restrictions(bccx: &BorrowckCtxt,\n                             span: Span,\n                             cause: euv::LoanCause,\n                             cmt: mc::cmt,\n-                            loan_region: ty::Region,\n-                            restr: RestrictionSet) -> RestrictionResult {\n+                            loan_region: ty::Region) -> RestrictionResult {\n     let ctxt = RestrictionsContext {\n         bccx: bccx,\n         span: span,\n         cause: cause,\n         loan_region: loan_region,\n     };\n \n-    ctxt.restrict(cmt, restr)\n+    ctxt.restrict(cmt)\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -54,11 +53,8 @@ struct RestrictionsContext<'a> {\n \n impl<'a> RestrictionsContext<'a> {\n     fn restrict(&self,\n-                cmt: mc::cmt,\n-                restrictions: RestrictionSet) -> RestrictionResult {\n-        debug!(\"restrict(cmt={}, restrictions={})\",\n-               cmt.repr(self.bccx.tcx),\n-               restrictions.repr(self.bccx.tcx));\n+                cmt: mc::cmt) -> RestrictionResult {\n+        debug!(\"restrict(cmt={})\", cmt.repr(self.bccx.tcx));\n \n         match cmt.cat.clone() {\n             mc::cat_rvalue(..) => {\n@@ -75,19 +71,14 @@ impl<'a> RestrictionsContext<'a> {\n             mc::cat_upvar(ty::UpvarId {var_id: local_id, ..}, _) => {\n                 // R-Variable\n                 let lp = Rc::new(LpVar(local_id));\n-                SafeIf(lp.clone(), vec!(Restriction {\n-                    loan_path: lp,\n-                    set: restrictions\n-                }))\n+                SafeIf(lp.clone(), vec!(lp))\n             }\n \n             mc::cat_downcast(cmt_base) => {\n                 // When we borrow the interior of an enum, we have to\n                 // ensure the enum itself is not mutated, because that\n                 // could cause the type of the memory to change.\n-                self.restrict(\n-                    cmt_base,\n-                    restrictions | RESTR_MUTATE)\n+                self.restrict(cmt_base)\n             }\n \n             mc::cat_interior(cmt_base, i) => {\n@@ -96,8 +87,8 @@ impl<'a> RestrictionsContext<'a> {\n                 // Overwriting the base would not change the type of\n                 // the memory, so no additional restrictions are\n                 // needed.\n-                let result = self.restrict(cmt_base, restrictions);\n-                self.extend(result, cmt.mutbl, LpInterior(i), restrictions)\n+                let result = self.restrict(cmt_base);\n+                self.extend(result, cmt.mutbl, LpInterior(i))\n             }\n \n             mc::cat_deref(cmt_base, _, pk @ mc::OwnedPtr) |\n@@ -112,10 +103,8 @@ impl<'a> RestrictionsContext<'a> {\n                 // same, because this could be the last ref.\n                 // Eventually we should make these non-special and\n                 // just rely on Deref<T> implementation.\n-                let result = self.restrict(\n-                    cmt_base,\n-                    restrictions | RESTR_MUTATE);\n-                self.extend(result, cmt.mutbl, LpDeref(pk), restrictions)\n+                let result = self.restrict(cmt_base);\n+                self.extend(result, cmt.mutbl, LpDeref(pk))\n             }\n \n             mc::cat_copied_upvar(..) | // FIXME(#2152) allow mutation of upvars\n@@ -133,7 +122,7 @@ impl<'a> RestrictionsContext<'a> {\n                             cause: self.cause,\n                             cmt: cmt_base,\n                             code: err_borrowed_pointer_too_short(\n-                                self.loan_region, lt, restrictions)});\n+                                self.loan_region, lt)});\n                     return Safe;\n                 }\n                 Safe\n@@ -148,12 +137,12 @@ impl<'a> RestrictionsContext<'a> {\n                             cause: self.cause,\n                             cmt: cmt_base,\n                             code: err_borrowed_pointer_too_short(\n-                                self.loan_region, lt, restrictions)});\n+                                self.loan_region, lt)});\n                     return Safe;\n                 }\n \n-                let result = self.restrict(cmt_base, restrictions);\n-                self.extend(result, cmt.mutbl, LpDeref(pk), restrictions)\n+                let result = self.restrict(cmt_base);\n+                self.extend(result, cmt.mutbl, LpDeref(pk))\n             }\n \n             mc::cat_deref(_, _, mc::UnsafePtr(..)) => {\n@@ -162,24 +151,20 @@ impl<'a> RestrictionsContext<'a> {\n             }\n \n             mc::cat_discr(cmt_base, _) => {\n-                self.restrict(cmt_base, restrictions)\n+                self.restrict(cmt_base)\n             }\n         }\n     }\n \n     fn extend(&self,\n               result: RestrictionResult,\n               mc: mc::MutabilityCategory,\n-              elem: LoanPathElem,\n-              restrictions: RestrictionSet) -> RestrictionResult {\n+              elem: LoanPathElem) -> RestrictionResult {\n         match result {\n             Safe => Safe,\n             SafeIf(base_lp, mut base_vec) => {\n                 let lp = Rc::new(LpExtend(base_lp, mc, elem));\n-                base_vec.push(Restriction {\n-                    loan_path: lp.clone(),\n-                    set: restrictions\n-                });\n+                base_vec.push(lp.clone());\n                 SafeIf(lp, base_vec)\n             }\n         }"}, {"sha": "18cd0b1326d9610e38955b000c5035a8e29cfd54", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 66, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/79fca994389554a0808ece09e3adca2e562cacea/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fca994389554a0808ece09e3adca2e562cacea/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=79fca994389554a0808ece09e3adca2e562cacea", "patch": "@@ -21,7 +21,6 @@ use middle::ty;\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use std::cell::{Cell};\n-use std::ops::{BitOr, BitAnd};\n use std::rc::Rc;\n use std::gc::{Gc, GC};\n use std::string::String;\n@@ -182,7 +181,7 @@ pub struct Loan {\n     index: uint,\n     loan_path: Rc<LoanPath>,\n     kind: ty::BorrowKind,\n-    restrictions: Vec<Restriction>,\n+    restricted_paths: Vec<Rc<LoanPath>>,\n     gen_scope: ast::NodeId,\n     kill_scope: ast::NodeId,\n     span: Span,\n@@ -250,58 +249,6 @@ pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Restrictions\n-//\n-// Borrowing an lvalue often results in *restrictions* that limit what\n-// can be done with this lvalue during the scope of the loan:\n-//\n-// - `RESTR_MUTATE`: The lvalue may not be modified or `&mut` borrowed.\n-// - `RESTR_FREEZE`: `&` borrows of the lvalue are forbidden.\n-//\n-// In addition, no value which is restricted may be moved. Therefore,\n-// restrictions are meaningful even if the RestrictionSet is empty,\n-// because the restriction against moves is implied.\n-\n-pub struct Restriction {\n-    loan_path: Rc<LoanPath>,\n-    set: RestrictionSet\n-}\n-\n-#[deriving(PartialEq)]\n-pub struct RestrictionSet {\n-    bits: u32\n-}\n-\n-#[allow(dead_code)] // potentially useful\n-pub static RESTR_EMPTY: RestrictionSet  = RestrictionSet {bits: 0b0000};\n-pub static RESTR_MUTATE: RestrictionSet = RestrictionSet {bits: 0b0001};\n-pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b0010};\n-\n-impl RestrictionSet {\n-    pub fn intersects(&self, restr: RestrictionSet) -> bool {\n-        (self.bits & restr.bits) != 0\n-    }\n-}\n-\n-impl BitOr<RestrictionSet,RestrictionSet> for RestrictionSet {\n-    fn bitor(&self, rhs: &RestrictionSet) -> RestrictionSet {\n-        RestrictionSet {bits: self.bits | rhs.bits}\n-    }\n-}\n-\n-impl BitAnd<RestrictionSet,RestrictionSet> for RestrictionSet {\n-    fn bitand(&self, rhs: &RestrictionSet) -> RestrictionSet {\n-        RestrictionSet {bits: self.bits & rhs.bits}\n-    }\n-}\n-\n-impl Repr for RestrictionSet {\n-    fn repr(&self, _tcx: &ty::ctxt) -> String {\n-        format!(\"RestrictionSet(0x{:x})\", self.bits as uint)\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Errors\n \n@@ -310,8 +257,7 @@ impl Repr for RestrictionSet {\n pub enum bckerr_code {\n     err_mutbl,\n     err_out_of_scope(ty::Region, ty::Region), // superscope, subscope\n-    err_borrowed_pointer_too_short(\n-        ty::Region, ty::Region, RestrictionSet), // loan, ptr\n+    err_borrowed_pointer_too_short(ty::Region, ty::Region), // loan, ptr\n }\n \n // Combination of an error code and the categorization of the expression\n@@ -711,7 +657,7 @@ impl<'a> BorrowckCtxt<'a> {\n                     suggestion);\n             }\n \n-            err_borrowed_pointer_too_short(loan_scope, ptr_scope, _) => {\n+            err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n                 let descr = match opt_loan_path(&err.cmt) {\n                     Some(lp) => {\n                         format!(\"`{}`\", self.loan_path_to_str(&*lp))\n@@ -827,15 +773,7 @@ impl Repr for Loan {\n                  self.kind,\n                  self.gen_scope,\n                  self.kill_scope,\n-                 self.restrictions.repr(tcx))).to_string()\n-    }\n-}\n-\n-impl Repr for Restriction {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        (format!(\"Restriction({}, {:x})\",\n-                 self.loan_path.repr(tcx),\n-                 self.set.bits as uint)).to_string()\n+                 self.restricted_paths.repr(tcx))).to_string()\n     }\n }\n "}]}