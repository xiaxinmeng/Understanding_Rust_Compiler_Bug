{"sha": "6b269e44322cfca727fd0e793d3a60bd371cbcae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMjY5ZTQ0MzIyY2ZjYTcyN2ZkMGU3OTNkM2E2MGJkMzcxY2JjYWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-29T22:24:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-29T22:24:46Z"}, "message": "Auto merge of #73767 - P1n3appl3:rustdoc-formats, r=tmandry\n\nRefactor librustdoc html backend\n\nThis PR moves several types out of the librustdoc::html module so that they can be used by a future json backend. These changes are a re-implementation of [some work done 6 months ago](https://github.com/rust-lang/rust/compare/master...GuillaumeGomez:multiple-output-formats) by @GuillaumeGomez. I'm currently working on said json backend and will put up an RFC soon with the proposed implementation.\n\nThere are a couple of changes that are more substantial than relocating structs to a different module:\n1. The `Cache` is no longer part of the `html::render::Context` type and therefor it needs to be explicitly passed to any functions that access it.\n2. The driving function `html::render::run` has been rewritten to use the `FormatRenderer` trait which should allow different backends to re-use the driving code.\n\nr? @GuillaumeGomez\n\ncc @tmandry @betamos", "tree": {"sha": "c1f6506d49873a56567536557959448ba6ac90c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1f6506d49873a56567536557959448ba6ac90c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b269e44322cfca727fd0e793d3a60bd371cbcae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b269e44322cfca727fd0e793d3a60bd371cbcae", "html_url": "https://github.com/rust-lang/rust/commit/6b269e44322cfca727fd0e793d3a60bd371cbcae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b269e44322cfca727fd0e793d3a60bd371cbcae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db0492ace429cfeb3567e2c04e300be7df9972ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/db0492ace429cfeb3567e2c04e300be7df9972ff", "html_url": "https://github.com/rust-lang/rust/commit/db0492ace429cfeb3567e2c04e300be7df9972ff"}, {"sha": "29df0508f3106d152ad2cd1b41cf627b98ea9d6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/29df0508f3106d152ad2cd1b41cf627b98ea9d6f", "html_url": "https://github.com/rust-lang/rust/commit/29df0508f3106d152ad2cd1b41cf627b98ea9d6f"}], "stats": {"total": 2275, "additions": 1203, "deletions": 1072}, "files": [{"sha": "89549eae2cb0e7bfdb6a18eb84efb8cffeae155a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -32,8 +32,9 @@ use crate::clean::inline;\n use crate::clean::types::Type::{QPath, ResolvedPath};\n use crate::core::DocContext;\n use crate::doctree;\n-use crate::html::item_type::ItemType;\n-use crate::html::render::{cache, ExternalLocation};\n+use crate::formats::cache::cache;\n+use crate::formats::item_type::ItemType;\n+use crate::html::render::cache::ExternalLocation;\n \n use self::FnRetTy::*;\n use self::ItemEnum::*;\n@@ -1172,7 +1173,7 @@ impl GetDefId for Type {\n     fn def_id(&self) -> Option<DefId> {\n         match *self {\n             ResolvedPath { did, .. } => Some(did),\n-            Primitive(p) => crate::html::render::cache().primitive_locations.get(&p).cloned(),\n+            Primitive(p) => cache().primitive_locations.get(&p).cloned(),\n             BorrowedRef { type_: box Generic(..), .. } => {\n                 Primitive(PrimitiveType::Reference).def_id()\n             }"}, {"sha": "3547b45dfa71f95b095723e2ef6c03749f00d871", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -4,6 +4,9 @@ use std::ffi::OsStr;\n use std::fmt;\n use std::path::PathBuf;\n \n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::middle::privacy::AccessLevels;\n use rustc_session::config::{self, parse_crate_types_from_list, parse_externs, CrateType};\n use rustc_session::config::{\n     build_codegen_options, build_debugging_options, get_cmd_lint_options, host_triple,\n@@ -249,6 +252,20 @@ pub struct RenderOptions {\n     pub document_hidden: bool,\n }\n \n+/// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n+/// Later on moved into `CACHE_KEY`.\n+#[derive(Default, Clone)]\n+pub struct RenderInfo {\n+    pub inlined: FxHashSet<DefId>,\n+    pub external_paths: crate::core::ExternalPaths,\n+    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n+    pub access_levels: AccessLevels<DefId>,\n+    pub deref_trait_did: Option<DefId>,\n+    pub deref_mut_trait_did: Option<DefId>,\n+    pub owned_box_did: Option<DefId>,\n+    pub output_format: Option<OutputFormat>,\n+}\n+\n impl Options {\n     /// Parses the given command-line for options. If an error message or other early-return has\n     /// been printed, returns `Err` with the exit code."}, {"sha": "2c2ebc9291b98f6e7423a88c2fbe255f42f8f7cd", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -32,8 +32,8 @@ use std::rc::Rc;\n \n use crate::clean;\n use crate::clean::{AttributesExt, MAX_DEF_ID};\n+use crate::config::RenderInfo;\n use crate::config::{Options as RustdocOptions, RenderOptions};\n-use crate::html::render::RenderInfo;\n use crate::passes::{self, Condition::*, ConditionalPass};\n \n pub use rustc_session::config::{CodegenOptions, DebuggingOptions, Input, Options};\n@@ -44,9 +44,9 @@ pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n pub struct DocContext<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub resolver: Rc<RefCell<interface::BoxedResolver>>,\n-    /// Later on moved into `html::render::CACHE_KEY`\n+    /// Later on moved into `CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n-    /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n+    /// Later on moved through `clean::Crate` into `CACHE_KEY`\n     pub external_traits: Rc<RefCell<FxHashMap<DefId, clean::Trait>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time."}, {"sha": "4ce6bcbe2749e0e7e4bb7a18954c0dce1ad809a6", "filename": "src/librustdoc/docfs.rs", "status": "modified", "additions": 16, "deletions": 45, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fdocfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fdocfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdocfs.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -13,8 +13,7 @@ use std::fs;\n use std::io;\n use std::path::Path;\n use std::string::ToString;\n-use std::sync::mpsc::{channel, Receiver, Sender};\n-use std::sync::Arc;\n+use std::sync::mpsc::Sender;\n \n macro_rules! try_err {\n     ($e:expr, $file:expr) => {\n@@ -31,47 +30,24 @@ pub trait PathError {\n         S: ToString + Sized;\n }\n \n-pub struct ErrorStorage {\n-    sender: Option<Sender<Option<String>>>,\n-    receiver: Receiver<Option<String>>,\n-}\n-\n-impl ErrorStorage {\n-    pub fn new() -> ErrorStorage {\n-        let (sender, receiver) = channel();\n-        ErrorStorage { sender: Some(sender), receiver }\n-    }\n-\n-    /// Prints all stored errors. Returns the number of printed errors.\n-    pub fn write_errors(&mut self, diag: &rustc_errors::Handler) -> usize {\n-        let mut printed = 0;\n-        // In order to drop the sender part of the channel.\n-        self.sender = None;\n-\n-        for msg in self.receiver.iter() {\n-            if let Some(ref error) = msg {\n-                diag.struct_err(&error).emit();\n-                printed += 1;\n-            }\n-        }\n-        printed\n-    }\n-}\n-\n pub struct DocFS {\n     sync_only: bool,\n-    errors: Arc<ErrorStorage>,\n+    errors: Option<Sender<String>>,\n }\n \n impl DocFS {\n-    pub fn new(errors: &Arc<ErrorStorage>) -> DocFS {\n-        DocFS { sync_only: false, errors: Arc::clone(errors) }\n+    pub fn new(errors: Sender<String>) -> DocFS {\n+        DocFS { sync_only: false, errors: Some(errors) }\n     }\n \n     pub fn set_sync_only(&mut self, sync_only: bool) {\n         self.sync_only = sync_only;\n     }\n \n+    pub fn close(&mut self) {\n+        self.errors = None;\n+    }\n+\n     pub fn create_dir_all<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n         // For now, dir creation isn't a huge time consideration, do it\n         // synchronously, which avoids needing ordering between write() actions\n@@ -88,20 +64,15 @@ impl DocFS {\n         if !self.sync_only && cfg!(windows) {\n             // A possible future enhancement after more detailed profiling would\n             // be to create the file sync so errors are reported eagerly.\n-            let contents = contents.as_ref().to_vec();\n             let path = path.as_ref().to_path_buf();\n-            let sender = self.errors.sender.clone().unwrap();\n-            rayon::spawn(move || match fs::write(&path, &contents) {\n-                Ok(_) => {\n-                    sender.send(None).unwrap_or_else(|_| {\n-                        panic!(\"failed to send error on \\\"{}\\\"\", path.display())\n-                    });\n-                }\n-                Err(e) => {\n-                    sender.send(Some(format!(\"\\\"{}\\\": {}\", path.display(), e))).unwrap_or_else(\n-                        |_| panic!(\"failed to send non-error on \\\"{}\\\"\", path.display()),\n-                    );\n-                }\n+            let contents = contents.as_ref().to_vec();\n+            let sender = self.errors.clone().expect(\"can't write after closing\");\n+            rayon::spawn(move || {\n+                fs::write(&path, contents).unwrap_or_else(|e| {\n+                    sender\n+                        .send(format!(\"\\\"{}\\\": {}\", path.display(), e))\n+                        .expect(&format!(\"failed to send error on \\\"{}\\\"\", path.display()));\n+                });\n             });\n             Ok(())\n         } else {"}, {"sha": "77063ab4639a121dccb44de7342941eee56e8766", "filename": "src/librustdoc/error.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ferror.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -0,0 +1,56 @@\n+use std::error;\n+use std::fmt::{self, Formatter};\n+use std::path::{Path, PathBuf};\n+\n+use crate::docfs::PathError;\n+\n+#[derive(Debug)]\n+pub struct Error {\n+    pub file: PathBuf,\n+    pub error: String,\n+}\n+\n+impl error::Error for Error {}\n+\n+impl std::fmt::Display for Error {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n+        let file = self.file.display().to_string();\n+        if file.is_empty() {\n+            write!(f, \"{}\", self.error)\n+        } else {\n+            write!(f, \"\\\"{}\\\": {}\", self.file.display(), self.error)\n+        }\n+    }\n+}\n+\n+impl PathError for Error {\n+    fn new<S, P: AsRef<Path>>(e: S, path: P) -> Error\n+    where\n+        S: ToString + Sized,\n+    {\n+        Error { file: path.as_ref().to_path_buf(), error: e.to_string() }\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! try_none {\n+    ($e:expr, $file:expr) => {{\n+        use std::io;\n+        match $e {\n+            Some(e) => e,\n+            None => {\n+                return Err(Error::new(io::Error::new(io::ErrorKind::Other, \"not found\"), $file));\n+            }\n+        }\n+    }};\n+}\n+\n+#[macro_export]\n+macro_rules! try_err {\n+    ($e:expr, $file:expr) => {{\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => return Err(Error::new(e, $file)),\n+        }\n+    }};\n+}"}, {"sha": "99b31473f87a371651bbe87295d607f1eebf349b", "filename": "src/librustdoc/formats/cache.rs", "status": "added", "additions": 488, "deletions": 0, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -0,0 +1,488 @@\n+use std::cell::RefCell;\n+use std::collections::BTreeMap;\n+use std::mem;\n+use std::path::{Path, PathBuf};\n+use std::sync::Arc;\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n+use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_span::source_map::FileName;\n+\n+use crate::clean::{self, GetDefId};\n+use crate::config::RenderInfo;\n+use crate::fold::DocFolder;\n+use crate::formats::item_type::ItemType;\n+use crate::formats::Impl;\n+use crate::html::render::cache::{extern_location, get_index_search_type, ExternalLocation};\n+use crate::html::render::IndexItem;\n+use crate::html::render::{plain_summary_line, shorten};\n+\n+thread_local!(crate static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n+\n+/// This cache is used to store information about the `clean::Crate` being\n+/// rendered in order to provide more useful documentation. This contains\n+/// information like all implementors of a trait, all traits a type implements,\n+/// documentation for all known traits, etc.\n+///\n+/// This structure purposefully does not implement `Clone` because it's intended\n+/// to be a fairly large and expensive structure to clone. Instead this adheres\n+/// to `Send` so it may be stored in a `Arc` instance and shared among the various\n+/// rendering threads.\n+#[derive(Default)]\n+pub struct Cache {\n+    /// Maps a type ID to all known implementations for that type. This is only\n+    /// recognized for intra-crate `ResolvedPath` types, and is used to print\n+    /// out extra documentation on the page of an enum/struct.\n+    ///\n+    /// The values of the map are a list of implementations and documentation\n+    /// found on that implementation.\n+    pub impls: FxHashMap<DefId, Vec<Impl>>,\n+\n+    /// Maintains a mapping of local crate `DefId`s to the fully qualified name\n+    /// and \"short type description\" of that node. This is used when generating\n+    /// URLs when a type is being linked to. External paths are not located in\n+    /// this map because the `External` type itself has all the information\n+    /// necessary.\n+    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+\n+    /// Similar to `paths`, but only holds external paths. This is only used for\n+    /// generating explicit hyperlinks to other crates.\n+    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+\n+    /// Maps local `DefId`s of exported types to fully qualified paths.\n+    /// Unlike 'paths', this mapping ignores any renames that occur\n+    /// due to 'use' statements.\n+    ///\n+    /// This map is used when writing out the special 'implementors'\n+    /// javascript file. By using the exact path that the type\n+    /// is declared with, we ensure that each path will be identical\n+    /// to the path used if the corresponding type is inlined. By\n+    /// doing this, we can detect duplicate impls on a trait page, and only display\n+    /// the impl for the inlined type.\n+    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n+\n+    /// This map contains information about all known traits of this crate.\n+    /// Implementations of a crate should inherit the documentation of the\n+    /// parent trait if no extra documentation is specified, and default methods\n+    /// should show up in documentation about trait implementations.\n+    pub traits: FxHashMap<DefId, clean::Trait>,\n+\n+    /// When rendering traits, it's often useful to be able to list all\n+    /// implementors of the trait, and this mapping is exactly, that: a mapping\n+    /// of trait ids to the list of known implementors of the trait\n+    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n+\n+    /// Cache of where external crate documentation can be found.\n+    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n+\n+    /// Cache of where documentation for primitives can be found.\n+    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n+\n+    // Note that external items for which `doc(hidden)` applies to are shown as\n+    // non-reachable while local items aren't. This is because we're reusing\n+    // the access levels from the privacy check pass.\n+    pub access_levels: AccessLevels<DefId>,\n+\n+    /// The version of the crate being documented, if given from the `--crate-version` flag.\n+    pub crate_version: Option<String>,\n+\n+    /// Whether to document private items.\n+    /// This is stored in `Cache` so it doesn't need to be passed through all rustdoc functions.\n+    pub document_private: bool,\n+\n+    // Private fields only used when initially crawling a crate to build a cache\n+    stack: Vec<String>,\n+    parent_stack: Vec<DefId>,\n+    parent_is_trait_impl: bool,\n+    stripped_mod: bool,\n+    masked_crates: FxHashSet<CrateNum>,\n+\n+    pub search_index: Vec<IndexItem>,\n+    pub deref_trait_did: Option<DefId>,\n+    pub deref_mut_trait_did: Option<DefId>,\n+    pub owned_box_did: Option<DefId>,\n+\n+    // In rare case where a structure is defined in one module but implemented\n+    // in another, if the implementing module is parsed before defining module,\n+    // then the fully qualified name of the structure isn't presented in `paths`\n+    // yet when its implementation methods are being indexed. Caches such methods\n+    // and their parent id here and indexes them at the end of crate parsing.\n+    pub orphan_impl_items: Vec<(DefId, clean::Item)>,\n+\n+    // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n+    // even though the trait itself is not exported. This can happen if a trait\n+    // was defined in function/expression scope, since the impl will be picked\n+    // up by `collect-trait-impls` but the trait won't be scraped out in the HIR\n+    // crawl. In order to prevent crashes when looking for spotlight traits or\n+    // when gathering trait documentation on a type, hold impls here while\n+    // folding and add them to the cache later on if we find the trait.\n+    orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n+\n+    /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n+    /// we need the alias element to have an array of items.\n+    pub aliases: BTreeMap<String, Vec<usize>>,\n+}\n+\n+impl Cache {\n+    pub fn from_krate(\n+        render_info: RenderInfo,\n+        document_private: bool,\n+        extern_html_root_urls: &BTreeMap<String, String>,\n+        dst: &Path,\n+        mut krate: clean::Crate,\n+    ) -> (clean::Crate, Cache) {\n+        // Crawl the crate to build various caches used for the output\n+        let RenderInfo {\n+            inlined: _,\n+            external_paths,\n+            exact_paths,\n+            access_levels,\n+            deref_trait_did,\n+            deref_mut_trait_did,\n+            owned_box_did,\n+            ..\n+        } = render_info;\n+\n+        let external_paths =\n+            external_paths.into_iter().map(|(k, (v, t))| (k, (v, ItemType::from(t)))).collect();\n+\n+        let mut cache = Cache {\n+            external_paths,\n+            exact_paths,\n+            parent_is_trait_impl: false,\n+            stripped_mod: false,\n+            access_levels,\n+            crate_version: krate.version.take(),\n+            document_private,\n+            traits: krate.external_traits.replace(Default::default()),\n+            deref_trait_did,\n+            deref_mut_trait_did,\n+            owned_box_did,\n+            masked_crates: mem::take(&mut krate.masked_crates),\n+            ..Cache::default()\n+        };\n+\n+        // Cache where all our extern crates are located\n+        // FIXME: this part is specific to HTML so it'd be nice to remove it from the common code\n+        for &(n, ref e) in &krate.externs {\n+            let src_root = match e.src {\n+                FileName::Real(ref p) => match p.local_path().parent() {\n+                    Some(p) => p.to_path_buf(),\n+                    None => PathBuf::new(),\n+                },\n+                _ => PathBuf::new(),\n+            };\n+            let extern_url = extern_html_root_urls.get(&e.name).map(|u| &**u);\n+            cache\n+                .extern_locations\n+                .insert(n, (e.name.clone(), src_root, extern_location(e, extern_url, &dst)));\n+\n+            let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n+            cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n+        }\n+\n+        // Cache where all known primitives have their documentation located.\n+        //\n+        // Favor linking to as local extern as possible, so iterate all crates in\n+        // reverse topological order.\n+        for &(_, ref e) in krate.externs.iter().rev() {\n+            for &(def_id, prim, _) in &e.primitives {\n+                cache.primitive_locations.insert(prim, def_id);\n+            }\n+        }\n+        for &(def_id, prim, _) in &krate.primitives {\n+            cache.primitive_locations.insert(prim, def_id);\n+        }\n+\n+        cache.stack.push(krate.name.clone());\n+        krate = cache.fold_crate(krate);\n+\n+        for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n+            if cache.traits.contains_key(&trait_did) {\n+                for did in dids {\n+                    cache.impls.entry(did).or_default().push(impl_.clone());\n+                }\n+            }\n+        }\n+\n+        (krate, cache)\n+    }\n+}\n+\n+impl DocFolder for Cache {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        if item.def_id.is_local() {\n+            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n+        }\n+\n+        // If this is a stripped module,\n+        // we don't want it or its children in the search index.\n+        let orig_stripped_mod = match item.inner {\n+            clean::StrippedItem(box clean::ModuleItem(..)) => {\n+                mem::replace(&mut self.stripped_mod, true)\n+            }\n+            _ => self.stripped_mod,\n+        };\n+\n+        // If the impl is from a masked crate or references something from a\n+        // masked crate then remove it completely.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if self.masked_crates.contains(&item.def_id.krate)\n+                || i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n+                || i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n+            {\n+                return None;\n+            }\n+        }\n+\n+        // Propagate a trait method's documentation to all implementors of the\n+        // trait.\n+        if let clean::TraitItem(ref t) = item.inner {\n+            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n+        }\n+\n+        // Collect all the implementors of traits.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if let Some(did) = i.trait_.def_id() {\n+                if i.blanket_impl.is_none() {\n+                    self.implementors\n+                        .entry(did)\n+                        .or_default()\n+                        .push(Impl { impl_item: item.clone() });\n+                }\n+            }\n+        }\n+\n+        // Index this method for searching later on.\n+        if let Some(ref s) = item.name {\n+            let (parent, is_inherent_impl_item) = match item.inner {\n+                clean::StrippedItem(..) => ((None, None), false),\n+                clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n+                    if self.parent_is_trait_impl =>\n+                {\n+                    // skip associated items in trait impls\n+                    ((None, None), false)\n+                }\n+                clean::AssocTypeItem(..)\n+                | clean::TyMethodItem(..)\n+                | clean::StructFieldItem(..)\n+                | clean::VariantItem(..) => (\n+                    (\n+                        Some(*self.parent_stack.last().expect(\"parent_stack is empty\")),\n+                        Some(&self.stack[..self.stack.len() - 1]),\n+                    ),\n+                    false,\n+                ),\n+                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n+                    if self.parent_stack.is_empty() {\n+                        ((None, None), false)\n+                    } else {\n+                        let last = self.parent_stack.last().expect(\"parent_stack is empty 2\");\n+                        let did = *last;\n+                        let path = match self.paths.get(&did) {\n+                            // The current stack not necessarily has correlation\n+                            // for where the type was defined. On the other\n+                            // hand, `paths` always has the right\n+                            // information if present.\n+                            Some(&(\n+                                ref fqp,\n+                                ItemType::Trait\n+                                | ItemType::Struct\n+                                | ItemType::Union\n+                                | ItemType::Enum,\n+                            )) => Some(&fqp[..fqp.len() - 1]),\n+                            Some(..) => Some(&*self.stack),\n+                            None => None,\n+                        };\n+                        ((Some(*last), path), true)\n+                    }\n+                }\n+                _ => ((None, Some(&*self.stack)), false),\n+            };\n+\n+            match parent {\n+                (parent, Some(path)) if is_inherent_impl_item || !self.stripped_mod => {\n+                    debug_assert!(!item.is_stripped());\n+\n+                    // A crate has a module at its root, containing all items,\n+                    // which should not be indexed. The crate-item itself is\n+                    // inserted later on when serializing the search-index.\n+                    if item.def_id.index != CRATE_DEF_INDEX {\n+                        self.search_index.push(IndexItem {\n+                            ty: item.type_(),\n+                            name: s.to_string(),\n+                            path: path.join(\"::\"),\n+                            desc: shorten(plain_summary_line(item.doc_value())),\n+                            parent,\n+                            parent_idx: None,\n+                            search_type: get_index_search_type(&item),\n+                        });\n+\n+                        for alias in item.attrs.get_doc_aliases() {\n+                            self.aliases\n+                                .entry(alias.to_lowercase())\n+                                .or_insert(Vec::new())\n+                                .push(self.search_index.len() - 1);\n+                        }\n+                    }\n+                }\n+                (Some(parent), None) if is_inherent_impl_item => {\n+                    // We have a parent, but we don't know where they're\n+                    // defined yet. Wait for later to index this item.\n+                    self.orphan_impl_items.push((parent, item.clone()));\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        // Keep track of the fully qualified path for this item.\n+        let pushed = match item.name {\n+            Some(ref n) if !n.is_empty() => {\n+                self.stack.push(n.to_string());\n+                true\n+            }\n+            _ => false,\n+        };\n+\n+        match item.inner {\n+            clean::StructItem(..)\n+            | clean::EnumItem(..)\n+            | clean::TypedefItem(..)\n+            | clean::TraitItem(..)\n+            | clean::FunctionItem(..)\n+            | clean::ModuleItem(..)\n+            | clean::ForeignFunctionItem(..)\n+            | clean::ForeignStaticItem(..)\n+            | clean::ConstantItem(..)\n+            | clean::StaticItem(..)\n+            | clean::UnionItem(..)\n+            | clean::ForeignTypeItem\n+            | clean::MacroItem(..)\n+            | clean::ProcMacroItem(..)\n+            | clean::VariantItem(..)\n+                if !self.stripped_mod =>\n+            {\n+                // Re-exported items mean that the same id can show up twice\n+                // in the rustdoc ast that we're looking at. We know,\n+                // however, that a re-exported item doesn't show up in the\n+                // `public_items` map, so we can skip inserting into the\n+                // paths map if there was already an entry present and we're\n+                // not a public item.\n+                if !self.paths.contains_key(&item.def_id)\n+                    || self.access_levels.is_public(item.def_id)\n+                {\n+                    self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n+                }\n+            }\n+            clean::PrimitiveItem(..) => {\n+                self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n+            }\n+\n+            _ => {}\n+        }\n+\n+        // Maintain the parent stack\n+        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n+        let parent_pushed = match item.inner {\n+            clean::TraitItem(..)\n+            | clean::EnumItem(..)\n+            | clean::ForeignTypeItem\n+            | clean::StructItem(..)\n+            | clean::UnionItem(..)\n+            | clean::VariantItem(..) => {\n+                self.parent_stack.push(item.def_id);\n+                self.parent_is_trait_impl = false;\n+                true\n+            }\n+            clean::ImplItem(ref i) => {\n+                self.parent_is_trait_impl = i.trait_.is_some();\n+                match i.for_ {\n+                    clean::ResolvedPath { did, .. } => {\n+                        self.parent_stack.push(did);\n+                        true\n+                    }\n+                    ref t => {\n+                        let prim_did = t\n+                            .primitive_type()\n+                            .and_then(|t| self.primitive_locations.get(&t).cloned());\n+                        match prim_did {\n+                            Some(did) => {\n+                                self.parent_stack.push(did);\n+                                true\n+                            }\n+                            None => false,\n+                        }\n+                    }\n+                }\n+            }\n+            _ => false,\n+        };\n+\n+        // Once we've recursively found all the generics, hoard off all the\n+        // implementations elsewhere.\n+        let ret = self.fold_item_recur(item).and_then(|item| {\n+            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n+                // Figure out the id of this impl. This may map to a\n+                // primitive rather than always to a struct/enum.\n+                // Note: matching twice to restrict the lifetime of the `i` borrow.\n+                let mut dids = FxHashSet::default();\n+                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n+                    match i.for_ {\n+                        clean::ResolvedPath { did, .. }\n+                        | clean::BorrowedRef {\n+                            type_: box clean::ResolvedPath { did, .. }, ..\n+                        } => {\n+                            dids.insert(did);\n+                        }\n+                        ref t => {\n+                            let did = t\n+                                .primitive_type()\n+                                .and_then(|t| self.primitive_locations.get(&t).cloned());\n+\n+                            if let Some(did) = did {\n+                                dids.insert(did);\n+                            }\n+                        }\n+                    }\n+\n+                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n+                        for bound in generics {\n+                            if let Some(did) = bound.def_id() {\n+                                dids.insert(did);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    unreachable!()\n+                };\n+                let impl_item = Impl { impl_item: item };\n+                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n+                    for did in dids {\n+                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n+                    }\n+                } else {\n+                    let trait_did = impl_item.trait_did().expect(\"no trait did\");\n+                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n+                }\n+                None\n+            } else {\n+                Some(item)\n+            }\n+        });\n+\n+        if pushed {\n+            self.stack.pop().expect(\"stack already empty\");\n+        }\n+        if parent_pushed {\n+            self.parent_stack.pop().expect(\"parent stack already empty\");\n+        }\n+        self.stripped_mod = orig_stripped_mod;\n+        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n+        ret\n+    }\n+}\n+\n+crate fn cache() -> Arc<Cache> {\n+    CACHE_KEY.with(|c| c.borrow().clone())\n+}"}, {"sha": "696bdae94fc88b89170999b60258b2d196781c04", "filename": "src/librustdoc/formats/item_type.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -13,7 +13,7 @@ use crate::clean;\n /// The search index uses item types encoded as smaller numbers which equal to\n /// discriminants. JavaScript then is used to decode them into the original value.\n /// Consequently, every change to this type should be synchronized to\n-/// the `itemTypes` mapping table in `static/main.js`.\n+/// the `itemTypes` mapping table in `html/static/main.js`.\n ///\n /// In addition, code in `html::render` uses this enum to generate CSS classes, page prefixes, and\n /// module headings. If you are adding to this enum and want to ensure that the sidebar also prints", "previous_filename": "src/librustdoc/html/item_type.rs"}, {"sha": "dcb0184c58cd20c95918f6c215e7a4edda050787", "filename": "src/librustdoc/formats/mod.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -0,0 +1,44 @@\n+pub mod cache;\n+pub mod item_type;\n+pub mod renderer;\n+\n+pub use renderer::{run_format, FormatRenderer};\n+\n+use rustc_span::def_id::DefId;\n+\n+use crate::clean;\n+use crate::clean::types::GetDefId;\n+\n+/// Specifies whether rendering directly implemented trait items or ones from a certain Deref\n+/// impl.\n+pub enum AssocItemRender<'a> {\n+    All,\n+    DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type, deref_mut_: bool },\n+}\n+\n+/// For different handling of associated items from the Deref target of a type rather than the type\n+/// itself.\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum RenderMode {\n+    Normal,\n+    ForDeref { mut_: bool },\n+}\n+\n+/// Metadata about implementations for a type or trait.\n+#[derive(Clone, Debug)]\n+pub struct Impl {\n+    pub impl_item: clean::Item,\n+}\n+\n+impl Impl {\n+    pub fn inner_impl(&self) -> &clean::Impl {\n+        match self.impl_item.inner {\n+            clean::ImplItem(ref impl_) => impl_,\n+            _ => panic!(\"non-impl item found in impl\"),\n+        }\n+    }\n+\n+    pub fn trait_did(&self) -> Option<DefId> {\n+        self.inner_impl().trait_.def_id()\n+    }\n+}"}, {"sha": "90ace4d44c47dc93e1539dbf1da183df6f641d4b", "filename": "src/librustdoc/formats/renderer.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -0,0 +1,106 @@\n+use std::sync::Arc;\n+\n+use rustc_span::edition::Edition;\n+\n+use crate::clean;\n+use crate::config::{RenderInfo, RenderOptions};\n+use crate::error::Error;\n+use crate::formats::cache::{Cache, CACHE_KEY};\n+\n+/// Allows for different backends to rustdoc to be used with the `run_format()` function. Each\n+/// backend renderer has hooks for initialization, documenting an item, entering and exiting a\n+/// module, and cleanup/finalizing output.\n+pub trait FormatRenderer: Clone {\n+    /// Sets up any state required for the renderer. When this is called the cache has already been\n+    /// populated.\n+    fn init(\n+        krate: clean::Crate,\n+        options: RenderOptions,\n+        render_info: RenderInfo,\n+        edition: Edition,\n+        cache: &mut Cache,\n+    ) -> Result<(Self, clean::Crate), Error>;\n+\n+    /// Renders a single non-module item. This means no recursive sub-item rendering is required.\n+    fn item(&mut self, item: clean::Item, cache: &Cache) -> Result<(), Error>;\n+\n+    /// Renders a module (should not handle recursing into children).\n+    fn mod_item_in(\n+        &mut self,\n+        item: &clean::Item,\n+        item_name: &str,\n+        cache: &Cache,\n+    ) -> Result<(), Error>;\n+\n+    /// Runs after recursively rendering all sub-items of a module.\n+    fn mod_item_out(&mut self, item_name: &str) -> Result<(), Error>;\n+\n+    /// Post processing hook for cleanup and dumping output to files.\n+    fn after_krate(&mut self, krate: &clean::Crate, cache: &Cache) -> Result<(), Error>;\n+\n+    /// Called after everything else to write out errors.\n+    fn after_run(&mut self, diag: &rustc_errors::Handler) -> Result<(), Error>;\n+}\n+\n+/// Main method for rendering a crate.\n+pub fn run_format<T: FormatRenderer>(\n+    krate: clean::Crate,\n+    options: RenderOptions,\n+    render_info: RenderInfo,\n+    diag: &rustc_errors::Handler,\n+    edition: Edition,\n+) -> Result<(), Error> {\n+    let (krate, mut cache) = Cache::from_krate(\n+        render_info.clone(),\n+        options.document_private,\n+        &options.extern_html_root_urls,\n+        &options.output,\n+        krate,\n+    );\n+\n+    let (mut format_renderer, mut krate) =\n+        T::init(krate, options, render_info, edition, &mut cache)?;\n+\n+    let cache = Arc::new(cache);\n+    // Freeze the cache now that the index has been built. Put an Arc into TLS for future\n+    // parallelization opportunities\n+    CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n+\n+    let mut item = match krate.module.take() {\n+        Some(i) => i,\n+        None => return Ok(()),\n+    };\n+\n+    item.name = Some(krate.name.clone());\n+\n+    // Render the crate documentation\n+    let mut work = vec![(format_renderer.clone(), item)];\n+\n+    while let Some((mut cx, item)) = work.pop() {\n+        if item.is_mod() {\n+            // modules are special because they add a namespace. We also need to\n+            // recurse into the items of the module as well.\n+            let name = item.name.as_ref().unwrap().to_string();\n+            if name.is_empty() {\n+                panic!(\"Unexpected module with empty name\");\n+            }\n+\n+            cx.mod_item_in(&item, &name, &cache)?;\n+            let module = match item.inner {\n+                clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n+                _ => unreachable!(),\n+            };\n+            for it in module.items {\n+                debug!(\"Adding {:?} to worklist\", it.name);\n+                work.push((cx.clone(), it));\n+            }\n+\n+            cx.mod_item_out(&name)?;\n+        } else if item.name.is_some() {\n+            cx.item(item, &cache)?;\n+        }\n+    }\n+\n+    format_renderer.after_krate(&krate, &cache)?;\n+    format_renderer.after_run(diag)\n+}"}, {"sha": "699f8c36cba6a43cbdd9a2a198fdf899275713dd", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -11,13 +11,15 @@ use std::fmt;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_span::def_id::DefId;\n use rustc_target::spec::abi::Abi;\n \n use crate::clean::{self, PrimitiveType};\n+use crate::formats::cache::cache;\n+use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n-use crate::html::item_type::ItemType;\n-use crate::html::render::{self, cache, CURRENT_DEPTH};\n+use crate::html::render::cache::ExternalLocation;\n+use crate::html::render::CURRENT_DEPTH;\n \n pub trait Print {\n     fn print(self, buffer: &mut Buffer);\n@@ -493,9 +495,9 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n                 fqp,\n                 shortty,\n                 match cache.extern_locations[&did.krate] {\n-                    (.., render::Remote(ref s)) => s.to_string(),\n-                    (.., render::Local) => \"../\".repeat(depth),\n-                    (.., render::Unknown) => return None,\n+                    (.., ExternalLocation::Remote(ref s)) => s.to_string(),\n+                    (.., ExternalLocation::Local) => \"../\".repeat(depth),\n+                    (.., ExternalLocation::Unknown) => return None,\n                 },\n             )\n         }\n@@ -574,12 +576,12 @@ fn primitive_link(\n             }\n             Some(&def_id) => {\n                 let loc = match m.extern_locations[&def_id.krate] {\n-                    (ref cname, _, render::Remote(ref s)) => Some((cname, s.to_string())),\n-                    (ref cname, _, render::Local) => {\n+                    (ref cname, _, ExternalLocation::Remote(ref s)) => Some((cname, s.to_string())),\n+                    (ref cname, _, ExternalLocation::Local) => {\n                         let len = CURRENT_DEPTH.with(|s| s.get());\n                         Some((cname, \"../\".repeat(len)))\n                     }\n-                    (.., render::Unknown) => None,\n+                    (.., ExternalLocation::Unknown) => None,\n                 };\n                 if let Some((cname, root)) = loc {\n                     write!("}, {"sha": "367538d440ea113c839e3de90f6c195c616b56a0", "filename": "src/librustdoc/html/mod.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmod.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -0,0 +1,9 @@\n+crate mod escape;\n+crate mod format;\n+crate mod highlight;\n+crate mod layout;\n+pub mod markdown;\n+pub mod render;\n+crate mod sources;\n+crate mod static_files;\n+crate mod toc;"}, {"sha": "378efa1a1bed7c0aaad67a5a2aab26a8af8ed225", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 12, "deletions": 488, "changes": 500, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -1,18 +1,16 @@\n-use crate::clean::{self, AttributesExt, GetDefId};\n-use crate::fold::DocFolder;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n-use rustc_middle::middle::privacy::AccessLevels;\n-use rustc_span::source_map::FileName;\n-use rustc_span::symbol::sym;\n use std::collections::BTreeMap;\n-use std::mem;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n \n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::symbol::sym;\n use serde::Serialize;\n \n-use super::{plain_summary_line, shorten, Impl, IndexItem, IndexItemFunctionType, ItemType};\n-use super::{Generic, RenderInfo, RenderType, TypeWithKind};\n+use crate::clean::types::GetDefId;\n+use crate::clean::{self, AttributesExt};\n+use crate::formats::cache::Cache;\n+use crate::formats::item_type::ItemType;\n+use crate::html::render::{plain_summary_line, shorten};\n+use crate::html::render::{Generic, IndexItem, IndexItemFunctionType, RenderType, TypeWithKind};\n \n /// Indicates where an external crate can be found.\n pub enum ExternalLocation {\n@@ -24,483 +22,9 @@ pub enum ExternalLocation {\n     Unknown,\n }\n \n-/// This cache is used to store information about the `clean::Crate` being\n-/// rendered in order to provide more useful documentation. This contains\n-/// information like all implementors of a trait, all traits a type implements,\n-/// documentation for all known traits, etc.\n-///\n-/// This structure purposefully does not implement `Clone` because it's intended\n-/// to be a fairly large and expensive structure to clone. Instead this adheres\n-/// to `Send` so it may be stored in a `Arc` instance and shared among the various\n-/// rendering threads.\n-#[derive(Default)]\n-crate struct Cache {\n-    /// Maps a type ID to all known implementations for that type. This is only\n-    /// recognized for intra-crate `ResolvedPath` types, and is used to print\n-    /// out extra documentation on the page of an enum/struct.\n-    ///\n-    /// The values of the map are a list of implementations and documentation\n-    /// found on that implementation.\n-    pub impls: FxHashMap<DefId, Vec<Impl>>,\n-\n-    /// Maintains a mapping of local crate `DefId`s to the fully qualified name\n-    /// and \"short type description\" of that node. This is used when generating\n-    /// URLs when a type is being linked to. External paths are not located in\n-    /// this map because the `External` type itself has all the information\n-    /// necessary.\n-    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n-\n-    /// Similar to `paths`, but only holds external paths. This is only used for\n-    /// generating explicit hyperlinks to other crates.\n-    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n-\n-    /// Maps local `DefId`s of exported types to fully qualified paths.\n-    /// Unlike 'paths', this mapping ignores any renames that occur\n-    /// due to 'use' statements.\n-    ///\n-    /// This map is used when writing out the special 'implementors'\n-    /// javascript file. By using the exact path that the type\n-    /// is declared with, we ensure that each path will be identical\n-    /// to the path used if the corresponding type is inlined. By\n-    /// doing this, we can detect duplicate impls on a trait page, and only display\n-    /// the impl for the inlined type.\n-    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n-\n-    /// This map contains information about all known traits of this crate.\n-    /// Implementations of a crate should inherit the documentation of the\n-    /// parent trait if no extra documentation is specified, and default methods\n-    /// should show up in documentation about trait implementations.\n-    pub traits: FxHashMap<DefId, clean::Trait>,\n-\n-    /// When rendering traits, it's often useful to be able to list all\n-    /// implementors of the trait, and this mapping is exactly, that: a mapping\n-    /// of trait ids to the list of known implementors of the trait\n-    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n-\n-    /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n-\n-    /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n-\n-    // Note that external items for which `doc(hidden)` applies to are shown as\n-    // non-reachable while local items aren't. This is because we're reusing\n-    // the access levels from the privacy check pass.\n-    pub access_levels: AccessLevels<DefId>,\n-\n-    /// The version of the crate being documented, if given from the `--crate-version` flag.\n-    pub crate_version: Option<String>,\n-\n-    /// Whether to document private items.\n-    /// This is stored in `Cache` so it doesn't need to be passed through all rustdoc functions.\n-    pub document_private: bool,\n-\n-    // Private fields only used when initially crawling a crate to build a cache\n-    stack: Vec<String>,\n-    parent_stack: Vec<DefId>,\n-    parent_is_trait_impl: bool,\n-    search_index: Vec<IndexItem>,\n-    stripped_mod: bool,\n-    pub deref_trait_did: Option<DefId>,\n-    pub deref_mut_trait_did: Option<DefId>,\n-    pub owned_box_did: Option<DefId>,\n-    masked_crates: FxHashSet<CrateNum>,\n-\n-    // In rare case where a structure is defined in one module but implemented\n-    // in another, if the implementing module is parsed before defining module,\n-    // then the fully qualified name of the structure isn't presented in `paths`\n-    // yet when its implementation methods are being indexed. Caches such methods\n-    // and their parent id here and indexes them at the end of crate parsing.\n-    orphan_impl_items: Vec<(DefId, clean::Item)>,\n-\n-    // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n-    // even though the trait itself is not exported. This can happen if a trait\n-    // was defined in function/expression scope, since the impl will be picked\n-    // up by `collect-trait-impls` but the trait won't be scraped out in the HIR\n-    // crawl. In order to prevent crashes when looking for spotlight traits or\n-    // when gathering trait documentation on a type, hold impls here while\n-    // folding and add them to the cache later on if we find the trait.\n-    orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n-\n-    /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n-    /// we need the alias element to have an array of items.\n-    pub(super) aliases: BTreeMap<String, Vec<usize>>,\n-}\n-\n-impl Cache {\n-    pub fn from_krate(\n-        renderinfo: RenderInfo,\n-        document_private: bool,\n-        extern_html_root_urls: &BTreeMap<String, String>,\n-        dst: &Path,\n-        mut krate: clean::Crate,\n-    ) -> (clean::Crate, String, Cache) {\n-        // Crawl the crate to build various caches used for the output\n-        let RenderInfo {\n-            inlined: _,\n-            external_paths,\n-            exact_paths,\n-            access_levels,\n-            deref_trait_did,\n-            deref_mut_trait_did,\n-            owned_box_did,\n-            ..\n-        } = renderinfo;\n-\n-        let external_paths =\n-            external_paths.into_iter().map(|(k, (v, t))| (k, (v, ItemType::from(t)))).collect();\n-\n-        let mut cache = Cache {\n-            impls: Default::default(),\n-            external_paths,\n-            exact_paths,\n-            paths: Default::default(),\n-            implementors: Default::default(),\n-            stack: Vec::new(),\n-            parent_stack: Vec::new(),\n-            search_index: Vec::new(),\n-            parent_is_trait_impl: false,\n-            extern_locations: Default::default(),\n-            primitive_locations: Default::default(),\n-            stripped_mod: false,\n-            access_levels,\n-            crate_version: krate.version.take(),\n-            document_private,\n-            orphan_impl_items: Vec::new(),\n-            orphan_trait_impls: Vec::new(),\n-            traits: krate.external_traits.replace(Default::default()),\n-            deref_trait_did,\n-            deref_mut_trait_did,\n-            owned_box_did,\n-            masked_crates: mem::take(&mut krate.masked_crates),\n-            aliases: Default::default(),\n-        };\n-\n-        // Cache where all our extern crates are located\n-        for &(n, ref e) in &krate.externs {\n-            let src_root = match e.src {\n-                FileName::Real(ref p) => match p.local_path().parent() {\n-                    Some(p) => p.to_path_buf(),\n-                    None => PathBuf::new(),\n-                },\n-                _ => PathBuf::new(),\n-            };\n-            let extern_url = extern_html_root_urls.get(&e.name).map(|u| &**u);\n-            cache\n-                .extern_locations\n-                .insert(n, (e.name.clone(), src_root, extern_location(e, extern_url, &dst)));\n-\n-            let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n-            cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n-        }\n-\n-        // Cache where all known primitives have their documentation located.\n-        //\n-        // Favor linking to as local extern as possible, so iterate all crates in\n-        // reverse topological order.\n-        for &(_, ref e) in krate.externs.iter().rev() {\n-            for &(def_id, prim, _) in &e.primitives {\n-                cache.primitive_locations.insert(prim, def_id);\n-            }\n-        }\n-        for &(def_id, prim, _) in &krate.primitives {\n-            cache.primitive_locations.insert(prim, def_id);\n-        }\n-\n-        cache.stack.push(krate.name.clone());\n-        krate = cache.fold_crate(krate);\n-\n-        for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n-            if cache.traits.contains_key(&trait_did) {\n-                for did in dids {\n-                    cache.impls.entry(did).or_insert(vec![]).push(impl_.clone());\n-                }\n-            }\n-        }\n-\n-        // Build our search index\n-        let index = build_index(&krate, &mut cache);\n-\n-        (krate, index, cache)\n-    }\n-}\n-\n-impl DocFolder for Cache {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        if item.def_id.is_local() {\n-            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n-        }\n-\n-        // If this is a stripped module,\n-        // we don't want it or its children in the search index.\n-        let orig_stripped_mod = match item.inner {\n-            clean::StrippedItem(box clean::ModuleItem(..)) => {\n-                mem::replace(&mut self.stripped_mod, true)\n-            }\n-            _ => self.stripped_mod,\n-        };\n-\n-        // If the impl is from a masked crate or references something from a\n-        // masked crate then remove it completely.\n-        if let clean::ImplItem(ref i) = item.inner {\n-            if self.masked_crates.contains(&item.def_id.krate)\n-                || i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n-                || i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n-            {\n-                return None;\n-            }\n-        }\n-\n-        // Propagate a trait method's documentation to all implementors of the\n-        // trait.\n-        if let clean::TraitItem(ref t) = item.inner {\n-            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n-        }\n-\n-        // Collect all the implementors of traits.\n-        if let clean::ImplItem(ref i) = item.inner {\n-            if let Some(did) = i.trait_.def_id() {\n-                if i.blanket_impl.is_none() {\n-                    self.implementors\n-                        .entry(did)\n-                        .or_default()\n-                        .push(Impl { impl_item: item.clone() });\n-                }\n-            }\n-        }\n-\n-        // Index this method for searching later on.\n-        if let Some(ref s) = item.name {\n-            let (parent, is_inherent_impl_item) = match item.inner {\n-                clean::StrippedItem(..) => ((None, None), false),\n-                clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n-                    if self.parent_is_trait_impl =>\n-                {\n-                    // skip associated items in trait impls\n-                    ((None, None), false)\n-                }\n-                clean::AssocTypeItem(..)\n-                | clean::TyMethodItem(..)\n-                | clean::StructFieldItem(..)\n-                | clean::VariantItem(..) => (\n-                    (\n-                        Some(*self.parent_stack.last().expect(\"parent_stack is empty\")),\n-                        Some(&self.stack[..self.stack.len() - 1]),\n-                    ),\n-                    false,\n-                ),\n-                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n-                    if self.parent_stack.is_empty() {\n-                        ((None, None), false)\n-                    } else {\n-                        let last = self.parent_stack.last().expect(\"parent_stack is empty 2\");\n-                        let did = *last;\n-                        let path = match self.paths.get(&did) {\n-                            // The current stack not necessarily has correlation\n-                            // for where the type was defined. On the other\n-                            // hand, `paths` always has the right\n-                            // information if present.\n-                            Some(&(\n-                                ref fqp,\n-                                ItemType::Trait\n-                                | ItemType::Struct\n-                                | ItemType::Union\n-                                | ItemType::Enum,\n-                            )) => Some(&fqp[..fqp.len() - 1]),\n-                            Some(..) => Some(&*self.stack),\n-                            None => None,\n-                        };\n-                        ((Some(*last), path), true)\n-                    }\n-                }\n-                _ => ((None, Some(&*self.stack)), false),\n-            };\n-\n-            match parent {\n-                (parent, Some(path)) if is_inherent_impl_item || !self.stripped_mod => {\n-                    debug_assert!(!item.is_stripped());\n-\n-                    // A crate has a module at its root, containing all items,\n-                    // which should not be indexed. The crate-item itself is\n-                    // inserted later on when serializing the search-index.\n-                    if item.def_id.index != CRATE_DEF_INDEX {\n-                        self.search_index.push(IndexItem {\n-                            ty: item.type_(),\n-                            name: s.to_string(),\n-                            path: path.join(\"::\"),\n-                            desc: shorten(plain_summary_line(item.doc_value())),\n-                            parent,\n-                            parent_idx: None,\n-                            search_type: get_index_search_type(&item),\n-                        });\n-\n-                        for alias in item.attrs.get_doc_aliases() {\n-                            self.aliases\n-                                .entry(alias.to_lowercase())\n-                                .or_insert(Vec::new())\n-                                .push(self.search_index.len() - 1);\n-                        }\n-                    }\n-                }\n-                (Some(parent), None) if is_inherent_impl_item => {\n-                    // We have a parent, but we don't know where they're\n-                    // defined yet. Wait for later to index this item.\n-                    self.orphan_impl_items.push((parent, item.clone()));\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        // Keep track of the fully qualified path for this item.\n-        let pushed = match item.name {\n-            Some(ref n) if !n.is_empty() => {\n-                self.stack.push(n.to_string());\n-                true\n-            }\n-            _ => false,\n-        };\n-\n-        match item.inner {\n-            clean::StructItem(..)\n-            | clean::EnumItem(..)\n-            | clean::TypedefItem(..)\n-            | clean::TraitItem(..)\n-            | clean::FunctionItem(..)\n-            | clean::ModuleItem(..)\n-            | clean::ForeignFunctionItem(..)\n-            | clean::ForeignStaticItem(..)\n-            | clean::ConstantItem(..)\n-            | clean::StaticItem(..)\n-            | clean::UnionItem(..)\n-            | clean::ForeignTypeItem\n-            | clean::MacroItem(..)\n-            | clean::ProcMacroItem(..)\n-            | clean::VariantItem(..)\n-                if !self.stripped_mod =>\n-            {\n-                // Re-exported items mean that the same id can show up twice\n-                // in the rustdoc ast that we're looking at. We know,\n-                // however, that a re-exported item doesn't show up in the\n-                // `public_items` map, so we can skip inserting into the\n-                // paths map if there was already an entry present and we're\n-                // not a public item.\n-                if !self.paths.contains_key(&item.def_id)\n-                    || self.access_levels.is_public(item.def_id)\n-                {\n-                    self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n-                }\n-            }\n-            clean::PrimitiveItem(..) => {\n-                self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n-            }\n-\n-            _ => {}\n-        }\n-\n-        // Maintain the parent stack\n-        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n-        let parent_pushed = match item.inner {\n-            clean::TraitItem(..)\n-            | clean::EnumItem(..)\n-            | clean::ForeignTypeItem\n-            | clean::StructItem(..)\n-            | clean::UnionItem(..)\n-            | clean::VariantItem(..) => {\n-                self.parent_stack.push(item.def_id);\n-                self.parent_is_trait_impl = false;\n-                true\n-            }\n-            clean::ImplItem(ref i) => {\n-                self.parent_is_trait_impl = i.trait_.is_some();\n-                match i.for_ {\n-                    clean::ResolvedPath { did, .. } => {\n-                        self.parent_stack.push(did);\n-                        true\n-                    }\n-                    ref t => {\n-                        let prim_did = t\n-                            .primitive_type()\n-                            .and_then(|t| self.primitive_locations.get(&t).cloned());\n-                        match prim_did {\n-                            Some(did) => {\n-                                self.parent_stack.push(did);\n-                                true\n-                            }\n-                            None => false,\n-                        }\n-                    }\n-                }\n-            }\n-            _ => false,\n-        };\n-\n-        // Once we've recursively found all the generics, hoard off all the\n-        // implementations elsewhere.\n-        let ret = self.fold_item_recur(item).and_then(|item| {\n-            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n-                // Figure out the id of this impl. This may map to a\n-                // primitive rather than always to a struct/enum.\n-                // Note: matching twice to restrict the lifetime of the `i` borrow.\n-                let mut dids = FxHashSet::default();\n-                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n-                    match i.for_ {\n-                        clean::ResolvedPath { did, .. }\n-                        | clean::BorrowedRef {\n-                            type_: box clean::ResolvedPath { did, .. }, ..\n-                        } => {\n-                            dids.insert(did);\n-                        }\n-                        ref t => {\n-                            let did = t\n-                                .primitive_type()\n-                                .and_then(|t| self.primitive_locations.get(&t).cloned());\n-\n-                            if let Some(did) = did {\n-                                dids.insert(did);\n-                            }\n-                        }\n-                    }\n-\n-                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n-                        for bound in generics {\n-                            if let Some(did) = bound.def_id() {\n-                                dids.insert(did);\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    unreachable!()\n-                };\n-                let impl_item = Impl { impl_item: item };\n-                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n-                    for did in dids {\n-                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n-                    }\n-                } else {\n-                    let trait_did = impl_item.trait_did().expect(\"no trait did\");\n-                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n-                }\n-                None\n-            } else {\n-                Some(item)\n-            }\n-        });\n-\n-        if pushed {\n-            self.stack.pop().expect(\"stack already empty\");\n-        }\n-        if parent_pushed {\n-            self.parent_stack.pop().expect(\"parent stack already empty\");\n-        }\n-        self.stripped_mod = orig_stripped_mod;\n-        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n-        ret\n-    }\n-}\n-\n /// Attempts to find where an external crate is located, given that we're\n /// rendering in to the specified source destination.\n-fn extern_location(\n+pub fn extern_location(\n     e: &clean::ExternalCrate,\n     extern_url: Option<&str>,\n     dst: &Path,\n@@ -538,7 +62,7 @@ fn extern_location(\n }\n \n /// Builds the search index from the collected metadata\n-fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n+pub fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut defid_to_pathid = FxHashMap::default();\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = vec![];\n@@ -640,7 +164,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     )\n }\n \n-fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n+crate fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n     let (all_types, ret_types) = match item.inner {\n         clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n         clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),"}, {"sha": "5fb2d9f6f917c929746c3f1c1a1bea65b866db82", "filename": "src/librustdoc/html/render/mod.rs", "status": "renamed", "additions": 418, "deletions": 505, "changes": 923, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -25,21 +25,26 @@\n //! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n+pub mod cache;\n+\n+#[cfg(test)]\n+mod tests;\n+\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n use std::collections::{BTreeMap, VecDeque};\n use std::default::Default;\n-use std::error;\n use std::ffi::OsStr;\n-use std::fmt::{self, Formatter, Write};\n+use std::fmt::{self, Write};\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Component, Path, PathBuf};\n use std::rc::Rc;\n use std::str;\n use std::string::ToString;\n+use std::sync::mpsc::{channel, Receiver};\n use std::sync::Arc;\n \n use itertools::Itertools;\n@@ -50,7 +55,6 @@ use rustc_feature::UnstableFeatures;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::Mutability;\n-use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::middle::stability;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n@@ -60,26 +64,23 @@ use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n \n use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, TypeKind};\n-use crate::config::{OutputFormat, RenderOptions};\n-use crate::docfs::{DocFS, ErrorStorage, PathError};\n+use crate::config::RenderInfo;\n+use crate::config::RenderOptions;\n+use crate::docfs::{DocFS, PathError};\n use crate::doctree;\n+use crate::error::Error;\n+use crate::formats::cache::{cache, Cache};\n+use crate::formats::item_type::ItemType;\n+use crate::formats::{AssocItemRender, FormatRenderer, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::fmt_impl_for_trait_page;\n use crate::html::format::Function;\n use crate::html::format::{href, print_default_space, print_generic_bounds, WhereClause};\n use crate::html::format::{print_abi_with_space, Buffer, PrintWithSpace};\n-use crate::html::item_type::ItemType;\n use crate::html::markdown::{self, ErrorCodes, IdMap, Markdown, MarkdownHtml, MarkdownSummaryLine};\n use crate::html::sources;\n use crate::html::{highlight, layout, static_files};\n-\n-#[cfg(test)]\n-mod tests;\n-\n-mod cache;\n-\n-use cache::Cache;\n-crate use cache::ExternalLocation::{self, *};\n+use cache::{build_index, ExternalLocation};\n \n /// A pair of name and its optional document.\n pub type NameDoc = (String, Option<String>);\n@@ -90,55 +91,6 @@ crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n     })\n }\n \n-#[derive(Debug)]\n-pub struct Error {\n-    pub file: PathBuf,\n-    pub error: String,\n-}\n-\n-impl error::Error for Error {}\n-\n-impl std::fmt::Display for Error {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n-        let file = self.file.display().to_string();\n-        if file.is_empty() {\n-            write!(f, \"{}\", self.error)\n-        } else {\n-            write!(f, \"\\\"{}\\\": {}\", self.file.display(), self.error)\n-        }\n-    }\n-}\n-\n-impl PathError for Error {\n-    fn new<S, P: AsRef<Path>>(e: S, path: P) -> Error\n-    where\n-        S: ToString + Sized,\n-    {\n-        Error { file: path.as_ref().to_path_buf(), error: e.to_string() }\n-    }\n-}\n-\n-macro_rules! try_none {\n-    ($e:expr, $file:expr) => {{\n-        use std::io;\n-        match $e {\n-            Some(e) => e,\n-            None => {\n-                return Err(Error::new(io::Error::new(io::ErrorKind::Other, \"not found\"), $file));\n-            }\n-        }\n-    }};\n-}\n-\n-macro_rules! try_err {\n-    ($e:expr, $file:expr) => {{\n-        match $e {\n-            Ok(e) => e,\n-            Err(e) => return Err(Error::new(e, $file)),\n-        }\n-    }};\n-}\n-\n /// Major driving force in all rustdoc rendering. This contains information\n /// about where in the tree-like hierarchy rendering is occurring and controls\n /// how the current page is being rendered.\n@@ -147,7 +99,7 @@ macro_rules! try_err {\n /// easily cloned because it is cloned per work-job (about once per item in the\n /// rustdoc tree).\n #[derive(Clone)]\n-struct Context {\n+crate struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n     pub current: Vec<String>,\n@@ -161,7 +113,10 @@ struct Context {\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n-    pub cache: Arc<Cache>,\n+    all: Rc<RefCell<AllTypes>>,\n+    /// Storage for the errors produced while generating documentation so they\n+    /// can be printed together at the end.\n+    pub errors: Rc<Receiver<String>>,\n }\n \n crate struct SharedContext {\n@@ -241,53 +196,20 @@ impl SharedContext {\n     }\n }\n \n-/// Metadata about implementations for a type or trait.\n-#[derive(Clone, Debug)]\n-pub struct Impl {\n-    pub impl_item: clean::Item,\n-}\n-\n-impl Impl {\n-    fn inner_impl(&self) -> &clean::Impl {\n-        match self.impl_item.inner {\n-            clean::ImplItem(ref impl_) => impl_,\n-            _ => panic!(\"non-impl item found in impl\"),\n-        }\n-    }\n-\n-    fn trait_did(&self) -> Option<DefId> {\n-        self.inner_impl().trait_.def_id()\n-    }\n-}\n-\n-/// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n-/// Later on moved into `CACHE_KEY`.\n-#[derive(Default)]\n-pub struct RenderInfo {\n-    pub inlined: FxHashSet<DefId>,\n-    pub external_paths: crate::core::ExternalPaths,\n-    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n-    pub access_levels: AccessLevels<DefId>,\n-    pub deref_trait_did: Option<DefId>,\n-    pub deref_mut_trait_did: Option<DefId>,\n-    pub owned_box_did: Option<DefId>,\n-    pub output_format: Option<OutputFormat>,\n-}\n-\n // Helper structs for rendering items/sidebars and carrying along contextual\n // information\n \n /// Struct representing one entry in the JS search index. These are all emitted\n /// by hand to a large JS file at the end of cache-creation.\n #[derive(Debug)]\n-struct IndexItem {\n-    ty: ItemType,\n-    name: String,\n-    path: String,\n-    desc: String,\n-    parent: Option<DefId>,\n-    parent_idx: Option<usize>,\n-    search_type: Option<IndexItemFunctionType>,\n+pub struct IndexItem {\n+    pub ty: ItemType,\n+    pub name: String,\n+    pub path: String,\n+    pub desc: String,\n+    pub parent: Option<DefId>,\n+    pub parent_idx: Option<usize>,\n+    pub search_type: Option<IndexItemFunctionType>,\n }\n \n impl Serialize for IndexItem {\n@@ -309,7 +231,7 @@ impl Serialize for IndexItem {\n \n /// A type used for the search index.\n #[derive(Debug)]\n-struct RenderType {\n+crate struct RenderType {\n     ty: Option<DefId>,\n     idx: Option<usize>,\n     name: Option<String>,\n@@ -340,7 +262,7 @@ impl Serialize for RenderType {\n \n /// A type used for the search index.\n #[derive(Debug)]\n-struct Generic {\n+crate struct Generic {\n     name: String,\n     defid: Option<DefId>,\n     idx: Option<usize>,\n@@ -361,7 +283,7 @@ impl Serialize for Generic {\n \n /// Full type of functions/methods in the search index.\n #[derive(Debug)]\n-struct IndexItemFunctionType {\n+pub struct IndexItemFunctionType {\n     inputs: Vec<TypeWithKind>,\n     output: Option<Vec<TypeWithKind>>,\n }\n@@ -394,7 +316,7 @@ impl Serialize for IndexItemFunctionType {\n }\n \n #[derive(Debug)]\n-pub struct TypeWithKind {\n+crate struct TypeWithKind {\n     ty: RenderType,\n     kind: TypeKind,\n }\n@@ -426,7 +348,6 @@ pub struct StylePath {\n     pub disabled: bool,\n }\n \n-thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n \n pub fn initial_ids() -> Vec<String> {\n@@ -454,147 +375,301 @@ pub fn initial_ids() -> Vec<String> {\n }\n \n /// Generates the documentation for `crate` into the directory `dst`\n-pub fn run(\n-    mut krate: clean::Crate,\n-    options: RenderOptions,\n-    renderinfo: RenderInfo,\n-    diag: &rustc_errors::Handler,\n-    edition: Edition,\n-) -> Result<(), Error> {\n-    // need to save a copy of the options for rendering the index page\n-    let md_opts = options.clone();\n-    let RenderOptions {\n-        output,\n-        external_html,\n-        id_map,\n-        playground_url,\n-        sort_modules_alphabetically,\n-        themes: style_files,\n-        extension_css,\n-        extern_html_root_urls,\n-        resource_suffix,\n-        static_root_path,\n-        generate_search_filter,\n-        document_private,\n-        ..\n-    } = options;\n-\n-    let src_root = match krate.src {\n-        FileName::Real(ref p) => match p.local_path().parent() {\n-            Some(p) => p.to_path_buf(),\n-            None => PathBuf::new(),\n-        },\n-        _ => PathBuf::new(),\n-    };\n-    let mut errors = Arc::new(ErrorStorage::new());\n-    // If user passed in `--playground-url` arg, we fill in crate name here\n-    let mut playground = None;\n-    if let Some(url) = playground_url {\n-        playground = Some(markdown::Playground { crate_name: Some(krate.name.clone()), url });\n-    }\n-    let mut layout = layout::Layout {\n-        logo: String::new(),\n-        favicon: String::new(),\n-        external_html,\n-        krate: krate.name.clone(),\n-        css_file_extension: extension_css,\n-        generate_search_filter,\n-    };\n-    let mut issue_tracker_base_url = None;\n-    let mut include_sources = true;\n-\n-    // Crawl the crate attributes looking for attributes which control how we're\n-    // going to emit HTML\n-    if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n-        for attr in attrs.lists(sym::doc) {\n-            match (attr.name_or_empty(), attr.value_str()) {\n-                (sym::html_favicon_url, Some(s)) => {\n-                    layout.favicon = s.to_string();\n-                }\n-                (sym::html_logo_url, Some(s)) => {\n-                    layout.logo = s.to_string();\n-                }\n-                (sym::html_playground_url, Some(s)) => {\n-                    playground = Some(markdown::Playground {\n-                        crate_name: Some(krate.name.clone()),\n-                        url: s.to_string(),\n-                    });\n-                }\n-                (sym::issue_tracker_base_url, Some(s)) => {\n-                    issue_tracker_base_url = Some(s.to_string());\n-                }\n-                (sym::html_no_source, None) if attr.is_word() => {\n-                    include_sources = false;\n+impl FormatRenderer for Context {\n+    fn init(\n+        mut krate: clean::Crate,\n+        options: RenderOptions,\n+        _render_info: RenderInfo,\n+        edition: Edition,\n+        cache: &mut Cache,\n+    ) -> Result<(Context, clean::Crate), Error> {\n+        // need to save a copy of the options for rendering the index page\n+        let md_opts = options.clone();\n+        let RenderOptions {\n+            output,\n+            external_html,\n+            id_map,\n+            playground_url,\n+            sort_modules_alphabetically,\n+            themes: style_files,\n+            extension_css,\n+            resource_suffix,\n+            static_root_path,\n+            generate_search_filter,\n+            ..\n+        } = options;\n+\n+        let src_root = match krate.src {\n+            FileName::Real(ref p) => match p.local_path().parent() {\n+                Some(p) => p.to_path_buf(),\n+                None => PathBuf::new(),\n+            },\n+            _ => PathBuf::new(),\n+        };\n+        // If user passed in `--playground-url` arg, we fill in crate name here\n+        let mut playground = None;\n+        if let Some(url) = playground_url {\n+            playground = Some(markdown::Playground { crate_name: Some(krate.name.clone()), url });\n+        }\n+        let mut layout = layout::Layout {\n+            logo: String::new(),\n+            favicon: String::new(),\n+            external_html,\n+            krate: krate.name.clone(),\n+            css_file_extension: extension_css,\n+            generate_search_filter,\n+        };\n+        let mut issue_tracker_base_url = None;\n+        let mut include_sources = true;\n+\n+        // Crawl the crate attributes looking for attributes which control how we're\n+        // going to emit HTML\n+        if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n+            for attr in attrs.lists(sym::doc) {\n+                match (attr.name_or_empty(), attr.value_str()) {\n+                    (sym::html_favicon_url, Some(s)) => {\n+                        layout.favicon = s.to_string();\n+                    }\n+                    (sym::html_logo_url, Some(s)) => {\n+                        layout.logo = s.to_string();\n+                    }\n+                    (sym::html_playground_url, Some(s)) => {\n+                        playground = Some(markdown::Playground {\n+                            crate_name: Some(krate.name.clone()),\n+                            url: s.to_string(),\n+                        });\n+                    }\n+                    (sym::issue_tracker_base_url, Some(s)) => {\n+                        issue_tracker_base_url = Some(s.to_string());\n+                    }\n+                    (sym::html_no_source, None) if attr.is_word() => {\n+                        include_sources = false;\n+                    }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n         }\n+        let (sender, receiver) = channel();\n+        let mut scx = SharedContext {\n+            collapsed: krate.collapsed,\n+            src_root,\n+            include_sources,\n+            local_sources: Default::default(),\n+            issue_tracker_base_url,\n+            layout,\n+            created_dirs: Default::default(),\n+            sort_modules_alphabetically,\n+            style_files,\n+            resource_suffix,\n+            static_root_path,\n+            fs: DocFS::new(sender),\n+            edition,\n+            codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n+            playground,\n+        };\n+\n+        // Add the default themes to the `Vec` of stylepaths\n+        //\n+        // Note that these must be added before `sources::render` is called\n+        // so that the resulting source pages are styled\n+        //\n+        // `light.css` is not disabled because it is the stylesheet that stays loaded\n+        // by the browser as the theme stylesheet. The theme system (hackily) works by\n+        // changing the href to this stylesheet. All other themes are disabled to\n+        // prevent rule conflicts\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"light.css\"), disabled: false });\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"dark.css\"), disabled: true });\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"ayu.css\"), disabled: true });\n+\n+        let dst = output;\n+        scx.ensure_dir(&dst)?;\n+        krate = sources::render(&dst, &mut scx, krate)?;\n+\n+        // Build our search index\n+        let index = build_index(&krate, cache);\n+\n+        let cache = Arc::new(cache);\n+        let mut cx = Context {\n+            current: Vec::new(),\n+            dst,\n+            render_redirect_pages: false,\n+            id_map: Rc::new(RefCell::new(id_map)),\n+            shared: Arc::new(scx),\n+            all: Rc::new(RefCell::new(AllTypes::new())),\n+            errors: Rc::new(receiver),\n+        };\n+\n+        CURRENT_DEPTH.with(|s| s.set(0));\n+\n+        // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n+        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n+        write_shared(&cx, &krate, index, &md_opts, &cache)?;\n+        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n+        Ok((cx, krate))\n     }\n-    let mut scx = SharedContext {\n-        collapsed: krate.collapsed,\n-        src_root,\n-        include_sources,\n-        local_sources: Default::default(),\n-        issue_tracker_base_url,\n-        layout,\n-        created_dirs: Default::default(),\n-        sort_modules_alphabetically,\n-        style_files,\n-        resource_suffix,\n-        static_root_path,\n-        fs: DocFS::new(&errors),\n-        edition,\n-        codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n-        playground,\n-    };\n \n-    // Add the default themes to the `Vec` of stylepaths\n-    //\n-    // Note that these must be added before `sources::render` is called\n-    // so that the resulting source pages are styled\n-    //\n-    // `light.css` is not disabled because it is the stylesheet that stays loaded\n-    // by the browser as the theme stylesheet. The theme system (hackily) works by\n-    // changing the href to this stylesheet. All other themes are disabled to\n-    // prevent rule conflicts\n-    scx.style_files.push(StylePath { path: PathBuf::from(\"light.css\"), disabled: false });\n-    scx.style_files.push(StylePath { path: PathBuf::from(\"dark.css\"), disabled: true });\n-    scx.style_files.push(StylePath { path: PathBuf::from(\"ayu.css\"), disabled: true });\n-\n-    let dst = output;\n-    scx.ensure_dir(&dst)?;\n-    krate = sources::render(&dst, &mut scx, krate)?;\n-    let (new_crate, index, cache) =\n-        Cache::from_krate(renderinfo, document_private, &extern_html_root_urls, &dst, krate);\n-    krate = new_crate;\n-    let cache = Arc::new(cache);\n-    let mut cx = Context {\n-        current: Vec::new(),\n-        dst,\n-        render_redirect_pages: false,\n-        id_map: Rc::new(RefCell::new(id_map)),\n-        shared: Arc::new(scx),\n-        cache: cache.clone(),\n-    };\n+    fn after_run(&mut self, diag: &rustc_errors::Handler) -> Result<(), Error> {\n+        Arc::get_mut(&mut self.shared).unwrap().fs.close();\n+        let nb_errors = self.errors.iter().map(|err| diag.struct_err(&err).emit()).count();\n+        if nb_errors > 0 {\n+            Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    fn after_krate(&mut self, krate: &clean::Crate, cache: &Cache) -> Result<(), Error> {\n+        let final_file = self.dst.join(&krate.name).join(\"all.html\");\n+        let settings_file = self.dst.join(\"settings.html\");\n+        let crate_name = krate.name.clone();\n \n-    // Freeze the cache now that the index has been built. Put an Arc into TLS\n-    // for future parallelization opportunities\n-    CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n-    CURRENT_DEPTH.with(|s| s.set(0));\n+        let mut root_path = self.dst.to_str().expect(\"invalid path\").to_owned();\n+        if !root_path.ends_with('/') {\n+            root_path.push('/');\n+        }\n+        let mut page = layout::Page {\n+            title: \"List of all items in this crate\",\n+            css_class: \"mod\",\n+            root_path: \"../\",\n+            static_root_path: self.shared.static_root_path.as_deref(),\n+            description: \"List of all items in this crate\",\n+            keywords: BASIC_KEYWORDS,\n+            resource_suffix: &self.shared.resource_suffix,\n+            extra_scripts: &[],\n+            static_extra_scripts: &[],\n+        };\n+        let sidebar = if let Some(ref version) = cache.crate_version {\n+            format!(\n+                \"<p class='location'>Crate {}</p>\\\n+                     <div class='block version'>\\\n+                         <p>Version {}</p>\\\n+                     </div>\\\n+                     <a id='all-types' href='index.html'><p>Back to index</p></a>\",\n+                crate_name,\n+                Escape(version),\n+            )\n+        } else {\n+            String::new()\n+        };\n+        let all = self.all.replace(AllTypes::new());\n+        let v = layout::render(\n+            &self.shared.layout,\n+            &page,\n+            sidebar,\n+            |buf: &mut Buffer| all.print(buf),\n+            &self.shared.style_files,\n+        );\n+        self.shared.fs.write(&final_file, v.as_bytes())?;\n \n-    // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n-    Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n-    write_shared(&cx, &krate, index, &md_opts)?;\n-    Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n+        // Generating settings page.\n+        page.title = \"Rustdoc settings\";\n+        page.description = \"Settings of Rustdoc\";\n+        page.root_path = \"./\";\n \n-    // And finally render the whole crate's documentation\n-    let ret = cx.krate(krate);\n-    let nb_errors = Arc::get_mut(&mut errors).map_or_else(|| 0, |errors| errors.write_errors(diag));\n-    if ret.is_err() {\n-        ret\n-    } else if nb_errors > 0 {\n-        Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n-    } else {\n+        let mut style_files = self.shared.style_files.clone();\n+        let sidebar = \"<p class='location'>Settings</p><div class='sidebar-elems'></div>\";\n+        style_files.push(StylePath { path: PathBuf::from(\"settings.css\"), disabled: false });\n+        let v = layout::render(\n+            &self.shared.layout,\n+            &page,\n+            sidebar,\n+            settings(\n+                self.shared.static_root_path.as_deref().unwrap_or(\"./\"),\n+                &self.shared.resource_suffix,\n+            ),\n+            &style_files,\n+        );\n+        self.shared.fs.write(&settings_file, v.as_bytes())?;\n+        Ok(())\n+    }\n+\n+    fn mod_item_in(\n+        &mut self,\n+        item: &clean::Item,\n+        item_name: &str,\n+        cache: &Cache,\n+    ) -> Result<(), Error> {\n+        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n+        // if they contain impls for public types. These modules can also\n+        // contain items such as publicly re-exported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = item.is_stripped();\n+        }\n+        let scx = &self.shared;\n+        self.dst.push(item_name);\n+        self.current.push(item_name.to_owned());\n+\n+        info!(\"Recursing into {}\", self.dst.display());\n+\n+        let buf = self.render_item(item, false, cache);\n+        // buf will be empty if the module is stripped and there is no redirect for it\n+        if !buf.is_empty() {\n+            self.shared.ensure_dir(&self.dst)?;\n+            let joint_dst = self.dst.join(\"index.html\");\n+            scx.fs.write(&joint_dst, buf.as_bytes())?;\n+        }\n+\n+        // Render sidebar-items.js used throughout this module.\n+        if !self.render_redirect_pages {\n+            let module = match item.inner {\n+                clean::StrippedItem(box clean::ModuleItem(ref m)) | clean::ModuleItem(ref m) => m,\n+                _ => unreachable!(),\n+            };\n+            let items = self.build_sidebar_items(module);\n+            let js_dst = self.dst.join(\"sidebar-items.js\");\n+            let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n+            scx.fs.write(&js_dst, &v)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn mod_item_out(&mut self, _item_name: &str) -> Result<(), Error> {\n+        info!(\"Recursed; leaving {}\", self.dst.display());\n+\n+        // Go back to where we were at\n+        self.dst.pop();\n+        self.current.pop();\n+        Ok(())\n+    }\n+\n+    fn item(&mut self, item: clean::Item, cache: &Cache) -> Result<(), Error> {\n+        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n+        // if they contain impls for public types. These modules can also\n+        // contain items such as publicly re-exported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = item.is_stripped();\n+        }\n+\n+        let buf = self.render_item(&item, true, cache);\n+        // buf will be empty if the item is stripped and there is no redirect for it\n+        if !buf.is_empty() {\n+            let name = item.name.as_ref().unwrap();\n+            let item_type = item.type_();\n+            let file_name = &item_path(item_type, name);\n+            self.shared.ensure_dir(&self.dst)?;\n+            let joint_dst = self.dst.join(file_name);\n+            self.shared.fs.write(&joint_dst, buf.as_bytes())?;\n+\n+            if !self.render_redirect_pages {\n+                self.all.borrow_mut().append(full_path(self, &item), &item_type);\n+            }\n+            // If the item is a macro, redirect from the old macro URL (with !)\n+            // to the new one (without).\n+            if item_type == ItemType::Macro {\n+                let redir_name = format!(\"{}.{}!.html\", item_type, name);\n+                let redir_dst = self.dst.join(redir_name);\n+                let v = layout::redirect(file_name);\n+                self.shared.fs.write(&redir_dst, v.as_bytes())?;\n+            }\n+        }\n         Ok(())\n     }\n }\n@@ -604,6 +679,7 @@ fn write_shared(\n     krate: &clean::Crate,\n     search_index: String,\n     options: &RenderOptions,\n+    cache: &Cache,\n ) -> Result<(), Error> {\n     // Write out the shared files. Note that these are shared among all rustdoc\n     // docs placed in the output directory, so this needs to be a synchronized\n@@ -1001,17 +1077,17 @@ themePicker.onblur = handleThemeButtonsBlur;\n \n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n-    for (&did, imps) in &cx.cache.implementors {\n+    for (&did, imps) in &cache.implementors {\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n         // rare cases we could find an implementation for an item which wasn't\n         // indexed, so we just skip this step in that case.\n         //\n         // FIXME: this is a vague explanation for why this can't be a `get`, in\n         //        theory it should be...\n-        let &(ref remote_path, remote_item_type) = match cx.cache.paths.get(&did) {\n+        let &(ref remote_path, remote_item_type) = match cache.paths.get(&did) {\n             Some(p) => p,\n-            None => match cx.cache.external_paths.get(&did) {\n+            None => match cache.external_paths.get(&did) {\n                 Some(p) => p,\n                 None => continue,\n             },\n@@ -1049,7 +1125,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         // Only create a js file if we have impls to add to it. If the trait is\n         // documented locally though we always create the file to avoid dead\n         // links.\n-        if implementors.is_empty() && !cx.cache.paths.contains_key(&did) {\n+        if implementors.is_empty() && !cache.paths.contains_key(&did) {\n             continue;\n         }\n \n@@ -1354,93 +1430,7 @@ impl Context {\n         \"../\".repeat(self.current.len())\n     }\n \n-    /// Main method for rendering a crate.\n-    ///\n-    /// This currently isn't parallelized, but it'd be pretty easy to add\n-    /// parallelization to this function.\n-    fn krate(self, mut krate: clean::Crate) -> Result<(), Error> {\n-        let mut item = match krate.module.take() {\n-            Some(i) => i,\n-            None => return Ok(()),\n-        };\n-        let final_file = self.dst.join(&krate.name).join(\"all.html\");\n-        let settings_file = self.dst.join(\"settings.html\");\n-\n-        let crate_name = krate.name.clone();\n-        item.name = Some(krate.name);\n-\n-        let mut all = AllTypes::new();\n-\n-        {\n-            // Render the crate documentation\n-            let mut work = vec![(self.clone(), item)];\n-\n-            while let Some((mut cx, item)) = work.pop() {\n-                cx.item(item, &mut all, |cx, item| work.push((cx.clone(), item)))?\n-            }\n-        }\n-\n-        let mut root_path = self.dst.to_str().expect(\"invalid path\").to_owned();\n-        if !root_path.ends_with('/') {\n-            root_path.push('/');\n-        }\n-        let mut page = layout::Page {\n-            title: \"List of all items in this crate\",\n-            css_class: \"mod\",\n-            root_path: \"../\",\n-            static_root_path: self.shared.static_root_path.as_deref(),\n-            description: \"List of all items in this crate\",\n-            keywords: BASIC_KEYWORDS,\n-            resource_suffix: &self.shared.resource_suffix,\n-            extra_scripts: &[],\n-            static_extra_scripts: &[],\n-        };\n-        let sidebar = if let Some(ref version) = self.cache.crate_version {\n-            format!(\n-                \"<p class='location'>Crate {}</p>\\\n-                     <div class='block version'>\\\n-                         <p>Version {}</p>\\\n-                     </div>\\\n-                     <a id='all-types' href='index.html'><p>Back to index</p></a>\",\n-                crate_name,\n-                Escape(version),\n-            )\n-        } else {\n-            String::new()\n-        };\n-        let v = layout::render(\n-            &self.shared.layout,\n-            &page,\n-            sidebar,\n-            |buf: &mut Buffer| all.print(buf),\n-            &self.shared.style_files,\n-        );\n-        self.shared.fs.write(&final_file, v.as_bytes())?;\n-\n-        // Generating settings page.\n-        page.title = \"Rustdoc settings\";\n-        page.description = \"Settings of Rustdoc\";\n-        page.root_path = \"./\";\n-\n-        let mut style_files = self.shared.style_files.clone();\n-        let sidebar = \"<p class='location'>Settings</p><div class='sidebar-elems'></div>\";\n-        style_files.push(StylePath { path: PathBuf::from(\"settings.css\"), disabled: false });\n-        let v = layout::render(\n-            &self.shared.layout,\n-            &page,\n-            sidebar,\n-            settings(\n-                self.shared.static_root_path.as_deref().unwrap_or(\"./\"),\n-                &self.shared.resource_suffix,\n-            ),\n-            &style_files,\n-        );\n-        self.shared.fs.write(&settings_file, v.as_bytes())?;\n-\n-        Ok(())\n-    }\n-\n-    fn render_item(&self, it: &clean::Item, pushname: bool) -> String {\n+    fn render_item(&self, it: &clean::Item, pushname: bool, cache: &Cache) -> String {\n         // A little unfortunate that this is done like this, but it sure\n         // does make formatting *a lot* nicer.\n         CURRENT_DEPTH.with(|slot| {\n@@ -1493,13 +1483,13 @@ impl Context {\n             layout::render(\n                 &self.shared.layout,\n                 &page,\n-                |buf: &mut _| print_sidebar(self, it, buf),\n-                |buf: &mut _| print_item(self, it, buf),\n+                |buf: &mut _| print_sidebar(self, it, buf, cache),\n+                |buf: &mut _| print_item(self, it, buf, cache),\n                 &self.shared.style_files,\n             )\n         } else {\n             let mut url = self.root_path();\n-            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id) {\n+            if let Some(&(ref names, ty)) = cache.paths.get(&it.def_id) {\n                 for name in &names[..names.len() - 1] {\n                     url.push_str(name);\n                     url.push_str(\"/\");\n@@ -1512,97 +1502,6 @@ impl Context {\n         }\n     }\n \n-    /// Non-parallelized version of rendering an item. This will take the input\n-    /// item, render its contents, and then invoke the specified closure with\n-    /// all sub-items which need to be rendered.\n-    ///\n-    /// The rendering driver uses this closure to queue up more work.\n-    fn item<F>(&mut self, item: clean::Item, all: &mut AllTypes, mut f: F) -> Result<(), Error>\n-    where\n-        F: FnMut(&mut Context, clean::Item),\n-    {\n-        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n-        // if they contain impls for public types. These modules can also\n-        // contain items such as publicly re-exported structures.\n-        //\n-        // External crates will provide links to these structures, so\n-        // these modules are recursed into, but not rendered normally\n-        // (a flag on the context).\n-        if !self.render_redirect_pages {\n-            self.render_redirect_pages = item.is_stripped();\n-        }\n-\n-        if item.is_mod() {\n-            // modules are special because they add a namespace. We also need to\n-            // recurse into the items of the module as well.\n-            let name = item.name.as_ref().unwrap().to_string();\n-            let scx = &self.shared;\n-            if name.is_empty() {\n-                panic!(\"Unexpected empty destination: {:?}\", self.current);\n-            }\n-            let prev = self.dst.clone();\n-            self.dst.push(&name);\n-            self.current.push(name);\n-\n-            info!(\"Recursing into {}\", self.dst.display());\n-\n-            let buf = self.render_item(&item, false);\n-            // buf will be empty if the module is stripped and there is no redirect for it\n-            if !buf.is_empty() {\n-                self.shared.ensure_dir(&self.dst)?;\n-                let joint_dst = self.dst.join(\"index.html\");\n-                scx.fs.write(&joint_dst, buf.as_bytes())?;\n-            }\n-\n-            let m = match item.inner {\n-                clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n-                _ => unreachable!(),\n-            };\n-\n-            // Render sidebar-items.js used throughout this module.\n-            if !self.render_redirect_pages {\n-                let items = self.build_sidebar_items(&m);\n-                let js_dst = self.dst.join(\"sidebar-items.js\");\n-                let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n-                scx.fs.write(&js_dst, &v)?;\n-            }\n-\n-            for item in m.items {\n-                f(self, item);\n-            }\n-\n-            info!(\"Recursed; leaving {}\", self.dst.display());\n-\n-            // Go back to where we were at\n-            self.dst = prev;\n-            self.current.pop().unwrap();\n-        } else if item.name.is_some() {\n-            let buf = self.render_item(&item, true);\n-            // buf will be empty if the item is stripped and there is no redirect for it\n-            if !buf.is_empty() {\n-                let name = item.name.as_ref().unwrap();\n-                let item_type = item.type_();\n-                let file_name = &item_path(item_type, name);\n-                self.shared.ensure_dir(&self.dst)?;\n-                let joint_dst = self.dst.join(file_name);\n-                self.shared.fs.write(&joint_dst, buf.as_bytes())?;\n-\n-                if !self.render_redirect_pages {\n-                    all.append(full_path(self, &item), &item_type);\n-                }\n-                // If the item is a macro, redirect from the old macro URL (with !)\n-                // to the new one (without).\n-                if item_type == ItemType::Macro {\n-                    let redir_name = format!(\"{}.{}!.html\", item_type, name);\n-                    let redir_dst = self.dst.join(redir_name);\n-                    let v = layout::redirect(file_name);\n-                    self.shared.fs.write(&redir_dst, v.as_bytes())?;\n-                }\n-            }\n-        }\n-        Ok(())\n-    }\n-\n     fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n         // BTreeMap instead of HashMap to get a sorted output\n         let mut map: BTreeMap<_, Vec<_>> = BTreeMap::new();\n@@ -1629,9 +1528,7 @@ impl Context {\n         }\n         map\n     }\n-}\n \n-impl Context {\n     /// Generates a url appropriate for an `href` attribute back to the source of\n     /// this item.\n     ///\n@@ -1641,7 +1538,7 @@ impl Context {\n     /// If `None` is returned, then a source link couldn't be generated. This\n     /// may happen, for example, with externally inlined items where the source\n     /// of their crate documentation isn't known.\n-    fn src_href(&self, item: &clean::Item) -> Option<String> {\n+    fn src_href(&self, item: &clean::Item, cache: &Cache) -> Option<String> {\n         let mut root = self.root_path();\n \n         let mut path = String::new();\n@@ -1660,13 +1557,13 @@ impl Context {\n                 return None;\n             }\n         } else {\n-            let (krate, src_root) = match *self.cache.extern_locations.get(&item.source.cnum)? {\n-                (ref name, ref src, Local) => (name, src),\n-                (ref name, ref src, Remote(ref s)) => {\n+            let (krate, src_root) = match *cache.extern_locations.get(&item.source.cnum)? {\n+                (ref name, ref src, ExternalLocation::Local) => (name, src),\n+                (ref name, ref src, ExternalLocation::Remote(ref s)) => {\n                     root = s.to_string();\n                     (name, src)\n                 }\n-                (_, _, Unknown) => return None,\n+                (_, _, ExternalLocation::Unknown) => return None,\n             };\n \n             sources::clean_path(&src_root, file, false, |component| {\n@@ -1703,7 +1600,7 @@ where\n     write!(w, \"</div>\")\n }\n \n-fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n+fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache) {\n     debug_assert!(!item.is_stripped());\n     // Write the breadcrumb trail header for the top\n     write!(buf, \"<h1 class='fqn'><span class='out-of-band'>\");\n@@ -1731,7 +1628,7 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n     // this page, and this link will be auto-clicked. The `id` attribute is\n     // used to find the link to auto-click.\n     if cx.shared.include_sources && !item.is_primitive() {\n-        if let Some(l) = cx.src_href(item) {\n+        if let Some(l) = cx.src_href(item, cache) {\n             write!(buf, \"<a class='srclink' href='{}' title='{}'>[src]</a>\", l, \"goto source code\");\n         }\n     }\n@@ -1792,20 +1689,20 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n         clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) => {\n             item_function(buf, cx, item, f)\n         }\n-        clean::TraitItem(ref t) => item_trait(buf, cx, item, t),\n-        clean::StructItem(ref s) => item_struct(buf, cx, item, s),\n-        clean::UnionItem(ref s) => item_union(buf, cx, item, s),\n-        clean::EnumItem(ref e) => item_enum(buf, cx, item, e),\n-        clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t),\n+        clean::TraitItem(ref t) => item_trait(buf, cx, item, t, cache),\n+        clean::StructItem(ref s) => item_struct(buf, cx, item, s, cache),\n+        clean::UnionItem(ref s) => item_union(buf, cx, item, s, cache),\n+        clean::EnumItem(ref e) => item_enum(buf, cx, item, e, cache),\n+        clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t, cache),\n         clean::MacroItem(ref m) => item_macro(buf, cx, item, m),\n         clean::ProcMacroItem(ref m) => item_proc_macro(buf, cx, item, m),\n-        clean::PrimitiveItem(_) => item_primitive(buf, cx, item),\n+        clean::PrimitiveItem(_) => item_primitive(buf, cx, item, cache),\n         clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) => item_static(buf, cx, item, i),\n         clean::ConstantItem(ref c) => item_constant(buf, cx, item, c),\n-        clean::ForeignTypeItem => item_foreign_type(buf, cx, item),\n+        clean::ForeignTypeItem => item_foreign_type(buf, cx, item, cache),\n         clean::KeywordItem(_) => item_keyword(buf, cx, item),\n-        clean::OpaqueTyItem(ref e, _) => item_opaque_ty(buf, cx, item, e),\n-        clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta),\n+        clean::OpaqueTyItem(ref e, _) => item_opaque_ty(buf, cx, item, e, cache),\n+        clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta, cache),\n         _ => {\n             // We don't generate pages for any other type.\n             unreachable!();\n@@ -1828,7 +1725,7 @@ fn full_path(cx: &Context, item: &clean::Item) -> String {\n }\n \n #[inline]\n-fn plain_summary_line(s: Option<&str>) -> String {\n+crate fn plain_summary_line(s: Option<&str>) -> String {\n     let s = s.unwrap_or(\"\");\n     // This essentially gets the first paragraph of text in one line.\n     let mut line = s\n@@ -1845,7 +1742,7 @@ fn plain_summary_line(s: Option<&str>) -> String {\n     markdown::plain_summary_line(&line[..])\n }\n \n-fn shorten(s: String) -> String {\n+crate fn shorten(s: String) -> String {\n     if s.chars().count() > 60 {\n         let mut len = 0;\n         let mut ret = s\n@@ -2415,6 +2312,7 @@ fn render_implementor(\n     w: &mut Buffer,\n     implementor_dups: &FxHashMap<&str, (DefId, bool)>,\n     aliases: &[String],\n+    cache: &Cache,\n ) {\n     // If there's already another implementor that has the same abbridged name, use the\n     // full path, for example in `std::iter::ExactSizeIterator`\n@@ -2438,10 +2336,17 @@ fn render_implementor(\n         false,\n         false,\n         aliases,\n+        cache,\n     );\n }\n \n-fn render_impls(cx: &Context, w: &mut Buffer, traits: &[&&Impl], containing_item: &clean::Item) {\n+fn render_impls(\n+    cx: &Context,\n+    w: &mut Buffer,\n+    traits: &[&&Impl],\n+    containing_item: &clean::Item,\n+    cache: &Cache,\n+) {\n     let mut impls = traits\n         .iter()\n         .map(|i| {\n@@ -2460,6 +2365,7 @@ fn render_impls(cx: &Context, w: &mut Buffer, traits: &[&&Impl], containing_item\n                 false,\n                 true,\n                 &[],\n+                cache,\n             );\n             buffer.into_inner()\n         })\n@@ -2492,7 +2398,7 @@ fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n     name_key(&lhs).cmp(&name_key(&rhs))\n }\n \n-fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait) {\n+fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait, cache: &Cache) {\n     let bounds = bounds(&t.bounds, false);\n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n@@ -2652,9 +2558,9 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache);\n \n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n+    if let Some(implementors) = cache.implementors.get(&it.def_id) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<&str, (DefId, bool)> = FxHashMap::default();\n@@ -2676,7 +2582,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n         }\n \n         let (local, foreign) = implementors.iter().partition::<Vec<_>, _>(|i| {\n-            i.inner_impl().for_.def_id().map_or(true, |d| cx.cache.paths.contains_key(&d))\n+            i.inner_impl().for_.def_id().map_or(true, |d| cache.paths.contains_key(&d))\n         });\n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -2705,6 +2611,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n                     true,\n                     false,\n                     &[],\n+                    cache,\n                 );\n             }\n             write_loading_content(w, \"\");\n@@ -2717,7 +2624,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n             \"<div class='item-list' id='implementors-list'>\",\n         );\n         for implementor in concrete {\n-            render_implementor(cx, implementor, w, &implementor_dups, &[]);\n+            render_implementor(cx, implementor, w, &implementor_dups, &[], cache);\n         }\n         write_loading_content(w, \"</div>\");\n \n@@ -2735,6 +2642,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n                     w,\n                     &implementor_dups,\n                     &collect_paths_for_type(implementor.inner_impl().for_.clone()),\n+                    cache,\n                 );\n             }\n             write_loading_content(w, \"</div>\");\n@@ -2770,7 +2678,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n         path = if it.def_id.is_local() {\n             cx.current.join(\"/\")\n         } else {\n-            let (ref path, _) = cx.cache.external_paths[&it.def_id];\n+            let (ref path, _) = cache.external_paths[&it.def_id];\n             path[..path.len() - 1].join(\"/\")\n         },\n         ty = it.type_(),\n@@ -2779,7 +2687,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n }\n \n fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>) -> String {\n-    use crate::html::item_type::ItemType::*;\n+    use crate::formats::item_type::ItemType::*;\n \n     let name = it.name.as_ref().unwrap();\n     let ty = match it.type_() {\n@@ -2945,7 +2853,7 @@ fn render_assoc_item(\n     }\n }\n \n-fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct) {\n+fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct, cache: &Cache) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust struct'>\");\n         render_attributes(w, it, true);\n@@ -2992,10 +2900,10 @@ fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct\n             }\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union) {\n+fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union, cache: &Cache) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust union'>\");\n         render_attributes(w, it, true);\n@@ -3038,10 +2946,10 @@ fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union)\n             document(w, cx, field);\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n+fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, cache: &Cache) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust enum'>\");\n         render_attributes(w, it, true);\n@@ -3166,7 +3074,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n             render_stability_since(w, variant, it);\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n const ALLOWED_ATTRIBUTES: &[Symbol] = &[\n@@ -3348,26 +3256,15 @@ impl<'a> AssocItemLink<'a> {\n     }\n }\n \n-enum AssocItemRender<'a> {\n-    All,\n-    DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type, deref_mut_: bool },\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-enum RenderMode {\n-    Normal,\n-    ForDeref { mut_: bool },\n-}\n-\n fn render_assoc_items(\n     w: &mut Buffer,\n     cx: &Context,\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n+    cache: &Cache,\n ) {\n-    let c = &cx.cache;\n-    let v = match c.impls.get(&it) {\n+    let v = match cache.impls.get(&it) {\n         Some(v) => v,\n         None => return,\n     };\n@@ -3413,6 +3310,7 @@ fn render_assoc_items(\n                 false,\n                 true,\n                 &[],\n+                cache,\n             );\n         }\n     }\n@@ -3421,11 +3319,11 @@ fn render_assoc_items(\n     }\n     if !traits.is_empty() {\n         let deref_impl =\n-            traits.iter().find(|t| t.inner_impl().trait_.def_id() == c.deref_trait_did);\n+            traits.iter().find(|t| t.inner_impl().trait_.def_id() == cache.deref_trait_did);\n         if let Some(impl_) = deref_impl {\n             let has_deref_mut =\n-                traits.iter().any(|t| t.inner_impl().trait_.def_id() == c.deref_mut_trait_did);\n-            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n+                traits.iter().any(|t| t.inner_impl().trait_.def_id() == cache.deref_mut_trait_did);\n+            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut, cache);\n         }\n \n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -3434,7 +3332,7 @@ fn render_assoc_items(\n             concrete.into_iter().partition(|t| t.inner_impl().blanket_impl.is_some());\n \n         let mut impls = Buffer::empty_from(&w);\n-        render_impls(cx, &mut impls, &concrete, containing_item);\n+        render_impls(cx, &mut impls, &concrete, containing_item, cache);\n         let impls = impls.into_inner();\n         if !impls.is_empty() {\n             write!(\n@@ -3459,7 +3357,7 @@ fn render_assoc_items(\n                 <div id='synthetic-implementations-list'>\\\n             \"\n             );\n-            render_impls(cx, w, &synthetic, containing_item);\n+            render_impls(cx, w, &synthetic, containing_item, cache);\n             write!(w, \"</div>\");\n         }\n \n@@ -3474,7 +3372,7 @@ fn render_assoc_items(\n                 <div id='blanket-implementations-list'>\\\n             \"\n             );\n-            render_impls(cx, w, &blanket_impl, containing_item);\n+            render_impls(cx, w, &blanket_impl, containing_item, cache);\n             write!(w, \"</div>\");\n         }\n     }\n@@ -3486,6 +3384,7 @@ fn render_deref_methods(\n     impl_: &Impl,\n     container_item: &clean::Item,\n     deref_mut: bool,\n+    cache: &Cache,\n ) {\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n     let (target, real_target) = impl_\n@@ -3503,11 +3402,11 @@ fn render_deref_methods(\n     let what =\n         AssocItemRender::DerefFor { trait_: deref_type, type_: real_target, deref_mut_: deref_mut };\n     if let Some(did) = target.def_id() {\n-        render_assoc_items(w, cx, container_item, did, what);\n+        render_assoc_items(w, cx, container_item, did, what, cache);\n     } else {\n         if let Some(prim) = target.primitive_type() {\n-            if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n-                render_assoc_items(w, cx, container_item, did, what);\n+            if let Some(&did) = cache.primitive_locations.get(&prim) {\n+                render_assoc_items(w, cx, container_item, did, what, cache);\n             }\n         }\n     }\n@@ -3609,6 +3508,7 @@ fn render_impl(\n     // This argument is used to reference same type with different paths to avoid duplication\n     // in documentation pages for trait with automatic implementations like \"Send\" and \"Sync\".\n     aliases: &[String],\n+    cache: &Cache,\n ) {\n     if render_mode == RenderMode::Normal {\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n@@ -3651,7 +3551,7 @@ fn render_impl(\n         write!(w, \"<a href='#{}' class='anchor'></a>\", id);\n         let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n         render_stability_since_raw(w, since, outer_version);\n-        if let Some(l) = cx.src_href(&i.impl_item) {\n+        if let Some(l) = cx.src_href(&i.impl_item, cache) {\n             write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\", l, \"goto source code\");\n         }\n         write!(w, \"</h3>\");\n@@ -3683,6 +3583,7 @@ fn render_impl(\n         outer_version: Option<&str>,\n         trait_: Option<&clean::Trait>,\n         show_def_docs: bool,\n+        cache: &Cache,\n     ) {\n         let item_type = item.type_();\n         let name = item.name.as_ref().unwrap();\n@@ -3711,7 +3612,7 @@ fn render_impl(\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl);\n                     write!(w, \"</code>\");\n                     render_stability_since_raw(w, item.stable_since(), outer_version);\n-                    if let Some(l) = cx.src_href(item) {\n+                    if let Some(l) = cx.src_href(item, cache) {\n                         write!(\n                             w,\n                             \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n@@ -3733,7 +3634,7 @@ fn render_impl(\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\");\n                 write!(w, \"</code>\");\n                 render_stability_since_raw(w, item.stable_since(), outer_version);\n-                if let Some(l) = cx.src_href(item) {\n+                if let Some(l) = cx.src_href(item, cache) {\n                     write!(\n                         w,\n                         \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n@@ -3784,7 +3685,7 @@ fn render_impl(\n         }\n     }\n \n-    let traits = &cx.cache.traits;\n+    let traits = &cache.traits;\n     let trait_ = i.trait_did().map(|did| &traits[&did]);\n \n     write!(w, \"<div class='impl-items'>\");\n@@ -3799,6 +3700,7 @@ fn render_impl(\n             outer_version,\n             trait_,\n             show_def_docs,\n+            cache,\n         );\n     }\n \n@@ -3810,6 +3712,7 @@ fn render_impl(\n         render_mode: RenderMode,\n         outer_version: Option<&str>,\n         show_def_docs: bool,\n+        cache: &Cache,\n     ) {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n@@ -3829,6 +3732,7 @@ fn render_impl(\n                 outer_version,\n                 None,\n                 show_def_docs,\n+                cache,\n             );\n         }\n     }\n@@ -3847,13 +3751,20 @@ fn render_impl(\n                 render_mode,\n                 outer_version,\n                 show_def_docs,\n+                cache,\n             );\n         }\n     }\n     write!(w, \"</div>\");\n }\n \n-fn item_opaque_ty(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::OpaqueTy) {\n+fn item_opaque_ty(\n+    w: &mut Buffer,\n+    cx: &Context,\n+    it: &clean::Item,\n+    t: &clean::OpaqueTy,\n+    cache: &Cache,\n+) {\n     write!(w, \"<pre class='rust opaque'>\");\n     render_attributes(w, it, false);\n     write!(\n@@ -3871,10 +3782,16 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Opa\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_trait_alias(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::TraitAlias) {\n+fn item_trait_alias(\n+    w: &mut Buffer,\n+    cx: &Context,\n+    it: &clean::Item,\n+    t: &clean::TraitAlias,\n+    cache: &Cache,\n+) {\n     write!(w, \"<pre class='rust trait-alias'>\");\n     render_attributes(w, it, false);\n     write!(\n@@ -3892,10 +3809,10 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::T\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typedef) {\n+fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typedef, cache: &Cache) {\n     write!(w, \"<pre class='rust typedef'>\");\n     render_attributes(w, it, false);\n     write!(\n@@ -3913,10 +3830,10 @@ fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typed\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n+fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item, cache: &Cache) {\n     writeln!(w, \"<pre class='rust foreigntype'>extern {{\");\n     render_attributes(w, it, false);\n     write!(\n@@ -3928,10 +3845,10 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n \n     document(w, cx, it);\n \n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n+fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer, cache: &Cache) {\n     let parentlen = cx.current.len() - if it.is_mod() { 1 } else { 0 };\n \n     if it.is_struct()\n@@ -3966,7 +3883,7 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n     }\n \n     if it.is_crate() {\n-        if let Some(ref version) = cx.cache.crate_version {\n+        if let Some(ref version) = cache.crate_version {\n             write!(\n                 buffer,\n                 \"<div class='block version'>\\\n@@ -4603,9 +4520,9 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, m: &clean::Pr\n     document(w, cx, it)\n }\n \n-fn item_primitive(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n+fn item_primitive(w: &mut Buffer, cx: &Context, it: &clean::Item, cache: &Cache) {\n     document(w, cx, it);\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n fn item_keyword(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n@@ -4670,7 +4587,3 @@ fn collect_paths_for_type(first_ty: clean::Type) -> Vec<String> {\n     }\n     out\n }\n-\n-crate fn cache() -> Arc<Cache> {\n-    CACHE_KEY.with(|c| c.borrow().clone())\n-}", "previous_filename": "src/librustdoc/html/render.rs"}, {"sha": "aaa73b100c2433b15918b871091e4e645c7a0698", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -1,10 +1,11 @@\n use crate::clean;\n use crate::docfs::PathError;\n+use crate::error::Error;\n use crate::fold::DocFolder;\n use crate::html::format::Buffer;\n use crate::html::highlight;\n use crate::html::layout;\n-use crate::html::render::{Error, SharedContext, BASIC_KEYWORDS};\n+use crate::html::render::{SharedContext, BASIC_KEYWORDS};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_span::source_map::FileName;\n use std::ffi::OsStr;"}, {"sha": "65bc089faf42816dc9dbd9ba9cb5505c9e10fbce", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b269e44322cfca727fd0e793d3a60bd371cbcae/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6b269e44322cfca727fd0e793d3a60bd371cbcae", "patch": "@@ -63,19 +63,11 @@ mod config;\n mod core;\n mod docfs;\n mod doctree;\n+#[macro_use]\n+mod error;\n mod fold;\n-pub mod html {\n-    crate mod escape;\n-    crate mod format;\n-    crate mod highlight;\n-    crate mod item_type;\n-    crate mod layout;\n-    pub mod markdown;\n-    crate mod render;\n-    crate mod sources;\n-    crate mod static_files;\n-    crate mod toc;\n-}\n+crate mod formats;\n+pub mod html;\n mod markdown;\n mod passes;\n mod test;\n@@ -85,7 +77,7 @@ mod visit_lib;\n \n struct Output {\n     krate: clean::Crate,\n-    renderinfo: html::render::RenderInfo,\n+    renderinfo: config::RenderInfo,\n     renderopts: config::RenderOptions,\n }\n \n@@ -510,12 +502,19 @@ fn main_options(options: config::Options) -> i32 {\n         info!(\"going to format\");\n         let (error_format, edition, debugging_options) = diag_opts;\n         let diag = core::new_handler(error_format, None, &debugging_options);\n-        match html::render::run(krate, renderopts, renderinfo, &diag, edition) {\n+        match formats::run_format::<html::render::Context>(\n+            krate, renderopts, renderinfo, &diag, edition,\n+        ) {\n             Ok(_) => rustc_driver::EXIT_SUCCESS,\n             Err(e) => {\n-                diag.struct_err(&format!(\"couldn't generate documentation: {}\", e.error))\n-                    .note(&format!(\"failed to create or modify \\\"{}\\\"\", e.file.display()))\n-                    .emit();\n+                let mut msg =\n+                    diag.struct_err(&format!(\"couldn't generate documentation: {}\", e.error));\n+                let file = e.file.display().to_string();\n+                if file.is_empty() {\n+                    msg.emit()\n+                } else {\n+                    msg.note(&format!(\"failed to create or modify \\\"{}\\\"\", file)).emit()\n+                }\n                 rustc_driver::EXIT_FAILURE\n             }\n         }"}]}