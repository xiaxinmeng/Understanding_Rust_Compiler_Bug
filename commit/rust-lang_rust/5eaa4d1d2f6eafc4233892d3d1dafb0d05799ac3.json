{"sha": "5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYWE0ZDFkMmY2ZWFmYzQyMzM4OTJkM2QxZGFmYjBkMDU3OTlhYzM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-06T23:21:02Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-06T23:21:02Z"}, "message": "Merge remote-tracking branch 'remotes/origin/master' into remove-str-trailing-nulls", "tree": {"sha": "3ee757ce4806cf7686f0508952149f2a75d0d0f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ee757ce4806cf7686f0508952149f2a75d0d0f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "html_url": "https://github.com/rust-lang/rust/commit/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e7b6662502a82b6f1a789277d3dc2e68aa4eb13", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e7b6662502a82b6f1a789277d3dc2e68aa4eb13", "html_url": "https://github.com/rust-lang/rust/commit/5e7b6662502a82b6f1a789277d3dc2e68aa4eb13"}, {"sha": "6972eb4cd7702a343a7e79c4a57522d0de763327", "url": "https://api.github.com/repos/rust-lang/rust/commits/6972eb4cd7702a343a7e79c4a57522d0de763327", "html_url": "https://github.com/rust-lang/rust/commit/6972eb4cd7702a343a7e79c4a57522d0de763327"}], "stats": {"total": 2500, "additions": 1283, "deletions": 1217}, "files": [{"sha": "fce6e8a9e2fccf190bf34d8c1a51ec93e3202f7e", "filename": "mk/target.mk", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -48,7 +48,7 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2)): \\\n \t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(STDLIB_GLOB_$(2)),$$(notdir $$@))\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) $$(WFLAGS_ST$(1)) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) $$(WFLAGS_ST$(1)) --out-dir $$(@D) $$< && touch $$@\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(STDLIB_GLOB_$(2)),$$(notdir $$@))\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2)): \\\n@@ -58,7 +58,7 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2)): \\\n \t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(EXTRALIB_GLOB_$(2)),$$(notdir $$@))\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) $$(WFLAGS_ST$(1)) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) $$(WFLAGS_ST$(1)) --out-dir $$(@D) $$< && touch $$@\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(EXTRALIB_GLOB_$(2)),$$(notdir $$@))\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(3)): \\\n@@ -69,7 +69,7 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(3)): \\\n \t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBSYNTAX_GLOB_$(2)),$$(notdir $$@))\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) $(BORROWCK) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) $(BORROWCK) --out-dir $$(@D) $$< && touch $$@\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBSYNTAX_GLOB_$(2)),$$(notdir $$@))\n \n # Only build the compiler for host triples\n@@ -90,7 +90,7 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(3)):\t\t\\\n \t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTC_GLOB_$(2)),$$(notdir $$@))\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) --out-dir $$(@D) $$< && touch $$@\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTC_GLOB_$(2)),$$(notdir $$@))\n \n $$(TBIN$(1)_T_$(2)_H_$(3))/rustc$$(X_$(3)):\t\t\t\\"}, {"sha": "32c034d878cb9671a5ef7ada47c308dd9be0e550", "filename": "mk/tools.mk", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -49,7 +49,7 @@ $$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTPKG_$(4)):\t\t\\\n \t\t| $$(TLIB$(1)_T_$(4)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTPKG_GLOB_$(4)),$$(notdir $$@))\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) $$(WFLAGS_ST$(1)) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(4)_H_$(3)) $$(WFLAGS_ST$(1)) --out-dir $$(@D) $$< && touch $$@\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTPKG_GLOB_$(4)),$$(notdir $$@))\n \n $$(TBIN$(1)_T_$(4)_H_$(3))/rustpkg$$(X_$(4)):\t\t\t\t\\\n@@ -67,7 +67,7 @@ $$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTDOC_$(4)):\t\t\\\n \t\t| $$(TLIB$(1)_T_$(4)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTDOC_GLOB_$(4)),$$(notdir $$@))\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(4)_H_$(3)) --out-dir $$(@D) $$< && touch $$@\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTDOC_GLOB_$(4)),$$(notdir $$@))\n \n $$(TBIN$(1)_T_$(4)_H_$(3))/rustdoc$$(X_$(4)):\t\t\t\\\n@@ -85,7 +85,7 @@ $$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTI_$(4)):\t\t\\\n \t\t| $$(TLIB$(1)_T_$(4)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTI_GLOB_$(4)),$$(notdir $$@))\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(4)_H_$(3)) --out-dir $$(@D) $$< && touch $$@\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTI_GLOB_$(4)),$$(notdir $$@))\n \n $$(TBIN$(1)_T_$(4)_H_$(3))/rusti$$(X_$(4)):\t\t\t\\\n@@ -106,7 +106,7 @@ $$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUST_$(4)):\t\t\\\n \t\t| $$(TLIB$(1)_T_$(4)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUST_GLOB_$(4)),$$(notdir $$@))\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(4)_H_$(3)) --out-dir $$(@D) $$< && touch $$@\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUST_GLOB_$(4)),$$(notdir $$@))\n \n $$(TBIN$(1)_T_$(4)_H_$(3))/rust$$(X_$(4)):\t\t\t\\"}, {"sha": "4e4261e8b2bbda8b8dd19dfc6a3d3704a941dd6d", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -11,7 +11,6 @@\n #[crate_type = \"bin\"];\n \n #[allow(non_camel_case_types)];\n-#[allow(unrecognized_lint)]; // NOTE: remove after snapshot\n #[deny(warnings)];\n \n extern mod extra;\n@@ -131,7 +130,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n         ratchet_noise_percent:\n             getopts::opt_maybe_str(matches,\n                                    \"ratchet-noise-percent\").map(|s|\n-                                                                f64::from_str(*s).get()),\n+                                                                f64::from_str(*s).unwrap()),\n         runtool: getopts::opt_maybe_str(matches, \"runtool\"),\n         rustcflags: getopts::opt_maybe_str(matches, \"rustcflags\"),\n         jit: getopts::opt_present(matches, \"jit\"),\n@@ -267,7 +266,7 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n           _ => ~[~\".rc\", ~\".rs\"]\n         };\n     let invalid_prefixes = ~[~\".\", ~\"#\", ~\"~\"];\n-    let name = testfile.filename().get();\n+    let name = testfile.filename().unwrap();\n \n     let mut valid = false;\n \n@@ -300,7 +299,7 @@ pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n     fn shorten(path: &Path) -> ~str {\n         let filename = path.filename();\n         let dir = path.pop().filename();\n-        fmt!(\"%s/%s\", dir.get_or_default(~\"\"), filename.get_or_default(~\"\"))\n+        fmt!(\"%s/%s\", dir.unwrap_or_default(~\"\"), filename.unwrap_or_default(~\"\"))\n     }\n \n     test::DynTestName(fmt!(\"[%s] %s\","}, {"sha": "5c1cc78d678f361f1525226fbcb8e1bf7f807f34", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -145,7 +145,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let rounds =\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n-    let mut srcs = ~[io::read_whole_file_str(testfile).get()];\n+    let mut srcs = ~[io::read_whole_file_str(testfile).unwrap()];\n \n     let mut round = 0;\n     while round < rounds {\n@@ -166,7 +166,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n         match props.pp_exact {\n           Some(ref file) => {\n             let filepath = testfile.dir_path().push_rel(file);\n-            io::read_whole_file_str(&filepath).get()\n+            io::read_whole_file_str(&filepath).unwrap()\n           }\n           None => { srcs[srcs.len() - 2u].clone() }\n         };\n@@ -448,7 +448,7 @@ fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if opt.is_none() {\n         return false;\n     }\n-    *idx = opt.get();\n+    *idx = opt.unwrap();\n     return true;\n }\n \n@@ -709,7 +709,7 @@ fn aux_output_dir_name(config: &config, testfile: &Path) -> Path {\n }\n \n fn output_testname(testfile: &Path) -> Path {\n-    Path(testfile.filestem().get())\n+    Path(testfile.filestem().unwrap())\n }\n \n fn output_base_name(config: &config, testfile: &Path) -> Path {\n@@ -878,7 +878,7 @@ fn append_suffix_to_stem(p: &Path, suffix: &str) -> Path {\n     if suffix.len() == 0 {\n         (*p).clone()\n     } else {\n-        let stem = p.filestem().get();\n+        let stem = p.filestem().unwrap();\n         p.with_filestem(stem + \"-\" + suffix)\n     }\n }\n@@ -938,7 +938,7 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n \n \n fn count_extracted_lines(p: &Path) -> uint {\n-    let x = io::read_whole_file_str(&p.with_filetype(\"ll\")).get();\n+    let x = io::read_whole_file_str(&p.with_filetype(\"ll\")).unwrap();\n     x.line_iter().len_()\n }\n "}, {"sha": "550b891a4db16c22356d20be362f55ca7b06e6cb", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -322,24 +322,24 @@ mod test {\n \n     #[test]\n     fn test_from_base64_basic() {\n-        assert_eq!(\"\".from_base64().get(), \"\".as_bytes().to_owned());\n-        assert_eq!(\"Zg==\".from_base64().get(), \"f\".as_bytes().to_owned());\n-        assert_eq!(\"Zm8=\".from_base64().get(), \"fo\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9v\".from_base64().get(), \"foo\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYg==\".from_base64().get(), \"foob\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYmE=\".from_base64().get(), \"fooba\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYmFy\".from_base64().get(), \"foobar\".as_bytes().to_owned());\n+        assert_eq!(\"\".from_base64().unwrap(), \"\".as_bytes().to_owned());\n+        assert_eq!(\"Zg==\".from_base64().unwrap(), \"f\".as_bytes().to_owned());\n+        assert_eq!(\"Zm8=\".from_base64().unwrap(), \"fo\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9v\".from_base64().unwrap(), \"foo\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYg==\".from_base64().unwrap(), \"foob\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYmE=\".from_base64().unwrap(), \"fooba\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYmFy\".from_base64().unwrap(), \"foobar\".as_bytes().to_owned());\n     }\n \n     #[test]\n     fn test_from_base64_newlines() {\n-        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().get(),\n+        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().unwrap(),\n                    \"foobar\".as_bytes().to_owned());\n     }\n \n     #[test]\n     fn test_from_base64_urlsafe() {\n-        assert_eq!(\"-_8\".from_base64().get(), \"+/8=\".from_base64().get());\n+        assert_eq!(\"-_8\".from_base64().unwrap(), \"+/8=\".from_base64().unwrap());\n     }\n \n     #[test]\n@@ -364,7 +364,7 @@ mod test {\n                     push(random());\n                 }\n             };\n-            assert_eq!(v.to_base64(STANDARD).from_base64().get(), v);\n+            assert_eq!(v.to_base64(STANDARD).from_base64().unwrap(), v);\n         }\n     }\n "}, {"sha": "6dedd9ee4dd266f95da9777cf67bd7737e8edc18", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 22, "deletions": 48, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -13,7 +13,7 @@\n \n use std::cmp;\n use std::iterator::RandomAccessIterator;\n-use std::iterator::{Invert, Enumerate};\n+use std::iterator::{Invert, Enumerate, Repeat, Map, Zip};\n use std::num;\n use std::ops;\n use std::uint;\n@@ -206,14 +206,13 @@ impl BigBitv {\n     #[inline]\n     pub fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n-        do uint::iterate(0, len) |i| {\n+        for i in range(0, len) {\n             let mask = big_mask(nbits, i);\n             if mask & self.storage[i] != mask & b.storage[i] {\n-                false\n-            } else {\n-                true\n+                return false;\n             }\n         }\n+        true\n     }\n }\n \n@@ -864,13 +863,12 @@ impl BitvSet {\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n     fn common_iter<'a>(&'a self, other: &'a BitvSet)\n-        -> MapE<(uint,&uint),(uint,uint,uint), &'a ~[uint],Enumerate<vec::VecIterator<'a,uint>>> {\n-        let min = num::min(self.bitv.storage.len(),\n-                            other.bitv.storage.len());\n-        MapE{iter: self.bitv.storage.slice(0, min).iter().enumerate(),\n-             env: &other.bitv.storage,\n-             f: |(i, &w): (uint, &uint), o_store| (i * uint::bits, w, o_store[i])\n-        }\n+        -> Map<'static, ((uint, &'a uint), &'a ~[uint]), (uint, uint, uint),\n+               Zip<Enumerate<vec::VecIterator<'a, uint>>, Repeat<&'a ~[uint]>>> {\n+        let min = num::min(self.bitv.storage.len(), other.bitv.storage.len());\n+        self.bitv.storage.slice(0, min).iter().enumerate()\n+            .zip(Repeat::new(&other.bitv.storage))\n+            .transform(|((i, &w), o_store)| (i * uint::bits, w, o_store[i]))\n     }\n \n     /// Visits each word in self or other that extends beyond the other. This\n@@ -881,45 +879,21 @@ impl BitvSet {\n     /// is true if the word comes from 'self', and false if it comes from\n     /// 'other'.\n     fn outlier_iter<'a>(&'a self, other: &'a BitvSet)\n-        -> MapE<(uint, &uint),(bool, uint, uint), uint, Enumerate<vec::VecIterator<'a, uint>>> {\n-        let len1 = self.bitv.storage.len();\n-        let len2 = other.bitv.storage.len();\n-        let min = num::min(len1, len2);\n-\n-        if min < len1 {\n-            MapE{iter: self.bitv.storage.slice(min, len1).iter().enumerate(),\n-                 env: min,\n-                 f: |(i, &w): (uint, &uint), min| (true, (i + min) * uint::bits, w)\n-            }\n+        -> Map<'static, ((uint, &'a uint), uint), (bool, uint, uint),\n+               Zip<Enumerate<vec::VecIterator<'a, uint>>, Repeat<uint>>> {\n+        let slen = self.bitv.storage.len();\n+        let olen = other.bitv.storage.len();\n+\n+        if olen < slen {\n+            self.bitv.storage.slice_from(olen).iter().enumerate()\n+                .zip(Repeat::new(olen))\n+                .transform(|((i, &w), min)| (true, (i + min) * uint::bits, w))\n         } else {\n-            MapE{iter: other.bitv.storage.slice(min, len2).iter().enumerate(),\n-                 env: min,\n-                 f: |(i, &w): (uint, &uint), min| (false, (i + min) * uint::bits, w)\n-            }\n-        }\n-    }\n-}\n-\n-/// Like iterator::Map with explicit env capture\n-struct MapE<A, B, Env, I> {\n-    priv env: Env,\n-    priv f: &'static fn(A, Env) -> B,\n-    priv iter: I,\n-}\n-\n-impl<'self, A, B, Env: Clone, I: Iterator<A>> Iterator<B> for MapE<A, B, Env, I> {\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        match self.iter.next() {\n-            Some(elt) => Some((self.f)(elt, self.env.clone())),\n-            None => None\n+            other.bitv.storage.slice_from(slen).iter().enumerate()\n+                .zip(Repeat::new(slen))\n+                .transform(|((i, &w), min)| (false, (i + min) * uint::bits, w))\n         }\n     }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n-    }\n }\n \n pub struct BitvSetIterator<'self> {"}, {"sha": "25501faa02e12dd000cc8f1a5201251c1a5d939b", "filename": "src/libextra/enum_set.rs", "status": "renamed", "additions": 17, "deletions": 47, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fenum_set.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -10,15 +10,19 @@\n \n use std::iterator::Iterator;\n \n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes, ToStr)]\n+/// A specialized Set implementation to use enum types.\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n     // for which no variant exists\n     priv bits: uint\n }\n \n+/// An iterface for casting C-like enum to uint and back.\n pub trait CLike {\n+    /// Converts C-like enum to uint.\n     pub fn to_uint(&self) -> uint;\n+    /// Converts uint to C-like enum.\n     pub fn from_uint(uint) -> Self;\n }\n \n@@ -27,54 +31,47 @@ fn bit<E:CLike>(e: E) -> uint {\n }\n \n impl<E:CLike> EnumSet<E> {\n+    /// Returns an empty EnumSet.\n     pub fn empty() -> EnumSet<E> {\n         EnumSet {bits: 0}\n     }\n \n+    /// Returns true if an EnumSet is empty.\n     pub fn is_empty(&self) -> bool {\n         self.bits == 0\n     }\n \n+    /// Returns true if an EnumSet contains any enum of a given EnumSet\n     pub fn intersects(&self, e: EnumSet<E>) -> bool {\n         (self.bits & e.bits) != 0\n     }\n \n+    /// Returns an intersection of both EnumSets.\n     pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & e.bits}\n     }\n \n+    /// Returns true if a given EnumSet is included in an EnumSet.\n     pub fn contains(&self, e: EnumSet<E>) -> bool {\n         (self.bits & e.bits) == e.bits\n     }\n \n+    /// Returns a union of both EnumSets.\n     pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits | e.bits}\n     }\n \n+    /// Add an enum to an EnumSet\n     pub fn add(&mut self, e: E) {\n         self.bits |= bit(e);\n     }\n \n+    /// Returns true if an EnumSet contains a given enum\n     pub fn contains_elem(&self, e: E) -> bool {\n         (self.bits & bit(e)) != 0\n     }\n \n-    pub fn each(&self, f: &fn(E) -> bool) -> bool {\n-        let mut bits = self.bits;\n-        let mut index = 0;\n-        while bits != 0 {\n-            if (bits & 1) != 0 {\n-                let e = CLike::from_uint(index);\n-                if !f(e) {\n-                    return false;\n-                }\n-            }\n-            index += 1;\n-            bits >>= 1;\n-        }\n-        return true;\n-    }\n-\n+    /// Returns an iterator over an EnumSet\n     pub fn iter(&self) -> EnumSetIterator<E> {\n         EnumSetIterator::new(self.bits)\n     }\n@@ -98,6 +95,7 @@ impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     }\n }\n \n+/// An iterator over an EnumSet\n pub struct EnumSetIterator<E> {\n     priv index: uint,\n     priv bits: uint,\n@@ -136,7 +134,7 @@ mod test {\n \n     use std::cast;\n \n-    use util::enum_set::*;\n+    use enum_set::*;\n \n     #[deriving(Eq)]\n     enum Foo {\n@@ -236,7 +234,7 @@ mod test {\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n-    // iter / each\n+    // iter\n \n     #[test]\n     fn test_iterator() {\n@@ -262,34 +260,6 @@ mod test {\n         assert_eq!(~[A,B,C], elems)\n     }\n \n-    #[test]\n-    fn test_each() {\n-        let mut e1: EnumSet<Foo> = EnumSet::empty();\n-\n-        assert_eq!(~[], collect(e1))\n-\n-        e1.add(A);\n-        assert_eq!(~[A], collect(e1))\n-\n-        e1.add(C);\n-        assert_eq!(~[A,C], collect(e1))\n-\n-        e1.add(C);\n-        assert_eq!(~[A,C], collect(e1))\n-\n-        e1.add(B);\n-        assert_eq!(~[A,B,C], collect(e1))\n-    }\n-\n-    fn collect(e: EnumSet<Foo>) -> ~[Foo] {\n-        let mut elems = ~[];\n-        e.each(|elem| {\n-           elems.push(elem);\n-           true\n-        });\n-        elems\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // operators\n ", "previous_filename": "src/librustc/util/enum_set.rs"}, {"sha": "58929778a59e20f6afb11105979894b771755207", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -91,6 +91,7 @@ pub mod par;\n pub mod base64;\n pub mod rl;\n pub mod workcache;\n+pub mod enum_set;\n #[path=\"num/bigint.rs\"]\n pub mod bigint;\n #[path=\"num/rational.rs\"]"}, {"sha": "7a36b25eac57a53b32bb877c21e69bb60e97c109", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -526,8 +526,8 @@ mod test {\n \n         do input_vec_state(filenames) |line, state| {\n             let nums: ~[&str] = line.split_iter(' ').collect();\n-            let file_num = uint::from_str(nums[0]).get();\n-            let line_num = uint::from_str(nums[1]).get();\n+            let file_num = uint::from_str(nums[0]).unwrap();\n+            let line_num = uint::from_str(nums[1]).unwrap();\n             assert_eq!(line_num, state.line_num_file);\n             assert_eq!(file_num * 3 + line_num, state.line_num);\n             true"}, {"sha": "15aac8ef47c9e660dd59ac98ab0e947f0951b1c9", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -196,7 +196,7 @@ fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n  * The type returned when the command line does not conform to the\n  * expected format. Pass this value to <fail_str> to get an error message.\n  */\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, ToStr)]\n pub enum Fail_ {\n     ArgumentMissing(~str),\n     UnrecognizedOption(~str),\n@@ -288,7 +288,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                       None => {\n                         let arg_follows =\n                             last_valid_opt_id.is_some() &&\n-                            match opts[last_valid_opt_id.get()]\n+                            match opts[last_valid_opt_id.unwrap()]\n                               .hasarg {\n \n                               Yes | Maybe => true,\n@@ -322,15 +322,15 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                   }\n                   Maybe => {\n                     if !i_arg.is_none() {\n-                        vals[optid].push(Val((i_arg.clone()).get()));\n+                        vals[optid].push(Val((i_arg.clone()).unwrap()));\n                     } else if name_pos < names.len() ||\n                                   i + 1 == l || is_arg(args[i + 1]) {\n                         vals[optid].push(Given);\n                     } else { i += 1; vals[optid].push(Val(args[i].clone())); }\n                   }\n                   Yes => {\n                     if !i_arg.is_none() {\n-                        vals[optid].push(Val(i_arg.clone().get()));\n+                        vals[optid].push(Val(i_arg.clone().unwrap()));\n                     } else if i + 1 == l {\n                         return Err(ArgumentMissing(name_str(nm)));\n                     } else { i += 1; vals[optid].push(Val(args[i].clone())); }"}, {"sha": "ec9cb902d3d29125229303677e178e4622145903", "filename": "src/libextra/json.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -26,7 +26,6 @@ use std::to_str;\n \n use serialize::Encodable;\n use serialize;\n-use sort::Sort;\n use treemap::TreeMap;\n \n /// Represents a json value\n@@ -1152,23 +1151,7 @@ impl Ord for Json {\n             Object(ref d0) => {\n                 match *other {\n                     Number(_) | String(_) | Boolean(_) | List(_) => false,\n-                    Object(ref d1) => {\n-                        let mut d0_flat = ~[];\n-                        let mut d1_flat = ~[];\n-\n-                        // FIXME #4430: this is horribly inefficient...\n-                        for (k, v) in d0.iter() {\n-                             d0_flat.push((@(*k).clone(), @(*v).clone()));\n-                        }\n-                        d0_flat.qsort();\n-\n-                        for (k, v) in d1.iter() {\n-                            d1_flat.push((@(*k).clone(), @(*v).clone()));\n-                        }\n-                        d1_flat.qsort();\n-\n-                        d0_flat < d1_flat\n-                    }\n+                    Object(ref d1) => d0 < d1,\n                     Null => true\n                 }\n             }"}, {"sha": "bced00902c95f5abdcc62dee20adb3b42f14d372", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -1510,11 +1510,11 @@ mod biguint_tests {\n \n     #[test]\n     fn test_is_even() {\n-        assert!(FromStr::from_str::<BigUint>(\"1\").get().is_odd());\n-        assert!(FromStr::from_str::<BigUint>(\"2\").get().is_even());\n-        assert!(FromStr::from_str::<BigUint>(\"1000\").get().is_even());\n-        assert!(FromStr::from_str::<BigUint>(\"1000000000000000000000\").get().is_even());\n-        assert!(FromStr::from_str::<BigUint>(\"1000000000000000000001\").get().is_odd());\n+        assert!(FromStr::from_str::<BigUint>(\"1\").unwrap().is_odd());\n+        assert!(FromStr::from_str::<BigUint>(\"2\").unwrap().is_even());\n+        assert!(FromStr::from_str::<BigUint>(\"1000\").unwrap().is_even());\n+        assert!(FromStr::from_str::<BigUint>(\"1000000000000000000000\").unwrap().is_even());\n+        assert!(FromStr::from_str::<BigUint>(\"1000000000000000000001\").unwrap().is_odd());\n         assert!((BigUint::from_uint(1) << 64).is_even());\n         assert!(((BigUint::from_uint(1) << 64) + BigUint::from_uint(1)).is_odd());\n     }\n@@ -1595,7 +1595,7 @@ mod biguint_tests {\n             let &(ref n, ref rs) = num_pair;\n             for str_pair in rs.iter() {\n                 let &(ref radix, ref str) = str_pair;\n-                assert_eq!(n, &FromStrRadix::from_str_radix(*str, *radix).get());\n+                assert_eq!(n, &FromStrRadix::from_str_radix(*str, *radix).unwrap());\n             }\n         }\n "}, {"sha": "9833bd5d1cbf2cebe758fe7213832681d2bba76c", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -437,12 +437,12 @@ mod tests {\n         assert_eq!(deq.len(), 3);\n         deq.push_back(d.clone());\n         assert_eq!(deq.len(), 4);\n-        assert_eq!((*deq.front().get()).clone(), b.clone());\n-        assert_eq!((*deq.back().get()).clone(), d.clone());\n-        assert_eq!(deq.pop_front().get(), b.clone());\n-        assert_eq!(deq.pop_back().get(), d.clone());\n-        assert_eq!(deq.pop_back().get(), c.clone());\n-        assert_eq!(deq.pop_back().get(), a.clone());\n+        assert_eq!((*deq.front().unwrap()).clone(), b.clone());\n+        assert_eq!((*deq.back().unwrap()).clone(), d.clone());\n+        assert_eq!(deq.pop_front().unwrap(), b.clone());\n+        assert_eq!(deq.pop_back().unwrap(), d.clone());\n+        assert_eq!(deq.pop_back().unwrap(), c.clone());\n+        assert_eq!(deq.pop_back().unwrap(), a.clone());\n         assert_eq!(deq.len(), 0);\n         deq.push_back(c.clone());\n         assert_eq!(deq.len(), 1);"}, {"sha": "b0f89e219d8d8aa81d06240a04aaa853dae5e0b0", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -386,8 +386,8 @@ fn test_spec_order() {\n               \"1.0.0\"];\n     let mut i = 1;\n     while i < vs.len() {\n-        let a = parse(vs[i-1]).get();\n-        let b = parse(vs[i]).get();\n+        let a = parse(vs[i-1]).unwrap();\n+        let b = parse(vs[i]).unwrap();\n         assert!(a < b);\n         i += 1;\n     }"}, {"sha": "3f62317eb8908ca7b083f91b7edfee1e0b08af3c", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -366,9 +366,9 @@ mod test_map {\n         map.update_with_key(3, 2, addMoreToCount);\n \n         // check the total counts\n-        assert_eq!(map.find(&3).get(), &10);\n-        assert_eq!(map.find(&5).get(), &3);\n-        assert_eq!(map.find(&9).get(), &1);\n+        assert_eq!(map.find(&3).unwrap(), &10);\n+        assert_eq!(map.find(&5).unwrap(), &3);\n+        assert_eq!(map.find(&9).unwrap(), &1);\n \n         // sadly, no sevens were counted\n         assert!(map.find(&7).is_none());"}, {"sha": "e87be1462267468dc8cc3b6772c41b191da6895e", "filename": "src/libextra/test.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -247,9 +247,8 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n     let ratchet_metrics = getopts::opt_maybe_str(&matches, \"ratchet-metrics\");\n     let ratchet_metrics = ratchet_metrics.map(|s| Path(*s));\n \n-    let ratchet_noise_percent =\n-        getopts::opt_maybe_str(&matches, \"ratchet-noise-percent\");\n-    let ratchet_noise_percent = ratchet_noise_percent.map(|s| f64::from_str(*s).get());\n+    let ratchet_noise_percent = getopts::opt_maybe_str(&matches, \"ratchet-noise-percent\");\n+    let ratchet_noise_percent = ratchet_noise_percent.map(|s| f64::from_str(*s).unwrap());\n \n     let save_metrics = getopts::opt_maybe_str(&matches, \"save-metrics\");\n     let save_metrics = save_metrics.map(|s| Path(*s));\n@@ -631,8 +630,8 @@ fn should_sort_failures_before_printing_them() {\n         st.write_failures();\n     };\n \n-    let apos = s.find_str(\"a\").get();\n-    let bpos = s.find_str(\"b\").get();\n+    let apos = s.find_str(\"a\").unwrap();\n+    let bpos = s.find_str(\"b\").unwrap();\n     assert!(apos < bpos);\n }\n \n@@ -868,7 +867,7 @@ impl MetricMap {\n     pub fn load(p: &Path) -> MetricMap {\n         assert!(os::path_exists(p));\n         let f = io::file_reader(p).unwrap();\n-        let mut decoder = json::Decoder(json::from_reader(f).get());\n+        let mut decoder = json::Decoder(json::from_reader(f).unwrap());\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n \n@@ -1207,7 +1206,7 @@ mod tests {\n           either::Left(o) => o,\n           _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n-        assert!(\"filter\" == opts.filter.clone().get());\n+        assert!(\"filter\" == opts.filter.clone().unwrap());\n     }\n \n     #[test]\n@@ -1346,28 +1345,28 @@ mod tests {\n \n         let diff1 = m2.compare_to_old(&m1, None);\n \n-        assert_eq!(*(diff1.find(&~\"in-both-noise\").get()), LikelyNoise);\n-        assert_eq!(*(diff1.find(&~\"in-first-noise\").get()), MetricRemoved);\n-        assert_eq!(*(diff1.find(&~\"in-second-noise\").get()), MetricAdded);\n-        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-but-regressed\").get()),\n+        assert_eq!(*(diff1.find(&~\"in-both-noise\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.find(&~\"in-first-noise\").unwrap()), MetricRemoved);\n+        assert_eq!(*(diff1.find(&~\"in-second-noise\").unwrap()), MetricAdded);\n+        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-but-regressed\").unwrap()),\n                    Regression(100.0));\n-        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-and-improved\").get()),\n+        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-and-improved\").unwrap()),\n                    Improvement(50.0));\n-        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-but-regressed\").get()),\n+        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-but-regressed\").unwrap()),\n                    Regression(50.0));\n-        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-and-improved\").get()),\n+        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-and-improved\").unwrap()),\n                    Improvement(100.0));\n         assert_eq!(diff1.len(), 7);\n \n         let diff2 = m2.compare_to_old(&m1, Some(200.0));\n \n-        assert_eq!(*(diff2.find(&~\"in-both-noise\").get()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"in-first-noise\").get()), MetricRemoved);\n-        assert_eq!(*(diff2.find(&~\"in-second-noise\").get()), MetricAdded);\n-        assert_eq!(*(diff2.find(&~\"in-both-want-downwards-but-regressed\").get()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"in-both-want-downwards-and-improved\").get()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"in-both-want-upwards-but-regressed\").get()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"in-both-want-upwards-and-improved\").get()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"in-both-noise\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"in-first-noise\").unwrap()), MetricRemoved);\n+        assert_eq!(*(diff2.find(&~\"in-second-noise\").unwrap()), MetricAdded);\n+        assert_eq!(*(diff2.find(&~\"in-both-want-downwards-but-regressed\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"in-both-want-downwards-and-improved\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"in-both-want-upwards-but-regressed\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"in-both-want-upwards-and-improved\").unwrap()), LikelyNoise);\n         assert_eq!(diff2.len(), 7);\n     }\n \n@@ -1391,28 +1390,28 @@ mod tests {\n         let (diff1, ok1) = m2.ratchet(&pth, None);\n         assert_eq!(ok1, false);\n         assert_eq!(diff1.len(), 2);\n-        assert_eq!(*(diff1.find(&~\"runtime\").get()), Regression(10.0));\n-        assert_eq!(*(diff1.find(&~\"throughput\").get()), LikelyNoise);\n+        assert_eq!(*(diff1.find(&~\"runtime\").unwrap()), Regression(10.0));\n+        assert_eq!(*(diff1.find(&~\"throughput\").unwrap()), LikelyNoise);\n \n         // Check that it was not rewritten.\n         let m3 = MetricMap::load(&pth);\n         assert_eq!(m3.len(), 2);\n-        assert_eq!(*(m3.find(&~\"runtime\").get()), Metric { value: 1000.0, noise: 2.0 });\n-        assert_eq!(*(m3.find(&~\"throughput\").get()), Metric { value: 50.0, noise: 2.0 });\n+        assert_eq!(*(m3.find(&~\"runtime\").unwrap()), Metric { value: 1000.0, noise: 2.0 });\n+        assert_eq!(*(m3.find(&~\"throughput\").unwrap()), Metric { value: 50.0, noise: 2.0 });\n \n         // Ask for a ratchet with an explicit noise-percentage override,\n         // that should advance.\n         let (diff2, ok2) = m2.ratchet(&pth, Some(10.0));\n         assert_eq!(ok2, true);\n         assert_eq!(diff2.len(), 2);\n-        assert_eq!(*(diff2.find(&~\"runtime\").get()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"throughput\").get()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"runtime\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"throughput\").unwrap()), LikelyNoise);\n \n         // Check that it was rewritten.\n         let m4 = MetricMap::load(&pth);\n         assert_eq!(m4.len(), 2);\n-        assert_eq!(*(m4.find(&~\"runtime\").get()), Metric { value: 1100.0, noise: 2.0 });\n-        assert_eq!(*(m4.find(&~\"throughput\").get()), Metric { value: 50.0, noise: 2.0 });\n+        assert_eq!(*(m4.find(&~\"runtime\").unwrap()), Metric { value: 1100.0, noise: 2.0 });\n+        assert_eq!(*(m4.find(&~\"throughput\").unwrap()), Metric { value: 50.0, noise: 2.0 });\n \n         os::remove_dir_recursive(&dpth);\n     }"}, {"sha": "581bdf2a294dbd6e1f1562b7492a5ba362e60f06", "filename": "src/libextra/url.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -134,7 +134,7 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n             match rdr.read_char() {\n               '%' => {\n                 let bytes = rdr.read_bytes(2u);\n-                let ch = uint::parse_bytes(bytes, 16u).get() as char;\n+                let ch = uint::parse_bytes(bytes, 16u).unwrap() as char;\n \n                 if full_url {\n                     // Only decode some characters:\n@@ -257,7 +257,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n                     let ch = match ch {\n                         '%' => {\n                             let bytes = rdr.read_bytes(2u);\n-                            uint::parse_bytes(bytes, 16u).get() as char\n+                            uint::parse_bytes(bytes, 16u).unwrap() as char\n                         }\n                         '+' => ' ',\n                         ch => ch"}, {"sha": "3dc02db8e41a2765f5f5dd20f71a8f5285dbf220", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -915,7 +915,7 @@ pub fn link_args(sess: Session,\n         }\n         let dir = cratepath.dirname();\n         if dir != ~\"\" { args.push(~\"-L\" + dir); }\n-        let libarg = unlib(sess.targ_cfg, cratepath.filestem().get());\n+        let libarg = unlib(sess.targ_cfg, cratepath.filestem().unwrap());\n         args.push(~\"-l\" + libarg);\n     }\n \n@@ -953,7 +953,7 @@ pub fn link_args(sess: Session,\n         // be rpathed\n         if sess.targ_cfg.os == session::os_macos {\n             args.push(~\"-Wl,-install_name,@rpath/\"\n-                      + output.filename().get());\n+                      + output.filename().unwrap());\n         }\n     }\n "}, {"sha": "854d11fd3503599e030e2d33d8f8a9dbd36ceb21", "filename": "src/librustc/back/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -320,23 +320,23 @@ fn passes_exist() {\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n-            unsafe { llvm::LLVMDestroyPass(pass.get()) }\n+            unsafe { llvm::LLVMDestroyPass(pass.unwrap()) }\n         }\n     }\n     for &(name,_) in transform_passes.iter() {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n-            unsafe { llvm::LLVMDestroyPass(pass.get()) }\n+            unsafe { llvm::LLVMDestroyPass(pass.unwrap()) }\n         }\n     }\n     for &(name,_) in utility_passes.iter() {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n-            unsafe { llvm::LLVMDestroyPass(pass.get()) }\n+            unsafe { llvm::LLVMDestroyPass(pass.unwrap()) }\n         }\n     }\n "}, {"sha": "2c642d54253b6b79c4cf28d142ab5de3653d8042", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -408,19 +408,21 @@ pub fn stop_after_phase_5(sess: Session) -> bool {\n #[fixed_stack_segment]\n pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n                      outdir: &Option<Path>, output: &Option<Path>) {\n-    let outputs = build_output_filenames(input, outdir, output, [], sess);\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let trans = {\n+    let (outputs, trans) = {\n         let expanded_crate = {\n             let crate = phase_1_parse_input(sess, cfg.clone(), input);\n             if stop_after_phase_1(sess) { return; }\n             phase_2_configure_and_expand(sess, cfg, crate)\n         };\n         let analysis = phase_3_run_analysis_passes(sess, expanded_crate);\n         if stop_after_phase_3(sess) { return; }\n-        phase_4_translate_to_llvm(sess, expanded_crate, &analysis, outputs)\n+        let outputs = build_output_filenames(input, outdir, output, [], sess);\n+        let trans = phase_4_translate_to_llvm(sess, expanded_crate,\n+                                              &analysis, outputs);\n+        (outputs, trans)\n     };\n     phase_5_run_llvm_passes(sess, &trans, outputs);\n     if stop_after_phase_5(sess) { return; }\n@@ -922,7 +924,7 @@ pub fn build_output_filenames(input: &input,\n           };\n \n           let mut stem = match *input {\n-              file_input(ref ifile) => (*ifile).filestem().get().to_managed(),\n+              file_input(ref ifile) => (*ifile).filestem().unwrap().to_managed(),\n               str_input(_) => @\"rust_out\"\n           };\n \n@@ -957,10 +959,7 @@ pub fn build_output_filenames(input: &input,\n         };\n \n         if *sess.building_library {\n-            // FIXME (#2401): We might want to warn here; we're actually not\n-            // going to respect the user's choice of library name when it\n-            // comes time to link, we'll be linking to\n-            // lib<basename>-<hash>-<version>.so no matter what.\n+            sess.warn(\"ignoring specified output filename for library.\");\n         }\n \n         if *odir != None {"}, {"sha": "d2d2a8b4be99d984f4c06c04f6b80ef3598a0418", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -308,7 +308,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n             #[main];\n             extra::test::test_main_static(::std::os::args(), TESTS);\n         }\n-    )).get();\n+    )).unwrap();\n \n     let testmod = ast::_mod {\n         view_items: view_items,\n@@ -366,7 +366,7 @@ fn mk_tests(cx: &TestCtxt) -> @ast::item {\n         pub static TESTS : &'static [self::extra::test::TestDescAndFn] =\n             $test_descs\n         ;\n-    )).get()\n+    )).unwrap()\n }\n \n fn is_extra(cx: &TestCtxt) -> bool {"}, {"sha": "ffd79433b76930fe7186c138a71fdaaed995436a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -413,15 +413,14 @@ fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n }\n \n fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: &ty::ParamBounds) {\n-    do bs.builtin_bounds.each |bound| {\n+    for bound in bs.builtin_bounds.iter() {\n         match bound {\n             ty::BoundSend => w.write_char('S'),\n             ty::BoundFreeze => w.write_char('K'),\n             ty::BoundStatic => w.write_char('O'),\n             ty::BoundSized => w.write_char('Z'),\n         }\n-        true\n-    };\n+    }\n \n     for &tp in bs.trait_bounds.iter() {\n         w.write_char('I');"}, {"sha": "b909f70440a8258031011ac11d0bf8024a2d4eda", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -328,7 +328,7 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n \n     match *ii {\n         //hack: we're not dropping items\n-        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).get()),\n+        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).unwrap()),\n         ast::ii_method(d, is_provided, m) =>\n           ast::ii_method(d, is_provided, fld.fold_method(m)),\n         ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i))\n@@ -350,7 +350,7 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n     });\n \n     match ii {\n-        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).get()),\n+        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).unwrap()),\n         ast::ii_method(d, is_provided, m) =>\n           ast::ii_method(xcx.tr_def_id(d), is_provided, fld.fold_method(m)),\n         ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i)),\n@@ -1275,7 +1275,7 @@ fn mk_ctxt() -> @fake_ext_ctxt {\n fn roundtrip(in_item: Option<@ast::item>) {\n     use std::io;\n \n-    let in_item = in_item.get();\n+    let in_item = in_item.unwrap();\n     let bytes = do io::with_bytes_writer |wr| {\n         let mut ebml_w = writer::Encoder(wr);\n         encode_item_ast(&mut ebml_w, in_item);\n@@ -1321,13 +1321,13 @@ fn test_simplification() {\n             fn eq_int(a: int, b: int) -> bool { a == b }\n             return alist {eq_fn: eq_int, data: ~[]};\n         }\n-    ).get());\n+    ).unwrap());\n     let item_out = simplify_ast(&item_in);\n     let item_exp = ast::ii_item(quote_item!(\n         fn new_int_alist<B>() -> alist<int, B> {\n             return alist {eq_fn: eq_int, data: ~[]};\n         }\n-    ).get());\n+    ).unwrap());\n     match (item_out, item_exp) {\n       (ast::ii_item(item_out), ast::ii_item(item_exp)) => {\n         assert!(pprust::item_to_str(item_out,"}, {"sha": "c3bb2000447f7fe6ae8f17694282738d72753b04", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -307,7 +307,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         // if they cannot already have been assigned\n         if self.is_local_variable(cmt) {\n             assert!(cmt.mutbl.is_immutable()); // no \"const\" locals\n-            let lp = opt_loan_path(cmt).get();\n+            let lp = opt_loan_path(cmt).unwrap();\n             do self.move_data.each_assignment_of(expr.id, lp) |assign| {\n                 self.bccx.report_reassigned_immutable_variable(\n                     expr.span,"}, {"sha": "767c2b4ee2ed75ca0de10e269d49b1bdcd54e79b", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -225,7 +225,7 @@ impl CFGBuilder {\n                 // Note that `break` and `loop` statements\n                 // may cause additional edges.\n \n-                // NOTE: Is the condition considered part of the loop?\n+                // Is the condition considered part of the loop?\n                 let loopback = self.add_dummy_node([pred]);           // 1\n                 let cond_exit = self.expr(cond, loopback);            // 2\n                 let expr_exit = self.add_node(expr.id, [cond_exit]);  // 3"}, {"sha": "cbd1d3cd9ad81ee4cdf05c982ebb1d2827f06ea4", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -52,7 +52,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: &Crate) {\n               }\n               expr_again(_) => {\n                 if !cx.in_loop {\n-                    tcx.sess.span_err(e.span, \"`again` outside of loop\");\n+                    tcx.sess.span_err(e.span, \"`loop` outside of loop\");\n                 }\n               }\n               expr_ret(oe) => {"}, {"sha": "1b420b9c06a55b60a758d3dfb6f76b311573ef6f", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -109,7 +109,7 @@ pub fn check_arms(cx: &MatchCheckCtxt, arms: &[arm]) {\n             let pat_matches_nan: &fn(@pat) -> bool = |p| {\n                 match cx.tcx.def_map.find(&p.id) {\n                     Some(&def_static(did, false)) => {\n-                        let const_expr = lookup_const_by_id(cx.tcx, did).get();\n+                        let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                         match eval_const_expr(cx.tcx, const_expr) {\n                             const_float(f) if f.is_NaN() => true,\n                             _ => false\n@@ -304,7 +304,7 @@ pub fn is_useful_specialized(cx: &MatchCheckCtxt,\n                           -> useful {\n     let ms = m.iter().filter_map(|r| specialize(cx, *r, &ctor, arity, lty)).collect::<matrix>();\n     let could_be_useful = is_useful(\n-        cx, &ms, specialize(cx, v, &ctor, arity, lty).get());\n+        cx, &ms, specialize(cx, v, &ctor, arity, lty).unwrap());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n       ref u => *u,\n@@ -319,7 +319,7 @@ pub fn pat_ctor_id(cx: &MatchCheckCtxt, p: @pat) -> Option<ctor> {\n         match cx.tcx.def_map.find(&pat.id) {\n           Some(&def_variant(_, id)) => Some(variant(id)),\n           Some(&def_static(did, false)) => {\n-            let const_expr = lookup_const_by_id(cx.tcx, did).get();\n+            let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n             Some(val(eval_const_expr(cx.tcx, const_expr)))\n           }\n           _ => None\n@@ -515,7 +515,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                     }\n                     Some(&def_static(did, _)) => {\n                         let const_expr =\n-                            lookup_const_by_id(cx.tcx, did).get();\n+                            lookup_const_by_id(cx.tcx, did).unwrap();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n                         let match_ = match *ctor_id {\n                             val(ref v) => {\n@@ -565,7 +565,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                 match cx.tcx.def_map.get_copy(&pat_id) {\n                     def_static(did, _) => {\n                         let const_expr =\n-                            lookup_const_by_id(cx.tcx, did).get();\n+                            lookup_const_by_id(cx.tcx, did).unwrap();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n                         let match_ = match *ctor_id {\n                             val(ref v) =>\n@@ -867,7 +867,7 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                 \"cannot bind by-move and by-ref \\\n                  in the same pattern\");\n             tcx.sess.span_note(\n-                by_ref_span.get(),\n+                by_ref_span.unwrap(),\n                 \"by-ref binding occurs here\");\n         }\n     };"}, {"sha": "77e81709a03d73370f51043a5a45ba9bc08840c4", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -466,9 +466,9 @@ pub fn lit_to_const(lit: &lit) -> const_val {\n       lit_int(n, _) => const_int(n),\n       lit_uint(n, _) => const_uint(n),\n       lit_int_unsuffixed(n) => const_int(n),\n-      lit_float(n, _) => const_float(float::from_str(n).get() as f64),\n+      lit_float(n, _) => const_float(float::from_str(n).unwrap() as f64),\n       lit_float_unsuffixed(n) =>\n-        const_float(float::from_str(n).get() as f64),\n+        const_float(float::from_str(n).unwrap() as f64),\n       lit_nil => const_int(0i64),\n       lit_bool(b) => const_bool(b)\n     }"}, {"sha": "84eb371d7b34ac49a51b99bbde139804bd918fbc", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -338,12 +338,11 @@ pub fn check_builtin_bounds(cx: Context, ty: ty::t, bounds: ty::BuiltinBounds,\n {\n     let kind = ty::type_contents(cx.tcx, ty);\n     let mut missing = ty::EmptyBuiltinBounds();\n-    do bounds.each |bound| {\n+    for bound in bounds.iter() {\n         if !kind.meets_bound(cx.tcx, bound) {\n             missing.add(bound);\n         }\n-        true\n-    };\n+    }\n     if !missing.is_empty() {\n         any_missing(missing);\n     }"}, {"sha": "9ffeb99ac3559bf7bf82810e3b7abba8579173c4", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -225,7 +225,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n         // the default implementation.\n         // Having to do this this is really unfortunate.\n         let method_id = ty::method(tcx, method_id).provided_source\n-            .get_or_default(method_id);\n+            .unwrap_or_default(method_id);\n \n         if method_id.crate == LOCAL_CRATE {\n             let is_private = method_is_private(span, method_id.node);"}, {"sha": "625dcd5d9cc49d1a5adb75fea9bd225e150c1cff", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -1726,7 +1726,7 @@ impl Resolver {\n         let mut modules = HashMap::new();\n \n         // Create all the items reachable by paths.\n-        do each_path(self.session.cstore, root.def_id.get().crate)\n+        do each_path(self.session.cstore, root.def_id.unwrap().crate)\n                 |path_string, def_like, visibility| {\n \n             debug!(\"(building reduced graph for external crate) found path \\\n@@ -2350,7 +2350,7 @@ impl Resolver {\n         match type_result {\n             BoundResult(target_module, name_bindings) => {\n                 debug!(\"(resolving single import) found type target: %?\",\n-                        name_bindings.type_def.get().type_def);\n+                        name_bindings.type_def.unwrap().type_def);\n                 import_resolution.type_target =\n                     Some(Target(target_module, name_bindings));\n                 import_resolution.type_id = directive.id;\n@@ -3097,7 +3097,7 @@ impl Resolver {\n         let imports: &mut ~[@ImportDirective] = &mut *module_.imports;\n         let import_count = imports.len();\n         if index != import_count {\n-            let sn = self.session.codemap.span_to_snippet(imports[index].span);\n+            let sn = self.session.codemap.span_to_snippet(imports[index].span).unwrap();\n             if sn.contains(\"::\") {\n                 self.session.span_err(imports[index].span, \"unresolved import\");\n             } else {"}, {"sha": "9a0dc5f036c76b701fe192d9724b68559b6539e6", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -171,6 +171,7 @@ use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::ty;\n use util::common::indenter;\n+use util::ppaux::{Repr, vec_map_to_str};\n \n use std::hashmap::HashMap;\n use std::vec;\n@@ -179,7 +180,6 @@ use syntax::ast::ident;\n use syntax::ast_util::path_to_ident;\n use syntax::ast_util;\n use syntax::codemap::{span, dummy_sp};\n-use syntax::print::pprust::pat_to_str;\n \n // An option identifying a literal: either a unit-like struct or an\n // expression.\n@@ -210,7 +210,7 @@ pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n                         ExprLit(existing_a_expr) => a_expr = existing_a_expr,\n                             ConstLit(a_const) => {\n                                 let e = const_eval::lookup_const_by_id(tcx, a_const);\n-                                a_expr = e.get();\n+                                a_expr = e.unwrap();\n                             }\n                         UnitLikeStructLit(_) => {\n                             fail!(\"UnitLikeStructLit should have been handled \\\n@@ -223,7 +223,7 @@ pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n                         ExprLit(existing_b_expr) => b_expr = existing_b_expr,\n                             ConstLit(b_const) => {\n                                 let e = const_eval::lookup_const_by_id(tcx, b_const);\n-                                b_expr = e.get();\n+                                b_expr = e.unwrap();\n                             }\n                         UnitLikeStructLit(_) => {\n                             fail!(\"UnitLikeStructLit should have been handled \\\n@@ -353,19 +353,17 @@ pub struct Match<'self> {\n     data: ArmData<'self>\n }\n \n-pub fn match_to_str(bcx: @mut Block, m: &Match) -> ~str {\n-    if bcx.sess().verbose() {\n-        // for many programs, this just take too long to serialize\n-        fmt!(\"%?\", m.pats.map(|p| pat_to_str(*p, bcx.sess().intr())))\n-    } else {\n-        fmt!(\"%u pats\", m.pats.len())\n+impl<'self> Repr for Match<'self> {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        if tcx.sess.verbose() {\n+            // for many programs, this just take too long to serialize\n+            self.pats.repr(tcx)\n+        } else {\n+            fmt!(\"%u pats\", self.pats.len())\n+        }\n     }\n }\n \n-pub fn matches_to_str(bcx: @mut Block, m: &[Match]) -> ~str {\n-    fmt!(\"%?\", m.map(|n| match_to_str(bcx, n)))\n-}\n-\n pub fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     for br in m.iter() {\n         match br.pats[col].node {\n@@ -381,9 +379,9 @@ pub fn expand_nested_bindings<'r>(bcx: @mut Block,\n                                   col: uint,\n                                   val: ValueRef)\n                               -> ~[Match<'r>] {\n-    debug!(\"expand_nested_bindings(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"expand_nested_bindings(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -416,7 +414,7 @@ pub fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n         bcx.sess().span_bug(\n             p.span,\n             fmt!(\"Expected an identifier pattern but found p: %s\",\n-                 pat_to_str(p, bcx.sess().intr())));\n+                 p.repr(bcx.tcx())));\n     }\n }\n \n@@ -429,9 +427,9 @@ pub fn enter_match<'r>(bcx: @mut Block,\n                        val: ValueRef,\n                        e: enter_pat)\n                     -> ~[Match<'r>] {\n-    debug!(\"enter_match(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_match(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -467,7 +465,7 @@ pub fn enter_match<'r>(bcx: @mut Block,\n         }\n     }\n \n-    debug!(\"result=%s\", matches_to_str(bcx, result));\n+    debug!(\"result=%s\", result.repr(bcx.tcx()));\n \n     return result;\n }\n@@ -478,9 +476,9 @@ pub fn enter_default<'r>(bcx: @mut Block,\n                          col: uint,\n                          val: ValueRef)\n                       -> ~[Match<'r>] {\n-    debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -525,9 +523,9 @@ pub fn enter_opt<'r>(bcx: @mut Block,\n                      variant_size: uint,\n                      val: ValueRef)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_opt(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_opt(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -637,9 +635,9 @@ pub fn enter_rec_or_struct<'r>(bcx: @mut Block,\n                                fields: &[ast::ident],\n                                val: ValueRef)\n                             -> ~[Match<'r>] {\n-    debug!(\"enter_rec_or_struct(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_rec_or_struct(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -672,9 +670,9 @@ pub fn enter_tup<'r>(bcx: @mut Block,\n                      val: ValueRef,\n                      n_elts: uint)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_tup(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_tup(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -698,9 +696,9 @@ pub fn enter_tuple_struct<'r>(bcx: @mut Block,\n                               val: ValueRef,\n                               n_elts: uint)\n                           -> ~[Match<'r>] {\n-    debug!(\"enter_tuple_struct(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_tuple_struct(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -723,9 +721,9 @@ pub fn enter_box<'r>(bcx: @mut Block,\n                      col: uint,\n                      val: ValueRef)\n                  -> ~[Match<'r>] {\n-    debug!(\"enter_box(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_box(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -750,9 +748,9 @@ pub fn enter_uniq<'r>(bcx: @mut Block,\n                       col: uint,\n                       val: ValueRef)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_uniq(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_uniq(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -777,9 +775,9 @@ pub fn enter_region<'r>(bcx: @mut Block,\n                         col: uint,\n                         val: ValueRef)\n                     -> ~[Match<'r>] {\n-    debug!(\"enter_region(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_region(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -922,7 +920,7 @@ pub fn extract_vec_elems(bcx: @mut Block,\n         }\n     };\n     if slice.is_some() {\n-        let n = slice.get();\n+        let n = slice.unwrap();\n         let slice_offset = Mul(bcx, vt.llunit_size,\n             C_int(bcx.ccx(), n as int)\n         );\n@@ -1213,11 +1211,11 @@ pub fn compile_guard(bcx: @mut Block,\n                      vals: &[ValueRef],\n                      chk: Option<mk_fail>)\n                   -> @mut Block {\n-    debug!(\"compile_guard(bcx=%s, guard_expr=%s, m=%s, vals=%?)\",\n+    debug!(\"compile_guard(bcx=%s, guard_expr=%s, m=%s, vals=%s)\",\n            bcx.to_str(),\n            bcx.expr_to_str(guard_expr),\n-           matches_to_str(bcx, m),\n-           vals.map(|v| bcx.val_to_str(*v)));\n+           m.repr(bcx.tcx()),\n+           vec_map_to_str(vals, |v| bcx.val_to_str(*v)));\n     let _indenter = indenter();\n \n     let mut bcx = bcx;\n@@ -1267,10 +1265,10 @@ pub fn compile_submatch(bcx: @mut Block,\n                         m: &[Match],\n                         vals: &[ValueRef],\n                         chk: Option<mk_fail>) {\n-    debug!(\"compile_submatch(bcx=%s, m=%s, vals=%?)\",\n+    debug!(\"compile_submatch(bcx=%s, m=%s, vals=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n-           vals.map(|v| bcx.val_to_str(*v)));\n+           m.repr(bcx.tcx()),\n+           vec_map_to_str(vals, |v| bcx.val_to_str(*v)));\n     let _indenter = indenter();\n \n     /*\n@@ -1280,7 +1278,7 @@ pub fn compile_submatch(bcx: @mut Block,\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n     if m.len() == 0u {\n-        Br(bcx, chk.get()());\n+        Br(bcx, chk.unwrap()());\n         return;\n     }\n     if m[0].pats.len() == 0u {\n@@ -1427,6 +1425,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n \n     // Decide what kind of branch we need\n     let opts = get_options(bcx, m, col);\n+    debug!(\"options=%?\", opts);\n     let mut kind = no_branch;\n     let mut test_val = val;\n     if opts.len() > 0u {\n@@ -1914,12 +1913,12 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n \n     debug!(\"bind_irrefutable_pat(bcx=%s, pat=%s, binding_mode=%?)\",\n            bcx.to_str(),\n-           pat_to_str(pat, bcx.sess().intr()),\n+           pat.repr(bcx.tcx()),\n            binding_mode);\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, fmt!(\"bind_irrefutable_pat(pat=%s)\",\n-                              pat_to_str(pat, bcx.sess().intr())));\n+                              pat.repr(bcx.tcx())));\n     }\n \n     let _indenter = indenter();"}, {"sha": "2eb9841c6c7577411454205a0a9f8c0e8bcec754", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -260,7 +260,7 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n                     most_aligned = Some(st);\n                 }\n             }\n-            let most_aligned = most_aligned.get();\n+            let most_aligned = most_aligned.unwrap();\n             let padding = largest_size - most_aligned.size;\n \n             struct_llfields(cx, most_aligned, sizing)"}, {"sha": "668aec1212af1763251d0807123a98f4dd77d551", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 22, "deletions": 30, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -1322,7 +1322,7 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n     }\n     match leave {\n       Some(target) => Br(bcx, target),\n-      None => { Resume(bcx, Load(bcx, bcx.fcx.personality.get())); }\n+      None => { Resume(bcx, Load(bcx, bcx.fcx.personality.unwrap())); }\n     }\n }\n \n@@ -1530,7 +1530,7 @@ pub fn alloca_maybe_zeroed(cx: @mut Block, ty: Type, name: &str, zero: bool) ->\n     let p = Alloca(cx, ty, name);\n     if zero {\n         let b = cx.fcx.ccx.builder();\n-        b.position_before(cx.fcx.alloca_insert_pt.get());\n+        b.position_before(cx.fcx.alloca_insert_pt.unwrap());\n         memzero(&b, p, ty);\n     }\n     p\n@@ -1576,7 +1576,7 @@ pub fn make_return_pointer(fcx: @mut FunctionContext, output_type: ty::t) -> Val\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-            let bcx = fcx.entry_bcx.get();\n+            let bcx = fcx.entry_bcx.unwrap();\n             Alloca(bcx, lloutputtype, \"__make_return_pointer\")\n         }\n     }\n@@ -1794,7 +1794,7 @@ pub fn finish_fn(fcx: @mut FunctionContext, last_bcx: @mut Block) {\n pub fn build_return_block(fcx: &FunctionContext, ret_cx: @mut Block) {\n     // Return the value if this function immediate; otherwise, return void.\n     if fcx.llretptr.is_some() && fcx.has_immediate_return_value {\n-        Ret(ret_cx, Load(ret_cx, fcx.llretptr.get()))\n+        Ret(ret_cx, Load(ret_cx, fcx.llretptr.unwrap()))\n     } else {\n         RetVoid(ret_cx)\n     }\n@@ -1844,7 +1844,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n-    let bcx_top = fcx.entry_bcx.get();\n+    let bcx_top = fcx.entry_bcx.unwrap();\n     let mut bcx = bcx_top;\n     let block_ty = node_id_type(bcx, body.id);\n \n@@ -1862,7 +1862,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     {\n         bcx = controlflow::trans_block(bcx, body, expr::Ignore);\n     } else {\n-        let dest = expr::SaveIn(fcx.llretptr.get());\n+        let dest = expr::SaveIn(fcx.llretptr.unwrap());\n         bcx = controlflow::trans_block(bcx, body, dest);\n     }\n \n@@ -2056,18 +2056,18 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n \n     let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n \n-    let bcx = fcx.entry_bcx.get();\n+    let bcx = fcx.entry_bcx.unwrap();\n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n     insert_synthetic_type_entries(bcx, fn_args, arg_tys);\n     let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n     let repr = adt::represent_type(ccx, result_ty);\n-    adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);\n+    adt::trans_start_init(bcx, repr, fcx.llretptr.unwrap(), disr);\n     for (i, fn_arg) in fn_args.iter().enumerate() {\n         let lldestptr = adt::trans_field_ptr(bcx,\n                                              repr,\n-                                             fcx.llretptr.get(),\n+                                             fcx.llretptr.unwrap(),\n                                              disr,\n                                              i);\n         let llarg = fcx.llargs.get_copy(&fn_arg.pat.id);\n@@ -2219,23 +2219,14 @@ pub fn trans_mod(ccx: @mut CrateContext, m: &ast::_mod) {\n pub fn register_fn(ccx: @mut CrateContext,\n                    sp: span,\n                    sym: ~str,\n-                   node_id: ast::NodeId)\n-                -> ValueRef {\n-    let t = ty::node_id_to_type(ccx.tcx, node_id);\n-    register_fn_full(ccx, sp, sym, node_id, t)\n-}\n-\n-pub fn register_fn_full(ccx: @mut CrateContext,\n-                        sp: span,\n-                        sym: ~str,\n-                        node_id: ast::NodeId,\n-                        node_type: ty::t)\n-                     -> ValueRef {\n+                   node_id: ast::NodeId,\n+                   node_type: ty::t)\n+                   -> ValueRef {\n     let llfty = type_of_fn_from_ty(ccx, node_type);\n-    register_fn_fuller(ccx, sp, sym, node_id, lib::llvm::CCallConv, llfty)\n+    register_fn_llvmty(ccx, sp, sym, node_id, lib::llvm::CCallConv, llfty)\n }\n \n-pub fn register_fn_fuller(ccx: @mut CrateContext,\n+pub fn register_fn_llvmty(ccx: @mut CrateContext,\n                           sp: span,\n                           sym: ~str,\n                           node_id: ast::NodeId,\n@@ -2294,7 +2285,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n         // be updated if this assertion starts to fail.\n         assert!(fcx.has_immediate_return_value);\n \n-        let bcx = fcx.entry_bcx.get();\n+        let bcx = fcx.entry_bcx.unwrap();\n         // Call main.\n         let llenvarg = unsafe {\n             let env_arg = fcx.env_arg_pos();\n@@ -2449,7 +2440,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n \n                         ast::item_fn(_, purity, _, _, _) => {\n                             let llfn = if purity != ast::extern_fn {\n-                                register_fn_full(ccx, i.span, sym, i.id, ty)\n+                                register_fn(ccx, i.span, sym, i.id, ty)\n                             } else {\n                                 foreign::register_foreign_fn(ccx, i.span, sym, i.id)\n                             };\n@@ -2499,7 +2490,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             let path = vec::append((*pth).clone(), [path_name(ni.ident)]);\n                             let sym = exported_name(ccx, path, ty, ni.attrs);\n \n-                            register_fn_full(ccx, ni.span, sym, ni.id, ty)\n+                            register_fn(ccx, ni.span, sym, ni.id, ty)\n                         }\n                         ast::foreign_item_static(*) => {\n                             let ident = token::ident_to_str(&ni.ident);\n@@ -2527,7 +2518,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n \n                             llfn = match enm.node {\n                                 ast::item_enum(_, _) => {\n-                                    register_fn_full(ccx, (*v).span, sym, id, ty)\n+                                    register_fn(ccx, (*v).span, sym, id, ty)\n                                 }\n                                 _ => fail!(\"node_variant, shouldn't happen\")\n                             };\n@@ -2551,7 +2542,8 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             let ty = ty::node_id_to_type(ccx.tcx, ctor_id);\n                             let sym = exported_name(ccx, (*struct_path).clone(), ty,\n                                                     struct_item.attrs);\n-                            let llfn = register_fn_full(ccx, struct_item.span, sym, ctor_id, ty);\n+                            let llfn = register_fn(ccx, struct_item.span,\n+                                                   sym, ctor_id, ty);\n                             set_inline_hint(llfn);\n                             llfn\n                         }\n@@ -2586,7 +2578,7 @@ pub fn register_method(ccx: @mut CrateContext,\n \n     let sym = exported_name(ccx, path, mty, m.attrs);\n \n-    let llfn = register_fn_full(ccx, m.span, sym, id, mty);\n+    let llfn = register_fn(ccx, m.span, sym, id, mty);\n     set_inline_hint_if_appr(m.attrs, llfn);\n     llfn\n }\n@@ -2782,7 +2774,7 @@ pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n     }\n \n     for key in keys.iter() {\n-        let val = *ccx.module_data.find_equiv(key).get();\n+        let val = *ccx.module_data.find_equiv(key).unwrap();\n         let s_const = C_cstr(ccx, *key);\n         let s_ptr = p2i(ccx, s_const);\n         let v_ptr = p2i(ccx, val);"}, {"sha": "c8e2a17c3b5f1bd93bc81448101c31e08a0404fb", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -319,7 +319,7 @@ pub fn Alloca(cx: @mut Block, Ty: Type, name: &str) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n-        b.position_before(cx.fcx.alloca_insert_pt.get());\n+        b.position_before(cx.fcx.alloca_insert_pt.unwrap());\n         b.alloca(Ty, name)\n     }\n }\n@@ -328,7 +328,7 @@ pub fn ArrayAlloca(cx: @mut Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n-        b.position_before(cx.fcx.alloca_insert_pt.get());\n+        b.position_before(cx.fcx.alloca_insert_pt.unwrap());\n         b.array_alloca(Ty, Val)\n     }\n }"}, {"sha": "895bea715c964e73713dcc086f491d9516cabdc6", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -169,7 +169,7 @@ impl FnType {\n             } else {\n                 Load(bcx, llretval)\n             };\n-            let llretptr = BitCast(bcx, bcx.fcx.llretptr.get(), self.ret_ty.ty.ptr_to());\n+            let llretptr = BitCast(bcx, bcx.fcx.llretptr.unwrap(), self.ret_ty.ty.ptr_to());\n             Store(bcx, llretval, llretptr);\n         }\n     }"}, {"sha": "602d33a197e29bfc536639d370372d07185a52a1", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -330,7 +330,7 @@ pub fn load_environment(fcx: @mut FunctionContext,\n         return;\n     }\n \n-    let bcx = fcx.entry_bcx.get();\n+    let bcx = fcx.entry_bcx.unwrap();\n \n     // Load a pointer to the closure data, skipping over the box header:\n     let llcdata = opaque_box_body(bcx, cdata_ty, fcx.llenv);\n@@ -443,7 +443,7 @@ pub fn trans_expr_fn(bcx: @mut Block,\n                               if is_loop_body.is_some() {\n                                   Store(bcx,\n                                         C_bool(true),\n-                                        bcx.fcx.llretptr.get());\n+                                        bcx.fcx.llretptr.unwrap());\n                               }\n                           });\n             rslt(bcx, llbox)"}, {"sha": "aa15335a6c208b4391ee9cf5498599a20020f2f9", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -252,7 +252,7 @@ impl FunctionContext {\n \n     pub fn cleanup(&mut self) {\n         unsafe {\n-            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt.get());\n+            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt.unwrap());\n         }\n         // Remove the cycle between fcx and bcx, so memory can be freed\n         self.entry_bcx = None;\n@@ -263,7 +263,7 @@ impl FunctionContext {\n             self.llreturn = Some(base::mk_return_basic_block(self.llfn));\n         }\n \n-        self.llreturn.get()\n+        self.llreturn.unwrap()\n     }\n }\n "}, {"sha": "46eb3928d595eb956d7998ebb09f762b5e2abe34", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -315,7 +315,7 @@ pub fn trans_break_cont(bcx: @mut Block,\n                     Some(bcx) => bcx,\n                         // This is a return from a loop body block\n                         None => {\n-                            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr.get());\n+                            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr.unwrap());\n                             cleanup_and_leave(bcx, None, Some(bcx.fcx.get_llreturn()));\n                             Unreachable(bcx);\n                             return bcx;\n@@ -347,7 +347,7 @@ pub fn trans_ret(bcx: @mut Block, e: Option<@ast::expr>) -> @mut Block {\n         // to false, return flag to true, and then store the value in the\n         // parent's retptr.\n         Store(bcx, C_bool(true), flagptr);\n-        Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n+        Store(bcx, C_bool(false), bcx.fcx.llretptr.unwrap());\n         expr::SaveIn(match e {\n           Some(x) => PointerCast(bcx, retptr,\n                                  type_of(bcx.ccx(), expr_ty(bcx, x)).ptr_to()),"}, {"sha": "11136627826beb20a24fc6102ed15cd786eeb20b", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -486,8 +486,8 @@ fn lexical_block_metadata(bcx: @mut Block) -> DILexicalBlock {\n         }\n     }\n \n-    let span = bcx.node_info.get().span;\n-    let id = bcx.node_info.get().id;\n+    let span = bcx.node_info.unwrap().span;\n+    let id = bcx.node_info.unwrap().id;\n \n     // Check whether we already have a cache entry for this node id\n     match dbg_cx(cx).created_blocks.find(&id) {"}, {"sha": "5153296337daed25055c7751d7d680c61abc37f5", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -149,7 +149,7 @@ fn build_shim_fn_(ccx: @mut CrateContext,\n \n     // Declare the body of the shim function:\n     let fcx = new_fn_ctxt(ccx, ~[], llshimfn, tys.fn_sig.output, None);\n-    let bcx = fcx.entry_bcx.get();\n+    let bcx = fcx.entry_bcx.unwrap();\n \n     let llargbundle = get_param(llshimfn, 0u);\n     let llargvals = arg_builder(bcx, tys, llargbundle);\n@@ -190,7 +190,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n                   ret_builder: wrap_ret_builder) {\n     let _icx = push_ctxt(\"foreign::build_wrap_fn_\");\n     let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, tys.fn_sig.output, None);\n-    let bcx = fcx.entry_bcx.get();\n+    let bcx = fcx.entry_bcx.unwrap();\n \n     // Patch up the return type if it's not immediate and we're returning via\n     // the C ABI.\n@@ -226,7 +226,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n     } else {\n         // Cast if we have to...\n         // XXX: This is ugly.\n-        let llretptr = BitCast(return_context, fcx.llretptr.get(), return_type.ptr_to());\n+        let llretptr = BitCast(return_context, fcx.llretptr.unwrap(), return_type.ptr_to());\n         Ret(return_context, Load(return_context, llretptr));\n     }\n     fcx.cleanup();\n@@ -421,7 +421,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         debug!(\"build_direct_fn(%s)\", link_name(ccx, item));\n \n         let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = fcx.entry_bcx.get();\n+        let bcx = fcx.entry_bcx.unwrap();\n         let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n         let ty = ty::lookup_item_type(ccx.tcx,\n                                       ast_util::local_def(item.id)).ty;\n@@ -431,7 +431,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         });\n         let retval = Call(bcx, llbasefn, args);\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n-            Store(bcx, retval, fcx.llretptr.get());\n+            Store(bcx, retval, fcx.llretptr.unwrap());\n         }\n         finish_fn(fcx, bcx);\n     }\n@@ -446,7 +446,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         debug!(\"build_fast_ffi_fn(%s)\", link_name(ccx, item));\n \n         let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = fcx.entry_bcx.get();\n+        let bcx = fcx.entry_bcx.unwrap();\n         let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n         set_no_inline(fcx.llfn);\n         set_fixed_stack_segment(fcx.llfn);\n@@ -458,7 +458,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         });\n         let retval = Call(bcx, llbasefn, args);\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n-            Store(bcx, retval, fcx.llretptr.get());\n+            Store(bcx, retval, fcx.llretptr.unwrap());\n         }\n         finish_fn(fcx, bcx);\n     }\n@@ -618,7 +618,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         set_fixed_stack_segment(fcx.llfn);\n     }\n \n-    let mut bcx = fcx.entry_bcx.get();\n+    let mut bcx = fcx.entry_bcx.unwrap();\n     let first_real_arg = fcx.arg_pos(0u);\n \n     let nm = ccx.sess.str_of(item.ident);\n@@ -775,7 +775,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n             let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n             if in_type_size != out_type_size {\n-                let sp = match ccx.tcx.items.get_copy(&ref_id.get()) {\n+                let sp = match ccx.tcx.items.get_copy(&ref_id.unwrap()) {\n                     ast_map::node_expr(e) => e.span,\n                     _ => fail!(\"transmute has non-expr arg\"),\n                 };\n@@ -816,7 +816,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                     // NB: Do not use a Load and Store here. This causes massive\n                     // code bloat when `transmute` is used on large structural\n                     // types.\n-                    let lldestptr = fcx.llretptr.get();\n+                    let lldestptr = fcx.llretptr.unwrap();\n                     let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n                     let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p());\n \n@@ -1157,6 +1157,6 @@ pub fn register_foreign_fn(ccx: @mut CrateContext,\n \n     let tys = shim_types(ccx, node_id);\n     do tys.fn_ty.decl_fn |fnty| {\n-        register_fn_fuller(ccx, sp, sym.take(), node_id, lib::llvm::CCallConv, fnty)\n+        register_fn_llvmty(ccx, sp, sym.take(), node_id, lib::llvm::CCallConv, fnty)\n     }\n }"}, {"sha": "a70b907f2628cc4090eb86174f16cb51a7543aed", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -312,7 +312,7 @@ pub fn call_tydesc_glue_full(bcx: @mut Block,\n     let llrawptr = if static_ti.is_none() || static_glue_fn.is_none() {\n         PointerCast(bcx, v, Type::i8p())\n     } else {\n-        let ty = static_ti.get().ty;\n+        let ty = static_ti.unwrap().ty;\n         let simpl = simplified_glue_type(ccx.tcx, field, ty);\n         if simpl != ty {\n             PointerCast(bcx, v, type_of(ccx, simpl).ptr_to())\n@@ -709,7 +709,7 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let bcx = fcx.entry_bcx.get();\n+    let bcx = fcx.entry_bcx.unwrap();\n     let rawptr0_arg = fcx.arg_pos(0u);\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, rawptr0_arg as c_uint) };\n     let bcx = helper(bcx, llrawptr0, t);"}, {"sha": "5f8837b538cdfbd8b0b9992fc47c26713c21696a", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -180,7 +180,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n             let idx = psubsts.tys.len() - num_method_ty_params;\n             let substs =\n                 (psubsts.tys.slice(0, idx) +\n-                 &[psubsts.self_ty.get()] +\n+                 &[psubsts.self_ty.unwrap()] +\n                  psubsts.tys.tailn(idx));\n             debug!(\"static default: changed substitution to %s\",\n                    substs.repr(ccx.tcx));\n@@ -245,7 +245,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       }\n       ast_map::node_variant(ref v, enum_item, _) => {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n-        let this_tv = *tvs.iter().find_(|tv| { tv.id.node == fn_id.node}).get();\n+        let this_tv = *tvs.iter().find_(|tv| { tv.id.node == fn_id.node}).unwrap();\n         let d = mk_lldecl();\n         set_inline_hint(d);\n         match v.node.kind {"}, {"sha": "e0403ac9ad7a800875bf1ba67726499031957fad", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -303,10 +303,10 @@ impl Reflector {\n                     //\n                     llvm::LLVMGetParam(llfdecl, fcx.arg_pos(0u) as c_uint)\n                 };\n-                let mut bcx = fcx.entry_bcx.get();\n+                let mut bcx = fcx.entry_bcx.unwrap();\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, repr, arg);\n-                Store(bcx, ret, fcx.llretptr.get());\n+                Store(bcx, ret, fcx.llretptr.unwrap());\n                 match fcx.llreturn {\n                     Some(llreturn) => cleanup_and_Br(bcx, bcx, llreturn),\n                     None => bcx = cleanup_block(bcx, Some(bcx.llbb))"}, {"sha": "6a382cc1a5d1cc82b6682d6fc34a32683c5509c2", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -239,7 +239,7 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n \n       ty::ty_estr(ty::vstore_slice(_)) => {\n           // This means we get a nicer name in the output\n-          cx.tn.find_type(\"str_slice\").get()\n+          cx.tn.find_type(\"str_slice\").unwrap()\n       }\n \n       ty::ty_estr(ty::vstore_fixed(n)) => {"}, {"sha": "a53bdff85f9dc2cb4903f2ef47d67b2b69969ce0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -25,14 +25,14 @@ use util::ppaux::{note_and_explain_region, bound_region_ptr_to_str};\n use util::ppaux::{trait_store_to_str, ty_to_str, vstore_to_str};\n use util::ppaux::{Repr, UserString};\n use util::common::{indenter};\n-use util::enum_set::{EnumSet, CLike};\n \n use std::cast;\n use std::cmp;\n use std::hashmap::{HashMap, HashSet};\n use std::ops;\n use std::ptr::to_unsafe_ptr;\n use std::to_bytes;\n+use std::to_str::ToStr;\n use std::u32;\n use std::vec;\n use syntax::ast::*;\n@@ -47,6 +47,7 @@ use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n use syntax::abi::AbiSet;\n use syntax;\n+use extra::enum_set::{EnumSet, CLike};\n \n pub static INITIAL_DISCRIMINANT_VALUE: uint = 0;\n \n@@ -116,15 +117,15 @@ pub struct mt {\n     mutbl: ast::mutability,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes, ToStr)]\n pub enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n     vstore_box,\n     vstore_slice(Region)\n }\n \n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable)]\n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n pub enum TraitStore {\n     BoxTraitStore,              // @Trait\n     UniqTraitStore,             // ~Trait\n@@ -350,6 +351,12 @@ pub struct t_box_ {\n enum t_opaque {}\n pub type t = *t_opaque;\n \n+impl ToStr for t {\n+    fn to_str(&self) -> ~str {\n+        ~\"*t_opaque\"\n+    }\n+}\n+\n pub fn get(t: t) -> t_box {\n     unsafe {\n         let t2: t_box = cast::transmute(t);\n@@ -410,7 +417,7 @@ pub struct param_ty {\n }\n \n /// Representation of regions:\n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable)]\n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n pub enum Region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n     /// region parameters that have yet to be replaced with actual regions\n@@ -456,13 +463,13 @@ impl Region {\n     }\n }\n \n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable)]\n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n pub struct FreeRegion {\n     scope_id: NodeId,\n     bound_region: bound_region\n }\n \n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable)]\n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n pub enum bound_region {\n     /// The self region for structs, impls (&T in a type defn or &'self T)\n     br_self,\n@@ -620,19 +627,22 @@ pub enum IntVarValue {\n     UintType(ast::uint_ty),\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, ToStr)]\n pub enum terr_vstore_kind {\n-    terr_vec, terr_str, terr_fn, terr_trait\n+    terr_vec,\n+    terr_str,\n+    terr_fn,\n+    terr_trait\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, ToStr)]\n pub struct expected_found<T> {\n     expected: T,\n     found: T\n }\n \n // Data structures used in type unification\n-#[deriving(Clone)]\n+#[deriving(Clone, ToStr)]\n pub enum type_err {\n     terr_mismatch,\n     terr_purity_mismatch(expected_found<purity>),\n@@ -674,7 +684,7 @@ pub struct ParamBounds {\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes, ToStr)]\n pub enum BuiltinBound {\n     BoundStatic,\n     BoundSend,\n@@ -725,7 +735,7 @@ pub enum InferTy {\n     FloatVar(FloatVid)\n }\n \n-#[deriving(Clone, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Encodable, Decodable, IterBytes, ToStr)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(uint, bound_region)\n@@ -2277,7 +2287,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         // This is like with typarams below, but less \"pessimistic\" and also\n         // dependent on the trait store.\n         let mut bt = TC_NONE;\n-        do (AllBuiltinBounds() - bounds).each |bound| {\n+        for bound in (AllBuiltinBounds() - bounds).iter() {\n             bt = bt + match bound {\n                 BoundStatic if bounds.contains_elem(BoundSend)\n                             => TC_NONE, // Send bound implies static bound.\n@@ -2286,8 +2296,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 BoundFreeze => TC_MUTABLE,\n                 BoundSized  => TC_NONE, // don't care if interior is sized\n             };\n-            true\n-        };\n+        }\n         st + mt + bt\n     }\n \n@@ -2298,7 +2307,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         let _i = indenter();\n \n         let mut tc = TC_ALL;\n-        do type_param_def.bounds.builtin_bounds.each |bound| {\n+        for bound in type_param_def.bounds.builtin_bounds.iter() {\n             debug!(\"tc = %s, bound = %?\", tc.to_str(), bound);\n             tc = tc - match bound {\n                 BoundStatic => TypeContents::nonstatic(cx),\n@@ -2307,8 +2316,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // The dynamic-size bit can be removed at pointer-level, etc.\n                 BoundSized => TypeContents::dynamically_sized(cx),\n             };\n-            true\n-        };\n+        }\n \n         debug!(\"result = %s\", tc.to_str());\n         return tc;"}, {"sha": "53853e4fe1a78be01dedd8e7e1256cb521214e7b", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -531,7 +531,7 @@ pub fn ty_of_arg<AC:AstConv,\n                  expected_ty: Option<ty::t>)\n                  -> ty::t {\n     match a.ty.node {\n-        ast::ty_infer if expected_ty.is_some() => expected_ty.get(),\n+        ast::ty_infer if expected_ty.is_some() => expected_ty.unwrap(),\n         ast::ty_infer => this.ty_infer(a.ty.span),\n         _ => ast_ty_to_ty(this, rscope, &a.ty),\n     }\n@@ -587,7 +587,7 @@ pub fn ty_of_method<AC:AstConv,RS:region_scope + Clone + 'static>(\n     };\n     let (a, b) = ty_of_method_or_bare_fn(\n         this, rscope, purity, AbiSet::Rust(), lifetimes, Some(&self_info), decl);\n-    (a.get(), b)\n+    (a.unwrap(), b)\n }\n \n pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Clone + 'static>(\n@@ -735,7 +735,7 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Clone + 'static>(\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n     let output_ty = match decl.output.node {\n-        ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.get(),\n+        ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.unwrap(),\n         ast::ty_infer => this.ty_infer(decl.output.span),\n         _ => ast_ty_to_ty(this, &rb, &decl.output)\n     };"}, {"sha": "7caed39060159bd2c1d321c9466a1a9b20ba5a1d", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -166,7 +166,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n                     fcx.write_error(pat.id);\n                     kind_name = \"[error]\";\n                     arg_types = (*subpats).clone()\n-                                          .get_or_default(~[])\n+                                          .unwrap_or_default(~[])\n                                           .map(|_| ty::mk_err());\n                 }\n             }\n@@ -209,7 +209,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n             fcx.write_error(pat.id);\n             kind_name = \"[error]\";\n             arg_types = (*subpats).clone()\n-                                  .get_or_default(~[])\n+                                  .unwrap_or_default(~[])\n                                   .map(|_| ty::mk_err());\n         }\n     }"}, {"sha": "e1e7d10db0abd5ba07481b5a9d505e08f8221319", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -854,7 +854,7 @@ impl<'self> LookupContext<'self> {\n                         // like &'a Self.  We then perform a\n                         // substitution which will replace Self with\n                         // @Trait.\n-                        let t = candidate.method_ty.transformed_self_ty.get();\n+                        let t = candidate.method_ty.transformed_self_ty.unwrap();\n                         ty::subst(tcx, &candidate.rcvr_substs, t)\n                     }\n                     _ => {\n@@ -863,7 +863,7 @@ impl<'self> LookupContext<'self> {\n                 }\n             }\n             _ => {\n-                let t = candidate.method_ty.transformed_self_ty.get();\n+                let t = candidate.method_ty.transformed_self_ty.unwrap();\n                 ty::subst(tcx, &candidate.rcvr_substs, t)\n             }\n         };\n@@ -922,7 +922,7 @@ impl<'self> LookupContext<'self> {\n                 tcx, @Nil, Some(transformed_self_ty), &bare_fn_ty.sig,\n                 |br| self.fcx.infcx().next_region_var(\n                     infer::BoundRegionInFnCall(self.expr.span, br)));\n-        let transformed_self_ty = opt_transformed_self_ty.get();\n+        let transformed_self_ty = opt_transformed_self_ty.unwrap();\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n             purity: bare_fn_ty.purity,"}, {"sha": "ea8a11fc7b3821b425f4ee3fac59c6927a712bb6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -365,7 +365,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                                                  bound_region: br}));\n         let opt_self_info =\n             opt_self_info.map(\n-                |si| SelfInfo {self_ty: opt_self_ty.get(), ..*si});\n+                |si| SelfInfo {self_ty: opt_self_ty.unwrap(), ..*si});\n         (isr, opt_self_info, fn_sig)\n     };\n \n@@ -2449,7 +2449,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                            expected,\n                                            |x| Some((*x).clone()));\n         let inner_ty = match expected_sty {\n-            Some(ty::ty_closure(_)) => expected.get(),\n+            Some(ty::ty_closure(_)) => expected.unwrap(),\n             _ => match expected {\n                 Some(expected_t) => {\n                     fcx.type_error_message(expr.span, |actual| {"}, {"sha": "f05388344bc7129914c230f0fa922af9dc2b8c07", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -253,7 +253,7 @@ impl Combine for Glb {\n \n             if a_r.is_some() && b_r.is_some() && only_new_vars {\n                 // Related to exactly one bound variable from each fn:\n-                return rev_lookup(this, a_isr, a_r.get());\n+                return rev_lookup(this, a_isr, a_r.unwrap());\n             } else if a_r.is_none() && b_r.is_none() {\n                 // Not related to bound variables from either fn:\n                 return r0;"}, {"sha": "b1356ffb2d5e943632dd9d6a47f0b9966bb9ba52", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -295,7 +295,7 @@ trait get_and_find_region {\n \n impl get_and_find_region for isr_alist {\n     pub fn get(&self, br: ty::bound_region) -> ty::Region {\n-        self.find(br).get()\n+        self.find(br).unwrap()\n     }\n \n     pub fn find(&self, br: ty::bound_region) -> Option<ty::Region> {"}, {"sha": "bbcf42b1c5d321b600eb4a1be6fa0f7411990c5b", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -18,6 +18,7 @@ use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n \n+#[deriving(ToStr)]\n pub struct RegionError {\n     msg: ~str,\n     replacement: ty::Region"}, {"sha": "46414a7a5e23e0cc13e0e886d94db7c872a2c20c", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -96,7 +96,6 @@ pub mod driver;\n pub mod util {\n     pub mod common;\n     pub mod ppaux;\n-    pub mod enum_set;\n }\n \n pub mod lib {"}, {"sha": "1bea3003c63d292402bec46afef8cd578739a293", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -280,9 +280,13 @@ pub fn vstore_ty_to_str(cx: ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n     }\n }\n \n+pub fn vec_map_to_str<T>(ts: &[T], f: &fn(t: &T) -> ~str) -> ~str {\n+    let tstrs = ts.map(f);\n+    fmt!(\"[%s]\", tstrs.connect(\", \"))\n+}\n+\n pub fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n-    let tstrs = ts.map(|t| ty_to_str(cx, *t));\n-    fmt!(\"(%s)\", tstrs.connect(\", \"))\n+    vec_map_to_str(ts, |t| ty_to_str(cx, *t))\n }\n \n pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n@@ -529,7 +533,7 @@ impl<T:Repr> Repr for ~T {\n }\n \n fn repr_vec<T:Repr>(tcx: ctxt, v: &[T]) -> ~str {\n-    fmt!(\"[%s]\", v.map(|t| t.repr(tcx)).connect(\",\"))\n+    vec_map_to_str(v, |t| t.repr(tcx))\n }\n \n impl<'self, T:Repr> Repr for &'self [T] {\n@@ -589,15 +593,14 @@ impl Repr for ty::RegionSubsts {\n impl Repr for ty::ParamBounds {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         let mut res = ~[];\n-        do self.builtin_bounds.each |b| {\n+        for b in self.builtin_bounds.iter() {\n             res.push(match b {\n                 ty::BoundStatic => ~\"'static\",\n                 ty::BoundSend => ~\"Send\",\n                 ty::BoundFreeze => ~\"Freeze\",\n                 ty::BoundSized => ~\"Sized\",\n             });\n-            true\n-        };\n+        }\n         for t in self.trait_bounds.iter() {\n             res.push(t.repr(tcx));\n         }\n@@ -833,10 +836,9 @@ impl UserString for ty::BuiltinBounds {\n     fn user_string(&self, tcx: ctxt) -> ~str {\n         if self.is_empty() { ~\"<no-bounds>\" } else {\n             let mut result = ~[];\n-            do self.each |bb| {\n+            for bb in self.iter() {\n                 result.push(bb.user_string(tcx));\n-                true\n-            };\n+            }\n             result.connect(\"+\")\n         }\n     }"}, {"sha": "a1cb81f4503579eae39d6c34a9f13c9728dbbfcd", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -68,7 +68,7 @@ fn fold_crate(\n     doc::CrateDoc {\n         topmod: doc::ModDoc {\n             item: doc::ItemDoc {\n-                name: attrs.name.clone().get_or_default(doc.topmod.name_()),\n+                name: attrs.name.clone().unwrap_or_default(doc.topmod.name_()),\n                 .. doc.topmod.item.clone()\n             },\n             .. doc.topmod.clone()\n@@ -135,7 +135,7 @@ fn fold_enum(\n                             let ast_variant =\n                                 (*enum_definition.variants.iter().find_(|v| {\n                                     to_str(v.node.name) == variant.name\n-                                }).get()).clone();\n+                                }).unwrap()).clone();\n \n                             attr_parser::parse_desc(\n                                 ast_variant.node.attrs.clone())"}, {"sha": "d387bbea592d36374231a4e59a4572d00d177fef", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -142,7 +142,7 @@ fn config_from_opts(\n         let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n         let output_dir = output_dir.map(|s| Path(*s));\n         result::Ok(Config {\n-            output_dir: output_dir.get_or_default(config.output_dir.clone()),\n+            output_dir: output_dir.unwrap_or_default(config.output_dir.clone()),\n             .. config\n         })\n     };\n@@ -273,101 +273,101 @@ mod test {\n     #[test]\n     fn should_error_with_no_crates() {\n         let config = parse_config([~\"rustdoc\"]);\n-        assert!(config.get_err() == ~\"no crates specified\");\n+        assert!(config.unwrap_err() == ~\"no crates specified\");\n     }\n \n     #[test]\n     fn should_error_with_multiple_crates() {\n         let config =\n             parse_config([~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n-        assert!(config.get_err() == ~\"multiple crates specified\");\n+        assert!(config.unwrap_err() == ~\"multiple crates specified\");\n     }\n \n     #[test]\n     fn should_set_output_dir_to_cwd_if_not_provided() {\n         let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n-        assert!(config.get().output_dir == Path(\".\"));\n+        assert!(config.unwrap().output_dir == Path(\".\"));\n     }\n \n     #[test]\n     fn should_set_output_dir_if_provided() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-dir\", ~\"snuggles\"\n         ]);\n-        assert!(config.get().output_dir == Path(\"snuggles\"));\n+        assert!(config.unwrap().output_dir == Path(\"snuggles\"));\n     }\n \n     #[test]\n     fn should_set_output_format_to_pandoc_html_if_not_provided() {\n         let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n-        assert!(config.get().output_format == PandocHtml);\n+        assert!(config.unwrap().output_format == PandocHtml);\n     }\n \n     #[test]\n     fn should_set_output_format_to_markdown_if_requested() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"markdown\"\n         ]);\n-        assert!(config.get().output_format == Markdown);\n+        assert!(config.unwrap().output_format == Markdown);\n     }\n \n     #[test]\n     fn should_set_output_format_to_pandoc_html_if_requested() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"html\"\n         ]);\n-        assert!(config.get().output_format == PandocHtml);\n+        assert!(config.unwrap().output_format == PandocHtml);\n     }\n \n     #[test]\n     fn should_error_on_bogus_format() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"bogus\"\n         ]);\n-        assert!(config.get_err() == ~\"unknown output format 'bogus'\");\n+        assert!(config.unwrap_err() == ~\"unknown output format 'bogus'\");\n     }\n \n     #[test]\n     fn should_set_output_style_to_doc_per_mod_by_default() {\n         let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n-        assert!(config.get().output_style == DocPerMod);\n+        assert!(config.unwrap().output_style == DocPerMod);\n     }\n \n     #[test]\n     fn should_set_output_style_to_one_doc_if_requested() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-crate\"\n         ]);\n-        assert!(config.get().output_style == DocPerCrate);\n+        assert!(config.unwrap().output_style == DocPerCrate);\n     }\n \n     #[test]\n     fn should_set_output_style_to_doc_per_mod_if_requested() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-mod\"\n         ]);\n-        assert!(config.get().output_style == DocPerMod);\n+        assert!(config.unwrap().output_style == DocPerMod);\n     }\n \n     #[test]\n     fn should_error_on_bogus_output_style() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"bogus\"\n         ]);\n-        assert!(config.get_err() == ~\"unknown output style 'bogus'\");\n+        assert!(config.unwrap_err() == ~\"unknown output style 'bogus'\");\n     }\n \n     #[test]\n     fn should_set_pandoc_command_if_requested() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--pandoc-cmd\", ~\"panda-bear-doc\"\n         ]);\n-        assert!(config.get().pandoc_cmd == Some(~\"panda-bear-doc\"));\n+        assert!(config.unwrap().pandoc_cmd == Some(~\"panda-bear-doc\"));\n     }\n \n     #[test]\n     fn should_set_pandoc_command_when_using_pandoc() {\n         let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n-        assert!(config.get().pandoc_cmd == Some(~\"pandoc\"));\n+        assert!(config.unwrap().pandoc_cmd == Some(~\"pandoc\"));\n     }\n }"}, {"sha": "9f8041712eaecdb12d38bb0843ec7edbe675e9c2", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -83,7 +83,7 @@ pub fn extract(desc: Option<~str>) -> Option<~str> {\n         return None\n     }\n \n-    parse_desc(desc.clone().get())\n+    parse_desc(desc.clone().unwrap())\n }\n \n fn parse_desc(desc: ~str) -> Option<~str> {"}, {"sha": "d24fd1f5bfe54fb59cc90ecb61fc482976938154", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -176,7 +176,7 @@ impl Doc {\n               doc::CratePage(doc) => Some(doc),\n               _ => None\n             }\n-        }).get()\n+        }).unwrap()\n     }\n \n     pub fn cratemod(&self) -> ModDoc {"}, {"sha": "90634770a501eaa0b8869a48ff3aa10bcab69be3", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -223,13 +223,13 @@ mod test {\n             config::DocPerCrate,\n             ~\"mod a { } fn b() { }\"\n         );\n-        assert!(doc.cratemod().index.get().entries[0] == doc::IndexEntry {\n+        assert!(doc.cratemod().index.unwrap().entries[0] == doc::IndexEntry {\n             kind: ~\"Module\",\n             name: ~\"a\",\n             brief: None,\n             link: ~\"#module-a\"\n         });\n-        assert!(doc.cratemod().index.get().entries[1] == doc::IndexEntry {\n+        assert!(doc.cratemod().index.unwrap().entries[1] == doc::IndexEntry {\n             kind: ~\"Function\",\n             name: ~\"b\",\n             brief: None,\n@@ -243,13 +243,13 @@ mod test {\n             config::DocPerMod,\n             ~\"mod a { } fn b() { }\"\n         );\n-        assert_eq!(doc.cratemod().index.get().entries[0], doc::IndexEntry {\n+        assert_eq!(doc.cratemod().index.unwrap().entries[0], doc::IndexEntry {\n             kind: ~\"Module\",\n             name: ~\"a\",\n             brief: None,\n             link: ~\"a.html\"\n         });\n-        assert_eq!(doc.cratemod().index.get().entries[1], doc::IndexEntry {\n+        assert_eq!(doc.cratemod().index.unwrap().entries[1], doc::IndexEntry {\n             kind: ~\"Function\",\n             name: ~\"b\",\n             brief: None,\n@@ -263,7 +263,7 @@ mod test {\n             config::DocPerMod,\n             ~\"#[doc = \\\"test\\\"] mod a { }\"\n         );\n-        assert_eq!(doc.cratemod().index.get().entries[0].brief, Some(~\"test\"));\n+        assert_eq!(doc.cratemod().index.unwrap().entries[0].brief, Some(~\"test\"));\n     }\n \n     #[test]\n@@ -273,7 +273,7 @@ mod test {\n             ~\"extern { fn b(); }\"\n         );\n         // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().nmods()[0].index.get().entries[0],\n+        assert_eq!(doc.cratemod().nmods()[0].index.unwrap().entries[0],\n                    doc::IndexEntry {\n                        kind: ~\"Function\",\n                        name: ~\"b\","}, {"sha": "85c360a9e0dfdd8153fa103791365235687276f3", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -617,10 +617,10 @@ mod test {\n               fn d() { }\"\n         );\n \n-        let idx_a = markdown.find_str(\"# Module `a`\").get();\n-        let idx_b = markdown.find_str(\"## Function `b`\").get();\n-        let idx_c = markdown.find_str(\"# Module `c`\").get();\n-        let idx_d = markdown.find_str(\"## Function `d`\").get();\n+        let idx_a = markdown.find_str(\"# Module `a`\").unwrap();\n+        let idx_b = markdown.find_str(\"## Function `b`\").unwrap();\n+        let idx_c = markdown.find_str(\"# Module `c`\").unwrap();\n+        let idx_d = markdown.find_str(\"## Function `d`\").unwrap();\n \n         assert!(idx_b < idx_d);\n         assert!(idx_d < idx_a);"}, {"sha": "20f3ff3e98d4871b0ec72d4bf7a865c22d55b6f0", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -218,8 +218,8 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(!doc.cratemod().mods()[0].desc().get().contains(\"Header\"));\n-        assert!(!doc.cratemod().mods()[0].desc().get().contains(\"Body\"));\n+        assert!(!doc.cratemod().mods()[0].desc().unwrap().contains(\"Header\"));\n+        assert!(!doc.cratemod().mods()[0].desc().unwrap().contains(\"Body\"));\n     }\n \n     #[test]"}, {"sha": "684b4e9d198d4d1551e05418143f33b469485ce5", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -135,7 +135,7 @@ fn fold_enum(\n                             let ast_variant =\n                                 (*do enum_definition.variants.iter().find_ |v| {\n                                 to_str(v.node.name) == variant.name\n-                            }.get()).clone();\n+                            }.unwrap()).clone();\n \n                             pprust::variant_to_str(\n                                 &ast_variant, extract::interner())\n@@ -443,14 +443,14 @@ mod test {\n     #[test]\n     fn should_add_struct_defs() {\n         let doc = mk_doc(~\"struct S { field: () }\");\n-        assert!(doc.cratemod().structs()[0].sig.get().contains(\n+        assert!(doc.cratemod().structs()[0].sig.unwrap().contains(\n             \"struct S {\"));\n     }\n \n     #[test]\n     fn should_not_serialize_struct_attrs() {\n         // All we care about are the fields\n         let doc = mk_doc(~\"#[wut] struct S { field: () }\");\n-        assert!(!doc.cratemod().structs()[0].sig.get().contains(\"wut\"));\n+        assert!(!doc.cratemod().structs()[0].sig.unwrap().contains(\"wut\"));\n     }\n }"}, {"sha": "86290ea65b5646f939eed20204ae3a07b79c6bc4", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -322,14 +322,14 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n             // instead we guess which file is the library by matching\n             // the prefix and suffix of out_filename to files in the\n             // directory.\n-            let file_str = file.filename().get();\n-            file_str.starts_with(outputs.out_filename.filestem().get())\n-                && file_str.ends_with(outputs.out_filename.filetype().get())\n+            let file_str = file.filename().unwrap();\n+            file_str.starts_with(outputs.out_filename.filestem().unwrap())\n+                && file_str.ends_with(outputs.out_filename.filetype().unwrap())\n         };\n         match maybe_lib_path {\n             Some(lib_path) => {\n-                let (src_mtime, _) = src_path.get_mtime().get();\n-                let (lib_mtime, _) = lib_path.get_mtime().get();\n+                let (src_mtime, _) = src_path.get_mtime().unwrap();\n+                let (lib_mtime, _) = lib_path.get_mtime().unwrap();\n                 if lib_mtime >= src_mtime {\n                     should_compile = false;\n                 }\n@@ -565,10 +565,7 @@ mod tests {\n         }\n     }\n \n-    // FIXME: #7220 rusti on 32bit mac doesn't work.\n-    // FIXME: #7641 rusti on 32bit linux cross compile doesn't work\n-    // FIXME: #7115 re-enable once LLVM has been upgraded\n-    #[cfg(thiswillneverbeacfgflag)]\n+    #[cfg(not(target_word_size = \"32\"))]\n     fn run_program(prog: &str) {\n         let mut r = repl();\n         for cmd in prog.split_iter('\\n') {\n@@ -577,6 +574,9 @@ mod tests {\n                     \"the command '%s' failed\", cmd);\n         }\n     }\n+    // FIXME: #7220 rusti on 32bit mac doesn't work\n+    // FIXME: #7641 rusti on 32bit linux cross compile doesn't work\n+    #[cfg(target_word_size = \"32\")]\n     fn run_program(_: &str) {}\n \n     #[test]\n@@ -594,13 +594,12 @@ mod tests {\n         run_program(\"let a = 3;\");\n     }\n \n-    #[test] #[ignore]\n+    #[test]\n     fn new_tasks() {\n-        // XXX: can't spawn new tasks because the JIT code is cleaned up\n-        //      after the main function is done.\n         run_program(\"\n-            spawn( || println(\\\"Please don't segfault\\\") );\n-            do spawn { println(\\\"Please?\\\"); }\n+            use std::task::try;\n+            try( || println(\\\"Please don't segfault\\\") );\n+            do try { println(\\\"Please?\\\"); }\n         \");\n     }\n "}, {"sha": "fa03a5bbfc2fbf70eb47beea86951ae38971edd4", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -102,7 +102,7 @@ impl<'self> PkgScript<'self> {\n     debug!(\"pkgscript parse: %?\", os::self_exe_path());\n         let options = @session::options {\n             binary: binary,\n-            maybe_sysroot: Some(@os::self_exe_path().get().pop()),\n+            maybe_sysroot: Some(@os::self_exe_path().unwrap().pop()),\n             crate_type: session::bin_crate,\n             .. (*session::basic_options()).clone()\n         };\n@@ -535,7 +535,7 @@ pub fn main() {\n  * in is the working directory.\n  */\n pub fn work_dir() -> Path {\n-    os::self_exe_path().get()\n+    os::self_exe_path().unwrap()\n }\n \n /**"}, {"sha": "a7e92afd2a4e4d61ecfbe8576570181eb6910497", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -196,7 +196,7 @@ pub fn compile_input(ctxt: &Ctx,\n                           }\n                           + flags\n                           + cfgs.flat_map(|c| { ~[~\"--cfg\", (*c).clone()] }),\n-                          driver::optgroups()).get();\n+                          driver::optgroups()).unwrap();\n     let options = @session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },"}, {"sha": "a84f3137bbd5bfb022f2ac93a6982472c59b3064", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -78,10 +78,8 @@ pub fn build<A>(builder: &fn(push: &fn(v: A))) -> @[A] {\n  *             onto the vector being constructed.\n  */\n #[inline]\n-pub fn build_sized_opt<A>(size: Option<uint>,\n-                          builder: &fn(push: &fn(v: A)))\n-                       -> @[A] {\n-    build_sized(size.get_or_default(4), builder)\n+pub fn build_sized_opt<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> @[A] {\n+    build_sized(size.unwrap_or_default(4), builder)\n }\n \n // Appending"}, {"sha": "cfaef550c6fa74072a2cd64413d7aa612e044a06", "filename": "src/libstd/either.rs", "status": "modified", "additions": 173, "deletions": 193, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -23,29 +23,102 @@ use str::StrSlice;\n use vec;\n use vec::{OwnedVector, ImmutableVector};\n \n-/// The either type\n+/// `Either` is a type that represents one of two alternatives\n #[deriving(Clone, Eq)]\n-pub enum Either<T, U> {\n-    Left(T),\n-    Right(U)\n+pub enum Either<L, R> {\n+    Left(L),\n+    Right(R)\n }\n \n-/// Applies a function based on the given either value\n-///\n-/// If `value` is left(T) then `f_left` is applied to its contents, if\n-/// `value` is right(U) then `f_right` is applied to its contents, and the\n-/// result is returned.\n-#[inline]\n-pub fn either<T, U, V>(f_left: &fn(&T) -> V,\n-                       f_right: &fn(&U) -> V, value: &Either<T, U>) -> V {\n-    match *value {\n-        Left(ref l) => f_left(l),\n-        Right(ref r) => f_right(r)\n+impl<L, R> Either<L, R> {\n+    /// Applies a function based on the given either value\n+    ///\n+    /// If `value` is `Left(L)` then `f_left` is applied to its contents, if\n+    /// `value` is `Right(R)` then `f_right` is applied to its contents, and the\n+    /// result is returned.\n+    #[inline]\n+    pub fn either<T>(&self, f_left: &fn(&L) -> T, f_right: &fn(&R) -> T) -> T {\n+        match *self {\n+            Left(ref l) => f_left(l),\n+            Right(ref r) => f_right(r)\n+        }\n+    }\n+\n+    /// Flips between left and right of a given `Either`\n+    #[inline]\n+    pub fn flip(self) -> Either<R, L> {\n+        match self {\n+            Right(r) => Left(r),\n+            Left(l) => Right(l)\n+        }\n+    }\n+\n+    /// Converts a `Either` to a `Result`\n+    ///\n+    /// Converts an `Either` type to a `Result` type, making the \"right\" choice\n+    /// an `Ok` result, and the \"left\" choice a `Err`\n+    #[inline]\n+    pub fn to_result(self) -> Result<R, L> {\n+        match self {\n+            Right(r) => result::Ok(r),\n+            Left(l) => result::Err(l)\n+        }\n+    }\n+\n+    /// Checks whether the given value is a `Left`\n+    #[inline]\n+    pub fn is_left(&self) -> bool {\n+        match *self {\n+            Left(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks whether the given value is a `Right`\n+    #[inline]\n+    pub fn is_right(&self) -> bool {\n+        match *self {\n+            Right(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Retrieves the value from a `Left`.\n+    /// Fails with a specified reason if the `Either` is `Right`.\n+    #[inline]\n+    pub fn expect_left(self, reason: &str) -> L {\n+        match self {\n+            Left(x) => x,\n+            Right(_) => fail!(reason.to_owned())\n+        }\n+    }\n+\n+    /// Retrieves the value from a `Left`. Fails if the `Either` is `Right`.\n+    #[inline]\n+    pub fn unwrap_left(self) -> L {\n+        self.expect_left(\"called Either::unwrap_left()` on `Right` value\")\n+    }\n+\n+    /// Retrieves the value from a `Right`.\n+    /// Fails with a specified reason if the `Either` is `Left`.\n+    #[inline]\n+    pub fn expect_right(self, reason: &str) -> R {\n+        match self {\n+            Right(x) => x,\n+            Left(_) => fail!(reason.to_owned())\n+        }\n+    }\n+\n+    /// Retrieves the value from a `Right`. Fails if the `Either` is `Left`.\n+    #[inline]\n+    pub fn unwrap_right(self) -> R {\n+        self.expect_right(\"called Either::unwrap_right()` on `Left` value\")\n     }\n }\n \n+// FIXME: #8228 Replaceable by an external iterator?\n /// Extracts from a vector of either all the left values\n-pub fn lefts<T:Clone,U>(eithers: &[Either<T, U>]) -> ~[T] {\n+pub fn lefts<L: Clone, R>(eithers: &[Either<L, R>]) -> ~[L] {\n     do vec::build_sized(eithers.len()) |push| {\n         for elt in eithers.iter() {\n             match *elt {\n@@ -56,8 +129,9 @@ pub fn lefts<T:Clone,U>(eithers: &[Either<T, U>]) -> ~[T] {\n     }\n }\n \n+// FIXME: #8228 Replaceable by an external iterator?\n /// Extracts from a vector of either all the right values\n-pub fn rights<T, U: Clone>(eithers: &[Either<T, U>]) -> ~[U] {\n+pub fn rights<L, R: Clone>(eithers: &[Either<L, R>]) -> ~[R] {\n     do vec::build_sized(eithers.len()) |push| {\n         for elt in eithers.iter() {\n             match *elt {\n@@ -68,13 +142,14 @@ pub fn rights<T, U: Clone>(eithers: &[Either<T, U>]) -> ~[U] {\n     }\n }\n \n+// FIXME: #8228 Replaceable by an external iterator?\n /// Extracts from a vector of either all the left values and right values\n ///\n /// Returns a structure containing a vector of left values and a vector of\n /// right values.\n-pub fn partition<T, U>(eithers: ~[Either<T, U>]) -> (~[T], ~[U]) {\n-    let mut lefts: ~[T] = ~[];\n-    let mut rights: ~[U] = ~[];\n+pub fn partition<L, R>(eithers: ~[Either<L, R>]) -> (~[L], ~[R]) {\n+    let mut lefts: ~[L] = ~[];\n+    let mut rights: ~[R] = ~[];\n     for elt in eithers.consume_iter() {\n         match elt {\n             Left(l) => lefts.push(l),\n@@ -84,196 +159,101 @@ pub fn partition<T, U>(eithers: ~[Either<T, U>]) -> (~[T], ~[U]) {\n     return (lefts, rights);\n }\n \n-/// Flips between left and right of a given either\n-#[inline]\n-pub fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n-    match eith {\n-        Right(r) => Left(r),\n-        Left(l) => Right(l)\n-    }\n-}\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n \n-/// Converts either::t to a result::t\n-///\n-/// Converts an `either` type to a `result` type, making the \"right\" choice\n-/// an ok result, and the \"left\" choice a fail\n-#[inline]\n-pub fn to_result<T, U>(eith: Either<T, U>) -> Result<U, T> {\n-    match eith {\n-        Right(r) => result::Ok(r),\n-        Left(l) => result::Err(l)\n+    #[test]\n+    fn test_either_left() {\n+        let val = Left(10);\n+        fn f_left(x: &int) -> bool { *x == 10 }\n+        fn f_right(_x: &uint) -> bool { false }\n+        assert!(val.either(f_left, f_right));\n     }\n-}\n \n-/// Checks whether the given value is a left\n-#[inline]\n-pub fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n-    match *eith {\n-        Left(_) => true,\n-        _ => false\n+    #[test]\n+    fn test_either_right() {\n+        let val = Right(10u);\n+        fn f_left(_x: &int) -> bool { false }\n+        fn f_right(x: &uint) -> bool { *x == 10u }\n+        assert!(val.either(f_left, f_right));\n     }\n-}\n \n-/// Checks whether the given value is a right\n-#[inline]\n-pub fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n-    match *eith {\n-        Right(_) => true,\n-        _ => false\n+    #[test]\n+    fn test_lefts() {\n+        let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n+        let result = lefts(input);\n+        assert_eq!(result, ~[10, 12, 14]);\n     }\n-}\n \n-/// Retrieves the value in the left branch.\n-/// Fails with a specified reason if the either is Right.\n-#[inline]\n-pub fn expect_left<T,U>(eith: Either<T,U>, reason: &str) -> T {\n-    match eith {\n-        Left(x) => x,\n-        Right(_) => fail!(reason.to_owned())\n+    #[test]\n+    fn test_lefts_none() {\n+        let input: ~[Either<int, int>] = ~[Right(10), Right(10)];\n+        let result = lefts(input);\n+        assert_eq!(result.len(), 0u);\n     }\n-}\n \n-/// Retrieves the value in the left branch. Fails if the either is Right.\n-#[inline]\n-pub fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n-    expect_left(eith, \"either::unwrap_left Right\")\n-}\n-\n-/// Retrieves the value in the right branch.\n-/// Fails with a specified reason if the either is Left.\n-#[inline]\n-pub fn expect_right<T,U>(eith: Either<T,U>, reason: &str) -> U {\n-    match eith {\n-        Right(x) => x,\n-        Left(_) => fail!(reason.to_owned())\n+    #[test]\n+    fn test_lefts_empty() {\n+        let input: ~[Either<int, int>] = ~[];\n+        let result = lefts(input);\n+        assert_eq!(result.len(), 0u);\n     }\n-}\n \n-/// Retrieves the value in the right branch. Fails if the either is Left.\n-pub fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n-    expect_right(eith, \"either::unwrap_right Left\")\n-}\n-\n-impl<T, U> Either<T, U> {\n-    #[inline]\n-    pub fn either<V>(&self, f_left: &fn(&T) -> V, f_right: &fn(&U) -> V) -> V {\n-        either(f_left, f_right, self)\n+    #[test]\n+    fn test_rights() {\n+        let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n+        let result = rights(input);\n+        assert_eq!(result, ~[11, 13]);\n     }\n \n-    #[inline]\n-    pub fn flip(self) -> Either<U, T> { flip(self) }\n-\n-    #[inline]\n-    pub fn to_result(self) -> Result<U, T> { to_result(self) }\n-\n-    #[inline]\n-    pub fn is_left(&self) -> bool { is_left(self) }\n-\n-    #[inline]\n-    pub fn is_right(&self) -> bool { is_right(self) }\n-\n-    #[inline]\n-    pub fn expect_left(self, reason: &str) -> T { expect_left(self, reason) }\n-\n-    #[inline]\n-    pub fn unwrap_left(self) -> T { unwrap_left(self) }\n-\n-    #[inline]\n-    pub fn expect_right(self, reason: &str) -> U { expect_right(self, reason) }\n-\n-    #[inline]\n-    pub fn unwrap_right(self) -> U { unwrap_right(self) }\n-}\n-\n-#[test]\n-fn test_either_left() {\n-    let val = Left(10);\n-    fn f_left(x: &int) -> bool { *x == 10 }\n-    fn f_right(_x: &uint) -> bool { false }\n-    assert!((either(f_left, f_right, &val)));\n-}\n-\n-#[test]\n-fn test_either_right() {\n-    let val = Right(10u);\n-    fn f_left(_x: &int) -> bool { false }\n-    fn f_right(x: &uint) -> bool { *x == 10u }\n-    assert!((either(f_left, f_right, &val)));\n-}\n-\n-#[test]\n-fn test_lefts() {\n-    let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-    let result = lefts(input);\n-    assert_eq!(result, ~[10, 12, 14]);\n-}\n-\n-#[test]\n-fn test_lefts_none() {\n-    let input: ~[Either<int, int>] = ~[Right(10), Right(10)];\n-    let result = lefts(input);\n-    assert_eq!(result.len(), 0u);\n-}\n-\n-#[test]\n-fn test_lefts_empty() {\n-    let input: ~[Either<int, int>] = ~[];\n-    let result = lefts(input);\n-    assert_eq!(result.len(), 0u);\n-}\n-\n-#[test]\n-fn test_rights() {\n-    let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-    let result = rights(input);\n-    assert_eq!(result, ~[11, 13]);\n-}\n+    #[test]\n+    fn test_rights_none() {\n+        let input: ~[Either<int, int>] = ~[Left(10), Left(10)];\n+        let result = rights(input);\n+        assert_eq!(result.len(), 0u);\n+    }\n \n-#[test]\n-fn test_rights_none() {\n-    let input: ~[Either<int, int>] = ~[Left(10), Left(10)];\n-    let result = rights(input);\n-    assert_eq!(result.len(), 0u);\n-}\n+    #[test]\n+    fn test_rights_empty() {\n+        let input: ~[Either<int, int>] = ~[];\n+        let result = rights(input);\n+        assert_eq!(result.len(), 0u);\n+    }\n \n-#[test]\n-fn test_rights_empty() {\n-    let input: ~[Either<int, int>] = ~[];\n-    let result = rights(input);\n-    assert_eq!(result.len(), 0u);\n-}\n+    #[test]\n+    fn test_partition() {\n+        let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n+        let (lefts, rights) = partition(input);\n+        assert_eq!(lefts[0], 10);\n+        assert_eq!(lefts[1], 12);\n+        assert_eq!(lefts[2], 14);\n+        assert_eq!(rights[0], 11);\n+        assert_eq!(rights[1], 13);\n+    }\n \n-#[test]\n-fn test_partition() {\n-    let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-    let (lefts, rights) = partition(input);\n-    assert_eq!(lefts[0], 10);\n-    assert_eq!(lefts[1], 12);\n-    assert_eq!(lefts[2], 14);\n-    assert_eq!(rights[0], 11);\n-    assert_eq!(rights[1], 13);\n-}\n+    #[test]\n+    fn test_partition_no_lefts() {\n+        let input: ~[Either<int, int>] = ~[Right(10), Right(11)];\n+        let (lefts, rights) = partition(input);\n+        assert_eq!(lefts.len(), 0u);\n+        assert_eq!(rights.len(), 2u);\n+    }\n \n-#[test]\n-fn test_partition_no_lefts() {\n-    let input: ~[Either<int, int>] = ~[Right(10), Right(11)];\n-    let (lefts, rights) = partition(input);\n-    assert_eq!(lefts.len(), 0u);\n-    assert_eq!(rights.len(), 2u);\n-}\n+    #[test]\n+    fn test_partition_no_rights() {\n+        let input: ~[Either<int, int>] = ~[Left(10), Left(11)];\n+        let (lefts, rights) = partition(input);\n+        assert_eq!(lefts.len(), 2u);\n+        assert_eq!(rights.len(), 0u);\n+    }\n \n-#[test]\n-fn test_partition_no_rights() {\n-    let input: ~[Either<int, int>] = ~[Left(10), Left(11)];\n-    let (lefts, rights) = partition(input);\n-    assert_eq!(lefts.len(), 2u);\n-    assert_eq!(rights.len(), 0u);\n-}\n+    #[test]\n+    fn test_partition_empty() {\n+        let input: ~[Either<int, int>] = ~[];\n+        let (lefts, rights) = partition(input);\n+        assert_eq!(lefts.len(), 0u);\n+        assert_eq!(rights.len(), 0u);\n+    }\n \n-#[test]\n-fn test_partition_empty() {\n-    let input: ~[Either<int, int>] = ~[];\n-    let (lefts, rights) = partition(input);\n-    assert_eq!(lefts.len(), 0u);\n-    assert_eq!(rights.len(), 0u);\n }"}, {"sha": "fbc471c0ae05d4b289235134ec8366d040459437", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 17, "deletions": 37, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -19,7 +19,8 @@ use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use clone::Clone;\n use cmp::{Eq, Equiv};\n use hash::Hash;\n-use iterator::{Iterator, IteratorUtil, FromIterator, Extendable, Chain, range};\n+use iterator::{Iterator, IteratorUtil, FromIterator, Extendable, range};\n+use iterator::{FilterMap, Chain, Repeat, Zip};\n use num;\n use option::{None, Option, Some};\n use rand::RngUtil;\n@@ -712,10 +713,12 @@ impl<T:Hash + Eq> HashSet<T> {\n     }\n \n     /// Visit the values representing the difference\n-    pub fn difference_iter<'a>(&'a self, other: &'a HashSet<T>)\n-        -> SetAlgebraIter<'a, T> {\n-        EnvFilterIterator{iter: self.iter(), env: other,\n-                          filter: |elt, other| !other.contains(elt) }\n+    pub fn difference_iter<'a>(&'a self, other: &'a HashSet<T>) -> SetAlgebraIter<'a, T> {\n+        Repeat::new(other)\n+            .zip(self.iter())\n+            .filter_map(|(other, elt)| {\n+                if !other.contains(elt) { Some(elt) } else { None }\n+            })\n     }\n \n     /// Visit the values representing the symmetric difference\n@@ -727,8 +730,11 @@ impl<T:Hash + Eq> HashSet<T> {\n     /// Visit the values representing the intersection\n     pub fn intersection_iter<'a>(&'a self, other: &'a HashSet<T>)\n         -> SetAlgebraIter<'a, T> {\n-        EnvFilterIterator{iter: self.iter(), env: other,\n-                          filter: |elt, other| other.contains(elt) }\n+        Repeat::new(other)\n+            .zip(self.iter())\n+            .filter_map(|(other, elt)| {\n+                if other.contains(elt) { Some(elt) } else { None }\n+            })\n     }\n \n     /// Visit the values representing the union\n@@ -756,38 +762,12 @@ impl<K: Eq + Hash, T: Iterator<K>> Extendable<K, T> for HashSet<K> {\n     }\n }\n \n-// FIXME #7814: use std::iterator::FilterIterator\n-/// Building block for Set operation iterators\n-pub struct EnvFilterIterator<A, Env, I> {\n-    priv env: Env,\n-    priv filter: &'static fn(&A, Env) -> bool,\n-    priv iter: I,\n-}\n-\n-impl<'self, A, Env: Clone, I: Iterator<&'self A>> Iterator<&'self A>\n-        for EnvFilterIterator<A, Env, I> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'self A> {\n-        loop {\n-            match self.iter.next() {\n-                Some(elt) => if (self.filter)(elt, self.env.clone()) {\n-                    return Some(elt)\n-                },\n-                None => return None,\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper)\n-    }\n-}\n-\n+// `Repeat` is used to feed the filter closure an explicit capture\n+// of a reference to the other set\n /// Set operations iterator\n pub type SetAlgebraIter<'self, T> =\n-    EnvFilterIterator<T, &'self HashSet<T>, HashSetIterator<'self, T>>;\n+    FilterMap<'static,(&'self HashSet<T>, &'self T), &'self T,\n+              Zip<Repeat<&'self HashSet<T>>,HashSetIterator<'self,T>>>;\n \n \n #[cfg(test)]"}, {"sha": "07572d60917a0246c6f24be086ae26a64b52697f", "filename": "src/libstd/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -1042,7 +1042,7 @@ pub fn stdin() -> @Reader {\n \n pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n     let f = do path.to_c_str().with_ref |pathbuf| {\n-        do \"r\".to_c_str().with_ref |modebuf| {\n+        do \"rb\".to_c_str().with_ref |modebuf| {\n             unsafe { libc::fopen(pathbuf, modebuf as *libc::c_char) }\n         }\n     };"}, {"sha": "56a0dca56679ccf3a34d89038944614d0c497263", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -82,6 +82,17 @@ pub trait DoubleEndedIteratorUtil {\n /// In the future these will be default methods instead of a utility trait.\n impl<A, T: DoubleEndedIterator<A>> DoubleEndedIteratorUtil for T {\n     /// Flip the direction of the iterator\n+    ///\n+    /// The inverted iterator flips the ends on an iterator that can already\n+    /// be iterated from the front and from the back.\n+    ///\n+    ///\n+    /// If the iterator also implements RandomAccessIterator, the inverted\n+    /// iterator is also random access, with the indices starting at the back\n+    /// of the original iterator.\n+    ///\n+    /// Note: Random access with inverted indices still only applies to the first\n+    /// `uint::max_value` elements of the original iterator.\n     #[inline]\n     fn invert(self) -> Invert<T> {\n         Invert{iter: self}\n@@ -106,6 +117,16 @@ impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Invert<T> {\n     fn next_back(&mut self) -> Option<A> { self.iter.next() }\n }\n \n+impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterator<A>\n+    for Invert<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint { self.iter.indexable() }\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        self.iter.idx(self.indexable() - index - 1)\n+    }\n+}\n+\n /// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n /// implementations of the `Iterator` trait.\n ///\n@@ -1555,6 +1576,39 @@ impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n     }\n }\n \n+/// An iterator that repeats an element endlessly\n+#[deriving(Clone, DeepClone)]\n+pub struct Repeat<A> {\n+    priv element: A\n+}\n+\n+impl<A: Clone> Repeat<A> {\n+    /// Create a new `Repeat` that enlessly repeats the element `elt`.\n+    #[inline]\n+    pub fn new(elt: A) -> Repeat<A> {\n+        Repeat{element: elt}\n+    }\n+}\n+\n+impl<A: Clone> Iterator<A> for Repeat<A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> { self.idx(0) }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { (uint::max_value, None) }\n+}\n+\n+impl<A: Clone> DoubleEndedIterator<A> for Repeat<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> { self.idx(0) }\n+}\n+\n+impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n+    #[inline]\n+    fn indexable(&self) -> uint { uint::max_value }\n+    #[inline]\n+    fn idx(&self, _: uint) -> Option<A> { Some(self.element.clone()) }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -2017,6 +2071,17 @@ mod tests {\n         check_randacc_iter(xs.iter().enumerate(), xs.len());\n     }\n \n+    #[test]\n+    fn test_random_access_invert() {\n+        let xs = [1, 2, 3, 4, 5];\n+        check_randacc_iter(xs.iter().invert(), xs.len());\n+        let mut it = xs.iter().invert();\n+        it.next();\n+        it.next_back();\n+        it.next();\n+        check_randacc_iter(it, xs.len() - 3);\n+    }\n+\n     #[test]\n     fn test_random_access_zip() {\n         let xs = [1, 2, 3, 4, 5];"}, {"sha": "c2a60e1c0e9c01891dd97a56a2abb09c80bf06d2", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -112,29 +112,29 @@ fn test_tls_multitask() {\n         // TLS shouldn't carry over.\n         assert!(get(my_key, |k| k.map(|&k| *k)).is_none());\n         set(my_key, @~\"child data\");\n-        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) ==\n+        assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) ==\n                 ~\"child data\");\n         // should be cleaned up for us\n     }\n     // Must work multiple times\n-    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n-    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n-    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) == ~\"parent data\");\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) == ~\"parent data\");\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) == ~\"parent data\");\n }\n \n #[test]\n fn test_tls_overwrite() {\n     static my_key: Key<@~str> = &Key;\n     set(my_key, @~\"first data\");\n     set(my_key, @~\"next data\"); // Shouldn't leak.\n-    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"next data\");\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) == ~\"next data\");\n }\n \n #[test]\n fn test_tls_pop() {\n     static my_key: Key<@~str> = &Key;\n     set(my_key, @~\"weasel\");\n-    assert!(*(pop(my_key).get()) == ~\"weasel\");\n+    assert!(*(pop(my_key).unwrap()) == ~\"weasel\");\n     // Pop must remove the data from the map.\n     assert!(pop(my_key).is_none());\n }\n@@ -155,7 +155,7 @@ fn test_tls_modify() {\n             None                 => fail!(\"missing value\")\n         }\n     });\n-    assert!(*(pop(my_key).get()) == ~\"next data\");\n+    assert!(*(pop(my_key).unwrap()) == ~\"next data\");\n }\n \n #[test]"}, {"sha": "7ab3c81b61f7abd4e134e8f66ecafbff0187bf26", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -726,4 +726,4 @@ mod bench {\n             float::to_str(rng.gen());\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "86bc98e53fcb6605cca989137c733653f47326df", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -70,30 +70,6 @@ pub fn div_round(x: uint, y: uint) -> uint {\n ///\n pub fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n \n-///\n-/// Iterate over the range [`lo`..`hi`), or stop when requested\n-///\n-/// # Arguments\n-///\n-/// * lo - The integer at which to start the loop (included)\n-/// * hi - The integer at which to stop the loop (excluded)\n-/// * it - A block to execute with each consecutive integer of the range.\n-///        Return `true` to continue, `false` to stop.\n-///\n-/// # Return value\n-///\n-/// `true` If execution proceeded correctly, `false` if it was interrupted,\n-/// that is if `it` returned `false` at any point.\n-///\n-pub fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n-    let mut i = lo;\n-    while i < hi {\n-        if (!it(i)) { return false; }\n-        i += 1u;\n-    }\n-    return true;\n-}\n-\n impl iter::Times for uint {\n     #[inline]\n     ///"}, {"sha": "ea1bddcdb4b9d60aba0138494219519e120d5317", "filename": "src/libstd/option.rs", "status": "modified", "additions": 122, "deletions": 136, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -47,7 +47,8 @@ use ops::Add;\n use util;\n use num::Zero;\n use iterator::Iterator;\n-use str::StrSlice;\n+use str::{StrSlice, OwnedStr};\n+use to_str::ToStr;\n use clone::DeepClone;\n \n /// The option type\n@@ -85,22 +86,37 @@ impl<T:Ord> Ord for Option<T> {\n     }\n }\n \n-impl<T:Clone+Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n+impl<T: Add<T, T>> Add<Option<T>, Option<T>> for Option<T> {\n     #[inline]\n     fn add(&self, other: &Option<T>) -> Option<T> {\n         match (&*self, &*other) {\n             (&None, &None) => None,\n-            (_, &None) => (*self).clone(),\n-            (&None, _) => (*other).clone(),\n+            (_, &None) => None,\n+            (&None, _) => None,\n             (&Some(ref lhs), &Some(ref rhs)) => Some(*lhs + *rhs)\n         }\n     }\n }\n \n+// FIXME: #8242 implementing manually because deriving doesn't work for some reason\n+impl<T: ToStr> ToStr for Option<T> {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            Some(ref x) => {\n+                let mut s = ~\"Some(\";\n+                s.push_str(x.to_str());\n+                s.push_str(\")\");\n+                s\n+            }\n+            None => ~\"None\"\n+        }\n+    }\n+}\n+\n impl<T> Option<T> {\n     /// Return an iterator over the possibly contained value\n     #[inline]\n-    pub fn iter<'r>(&'r self) -> OptionIterator<'r, T> {\n+    pub fn iter<'r>(&'r self) -> OptionIterator<&'r T> {\n         match *self {\n             Some(ref x) => OptionIterator{opt: Some(x)},\n             None => OptionIterator{opt: None}\n@@ -109,13 +125,19 @@ impl<T> Option<T> {\n \n     /// Return a mutable iterator over the possibly contained value\n     #[inline]\n-    pub fn mut_iter<'r>(&'r mut self) -> OptionMutIterator<'r, T> {\n+    pub fn mut_iter<'r>(&'r mut self) -> OptionIterator<&'r mut T> {\n         match *self {\n-            Some(ref mut x) => OptionMutIterator{opt: Some(x)},\n-            None => OptionMutIterator{opt: None}\n+            Some(ref mut x) => OptionIterator{opt: Some(x)},\n+            None => OptionIterator{opt: None}\n         }\n     }\n \n+    /// Return a consuming iterator over the possibly contained value\n+    #[inline]\n+    pub fn consume(self) -> OptionIterator<T> {\n+        OptionIterator{opt: self}\n+    }\n+\n     /// Returns true if the option equals `None`\n     #[inline]\n     pub fn is_none(&self) -> bool {\n@@ -148,8 +170,7 @@ impl<T> Option<T> {\n     /// Update an optional value by optionally running its content by reference\n     /// through a function that returns an option.\n     #[inline]\n-    pub fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>)\n-                            -> Option<U> {\n+    pub fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>) -> Option<U> {\n         match *self {\n             Some(ref x) => f(x),\n             None => None\n@@ -159,8 +180,7 @@ impl<T> Option<T> {\n     /// Update an optional value by optionally running its content by mut reference\n     /// through a function that returns an option.\n     #[inline]\n-    pub fn chain_mut_ref<'a, U>(&'a mut self, f: &fn(x: &'a mut T) -> Option<U>)\n-                                -> Option<U> {\n+    pub fn chain_mut_ref<'a, U>(&'a mut self, f: &fn(x: &'a mut T) -> Option<U>) -> Option<U> {\n         match *self {\n             Some(ref mut x) => f(x),\n             None => None\n@@ -256,132 +276,105 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /**\n-    Gets an immutable reference to the value inside an option.\n-\n-    # Failure\n-\n-    Fails if the value equals `None`\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged\n-    (calling `get` on `None` is akin to dereferencing a null pointer).\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-     */\n+    /// Gets an immutable reference to the value inside an option.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value equals `None`\n+    ///\n+    /// # Safety note\n+    ///\n+    /// In general, because this function may fail, its use is discouraged\n+    /// (calling `get` on `None` is akin to dereferencing a null pointer).\n+    /// Instead, prefer to use pattern matching and handle the `None`\n+    /// case explicitly.\n     #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n-          Some(ref x) => x,\n-          None => fail!(\"option::get_ref `None`\"),\n+            Some(ref x) => x,\n+            None => fail!(\"called `Option::get_ref()` on a `None` value\"),\n         }\n     }\n \n-    /**\n-    Gets a mutable reference to the value inside an option.\n-\n-    # Failure\n-\n-    Fails if the value equals `None`\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged\n-    (calling `get` on `None` is akin to dereferencing a null pointer).\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-     */\n+    /// Gets a mutable reference to the value inside an option.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value equals `None`\n+    ///\n+    /// # Safety note\n+    ///\n+    /// In general, because this function may fail, its use is discouraged\n+    /// (calling `get` on `None` is akin to dereferencing a null pointer).\n+    /// Instead, prefer to use pattern matching and handle the `None`\n+    /// case explicitly.\n     #[inline]\n     pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n         match *self {\n-          Some(ref mut x) => x,\n-          None => fail!(\"option::get_mut_ref `None`\"),\n+            Some(ref mut x) => x,\n+            None => fail!(\"called `Option::get_mut_ref()` on a `None` value\"),\n         }\n     }\n \n+    /// Moves a value out of an option type and returns it.\n+    ///\n+    /// Useful primarily for getting strings, vectors and unique pointers out\n+    /// of option types without copying them.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value equals `None`.\n+    ///\n+    /// # Safety note\n+    ///\n+    /// In general, because this function may fail, its use is discouraged.\n+    /// Instead, prefer to use pattern matching and handle the `None`\n+    /// case explicitly.\n     #[inline]\n     pub fn unwrap(self) -> T {\n-        /*!\n-        Moves a value out of an option type and returns it.\n-\n-        Useful primarily for getting strings, vectors and unique pointers out\n-        of option types without copying them.\n-\n-        # Failure\n-\n-        Fails if the value equals `None`.\n-\n-        # Safety note\n-\n-        In general, because this function may fail, its use is discouraged.\n-        Instead, prefer to use pattern matching and handle the `None`\n-        case explicitly.\n-         */\n         match self {\n-          Some(x) => x,\n-          None => fail!(\"option::unwrap `None`\"),\n+            Some(x) => x,\n+            None => fail!(\"called `Option::unwrap()` on a `None` value\"),\n         }\n     }\n \n-    /**\n-     * The option dance. Moves a value out of an option type and returns it,\n-     * replacing the original with `None`.\n-     *\n-     * # Failure\n-     *\n-     * Fails if the value equals `None`.\n-     */\n+    /// The option dance. Moves a value out of an option type and returns it,\n+    /// replacing the original with `None`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value equals `None`.\n     #[inline]\n     pub fn take_unwrap(&mut self) -> T {\n-        if self.is_none() { fail!(\"option::take_unwrap `None`\") }\n+        if self.is_none() {\n+            fail!(\"called `Option::take_unwrap()` on a `None` value\")\n+        }\n         self.take().unwrap()\n     }\n \n-    /**\n-     * Gets the value out of an option, printing a specified message on\n-     * failure\n-     *\n-     * # Failure\n-     *\n-     * Fails if the value equals `None`\n-     */\n+    ///  Gets the value out of an option, printing a specified message on\n+    ///  failure\n+    ///\n+    ///  # Failure\n+    ///\n+    ///  Fails if the value equals `None`\n     #[inline]\n     pub fn expect(self, reason: &str) -> T {\n         match self {\n-          Some(val) => val,\n-          None => fail!(reason.to_owned()),\n+            Some(val) => val,\n+            None => fail!(reason.to_owned()),\n         }\n     }\n \n-    /**\n-    Gets the value out of an option\n-\n-    # Failure\n-\n-    Fails if the value equals `None`\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged\n-    (calling `get` on `None` is akin to dereferencing a null pointer).\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-    */\n+    /// Returns the contained value or a default\n     #[inline]\n-    pub fn get(self) -> T {\n+    pub fn unwrap_or_default(self, def: T) -> T {\n         match self {\n-          Some(x) => return x,\n-          None => fail!(\"option::get `None`\")\n+            Some(x) => x,\n+            None => def\n         }\n     }\n \n-    /// Returns the contained value or a default\n-    #[inline]\n-    pub fn get_or_default(self, def: T) -> T {\n-        match self { Some(x) => x, None => def }\n-    }\n-\n     /// Applies a function zero or more times until the result is `None`.\n     #[inline]\n     pub fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n@@ -395,47 +388,40 @@ impl<T> Option<T> {\n impl<T:Zero> Option<T> {\n     /// Returns the contained value or zero (for this type)\n     #[inline]\n-    pub fn get_or_zero(self) -> T {\n+    pub fn unwrap_or_zero(self) -> T {\n         match self {\n             Some(x) => x,\n             None => Zero::zero()\n         }\n     }\n+\n+    /// Returns self or `Some(zero)` (for this type)\n+    #[inline]\n+    pub fn or_zero(self) -> Option<T> {\n+        match self {\n+            None => Some(Zero::zero()),\n+            x => x\n+        }\n+    }\n }\n \n impl<T> Zero for Option<T> {\n     fn zero() -> Option<T> { None }\n     fn is_zero(&self) -> bool { self.is_none() }\n }\n \n-/// Immutable iterator over an `Option<A>`\n-pub struct OptionIterator<'self, A> {\n-    priv opt: Option<&'self A>\n+/// An iterator that yields either one or zero elements\n+pub struct OptionIterator<A> {\n+    priv opt: Option<A>\n }\n \n-impl<'self, A> Iterator<&'self A> for OptionIterator<'self, A> {\n-    fn next(&mut self) -> Option<&'self A> {\n-        util::replace(&mut self.opt, None)\n-    }\n-\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        match self.opt {\n-            Some(_) => (1, Some(1)),\n-            None => (0, Some(0)),\n-        }\n-    }\n-}\n-\n-/// Mutable iterator over an `Option<A>`\n-pub struct OptionMutIterator<'self, A> {\n-    priv opt: Option<&'self mut A>\n-}\n-\n-impl<'self, A> Iterator<&'self mut A> for OptionMutIterator<'self, A> {\n-    fn next(&mut self) -> Option<&'self mut A> {\n-        util::replace(&mut self.opt, None)\n+impl<A> Iterator<A> for OptionIterator<A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        self.opt.take()\n     }\n \n+    #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         match self.opt {\n             Some(_) => (1, Some(1)),\n@@ -450,7 +436,7 @@ mod tests {\n     use util;\n \n     #[test]\n-    fn test_unwrap_ptr() {\n+    fn test_get_ptr() {\n         unsafe {\n             let x = ~0;\n             let addr_x: *int = ::cast::transmute(&*x);\n@@ -462,7 +448,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_unwrap_str() {\n+    fn test_get_str() {\n         let x = ~\"test\";\n         let addr_x = x.as_imm_buf(|buf, _len| buf);\n         let opt = Some(x);\n@@ -472,7 +458,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_unwrap_resource() {\n+    fn test_get_resource() {\n         struct R {\n            i: @mut int,\n         }\n@@ -530,18 +516,18 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_get_or_zero() {\n+    fn test_unwrap_or_zero() {\n         let some_stuff = Some(42);\n-        assert_eq!(some_stuff.get_or_zero(), 42);\n+        assert_eq!(some_stuff.unwrap_or_zero(), 42);\n         let no_stuff: Option<int> = None;\n-        assert_eq!(no_stuff.get_or_zero(), 0);\n+        assert_eq!(no_stuff.unwrap_or_zero(), 0);\n     }\n \n     #[test]\n     fn test_filtered() {\n         let some_stuff = Some(42);\n         let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n-        assert_eq!(some_stuff.get(), 42);\n+        assert_eq!(some_stuff.unwrap(), 42);\n         assert!(modified_stuff.is_none());\n     }\n "}, {"sha": "1f63a7c60414771b11a1183dfdba6a7726d82c16", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -574,15 +574,15 @@ pub fn tmpdir() -> Path {\n \n     #[cfg(unix)]\n     fn lookup() -> Path {\n-        getenv_nonempty(\"TMPDIR\").get_or_default(Path(\"/tmp\"))\n+        getenv_nonempty(\"TMPDIR\").unwrap_or_default(Path(\"/tmp\"))\n     }\n \n     #[cfg(windows)]\n     fn lookup() -> Path {\n         getenv_nonempty(\"TMP\").or(\n             getenv_nonempty(\"TEMP\").or(\n                 getenv_nonempty(\"USERPROFILE\").or(\n-                   getenv_nonempty(\"WINDIR\")))).get_or_default(Path(\"C:\\\\Windows\"))\n+                   getenv_nonempty(\"WINDIR\")))).unwrap_or_default(Path(\"C:\\\\Windows\"))\n     }\n }\n \n@@ -1788,7 +1788,7 @@ mod tests {\n     fn test_self_exe_path() {\n         let path = os::self_exe_path();\n         assert!(path.is_some());\n-        let path = path.get();\n+        let path = path.unwrap();\n         debug!(path.clone());\n \n         // Hard to test this function"}, {"sha": "a9e2e4c81a9b6653fa0993550372a575b11a0338", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -12,6 +12,7 @@\n \n use cast;\n use clone::Clone;\n+use iterator::{range, Iterator};\n use option::{Option, Some, None};\n use unstable::intrinsics;\n use util::swap;\n@@ -20,7 +21,6 @@ use util::swap;\n #[cfg(not(test))] use num::Int;\n \n #[cfg(not(test))] use cmp::{Eq, Ord};\n-use uint;\n \n /// Calculate the offset from a pointer\n #[inline]\n@@ -240,11 +240,10 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: &fn(*T)) {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }\n     //let start_ptr = *arr;\n-    uint::iterate(0, len, |e| {\n+    for e in range(0, len) {\n         let n = offset(arr, e as int);\n         cb(*n);\n-        true\n-    });\n+    }\n     debug!(\"array_each_with_len: after iterate\");\n }\n "}, {"sha": "4ef524d77152bb224021d3ef7dc3b8a8e253906c", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -533,7 +533,7 @@ impl<R: Rng> RngUtil for R {\n \n     /// Choose an item randomly, failing if values is empty\n     fn choose<T:Clone>(&mut self, values: &[T]) -> T {\n-        self.choose_option(values).get()\n+        self.choose_option(values).unwrap()\n     }\n \n     /// Choose Some(item) randomly, returning None if values is empty\n@@ -549,7 +549,7 @@ impl<R: Rng> RngUtil for R {\n      * the weights is 0\n      */\n     fn choose_weighted<T:Clone>(&mut self, v: &[Weighted<T>]) -> T {\n-        self.choose_weighted_option(v).get()\n+        self.choose_weighted_option(v).unwrap()\n     }\n \n     /**"}, {"sha": "91f42edf0aecd46e33efafc41fa7fccf43032be4", "filename": "src/libstd/result.rs", "status": "modified", "additions": 166, "deletions": 191, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -16,27 +16,31 @@ use clone::Clone;\n use cmp::Eq;\n use either;\n use iterator::Iterator;\n-use option::{None, Option, Some};\n+use option::{None, Option, Some, OptionIterator};\n use vec;\n use vec::{OwnedVector, ImmutableVector};\n use container::Container;\n-\n-/// The result type\n+use to_str::ToStr;\n+use str::StrSlice;\n+\n+/// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n+///\n+/// In order to provide informative error messages, `E` is reqired to implement `ToStr`.\n+/// It is further recommended for `E` to be a descriptive error type, eg a `enum` for\n+/// all possible errors cases.\n #[deriving(Clone, Eq)]\n-pub enum Result<T, U> {\n+pub enum Result<T, E> {\n     /// Contains the successful result value\n     Ok(T),\n     /// Contains the error value\n-    Err(U)\n+    Err(E)\n }\n \n-impl<T, E> Result<T, E> {\n-    /**\n-     * Convert to the `either` type\n-     *\n-     * `Ok` result variants are converted to `either::Right` variants, `Err`\n-     * result variants are converted to `either::Left`.\n-     */\n+impl<T, E: ToStr> Result<T, E> {\n+    /// Convert to the `either` type\n+    ///\n+    /// `Ok` result variants are converted to `either::Right` variants, `Err`\n+    /// result variants are converted to `either::Left`.\n     #[inline]\n     pub fn to_either(self)-> either::Either<E, T>{\n         match self {\n@@ -45,18 +49,16 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /**\n-     * Get a reference to the value out of a successful result\n-     *\n-     * # Failure\n-     *\n-     * If the result is an error\n-     */\n+    /// Get a reference to the value out of a successful result\n+    ///\n+    /// # Failure\n+    ///\n+    /// If the result is an error\n     #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n             Ok(ref t) => t,\n-            Err(ref e) => fail!(\"get_ref called on `Err` result: %?\", *e),\n+            Err(ref e) => fail!(\"called `Result::get_ref()` on `Err` value: %s\", e.to_str()),\n         }\n     }\n \n@@ -75,76 +77,90 @@ impl<T, E> Result<T, E> {\n         !self.is_ok()\n     }\n \n-    /**\n-     * Call a method based on a previous result\n-     *\n-     * If `self` is `Ok` then the value is extracted and passed to `op`\n-     * whereupon `op`s result is returned. if `self` is `Err` then it is\n-     * immediately returned. This function can be used to compose the results\n-     * of two functions.\n-     *\n-     * Example:\n-     *\n-     *     do read_file(file).iter |buf| {\n-     *         print_buf(buf)\n-     *     }\n-     */\n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Ok` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is returned. if `self` is `Err` then it is\n+    /// immediately returned. This function can be used to compose the results\n+    /// of two functions.\n+    ///\n+    /// Example:\n+    ///\n+    ///     for buf in read_file(file) {\n+    ///         print_buf(buf)\n+    ///     }\n     #[inline]\n-    pub fn iter(&self, f: &fn(&T)) {\n+    pub fn iter<'r>(&'r self) -> OptionIterator<&'r T> {\n         match *self {\n-            Ok(ref t) => f(t),\n-            Err(_) => (),\n-        }\n+            Ok(ref t) => Some(t),\n+            Err(*) => None,\n+        }.consume()\n     }\n \n-    /**\n-     * Call a method based on a previous result\n-     *\n-     * If `self` is `Err` then the value is extracted and passed to `op`\n-     * whereupon `op`s result is returned. if `self` is `Ok` then it is\n-     * immediately returned.  This function can be used to pass through a\n-     * successful result while handling an error.\n-     */\n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Err` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is returned. if `self` is `Ok` then it is\n+    /// immediately returned.  This function can be used to pass through a\n+    /// successful result while handling an error.\n     #[inline]\n-    pub fn iter_err(&self, f: &fn(&E)) {\n+    pub fn iter_err<'r>(&'r self) -> OptionIterator<&'r E> {\n         match *self {\n-            Ok(_) => (),\n-            Err(ref e) => f(e),\n-        }\n+            Ok(*) => None,\n+            Err(ref t) => Some(t),\n+        }.consume()\n     }\n \n-    /// Unwraps a result, assuming it is an `Ok(T)`\n+    /// Unwraps a result, yielding the content of an `Ok`.\n+    /// Fails if the value is a `Err` with an error message derived\n+    /// from `E`'s `ToStr` implementation.\n     #[inline]\n     pub fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(_) => fail!(\"unwrap called on an `Err` result\"),\n+            Err(e) => fail!(\"called `Result::unwrap()` on `Err` value: %s\", e.to_str()),\n         }\n     }\n \n-    /// Unwraps a result, assuming it is an `Err(U)`\n+    /// Unwraps a result, yielding the content of an `Err`.\n+    /// Fails if the value is a `Ok`.\n     #[inline]\n     pub fn unwrap_err(self) -> E {\n+        self.expect_err(\"called `Result::unwrap_err()` on `Ok` value\")\n+    }\n+\n+    /// Unwraps a result, yielding the content of an `Ok`.\n+    /// Fails if the value is a `Err` with a custom failure message.\n+    #[inline]\n+    pub fn expect(self, reason: &str) -> T {\n+        match self {\n+            Ok(t) => t,\n+            Err(_) => fail!(reason.to_owned()),\n+        }\n+    }\n+\n+    /// Unwraps a result, yielding the content of an `Err`\n+    /// Fails if the value is a `Ok` with a custom failure message.\n+    #[inline]\n+    pub fn expect_err(self, reason: &str) -> E {\n         match self {\n             Err(e) => e,\n-            Ok(_) => fail!(\"unwrap called on an `Ok` result\"),\n+            Ok(_) => fail!(reason.to_owned()),\n         }\n     }\n \n-    /**\n-     * Call a method based on a previous result\n-     *\n-     * If `self` is `Ok` then the value is extracted and passed to `op`\n-     * whereupon `op`s result is returned. if `self` is `Err` then it is\n-     * immediately returned. This function can be used to compose the results\n-     * of two functions.\n-     *\n-     * Example:\n-     *\n-     *     let res = do read_file(file) |buf| {\n-     *         Ok(parse_bytes(buf))\n-     *     };\n-     */\n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Ok` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is returned. if `self` is `Err` then it is\n+    /// immediately returned. This function can be used to compose the results\n+    /// of two functions.\n+    ///\n+    /// Example:\n+    ///\n+    ///     let res = do read_file(file) |buf| {\n+    ///         Ok(parse_bytes(buf))\n+    ///     };\n     #[inline]\n     pub fn chain<U>(self, op: &fn(T) -> Result<U, E>) -> Result<U, E> {\n         match self {\n@@ -153,14 +169,12 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /**\n-     * Call a function based on a previous result\n-     *\n-     * If `self` is `Err` then the value is extracted and passed to `op`\n-     * whereupon `op`s result is returned. if `self` is `Ok` then it is\n-     * immediately returned.  This function can be used to pass through a\n-     * successful result while handling an error.\n-     */\n+    /// Call a function based on a previous result\n+    ///\n+    /// If `self` is `Err` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is returned. if `self` is `Ok` then it is\n+    /// immediately returned.  This function can be used to pass through a\n+    /// successful result while handling an error.\n     #[inline]\n     pub fn chain_err<F>(self, op: &fn(E) -> Result<T, F>) -> Result<T, F> {\n         match self {\n@@ -170,95 +184,73 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n-impl<T: Clone, E> Result<T, E> {\n-    /**\n-     * Get the value out of a successful result\n-     *\n-     * # Failure\n-     *\n-     * If the result is an error\n-     */\n-    #[inline]\n-    pub fn get(&self) -> T {\n-        match *self {\n-            Ok(ref t) => t.clone(),\n-            Err(ref e) => fail!(\"get called on `Err` result: %?\", *e),\n-        }\n-    }\n-\n-    /**\n-     * Call a method based on a previous result\n-     *\n-     * If `self` is `Err` then the value is extracted and passed to `op`\n-     * whereupon `op`s result is wrapped in an `Err` and returned. if `self` is\n-     * `Ok` then it is immediately returned.  This function can be used to pass\n-     * through a successful result while handling an error.\n-     */\n+impl<T: Clone, E: ToStr> Result<T, E> {\n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Err` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is wrapped in an `Err` and returned. if `self` is\n+    /// `Ok` then it is immediately returned.  This function can be used to pass\n+    /// through a successful result while handling an error.\n     #[inline]\n-    pub fn map_err<F:Clone>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n+    pub fn map_err<F: Clone>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n         match *self {\n             Ok(ref t) => Ok(t.clone()),\n             Err(ref e) => Err(op(e))\n         }\n     }\n }\n \n-impl<T, E: Clone> Result<T, E> {\n-    /**\n-     * Get the value out of an error result\n-     *\n-     * # Failure\n-     *\n-     * If the result is not an error\n-     */\n+impl<T, E: Clone + ToStr> Result<T, E> {\n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Ok` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is wrapped in `Ok` and returned. if `self` is\n+    /// `Err` then it is immediately returned.  This function can be used to\n+    /// compose the results of two functions.\n+    ///\n+    /// Example:\n+    ///\n+    ///     let res = do read_file(file).map |buf| {\n+    ///         parse_bytes(buf)\n+    ///     };\n     #[inline]\n-    pub fn get_err(&self) -> E {\n+    pub fn map<U>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n         match *self {\n-            Err(ref e) => e.clone(),\n-            Ok(_) => fail!(\"get_err called on `Ok` result\")\n+            Ok(ref t) => Ok(op(t)),\n+            Err(ref e) => Err(e.clone())\n         }\n     }\n+}\n \n-    /**\n-     * Call a method based on a previous result\n-     *\n-     * If `self` is `Ok` then the value is extracted and passed to `op`\n-     * whereupon `op`s result is wrapped in `Ok` and returned. if `self` is\n-     * `Err` then it is immediately returned.  This function can be used to\n-     * compose the results of two functions.\n-     *\n-     * Example:\n-     *\n-     *     let res = do read_file(file).map |buf| {\n-     *         parse_bytes(buf)\n-     *     };\n-     */\n-    #[inline]\n-    pub fn map<U:Clone>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n-        match *self {\n-            Ok(ref t) => Ok(op(t)),\n-            Err(ref e) => Err(e.clone())\n+#[inline]\n+#[allow(missing_doc)]\n+pub fn map_opt<T, U: ToStr, V>(o_t: &Option<T>,\n+                               op: &fn(&T) -> Result<V,U>) -> Result<Option<V>,U> {\n+    match *o_t {\n+        None => Ok(None),\n+        Some(ref t) => match op(t) {\n+            Ok(v) => Ok(Some(v)),\n+            Err(e) => Err(e)\n         }\n     }\n }\n \n-/**\n- * Maps each element in the vector `ts` using the operation `op`.  Should an\n- * error occur, no further mappings are performed and the error is returned.\n- * Should no error occur, a vector containing the result of each map is\n- * returned.\n- *\n- * Here is an example which increments every integer in a vector,\n- * checking for overflow:\n- *\n- *     fn inc_conditionally(x: uint) -> result<uint,str> {\n- *         if x == uint::max_value { return Err(\"overflow\"); }\n- *         else { return Ok(x+1u); }\n- *     }\n- *     map(~[1u, 2u, 3u], inc_conditionally).chain {|incd|\n- *         assert!(incd == ~[2u, 3u, 4u]);\n- *     }\n- */\n+// FIXME: #8228 Replaceable by an external iterator?\n+/// Maps each element in the vector `ts` using the operation `op`.  Should an\n+/// error occur, no further mappings are performed and the error is returned.\n+/// Should no error occur, a vector containing the result of each map is\n+/// returned.\n+///\n+/// Here is an example which increments every integer in a vector,\n+/// checking for overflow:\n+///\n+///     fn inc_conditionally(x: uint) -> result<uint,str> {\n+///         if x == uint::max_value { return Err(\"overflow\"); }\n+///         else { return Ok(x+1u); }\n+///     }\n+///     map(~[1u, 2u, 3u], inc_conditionally).chain {|incd|\n+///         assert!(incd == ~[2u, 3u, 4u]);\n+///     }\n #[inline]\n pub fn map_vec<T,U,V>(ts: &[T], op: &fn(&T) -> Result<V,U>)\n                       -> Result<~[V],U> {\n@@ -272,36 +264,17 @@ pub fn map_vec<T,U,V>(ts: &[T], op: &fn(&T) -> Result<V,U>)\n     return Ok(vs);\n }\n \n+// FIXME: #8228 Replaceable by an external iterator?\n+/// Same as map, but it operates over two parallel vectors.\n+///\n+/// A precondition is used here to ensure that the vectors are the same\n+/// length.  While we do not often use preconditions in the standard\n+/// library, a precondition is used here because result::t is generally\n+/// used in 'careful' code contexts where it is both appropriate and easy\n+/// to accommodate an error like the vectors being of different lengths.\n #[inline]\n-#[allow(missing_doc)]\n-pub fn map_opt<T,\n-               U,\n-               V>(\n-               o_t: &Option<T>,\n-               op: &fn(&T) -> Result<V,U>)\n-               -> Result<Option<V>,U> {\n-    match *o_t {\n-        None => Ok(None),\n-        Some(ref t) => match op(t) {\n-            Ok(v) => Ok(Some(v)),\n-            Err(e) => Err(e)\n-        }\n-    }\n-}\n-\n-/**\n- * Same as map, but it operates over two parallel vectors.\n- *\n- * A precondition is used here to ensure that the vectors are the same\n- * length.  While we do not often use preconditions in the standard\n- * library, a precondition is used here because result::t is generally\n- * used in 'careful' code contexts where it is both appropriate and easy\n- * to accommodate an error like the vectors being of different lengths.\n- */\n-#[inline]\n-pub fn map_vec2<S,T,U,V>(ss: &[S], ts: &[T],\n-                op: &fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n-\n+pub fn map_vec2<S, T, U: ToStr, V>(ss: &[S], ts: &[T],\n+                                   op: &fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n     assert!(vec::same_length(ss, ts));\n     let n = ts.len();\n     let mut vs = vec::with_capacity(n);\n@@ -316,15 +289,13 @@ pub fn map_vec2<S,T,U,V>(ss: &[S], ts: &[T],\n     return Ok(vs);\n }\n \n-/**\n- * Applies op to the pairwise elements from `ss` and `ts`, aborting on\n- * error.  This could be implemented using `map_zip()` but it is more efficient\n- * on its own as no result vector is built.\n- */\n+// FIXME: #8228 Replaceable by an external iterator?\n+/// Applies op to the pairwise elements from `ss` and `ts`, aborting on\n+/// error.  This could be implemented using `map_zip()` but it is more efficient\n+/// on its own as no result vector is built.\n #[inline]\n-pub fn iter_vec2<S,T,U>(ss: &[S], ts: &[T],\n-                         op: &fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n-\n+pub fn iter_vec2<S, T, U: ToStr>(ss: &[S], ts: &[T],\n+                                 op: &fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n     assert!(vec::same_length(ss, ts));\n     let n = ts.len();\n     let mut i = 0u;\n@@ -353,32 +324,36 @@ mod tests {\n \n     #[test]\n     pub fn chain_success() {\n-        assert_eq!(op1().chain(op2).get(), 667u);\n+        assert_eq!(op1().chain(op2).unwrap(), 667u);\n     }\n \n     #[test]\n     pub fn chain_failure() {\n-        assert_eq!(op3().chain( op2).get_err(), ~\"sadface\");\n+        assert_eq!(op3().chain( op2).unwrap_err(), ~\"sadface\");\n     }\n \n     #[test]\n     pub fn test_impl_iter() {\n         let mut valid = false;\n-        Ok::<~str, ~str>(~\"a\").iter(|_x| valid = true);\n+        let okval = Ok::<~str, ~str>(~\"a\");\n+        do okval.iter().next().map |_| { valid = true; };\n         assert!(valid);\n \n-        Err::<~str, ~str>(~\"b\").iter(|_x| valid = false);\n+        let errval = Err::<~str, ~str>(~\"b\");\n+        do errval.iter().next().map |_| { valid = false; };\n         assert!(valid);\n     }\n \n     #[test]\n     pub fn test_impl_iter_err() {\n         let mut valid = true;\n-        Ok::<~str, ~str>(~\"a\").iter_err(|_x| valid = false);\n+        let okval = Ok::<~str, ~str>(~\"a\");\n+        do okval.iter_err().next().map |_| { valid = false };\n         assert!(valid);\n \n         valid = false;\n-        Err::<~str, ~str>(~\"b\").iter_err(|_x| valid = true);\n+        let errval = Err::<~str, ~str>(~\"b\");\n+        do errval.iter_err().next().map |_| { valid = true };\n         assert!(valid);\n     }\n "}, {"sha": "16bca850fd2894d0b32dacb92b1e33a73a84170d", "filename": "src/libstd/rt/io/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fflate.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Some various other I/O types\n \n-// NOTE: These ultimately belong somewhere else\n+// FIXME(#3660): should move to libextra\n \n use prelude::*;\n use super::*;\n@@ -115,7 +115,7 @@ mod test {\n         let mem_reader = MemReader::new(buf);\n         let mut inflate_reader = InflateReader::new(mem_reader);\n         let mut out_bytes = [0, .. 100];\n-        let bytes_read = inflate_reader.read(out_bytes).get();\n+        let bytes_read = inflate_reader.read(out_bytes).unwrap();\n         assert_eq!(bytes_read, in_bytes.len());\n         let out_msg = str::from_bytes(out_bytes);\n         assert!(in_msg == out_msg);"}, {"sha": "c980dc9d73efdc6546cf216b0368de4e5eb7e845", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -243,6 +243,8 @@ Out of scope\n */\n \n use prelude::*;\n+use to_str::ToStr;\n+use str::{StrSlice, OwnedStr};\n \n // Reexports\n pub use self::stdio::stdin;\n@@ -334,6 +336,20 @@ pub struct IoError {\n     detail: Option<~str>\n }\n \n+// FIXME: #8242 implementing manually because deriving doesn't work for some reason\n+impl ToStr for IoError {\n+    fn to_str(&self) -> ~str {\n+        let mut s = ~\"IoError { kind: \";\n+        s.push_str(self.kind.to_str());\n+        s.push_str(\", desc: \");\n+        s.push_str(self.desc);\n+        s.push_str(\", detail: \");\n+        s.push_str(self.detail.to_str());\n+        s.push_str(\" }\");\n+        s\n+    }\n+}\n+\n #[deriving(Eq)]\n pub enum IoErrorKind {\n     PreviousIoError,\n@@ -348,6 +364,24 @@ pub enum IoErrorKind {\n     BrokenPipe\n }\n \n+// FIXME: #8242 implementing manually because deriving doesn't work for some reason\n+impl ToStr for IoErrorKind {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            PreviousIoError => ~\"PreviousIoError\",\n+            OtherIoError => ~\"OtherIoError\",\n+            EndOfFile => ~\"EndOfFile\",\n+            FileNotFound => ~\"FileNotFound\",\n+            PermissionDenied => ~\"PermissionDenied\",\n+            ConnectionFailed => ~\"ConnectionFailed\",\n+            Closed => ~\"Closed\",\n+            ConnectionRefused => ~\"ConnectionRefused\",\n+            ConnectionReset => ~\"ConnectionReset\",\n+            BrokenPipe => ~\"BrokenPipe\"\n+        }\n+    }\n+}\n+\n // XXX: Can't put doc comments on macros\n // Raised by `I/O` operations on error.\n condition! {\n@@ -505,4 +539,4 @@ pub fn placeholder_error() -> IoError {\n         desc: \"Placeholder error. You shouldn't be seeing this\",\n         detail: None\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3372c13b87703a72cdef5af13fa5b651cc2379fc", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -193,6 +193,10 @@ impl BlockedTask {\n \n     /// Create a blocked task, unless the task was already killed.\n     pub fn try_block(mut task: ~Task) -> Either<~Task, BlockedTask> {\n+        // NB: As an optimization, we could give a free pass to being unkillable\n+        // to tasks whose taskgroups haven't been initialized yet, but that\n+        // introduces complications with select() and with the test cases below,\n+        // and it's not clear the uncommon performance boost is worth it.\n         if task.death.unkillable > 0 {\n             Right(Unkillable(task))\n         } else {\n@@ -205,11 +209,10 @@ impl BlockedTask {\n                 let flag_arc = match task.death.spare_kill_flag.take() {\n                     Some(spare_flag) => spare_flag,\n                     None => {\n-                        // FIXME(#7544): Uncomment this when terminate_current_task\n-                        // stops being *terrible*. That's the only place that violates\n-                        // the assumption of \"becoming unkillable will fail if the\n-                        // task was killed\".\n-                        // rtassert!(task.unwinder.unwinding);\n+                        // A task that kills us won't have a spare kill flag to\n+                        // give back to us, so we restore it ourselves here. This\n+                        // situation should only arise when we're already failing.\n+                        rtassert!(task.unwinder.unwinding);\n                         (*task.death.kill_handle.get_ref().get()).killed.clone()\n                     }\n                 };"}, {"sha": "760ca8a9adadcbae741cce4423728ffd6ea3e75e", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -365,7 +365,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n         rtdebug!(\"about to create the main scheduler task\");\n \n-        let mut main_sched = main_sched.get();\n+        let mut main_sched = main_sched.unwrap();\n \n         let home = Sched(main_sched.make_handle());\n         let mut main_task = ~Task::new_root_homed(&mut main_sched.stack_pool,"}, {"sha": "4c5e4bdc3c1d9b8b984642686428527ec1f40d38", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -465,10 +465,10 @@ mod test {\n         do run_in_newsched_task() {\n             static key: local_data::Key<@~str> = &local_data::Key;\n             local_data::set(key, @~\"data\");\n-            assert!(*local_data::get(key, |k| k.map(|&k| *k)).get() == ~\"data\");\n+            assert!(*local_data::get(key, |k| k.map(|&k| *k)).unwrap() == ~\"data\");\n             static key2: local_data::Key<@~str> = &local_data::Key;\n             local_data::set(key2, @~\"data\");\n-            assert!(*local_data::get(key2, |k| k.map(|&k| *k)).get() == ~\"data\");\n+            assert!(*local_data::get(key2, |k| k.map(|&k| *k)).unwrap() == ~\"data\");\n         }\n     }\n "}, {"sha": "8b5215ae9694aedc4d0549b1c8f184e14d00edb5", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -154,7 +154,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n \n     do run_in_bare_thread {\n         let nthreads = match os::getenv(\"RUST_RT_TEST_THREADS\") {\n-            Some(nstr) => FromStr::from_str(nstr).get(),\n+            Some(nstr) => FromStr::from_str(nstr).unwrap(),\n             None => {\n                 // Using more threads than cores in test code\n                 // to force the OS to preempt them frequently.\n@@ -362,7 +362,7 @@ pub fn stress_factor() -> uint {\n     use os::getenv;\n \n     match getenv(\"RUST_RT_STRESS\") {\n-        Some(val) => uint::from_str(val).get(),\n+        Some(val) => uint::from_str(val).unwrap(),\n         None => 1\n     }\n }"}, {"sha": "40e5c8d4bf1a088d7d470e768f35a61c1afd4645", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -31,7 +31,7 @@ pub fn num_cpus() -> uint {\n /// either `RUST_THREADS` or `num_cpus`.\n pub fn default_sched_threads() -> uint {\n     match os::getenv(\"RUST_THREADS\") {\n-        Some(nstr) => FromStr::from_str(nstr).get(),\n+        Some(nstr) => FromStr::from_str(nstr).unwrap(),\n         None => num_cpus()\n     }\n }\n@@ -118,4 +118,4 @@ pub fn get_exit_status() -> int {\n     extern {\n         fn rust_get_exit_status_newrt() -> libc::uintptr_t;\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "fd3042899f6bca5e28dadc366b1ed0e0208ea8d3", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -108,7 +108,7 @@ fn uv_socket_addr_as_socket_addr<T>(addr: UvSocketAddr, f: &fn(SocketAddr) -> T)\n                             \"\" => ~[],\n                             // IPv4-Mapped/Compatible IPv6 Address?\n                             s if s.find('.').is_some() => {\n-                                let i = s.rfind(':').get_or_default(-1);\n+                                let i = s.rfind(':').unwrap_or_default(-1);\n \n                                 let b = s.slice(i + 1, s.len()); // the ipv4 part\n \n@@ -614,7 +614,7 @@ mod test {\n             do tcp_watcher.connect(addr) |stream_watcher, status| {\n                 rtdebug!(\"tcp_watcher.connect!\");\n                 assert!(status.is_some());\n-                assert_eq!(status.get().name(), ~\"ECONNREFUSED\");\n+                assert_eq!(status.unwrap().name(), ~\"ECONNREFUSED\");\n                 stream_watcher.close(||());\n             }\n             loop_.run();\n@@ -632,7 +632,7 @@ mod test {\n             do tcp_watcher.connect(addr) |stream_watcher, status| {\n                 rtdebug!(\"tcp_watcher.connect!\");\n                 assert!(status.is_some());\n-                assert_eq!(status.get().name(), ~\"ECONNREFUSED\");\n+                assert_eq!(status.unwrap().name(), ~\"ECONNREFUSED\");\n                 stream_watcher.close(||());\n             }\n             loop_.run();"}, {"sha": "038ebad3540aecd29657474dffaacaaf8a2ab365", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -278,7 +278,7 @@ impl IoFactory for UvIoFactory {\n                     rtdebug!(\"status is some\");\n                     let task_cell = Cell::new(task_cell.take());\n                     do stream_watcher.close {\n-                        let res = Err(uv_error_to_io_error(status.get()));\n+                        let res = Err(uv_error_to_io_error(status.unwrap()));\n                         unsafe { (*result_cell_ptr).put_back(res); }\n                         let scheduler = Local::take::<Scheduler>();\n                         scheduler.resume_blocked_task_immediately(task_cell.take());"}, {"sha": "7c3a3ca8619ea621ae8c5e93710a8ca8bc9dcb7d", "filename": "src/libstd/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -59,7 +59,7 @@ pub fn from_bytes(vv: &[u8]) -> ~str {\n     use str::not_utf8::cond;\n \n     if !is_utf8(vv) {\n-        let first_bad_byte = *vv.iter().find_(|&b| !is_utf8([*b])).get();\n+        let first_bad_byte = *vv.iter().find_(|&b| !is_utf8([*b])).unwrap();\n         cond.raise(fmt!(\"from_bytes: input is not UTF-8; first bad byte is %u\",\n                         first_bad_byte as uint))\n     } else {\n@@ -76,7 +76,7 @@ pub fn from_bytes_owned(vv: ~[u8]) -> ~str {\n     use str::not_utf8::cond;\n \n     if !is_utf8(vv) {\n-        let first_bad_byte = *vv.iter().find_(|&b| !is_utf8([*b])).get();\n+        let first_bad_byte = *vv.iter().find_(|&b| !is_utf8([*b])).unwrap();\n         cond.raise(fmt!(\"from_bytes: input is not UTF-8; first bad byte is %u\",\n                         first_bad_byte as uint))\n     } else {\n@@ -1029,7 +1029,7 @@ pub mod raw {\n     /// If end is greater than the length of the string.\n     #[cfg(stage0)]\n     #[inline]\n-    pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> &str {\n+    pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n         do s.as_imm_buf |sbuf, n| {\n              assert!((begin <= end));\n              assert!((end <= n));"}, {"sha": "225a4b8cfd294eacb0fddb4ad2b5058b5dd0edab", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -926,7 +926,7 @@ fn test_named_task() {\n         t.name(~\"ada lovelace\");\n         do t.spawn {\n             do with_task_name |name| {\n-                assert!(name.get() == \"ada lovelace\");\n+                assert!(name.unwrap() == \"ada lovelace\");\n             }\n         }\n     }"}, {"sha": "527b20b0e9027312afc5d66244365fa54b5cb28f", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 59, "deletions": 45, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -568,7 +568,8 @@ impl RuntimeGlue {\n                 let me = Local::unsafe_borrow::<Task>();\n                 blk(match (*me).taskgroup {\n                     None => {\n-                        // Main task, doing first spawn ever. Lazily initialize.\n+                        // First task in its (unlinked/unsupervised) taskgroup.\n+                        // Lazily initialize.\n                         let mut members = TaskSet::new();\n                         let my_handle = (*me).death.kill_handle.get_ref().clone();\n                         members.insert(NewTask(my_handle));\n@@ -591,37 +592,46 @@ impl RuntimeGlue {\n     }\n }\n \n+// Returns 'None' in the case where the child's TG should be lazily initialized.\n fn gen_child_taskgroup(linked: bool, supervised: bool)\n-    -> (TaskGroupArc, AncestorList, bool) {\n-    do RuntimeGlue::with_my_taskgroup |spawner_group| {\n-        let ancestors = AncestorList(spawner_group.ancestors.map(|x| x.clone()));\n-        if linked {\n-            // Child is in the same group as spawner.\n-            // Child's ancestors are spawner's ancestors.\n-            // Propagate main-ness.\n-            (spawner_group.tasks.clone(), ancestors, spawner_group.is_main)\n-        } else {\n-            // Child is in a separate group from spawner.\n-            let g = Exclusive::new(Some(TaskGroupData {\n-                members:     TaskSet::new(),\n-                descendants: TaskSet::new(),\n-            }));\n-            let a = if supervised {\n-                let new_generation = incr_generation(&ancestors);\n-                assert!(new_generation < uint::max_value);\n-                // Child's ancestors start with the spawner.\n-                // Build a new node in the ancestor list.\n-                AncestorList(Some(Exclusive::new(AncestorNode {\n-                    generation: new_generation,\n-                    parent_group: spawner_group.tasks.clone(),\n-                    ancestors: ancestors,\n-                })))\n+    -> Option<(TaskGroupArc, AncestorList, bool)> {\n+    // FIXME(#7544): Not safe to lazily initialize in the old runtime. Remove\n+    // this context check once 'spawn_raw_oldsched' is gone.\n+    if context() == OldTaskContext || linked || supervised {\n+        // with_my_taskgroup will lazily initialize the parent's taskgroup if\n+        // it doesn't yet exist. We don't want to call it in the unlinked case.\n+        do RuntimeGlue::with_my_taskgroup |spawner_group| {\n+            let ancestors = AncestorList(spawner_group.ancestors.map(|x| x.clone()));\n+            if linked {\n+                // Child is in the same group as spawner.\n+                // Child's ancestors are spawner's ancestors.\n+                // Propagate main-ness.\n+                Some((spawner_group.tasks.clone(), ancestors, spawner_group.is_main))\n             } else {\n-                // Child has no ancestors.\n-                AncestorList(None)\n-            };\n-            (g, a, false)\n+                // Child is in a separate group from spawner.\n+                let g = Exclusive::new(Some(TaskGroupData {\n+                    members:     TaskSet::new(),\n+                    descendants: TaskSet::new(),\n+                }));\n+                let a = if supervised {\n+                    let new_generation = incr_generation(&ancestors);\n+                    assert!(new_generation < uint::max_value);\n+                    // Child's ancestors start with the spawner.\n+                    // Build a new node in the ancestor list.\n+                    AncestorList(Some(Exclusive::new(AncestorNode {\n+                        generation: new_generation,\n+                        parent_group: spawner_group.tasks.clone(),\n+                        ancestors: ancestors,\n+                    })))\n+                } else {\n+                    // Child has no ancestors.\n+                    AncestorList(None)\n+                };\n+                Some((g, a, false))\n+            }\n         }\n+    } else {\n+        None\n     }\n }\n \n@@ -670,20 +680,24 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n \n     let child_wrapper: ~fn() = || {\n         // Child task runs this code.\n-        let child_data = Cell::new(child_data.take()); // :(\n-        let enlist_success = do Local::borrow::<Task, bool> |me| {\n-            let (child_tg, ancestors, is_main) = child_data.take();\n-            let mut ancestors = ancestors;\n-            // FIXME(#7544): Optimize out the xadd in this clone, somehow.\n-            let handle = me.death.kill_handle.get_ref().clone();\n-            // Atomically try to get into all of our taskgroups.\n-            if enlist_many(NewTask(handle), &child_tg, &mut ancestors) {\n-                // Got in. We can run the provided child body, and can also run\n-                // the taskgroup's exit-time-destructor afterward.\n-                me.taskgroup = Some(Taskgroup(child_tg, ancestors, is_main, None));\n-                true\n-            } else {\n-                false\n+\n+        // If child data is 'None', the enlist is vacuously successful.\n+        let enlist_success = do child_data.take().map_consume_default(true) |child_data| {\n+            let child_data = Cell::new(child_data); // :(\n+            do Local::borrow::<Task, bool> |me| {\n+                let (child_tg, ancestors, is_main) = child_data.take();\n+                let mut ancestors = ancestors;\n+                // FIXME(#7544): Optimize out the xadd in this clone, somehow.\n+                let handle = me.death.kill_handle.get_ref().clone();\n+                // Atomically try to get into all of our taskgroups.\n+                if enlist_many(NewTask(handle), &child_tg, &mut ancestors) {\n+                    // Got in. We can run the provided child body, and can also run\n+                    // the taskgroup's exit-time-destructor afterward.\n+                    me.taskgroup = Some(Taskgroup(child_tg, ancestors, is_main, None));\n+                    true\n+                } else {\n+                    false\n+                }\n             }\n         };\n         // Should be run after the local-borrowed task is returned.\n@@ -749,7 +763,7 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n                 let join_task = join_task_cell.take();\n \n                 let bootstrap_task = ~do Task::new_root(&mut new_sched.stack_pool) || {\n-                    rtdebug!(\"boostraping a 1:1 scheduler\");\n+                    rtdebug!(\"bootstrapping a 1:1 scheduler\");\n                 };\n                 new_sched.bootstrap(bootstrap_task);\n \n@@ -793,7 +807,7 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n \n     let (child_tg, ancestors, is_main) =\n-        gen_child_taskgroup(opts.linked, opts.supervised);\n+        gen_child_taskgroup(opts.linked, opts.supervised).expect(\"old runtime needs TG\");\n \n     unsafe {\n         let child_data = Cell::new((child_tg, ancestors, f));"}, {"sha": "6f61d29780f044307d048aff29d1ae0de826a547", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -14,6 +14,7 @@ use prelude::*;\n use iterator::{IteratorUtil, FromIterator, Extendable};\n use uint;\n use util::{swap, replace};\n+use vec;\n \n // FIXME: #5244: need to manually update the TrieNode constructor\n static SHIFT: uint = 4;\n@@ -146,6 +147,15 @@ impl<T> TrieMap<T> {\n     pub fn each_value_reverse(&self, f: &fn(&T) -> bool) -> bool {\n         self.each_reverse(|_, v| f(v))\n     }\n+\n+    /// Get an iterator over the key-value pairs in the map\n+    pub fn iter<'a>(&'a self) -> TrieMapIterator<'a, T> {\n+        TrieMapIterator {\n+            stack: ~[self.root.children.iter()],\n+            remaining_min: self.length,\n+            remaining_max: self.length\n+        }\n+    }\n }\n \n impl<T, Iter: Iterator<(uint, T)>> FromIterator<(uint, T), Iter> for TrieMap<T> {\n@@ -217,6 +227,12 @@ impl TrieSet {\n     pub fn each_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n         self.map.each_key_reverse(f)\n     }\n+\n+    /// Get an iterator over the values in the set\n+    #[inline]\n+    pub fn iter<'a>(&'a self) -> TrieSetIterator<'a> {\n+        TrieSetIterator{iter: self.map.iter()}\n+    }\n }\n \n impl<Iter: Iterator<uint>> FromIterator<uint, Iter> for TrieSet {\n@@ -366,6 +382,61 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n     return ret;\n }\n \n+/// Forward iterator over a map\n+pub struct TrieMapIterator<'self, T> {\n+    priv stack: ~[vec::VecIterator<'self, Child<T>>],\n+    priv remaining_min: uint,\n+    priv remaining_max: uint\n+}\n+\n+impl<'self, T> Iterator<(uint, &'self T)> for TrieMapIterator<'self, T> {\n+    fn next(&mut self) -> Option<(uint, &'self T)> {\n+        while !self.stack.is_empty() {\n+            match self.stack[self.stack.len() - 1].next() {\n+                None => {\n+                    self.stack.pop();\n+                }\n+                Some(ref child) => {\n+                    match **child {\n+                        Internal(ref node) => {\n+                            self.stack.push(node.children.iter());\n+                        }\n+                        External(key, ref value) => {\n+                            self.remaining_max -= 1;\n+                            if self.remaining_min > 0 {\n+                                self.remaining_min -= 1;\n+                            }\n+                            return Some((key, value));\n+                        }\n+                        Nothing => {}\n+                    }\n+                }\n+            }\n+        }\n+        return None;\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.remaining_min, Some(self.remaining_max))\n+    }\n+}\n+\n+/// Forward iterator over a set\n+pub struct TrieSetIterator<'self> {\n+    priv iter: TrieMapIterator<'self, ()>\n+}\n+\n+impl<'self> Iterator<uint> for TrieSetIterator<'self> {\n+    fn next(&mut self) -> Option<uint> {\n+        do self.iter.next().map |&(key, _)| { key }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n #[cfg(test)]\n pub fn check_integrity<T>(trie: &TrieNode<T>) {\n     assert!(trie.count != 0);\n@@ -553,6 +624,29 @@ mod test_map {\n             assert_eq!(map.find(&k), Some(&v));\n         }\n     }\n+\n+    #[test]\n+    fn test_iteration() {\n+        let empty_map : TrieMap<uint> = TrieMap::new();\n+        assert_eq!(empty_map.iter().next(), None);\n+\n+        let first = uint::max_value - 10000;\n+        let last = uint::max_value;\n+\n+        let mut map = TrieMap::new();\n+        do uint::range_rev(last, first) |x| {\n+            map.insert(x, x / 2);\n+            true\n+        };\n+\n+        let mut i = 0;\n+        for (k, &v) in map.iter() {\n+            assert_eq!(k, first + i);\n+            assert_eq!(v, k / 2);\n+            i += 1;\n+        }\n+        assert_eq!(i, last - first);\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "0259b547ab3f06040f812deaa55144fbb5bded3e", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -195,10 +195,8 @@ pub fn build<A>(builder: &fn(push: &fn(v: A))) -> ~[A] {\n  *             onto the vector being constructed.\n  */\n #[inline]\n-pub fn build_sized_opt<A>(size: Option<uint>,\n-                          builder: &fn(push: &fn(v: A)))\n-                       -> ~[A] {\n-    build_sized(size.get_or_default(4), builder)\n+pub fn build_sized_opt<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> ~[A] {\n+    build_sized(size.unwrap_or_default(4), builder)\n }\n \n /// An iterator over the slices of a vector separated by elements that\n@@ -481,6 +479,7 @@ pub fn each_permutation<T:Clone>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n \n /// An iterator over the (overlapping) slices of length `size` within\n /// a vector.\n+#[deriving(Clone)]\n pub struct WindowIter<'self, T> {\n     priv v: &'self [T],\n     priv size: uint\n@@ -500,23 +499,60 @@ impl<'self, T> Iterator<&'self [T]> for WindowIter<'self, T> {\n \n /// An iterator over a vector in (non-overlapping) chunks (`size`\n /// elements at a time).\n+///\n+/// When the vector len is not evenly divided by the chunk size,\n+/// the last slice of the iteration will be the remainer.\n+#[deriving(Clone)]\n pub struct ChunkIter<'self, T> {\n     priv v: &'self [T],\n     priv size: uint\n }\n \n impl<'self, T> Iterator<&'self [T]> for ChunkIter<'self, T> {\n     fn next(&mut self) -> Option<&'self [T]> {\n-        if self.size == 0 {\n+        if self.v.len() == 0 {\n             None\n-        } else if self.size >= self.v.len() {\n-            // finished\n-            self.size = 0;\n-            Some(self.v)\n         } else {\n-            let ret = Some(self.v.slice(0, self.size));\n-            self.v = self.v.slice(self.size, self.v.len());\n-            ret\n+            let chunksz = cmp::min(self.v.len(), self.size);\n+            let (fst, snd) = (self.v.slice_to(chunksz),\n+                              self.v.slice_from(chunksz));\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+}\n+\n+impl<'self, T> DoubleEndedIterator<&'self [T]> for ChunkIter<'self, T> {\n+    fn next_back(&mut self) -> Option<&'self [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.size;\n+            let chunksz = if remainder != 0 { remainder } else { self.size };\n+            let (fst, snd) = (self.v.slice_to(self.v.len() - chunksz),\n+                              self.v.slice_from(self.v.len() - chunksz));\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+}\n+\n+impl<'self, T> RandomAccessIterator<&'self [T]> for ChunkIter<'self, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<&'self [T]> {\n+        if index < self.indexable() {\n+            let lo = index * self.size;\n+            let mut hi = lo + self.size;\n+            if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n+\n+            Some(self.v.slice(lo, hi))\n+        } else {\n+            None\n         }\n     }\n }\n@@ -3380,6 +3416,14 @@ mod tests {\n         assert_eq!(v.chunk_iter(2).collect::<~[&[int]]>(), ~[&[1i,2], &[3,4], &[5]]);\n         assert_eq!(v.chunk_iter(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[4,5]]);\n         assert_eq!(v.chunk_iter(6).collect::<~[&[int]]>(), ~[&[1i,2,3,4,5]]);\n+\n+        assert_eq!(v.chunk_iter(2).invert().collect::<~[&[int]]>(), ~[&[5i], &[3,4], &[1,2]]);\n+        let it = v.chunk_iter(2);\n+        assert_eq!(it.indexable(), 3);\n+        assert_eq!(it.idx(0).unwrap(), &[1,2]);\n+        assert_eq!(it.idx(1).unwrap(), &[3,4]);\n+        assert_eq!(it.idx(2).unwrap(), &[5]);\n+        assert_eq!(it.idx(3), None);\n     }\n \n     #[test]"}, {"sha": "883020e637a1b80bf81886c75c18e0af663504fd", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -280,13 +280,13 @@ impl ToStr for AbiSet {\n #[test]\n fn lookup_Rust() {\n     let abi = lookup(\"Rust\");\n-    assert!(abi.is_some() && abi.get().data().name == \"Rust\");\n+    assert!(abi.is_some() && abi.unwrap().data().name == \"Rust\");\n }\n \n #[test]\n fn lookup_cdecl() {\n     let abi = lookup(\"cdecl\");\n-    assert!(abi.is_some() && abi.get().data().name == \"cdecl\");\n+    assert!(abi.is_some() && abi.unwrap().data().name == \"cdecl\");\n }\n \n #[test]"}, {"sha": "435be3c71af6f08d1fc57d644341a354cb86ddb9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -24,7 +24,7 @@ use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n // table) and a SyntaxContext to track renaming and\n // macro expansion per Flatt et al., \"Macros\n // That Work Together\"\n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes, ToStr)]\n pub struct ident { name: Name, ctxt: SyntaxContext }\n \n /// Construct an identifier with the given name and an empty context:\n@@ -121,7 +121,7 @@ pub type CrateNum = int;\n \n pub type NodeId = int;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes, ToStr)]\n pub struct def_id {\n     crate: CrateNum,\n     node: NodeId,"}, {"sha": "6b4da9671a9636a02641804fc2a0cb3e23672125", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -466,11 +466,11 @@ pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n       Some(&node_local(ident)) => {\n         fmt!(\"local (id=%?, name=%s)\", id, itr.get(ident.name))\n       }\n-      Some(&node_block(_)) => {\n-        fmt!(\"block\")\n+      Some(&node_block(ref block)) => {\n+        fmt!(\"block %s (id=%?)\", pprust::block_to_str(block, itr), id)\n       }\n-      Some(&node_struct_ctor(*)) => {\n-        fmt!(\"struct_ctor\")\n+      Some(&node_struct_ctor(_, _, path)) => {\n+        fmt!(\"struct_ctor %s (id=%?)\", path_to_str(*path, itr), id)\n       }\n     }\n }"}, {"sha": "84e6544f78092b56ca51416548ae9b03c1c47947", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -410,7 +410,7 @@ impl IdVisitor {\n impl Visitor<()> for IdVisitor {\n     fn visit_mod(@mut self,\n                  module: &_mod,\n-                 span: span,\n+                 _span: span,\n                  node_id: NodeId,\n                  env: ()) {\n         (self.visit_callback)(node_id);"}, {"sha": "d39cb2f507ca957ae57d1ec7d45332487ddcfd88", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -114,7 +114,7 @@ impl AttributeMethods for Attribute {\n     /// non-sugared doc attributes.)\n     pub fn desugar_doc(&self) -> Attribute {\n         if self.node.is_sugared_doc {\n-            let comment = self.value_str().get();\n+            let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(@\"doc\",\n                                               strip_doc_comment_decoration(comment).to_managed());\n             mk_attr(meta)"}, {"sha": "8c70f128d9a09b82408950f3bba087b3189b7d5c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -369,12 +369,19 @@ impl CodeMap {\n         return @FileLines {file: lo.file, lines: lines};\n     }\n \n-    pub fn span_to_snippet(&self, sp: span) -> ~str {\n+    pub fn span_to_snippet(&self, sp: span) -> Option<~str> {\n         let begin = self.lookup_byte_offset(sp.lo);\n         let end = self.lookup_byte_offset(sp.hi);\n-        assert_eq!(begin.fm.start_pos, end.fm.start_pos);\n-        return begin.fm.src.slice(\n-                          begin.pos.to_uint(), end.pos.to_uint()).to_owned();\n+\n+        // FIXME #8256: this used to be an assert but whatever precondition\n+        // it's testing isn't true for all spans in the AST, so to allow the\n+        // caller to not have to fail (and it can't catch it since the CodeMap\n+        // isn't sendable), return None\n+        if begin.fm.start_pos != end.fm.start_pos {\n+            None\n+        } else {\n+            Some(begin.fm.src.slice( begin.pos.to_uint(), end.pos.to_uint()).to_owned())\n+        }\n     }\n \n     pub fn get_filemap(&self, filename: &str) -> @FileMap {"}, {"sha": "6ed5ca3e402a8dc4ac5e69ada83f9255c30bc75f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -538,20 +538,20 @@ mod test {\n         m.insert (@\"def\",@16);\n         // FIXME: #4492 (ICE)  assert_eq!(m.find(&@\"abc\"),Some(@15));\n         //  ....               assert_eq!(m.find(&@\"def\"),Some(@16));\n-        assert_eq!(*(m.find(&@\"abc\").get()),15);\n-        assert_eq!(*(m.find(&@\"def\").get()),16);\n+        assert_eq!(*(m.find(&@\"abc\").unwrap()),15);\n+        assert_eq!(*(m.find(&@\"def\").unwrap()),16);\n         let n = m.push_frame();\n         // old bindings are still present:\n-        assert_eq!(*(n.find(&@\"abc\").get()),15);\n-        assert_eq!(*(n.find(&@\"def\").get()),16);\n+        assert_eq!(*(n.find(&@\"abc\").unwrap()),15);\n+        assert_eq!(*(n.find(&@\"def\").unwrap()),16);\n         n.insert (@\"def\",@17);\n         // n shows the new binding\n-        assert_eq!(*(n.find(&@\"abc\").get()),15);\n-        assert_eq!(*(n.find(&@\"def\").get()),17);\n+        assert_eq!(*(n.find(&@\"abc\").unwrap()),15);\n+        assert_eq!(*(n.find(&@\"def\").unwrap()),17);\n         // ... but m still has the old ones\n         // FIXME: #4492: assert_eq!(m.find(&@\"abc\"),Some(@15));\n         // FIXME: #4492: assert_eq!(m.find(&@\"def\"),Some(@16));\n-        assert_eq!(*(m.find(&@\"abc\").get()),15);\n-        assert_eq!(*(m.find(&@\"def\").get()),16);\n+        assert_eq!(*(m.find(&@\"abc\").unwrap()),15);\n+        assert_eq!(*(m.find(&@\"def\").unwrap()),16);\n     }\n }"}, {"sha": "fb1e6bf1913844c878d9e3a36702fcb686d61807", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -961,7 +961,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n         let field_pats = do vec::build |push| {\n             for (&pat, &(id, _)) in subpats.iter().zip(ident_expr.iter()) {\n                 // id is guaranteed to be Some\n-                push(ast::field_pat { ident: id.get(), pat: pat })\n+                push(ast::field_pat { ident: id.unwrap(), pat: pat })\n             }\n         };\n         cx.pat_struct(span, matching_path, field_pats)"}, {"sha": "c7020b990bf005695341846d0b0ecd49f773fa0a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -1182,9 +1182,9 @@ mod test {\n         let a2_name = intern(\"a2\");\n         let renamer = new_ident_renamer(ast::ident{name:a_name,ctxt:empty_ctxt},\n                                         a2_name);\n-        let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).get();\n+        let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).unwrap();\n         let resolver = new_ident_resolver();\n-        let resolved_ast = fun_to_ident_folder(resolver).fold_item(renamed_ast).get();\n+        let resolved_ast = fun_to_ident_folder(resolver).fold_item(renamed_ast).unwrap();\n         let resolved_as_str = pprust::item_to_str(resolved_ast,\n                                                   get_ident_interner());\n         assert_eq!(resolved_as_str,~\"fn a2() -> int { let b = 13; b }\");"}, {"sha": "71903b9aa0204790fca3917dc093d553a67d8117", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -31,7 +31,7 @@ pub fn expand_line(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().get());\n+    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n \n     base::MRExpr(cx.expr_uint(topmost.call_site, loc.line))\n@@ -42,7 +42,7 @@ pub fn expand_col(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().get());\n+    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n     base::MRExpr(cx.expr_uint(topmost.call_site, loc.col.to_uint()))\n }\n@@ -54,7 +54,7 @@ pub fn expand_file(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().get());\n+    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n     let filename = loc.file.name;\n     base::MRExpr(cx.expr_str(topmost.call_site, filename))"}, {"sha": "a0932729930e3c7fcc3da3da356b6b23251b3efd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -691,7 +691,7 @@ impl Parser {\n         */\n \n         let opt_abis = self.parse_opt_abis();\n-        let abis = opt_abis.get_or_default(AbiSet::Rust());\n+        let abis = opt_abis.unwrap_or_default(AbiSet::Rust());\n         let purity = self.parse_unsafety();\n         self.expect_keyword(keywords::Fn);\n         let (decl, lifetimes) = self.parse_ty_fn_decl();\n@@ -3326,7 +3326,7 @@ impl Parser {\n         let ident = self.parse_ident();\n         let opt_bounds = self.parse_optional_ty_param_bounds();\n         // For typarams we don't care about the difference b/w \"<T>\" and \"<T:>\".\n-        let bounds = opt_bounds.get_or_default(opt_vec::Empty);\n+        let bounds = opt_bounds.unwrap_or_default(opt_vec::Empty);\n         ast::TyParam { ident: ident, id: self.get_id(), bounds: bounds }\n     }\n \n@@ -4196,7 +4196,7 @@ impl Parser {\n                 self.obsolete(*self.last_span, ObsoleteExternVisibility);\n             }\n \n-            let abis = opt_abis.get_or_default(AbiSet::C());\n+            let abis = opt_abis.unwrap_or_default(AbiSet::C());\n \n             let (inner, next) = self.parse_inner_attrs_and_next();\n             let m = self.parse_foreign_mod_items(sort, abis, next);\n@@ -4463,7 +4463,7 @@ impl Parser {\n \n             if self.eat_keyword(keywords::Fn) {\n                 // EXTERN FUNCTION ITEM\n-                let abis = opt_abis.get_or_default(AbiSet::C());\n+                let abis = opt_abis.unwrap_or_default(AbiSet::C());\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(extern_fn, abis);\n                 return iovi_item(self.mk_item(lo, self.last_span.hi, ident,"}, {"sha": "f517179f6036613e100e2ed9290820d934db96b8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -874,7 +874,7 @@ pub fn print_attribute(s: @ps, attr: &ast::Attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n     if attr.node.is_sugared_doc {\n-        let comment = attr.value_str().get();\n+        let comment = attr.value_str().unwrap();\n         word(s.s, comment);\n     } else {\n         word(s.s, \"#[\");\n@@ -1085,7 +1085,7 @@ pub fn print_call_post(s: @ps,\n     }\n     if sugar != ast::NoSugar {\n         nbsp(s);\n-        match blk.get().node {\n+        match blk.unwrap().node {\n           // need to handle closures specifically\n           ast::expr_do_body(e) => {\n             end(s); // we close our head box; closure\n@@ -1095,7 +1095,7 @@ pub fn print_call_post(s: @ps,\n           }\n           _ => {\n             // not sure if this can happen.\n-            print_expr(s, blk.get());\n+            print_expr(s, blk.unwrap());\n           }\n         }\n     }\n@@ -1323,13 +1323,13 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         assert!(body.stmts.is_empty());\n         assert!(body.expr.is_some());\n         // we extract the block, so as not to create another set of boxes\n-        match body.expr.get().node {\n+        match body.expr.unwrap().node {\n             ast::expr_block(ref blk) => {\n                 print_block_unclosed(s, blk);\n             }\n             _ => {\n                 // this is a bare expression\n-                print_expr(s, body.expr.get());\n+                print_expr(s, body.expr.unwrap());\n                 end(s); // need to close a box\n             }\n         }"}, {"sha": "cf160ca31c6f185d3ae38b5a06ef6edda527674d", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -100,7 +100,7 @@ fn main() {\n     let args = os::args();\n     let n_keys = {\n         if args.len() == 2 {\n-            uint::from_str(args[1]).get()\n+            uint::from_str(args[1]).unwrap()\n         } else {\n             1000000\n         }"}, {"sha": "4fbe00622aa26fdded3c4d32bf8a6d4b7f0824e3", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -159,7 +159,7 @@ fn main() {\n     let args = os::args();\n     let num_keys = {\n         if args.len() == 2 {\n-            uint::from_str(args[1]).get()\n+            uint::from_str(args[1]).unwrap()\n         } else {\n             100 // woefully inadequate for any real measurement\n         }"}, {"sha": "4a32fda59d81ad5cb4e15963083b73f361b97da7", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -21,7 +21,7 @@ fn main() {\n         args\n     };\n \n-    let n = uint::from_str(args[1]).get();\n+    let n = uint::from_str(args[1]).unwrap();\n \n     for i in range(0u, n) {\n         let x = uint::to_str(i);"}, {"sha": "2f4d763b84d778ab750446de95e447dd2b0cb122", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -418,8 +418,8 @@ fn main() {\n         args\n     };\n \n-    let scale = uint::from_str(args[1]).get();\n-    let num_keys = uint::from_str(args[2]).get();\n+    let scale = uint::from_str(args[1]).unwrap();\n+    let num_keys = uint::from_str(args[2]).unwrap();\n     let do_validate = false;\n     let do_sequential = true;\n "}, {"sha": "4e9656afb813d253c50713163bdc3cfa4f8eae7a", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -59,8 +59,8 @@ fn run(args: &[~str]) {\n \n     let to_child = SharedChan::new(to_child);\n \n-    let size = uint::from_str(args[1]).get();\n-    let workers = uint::from_str(args[2]).get();\n+    let size = uint::from_str(args[1]).unwrap();\n+    let workers = uint::from_str(args[2]).unwrap();\n     let num_bytes = 100;\n     let start = extra::time::precise_time_s();\n     let mut worker_results = ~[];"}, {"sha": "470e23d63a514ff81f8bbd419c4b32fab03ff927", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -53,8 +53,8 @@ fn run(args: &[~str]) {\n     let (from_parent, to_child) = stream();\n     let to_child = SharedChan::new(to_child);\n \n-    let size = uint::from_str(args[1]).get();\n-    let workers = uint::from_str(args[2]).get();\n+    let size = uint::from_str(args[1]).unwrap();\n+    let workers = uint::from_str(args[2]).unwrap();\n     let num_bytes = 100;\n     let start = extra::time::precise_time_s();\n     let mut worker_results = ~[];"}, {"sha": "7de95f4d822c54613a3f72064c3efb9b0778d02e", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -79,8 +79,8 @@ fn main() {\n         args.clone()\n     };\n \n-    let num_tasks = uint::from_str(args[1]).get();\n-    let msg_per_task = uint::from_str(args[2]).get();\n+    let num_tasks = uint::from_str(args[1]).unwrap();\n+    let msg_per_task = uint::from_str(args[2]).unwrap();\n \n     let (num_chan, num_port) = init();\n     let num_chan = Cell::new(num_chan);"}, {"sha": "1299e863db6b3f923274740bc443b65f5b802862", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -75,8 +75,8 @@ fn main() {\n         args.clone()\n     };\n \n-    let num_tasks = uint::from_str(args[1]).get();\n-    let msg_per_task = uint::from_str(args[2]).get();\n+    let num_tasks = uint::from_str(args[1]).unwrap();\n+    let msg_per_task = uint::from_str(args[2]).unwrap();\n \n     let (num_chan, num_port) = init();\n     let num_chan = Cell::new(num_chan);"}, {"sha": "e8659ba26d4bc878bd686b5f873ba7365bfe4bc8", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -35,6 +35,6 @@ fn main() {\n     } else {\n         args\n     };\n-    let n = int::from_str(args[1]).get();\n+    let n = int::from_str(args[1]).unwrap();\n     printfln!(\"Ack(3,%d): %d\\n\", n, ack(3, n));\n }"}, {"sha": "8a2ae3e89952007903431e6484d1e70af1d7c366", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -48,7 +48,7 @@ fn main() {\n         args\n     };\n \n-    let n = int::from_str(args[1]).get();\n+    let n = int::from_str(args[1]).unwrap();\n     let min_depth = 4;\n     let mut max_depth;\n     if min_depth + 2 > n {"}, {"sha": "190ad62d6e17ff771ecb81900a8cdd2767479a3b", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -212,7 +212,7 @@ fn main() {\n         args\n     };\n \n-    let nn = uint::from_str(args[1]).get();\n+    let nn = uint::from_str(args[1]).unwrap();\n \n     print_complements();\n     io::println(\"\");"}, {"sha": "9d4d31b8969205a3b0b7a911dd9648897c3d8214", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -91,6 +91,6 @@ fn fannkuch_redux(n: i32) -> i32 {\n \n #[fixed_stack_segment]\n fn main() {\n-    let n: i32 = FromStr::from_str(os::args()[1]).get();\n+    let n: i32 = FromStr::from_str(os::args()[1]).unwrap();\n     printfln!(\"Pfannkuchen(%d) = %d\", n as int, fannkuch_redux(n) as int);\n }"}, {"sha": "579b88a7e0e72c0231fb22f17a8c7a407cbfb83b", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -184,7 +184,7 @@ impl RandomFasta {\n \n #[fixed_stack_segment]\n fn main() {\n-    let n: uint = FromStr::from_str(os::args()[1]).get();\n+    let n: uint = FromStr::from_str(os::args()[1]).unwrap();\n \n     unsafe {\n         let mode = \"w\";"}, {"sha": "4e2ab8b0a498dce2b444fad63f81717b4015dd48", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -130,7 +130,7 @@ fn main() {\n         io::stdout()\n     };\n \n-    let n = int::from_str(args[1]).get();\n+    let n = int::from_str(args[1]).unwrap();\n \n     let iub: ~[AminoAcids] =\n         make_cumulative(~[acid('a', 27u32), acid('c', 12u32), acid('g', 12u32),"}, {"sha": "9c07df36eb3c1be3bf84a94a2f34dc11dd416bd4", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -31,6 +31,6 @@ fn main() {\n     } else {\n         args\n     };\n-    let n = int::from_str(args[1]).get();\n+    let n = int::from_str(args[1]).unwrap();\n     printfln!(\"%d\\n\", fib(n));\n }"}, {"sha": "cf43f470e7177d55e2fcf77b0c57061fc03d02a7", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -9,7 +9,7 @@ static LIMIT: f64 = 2.0;\n #[fixed_stack_segment]\n fn main() {\n     unsafe {\n-        let w: i32 = FromStr::from_str(os::args()[1]).get();\n+        let w: i32 = FromStr::from_str(os::args()[1]).unwrap();\n         let h = w;\n         let mut byte_acc: i8 = 0;\n         let mut bit_num: i32 = 0;"}, {"sha": "115607d0a992c14896d3d227799dee2dbc611bbf", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -137,7 +137,7 @@ fn offset_momentum(bodies: &mut [Planet, ..N_BODIES]) {\n }\n \n fn main() {\n-    let n: i32 = FromStr::from_str(os::args()[1]).get();\n+    let n: i32 = FromStr::from_str(os::args()[1]).unwrap();\n     let mut bodies = BODIES;\n \n     offset_momentum(&mut bodies);"}, {"sha": "611b11560e4ae8b0e8970b3d5a16bf73d66f9366", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -110,7 +110,7 @@ fn main() {\n     if opts.stress {\n         stress(2);\n     } else {\n-        let max = uint::parse_bytes(args[1].as_bytes(), 10u).get() as int;\n+        let max = uint::parse_bytes(args[1].as_bytes(), 10u).unwrap() as int;\n \n         let num_trials = 10;\n "}, {"sha": "aef22bc2b8426f056a4047abb81092e288f9ece6", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -52,7 +52,7 @@ fn mult_AtAv(v: &mut [f64], out: &mut [f64], tmp: &mut [f64]) {\n \n #[fixed_stack_segment]\n fn main() {\n-    let n: uint = FromStr::from_str(os::args()[1]).get();\n+    let n: uint = FromStr::from_str(os::args()[1]).unwrap();\n     let mut u = vec::from_elem(n, 1f64);\n     let mut v = u.clone();\n     let mut tmp = u.clone();"}, {"sha": "ace008c1f95d2164febe6451d5d3e3d98c6f5cd5", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -62,13 +62,13 @@ fn main() {\n         os::args()\n     };\n     let token = if args.len() > 1u {\n-        FromStr::from_str(args[1]).get()\n+        FromStr::from_str(args[1]).unwrap()\n     }\n     else {\n         1000\n     };\n     let n_tasks = if args.len() > 2u {\n-        FromStr::from_str(args[2]).get()\n+        FromStr::from_str(args[2]).unwrap()\n     }\n     else {\n         503"}, {"sha": "a035041a662dc73097c6a8bbd28430a6f99cc43a", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -39,8 +39,8 @@ fn main() {\n     } else {\n         args\n     };\n-    let max = uint::from_str(args[1]).get();\n-    let rep = uint::from_str(args[2]).get();\n+    let max = uint::from_str(args[1]).unwrap();\n+    let rep = uint::from_str(args[2]).unwrap();\n \n     let mut checkf = 0.0;\n     let mut appendf = 0.0;"}, {"sha": "675735408953403b49d6fd622a2cd906c0cd7eaa", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -75,9 +75,9 @@ impl Sudoku {\n             let comps: ~[&str] = line.trim().split_iter(',').collect();\n \n             if comps.len() == 3u {\n-                let row     = uint::from_str(comps[0]).get() as u8;\n-                let col     = uint::from_str(comps[1]).get() as u8;\n-                g[row][col] = uint::from_str(comps[2]).get() as u8;\n+                let row     = uint::from_str(comps[0]).unwrap() as u8;\n+                let col     = uint::from_str(comps[1]).unwrap() as u8;\n+                g[row][col] = uint::from_str(comps[2]).unwrap() as u8;\n             }\n             else {\n                 fail!(\"Invalid sudoku file\");"}, {"sha": "be7f9b5f43adfc22b75ad98e0e513408d9e3fb6e", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -52,7 +52,7 @@ fn main() {\n     };\n \n     let (p,c) = comm::stream();\n-    child_generation(uint::from_str(args[1]).get(), c);\n+    child_generation(uint::from_str(args[1]).unwrap(), c);\n     if p.try_recv().is_none() {\n         fail!(\"it happened when we slumbered\");\n     }"}, {"sha": "95dd803af8183221f00bbc21ee6a2c56bbabd3e9", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -71,7 +71,7 @@ fn main() {\n         args.clone()\n     };\n \n-    let num_tasks = uint::from_str(args[1]).get();\n+    let num_tasks = uint::from_str(args[1]).unwrap();\n \n     // Main group #0 waits for unsupervised group #1.\n     // Grandparent group #1 waits for middle group #2, then fails, killing #3."}, {"sha": "83116ae3c87deb07df1902da9201edb1ef55ea5e", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -31,7 +31,7 @@ fn main() {\n     } else {\n         args\n     };\n-    let n = uint::from_str(args[1]).get();\n+    let n = uint::from_str(args[1]).unwrap();\n     let mut i = 0u;\n     while i < n { task::spawn(|| f(n) ); i += 1u; }\n }"}, {"sha": "cb6290686816d74054a3e9923c9f4a862d628bd7", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -17,7 +17,7 @@ fn main() {\n         y = Some(x.downgrade(write_mode));\n         //~^ ERROR cannot infer an appropriate lifetime\n     }\n-    y.get();\n+    y.unwrap();\n     // Adding this line causes a method unification failure instead\n     // do (&option::unwrap(y)).read |state| { assert!(*state == 1); }\n }"}, {"sha": "75e1989aff01a5ad7faf55da8087bf89bda910cb", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -17,7 +17,7 @@ fn main() {\n     do x.write_downgrade |write_mode| {\n         y = Some(write_mode);\n     }\n-    y.get();\n+    y.unwrap();\n     // Adding this line causes a method unification failure instead\n     // do (&option::unwrap(y)).write |state| { assert!(*state == 1); }\n }"}, {"sha": "4f552bc8f4216468a8929cb78c44300bb225dcf4", "filename": "src/test/run-fail/result-get-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:get called on `Err` result: ~\"kitty\"\n+// error-pattern:called `Result::unwrap()` on `Err` value: kitty\n \n use std::result;\n \n fn main() {\n-  error!(result::Err::<int,~str>(~\"kitty\").get());\n+    error!(result::Err::<int,~str>(~\"kitty\").unwrap());\n }"}, {"sha": "668f602b3d35c941770d07d920c29f7c04bdab7a", "filename": "src/test/run-pass/borrowck-wg-borrow-mut-to-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -1,5 +1,5 @@\n fn g(x: &Option<int>) {\n-    println(x.get().to_str());\n+    println(x.unwrap().to_str());\n }\n \n fn f(x: &mut Option<int>) {"}, {"sha": "9f17b9d7f95b5811ed82a74dd3cae7b2ac877317", "filename": "src/test/run-pass/borrowed-ptr-pattern-option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-option.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -19,5 +19,5 @@ fn select<'r>(x: &'r Option<int>, y: &'r Option<int>) -> &'r Option<int> {\n pub fn main() {\n     let x = None;\n     let y = Some(3);\n-    assert_eq!(select(&x, &y).get(), 3);\n+    assert_eq!(select(&x, &y).unwrap(), 3);\n }"}, {"sha": "8af173150a06dceee7c93cddfbf1485c2ce9964d", "filename": "src/test/run-pass/option_addition.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Frun-pass%2Foption_addition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Frun-pass%2Foption_addition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foption_addition.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -9,29 +9,17 @@\n // except according to those terms.\n \n pub fn main() {\n-    let foo = 1;\n-    let bar = 2;\n+    let foo: int = 1;\n+    let bar: int = 2;\n     let foobar = foo + bar;\n \n-    let nope = optint(0) + optint(0);\n-    let somefoo = optint(foo) + optint(0);\n-    let somebar = optint(bar) + optint(0);\n-    let somefoobar = optint(foo) + optint(bar);\n+    let nope = None::<int> + None::<int>;\n+    let somefoo = Some(foo) + None::<int>;\n+    let somebar = None::<int> + Some(bar);\n+    let somefoobar = Some(foo) + Some(bar);\n \n-    match nope {\n-        None => (),\n-        Some(foo) => fail!(\"expected None, but found %?\", foo)\n-    }\n-    assert_eq!(foo, somefoo.get());\n-    assert_eq!(bar, somebar.get());\n-    assert_eq!(foobar, somefoobar.get());\n-}\n-\n-fn optint(input: int) -> Option<int> {\n-    if input == 0 {\n-        return None;\n-    }\n-    else {\n-        return Some(input);\n-    }\n+    assert_eq!(nope, None::<int>);\n+    assert_eq!(somefoo, None::<int>);\n+    assert_eq!(somebar, None::<int>);\n+    assert_eq!(foobar, somefoobar.unwrap());\n }"}, {"sha": "f5eb04dd83bfe3774c0466e33fd2820fdb9aac53", "filename": "src/test/run-pass/region-dependent-addr-of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs?ref=5eaa4d1d2f6eafc4233892d3d1dafb0d05799ac3", "patch": "@@ -105,13 +105,13 @@ pub fn main() {\n     assert_eq!(*p, a.value.v5.f);\n \n     let p = get_v6_a(&a, 1);\n-    assert_eq!(*p, a.value.v6.get().f);\n+    assert_eq!(*p, a.value.v6.unwrap().f);\n \n     let p = get_v6_b(&a, 1);\n-    assert_eq!(*p, a.value.v6.get().f);\n+    assert_eq!(*p, a.value.v6.unwrap().f);\n \n     let p = get_v6_c(&a, 1);\n-    assert_eq!(*p, a.value.v6.get().f);\n+    assert_eq!(*p, a.value.v6.unwrap().f);\n \n     let p = get_v5_ref(&a, 1);\n     assert_eq!(*p, a.value.v5.f);"}]}