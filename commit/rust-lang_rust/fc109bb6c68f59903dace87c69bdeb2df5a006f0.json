{"sha": "fc109bb6c68f59903dace87c69bdeb2df5a006f0", "node_id": "C_kwDOAAsO6NoAKGZjMTA5YmI2YzY4ZjU5OTAzZGFjZTg3YzY5YmRlYjJkZjVhMDA2ZjA", "commit": {"author": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2022-05-02T08:45:21Z"}, "committer": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2022-05-28T05:12:20Z"}, "message": "Avoid zero-sized allocs in ThinBox if T and H are both ZSTs.", "tree": {"sha": "4dcf009bc9093eb0a1dfa2817ce20a6e1bbe6d89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dcf009bc9093eb0a1dfa2817ce20a6e1bbe6d89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc109bb6c68f59903dace87c69bdeb2df5a006f0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0+qV0hta6XFe2D54u/UMJ4RyKgFAmKRrzQACgkQ4u/UMJ4R\nyKgupQ//VJAE872SON0+y1kzW3QdwFW6ONoFzV8dNfoVXJOa7btteaJilAIZiH/Q\n5M6p0VczsxOfuUZOzc5edxqojlnPePp8sxrVxeeDveX/6W9VAf02y/B5UWkPhg82\nXrrnnVAzlXvjqWKVNx5INmalqoZQTnzSHVu4CJKaYp55hrD6BSOcV+/UmiQNFAhY\n6+EDpTbwe+YhcloONaIN425ilyiWCRAsXumbx0hHRdiza5YR5DAuFL7DRBTuI2J5\n2WIpiTlYGnVDDjzknCvl8NyGSFPImS3Uu57ATcryr3ZVP86CCTrSYtvjIIucPZru\nGZpn6et0he3+iGVWV/rHi7w9SoG0S8xXjOrJMMCbVWJ3dktK3cgEC3puWdwMYR56\neR3KNQ1Rpvq2Sgg6OSmgFr98BIYLX7W5TstYttglvYDwSDw9xiElD1p128NVXC44\nX96Xs4TXVd+OGnwQeuUqZNCudRNWdi7JeP3x3nt8DyOuWl61ivuRe8fN5uszDpkV\n24LZIuRqDLTB1wU6+SgdPMlAOhhj07u+apNgxCWROaggoJU/FMV2bQYEiGtWdww2\ndqMse9gqEpqTRsUHDXMfsakKwMYBbxk5KyJB1z4D/l6N4ZqLv1LPej7houO4fXXb\nHeQ+Lw0cdG6yDgKp+UBNkJvZ7bIjgvtt3H+wVPPQkS8TAo5wTAc=\n=fWbB\n-----END PGP SIGNATURE-----", "payload": "tree 4dcf009bc9093eb0a1dfa2817ce20a6e1bbe6d89\nparent 764b8615e9149431d8790e3c07cb663642fe393d\nauthor Thom Chiovoloni <chiovolonit@gmail.com> 1651481121 -0700\ncommitter Thom Chiovoloni <chiovolonit@gmail.com> 1653714740 -0700\n\nAvoid zero-sized allocs in ThinBox if T and H are both ZSTs.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc109bb6c68f59903dace87c69bdeb2df5a006f0", "html_url": "https://github.com/rust-lang/rust/commit/fc109bb6c68f59903dace87c69bdeb2df5a006f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc109bb6c68f59903dace87c69bdeb2df5a006f0/comments", "author": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "764b8615e9149431d8790e3c07cb663642fe393d", "url": "https://api.github.com/repos/rust-lang/rust/commits/764b8615e9149431d8790e3c07cb663642fe393d", "html_url": "https://github.com/rust-lang/rust/commit/764b8615e9149431d8790e3c07cb663642fe393d"}], "stats": {"total": 297, "additions": 278, "deletions": 19}, "files": [{"sha": "703a28cf2de6cdfa4717778c354157fc97d53341", "filename": "library/alloc/src/boxed/thin.rs", "status": "modified", "additions": 46, "deletions": 19, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fc109bb6c68f59903dace87c69bdeb2df5a006f0/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc109bb6c68f59903dace87c69bdeb2df5a006f0/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs?ref=fc109bb6c68f59903dace87c69bdeb2df5a006f0", "patch": "@@ -138,7 +138,11 @@ impl<T: ?Sized> ThinBox<T> {\n     }\n }\n \n-/// A pointer to type-erased data, guaranteed to have a header `H` before the pointed-to location.\n+/// A pointer to type-erased data, guaranteed to either be:\n+/// 1. `NonNull::dangling()`, in the case where both the pointee (`T`) and\n+///    metadata (`H`) are ZSTs.\n+/// 2. A pointer to a valid `T` that has a header `H` directly before the\n+///    pointed-to location.\n struct WithHeader<H>(NonNull<u8>, PhantomData<H>);\n \n impl<H> WithHeader<H> {\n@@ -156,16 +160,27 @@ impl<H> WithHeader<H> {\n         };\n \n         unsafe {\n-            let ptr = alloc::alloc(layout);\n-\n-            if ptr.is_null() {\n-                alloc::handle_alloc_error(layout);\n-            }\n-            //  Safety:\n-            //  -   The size is at least `aligned_header_size`.\n-            let ptr = ptr.add(value_offset) as *mut _;\n-\n-            let ptr = NonNull::new_unchecked(ptr);\n+            // Note: It's UB to pass a layout with a zero size to `alloc::alloc`, so\n+            // we use `layout.dangling()` for this case, which should have a valid\n+            // alignment for both `T` and `H`.\n+            let ptr = if layout.size() == 0 {\n+                // Some paranoia checking, mostly so that the ThinBox tests are\n+                // more able to catch issues.\n+                debug_assert!(\n+                    value_offset == 0 && mem::size_of::<T>() == 0 && mem::size_of::<H>() == 0\n+                );\n+                layout.dangling()\n+            } else {\n+                let ptr = alloc::alloc(layout);\n+                if ptr.is_null() {\n+                    alloc::handle_alloc_error(layout);\n+                }\n+                // Safety:\n+                // - The size is at least `aligned_header_size`.\n+                let ptr = ptr.add(value_offset) as *mut _;\n+\n+                NonNull::new_unchecked(ptr)\n+            };\n \n             let result = WithHeader(ptr, PhantomData);\n             ptr::write(result.header(), header);\n@@ -175,18 +190,28 @@ impl<H> WithHeader<H> {\n         }\n     }\n \n-    //  Safety:\n-    //  -   Assumes that `value` can be dereferenced.\n+    // Safety:\n+    // - Assumes that either `value` can be dereferenced, or is the\n+    //   `NonNull::dangling()` we use when both `T` and `H` are ZSTs.\n     unsafe fn drop<T: ?Sized>(&self, value: *mut T) {\n         unsafe {\n+            let value_layout = Layout::for_value_raw(value);\n             // SAFETY: Layout must have been computable if we're in drop\n-            let (layout, value_offset) =\n-                Self::alloc_layout(Layout::for_value_raw(value)).unwrap_unchecked();\n+            let (layout, value_offset) = Self::alloc_layout(value_layout).unwrap_unchecked();\n \n-            ptr::drop_in_place::<T>(value);\n             // We only drop the value because the Pointee trait requires that the metadata is copy\n-            // aka trivially droppable\n-            alloc::dealloc(self.0.as_ptr().sub(value_offset), layout);\n+            // aka trivially droppable.\n+            ptr::drop_in_place::<T>(value);\n+\n+            // Note: Don't deallocate if the layout size is zero, because the pointer\n+            // didn't come from the allocator.\n+            if layout.size() != 0 {\n+                alloc::dealloc(self.0.as_ptr().sub(value_offset), layout);\n+            } else {\n+                debug_assert!(\n+                    value_offset == 0 && mem::size_of::<H>() == 0 && value_layout.size() == 0\n+                );\n+            }\n         }\n     }\n \n@@ -198,7 +223,9 @@ impl<H> WithHeader<H> {\n         //    needed to align the header. Subtracting the header size from the aligned data pointer\n         //    will always result in an aligned header pointer, it just may not point to the\n         //    beginning of the allocation.\n-        unsafe { self.0.as_ptr().sub(Self::header_size()) as *mut H }\n+        let hp = unsafe { self.0.as_ptr().sub(Self::header_size()) as *mut H };\n+        debug_assert!((hp.addr() & (core::mem::align_of::<H>() - 1)) == 0);\n+        hp\n     }\n \n     fn value(&self) -> *mut u8 {"}, {"sha": "ffc7944ec7e1b7176e13f7c3ff5d6e9228a9feac", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc109bb6c68f59903dace87c69bdeb2df5a006f0/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc109bb6c68f59903dace87c69bdeb2df5a006f0/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=fc109bb6c68f59903dace87c69bdeb2df5a006f0", "patch": "@@ -42,6 +42,9 @@\n #![feature(panic_update_hook)]\n #![feature(slice_flatten)]\n #![feature(thin_box)]\n+#![feature(bench_black_box)]\n+#![feature(strict_provenance)]\n+#![feature(once_cell)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "70d1db8b45766c373bbf82eeb053020646cf8a36", "filename": "library/alloc/tests/thin_box.rs", "status": "modified", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/fc109bb6c68f59903dace87c69bdeb2df5a006f0/library%2Falloc%2Ftests%2Fthin_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc109bb6c68f59903dace87c69bdeb2df5a006f0/library%2Falloc%2Ftests%2Fthin_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fthin_box.rs?ref=fc109bb6c68f59903dace87c69bdeb2df5a006f0", "patch": "@@ -1,3 +1,4 @@\n+use core::fmt::Debug;\n use core::mem::size_of;\n use std::boxed::ThinBox;\n \n@@ -24,3 +25,231 @@ fn want_thin() {\n     assert!(is_thin::<[i32]>());\n     assert!(is_thin::<i32>());\n }\n+\n+#[track_caller]\n+fn verify_aligned<T>(ptr: *const T) {\n+    // Use `black_box` to attempt to obscure the fact that we're calling this\n+    // function on pointers that come from box/references, which the compiler\n+    // would otherwise realize is impossible (because it would mean we've\n+    // already executed UB).\n+    //\n+    // That is, we'd *like* it to be possible for the asserts in this function\n+    // to detect brokenness in the ThinBox impl.\n+    //\n+    // It would probably be better if we instead had these as debug_asserts\n+    // inside `ThinBox`, prior to the point where we do the UB. Anyway, in\n+    // practice these checks are mostly just smoke-detectors for an extremely\n+    // broken `ThinBox` impl, since it's an extremely subtle piece of code.\n+    let ptr = core::hint::black_box(ptr);\n+    let align = core::mem::align_of::<T>();\n+    assert!(\n+        (ptr.addr() & (align - 1)) == 0 && !ptr.is_null(),\n+        \"misaligned ThinBox data; valid pointers to `{}` should be aligned to {align}: {ptr:p}\",\n+        core::any::type_name::<T>(),\n+    );\n+}\n+\n+#[track_caller]\n+fn check_thin_sized<T: Debug + PartialEq + Clone>(make: impl FnOnce() -> T) {\n+    let value = make();\n+    let boxed = ThinBox::new(value.clone());\n+    let val = &*boxed;\n+    verify_aligned(val as *const T);\n+    assert_eq!(val, &value);\n+}\n+\n+#[track_caller]\n+fn check_thin_dyn<T: Debug + PartialEq + Clone>(make: impl FnOnce() -> T) {\n+    let value = make();\n+    let wanted_debug = format!(\"{value:?}\");\n+    let boxed: ThinBox<dyn Debug> = ThinBox::new_unsize(value.clone());\n+    let val = &*boxed;\n+    // wide reference -> wide pointer -> thin pointer\n+    verify_aligned(val as *const dyn Debug as *const T);\n+    let got_debug = format!(\"{val:?}\");\n+    assert_eq!(wanted_debug, got_debug);\n+}\n+\n+macro_rules! define_test {\n+    (\n+        @test_name: $testname:ident;\n+\n+        $(#[$m:meta])*\n+        struct $Type:ident($inner:ty);\n+\n+        $($test_stmts:tt)*\n+    ) => {\n+        #[test]\n+        fn $testname() {\n+            use core::sync::atomic::{AtomicIsize, Ordering};\n+            // Define the type, and implement new/clone/drop in such a way that\n+            // the number of live instances will be counted.\n+            $(#[$m])*\n+            #[derive(Debug, PartialEq)]\n+            struct $Type {\n+                _priv: $inner,\n+            }\n+\n+            impl Clone for $Type {\n+                fn clone(&self) -> Self {\n+                    verify_aligned(self);\n+                    Self::new(self._priv.clone())\n+                }\n+            }\n+\n+            impl Drop for $Type {\n+                fn drop(&mut self) {\n+                    verify_aligned(self);\n+                    Self::modify_live(-1);\n+                }\n+            }\n+\n+            impl $Type {\n+                fn new(i: $inner) -> Self {\n+                    Self::modify_live(1);\n+                    Self { _priv: i }\n+                }\n+\n+                fn modify_live(n: isize) -> isize {\n+                    static COUNTER: AtomicIsize = AtomicIsize::new(0);\n+                    COUNTER.fetch_add(n, Ordering::Relaxed) + n\n+                }\n+\n+                fn live_objects() -> isize {\n+                    Self::modify_live(0)\n+                }\n+            }\n+            // Run the test statements\n+            let _: () = { $($test_stmts)* };\n+            // Check that we didn't leak anything, or call drop too many times.\n+            assert_eq!(\n+                $Type::live_objects(), 0,\n+                \"Wrong number of drops of {}, `initializations - drops` should be 0.\",\n+                stringify!($Type),\n+            );\n+        }\n+    };\n+}\n+\n+define_test! {\n+    @test_name: align1zst;\n+    struct Align1Zst(());\n+\n+    check_thin_sized(|| Align1Zst::new(()));\n+    check_thin_dyn(|| Align1Zst::new(()));\n+}\n+\n+define_test! {\n+    @test_name: align1small;\n+    struct Align1Small(u8);\n+\n+    check_thin_sized(|| Align1Small::new(50));\n+    check_thin_dyn(|| Align1Small::new(50));\n+}\n+\n+define_test! {\n+    @test_name: align1_size_not_pow2;\n+    struct Align64NotPow2Size([u8; 79]);\n+\n+    check_thin_sized(|| Align64NotPow2Size::new([100; 79]));\n+    check_thin_dyn(|| Align64NotPow2Size::new([100; 79]));\n+}\n+\n+define_test! {\n+    @test_name: align1big;\n+    struct Align1Big([u8; 256]);\n+\n+    check_thin_sized(|| Align1Big::new([5u8; 256]));\n+    check_thin_dyn(|| Align1Big::new([5u8; 256]));\n+}\n+\n+// Note: `#[repr(align(2))]` is worth testing because\n+// - can have pointers which are misaligned, unlike align(1)\n+// - is still expected to have an alignment less than the alignment of a vtable.\n+define_test! {\n+    @test_name: align2zst;\n+    #[repr(align(2))]\n+    struct Align2Zst(());\n+\n+    check_thin_sized(|| Align2Zst::new(()));\n+    check_thin_dyn(|| Align2Zst::new(()));\n+}\n+\n+define_test! {\n+    @test_name: align2small;\n+    #[repr(align(2))]\n+    struct Align2Small(u8);\n+\n+    check_thin_sized(|| Align2Small::new(60));\n+    check_thin_dyn(|| Align2Small::new(60));\n+}\n+\n+define_test! {\n+    @test_name: align2full;\n+    #[repr(align(2))]\n+    struct Align2Full([u8; 2]);\n+    check_thin_sized(|| Align2Full::new([3u8; 2]));\n+    check_thin_dyn(|| Align2Full::new([3u8; 2]));\n+}\n+\n+define_test! {\n+    @test_name: align2_size_not_pow2;\n+    #[repr(align(2))]\n+    struct Align2NotPower2Size([u8; 6]);\n+\n+    check_thin_sized(|| Align2NotPower2Size::new([3; 6]));\n+    check_thin_dyn(|| Align2NotPower2Size::new([3; 6]));\n+}\n+\n+define_test! {\n+    @test_name: align2big;\n+    #[repr(align(2))]\n+    struct Align2Big([u8; 256]);\n+\n+    check_thin_sized(|| Align2Big::new([5u8; 256]));\n+    check_thin_dyn(|| Align2Big::new([5u8; 256]));\n+}\n+\n+define_test! {\n+    @test_name: align64zst;\n+    #[repr(align(64))]\n+    struct Align64Zst(());\n+\n+    check_thin_sized(|| Align64Zst::new(()));\n+    check_thin_dyn(|| Align64Zst::new(()));\n+}\n+\n+define_test! {\n+    @test_name: align64small;\n+    #[repr(align(64))]\n+    struct Align64Small(u8);\n+\n+    check_thin_sized(|| Align64Small::new(50));\n+    check_thin_dyn(|| Align64Small::new(50));\n+}\n+\n+define_test! {\n+    @test_name: align64med;\n+    #[repr(align(64))]\n+    struct Align64Med([u8; 64]);\n+    check_thin_sized(|| Align64Med::new([10; 64]));\n+    check_thin_dyn(|| Align64Med::new([10; 64]));\n+}\n+\n+define_test! {\n+    @test_name: align64_size_not_pow2;\n+    #[repr(align(64))]\n+    struct Align64NotPow2Size([u8; 192]);\n+\n+    check_thin_sized(|| Align64NotPow2Size::new([10; 192]));\n+    check_thin_dyn(|| Align64NotPow2Size::new([10; 192]));\n+}\n+\n+define_test! {\n+    @test_name: align64big;\n+    #[repr(align(64))]\n+    struct Align64Big([u8; 256]);\n+\n+    check_thin_sized(|| Align64Big::new([10; 256]));\n+    check_thin_dyn(|| Align64Big::new([10; 256]));\n+}"}]}