{"sha": "38813cf40d96222b846bbe32e6a96faefa8c9f68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ODEzY2Y0MGQ5NjIyMmI4NDZiYmUzMmU2YTk2ZmFlZmE4YzlmNjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-19T12:43:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-19T14:39:00Z"}, "message": "start writing some typeck docs (incomplete)", "tree": {"sha": "e0b6174258607e37bcc9da6d721c0bedd0d23394", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0b6174258607e37bcc9da6d721c0bedd0d23394"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38813cf40d96222b846bbe32e6a96faefa8c9f68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38813cf40d96222b846bbe32e6a96faefa8c9f68", "html_url": "https://github.com/rust-lang/rust/commit/38813cf40d96222b846bbe32e6a96faefa8c9f68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38813cf40d96222b846bbe32e6a96faefa8c9f68/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "032fdef3befba19c80d2ec6d59f9309bbc359e68", "url": "https://api.github.com/repos/rust-lang/rust/commits/032fdef3befba19c80d2ec6d59f9309bbc359e68", "html_url": "https://github.com/rust-lang/rust/commit/032fdef3befba19c80d2ec6d59f9309bbc359e68"}], "stats": {"total": 107, "additions": 63, "deletions": 44}, "files": [{"sha": "a38f04e304b6c38d5b1da48341d48ec7e0e59003", "filename": "src/librustc_typeck/README.md", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/38813cf40d96222b846bbe32e6a96faefa8c9f68/src%2Flibrustc_typeck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/38813cf40d96222b846bbe32e6a96faefa8c9f68/src%2Flibrustc_typeck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FREADME.md?ref=38813cf40d96222b846bbe32e6a96faefa8c9f68", "patch": "@@ -0,0 +1,48 @@\n+NB: This crate is part of the Rust compiler. For an overview of the\n+compiler as a whole, see\n+[the README.md file found in `librustc`](../librustc/README.md).\n+\n+The `rustc_typeck` crate contains the source for \"type collection\" and\n+\"type checking\", as well as a few other bits of related functionality.\n+(It draws heavily on the [type inferencing][infer] and\n+[trait solving][traits] code found in librustc.)\n+\n+[infer]: ../librustc/infer/README.md\n+[traits]: ../librustc/traits/README.md\n+\n+## Type collection\n+\n+Type \"collection\" is the process of convering the types found in the\n+HIR (`hir::Ty`), which represent the syntactic things that the user\n+wrote, into the **internal representation** used by the compiler\n+(`Ty<'tcx>`) -- we also do similar conversions for where-clauses and\n+other bits of the function signature.\n+\n+To try and get a sense for the difference, consider this function:\n+\n+```rust\n+struct Foo { }\n+fn foo(x: Foo, y: self::Foo) { .. }\n+//        ^^^     ^^^^^^^^^\n+```\n+\n+Those two parameters `x` and `y` each have the same type: but they\n+will have distinct `hir::Ty` nodes. Those nodes will have different\n+spans, and of course they encode the path somewhat differently. But\n+once they are \"collected\" into `Ty<'tcx>` nodes, they will be\n+represented by the exact same internal type.\n+\n+Collection is defined as a bundle of queries (e.g., `type_of`) for\n+computing information about the various functions, traits, and other\n+items in the crate being compiled. Note that each of these queries is\n+concerned with *interprocedural* things -- for example, for a function\n+definition, collection will figure out the type and signature of the\n+function, but it will not visit the *body* of the function in any way,\n+nor examine type annotations on local variables (that's the job of\n+type *checking*).\n+\n+For more details, see the `collect` module.\n+\n+## Type checking\n+\n+TODO"}, {"sha": "79cb9147c185bcc5455223edd0740742df131c21", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 44, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/38813cf40d96222b846bbe32e6a96faefa8c9f68/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38813cf40d96222b846bbe32e6a96faefa8c9f68/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=38813cf40d96222b846bbe32e6a96faefa8c9f68", "patch": "@@ -8,50 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*\n-\n-# Collect phase\n-\n-The collect phase of type check has the job of visiting all items,\n-determining their type, and writing that type into the `tcx.types`\n-table.  Despite its name, this table does not really operate as a\n-*cache*, at least not for the types of items defined within the\n-current crate: we assume that after the collect phase, the types of\n-all local items will be present in the table.\n-\n-Unlike most of the types that are present in Rust, the types computed\n-for each item are in fact type schemes. This means that they are\n-generic types that may have type parameters. TypeSchemes are\n-represented by a pair of `Generics` and `Ty`.  Type\n-parameters themselves are represented as `ty_param()` instances.\n-\n-The phasing of type conversion is somewhat complicated. There is no\n-clear set of phases we can enforce (e.g., converting traits first,\n-then types, or something like that) because the user can introduce\n-arbitrary interdependencies. So instead we generally convert things\n-lazilly and on demand, and include logic that checks for cycles.\n-Demand is driven by calls to `AstConv::get_item_type_scheme` or\n-`AstConv::trait_def`.\n-\n-Currently, we \"convert\" types and traits in two phases (note that\n-conversion only affects the types of items / enum variants / methods;\n-it does not e.g. compute the types of individual expressions):\n-\n-0. Intrinsics\n-1. Trait/Type definitions\n-\n-Conversion itself is done by simply walking each of the items in turn\n-and invoking an appropriate function (e.g., `trait_def_of_item` or\n-`convert_item`). However, it is possible that while converting an\n-item, we may need to compute the *type scheme* or *trait definition*\n-for other items.\n-\n-There are some shortcomings in this design:\n-- Because the item generics include defaults, cycles through type\n-  parameter defaults are illegal even if those defaults are never\n-  employed. This is not necessarily a bug.\n-\n-*/\n+//! \"Collection\" is the process of determining the type and other external\n+//! details of each item in Rust. Collection is specifically concerned\n+//! with *interprocedural* things -- for example, for a function\n+//! definition, collection will figure out the type and signature of the\n+//! function, but it will not visit the *body* of the function in any way,\n+//! nor examine type annotations on local variables (that's the job of\n+//! type *checking*).\n+//!\n+//! Collecting is ultimately defined by a bundle of queries that\n+//! inquire after various facts about the items in the crate (e.g.,\n+//! `type_of`, `generics_of`, `predicates_of`, etc). See the `provide` function\n+//! for the full set.\n+//!\n+//! At present, however, we do run collection across all items in the\n+//! crate as a kind of pass. This should eventually be factored away.\n \n use astconv::{AstConv, Bounds};\n use lint;"}]}