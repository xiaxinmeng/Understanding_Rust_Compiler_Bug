{"sha": "33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYjgzYWU3ZGZiN2YyMDgyNWY2NjZlY2M3OGQ1ZjdhZDk3NTk3YjE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-03-06T20:40:08Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-03-06T20:50:41Z"}, "message": "Formatting fallout\n\nAlso fixes a minor bug when we break a line after `if` and used to leave a trailing space", "tree": {"sha": "37ed503dd63170b039d608398315730d4e942b10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37ed503dd63170b039d608398315730d4e942b10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "html_url": "https://github.com/rust-lang/rust/commit/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7a33062e25e1d80545ae6094d3faa99348c79e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7a33062e25e1d80545ae6094d3faa99348c79e1", "html_url": "https://github.com/rust-lang/rust/commit/c7a33062e25e1d80545ae6094d3faa99348c79e1"}], "stats": {"total": 389, "additions": 225, "deletions": 164}, "files": [{"sha": "ceb6af93825126e2657b2c33856544fb1574f7e9", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -147,7 +147,10 @@ fn get_targets() -> Result<Vec<Target>, std::io::Error> {\n         // None of the unwraps should fail if output of `cargo read-manifest` is correct\n         let data = &String::from_utf8(output.stdout).unwrap();\n         let json = Json::from_str(data).unwrap();\n-        let jtargets = json.find(\"targets\").unwrap().as_array().unwrap();\n+        let jtargets = json.find(\"targets\")\n+            .unwrap()\n+            .as_array()\n+            .unwrap();\n         for jtarget in jtargets {\n             targets.push(target_from_json(jtarget));\n         }\n@@ -162,8 +165,14 @@ fn get_targets() -> Result<Vec<Target>, std::io::Error> {\n \n fn target_from_json(jtarget: &Json) -> Target {\n     let jtarget = jtarget.as_object().unwrap();\n-    let path = PathBuf::from(jtarget.get(\"src_path\").unwrap().as_string().unwrap());\n-    let kinds = jtarget.get(\"kind\").unwrap().as_array().unwrap();\n+    let path = PathBuf::from(jtarget.get(\"src_path\")\n+                                 .unwrap()\n+                                 .as_string()\n+                                 .unwrap());\n+    let kinds = jtarget.get(\"kind\")\n+        .unwrap()\n+        .as_array()\n+        .unwrap();\n     let kind = match kinds[0].as_string().unwrap() {\n         \"bin\" => TargetKind::Bin,\n         \"lib\" | \"dylib\" | \"staticlib\" | \"cdylib\" | \"rlib\" => TargetKind::Lib,"}, {"sha": "69a18d14cb56d646715627d1f5edf4aac2f4d2ba", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -223,7 +223,10 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n             let options = try!(CliOptions::from_matches(&matches));\n \n             // Add any additional files that were specified via `--file-lines`.\n-            files.extend(options.file_lines.files().cloned().map(PathBuf::from));\n+            files.extend(options.file_lines\n+                             .files()\n+                             .cloned()\n+                             .map(PathBuf::from));\n \n             let mut config = Config::default();\n             let mut path = None;\n@@ -354,7 +357,10 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n     }\n \n     // We append files from `--file-lines` later in `execute()`.\n-    let files: Vec<_> = matches.free.iter().map(PathBuf::from).collect();\n+    let files: Vec<_> = matches.free\n+        .iter()\n+        .map(PathBuf::from)\n+        .collect();\n \n     Ok(Operation::Format {\n            files: files,"}, {"sha": "4918ebd3cac3ae78cfe084782d0b1bea97aa6d54", "filename": "src/chains.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -158,9 +158,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n                      .collect::<Option<Vec<_>>>());\n \n     // Total of all items excluding the last.\n-    let almost_total = rewrites[..rewrites.len() - 1]\n-        .iter()\n-        .fold(0, |a, b| a + first_line_width(b)) + parent_rewrite.len();\n+    let almost_total = rewrites[..rewrites.len() - 1].iter().fold(0, |a, b| {\n+        a + first_line_width(b)\n+    }) + parent_rewrite.len();\n \n     let veto_single_line = if subexpr_list.len() > context.config.chain_one_line_max - 1 {\n         // -1 above because subexpr_list does not include the parent.\n@@ -425,17 +425,20 @@ fn rewrite_method_call(method_name: ast::Ident,\n     let (lo, type_str) = if types.is_empty() {\n         (args[0].span.hi, String::new())\n     } else {\n-        let type_list: Vec<_> = try_opt!(types.iter()\n-                                             .map(|ty| ty.rewrite(context, shape))\n-                                             .collect());\n+        let type_list: Vec<_> =\n+            try_opt!(types.iter().map(|ty| ty.rewrite(context, shape)).collect());\n \n         let type_str = if context.config.spaces_within_angle_brackets && type_list.len() > 0 {\n             format!(\"::< {} >\", type_list.join(\", \"))\n         } else {\n             format!(\"::<{}>\", type_list.join(\", \"))\n         };\n \n-        (types.last().unwrap().span.hi, type_str)\n+        (types.last()\n+             .unwrap()\n+             .span\n+             .hi,\n+         type_str)\n     };\n \n     let callee_str = format!(\".{}{}\", method_name, type_str);"}, {"sha": "602ab5c98be57ef1f55ba6ee4119f46ddc9a3459", "filename": "src/codemap.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodemap.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -26,7 +26,10 @@ pub struct LineRange {\n \n impl LineRange {\n     pub fn file_name(&self) -> &str {\n-        self.file.as_ref().name.as_str()\n+        self.file\n+            .as_ref()\n+            .name\n+            .as_str()\n     }\n }\n "}, {"sha": "e4f9db9f1584be4b3bda0360ea9970783f0f1f05", "filename": "src/comment.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -96,7 +96,10 @@ pub fn rewrite_comment(orig: &str,\n         config: config,\n     };\n \n-    let line_breaks = orig.trim_right().chars().filter(|&c| c == '\\n').count();\n+    let line_breaks = orig.trim_right()\n+        .chars()\n+        .filter(|&c| c == '\\n')\n+        .count();\n     let lines = orig.lines()\n         .enumerate()\n         .map(|(i, mut line)| {\n@@ -594,8 +597,9 @@ fn changed_comment_content(orig: &str, new: &str) -> bool {\n     // Cannot write this as a fn since we cannot return types containing closures\n     let code_comment_content = |code| {\n         let slices = UngroupedCommentCodeSlices::new(code);\n-        slices.filter(|&(ref kind, _, _)| *kind == CodeCharKind::Comment)\n-            .flat_map(|(_, _, s)| CommentReducer::new(s))\n+        slices.filter(|&(ref kind, _, _)| *kind == CodeCharKind::Comment).flat_map(|(_, _, s)| {\n+            CommentReducer::new(s)\n+        })\n     };\n     let res = code_comment_content(orig).ne(code_comment_content(new));\n     debug!(\"comment::changed_comment_content: {}\\norig: '{}'\\nnew: '{}'\\nraw_old: {}\\nraw_new: {}\","}, {"sha": "7f5d88d3f684b1d46310759c17d88f1a5cc2766e", "filename": "src/expr.rs", "status": "modified", "additions": 51, "deletions": 44, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -300,10 +300,9 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n \n     // Re-evaluate the rhs because we have more space now:\n     let infix = infix.trim_right();\n-    let lhs_budget = try_opt!(context.config\n-                                  .max_width\n-                                  .checked_sub(shape.used_width() + prefix.len() +\n-                                               infix.len()));\n+    let lhs_budget = try_opt!(context.config.max_width.checked_sub(shape.used_width() +\n+                                                                   prefix.len() +\n+                                                                   infix.len()));\n     let rhs_shape = try_opt!(shape.sub_width(suffix.len() + prefix.len()))\n         .visual_indent(prefix.len());\n \n@@ -893,15 +892,19 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             \" \"\n         };\n \n-        let mut result =\n-            format!(\"{}{}{}{}{}{}\",\n-                    label_string,\n-                    self.keyword,\n-                    between_kwd_cond_comment.as_ref()\n-                        .map_or(if pat_expr_string.is_empty() { \"\" } else { \" \" }, |s| &**s),\n-                    pat_expr_string,\n-                    after_cond_comment.as_ref().map_or(block_sep, |s| &**s),\n-                    block_str);\n+        let mut result = format!(\"{}{}{}{}{}{}\",\n+                                 label_string,\n+                                 self.keyword,\n+                                 between_kwd_cond_comment.as_ref().map_or(if\n+            pat_expr_string.is_empty() || pat_expr_string.starts_with('\\n') {\n+                                                                              \"\"\n+                                                                          } else {\n+                                                                              \" \"\n+                                                                          },\n+                                                                          |s| &**s),\n+                                 pat_expr_string,\n+                                 after_cond_comment.as_ref().map_or(block_sep, |s| &**s),\n+                                 block_str);\n \n         if let Some(else_block) = self.else_block {\n             // Since this is an else block, we should not indent for the assignment preceding\n@@ -944,15 +947,15 @@ impl<'a> Rewrite for ControlFlow<'a> {\n \n             let between_kwd_else_block =\n                 mk_sp(self.block.span.hi,\n-                      context.codemap\n-                          .span_before(mk_sp(self.block.span.hi, else_block.span.lo), \"else\"));\n+                      context.codemap.span_before(mk_sp(self.block.span.hi, else_block.span.lo),\n+                                                  \"else\"));\n             let between_kwd_else_block_comment =\n                 extract_comment(between_kwd_else_block, context, shape);\n \n-            let after_else =\n-                mk_sp(context.codemap\n-                          .span_after(mk_sp(self.block.span.hi, else_block.span.lo), \"else\"),\n-                      else_block.span.lo);\n+            let after_else = mk_sp(context.codemap.span_after(mk_sp(self.block.span.hi,\n+                                                                    else_block.span.lo),\n+                                                              \"else\"),\n+                                   else_block.span.lo);\n             let after_else_comment = extract_comment(after_else, context, shape);\n \n             let between_sep = match context.config.control_brace_style {\n@@ -966,8 +969,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             };\n             try_opt!(write!(&mut result,\n                             \"{}else{}\",\n-                            between_kwd_else_block_comment.as_ref()\n-                                .map_or(between_sep, |s| &**s),\n+                            between_kwd_else_block_comment.as_ref().map_or(between_sep, |s| &**s),\n                             after_else_comment.as_ref().map_or(after_sep, |s| &**s))\n                              .ok());\n             result.push_str(&try_opt!(rewrite));\n@@ -1094,8 +1096,8 @@ fn rewrite_match(context: &RewriteContext,\n     let arm_shape = shape.block_indent(context.config.tab_spaces);\n     let arm_indent_str = arm_shape.indent.to_string(context.config);\n \n-    let open_brace_pos = context.codemap\n-        .span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])), \"{\");\n+    let open_brace_pos = context.codemap.span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])),\n+                                                    \"{\");\n \n     for (i, arm) in arms.iter().enumerate() {\n         // Make sure we get the stuff between arms.\n@@ -1245,8 +1247,11 @@ impl Rewrite for ast::Arm {\n         // Let's try and get the arm body on the same line as the condition.\n         // 4 = ` => `.len()\n         if shape.width > pat_width + comma.len() + 4 {\n-            let arm_shape =\n-                shape.shrink_left(pat_width + 4).unwrap().sub_width(comma.len()).unwrap().block();\n+            let arm_shape = shape.shrink_left(pat_width + 4)\n+                .unwrap()\n+                .sub_width(comma.len())\n+                .unwrap()\n+                .block();\n             let rewrite = nop_block_collapse(body.rewrite(context, arm_shape), arm_shape.width);\n             let is_block = if let ast::ExprKind::Block(..) = body.node {\n                 true\n@@ -1338,7 +1343,10 @@ fn rewrite_guard(context: &RewriteContext,\n         // 4 = ` if `, 5 = ` => {`\n         let overhead = pattern_width + 4 + 5;\n         if overhead < shape.width {\n-            let cond_shape = shape.shrink_left(pattern_width + 4).unwrap().sub_width(5).unwrap();\n+            let cond_shape = shape.shrink_left(pattern_width + 4)\n+                .unwrap()\n+                .sub_width(5)\n+                .unwrap();\n             let cond_str = guard.rewrite(context, cond_shape);\n             if let Some(cond_str) = cond_str {\n                 return Some(format!(\" if {}\", cond_str));\n@@ -1469,7 +1477,10 @@ fn string_requires_rewrite(context: &RewriteContext,\n                            string: &str,\n                            shape: Shape)\n                            -> bool {\n-    if context.codemap.lookup_char_pos(span.lo).col.0 != shape.indent.width() {\n+    if context.codemap\n+           .lookup_char_pos(span.lo)\n+           .col\n+           .0 != shape.indent.width() {\n         return true;\n     }\n \n@@ -1584,10 +1595,10 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n         }\n     }\n \n-    let tactic = definitive_tactic(&item_vec,\n-                                   ListTactic::LimitedHorizontalVertical(context.config\n-                                                                             .fn_call_width),\n-                                   remaining_width);\n+    let tactic =\n+        definitive_tactic(&item_vec,\n+                          ListTactic::LimitedHorizontalVertical(context.config.fn_call_width),\n+                          remaining_width);\n \n     // Replace the stub with the full overflowing last argument if the rewrite\n     // succeeded and its first line fits with the other arguments.\n@@ -1709,8 +1720,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                              |item| match *item {\n                                  StructLitField::Regular(field) => field.span.lo,\n                                  StructLitField::Base(expr) => {\n-        let last_field_hi = fields.last()\n-            .map_or(span.lo, |field| field.span.hi);\n+        let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n         let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n         let pos = snippet.find_uncommented(\"..\").unwrap();\n         last_field_hi + BytePos(pos as u32)\n@@ -1728,8 +1738,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n             }\n             StructLitField::Base(expr) => {\n                 // 2 = ..\n-                expr.rewrite(context, try_opt!(v_shape.shrink_left(2)))\n-                    .map(|s| format!(\"..{}\", s))\n+                expr.rewrite(context, try_opt!(v_shape.shrink_left(2))).map(|s| format!(\"..{}\", s))\n             }\n         }\n     },\n@@ -1823,12 +1832,11 @@ fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) ->\n             Some(e) => Some(format!(\"{}{}{}\", name, separator, e)),\n             None => {\n                 let expr_offset = shape.indent.block_indent(context.config);\n-                let expr = field.expr\n-                    .rewrite(context,\n-                             Shape::legacy(try_opt!(context.config\n+                let expr = field.expr.rewrite(context,\n+                                              Shape::legacy(try_opt!(context.config\n                                                         .max_width\n                                                         .checked_sub(expr_offset.width())),\n-                                           expr_offset));\n+                                                            expr_offset));\n                 expr.map(|s| format!(\"{}:\\n{}{}\", name, expr_offset.to_string(&context.config), s))\n             }\n         }\n@@ -1894,11 +1902,10 @@ pub fn rewrite_unary_suffix<R: Rewrite>(context: &RewriteContext,\n                                         rewrite: &R,\n                                         shape: Shape)\n                                         -> Option<String> {\n-    rewrite.rewrite(context, try_opt!(shape.sub_width(suffix.len())))\n-        .map(|mut r| {\n-                 r.push_str(suffix);\n-                 r\n-             })\n+    rewrite.rewrite(context, try_opt!(shape.sub_width(suffix.len()))).map(|mut r| {\n+                                                                              r.push_str(suffix);\n+                                                                              r\n+                                                                          })\n }\n \n fn rewrite_unary_op(context: &RewriteContext,"}, {"sha": "65d8366ea22d049bcdcee1780bc102d760cded12", "filename": "src/imports.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -29,7 +29,10 @@ fn path_of(a: &ast::ViewPath_) -> &ast::Path {\n }\n \n fn compare_path_segments(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n-    a.identifier.name.as_str().cmp(&b.identifier.name.as_str())\n+    a.identifier\n+        .name\n+        .as_str()\n+        .cmp(&b.identifier.name.as_str())\n }\n \n fn compare_paths(a: &ast::Path, b: &ast::Path) -> Ordering {\n@@ -43,8 +46,14 @@ fn compare_paths(a: &ast::Path, b: &ast::Path) -> Ordering {\n }\n \n fn compare_path_list_items(a: &ast::PathListItem, b: &ast::PathListItem) -> Ordering {\n-    let a_name_str = &*a.node.name.name.as_str();\n-    let b_name_str = &*b.node.name.name.as_str();\n+    let a_name_str = &*a.node\n+                           .name\n+                           .name\n+                           .as_str();\n+    let b_name_str = &*b.node\n+                           .name\n+                           .name\n+                           .as_str();\n     let name_ordering = if a_name_str == \"self\" {\n         if b_name_str == \"self\" {\n             Ordering::Equal\n@@ -139,7 +148,11 @@ impl Rewrite for ast::ViewPath {\n                 // 4 = \" as \".len()\n                 let budget = try_opt!(shape.width.checked_sub(ident_str.len() + 4));\n \n-                let path_str = if path.segments.last().unwrap().identifier.to_string() == \"self\" &&\n+                let path_str = if path.segments\n+                       .last()\n+                       .unwrap()\n+                       .identifier\n+                       .to_string() == \"self\" &&\n                                   path.segments.len() > 1 {\n                     let path = &ast::Path {\n                                     span: path.span.clone(),\n@@ -158,7 +171,10 @@ impl Rewrite for ast::ViewPath {\n                                           Shape::legacy(budget, shape.indent)))\n                 };\n \n-                Some(if path.segments.last().unwrap().identifier == ident {\n+                Some(if path.segments\n+                            .last()\n+                            .unwrap()\n+                            .identifier == ident {\n                          path_str\n                      } else {\n                          format!(\"{} as {}\", path_str, ident_str)\n@@ -175,7 +191,11 @@ impl<'a> FmtVisitor<'a> {\n         let pos_before_first_use_item = use_items.first()\n             .map(|p_i| {\n                 cmp::max(self.last_pos,\n-                         p_i.attrs.iter().map(|attr| attr.span.lo).min().unwrap_or(p_i.span.lo))\n+                         p_i.attrs\n+                             .iter()\n+                             .map(|attr| attr.span.lo)\n+                             .min()\n+                             .unwrap_or(p_i.span.lo))\n             })\n             .unwrap_or(self.last_pos);\n         // Construct a list of pairs, each containing a `use` item and the start of span before"}, {"sha": "91fd91ef958d079e83655799b12d2dd39e4eab35", "filename": "src/items.rs", "status": "modified", "additions": 43, "deletions": 46, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -40,9 +40,8 @@ impl Rewrite for ast::Local {\n         // 1 = ;\n         let pattern_width = try_opt!(shape.width.checked_sub(pattern_offset.width() + 1));\n \n-        let pat_str = try_opt!(self.pat\n-                                   .rewrite(&context,\n-                                            Shape::legacy(pattern_width, pattern_offset)));\n+        let pat_str = try_opt!(self.pat.rewrite(&context,\n+                                                Shape::legacy(pattern_width, pattern_offset)));\n         result.push_str(&pat_str);\n \n         // String that is placed within the assignment pattern and expression.\n@@ -106,7 +105,10 @@ impl<'a> Item<'a> {\n             keyword: \"\",\n             abi: abi,\n             vis: None,\n-            body: fm.items.iter().map(|i| BodyElement::ForeignItem(i)).collect(),\n+            body: fm.items\n+                .iter()\n+                .map(|i| BodyElement::ForeignItem(i))\n+                .collect(),\n             span: span,\n         }\n     }\n@@ -455,12 +457,10 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let indent = self.block_indent;\n-        let mut result = try_opt!(field.node\n-                                      .attrs\n-                                      .rewrite(&self.get_context(),\n-                                               Shape::legacy(self.config.max_width -\n-                                                             indent.width(),\n-                                                             indent)));\n+        let mut result = try_opt!(field.node.attrs.rewrite(&self.get_context(),\n+                                                           Shape::legacy(self.config.max_width -\n+                                                                         indent.width(),\n+                                                                         indent)));\n         if !result.is_empty() {\n             result.push('\\n');\n             result.push_str(&indent.to_string(self.config));\n@@ -784,9 +784,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                 Density::Tall\n             };\n \n-        let where_budget = try_opt!(context.config\n-                                        .max_width\n-                                        .checked_sub(last_line_width(&result)));\n+        let where_budget = try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n                                                              context.config,\n@@ -1000,9 +998,8 @@ fn format_tuple_struct(context: &RewriteContext,\n                                                          mk_sp(span.lo, body_lo)));\n             result.push_str(&generics_str);\n \n-            let where_budget = try_opt!(context.config\n-                                            .max_width\n-                                            .checked_sub(last_line_width(&result)));\n+            let where_budget =\n+                try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n             try_opt!(rewrite_where_clause(context,\n                                           &generics.where_clause,\n                                           context.config,\n@@ -1093,9 +1090,7 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n \n     result.push_str(&generics_str);\n \n-    let where_budget = try_opt!(context.config\n-                                    .max_width\n-                                    .checked_sub(last_line_width(&result)));\n+    let where_budget = try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n     let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                          &generics.where_clause,\n                                                          context.config,\n@@ -1117,18 +1112,16 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n         .unwrap_or(0);\n     let type_indent = indent + line_width;\n     // Try to fit the type on the same line\n-    let ty_str = try_opt!(ty.rewrite(context, Shape::legacy(budget, type_indent))\n-                              .or_else(|| {\n+    let ty_str = try_opt!(ty.rewrite(context, Shape::legacy(budget, type_indent)).or_else(|| {\n         // The line was too short, try to put the type on the next line\n \n         // Remove the space after '='\n         result.pop();\n         let type_indent = indent.block_indent(context.config);\n         result.push('\\n');\n         result.push_str(&type_indent.to_string(context.config));\n-        let budget = try_opt!(context.config\n-                                  .max_width\n-                                  .checked_sub(type_indent.width() + \";\".len()));\n+        let budget = try_opt!(context.config.max_width.checked_sub(type_indent.width() +\n+                                                                   \";\".len()));\n         ty.rewrite(context, Shape::legacy(budget, type_indent))\n     }));\n     result.push_str(&ty_str);\n@@ -1158,11 +1151,10 @@ impl Rewrite for ast::StructField {\n \n         let name = self.ident;\n         let vis = format_visibility(&self.vis);\n-        let mut attr_str = try_opt!(self.attrs\n-                                        .rewrite(context,\n-                                                 Shape::legacy(context.config.max_width -\n-                                                               shape.indent.width(),\n-                                                               shape.indent)));\n+        let mut attr_str = try_opt!(self.attrs.rewrite(context,\n+                                                       Shape::legacy(context.config.max_width -\n+                                                                     shape.indent.width(),\n+                                                                     shape.indent)));\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n             attr_str.push_str(&shape.indent.to_string(context.config));\n@@ -1289,8 +1281,9 @@ impl Rewrite for ast::FunctionRetTy {\n             ast::FunctionRetTy::Default(_) => Some(String::new()),\n             ast::FunctionRetTy::Ty(ref ty) => {\n                 let inner_width = try_opt!(shape.width.checked_sub(3));\n-                ty.rewrite(context, Shape::legacy(inner_width, shape.indent + 3))\n-                    .map(|r| format!(\"-> {}\", r))\n+                ty.rewrite(context, Shape::legacy(inner_width, shape.indent + 3)).map(|r| {\n+                    format!(\"-> {}\", r)\n+                })\n             }\n         }\n     }\n@@ -1299,9 +1292,8 @@ impl Rewrite for ast::FunctionRetTy {\n impl Rewrite for ast::Arg {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if is_named_arg(self) {\n-            let mut result = try_opt!(self.pat\n-                                          .rewrite(context,\n-                                                   Shape::legacy(shape.width, shape.indent)));\n+            let mut result = try_opt!(self.pat.rewrite(context,\n+                                                       Shape::legacy(shape.width, shape.indent)));\n \n             if self.ty.node != ast::TyKind::Infer {\n                 if context.config.space_before_type_annotation {\n@@ -1478,11 +1470,10 @@ fn rewrite_fn_base(context: &RewriteContext,\n \n     // Note that if the width and indent really matter, we'll re-layout the\n     // return type later anyway.\n-    let ret_str = try_opt!(fd.output\n-                               .rewrite(&context,\n-                                        Shape::legacy(context.config.max_width -\n-                                                      indent.width(),\n-                                                      indent)));\n+    let ret_str = try_opt!(fd.output.rewrite(&context,\n+                                             Shape::legacy(context.config.max_width -\n+                                                           indent.width(),\n+                                                           indent)));\n \n     let multi_line_ret_str = ret_str.contains('\\n');\n     let ret_str_len = if multi_line_ret_str { 0 } else { ret_str.len() };\n@@ -1528,9 +1519,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n     }\n \n     // A conservative estimation, to goal is to be over all parens in generics\n-    let args_start = generics.ty_params\n-        .last()\n-        .map_or(span.lo, |tp| end_typaram(tp));\n+    let args_start = generics.ty_params.last().map_or(span.lo, |tp| end_typaram(tp));\n     let args_span = mk_sp(context.codemap.span_after(mk_sp(args_start, span.hi), \"(\"),\n                           span_for_return(&fd.output).lo);\n     let arg_str = try_opt!(rewrite_args(context,\n@@ -1731,7 +1720,12 @@ fn rewrite_args(context: &RewriteContext,\n         }\n \n         let variadic_arg = if variadic {\n-            let variadic_span = mk_sp(args.last().unwrap().ty.span.hi, span.hi);\n+            let variadic_span = mk_sp(args.last()\n+                                          .unwrap()\n+                                          .ty\n+                                          .span\n+                                          .hi,\n+                                      span.hi);\n             let variadic_start = context.codemap.span_after(variadic_span, \"...\") - BytePos(3);\n             Some(ArgumentKind::Variadic(variadic_start))\n         } else {\n@@ -1826,7 +1820,10 @@ fn compute_budgets_for_args(context: &RewriteContext,\n         if !newline_brace {\n             used_space += 2;\n         }\n-        let one_line_budget = context.config.max_width.checked_sub(used_space).unwrap_or(0);\n+        let one_line_budget = context.config\n+            .max_width\n+            .checked_sub(used_space)\n+            .unwrap_or(0);\n \n         if one_line_budget > 0 {\n             // 4 = \"() {\".len()\n@@ -1884,8 +1881,8 @@ fn rewrite_generics(context: &RewriteContext,\n \n     // Strings for the generics.\n     let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(context, Shape::legacy(h_budget, offset)));\n-    let ty_strs = tys.iter()\n-        .map(|ty_param| ty_param.rewrite(context, Shape::legacy(h_budget, offset)));\n+    let ty_strs =\n+        tys.iter().map(|ty_param| ty_param.rewrite(context, Shape::legacy(h_budget, offset)));\n \n     // Extract comments between generics.\n     let lt_spans = lifetimes.iter().map(|l| {"}, {"sha": "f37466bebfc04363413c3b675647ad734d303e11", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -394,7 +394,10 @@ impl FormatReport {\n     }\n \n     pub fn warning_count(&self) -> usize {\n-        self.file_error_map.iter().map(|(_, errors)| errors.len()).fold(0, |acc, x| acc + x)\n+        self.file_error_map\n+            .iter()\n+            .map(|(_, errors)| errors.len())\n+            .fold(0, |acc, x| acc + x)\n     }\n \n     pub fn has_warnings(&self) -> bool {"}, {"sha": "5c25c8b1cea07ee29c0924481ce90d1916460daa", "filename": "src/lists.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -147,9 +147,8 @@ pub fn definitive_tactic<I, T>(items: I, tactic: ListTactic, width: usize) -> De\n     where I: IntoIterator<Item = T> + Clone,\n           T: AsRef<ListItem>\n {\n-    let pre_line_comments = items.clone()\n-        .into_iter()\n-        .any(|item| item.as_ref().has_line_pre_comment());\n+    let pre_line_comments =\n+        items.clone().into_iter().any(|item| item.as_ref().has_line_pre_comment());\n \n     let limit = match tactic {\n         _ if pre_line_comments => return DefinitiveListTactic::Vertical,\n@@ -275,7 +274,10 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n \n         if tactic == DefinitiveListTactic::Vertical && item.post_comment.is_some() {\n             // 1 = space between item and comment.\n-            let width = formatting.shape.width.checked_sub(item_last_line_width + 1).unwrap_or(1);\n+            let width = formatting.shape\n+                .width\n+                .checked_sub(item_last_line_width + 1)\n+                .unwrap_or(1);\n             let mut offset = formatting.shape.indent;\n             offset.alignment += item_last_line_width + 1;\n             let comment = item.post_comment.as_ref().unwrap();\n@@ -475,9 +477,9 @@ fn calculate_width<I, T>(items: I) -> (usize, usize)\n     where I: IntoIterator<Item = T>,\n           T: AsRef<ListItem>\n {\n-    items.into_iter()\n-        .map(|item| total_item_width(item.as_ref()))\n-        .fold((0, 0), |acc, l| (acc.0 + 1, acc.1 + l))\n+    items.into_iter().map(|item| total_item_width(item.as_ref())).fold((0, 0), |acc, l| {\n+        (acc.0 + 1, acc.1 + l)\n+    })\n }\n \n fn total_item_width(item: &ListItem) -> usize {"}, {"sha": "767a81120e5c262920cab0f3de9dda1919f4c9e0", "filename": "src/missed_spans.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -75,12 +75,19 @@ impl<'a> FmtVisitor<'a> {\n         // Get a snippet from the file start to the span's hi without allocating.\n         // We need it to determine what precedes the current comment. If the comment\n         // follows code on the same line, we won't touch it.\n-        let big_span_lo = self.codemap.lookup_char_pos(span.lo).file.start_pos;\n+        let big_span_lo = self.codemap\n+            .lookup_char_pos(span.lo)\n+            .file\n+            .start_pos;\n         let local_begin = self.codemap.lookup_byte_offset(big_span_lo);\n         let local_end = self.codemap.lookup_byte_offset(span.hi);\n         let start_index = local_begin.pos.to_usize();\n         let end_index = local_end.pos.to_usize();\n-        let big_snippet = &local_begin.fm.src.as_ref().unwrap()[start_index..end_index];\n+        let big_snippet = &local_begin.fm\n+                               .src\n+                               .as_ref()\n+                               .unwrap()\n+                               [start_index..end_index];\n \n         let big_diff = (span.lo - big_span_lo).to_usize();\n         let snippet = self.snippet(span);\n@@ -105,9 +112,7 @@ impl<'a> FmtVisitor<'a> {\n         let mut rewrite_next_comment = true;\n \n         fn replace_chars(string: &str) -> String {\n-            string.chars()\n-                .map(|ch| if ch.is_whitespace() { ch } else { 'X' })\n-                .collect()\n+            string.chars().map(|ch| if ch.is_whitespace() { ch } else { 'X' }).collect()\n         }\n \n         let replaced = match self.config.write_mode {\n@@ -154,9 +159,10 @@ impl<'a> FmtVisitor<'a> {\n \n                     if let Some('/') = subslice.chars().skip(1).next() {\n                         // check that there are no contained block comments\n-                        if !subslice.split('\\n')\n-                                .map(|s| s.trim_left())\n-                                .any(|s| s.len() > 2 && &s[0..2] == \"/*\") {\n+                        if !subslice.split('\\n').map(|s| s.trim_left()).any(|s| {\n+                                                                                s.len() > 2 &&\n+                                                                                &s[0..2] == \"/*\"\n+                                                                            }) {\n                             // Add a newline after line comments\n                             self.buffer.push_str(\"\\n\");\n                         }"}, {"sha": "601506b4954dfcad20706cdb1eee6c49489471fe", "filename": "src/patterns.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -36,10 +36,10 @@ impl Rewrite for Pat {\n                 let sub_pat = match *sub_pat {\n                     Some(ref p) => {\n                         // 3 - ` @ `.\n-                        let width = try_opt!(shape.width\n-                                                 .checked_sub(prefix.len() + mut_infix.len() +\n-                                                              id_str.len() +\n-                                                              3));\n+                        let width = try_opt!(shape.width.checked_sub(prefix.len() +\n+                                                                     mut_infix.len() +\n+                                                                     id_str.len() +\n+                                                                     3));\n                         format!(\" @ {}\",\n                                 try_opt!(p.rewrite(context, Shape::legacy(width, shape.indent))))\n                     }\n@@ -90,15 +90,15 @@ impl Rewrite for Pat {\n             PatKind::Slice(ref prefix, ref slice_pat, ref suffix) => {\n                 // Rewrite all the sub-patterns.\n                 let prefix = prefix.iter().map(|p| p.rewrite(context, shape));\n-                let slice_pat =\n-                    slice_pat.as_ref()\n-                        .map(|p| Some(format!(\"{}..\", try_opt!(p.rewrite(context, shape)))));\n+                let slice_pat = slice_pat.as_ref().map(|p| {\n+                                                           Some(format!(\"{}..\",\n+                                                            try_opt!(p.rewrite(context, shape))))\n+                                                       });\n                 let suffix = suffix.iter().map(|p| p.rewrite(context, shape));\n \n                 // Munge them together.\n-                let pats: Option<Vec<String>> = prefix.chain(slice_pat.into_iter())\n-                    .chain(suffix)\n-                    .collect();\n+                let pats: Option<Vec<String>> =\n+                    prefix.chain(slice_pat.into_iter()).chain(suffix).collect();\n \n                 // Check that all the rewrites succeeded, and if not return None.\n                 let pats = try_opt!(pats);"}, {"sha": "39f9d40a627f41a7a485e1d6ae454dc3568deecc", "filename": "src/types.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -165,10 +165,10 @@ impl<'a> Rewrite for SegmentParam<'a> {\n                     TypeDensity::Compressed => format!(\"{}=\", binding.ident),\n                 };\n                 let budget = try_opt!(shape.width.checked_sub(result.len()));\n-                let rewrite =\n-                    try_opt!(binding.ty\n-                                 .rewrite(context,\n-                                          Shape::legacy(budget, shape.indent + result.len())));\n+                let rewrite = try_opt!(binding.ty.rewrite(context,\n+                                                          Shape::legacy(budget,\n+                                                                        shape.indent +\n+                                                                        result.len())));\n                 result.push_str(&rewrite);\n                 Some(result)\n             }\n@@ -208,7 +208,10 @@ fn rewrite_segment(path_context: PathContext,\n                     .chain(data.bindings.iter().map(|x| SegmentParam::Binding(&*x)))\n                     .collect::<Vec<_>>();\n \n-                let next_span_lo = param_list.last().unwrap().get_span().hi + BytePos(1);\n+                let next_span_lo = param_list.last()\n+                    .unwrap()\n+                    .get_span()\n+                    .hi + BytePos(1);\n                 let list_lo = context.codemap.span_after(codemap::mk_sp(*span_lo, span_hi), \"<\");\n                 let separator = if path_context == PathContext::Expr {\n                     \"::\"\n@@ -445,9 +448,8 @@ fn rewrite_bounded_lifetime<'b, I>(lt: &ast::Lifetime,\n     if bounds.len() == 0 {\n         Some(result)\n     } else {\n-        let appendix: Vec<_> = try_opt!(bounds.into_iter()\n-                                            .map(|b| b.rewrite(context, shape))\n-                                            .collect());\n+        let appendix: Vec<_> =\n+            try_opt!(bounds.into_iter().map(|b| b.rewrite(context, shape)).collect());\n         let colon = type_bound_colon(context);\n         let result = format!(\"{}{}{}\", result, colon, appendix.join(\" + \"));\n         wrap_str(result, context.config.max_width, shape)\n@@ -485,9 +487,7 @@ impl Rewrite for ast::TyParamBounds {\n             TypeDensity::Compressed => \"+\",\n             TypeDensity::Wide => \" + \",\n         };\n-        let strs: Vec<_> = try_opt!(self.iter()\n-                                        .map(|b| b.rewrite(context, shape))\n-                                        .collect());\n+        let strs: Vec<_> = try_opt!(self.iter().map(|b| b.rewrite(context, shape)).collect());\n         wrap_str(strs.join(joiner), context.config.max_width, shape)\n     }\n }\n@@ -543,10 +543,10 @@ impl Rewrite for ast::PolyTraitRef {\n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;\n             let max_path_width = try_opt!(shape.width.checked_sub(extra_offset));\n-            let path_str = try_opt!(self.trait_ref\n-                                        .rewrite(context,\n-                                                 Shape::legacy(max_path_width,\n-                                                               shape.indent + extra_offset)));\n+            let path_str = try_opt!(self.trait_ref.rewrite(context,\n+                                                           Shape::legacy(max_path_width,\n+                                                                         shape.indent +\n+                                                                         extra_offset)));\n \n             Some(if context.config.spaces_within_angle_brackets && lifetime_str.len() > 0 {\n                      format!(\"for< {} > {}\", lifetime_str, path_str)\n@@ -592,11 +592,10 @@ impl Rewrite for ast::Ty {\n                     format!(\"&{} {}{}\",\n                             lt_str,\n                             mut_str,\n-                            try_opt!(mt.ty\n-                                         .rewrite(context,\n-                                                  Shape::legacy(budget,\n-                                                                shape.indent + 2 + mut_len +\n-                                                                lt_len))))\n+                            try_opt!(mt.ty.rewrite(context,\n+                                                   Shape::legacy(budget,\n+                                                                 shape.indent + 2 + mut_len +\n+                                                                 lt_len))))\n                 }\n                          None => {\n                     let budget = try_opt!(shape.width.checked_sub(1 + mut_len));"}, {"sha": "999e1192b5d27e39eff66ba64cb2544800aabbce", "filename": "src/utils.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -278,7 +278,11 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, shape: Shape) -> Option<S\n             // indentation.\n             // A special check for the last line, since the caller may\n             // place trailing characters on this line.\n-            if snippet.lines().rev().next().unwrap().len() > shape.indent.width() + shape.width {\n+            if snippet.lines()\n+                   .rev()\n+                   .next()\n+                   .unwrap()\n+                   .len() > shape.indent.width() + shape.width {\n                 return None;\n             }\n         }"}, {"sha": "2f5258df235fd604296ef6cd4d7cbf9c90508c15", "filename": "tests/system.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b83ae7dfb7f20825f666ecc78d5f7ad97597b1/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=33b83ae7dfb7f20825f666ecc78d5f7ad97597b1", "patch": "@@ -84,8 +84,7 @@ fn assert_output(source: &str, expected_filename: &str) {\n \n     let mut expected_file = fs::File::open(&expected_filename).expect(\"Couldn't open target\");\n     let mut expected_text = String::new();\n-    expected_file.read_to_string(&mut expected_text)\n-        .expect(\"Failed reading target\");\n+    expected_file.read_to_string(&mut expected_text).expect(\"Failed reading target\");\n \n     let compare = make_diff(&expected_text, &output, DIFF_CONTEXT_SIZE);\n     if compare.len() > 0 {\n@@ -101,9 +100,8 @@ fn assert_output(source: &str, expected_filename: &str) {\n #[test]\n fn idempotence_tests() {\n     // Get all files in the tests/target directory.\n-    let files = fs::read_dir(\"tests/target\")\n-        .expect(\"Couldn't read target dir\")\n-        .map(get_path_string);\n+    let files =\n+        fs::read_dir(\"tests/target\").expect(\"Couldn't read target dir\").map(get_path_string);\n     let (_reports, count, fails) = check_files(files);\n \n     // Display results."}]}