{"sha": "8993358e77b82a3c8745c1200c2ac5f3640a7053", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5OTMzNThlNzdiODJhM2M4NzQ1YzEyMDBjMmFjNWYzNjQwYTcwNTM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-03-31T22:27:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-31T22:27:20Z"}, "message": "Rollup merge of #70081 - lcnr:issue68387, r=varkor\n\nadd `unused_braces` lint\n\nAdd the lint `unused_braces` which is warn by default.\n\n`unused_parens` is also extended and now checks anon consts.\n\ncloses #68387\n\nr? @varkor", "tree": {"sha": "35fd72dd3b901f33e364a04d80f7e823024eca24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35fd72dd3b901f33e364a04d80f7e823024eca24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8993358e77b82a3c8745c1200c2ac5f3640a7053", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeg8PICRBK7hj4Ov3rIwAAdHIIAKHaXkQN46u29DorTieLW+pq\nul+Y7Pw0HVRxnxJbxKqykk/wk/BmLdbeLSFLPTt3fcqsEHcYXabayJMSZtKeq2Qf\nuDA7eFk5Cn4/MkHofU/SxjOvB1Bhtc/7mf6rllUAtGFjPKOtgFQtR9j4oroFJ8dc\n9S+m6+DXkfIZ8vUvTbpFaeBf8waDhScO/IvQmWibODilkmXrjSjS2hXSVqRs4COC\n8/Js8pCkc6WcqCKGetoDNQinHqfpPrhCnfuopNaI+YQ3SZ7jdrwhyVplasuFZixt\nDJmyWmfqMDlMBdpJe/6THt0PI7s/R1Gpj5RBDcUPRKWF/thRursYM3EXE4xnArM=\n=AzsZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 35fd72dd3b901f33e364a04d80f7e823024eca24\nparent 718ba0d23bc13cd987acbb1b2286552eeee88a1d\nparent bab327c725bf084d0ec5c27527588b71b0a1ab1d\nauthor Dylan DPC <dylan.dpc@gmail.com> 1585693640 +0200\ncommitter GitHub <noreply@github.com> 1585693640 +0200\n\nRollup merge of #70081 - lcnr:issue68387, r=varkor\n\nadd `unused_braces` lint\n\nAdd the lint `unused_braces` which is warn by default.\n\n`unused_parens` is also extended and now checks anon consts.\n\ncloses #68387\n\nr? @varkor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8993358e77b82a3c8745c1200c2ac5f3640a7053", "html_url": "https://github.com/rust-lang/rust/commit/8993358e77b82a3c8745c1200c2ac5f3640a7053", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8993358e77b82a3c8745c1200c2ac5f3640a7053/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "718ba0d23bc13cd987acbb1b2286552eeee88a1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/718ba0d23bc13cd987acbb1b2286552eeee88a1d", "html_url": "https://github.com/rust-lang/rust/commit/718ba0d23bc13cd987acbb1b2286552eeee88a1d"}, {"sha": "bab327c725bf084d0ec5c27527588b71b0a1ab1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bab327c725bf084d0ec5c27527588b71b0a1ab1d", "html_url": "https://github.com/rust-lang/rust/commit/bab327c725bf084d0ec5c27527588b71b0a1ab1d"}], "stats": {"total": 735, "additions": 559, "deletions": 176}, "files": [{"sha": "f6b8d4ba081467647534044fe3dbbfe4428f4d3d", "filename": "src/libcore/array/iter.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -39,7 +39,7 @@ where\n     alive: Range<usize>,\n }\n \n-impl<T, const N: usize> IntoIter<T, { N }>\n+impl<T, const N: usize> IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -99,7 +99,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> Iterator for IntoIter<T, { N }>\n+impl<T, const N: usize> Iterator for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -146,7 +146,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, { N }>\n+impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -182,7 +182,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> Drop for IntoIter<T, { N }>\n+impl<T, const N: usize> Drop for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -195,7 +195,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> ExactSizeIterator for IntoIter<T, { N }>\n+impl<T, const N: usize> ExactSizeIterator for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -210,17 +210,17 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> FusedIterator for IntoIter<T, { N }> where [T; N]: LengthAtMost32 {}\n+impl<T, const N: usize> FusedIterator for IntoIter<T, N> where [T; N]: LengthAtMost32 {}\n \n // The iterator indeed reports the correct length. The number of \"alive\"\n // elements (that will still be yielded) is the length of the range `alive`.\n // This range is decremented in length in either `next` or `next_back`. It is\n // always decremented by 1 in those methods, but only if `Some(_)` is returned.\n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, { N }> where [T; N]: LengthAtMost32 {}\n+unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, N> where [T; N]: LengthAtMost32 {}\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T: Clone, const N: usize> Clone for IntoIter<T, { N }>\n+impl<T: Clone, const N: usize> Clone for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -249,7 +249,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, { N }>\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {"}, {"sha": "018e9da243c70a34f1319ef6549f6e8544f2779a", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -104,6 +104,11 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         run_early_pass!(self, check_pat_post, p);\n     }\n \n+    fn visit_anon_const(&mut self, c: &'a ast::AnonConst) {\n+        run_early_pass!(self, check_anon_const, c);\n+        ast_visit::walk_anon_const(self, c);\n+    }\n+\n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n         self.with_lint_attrs(e.id, &e.attrs, |cx| {\n             run_early_pass!(cx, check_expr, e);"}, {"sha": "af1fad2c6608be402f129cfa62f77891c8d869e9", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -104,6 +104,7 @@ macro_rules! early_lint_passes {\n             $args,\n             [\n                 UnusedParens: UnusedParens,\n+                UnusedBraces: UnusedBraces,\n                 UnusedImportBraces: UnusedImportBraces,\n                 UnsafeCode: UnsafeCode,\n                 AnonymousParameters: AnonymousParameters,\n@@ -275,6 +276,7 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n         UNUSED_FEATURES,\n         UNUSED_LABELS,\n         UNUSED_PARENS,\n+        UNUSED_BRACES,\n         REDUNDANT_SEMICOLONS\n     );\n "}, {"sha": "c9e12afedbbab6fd3cf24d1da39fa563b0c79de8", "filename": "src/librustc_lint/passes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibrustc_lint%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibrustc_lint%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fpasses.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -170,6 +170,7 @@ macro_rules! early_lint_methods {\n             fn check_stmt(a: &ast::Stmt);\n             fn check_arm(a: &ast::Arm);\n             fn check_pat(a: &ast::Pat);\n+            fn check_anon_const(a: &ast::AnonConst);\n             fn check_pat_post(a: &ast::Pat);\n             fn check_expr(a: &ast::Expr);\n             fn check_expr_post(a: &ast::Expr);"}, {"sha": "c74b399555a8a874ff96bd74e75af1aeb1515019", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 363, "deletions": 129, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,5 +1,7 @@\n+use crate::Lint;\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast::ast;\n+use rustc_ast::ast::{ExprKind, StmtKind};\n use rustc_ast::attr;\n use rustc_ast::util::parser;\n use rustc_ast_pretty::pprust;\n@@ -315,123 +317,108 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n     }\n }\n \n-declare_lint! {\n-    pub(super) UNUSED_PARENS,\n-    Warn,\n-    \"`if`, `match`, `while` and `return` do not need parentheses\"\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum UnusedDelimsCtx {\n+    FunctionArg,\n+    MethodArg,\n+    AssignedValue,\n+    IfCond,\n+    WhileCond,\n+    ForIterExpr,\n+    MatchScrutineeExpr,\n+    ReturnValue,\n+    BlockRetValue,\n+    LetScrutineeExpr,\n+    ArrayLenExpr,\n+    AnonConst,\n }\n \n-declare_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n+impl From<UnusedDelimsCtx> for &'static str {\n+    fn from(ctx: UnusedDelimsCtx) -> &'static str {\n+        match ctx {\n+            UnusedDelimsCtx::FunctionArg => \"function argument\",\n+            UnusedDelimsCtx::MethodArg => \"method argument\",\n+            UnusedDelimsCtx::AssignedValue => \"assigned value\",\n+            UnusedDelimsCtx::IfCond => \"`if` condition\",\n+            UnusedDelimsCtx::WhileCond => \"`while` condition\",\n+            UnusedDelimsCtx::ForIterExpr => \"`for` iterator expression\",\n+            UnusedDelimsCtx::MatchScrutineeExpr => \"`match` scrutinee expression\",\n+            UnusedDelimsCtx::ReturnValue => \"`return` value\",\n+            UnusedDelimsCtx::BlockRetValue => \"block return value\",\n+            UnusedDelimsCtx::LetScrutineeExpr => \"`let` scrutinee expression\",\n+            UnusedDelimsCtx::ArrayLenExpr | UnusedDelimsCtx::AnonConst => \"const expression\",\n+        }\n+    }\n+}\n \n-impl UnusedParens {\n-    fn is_expr_parens_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n+/// Used by both `UnusedParens` and `UnusedBraces` to prevent code duplication.\n+trait UnusedDelimLint {\n+    const DELIM_STR: &'static str;\n+\n+    // this cannot be a constant is it refers to a static.\n+    fn lint(&self) -> &'static Lint;\n+\n+    fn check_unused_delims_expr(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Expr,\n+        ctx: UnusedDelimsCtx,\n+        followed_by_block: bool,\n+        left_pos: Option<BytePos>,\n+        right_pos: Option<BytePos>,\n+    );\n+\n+    fn is_expr_delims_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n         followed_by_block\n             && match inner.kind {\n                 ast::ExprKind::Ret(_) | ast::ExprKind::Break(..) => true,\n                 _ => parser::contains_exterior_struct_lit(&inner),\n             }\n     }\n \n-    fn check_unused_parens_expr(\n+    fn emit_unused_delims_expr(\n         &self,\n         cx: &EarlyContext<'_>,\n         value: &ast::Expr,\n-        msg: &str,\n-        followed_by_block: bool,\n+        ctx: UnusedDelimsCtx,\n         left_pos: Option<BytePos>,\n         right_pos: Option<BytePos>,\n     ) {\n-        match value.kind {\n-            ast::ExprKind::Paren(ref inner) => {\n-                if !Self::is_expr_parens_necessary(inner, followed_by_block)\n-                    && value.attrs.is_empty()\n-                    && !value.span.from_expansion()\n-                {\n-                    let expr_text =\n-                        if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n-                            snippet\n-                        } else {\n-                            pprust::expr_to_string(value)\n-                        };\n-                    let keep_space = (\n-                        left_pos.map(|s| s >= value.span.lo()).unwrap_or(false),\n-                        right_pos.map(|s| s <= value.span.hi()).unwrap_or(false),\n-                    );\n-                    Self::remove_outer_parens(cx, value.span, &expr_text, msg, keep_space);\n-                }\n-            }\n-            ast::ExprKind::Let(_, ref expr) => {\n-                // FIXME(#60336): Properly handle `let true = (false && true)`\n-                // actually needing the parenthesis.\n-                self.check_unused_parens_expr(\n-                    cx,\n-                    expr,\n-                    \"`let` head expression\",\n-                    followed_by_block,\n-                    None,\n-                    None,\n-                );\n-            }\n-            _ => {}\n-        }\n+        let expr_text = if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n+            snippet\n+        } else {\n+            pprust::expr_to_string(value)\n+        };\n+        let keep_space = (\n+            left_pos.map(|s| s >= value.span.lo()).unwrap_or(false),\n+            right_pos.map(|s| s <= value.span.hi()).unwrap_or(false),\n+        );\n+        self.emit_unused_delims(cx, value.span, &expr_text, ctx.into(), keep_space);\n     }\n \n-    fn check_unused_parens_pat(\n+    fn emit_unused_delims(\n         &self,\n-        cx: &EarlyContext<'_>,\n-        value: &ast::Pat,\n-        avoid_or: bool,\n-        avoid_mut: bool,\n-    ) {\n-        use ast::{BindingMode, Mutability, PatKind};\n-\n-        if let PatKind::Paren(inner) = &value.kind {\n-            match inner.kind {\n-                // The lint visitor will visit each subpattern of `p`. We do not want to lint\n-                // any range pattern no matter where it occurs in the pattern. For something like\n-                // `&(a..=b)`, there is a recursive `check_pat` on `a` and `b`, but we will assume\n-                // that if there are unnecessary parens they serve a purpose of readability.\n-                PatKind::Range(..) => return,\n-                // Avoid `p0 | .. | pn` if we should.\n-                PatKind::Or(..) if avoid_or => return,\n-                // Avoid `mut x` and `mut x @ p` if we should:\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ..) if avoid_mut => return,\n-                // Otherwise proceed with linting.\n-                _ => {}\n-            }\n-\n-            let pattern_text =\n-                if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n-                    snippet\n-                } else {\n-                    pprust::pat_to_string(value)\n-                };\n-            Self::remove_outer_parens(cx, value.span, &pattern_text, \"pattern\", (false, false));\n-        }\n-    }\n-\n-    fn remove_outer_parens(\n         cx: &EarlyContext<'_>,\n         span: Span,\n         pattern: &str,\n         msg: &str,\n         keep_space: (bool, bool),\n     ) {\n-        cx.struct_span_lint(UNUSED_PARENS, span, |lint| {\n-            let span_msg = format!(\"unnecessary parentheses around {}\", msg);\n+        cx.struct_span_lint(self.lint(), span, |lint| {\n+            let span_msg = format!(\"unnecessary {} around {}\", Self::DELIM_STR, msg);\n             let mut err = lint.build(&span_msg);\n             let mut ate_left_paren = false;\n             let mut ate_right_paren = false;\n             let parens_removed = pattern.trim_matches(|c| match c {\n-                '(' => {\n+                '(' | '{' => {\n                     if ate_left_paren {\n                         false\n                     } else {\n                         ate_left_paren = true;\n                         true\n                     }\n                 }\n-                ')' => {\n+                ')' | '}' => {\n                     if ate_right_paren {\n                         false\n                     } else {\n@@ -457,61 +444,51 @@ impl UnusedParens {\n                 replace\n             };\n \n-            err.span_suggestion_short(\n-                span,\n-                \"remove these parentheses\",\n-                replace,\n-                Applicability::MachineApplicable,\n-            );\n+            let suggestion = format!(\"remove these {}\", Self::DELIM_STR);\n+\n+            err.span_suggestion_short(span, &suggestion, replace, Applicability::MachineApplicable);\n             err.emit();\n         });\n     }\n-}\n \n-impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use rustc_ast::ast::ExprKind::*;\n-        let (value, msg, followed_by_block, left_pos, right_pos) = match e.kind {\n-            Let(ref pat, ..) => {\n-                self.check_unused_parens_pat(cx, pat, false, false);\n-                return;\n-            }\n-\n+        let (value, ctx, followed_by_block, left_pos, right_pos) = match e.kind {\n             If(ref cond, ref block, ..) => {\n                 let left = e.span.lo() + rustc_span::BytePos(2);\n                 let right = block.span.lo();\n-                (cond, \"`if` condition\", true, Some(left), Some(right))\n+                (cond, UnusedDelimsCtx::IfCond, true, Some(left), Some(right))\n             }\n \n             While(ref cond, ref block, ..) => {\n                 let left = e.span.lo() + rustc_span::BytePos(5);\n                 let right = block.span.lo();\n-                (cond, \"`while` condition\", true, Some(left), Some(right))\n+                (cond, UnusedDelimsCtx::WhileCond, true, Some(left), Some(right))\n             }\n \n-            ForLoop(ref pat, ref cond, ref block, ..) => {\n-                self.check_unused_parens_pat(cx, pat, false, false);\n-                (cond, \"`for` head expression\", true, None, Some(block.span.lo()))\n+            ForLoop(_, ref cond, ref block, ..) => {\n+                (cond, UnusedDelimsCtx::ForIterExpr, true, None, Some(block.span.lo()))\n             }\n \n             Match(ref head, _) => {\n                 let left = e.span.lo() + rustc_span::BytePos(5);\n-                (head, \"`match` head expression\", true, Some(left), None)\n+                (head, UnusedDelimsCtx::MatchScrutineeExpr, true, Some(left), None)\n             }\n \n             Ret(Some(ref value)) => {\n                 let left = e.span.lo() + rustc_span::BytePos(3);\n-                (value, \"`return` value\", false, Some(left), None)\n+                (value, UnusedDelimsCtx::ReturnValue, false, Some(left), None)\n             }\n \n-            Assign(_, ref value, _) => (value, \"assigned value\", false, None, None),\n-            AssignOp(.., ref value) => (value, \"assigned value\", false, None, None),\n+            Assign(_, ref value, _) | AssignOp(.., ref value) => {\n+                (value, UnusedDelimsCtx::AssignedValue, false, None, None)\n+            }\n             // either function/method call, or something this lint doesn't care about\n             ref call_or_other => {\n-                let (args_to_check, call_kind) = match *call_or_other {\n-                    Call(_, ref args) => (&args[..], \"function\"),\n-                    // first \"argument\" is self (which sometimes needs parens)\n-                    MethodCall(_, ref args) => (&args[1..], \"method\"),\n+                let (args_to_check, ctx) = match *call_or_other {\n+                    Call(_, ref args) => (&args[..], UnusedDelimsCtx::FunctionArg),\n+                    // first \"argument\" is self (which sometimes needs delims)\n+                    MethodCall(_, ref args) => (&args[1..], UnusedDelimsCtx::MethodArg),\n                     // actual catch-all arm\n                     _ => {\n                         return;\n@@ -524,14 +501,152 @@ impl EarlyLintPass for UnusedParens {\n                 if e.span.ctxt().outer_expn_data().call_site.from_expansion() {\n                     return;\n                 }\n-                let msg = format!(\"{} argument\", call_kind);\n                 for arg in args_to_check {\n-                    self.check_unused_parens_expr(cx, arg, &msg, false, None, None);\n+                    self.check_unused_delims_expr(cx, arg, ctx, false, None, None);\n                 }\n                 return;\n             }\n         };\n-        self.check_unused_parens_expr(cx, &value, msg, followed_by_block, left_pos, right_pos);\n+        self.check_unused_delims_expr(cx, &value, ctx, followed_by_block, left_pos, right_pos);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n+        match s.kind {\n+            StmtKind::Local(ref local) => {\n+                if let Some(ref value) = local.init {\n+                    self.check_unused_delims_expr(\n+                        cx,\n+                        &value,\n+                        UnusedDelimsCtx::AssignedValue,\n+                        false,\n+                        None,\n+                        None,\n+                    );\n+                }\n+            }\n+            StmtKind::Expr(ref expr) => {\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    &expr,\n+                    UnusedDelimsCtx::BlockRetValue,\n+                    false,\n+                    None,\n+                    None,\n+                );\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        use ast::ItemKind::*;\n+\n+        if let Const(.., Some(expr)) | Static(.., Some(expr)) = &item.kind {\n+            self.check_unused_delims_expr(\n+                cx,\n+                expr,\n+                UnusedDelimsCtx::AssignedValue,\n+                false,\n+                None,\n+                None,\n+            );\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub(super) UNUSED_PARENS,\n+    Warn,\n+    \"`if`, `match`, `while` and `return` do not need parentheses\"\n+}\n+\n+declare_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n+\n+impl UnusedDelimLint for UnusedParens {\n+    const DELIM_STR: &'static str = \"parentheses\";\n+\n+    fn lint(&self) -> &'static Lint {\n+        UNUSED_PARENS\n+    }\n+\n+    fn check_unused_delims_expr(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Expr,\n+        ctx: UnusedDelimsCtx,\n+        followed_by_block: bool,\n+        left_pos: Option<BytePos>,\n+        right_pos: Option<BytePos>,\n+    ) {\n+        match value.kind {\n+            ast::ExprKind::Paren(ref inner) => {\n+                if !Self::is_expr_delims_necessary(inner, followed_by_block)\n+                    && value.attrs.is_empty()\n+                    && !value.span.from_expansion()\n+                {\n+                    self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n+                }\n+            }\n+            ast::ExprKind::Let(_, ref expr) => {\n+                // FIXME(#60336): Properly handle `let true = (false && true)`\n+                // actually needing the parenthesis.\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    expr,\n+                    UnusedDelimsCtx::LetScrutineeExpr,\n+                    followed_by_block,\n+                    None,\n+                    None,\n+                );\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+impl UnusedParens {\n+    fn check_unused_parens_pat(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Pat,\n+        avoid_or: bool,\n+        avoid_mut: bool,\n+    ) {\n+        use ast::{BindingMode, Mutability, PatKind};\n+\n+        if let PatKind::Paren(inner) = &value.kind {\n+            match inner.kind {\n+                // The lint visitor will visit each subpattern of `p`. We do not want to lint\n+                // any range pattern no matter where it occurs in the pattern. For something like\n+                // `&(a..=b)`, there is a recursive `check_pat` on `a` and `b`, but we will assume\n+                // that if there are unnecessary parens they serve a purpose of readability.\n+                PatKind::Range(..) => return,\n+                // Avoid `p0 | .. | pn` if we should.\n+                PatKind::Or(..) if avoid_or => return,\n+                // Avoid `mut x` and `mut x @ p` if we should:\n+                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ..) if avoid_mut => return,\n+                // Otherwise proceed with linting.\n+                _ => {}\n+            }\n+\n+            let pattern_text =\n+                if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n+                    snippet\n+                } else {\n+                    pprust::pat_to_string(value)\n+                };\n+            self.emit_unused_delims(cx, value.span, &pattern_text, \"pattern\", (false, false));\n+        }\n+    }\n+}\n+\n+impl EarlyLintPass for UnusedParens {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        if let ExprKind::Let(ref pat, ..) | ExprKind::ForLoop(ref pat, ..) = e.kind {\n+            self.check_unused_parens_pat(cx, pat, false, false);\n+        }\n+\n+        <Self as UnusedDelimLint>::check_expr(self, cx, e)\n     }\n \n     fn check_pat(&mut self, cx: &EarlyContext<'_>, p: &ast::Pat) {\n@@ -556,22 +671,16 @@ impl EarlyLintPass for UnusedParens {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n-        use ast::StmtKind::*;\n-\n-        match s.kind {\n-            Local(ref local) => {\n-                self.check_unused_parens_pat(cx, &local.pat, false, false);\n+    fn check_anon_const(&mut self, cx: &EarlyContext<'_>, c: &ast::AnonConst) {\n+        self.check_unused_delims_expr(cx, &c.value, UnusedDelimsCtx::AnonConst, false, None, None);\n+    }\n \n-                if let Some(ref value) = local.init {\n-                    self.check_unused_parens_expr(cx, &value, \"assigned value\", false, None, None);\n-                }\n-            }\n-            Expr(ref expr) => {\n-                self.check_unused_parens_expr(cx, &expr, \"block return value\", false, None, None);\n-            }\n-            _ => {}\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n+        if let StmtKind::Local(ref local) = s.kind {\n+            self.check_unused_parens_pat(cx, &local.pat, false, false);\n         }\n+\n+        <Self as UnusedDelimLint>::check_stmt(self, cx, s)\n     }\n \n     fn check_param(&mut self, cx: &EarlyContext<'_>, param: &ast::Param) {\n@@ -587,6 +696,16 @@ impl EarlyLintPass for UnusedParens {\n             match &r.kind {\n                 &ast::TyKind::TraitObject(..) => {}\n                 &ast::TyKind::ImplTrait(_, ref bounds) if bounds.len() > 1 => {}\n+                &ast::TyKind::Array(_, ref len) => {\n+                    self.check_unused_delims_expr(\n+                        cx,\n+                        &len.value,\n+                        UnusedDelimsCtx::ArrayLenExpr,\n+                        false,\n+                        None,\n+                        None,\n+                    );\n+                }\n                 _ => {\n                     let pattern_text =\n                         if let Ok(snippet) = cx.sess().source_map().span_to_snippet(ty.span) {\n@@ -595,19 +714,134 @@ impl EarlyLintPass for UnusedParens {\n                             pprust::ty_to_string(ty)\n                         };\n \n-                    Self::remove_outer_parens(cx, ty.span, &pattern_text, \"type\", (false, false));\n+                    self.emit_unused_delims(cx, ty.span, &pattern_text, \"type\", (false, false));\n                 }\n             }\n         }\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n-        use ast::ItemKind::*;\n+        <Self as UnusedDelimLint>::check_item(self, cx, item)\n+    }\n+}\n \n-        if let Const(.., Some(expr)) | Static(.., Some(expr)) = &item.kind {\n-            self.check_unused_parens_expr(cx, expr, \"assigned value\", false, None, None);\n+declare_lint! {\n+    pub(super) UNUSED_BRACES,\n+    Warn,\n+    \"unnecessary braces around an expression\"\n+}\n+\n+declare_lint_pass!(UnusedBraces => [UNUSED_BRACES]);\n+\n+impl UnusedDelimLint for UnusedBraces {\n+    const DELIM_STR: &'static str = \"braces\";\n+\n+    fn lint(&self) -> &'static Lint {\n+        UNUSED_BRACES\n+    }\n+\n+    fn check_unused_delims_expr(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Expr,\n+        ctx: UnusedDelimsCtx,\n+        followed_by_block: bool,\n+        left_pos: Option<BytePos>,\n+        right_pos: Option<BytePos>,\n+    ) {\n+        match value.kind {\n+            ast::ExprKind::Block(ref inner, None)\n+                if inner.rules == ast::BlockCheckMode::Default =>\n+            {\n+                // emit a warning under the following conditions:\n+                //\n+                // - the block does not have a label\n+                // - the block is not `unsafe`\n+                // - the block contains exactly one expression (do not lint `{ expr; }`)\n+                // - `followed_by_block` is true and the internal expr may contain a `{`\n+                // - the block is not multiline (do not lint multiline match arms)\n+                //      ```\n+                //      match expr {\n+                //          Pattern => {\n+                //              somewhat_long_expression\n+                //          }\n+                //          // ...\n+                //      }\n+                //      ```\n+                // - the block has no attribute and was not created inside a macro\n+                // - if the block is an `anon_const`, the inner expr must be a literal\n+                //      (do not lint `struct A<const N: usize>; let _: A<{ 2 + 3 }>;`)\n+                //\n+                // FIXME(const_generics): handle paths when #67075 is fixed.\n+                if let [stmt] = inner.stmts.as_slice() {\n+                    if let ast::StmtKind::Expr(ref expr) = stmt.kind {\n+                        if !Self::is_expr_delims_necessary(expr, followed_by_block)\n+                            && (ctx != UnusedDelimsCtx::AnonConst\n+                                || matches!(expr.kind, ast::ExprKind::Lit(_)))\n+                            // array length expressions are checked during `check_anon_const` and `check_ty`,\n+                            // once as `ArrayLenExpr` and once as `AnonConst`.\n+                            //\n+                            // As we do not want to lint this twice, we do not emit an error for\n+                            // `ArrayLenExpr` if `AnonConst` would do the same.\n+                            && (ctx != UnusedDelimsCtx::ArrayLenExpr\n+                                || !matches!(expr.kind, ast::ExprKind::Lit(_)))\n+                            && !cx.sess().source_map().is_multiline(value.span)\n+                            && value.attrs.is_empty()\n+                            && !value.span.from_expansion()\n+                        {\n+                            self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n+                        }\n+                    }\n+                }\n+            }\n+            ast::ExprKind::Let(_, ref expr) => {\n+                // FIXME(#60336): Properly handle `let true = (false && true)`\n+                // actually needing the parenthesis.\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    expr,\n+                    UnusedDelimsCtx::LetScrutineeExpr,\n+                    followed_by_block,\n+                    None,\n+                    None,\n+                );\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+impl EarlyLintPass for UnusedBraces {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        <Self as UnusedDelimLint>::check_expr(self, cx, e)\n+    }\n+\n+    fn check_anon_const(&mut self, cx: &EarlyContext<'_>, c: &ast::AnonConst) {\n+        self.check_unused_delims_expr(cx, &c.value, UnusedDelimsCtx::AnonConst, false, None, None);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n+        <Self as UnusedDelimLint>::check_stmt(self, cx, s)\n+    }\n+\n+    fn check_ty(&mut self, cx: &EarlyContext<'_>, ty: &ast::Ty) {\n+        if let &ast::TyKind::Paren(ref r) = &ty.kind {\n+            if let ast::TyKind::Array(_, ref len) = r.kind {\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    &len.value,\n+                    UnusedDelimsCtx::ArrayLenExpr,\n+                    false,\n+                    None,\n+                    None,\n+                );\n+            }\n         }\n     }\n+\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        <Self as UnusedDelimLint>::check_item(self, cx, item)\n+    }\n }\n \n declare_lint! {"}, {"sha": "7ed77304a90e1b07a26492ea1b0eb824c1424233", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -356,9 +356,11 @@ fn add_query_description_impl(\n                 quote! { #t }\n             })\n             .unwrap_or(quote! { _ });\n+        // expr is a `Block`, meaning that `{ #expr }` gets expanded\n+        // to `{ { stmts... } }`, which triggers the `unused_braces` lint.\n         quote! {\n             #[inline]\n-            #[allow(unused_variables)]\n+            #[allow(unused_variables, unused_braces)]\n             fn cache_on_disk(\n                 #tcx: TyCtxt<'tcx>,\n                 #key: Self::Key,"}, {"sha": "21f43b6fd4f6473b20e6bb735c681141171280b1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -2808,7 +2808,7 @@ impl<'a> Resolver<'a> {\n             ast::Path {\n                 span,\n                 segments: iter::once(Ident::with_dummy_span(kw::PathRoot))\n-                    .chain({ path_str.split(\"::\").skip(1).map(Ident::from_str) })\n+                    .chain(path_str.split(\"::\").skip(1).map(Ident::from_str))\n                     .map(|i| self.new_ast_path_segment(i))\n                     .collect(),\n             }"}, {"sha": "d00381792e351dfe185f54adad843c6c0bc53ec7", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -115,8 +115,7 @@ impl RawHandle {\n     ) -> io::Result<Option<usize>> {\n         let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n         let mut amt = 0;\n-        let res =\n-            cvt({ c::ReadFile(self.0, buf.as_ptr() as c::LPVOID, len, &mut amt, overlapped) });\n+        let res = cvt(c::ReadFile(self.0, buf.as_ptr() as c::LPVOID, len, &mut amt, overlapped));\n         match res {\n             Ok(_) => Ok(Some(amt as usize)),\n             Err(e) => {\n@@ -139,7 +138,7 @@ impl RawHandle {\n         unsafe {\n             let mut bytes = 0;\n             let wait = if wait { c::TRUE } else { c::FALSE };\n-            let res = cvt({ c::GetOverlappedResult(self.raw(), overlapped, &mut bytes, wait) });\n+            let res = cvt(c::GetOverlappedResult(self.raw(), overlapped, &mut bytes, wait));\n             match res {\n                 Ok(_) => Ok(bytes as usize),\n                 Err(e) => {"}, {"sha": "a193bf998dc73e5104b8aa3358ba2452fa6b2fb3", "filename": "src/test/incremental/const-generics/issue-61516.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-61516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-61516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-61516.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -4,7 +4,7 @@\n \n struct FakeArray<T, const N: usize>(T);\n \n-impl<T, const N: usize> FakeArray<T, { N }> {\n+impl<T, const N: usize> FakeArray<T, N> {\n     fn len(&self) -> usize {\n         N\n     }"}, {"sha": "908c39c7951c06ad510df8db8be8f0906594d539", "filename": "src/test/ui/array-slice-vec/vec-fixed-length.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-fixed-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-fixed-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-fixed-length.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -9,7 +9,7 @@ fn test_big_vec() {}\n #[cfg(target_pointer_width = \"64\")]\n fn test_big_vec()\n {\n-    assert_eq!(size_of::<[u8; (1 << 32)]>(), (1 << 32));\n+    assert_eq!(size_of::<[u8; 1 << 32]>(), (1 << 32));\n }\n \n fn main() {"}, {"sha": "d993ad9945974bc7091b8798c9ccc4e44af36965", "filename": "src/test/ui/block-fn-coerce.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fblock-fn-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fblock-fn-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-fn-coerce.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n \n fn force<F>(f: F) -> isize where F: FnOnce() -> isize { return f(); }\n "}, {"sha": "c5dd87c0f5a1fb712de242c120c997ab00e82559", "filename": "src/test/ui/cleanup-rvalue-scopes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fcleanup-rvalue-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fcleanup-rvalue-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcleanup-rvalue-scopes.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![allow(non_snake_case)]\n #![allow(unused_variables)]\n // Test that destructors for rvalue temporaries run either at end of"}, {"sha": "d486fdf73aba8d795a1dde8c4ff37ad921efed26", "filename": "src/test/ui/coerce/coerce-expect-unsized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fcoerce%2Fcoerce-expect-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fcoerce%2Fcoerce-expect-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoerce%2Fcoerce-expect-unsized.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n #![feature(box_syntax)]\n \n use std::cell::RefCell;"}, {"sha": "d5484607c8b52021ab31d7b36e7a7b688d904543", "filename": "src/test/ui/coerce/coerce-overloaded-autoderef.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fcoerce%2Fcoerce-overloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fcoerce%2Fcoerce-overloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoerce%2Fcoerce-overloaded-autoderef.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n #![allow(dead_code)]\n // pretty-expanded FIXME #23616\n "}, {"sha": "212e16253f6b812cb507a8499821faab666030e1", "filename": "src/test/ui/const-generics/issues/issue-62504.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -7,13 +7,13 @@ trait HasSize {\n     const SIZE: usize;\n }\n \n-impl<const X: usize> HasSize for ArrayHolder<{ X }> {\n+impl<const X: usize> HasSize for ArrayHolder<X> {\n     const SIZE: usize = X;\n }\n \n struct ArrayHolder<const X: usize>([u32; X]);\n \n-impl<const X: usize> ArrayHolder<{ X }> {\n+impl<const X: usize> ArrayHolder<X> {\n     pub const fn new() -> Self {\n         ArrayHolder([0; Self::SIZE])\n         //~^ ERROR: mismatched types"}, {"sha": "a3eca0dd7d965585fea9d5be467864248c589081", "filename": "src/test/ui/const-generics/issues/issue-70125-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70125-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70125-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70125-2.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -13,4 +13,4 @@ trait Foo<const X: usize> {\n     }\n }\n \n-impl Foo<{3}> for () {}\n+impl Foo<3> for () {}"}, {"sha": "05234faf714201f21db3bf6c80b5f83d0385f7d2", "filename": "src/test/ui/const-generics/unused_braces.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+#![warn(unused_braces)]\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+struct A<const N: usize>;\n+\n+fn main() {\n+    let _: A<7>; // ok\n+    let _: A<{ 7 }>; //~ WARN unnecessary braces\n+    let _: A<{ 3 + 5 }>; // ok\n+}"}, {"sha": "fc3da6096e7d447dd61561e6660ef976c3dedb39", "filename": "src/test/ui/const-generics/unused_braces.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.stderr?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -0,0 +1,20 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/unused_braces.rs:4:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: unnecessary braces around const expression\n+  --> $DIR/unused_braces.rs:11:14\n+   |\n+LL |     let _: A<{ 7 }>;\n+   |              ^^^^^ help: remove these braces\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused_braces.rs:2:9\n+   |\n+LL | #![warn(unused_braces)]\n+   |         ^^^^^^^^^^^^^\n+"}, {"sha": "ec99c70f6e0b90587871b0c66193b14950e1f440", "filename": "src/test/ui/consts/const-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fconsts%2Fconst-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fconsts%2Fconst-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-block.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![allow(dead_code)]\n #![allow(unused_unsafe)]\n "}, {"sha": "d081cb2be7ee39820bb146a6c5eab90f85a38ada", "filename": "src/test/ui/expr-block-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fexpr-block-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fexpr-block-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr-block-generic-unique1.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![feature(box_syntax)]\n \n fn test_generic<T, F>(expected: Box<T>, eq: F) where T: Clone, F: FnOnce(Box<T>, Box<T>) -> bool {"}, {"sha": "9362eb86fc30976dd713c7a408d70c05469bce09", "filename": "src/test/ui/expr-block-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr-block-generic-unique2.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![feature(box_syntax)]\n \n fn test_generic<T, F>(expected: T, eq: F) where T: Clone, F: FnOnce(T, T) -> bool {"}, {"sha": "29c7c42219c737df82b4aef911bfa8bd9d737f5d", "filename": "src/test/ui/expr-block-generic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr-block-generic.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n \n fn test_generic<T: Clone, F>(expected: T, eq: F) where F: FnOnce(T, T) -> bool {\n     let actual: T = { expected.clone() };"}, {"sha": "eff3fd3a15152a78e55d7d38d381d9c037de1ec1", "filename": "src/test/ui/expr-block-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fexpr-block-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fexpr-block-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr-block-unique.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![feature(box_syntax)]\n \n pub fn main() { let x: Box<_> = { box 100 }; assert_eq!(*x, 100); }"}, {"sha": "ff87595c934e9cca9375284d7df9bb88d4ab3168", "filename": "src/test/ui/expr-block.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr-block.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,10 +1,7 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![allow(dead_code)]\n \n-\n-\n-\n // Tests for standalone blocks as expressions\n \n fn test_basic() { let rs: bool = { true }; assert!((rs)); }"}, {"sha": "253cbfd5d38fa12f6926da761a2c5019aa8462e3", "filename": "src/test/ui/expr-fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fexpr-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fexpr-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr-fn.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n \n fn test_int() {\n     fn f() -> isize { 10 }"}, {"sha": "1877414f09942f99d75f2ea9e488175b7f176f25", "filename": "src/test/ui/functions-closures/closure-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-inference.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n \n fn foo(i: isize) -> isize { i + 1 }\n "}, {"sha": "4ce132e86caa4c89e5c2dadc7a513ba97585f499", "filename": "src/test/ui/functions-closures/closure-inference2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-inference2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-inference2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-inference2.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n // Test a rather underspecified example:\n-\n+#![allow(unused_braces)]\n \n pub fn main() {\n     let f = {|i| i};"}, {"sha": "9804c421db081cec72c5def5ef4305a808d921da", "filename": "src/test/ui/intrinsics/intrinsic-move-val-cleanups.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val-cleanups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val-cleanups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val-cleanups.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n #![allow(unused_unsafe)]\n #![allow(unreachable_code)]\n // ignore-emscripten no threads support"}, {"sha": "3de365675ad2214279537a8bcadd2e15dd588ec8", "filename": "src/test/ui/issues/issue-23898.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fissues%2Fissue-23898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fissues%2Fissue-23898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23898.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_parens)]\n #![allow(non_camel_case_types)]\n \n // Note: This test was used to demonstrate #5873 (now #23898)."}, {"sha": "1f426b7185e8f250c41a55f78c0124e1e6784495", "filename": "src/test/ui/issues/issue-28777.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fissues%2Fissue-28777.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fissues%2Fissue-28777.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28777.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n fn main() {\n     let v1 = { 1 + {2} * {3} };\n     let v2 =   1 + {2} * {3}  ;"}, {"sha": "623cd04d9bce35ddb1a65209554ef1c3ee0648a8", "filename": "src/test/ui/lint/lint-unnecessary-parens.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -48,11 +48,11 @@ fn main() {\n     if (true) {} //~ ERROR unnecessary parentheses around `if` condition\n     while (true) {} //~ ERROR unnecessary parentheses around `while` condition\n     //~^ WARN denote infinite loops with\n-    match (true) { //~ ERROR unnecessary parentheses around `match` head expression\n+    match (true) { //~ ERROR unnecessary parentheses around `match` scrutinee expression\n         _ => {}\n     }\n-    if let 1 = (1) {} //~ ERROR unnecessary parentheses around `let` head expression\n-    while let 1 = (2) {} //~ ERROR unnecessary parentheses around `let` head expression\n+    if let 1 = (1) {} //~ ERROR unnecessary parentheses around `let` scrutinee expression\n+    while let 1 = (2) {} //~ ERROR unnecessary parentheses around `let` scrutinee expression\n     let v = X { y: false };\n     // struct lits needs parens, so these shouldn't warn.\n     if (v == X { y: true }) {}"}, {"sha": "15184ba36ae85b68887575223c2ea413753c4f2b", "filename": "src/test/ui/lint/lint-unnecessary-parens.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -72,19 +72,19 @@ LL |     while (true) {}\n    |\n    = note: `#[warn(while_true)]` on by default\n \n-error: unnecessary parentheses around `match` head expression\n+error: unnecessary parentheses around `match` scrutinee expression\n   --> $DIR/lint-unnecessary-parens.rs:51:11\n    |\n LL |     match (true) {\n    |           ^^^^^^ help: remove these parentheses\n \n-error: unnecessary parentheses around `let` head expression\n+error: unnecessary parentheses around `let` scrutinee expression\n   --> $DIR/lint-unnecessary-parens.rs:54:16\n    |\n LL |     if let 1 = (1) {}\n    |                ^^^ help: remove these parentheses\n \n-error: unnecessary parentheses around `let` head expression\n+error: unnecessary parentheses around `let` scrutinee expression\n   --> $DIR/lint-unnecessary-parens.rs:55:19\n    |\n LL |     while let 1 = (2) {}"}, {"sha": "de456ee6c230cac9a7d4c9872ba1dbde8974386d", "filename": "src/test/ui/lint/unused_braces.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Funused_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Funused_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_braces.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -0,0 +1,31 @@\n+// check-pass\n+#![warn(unused_braces, unused_parens)]\n+\n+fn main() {\n+    let _ = (7);\n+    //~^WARN unnecessary parentheses\n+\n+    let _ = { 7 };\n+    //~^ WARN unnecessary braces\n+\n+    if let 7 = { 7 } {\n+        //~^ WARN unnecessary braces\n+    }\n+\n+    let _: [u8; { 3 }];\n+    //~^ WARN unnecessary braces\n+\n+    // do not emit error for multiline blocks.\n+    let _ = {\n+        7\n+    };\n+\n+    // do not emit error for unsafe blocks.\n+    let _ = unsafe { 7 };\n+\n+    // do not emit error, as the `{` would then\n+    // be parsed as part of the `return`.\n+    if { return } {\n+\n+    }\n+}"}, {"sha": "72f425ffc3e01147e88c6cc2b1c529545ded8de2", "filename": "src/test/ui/lint/unused_braces.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Funused_braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Funused_braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_braces.stderr?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -0,0 +1,36 @@\n+warning: unnecessary parentheses around assigned value\n+  --> $DIR/unused_braces.rs:5:13\n+   |\n+LL |     let _ = (7);\n+   |             ^^^ help: remove these parentheses\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused_braces.rs:2:24\n+   |\n+LL | #![warn(unused_braces, unused_parens)]\n+   |                        ^^^^^^^^^^^^^\n+\n+warning: unnecessary braces around assigned value\n+  --> $DIR/unused_braces.rs:8:13\n+   |\n+LL |     let _ = { 7 };\n+   |             ^^^^^ help: remove these braces\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused_braces.rs:2:9\n+   |\n+LL | #![warn(unused_braces, unused_parens)]\n+   |         ^^^^^^^^^^^^^\n+\n+warning: unnecessary braces around `let` scrutinee expression\n+  --> $DIR/unused_braces.rs:11:16\n+   |\n+LL |     if let 7 = { 7 } {\n+   |                ^^^^^ help: remove these braces\n+\n+warning: unnecessary braces around const expression\n+  --> $DIR/unused_braces.rs:15:17\n+   |\n+LL |     let _: [u8; { 3 }];\n+   |                 ^^^^^ help: remove these braces\n+"}, {"sha": "98dbbecfedde61ffeaaf3c738aa6416af090e72c", "filename": "src/test/ui/lint/unused_parens_borrow.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Funused_parens_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Funused_parens_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_borrow.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+#![warn(unused_braces)]\n+\n+// changing `&{ expr }` to `&expr` changes the semantic of the program\n+// so we should not warn this case\n+\n+#[repr(packed)]\n+struct A {\n+    a: u8,\n+    b: u32,\n+}\n+\n+fn main() {\n+    let a = A {\n+        a: 42,\n+        b: 1729,\n+    };\n+\n+    let _ = &{ a.b };\n+    let _ = { a.b };\n+    //~^ WARN unnecessary braces\n+}"}, {"sha": "7e3839ae4e0142fa53807a2d808a1ca88e836c14", "filename": "src/test/ui/lint/unused_parens_borrow.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Funused_parens_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Funused_parens_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_borrow.stderr?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -0,0 +1,12 @@\n+warning: unnecessary braces around assigned value\n+  --> $DIR/unused_parens_borrow.rs:20:13\n+   |\n+LL |     let _ = { a.b };\n+   |             ^^^^^^^ help: remove these braces\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused_parens_borrow.rs:2:9\n+   |\n+LL | #![warn(unused_braces)]\n+   |         ^^^^^^^^^^^^^\n+"}, {"sha": "5fb67fd7c95a3a99a8ff0cbbd4c7c9cbab1f4c97", "filename": "src/test/ui/lint/unused_parens_remove_json_suggestion.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.stderr?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -46,14 +46,14 @@ LL |     while(true && false) {\n    |          ^^^^^^^^^^^^^^^ help: remove these parentheses\n \n \"}\n-{\"message\":\"unnecessary parentheses around `for` head expression\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":987,\"byte_end\":995,\"line_start\":44,\"line_end\":44,\"column_start\":18,\"column_end\":26,\"is_primary\":true,\"text\":[{\"text\":\"        for _ in (0 .. 3){\n+{\"message\":\"unnecessary parentheses around `for` iterator expression\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":987,\"byte_end\":995,\"line_start\":44,\"line_end\":44,\"column_start\":18,\"column_end\":26,\"is_primary\":true,\"text\":[{\"text\":\"        for _ in (0 .. 3){\n   --> $DIR/unused_parens_remove_json_suggestion.rs:44:18\n    |\n LL |         for _ in (0 .. 3){\n    |                  ^^^^^^^^ help: remove these parentheses\n \n \"}\n-{\"message\":\"unnecessary parentheses around `for` head expression\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":1088,\"byte_end\":1096,\"line_start\":49,\"line_end\":49,\"column_start\":14,\"column_end\":22,\"is_primary\":true,\"text\":[{\"text\":\"    for _ in (0 .. 3) {\n+{\"message\":\"unnecessary parentheses around `for` iterator expression\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":1088,\"byte_end\":1096,\"line_start\":49,\"line_end\":49,\"column_start\":14,\"column_end\":22,\"is_primary\":true,\"text\":[{\"text\":\"    for _ in (0 .. 3) {\n   --> $DIR/unused_parens_remove_json_suggestion.rs:49:14\n    |\n LL |     for _ in (0 .. 3) {"}, {"sha": "f3f7508d12434870b3edd509c44dd0da1dc50828", "filename": "src/test/ui/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![allow(unused_comparisons)]\n #![allow(dead_code)]\n #![allow(unused_mut)]"}, {"sha": "540b35e0392de1ef5aad30813fc508b5805e6291", "filename": "src/test/ui/range_inclusive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange_inclusive.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n // Test inclusive range syntax.\n-\n #![feature(range_is_empty)]\n+#![allow(unused_braces)]\n #![allow(unused_comparisons)]\n \n use std::ops::RangeToInclusive;"}, {"sha": "271ab72c74fc14bec2c953b83008fcab219c7eba", "filename": "src/test/ui/structs-enums/empty-tag.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fstructs-enums%2Fempty-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fstructs-enums%2Fempty-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fempty-tag.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n #![allow(non_camel_case_types)]\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "7f3f86e4df009320ba1859edc9f973381e18c8f5", "filename": "src/test/ui/type-alias-impl-trait/assoc-type-const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -18,16 +18,16 @@ trait MyTrait<'a, const C: usize> {\n     const MY_CONST: usize;\n }\n \n-impl<'a, const C: usize> MyTrait<'a, { C }> for MyStruct<{ C }> {\n+impl<'a, const C: usize> MyTrait<'a, C> for MyStruct<C> {\n     type MyItem = u8;\n     const MY_CONST: usize = C;\n }\n \n-impl<'a, I, const C: usize> UnwrapItemsExt<'a, { C }> for I {\n-    type Iter = impl MyTrait<'a, { C }>;\n+impl<'a, I, const C: usize> UnwrapItemsExt<'a, C> for I {\n+    type Iter = impl MyTrait<'a, C>;\n \n     fn unwrap_items(self) -> Self::Iter {\n-        MyStruct::<{ C }> {}\n+        MyStruct::<C> {}\n     }\n }\n "}, {"sha": "24c2758a0a255520e58076bd29f841bebeee50b1", "filename": "src/test/ui/unsized-locals/unsized-exprs-rpass.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs-rpass.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces, unused_parens)]\n #![feature(unsized_tuple_coercion, unsized_locals)]\n \n struct A<X: ?Sized>(X);\n@@ -30,7 +30,6 @@ fn main() {\n         *foo()\n     });\n     udrop::<[u8]>({*foo()});\n-    #[allow(unused_parens)]\n     udrop::<[u8]>((*foo()));\n     udrop::<[u8]>((*tfoo()).1);\n     *afoo() + 42;"}, {"sha": "d812bbd011e0e275c1e120cc2e51784bcdea63d6", "filename": "src/test/ui/weird-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fweird-exprs.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -5,7 +5,7 @@\n #![allow(non_camel_case_types)]\n #![allow(dead_code)]\n #![allow(unreachable_code)]\n-#![allow(unused_parens)]\n+#![allow(unused_braces, unused_parens)]\n \n #![recursion_limit = \"256\"]\n "}, {"sha": "2208590f7d61bbf7d30f6cc8b41adce2769791fe", "filename": "src/test/ui/zero-sized/zero-sized-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8993358e77b82a3c8745c1200c2ac5f3640a7053/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-tuple-struct.rs?ref=8993358e77b82a3c8745c1200c2ac5f3640a7053", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n #![allow(unused_assignments)]\n \n // Make sure that the constructor args are codegened for zero-sized tuple structs"}]}