{"sha": "1316312c0c0f0225922b94fc6bfa2e07e3a85ac4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMTYzMTJjMGMwZjAyMjU5MjJiOTRmYzZiZmEyZTA3ZTNhODVhYzQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-28T03:48:28Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-28T03:48:28Z"}, "message": "Only translate or dwarf-emit items or stubs locally defined or used. Avoids instantiating O(sizeof(standard-library)) worth of imports stubs on each 'use std'. Closes issue 13.", "tree": {"sha": "3d56e02aa4afb3202a49dee2ec4c8757b97ec0fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d56e02aa4afb3202a49dee2ec4c8757b97ec0fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4", "html_url": "https://github.com/rust-lang/rust/commit/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7045526a3eb1d0818aeea94968f153ee349b7935", "url": "https://api.github.com/repos/rust-lang/rust/commits/7045526a3eb1d0818aeea94968f153ee349b7935", "html_url": "https://github.com/rust-lang/rust/commit/7045526a3eb1d0818aeea94968f153ee349b7935"}], "stats": {"total": 305, "additions": 269, "deletions": 36}, "files": [{"sha": "a2763d965bdef9a6f4aa0178dc0b7602c80076fc", "filename": "src/boot/fe/item.ml", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=1316312c0c0f0225922b94fc6bfa2e07e3a85ac4", "patch": "@@ -876,17 +876,31 @@ and parse_mod_item (ps:pstate) : (Ast.ident * Ast.mod_item) =\n and parse_mod_items_from_signature\n     (ps:pstate)\n     : (Ast.mod_view * Ast.mod_items) =\n-    let mis = Hashtbl.create 0 in\n-      expect ps LBRACE;\n-      while not (peek ps = RBRACE)\n-      do\n+  let exports = Hashtbl.create 0 in\n+  let mis = Hashtbl.create 0 in\n+  let in_view = ref true in\n+    expect ps LBRACE;\n+    while not (peek ps = RBRACE)\n+    do\n+      if !in_view\n+      then\n+        match peek ps with\n+            EXPORT ->\n+              bump ps;\n+              parse_export ps exports;\n+              expect ps SEMI;\n+          | _ ->\n+              in_view := false\n+      else\n         let (ident, mti) = ctxt \"mod items from sig: mod item\"\n           parse_mod_item_from_signature ps\n         in\n           Hashtbl.add mis ident mti;\n-      done;\n-      expect ps RBRACE;\n-      (empty_view, mis)\n+    done;\n+    if (Hashtbl.length exports) = 0\n+    then Hashtbl.add exports Ast.EXPORT_all_decls ();\n+    expect ps RBRACE;\n+    ({empty_view with Ast.view_exports = exports}, mis)\n \n \n and parse_mod_item_from_signature (ps:pstate)"}, {"sha": "910ef9837cff18412e15ffcc40eb9678467627dc", "filename": "src/boot/me/dwarf.ml", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Fboot%2Fme%2Fdwarf.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Fboot%2Fme%2Fdwarf.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fdwarf.ml?ref=1316312c0c0f0225922b94fc6bfa2e07e3a85ac4", "patch": "@@ -2517,11 +2517,12 @@ let process_crate\n \n   let passes =\n     [|\n-      dwarf_visitor cx Walk.empty_visitor path\n-        cx.ctxt_debug_info_fixup\n-        cu_aranges cu_pubnames\n-        cu_infos cu_abbrevs\n-        cu_lines cu_frames\n+      unreferenced_required_item_ignoring_visitor cx\n+        (dwarf_visitor cx Walk.empty_visitor path\n+           cx.ctxt_debug_info_fixup\n+           cu_aranges cu_pubnames\n+           cu_infos cu_abbrevs\n+           cu_lines cu_frames)\n     |];\n   in\n "}, {"sha": "c0146c97e35294746b1c64f6a7d580e6d42ebcf6", "filename": "src/boot/me/resolve.ml", "status": "modified", "additions": 83, "deletions": 4, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Fboot%2Fme%2Fresolve.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Fboot%2Fme%2Fresolve.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fresolve.ml?ref=1316312c0c0f0225922b94fc6bfa2e07e3a85ac4", "patch": "@@ -730,11 +730,33 @@ let lval_base_resolving_visitor\n                           (int_of_node nb.id) (int_of_node referent_id));\n               htab_put cx.ctxt_lval_to_referent nb.id referent_id\n     in\n+\n+    (*\n+     * The point here is just to tickle the reference-a-name machinery in\n+     * lookup that makes sure that all and only those items referenced get\n+     * processed by later stages. An lval that happens to be an item will\n+     * mark the item in question here.\n+     *)\n+    let reference_any_name lv =\n+      let rec lval_is_name lv =\n+        match lv with\n+            Ast.LVAL_base {node = Ast.BASE_ident _}\n+          | Ast.LVAL_base {node = Ast.BASE_app _} -> true\n+          | Ast.LVAL_ext (lv', Ast.COMP_named (Ast.COMP_ident _))\n+          | Ast.LVAL_ext (lv', Ast.COMP_named (Ast.COMP_app _))\n+            -> lval_is_name lv'\n+          | _ -> false\n+      in\n+        if lval_is_name lv && lval_is_item cx lv\n+        then ignore (lookup_by_name cx (!scopes) (lval_to_name lv))\n+    in\n+\n       lookup_lval lv;\n+      reference_any_name lv;\n       inner.Walk.visit_lval_pre lv\n   in\n     { inner with\n-        Walk.visit_lval_pre = visit_lval_pre }\n+        Walk.visit_lval_pre = visit_lval_pre };\n ;;\n \n \n@@ -868,7 +890,8 @@ let resolve_recursion\n \n let pattern_resolving_visitor\n     (cx:ctxt)\n-    (inner:Walk.visitor) : Walk.visitor =\n+    (inner:Walk.visitor)\n+    : Walk.visitor =\n \n   let not_tag_ctor nm id : unit =\n     err (Some id) \"'%s' is not a tag constructor\" (string_of_name nm)\n@@ -934,6 +957,43 @@ let pattern_resolving_visitor\n   { inner with Walk.visit_stmt_pre = visit_stmt_pre }\n ;;\n \n+let export_referencing_visitor\n+    (cx:ctxt)\n+    (inner:Walk.visitor)\n+    : Walk.visitor =\n+    let visit_mod_item_pre id params item =\n+      begin\n+        match item.node.Ast.decl_item with\n+            Ast.MOD_ITEM_mod (view, items) ->\n+              let is_defining_mod =\n+                (* auto-ref the default-export cases only if\n+                 * the containing mod is 'defining', meaning\n+                 * not-native / not-use\n+                 *)\n+                 not (Hashtbl.mem cx.ctxt_required_items item.id)\n+              in\n+              let reference _ item =\n+                Hashtbl.replace cx.ctxt_node_referenced item.id ();\n+              in\n+              let reference_export e _ =\n+                match e with\n+                    Ast.EXPORT_ident ident ->\n+                      let item = Hashtbl.find items ident in\n+                        reference ident item\n+                  | Ast.EXPORT_all_decls ->\n+                      if is_defining_mod\n+                      then Hashtbl.iter reference items\n+              in\n+                Hashtbl.iter reference_export view.Ast.view_exports\n+          | _ -> ()\n+      end;\n+      inner.Walk.visit_mod_item_pre id params item\n+    in\n+      { inner with Walk.visit_mod_item_pre = visit_mod_item_pre }\n+\n+\n+;;\n+\n let process_crate\n     (cx:ctxt)\n     (crate:Ast.crate)\n@@ -957,6 +1017,7 @@ let process_crate\n             Walk.empty_visitor))\n     |]\n   in\n+\n   let passes_1 =\n     [|\n       (scope_stack_managing_visitor scopes\n@@ -966,20 +1027,38 @@ let process_crate\n                Walk.empty_visitor)));\n     |]\n   in\n+\n   let passes_2 =\n     [|\n       (scope_stack_managing_visitor scopes\n          (pattern_resolving_visitor cx\n-            Walk.empty_visitor))\n+            Walk.empty_visitor));\n+      export_referencing_visitor cx Walk.empty_visitor\n     |]\n   in\n+\n     log cx \"running primary resolve passes\";\n     run_passes cx \"resolve collect\" path passes_0 (log cx \"%s\") crate;\n     resolve_recursion cx node_to_references recursive_tag_groups;\n     log cx \"running secondary resolve passes\";\n     run_passes cx \"resolve bind\" path passes_1 (log cx \"%s\") crate;\n     log cx \"running tertiary resolve passes\";\n-    run_passes cx \"resolve patterns\" path passes_2 (log cx \"%s\") crate\n+    run_passes cx \"resolve patterns\" path passes_2 (log cx \"%s\") crate;\n+\n+    iflog cx\n+      begin\n+        fun _ ->\n+          Hashtbl.iter\n+            begin\n+              fun n _ ->\n+                if referent_is_item cx n\n+                then\n+                  log cx \"referenced: %a\"\n+                    Ast.sprintf_name\n+                    (Hashtbl.find cx.ctxt_all_item_names n)\n+            end\n+            cx.ctxt_node_referenced;\n+      end\n ;;\n \n (*"}, {"sha": "40dd33bff9ca2f8a969326e2e9cf4056a9c235b3", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 134, "deletions": 11, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=1316312c0c0f0225922b94fc6bfa2e07e3a85ac4", "patch": "@@ -90,6 +90,7 @@ type ctxt =\n       ctxt_block_items: block_items_table;\n       ctxt_slot_is_arg: (node_id,unit) Hashtbl.t;\n       ctxt_slot_keys: (node_id,Ast.slot_key) Hashtbl.t;\n+      ctxt_node_referenced: (node_id, unit) Hashtbl.t;\n       ctxt_all_item_names: (node_id,Ast.name) Hashtbl.t;\n       ctxt_all_item_types: (node_id,Ast.ty) Hashtbl.t;\n       ctxt_all_lval_types: (node_id,Ast.ty) Hashtbl.t;\n@@ -179,6 +180,7 @@ let new_ctxt sess abi crate =\n     ctxt_block_items = Hashtbl.create 0;\n     ctxt_slot_is_arg = Hashtbl.create 0;\n     ctxt_slot_keys = Hashtbl.create 0;\n+    ctxt_node_referenced = Hashtbl.create 0;\n     ctxt_all_item_names = Hashtbl.create 0;\n     ctxt_all_item_types = Hashtbl.create 0;\n     ctxt_all_lval_types = Hashtbl.create 0;\n@@ -1330,22 +1332,130 @@ let scope_stack_managing_visitor\n         Walk.visit_crate_post = visit_crate_post; }\n ;;\n \n+let unreferenced_required_item_ignoring_visitor\n+    (cx:ctxt)\n+    (inner:Walk.visitor)\n+    : Walk.visitor =\n+\n+  let inhibition = ref 0 in\n+\n+  let directly_inhibited i =\n+    (Hashtbl.mem cx.ctxt_required_items i.id) &&\n+      (not (Hashtbl.mem cx.ctxt_node_referenced i.id))\n+  in\n+\n+  let indirectly_inhibited _ =\n+    (!inhibition) <> 0\n+  in\n+\n+  let should_visit i =\n+    not ((directly_inhibited i) || (indirectly_inhibited()))\n+  in\n+\n+  let inhibit_pre i =\n+    if directly_inhibited i\n+    then incr inhibition\n+  in\n+\n+  let inhibit_post i =\n+    if directly_inhibited i\n+    then decr inhibition\n+  in\n+\n+  let visit_mod_item_pre n p i =\n+    if should_visit i\n+    then inner.Walk.visit_mod_item_pre n p i;\n+    inhibit_pre i\n+  in\n+\n+  let visit_mod_item_post n p i =\n+    if should_visit i\n+    then inner.Walk.visit_mod_item_post n p i;\n+    inhibit_post i\n+  in\n+\n+  let visit_obj_fn_pre oid ident fn =\n+    if not (indirectly_inhibited())\n+    then inner.Walk.visit_obj_fn_pre oid ident fn;\n+  in\n+\n+  let visit_obj_fn_post oid ident fn =\n+    if not (indirectly_inhibited())\n+    then inner.Walk.visit_obj_fn_post oid ident fn;\n+  in\n+\n+  let visit_obj_drop_pre oid d =\n+    if not (indirectly_inhibited())\n+    then inner.Walk.visit_obj_drop_pre oid d;\n+  in\n+\n+  let visit_obj_drop_post oid d =\n+    if not (indirectly_inhibited())\n+    then inner.Walk.visit_obj_drop_post oid d;\n+  in\n+\n+  let visit_constr_pre n c =\n+    if not (indirectly_inhibited())\n+    then inner.Walk.visit_constr_pre n c;\n+  in\n+\n+  let visit_constr_post n c =\n+    if not (indirectly_inhibited())\n+    then inner.Walk.visit_constr_post n c;\n+  in\n+\n+  let wrap1 fn =\n+    fun x ->\n+      if not (indirectly_inhibited())\n+      then fn x\n+  in\n+\n+    { inner with\n+        Walk.visit_stmt_pre = wrap1 inner.Walk.visit_stmt_pre;\n+        Walk.visit_stmt_post = wrap1 inner.Walk.visit_stmt_post;\n+        Walk.visit_slot_identified_pre =\n+        wrap1 inner.Walk.visit_slot_identified_pre;\n+        Walk.visit_slot_identified_post =\n+        wrap1 inner.Walk.visit_slot_identified_post;\n+        Walk.visit_expr_pre = wrap1 inner.Walk.visit_expr_pre;\n+        Walk.visit_expr_post = wrap1 inner.Walk.visit_expr_post;\n+        Walk.visit_ty_pre = wrap1 inner.Walk.visit_ty_pre;\n+        Walk.visit_ty_post = wrap1 inner.Walk.visit_ty_post;\n+        Walk.visit_constr_pre = visit_constr_pre;\n+        Walk.visit_constr_post = visit_constr_post;\n+        Walk.visit_pat_pre = wrap1 inner.Walk.visit_pat_pre;\n+        Walk.visit_pat_post = wrap1 inner.Walk.visit_pat_post;\n+        Walk.visit_block_pre = wrap1 inner.Walk.visit_block_pre;\n+        Walk.visit_block_post = wrap1 inner.Walk.visit_block_post;\n+        Walk.visit_lit_pre = wrap1 inner.Walk.visit_lit_pre;\n+        Walk.visit_lit_post = wrap1 inner.Walk.visit_lit_post;\n+        Walk.visit_lval_pre = wrap1 inner.Walk.visit_lval_pre;\n+        Walk.visit_lval_post = wrap1 inner.Walk.visit_lval_post;\n+        Walk.visit_mod_item_pre = visit_mod_item_pre;\n+        Walk.visit_mod_item_post = visit_mod_item_post;\n+        Walk.visit_obj_fn_pre = visit_obj_fn_pre;\n+        Walk.visit_obj_fn_post = visit_obj_fn_post;\n+        Walk.visit_obj_drop_pre = visit_obj_drop_pre;\n+        Walk.visit_obj_drop_post = visit_obj_drop_post; }\n+;;\n+\n+\n (* Generic lookup, used for slots, items, types, etc. *)\n \n type resolved = ((scope list * node_id) option) ;;\n \n let get_item (cx:ctxt) (node:node_id) : Ast.mod_item_decl =\n   match htab_search cx.ctxt_all_defns node with\n       Some (DEFN_item item) -> item\n-    | Some _ -> err (Some node) \"defn is not an item\"\n-    | None -> bug () \"missing defn\"\n+    | Some _ -> bugi cx node \"defn is not an item\"\n+    | None -> bugi cx node \"missing defn\"\n ;;\n \n let get_slot (cx:ctxt) (node:node_id) : Ast.slot =\n   match htab_search cx.ctxt_all_defns node with\n       Some (DEFN_slot slot) -> slot\n-    | Some _ -> err (Some node) \"defn is not a slot\"\n-    | None -> bug () \"missing defn\"\n+    | Some _ -> bugi cx node \"defn is not a slot\"\n+    | None -> bugi cx node \"missing defn\"\n ;;\n \n let get_mod_item\n@@ -1354,7 +1464,7 @@ let get_mod_item\n     : (Ast.mod_view * Ast.mod_items) =\n   match get_item cx node with\n       { Ast.decl_item = Ast.MOD_ITEM_mod md } -> md\n-    | _ -> err (Some node) \"defn is not a mod\"\n+    | _ -> bugi cx node \"defn is not a mod\"\n ;;\n \n let get_name_comp_ident\n@@ -1387,12 +1497,17 @@ let rec project_ident_from_items\n   then None\n   else\n     match htab_search items ident with\n-        Some i -> Some (scopes, i.id)\n+        Some i ->\n+          found cx scopes i.id\n       | None ->\n           match htab_search view.Ast.view_imports ident with\n               None -> None\n             | Some name -> lookup_by_name cx scopes name\n \n+and found cx scopes id =\n+  Hashtbl.replace cx.ctxt_node_referenced id ();\n+  Some (scopes, id)\n+\n and project_name_comp_from_resolved\n     (cx:ctxt)\n     (mod_res:resolved)\n@@ -1405,6 +1520,7 @@ and project_name_comp_from_resolved\n         let scopes = scope :: scopes in\n         let ident = get_name_comp_ident ext in\n         let md = get_mod_item cx id in\n+          Hashtbl.replace cx.ctxt_node_referenced id ();\n           project_ident_from_items cx scopes md ident false\n \n and lookup_by_name\n@@ -1426,19 +1542,25 @@ and lookup_by_ident\n     (scopes:scope list)\n     (ident:Ast.ident)\n     : resolved =\n+\n   let check_slots scopes islots =\n     arr_search islots\n       (fun _ (sloti,ident') ->\n          if ident = ident'\n-         then Some (scopes, sloti.id)\n+         then found cx scopes sloti.id\n          else None)\n   in\n+\n   let check_params scopes params =\n     arr_search params\n       (fun _ {node=(i,_); id=id} ->\n-         if i = ident then Some (scopes, id) else None)\n+         if i = ident\n+         then found cx scopes id\n+         else None)\n   in\n+\n   let passed_capture_scope = ref false in\n+\n   let would_capture r =\n     match r with\n         None -> None\n@@ -1447,17 +1569,18 @@ and lookup_by_ident\n           then err None \"attempted dynamic environment-capture\"\n           else r\n   in\n+\n   let check_scope scopes scope =\n     match scope with\n         SCOPE_block block_id ->\n           let block_slots = Hashtbl.find cx.ctxt_block_slots block_id in\n           let block_items = Hashtbl.find cx.ctxt_block_items block_id in\n             begin\n               match htab_search block_slots (Ast.KEY_ident ident) with\n-                  Some id -> would_capture (Some (scopes, id))\n+                  Some id -> would_capture (found cx scopes id)\n                 | None ->\n                     match htab_search block_items ident with\n-                        Some id -> Some (scopes, id)\n+                        Some id -> found cx scopes id\n                       | None -> None\n             end\n \n@@ -1478,7 +1601,7 @@ and lookup_by_ident\n                 | Ast.MOD_ITEM_obj obj ->\n                     begin\n                       match htab_search obj.Ast.obj_fns ident with\n-                          Some fn -> Some (scopes, fn.id)\n+                          Some fn -> found cx scopes fn.id\n                         | None -> check_slots scopes obj.Ast.obj_state\n                     end\n "}, {"sha": "4b7c5b17a5e7d4538283f024dd5eb2fe52a05075", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=1316312c0c0f0225922b94fc6bfa2e07e3a85ac4", "patch": "@@ -5094,7 +5094,8 @@ let fixup_assigning_visitor\n   in\n \n   let visit_block_pre b =\n-    htab_put cx.ctxt_block_fixups b.id (new_fixup \"lexical block\");\n+    htab_put cx.ctxt_block_fixups b.id\n+      (new_fixup (\"lexical block in \" ^ (path_name())));\n     inner.Walk.visit_block_pre b\n   in\n \n@@ -5118,13 +5119,15 @@ let process_crate\n   let path = Stack.create () in\n   let passes =\n     [|\n-      (fixup_assigning_visitor cx path\n-         Walk.empty_visitor);\n-      (Walk.mod_item_logging_visitor\n-         (log cx \"translation pass: %s\")\n-         path\n-         (trans_visitor cx path\n-            Walk.empty_visitor))\n+      (unreferenced_required_item_ignoring_visitor cx\n+         (fixup_assigning_visitor cx path\n+            Walk.empty_visitor));\n+      (unreferenced_required_item_ignoring_visitor cx\n+         (Walk.mod_item_logging_visitor\n+            (log cx \"translation pass: %s\")\n+            path\n+            (trans_visitor cx path\n+               Walk.empty_visitor)))\n     |];\n   in\n     log cx \"translating crate\";"}, {"sha": "0eafc5eec29548d3b6bc270d81a55d543b8f96cc", "filename": "src/lib/sys.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Flib%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Flib%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsys.rs?ref=1316312c0c0f0225922b94fc6bfa2e07e3a85ac4", "patch": "@@ -1,4 +1,17 @@\n+export rustrt;\n+\n native \"rust\" mod rustrt {\n+\n+  // Explicitly re-export native stuff we want to be made\n+  // available outside this crate. Otherwise it's\n+  // visible-in-crate, but not re-exported.\n+\n+  export last_os_error;\n+  export size_of;\n+  export align_of;\n+  export refcount;\n+  export gc;\n+\n   fn last_os_error() -> str;\n   fn size_of[T]() -> uint;\n   fn align_of[T]() -> uint;"}, {"sha": "fa0677253da0d49f02abbfa64c5cfe1ef7aa0454", "filename": "src/test/compile-fail/direct-obj-fn-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1316312c0c0f0225922b94fc6bfa2e07e3a85ac4/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs?ref=1316312c0c0f0225922b94fc6bfa2e07e3a85ac4", "patch": "@@ -1,5 +1,5 @@\n \n-// error-pattern: mismatched types\n+// error-pattern: is not a mod\n \n obj x() {\n   fn hello() {"}]}