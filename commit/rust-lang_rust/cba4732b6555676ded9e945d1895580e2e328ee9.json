{"sha": "cba4732b6555676ded9e945d1895580e2e328ee9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiYTQ3MzJiNjU1NTY3NmRlZDllOTQ1ZDE4OTU1ODBlMmUzMjhlZTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-12T13:31:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:38:11Z"}, "message": "introduce a `NiceRegionError` type and define methods on that\n\nThis is more convenient, and allows us to be more independent from\ninfcx, particularly with respect to `in_progress_tables` field.\n\nNo functional change.", "tree": {"sha": "7e07239d9b772f64245390980924bfdfc7a5b873", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e07239d9b772f64245390980924bfdfc7a5b873"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cba4732b6555676ded9e945d1895580e2e328ee9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cba4732b6555676ded9e945d1895580e2e328ee9", "html_url": "https://github.com/rust-lang/rust/commit/cba4732b6555676ded9e945d1895580e2e328ee9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cba4732b6555676ded9e945d1895580e2e328ee9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a28ab84025831f3b73810e52f432af904e6fd85c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a28ab84025831f3b73810e52f432af904e6fd85c", "html_url": "https://github.com/rust-lang/rust/commit/a28ab84025831f3b73810e52f432af904e6fd85c"}], "stats": {"total": 219, "additions": 137, "deletions": 82}, "files": [{"sha": "aabe405768578c90562e9232b01eb32b333d435a", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cba4732b6555676ded9e945d1895580e2e328ee9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cba4732b6555676ded9e945d1895580e2e328ee9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=cba4732b6555676ded9e945d1895580e2e328ee9", "patch": "@@ -291,9 +291,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         for error in errors {\n             debug!(\"report_region_errors: error = {:?}\", error);\n \n-            if !self.try_report_named_anon_conflict(&error) &&\n-                !self.try_report_anon_anon_conflict(&error)\n-            {\n+            if !self.try_report_nice_region_error(&error) {\n                 match error.clone() {\n                     // These errors could indicate all manner of different\n                     // problems with many different solutions. Rather"}, {"sha": "5061a2ba27745309fe9a0be78dfc2f2b89de0344", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cba4732b6555676ded9e945d1895580e2e328ee9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cba4732b6555676ded9e945d1895580e2e328ee9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=cba4732b6555676ded9e945d1895580e2e328ee9", "patch": "@@ -10,12 +10,10 @@\n \n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where both the regions are anonymous.\n-use infer::InferCtxt;\n-use infer::lexical_region_resolve::RegionResolutionError::*;\n-use infer::lexical_region_resolve::RegionResolutionError;\n+use infer::error_reporting::nice_region_error::NiceRegionError;\n use infer::error_reporting::nice_region_error::util::AnonymousArgInfo;\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n     ///\n     /// Consider a case where we have\n@@ -52,12 +50,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// ````\n     ///\n     /// It will later be extended to trait objects.\n-    pub fn try_report_anon_anon_conflict(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-        let (span, sub, sup) = match *error {\n-            ConcreteFailure(ref origin, sub, sup) => (origin.span(), sub, sup),\n-            SubSupConflict(_, ref origin, sub, _, sup) => (origin.span(), sub, sup),\n-            _ => return false, // inapplicable\n-        };\n+    pub(super) fn try_report_anon_anon_conflict(&self) -> bool {\n+        let NiceRegionError { span, sub, sup, .. } = *self;\n \n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n         let anon_reg_sup = or_false!(self.is_suitable_region(sup));"}, {"sha": "dc53c1db06f14be0ccfc6bf229e32058a56332c8", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cba4732b6555676ded9e945d1895580e2e328ee9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cba4732b6555676ded9e945d1895580e2e328ee9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=cba4732b6555676ded9e945d1895580e2e328ee9", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n use hir;\n-use infer::InferCtxt;\n-use ty::{self, Region};\n+use ty::{self, Region, TyCtxt};\n use hir::map as hir_map;\n use middle::resolve_lifetime as rl;\n use hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use infer::error_reporting::nice_region_error::NiceRegionError;\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// This function calls the `visit_ty` method for the parameters\n     /// corresponding to the anonymous regions. The `nested_visitor.found_type`\n     /// contains the anonymous type.\n@@ -74,8 +74,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         br: &ty::BoundRegion,\n     ) -> Option<(&'gcx hir::Ty)> {\n         let mut nested_visitor = FindNestedTypeVisitor {\n-            infcx: &self,\n-            hir_map: &self.tcx.hir,\n+            tcx: self.tcx,\n             bound_region: *br,\n             found_type: None,\n             depth: 1,\n@@ -93,8 +92,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n // where that lifetime appears. This allows us to highlight the\n // specific part of the type in the error message.\n struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    hir_map: &'a hir::map::Map<'gcx>,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     // The bound_region corresponding to the Refree(freeregion)\n     // associated with the anonymous region we are looking for.\n     bound_region: ty::BoundRegion,\n@@ -106,7 +104,7 @@ struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.hir_map)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n     }\n \n     fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n@@ -126,8 +124,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n \n             hir::TyRptr(ref lifetime, _) => {\n                 // the lifetime of the TyRptr\n-                let hir_id = self.infcx.tcx.hir.node_to_hir_id(lifetime.id);\n-                match (self.infcx.tcx.named_region(hir_id), self.bound_region) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(lifetime.id);\n+                match (self.tcx.named_region(hir_id), self.bound_region) {\n                     // Find the index of the anonymous region that was part of the\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n@@ -195,10 +193,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n             // Checks if it is of type `hir::TyPath` which corresponds to a struct.\n             hir::TyPath(_) => {\n                 let subvisitor = &mut TyPathVisitor {\n-                    infcx: self.infcx,\n+                    tcx: self.tcx,\n                     found_it: false,\n                     bound_region: self.bound_region,\n-                    hir_map: self.hir_map,\n                     depth: self.depth,\n                 };\n                 intravisit::walk_ty(subvisitor, arg); // call walk_ty; as visit_ty is empty,\n@@ -222,21 +219,20 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n // where that lifetime appears. This allows us to highlight the\n // specific part of the type in the error message.\n struct TyPathVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    hir_map: &'a hir::map::Map<'gcx>,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     found_it: bool,\n     bound_region: ty::BoundRegion,\n     depth: u32,\n }\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.hir_map)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n-        let hir_id = self.infcx.tcx.hir.node_to_hir_id(lifetime.id);\n-        match (self.infcx.tcx.named_region(hir_id), self.bound_region) {\n+        let hir_id = self.tcx.hir.node_to_hir_id(lifetime.id);\n+        match (self.tcx.named_region(hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n             (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)), ty::BrAnon(br_index)) => {\n                 if debruijn_index.depth == self.depth && anon_index == br_index {"}, {"sha": "46283041fac41397babe413aff28772851f0a89d", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cba4732b6555676ded9e945d1895580e2e328ee9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cba4732b6555676ded9e945d1895580e2e328ee9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=cba4732b6555676ded9e945d1895580e2e328ee9", "patch": "@@ -8,8 +8,56 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[macro_use] mod util;\n+use infer::InferCtxt;\n+use infer::lexical_region_resolve::RegionResolutionError;\n+use infer::lexical_region_resolve::RegionResolutionError::*;\n+use syntax::codemap::Span;\n+use ty::{self, TyCtxt};\n+\n+#[macro_use]\n+mod util;\n \n mod find_anon_type;\n mod different_lifetimes;\n mod named_anon_conflict;\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    pub fn try_report_nice_region_error(&self, error: &RegionResolutionError<'tcx>) -> bool {\n+        let (span, sub, sup) = match *error {\n+            ConcreteFailure(ref origin, sub, sup) => (origin.span(), sub, sup),\n+            SubSupConflict(_, ref origin, sub, _, sup) => (origin.span(), sub, sup),\n+            _ => return false, // inapplicable\n+        };\n+\n+        if let Some(tables) = self.in_progress_tables {\n+            let tables = tables.borrow();\n+            NiceRegionError::new(self.tcx, span, sub, sup, Some(&tables)).try_report()\n+        } else {\n+            NiceRegionError::new(self.tcx, span, sub, sup, None).try_report()\n+        }\n+    }\n+}\n+\n+pub struct NiceRegionError<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    span: Span,\n+    sub: ty::Region<'tcx>,\n+    sup: ty::Region<'tcx>,\n+    tables: Option<&'cx ty::TypeckTables<'tcx>>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        span: Span,\n+        sub: ty::Region<'tcx>,\n+        sup: ty::Region<'tcx>,\n+        tables: Option<&'cx ty::TypeckTables<'tcx>>,\n+    ) -> Self {\n+        Self { tcx, span, sub, sup, tables }\n+    }\n+\n+    pub fn try_report(&self) -> bool {\n+        self.try_report_anon_anon_conflict() || self.try_report_named_anon_conflict()\n+    }\n+}"}, {"sha": "87c3da2ee16a79fd4924662e461d3ff70464c879", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 66, "deletions": 47, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/cba4732b6555676ded9e945d1895580e2e328ee9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cba4732b6555676ded9e945d1895580e2e328ee9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=cba4732b6555676ded9e945d1895580e2e328ee9", "patch": "@@ -10,56 +10,68 @@\n \n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n-use infer::InferCtxt;\n-use infer::lexical_region_resolve::RegionResolutionError::*;\n-use infer::lexical_region_resolve::RegionResolutionError;\n+use infer::error_reporting::nice_region_error::NiceRegionError;\n use ty;\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n-    pub fn try_report_named_anon_conflict(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-        let (span, sub, sup) = match *error {\n-            ConcreteFailure(ref origin, sub, sup) => (origin.span(), sub, sup),\n-            SubSupConflict(_, ref origin, sub, _, sup) => (origin.span(), sub, sup),\n-            _ => return false, // inapplicable\n-        };\n+    pub(super) fn try_report_named_anon_conflict(&self) -> bool {\n+        let NiceRegionError { span, sub, sup, .. } = *self;\n \n-        debug!(\"try_report_named_anon_conflict(sub={:?}, sup={:?})\", sub, sup);\n+        debug!(\n+            \"try_report_named_anon_conflict(sub={:?}, sup={:?})\",\n+            sub,\n+            sup\n+        );\n \n         // Determine whether the sub and sup consist of one named region ('a)\n         // and one anonymous (elided) region. If so, find the parameter arg\n         // where the anonymous region appears (there must always be one; we\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.//scope_def_id\n-        let (named, anon, anon_arg_info, region_info) =\n-            if self.is_named_region(sub) && self.is_suitable_region(sup).is_some() &&\n-               self.find_arg_with_region(sup, sub).is_some() {\n-                (sub,\n-                 sup,\n-                 self.find_arg_with_region(sup, sub).unwrap(),\n-                 self.is_suitable_region(sup).unwrap())\n-            } else if self.is_named_region(sup) && self.is_suitable_region(sub).is_some() &&\n-                      self.find_arg_with_region(sub, sup).is_some() {\n-                (sup,\n-                 sub,\n-                 self.find_arg_with_region(sub, sup).unwrap(),\n-                 self.is_suitable_region(sub).unwrap())\n-            } else {\n-                return false; // inapplicable\n-            };\n+        let (named, anon, anon_arg_info, region_info) = if self.is_named_region(sub)\n+            && self.is_suitable_region(sup).is_some()\n+            && self.find_arg_with_region(sup, sub).is_some()\n+        {\n+            (\n+                sub,\n+                sup,\n+                self.find_arg_with_region(sup, sub).unwrap(),\n+                self.is_suitable_region(sup).unwrap(),\n+            )\n+        } else if self.is_named_region(sup) && self.is_suitable_region(sub).is_some()\n+            && self.find_arg_with_region(sub, sup).is_some()\n+        {\n+            (\n+                sup,\n+                sub,\n+                self.find_arg_with_region(sub, sup).unwrap(),\n+                self.is_suitable_region(sub).unwrap(),\n+            )\n+        } else {\n+            return false; // inapplicable\n+        };\n \n         debug!(\"try_report_named_anon_conflict: named = {:?}\", named);\n-        debug!(\"try_report_named_anon_conflict: anon_arg_info = {:?}\", anon_arg_info);\n-        debug!(\"try_report_named_anon_conflict: region_info = {:?}\", region_info);\n+        debug!(\n+            \"try_report_named_anon_conflict: anon_arg_info = {:?}\",\n+            anon_arg_info\n+        );\n+        debug!(\n+            \"try_report_named_anon_conflict: region_info = {:?}\",\n+            region_info\n+        );\n \n-        let (arg, new_ty, br, is_first, scope_def_id, is_impl_item) = (anon_arg_info.arg,\n-                                                                       anon_arg_info.arg_ty,\n-                                                                       anon_arg_info.bound_region,\n-                                                                       anon_arg_info.is_first,\n-                                                                       region_info.def_id,\n-                                                                       region_info.is_impl_item);\n+        let (arg, new_ty, br, is_first, scope_def_id, is_impl_item) = (\n+            anon_arg_info.arg,\n+            anon_arg_info.arg_ty,\n+            anon_arg_info.bound_region,\n+            anon_arg_info.is_first,\n+            region_info.def_id,\n+            region_info.is_impl_item,\n+        );\n         match br {\n             ty::BrAnon(_) => {}\n             _ => {\n@@ -75,27 +87,34 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if let Some((_, fndecl)) = self.find_anon_type(anon, &br) {\n-            if self.is_return_type_anon(scope_def_id, br, fndecl).is_some() ||\n-               self.is_self_anon(is_first, scope_def_id) {\n+            if self.is_return_type_anon(scope_def_id, br, fndecl).is_some()\n+                || self.is_self_anon(is_first, scope_def_id)\n+            {\n                 return false;\n             }\n         }\n \n         let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n-            (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n+            (\n+                format!(\"the type of `{}`\", simple_name),\n+                format!(\"the type of `{}`\", simple_name),\n+            )\n         } else {\n             (\"parameter type\".to_owned(), \"type\".to_owned())\n         };\n \n-        struct_span_err!(self.tcx.sess,\n-                         span,\n-                         E0621,\n-                         \"explicit lifetime required in {}\",\n-                         error_var)\n-                .span_label(arg.pat.span,\n-                            format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n-                .span_label(span, format!(\"lifetime `{}` required\", named))\n-                .emit();\n+        struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0621,\n+            \"explicit lifetime required in {}\",\n+            error_var\n+        ).span_label(\n+            arg.pat.span,\n+            format!(\"consider changing {} to `{}`\", span_label_var, new_ty),\n+        )\n+            .span_label(span, format!(\"lifetime `{}` required\", named))\n+            .emit();\n         return true;\n     }\n }"}, {"sha": "9a9b8fbbb949a341eec717d90e7ba1ec678479e9", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cba4732b6555676ded9e945d1895580e2e328ee9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cba4732b6555676ded9e945d1895580e2e328ee9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=cba4732b6555676ded9e945d1895580e2e328ee9", "patch": "@@ -11,7 +11,7 @@\n //! Helper functions corresponding to lifetime errors due to\n //! anonymous regions.\n use hir;\n-use infer::InferCtxt;\n+use infer::error_reporting::nice_region_error::NiceRegionError;\n use ty::{self, Region, Ty};\n use hir::def_id::DefId;\n use hir::map as hir_map;\n@@ -56,7 +56,7 @@ pub(super) struct FreeRegionInfo {\n     pub is_impl_item: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     // This method walks the Type of the function body arguments using\n     // `fold_regions()` function and returns the\n     // &hir::Arg of the function argument corresponding to the anonymous\n@@ -86,13 +86,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         if let Some(node_id) = hir.as_local_node_id(id) {\n             if let Some(body_id) = hir.maybe_body_owned_by(node_id) {\n                 let body = hir.body(body_id);\n-                if let Some(tables) = self.in_progress_tables {\n+                if let Some(tables) = self.tables {\n                     body.arguments\n                         .iter()\n                         .enumerate()\n                         .filter_map(|(index, arg)| {\n                             // May return None; sometimes the tables are not yet populated.\n-                            let ty = tables.borrow().node_id_to_type_opt(arg.hir_id)?;\n+                            let ty = tables.node_id_to_type_opt(arg.hir_id)?;\n                             let mut found_anon_region = false;\n                             let new_arg_ty = self.tcx.fold_regions(&ty, &mut false, |r, _| {\n                                 if *r == *anon_region {"}]}