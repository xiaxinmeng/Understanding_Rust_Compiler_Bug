{"sha": "6b1a9af1732bf1ec7e4ca9eee18b6404f8d94ee0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMWE5YWYxNzMyYmYxZWM3ZTRjYTllZWUxOGI2NDA0ZjhkOTRlZTA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-18T00:09:53Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-18T00:09:53Z"}, "message": "rustc: Remove all the code dealing with named implementations in resolve3", "tree": {"sha": "47ee5cbddcf920351fc74702d0045877be5166d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47ee5cbddcf920351fc74702d0045877be5166d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b1a9af1732bf1ec7e4ca9eee18b6404f8d94ee0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b1a9af1732bf1ec7e4ca9eee18b6404f8d94ee0", "html_url": "https://github.com/rust-lang/rust/commit/6b1a9af1732bf1ec7e4ca9eee18b6404f8d94ee0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b1a9af1732bf1ec7e4ca9eee18b6404f8d94ee0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26aaf08ff4238b9117440f8717ab33a45ee45d4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/26aaf08ff4238b9117440f8717ab33a45ee45d4e", "html_url": "https://github.com/rust-lang/rust/commit/26aaf08ff4238b9117440f8717ab33a45ee45d4e"}], "stats": {"total": 260, "additions": 33, "deletions": 227}, "files": [{"sha": "24e8d2e1f91b9119cc35672110267d611361331f", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 33, "deletions": 227, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/6b1a9af1732bf1ec7e4ca9eee18b6404f8d94ee0/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b1a9af1732bf1ec7e4ca9eee18b6404f8d94ee0/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=6b1a9af1732bf1ec7e4ca9eee18b6404f8d94ee0", "patch": "@@ -73,9 +73,10 @@ struct binding_info {\n type BindingMap = hashmap<ident,binding_info>;\n \n // Implementation resolution\n-\n+//\n // XXX: This kind of duplicates information kept in ty::method. Maybe it\n // should go away.\n+\n type MethodInfo = {\n     did: def_id,\n     n_tps: uint,\n@@ -110,8 +111,7 @@ enum PatternBindingMode {\n enum Namespace {\n     ModuleNS,\n     TypeNS,\n-    ValueNS,\n-    ImplNS\n+    ValueNS\n }\n \n enum NamespaceResult {\n@@ -120,12 +120,6 @@ enum NamespaceResult {\n     BoundResult(@Module, @NameBindings)\n }\n \n-enum ImplNamespaceResult {\n-    UnknownImplResult,\n-    UnboundImplResult,\n-    BoundImplResult(@DVec<@Target>)\n-}\n-\n enum NameDefinition {\n     NoNameDefinition,           //< The name was unbound.\n     ChildNameDefinition(def),   //< The name identifies an immediate child.\n@@ -367,7 +361,6 @@ struct ImportResolution {\n     let mut module_target: option<Target>;\n     let mut value_target: option<Target>;\n     let mut type_target: option<Target>;\n-    let mut impl_target: @DVec<@Target>;\n \n     let mut used: bool;\n \n@@ -379,7 +372,6 @@ struct ImportResolution {\n         self.module_target = none;\n         self.value_target = none;\n         self.type_target = none;\n-        self.impl_target = @dvec();\n \n         self.used = false;\n     }\n@@ -388,14 +380,7 @@ struct ImportResolution {\n         match namespace {\n             ModuleNS    => return copy self.module_target,\n             TypeNS      => return copy self.type_target,\n-            ValueNS     => return copy self.value_target,\n-\n-            ImplNS => {\n-                if (*self.impl_target).len() > 0u {\n-                    return some(copy *(*self.impl_target).get_elt(0u));\n-                }\n-                return none;\n-            }\n+            ValueNS     => return copy self.value_target\n         }\n     }\n }\n@@ -496,7 +481,6 @@ struct NameBindings {\n     let mut module_def: ModuleDef;      //< Meaning in the module namespace.\n     let mut type_def: option<def>;      //< Meaning in the type namespace.\n     let mut value_def: option<def>;     //< Meaning in the value namespace.\n-    let mut impl_defs: ~[@Impl];        //< Meaning in the impl namespace.\n \n     // For error reporting\n     let mut module_span: option<span>;\n@@ -507,7 +491,6 @@ struct NameBindings {\n         self.module_def = NoModuleDef;\n         self.type_def = none;\n         self.value_def = none;\n-        self.impl_defs = ~[];\n         self.module_span = none;\n         self.type_span = none;\n         self.value_span = none;\n@@ -535,11 +518,6 @@ struct NameBindings {\n         self.value_span = some(sp);\n     }\n \n-    /// Records an impl definition.\n-    fn define_impl(implementation: @Impl) {\n-        self.impl_defs += ~[implementation];\n-    }\n-\n     /// Returns the module node if applicable.\n     fn get_module_if_available() -> option<@Module> {\n         match self.module_def {\n@@ -568,8 +546,7 @@ struct NameBindings {\n         match namespace {\n             ModuleNS    => return self.module_def != NoModuleDef,\n             TypeNS      => return self.type_def != none,\n-            ValueNS     => return self.value_def != none,\n-            ImplNS      => return self.impl_defs.len() >= 1u\n+            ValueNS     => return self.value_def != none\n         }\n     }\n \n@@ -583,15 +560,6 @@ struct NameBindings {\n               none => return none,\n               some(def_id) => return some(def_mod(def_id))\n             }\n-          },\n-          ImplNS => {\n-            // Danger: Be careful what you use this for! def_ty is not\n-            // necessarily the right def.\n-\n-            if self.impl_defs.len() == 0u {\n-                return none;\n-            }\n-            return some(def_ty(self.impl_defs[0].did));\n           }\n         }\n     }\n@@ -602,8 +570,7 @@ struct NameBindings {\n             match namespace {\n               TypeNS   => self.type_span,\n               ValueNS  => self.value_span,\n-              ModuleNS => self.module_span,\n-              _        => none\n+              ModuleNS => self.module_span\n             }\n           }\n           none => none\n@@ -647,8 +614,7 @@ fn namespace_to_str(ns: Namespace) -> ~str {\n     match ns {\n       TypeNS   => ~\"type\",\n       ValueNS  => ~\"value\",\n-      ModuleNS => ~\"module\",\n-      ImplNS   => ~\"implementation\"\n+      ModuleNS => ~\"module\"\n     }\n }\n \n@@ -737,7 +703,7 @@ struct Resolver {\n         self.self_atom = (*self.atom_table).intern(@~\"self\");\n         self.primitive_type_table = @PrimitiveTypeTable(self.atom_table);\n \n-        self.namespaces = ~[ ModuleNS, TypeNS, ValueNS, ImplNS ];\n+        self.namespaces = ~[ ModuleNS, TypeNS, ValueNS ];\n \n         self.def_map = int_hash();\n         self.export_map = int_hash();\n@@ -846,10 +812,8 @@ struct Resolver {\n             }\n             some(child) => {\n               // We don't want to complain if the multiple definitions\n-              // are in different namespaces. (unless it's the impl namespace,\n-              // since impls can share a name)\n-              match ns.find(|n| n != ImplNS\n-                            && child.defined_in_namespace(n)) {\n+              // are in different namespaces.\n+              match ns.find(|n| child.defined_in_namespace(n)) {\n                 some(ns) => {\n                   self.session.span_err(sp,\n                        #fmt(\"Duplicate definition of %s %s\",\n@@ -988,19 +952,20 @@ struct Resolver {\n \n             // These items live in both the type and value namespaces.\n             item_class(struct_definition, _) => {\n-                let (name_bindings, new_parent) =\n+                let new_parent =\n                     match struct_definition.ctor {\n                     none => {\n-                        let (name_bindings, new_parent) = self.add_child(atom,\n-                              parent, ~[TypeNS], sp);\n+                        let (name_bindings, new_parent) =\n+                            self.add_child(atom, parent, ~[TypeNS], sp);\n \n                         (*name_bindings).define_type(def_ty(\n                             local_def(item.id)), sp);\n-                        (name_bindings, new_parent)\n+                        new_parent\n                     }\n                     some(ctor) => {\n-                        let (name_bindings, new_parent) = self.add_child(atom,\n-                                 parent, ~[ValueNS, TypeNS], sp);\n+                        let (name_bindings, new_parent) =\n+                            self.add_child(atom, parent, ~[ValueNS, TypeNS],\n+                                           sp);\n \n                         (*name_bindings).define_type(def_ty(\n                             local_def(item.id)), sp);\n@@ -1009,74 +974,22 @@ struct Resolver {\n                         let ctor_def = def_fn(local_def(ctor.node.id),\n                                               purity);\n                         (*name_bindings).define_value(ctor_def, sp);\n-                        (name_bindings, new_parent)\n+                        new_parent\n                     }\n                 };\n \n-                // Create the set of implementation information that the\n-                // implementation scopes (ImplScopes) need and write it into\n-                // the implementation definition list for this set of name\n-                // bindings.\n-\n-                let mut method_infos = ~[];\n-                for struct_definition.methods.each |method| {\n-                    // XXX: Combine with impl method code below.\n-                    method_infos += ~[\n-                        @{\n-                            did: local_def(method.id),\n-                            n_tps: method.tps.len(),\n-                            ident: method.ident,\n-                            self_type: method.self_ty.node\n-                        }\n-                    ];\n-                }\n-\n-                let impl_info = @{\n-                    did: local_def(item.id),\n-                    ident: /* XXX: bad */ copy item.ident,\n-                    methods: method_infos\n-                };\n-\n-                (*name_bindings).define_impl(impl_info);\n-\n                 // Record the def ID of this struct.\n                 self.structs.insert(local_def(item.id),\n                                     is_some(struct_definition.ctor));\n \n                 visit_item(item, new_parent, visitor);\n             }\n \n-            item_impl(_, _, _, methods) => {\n-                // Create the set of implementation information that the\n-                // implementation scopes (ImplScopes) need and write it into\n-                // the implementation definition list for this set of name\n-                // bindings.\n-              let (name_bindings, new_parent) = self.add_child(atom, parent,\n-                                                               ~[ImplNS], sp);\n-\n-                let mut method_infos = ~[];\n-                for methods.each |method| {\n-                    method_infos += ~[\n-                        @{\n-                            did: local_def(method.id),\n-                            n_tps: method.tps.len(),\n-                            ident: method.ident,\n-                            self_type: method.self_ty.node\n-                        }\n-                    ];\n-                }\n-\n-                let impl_info = @{\n-                    did: local_def(item.id),\n-                    ident: /* XXX: bad */ copy item.ident,\n-                    methods: method_infos\n-                };\n-\n-                (*name_bindings).define_impl(impl_info);\n-                visit_item(item, new_parent, visitor);\n+            item_impl(*) => {\n+                visit_item(item, parent, visitor);\n             }\n \n-          item_trait(_, _, methods) => {\n+            item_trait(_, _, methods) => {\n               let (name_bindings, new_parent) = self.add_child(atom, parent,\n                                                                ~[TypeNS], sp);\n \n@@ -1813,7 +1726,6 @@ struct Resolver {\n         let mut module_result = UnknownResult;\n         let mut value_result = UnknownResult;\n         let mut type_result = UnknownResult;\n-        let mut impl_result = UnknownImplResult;\n \n         // Search for direct children of the containing module.\n         match containing_module.children.find(source) {\n@@ -1833,21 +1745,14 @@ struct Resolver {\n                     type_result = BoundResult(containing_module,\n                                               child_name_bindings);\n                 }\n-                if (*child_name_bindings).defined_in_namespace(ImplNS) {\n-                    let targets = @dvec();\n-                    (*targets).push(@Target(containing_module,\n-                                            child_name_bindings));\n-                    impl_result = BoundImplResult(targets);\n-                }\n             }\n         }\n \n         // Unless we managed to find a result in all four namespaces\n         // (exceedingly unlikely), search imports as well.\n \n-        match (module_result, value_result, type_result, impl_result) {\n-            (BoundResult(*), BoundResult(*), BoundResult(*),\n-             BoundImplResult(*)) => {\n+        match (module_result, value_result, type_result) {\n+            (BoundResult(*), BoundResult(*), BoundResult(*)) => {\n                 // Continue.\n             }\n             _ => {\n@@ -1880,9 +1785,6 @@ struct Resolver {\n                         if type_result == UnknownResult {\n                             type_result = UnboundResult;\n                         }\n-                        if impl_result == UnknownImplResult {\n-                            impl_result = UnboundImplResult;\n-                        }\n                     }\n                     some(import_resolution)\n                             if import_resolution.outstanding_references\n@@ -1905,18 +1807,6 @@ struct Resolver {\n                             }\n                         }\n \n-                        fn get_import_binding(import_resolution:\n-                                              @ImportResolution)\n-                                           -> ImplNamespaceResult {\n-\n-                            if (*import_resolution.impl_target).len() == 0u {\n-                                return UnboundImplResult;\n-                            }\n-                            return BoundImplResult(import_resolution.\n-                                                impl_target);\n-                        }\n-\n-\n                         // The name is an import which has been fully\n                         // resolved. We can, therefore, just follow it.\n \n@@ -1932,10 +1822,6 @@ struct Resolver {\n                             type_result = get_binding(import_resolution,\n                                                       TypeNS);\n                         }\n-                        if impl_result == UnknownImplResult {\n-                            impl_result =\n-                                get_import_binding(import_resolution);\n-                        }\n                     }\n                     some(_) => {\n                         // The import is unresolved. Bail out.\n@@ -1985,26 +1871,14 @@ struct Resolver {\n                 fail ~\"type result should be known at this point\";\n             }\n         }\n-        match impl_result {\n-            BoundImplResult(targets) => {\n-                for (*targets).each |target| {\n-                    (*import_resolution.impl_target).push(target);\n-                }\n-            }\n-            UnboundImplResult => { /* Continue. */ }\n-            UnknownImplResult => {\n-                fail ~\"impl result should be known at this point\";\n-            }\n-        }\n \n         let i = import_resolution;\n-        match (i.module_target, i.value_target,\n-               i.type_target, i.impl_target) {\n+        match (i.module_target, i.value_target, i.type_target) {\n           /*\n             If this name wasn't found in any of the four namespaces, it's\n             definitely unresolved\n            */\n-          (none, none, none, v) if v.len() == 0 => { return Failed; }\n+          (none, none, none) => { return Failed; }\n           _ => {}\n         }\n \n@@ -2067,8 +1941,6 @@ struct Resolver {\n                         copy target_import_resolution.value_target;\n                     new_import_resolution.type_target =\n                         copy target_import_resolution.type_target;\n-                    new_import_resolution.impl_target =\n-                        copy target_import_resolution.impl_target;\n \n                     module_.import_resolutions.insert\n                         (atom, new_import_resolution);\n@@ -2104,17 +1976,6 @@ struct Resolver {\n                                 some(copy type_target);\n                         }\n                     }\n-                    if (*target_import_resolution.impl_target).len() > 0u &&\n-                            !ptr_eq(target_import_resolution.impl_target,\n-                                    dest_import_resolution.impl_target) {\n-                        for (*target_import_resolution.impl_target).each\n-                                |impl_target| {\n-\n-                            (*dest_import_resolution.impl_target).\n-                                push(impl_target);\n-\n-                        }\n-                    }\n                 }\n             }\n         }\n@@ -2163,11 +2024,6 @@ struct Resolver {\n                 dest_import_resolution.type_target =\n                     some(Target(containing_module, name_bindings));\n             }\n-            if (*name_bindings).defined_in_namespace(ImplNS) {\n-                debug!{\"(resolving glob import) ... for impl target\"};\n-                (*dest_import_resolution.impl_target).push\n-                    (@Target(containing_module, name_bindings));\n-            }\n         }\n \n         debug!{\"(resolving glob import) successfully resolved import\"};\n@@ -2586,32 +2442,10 @@ struct Resolver {\n         // *and* A::B::foo being aliased to A::B::bar.\n         //\n \n-        let mut impl_result;\n-        debug!{\"(resolving one-level naming result) searching for impl\"};\n-        match self.resolve_item_in_lexical_scope(module_,\n-                                               source_name,\n-                                               ImplNS) {\n-\n-            Failed => {\n-                debug!{\"(resolving one-level renaming import) didn't find \\\n-                        impl result\"};\n-                impl_result = none;\n-            }\n-            Indeterminate => {\n-                debug!{\"(resolving one-level renaming import) impl result is \\\n-                        indeterminate; bailing\"};\n-                return Indeterminate;\n-            }\n-            Success(name_bindings) => {\n-                debug!{\"(resolving one-level renaming import) impl result \\\n-                        found\"};\n-                impl_result = some(@copy name_bindings);\n-            }\n-        }\n-\n         // If nothing at all was found, that's an error.\n-        if is_none(module_result) && is_none(value_result) &&\n-                is_none(type_result) && is_none(impl_result) {\n+        if is_none(module_result) &&\n+                is_none(value_result) &&\n+                is_none(type_result) {\n \n             self.session.span_err(import_directive.span,\n                                   ~\"unresolved import\");\n@@ -2636,15 +2470,6 @@ struct Resolver {\n                 import_resolution.value_target = value_result;\n                 import_resolution.type_target = type_result;\n \n-                match impl_result {\n-                    none => {\n-                        // Nothing to do.\n-                    }\n-                    some(impl_result) => {\n-                        (*import_resolution.impl_target).push(impl_result);\n-                    }\n-                }\n-\n                 assert import_resolution.outstanding_references >= 1u;\n                 import_resolution.outstanding_references -= 1u;\n             }\n@@ -2736,13 +2561,6 @@ struct Resolver {\n         for module_.exported_names.each |name, node_id| {\n             let mut exports = ~[];\n             for self.namespaces.each |namespace| {\n-                // Ignore impl namespaces; they cause the original resolve\n-                // to fail.\n-\n-                if namespace == ImplNS {\n-                    again;\n-                }\n-\n                 match self.resolve_definition_of_name_in_module(module_,\n                                                               name,\n                                                               namespace,\n@@ -3358,9 +3176,6 @@ struct Resolver {\n                      optional_destructor: option<class_dtor>,\n                      visitor: ResolveVisitor) {\n \n-        // Add a type into the def map. This is needed to prevent an ICE in\n-        // ty::impl_traits.\n-\n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = (*type_parameters).len();\n         let borrowed_type_parameters: &~[ty_param] = &*type_parameters;\n@@ -4211,8 +4026,8 @@ struct Resolver {\n                 search_result = self.search_ribs(self.type_ribs, name, span,\n                                                  AllowCapturingSelf);\n             }\n-            ModuleNS | ImplNS => {\n-                fail ~\"module or impl namespaces do not have local ribs\";\n+            ModuleNS => {\n+                fail ~\"module namespaces do not have local ribs\";\n             }\n         }\n \n@@ -4597,7 +4412,7 @@ struct Resolver {\n     }\n \n     fn check_for_unused_imports_in_module(module_: @Module) {\n-        for module_.import_resolutions.each |_impl_name, import_resolution| {\n+        for module_.import_resolutions.each |_name, import_resolution| {\n             if !import_resolution.used {\n                 match self.unused_import_lint_level {\n                     warn => {\n@@ -4703,18 +4518,9 @@ struct Resolver {\n                 }\n             }\n \n-            let mut impl_repr;\n-            match (*import_resolution).target_for_namespace(ImplNS) {\n-                none => { impl_repr = ~\"\"; }\n-                some(target) => {\n-                    impl_repr = ~\" impl:?\";\n-                    // XXX\n-                }\n-            }\n-\n-            debug!{\"* %s:%s%s%s%s\",\n+            debug!{\"* %s:%s%s%s\",\n                    *(*self.atom_table).atom_to_str(name),\n-                   module_repr, value_repr, type_repr, impl_repr};\n+                   module_repr, value_repr, type_repr};\n         }\n     }\n }"}]}