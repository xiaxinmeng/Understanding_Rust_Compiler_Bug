{"sha": "ff61b74a7d98bae2586047227579733080b71cf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNjFiNzRhN2Q5OGJhZTI1ODYwNDcyMjc1Nzk3MzMwODBiNzFjZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-13T00:22:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-13T00:22:39Z"}, "message": "auto merge of #17467 : hatahet/rust/mybranch, r=alexcrichton\n\n\r\n\r\n[breaking-change]", "tree": {"sha": "933df870909657d9ecd635b3f340f699ab8d538a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/933df870909657d9ecd635b3f340f699ab8d538a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff61b74a7d98bae2586047227579733080b71cf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff61b74a7d98bae2586047227579733080b71cf6", "html_url": "https://github.com/rust-lang/rust/commit/ff61b74a7d98bae2586047227579733080b71cf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff61b74a7d98bae2586047227579733080b71cf6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff0abf05c9852df629df4a1ebe2e4276a87fc4f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0abf05c9852df629df4a1ebe2e4276a87fc4f9", "html_url": "https://github.com/rust-lang/rust/commit/ff0abf05c9852df629df4a1ebe2e4276a87fc4f9"}, {"sha": "84ce372ceec5322f8bfef82367e03bd7a4de3184", "url": "https://api.github.com/repos/rust-lang/rust/commits/84ce372ceec5322f8bfef82367e03bd7a4de3184", "html_url": "https://github.com/rust-lang/rust/commit/84ce372ceec5322f8bfef82367e03bd7a4de3184"}], "stats": {"total": 459, "additions": 256, "deletions": 203}, "files": [{"sha": "5f8c7d29444ce6ec0da1138c08424d4940e13da0", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 256, "deletions": 203, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/ff61b74a7d98bae2586047227579733080b71cf6/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff61b74a7d98bae2586047227579733080b71cf6/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=ff61b74a7d98bae2586047227579733080b71cf6", "patch": "@@ -28,6 +28,8 @@\n extern crate serialize;\n extern crate libc;\n \n+use std::fmt::Show;\n+use std::fmt;\n use std::io::BufReader;\n use std::num;\n use std::string::String;\n@@ -318,7 +320,6 @@ pub fn now() -> Tm {\n     at(get_time())\n }\n \n-\n impl Tm {\n     /// Convert time to the seconds from January 1, 1970\n     pub fn to_timespec(&self) -> Timespec {\n@@ -359,11 +360,12 @@ impl Tm {\n      * Example: \"Thu Jan  1 00:00:00 1970\"\n      */\n     pub fn asctime(&self) -> String {\n-        self.strftime(\"%c\")\n+        self.strftime(\"%c\").unwrap()\n     }\n \n     /// Formats the time according to the format string.\n-    pub fn strftime(&self, format: &str) -> String {\n+    #[inline(always)]\n+    pub fn strftime(&self, format: &str) -> Result<String, ParseError> {\n         strftime(format, self)\n     }\n \n@@ -375,9 +377,9 @@ impl Tm {\n      */\n     pub fn rfc822(&self) -> String {\n         if self.tm_gmtoff == 0_i32 {\n-            self.strftime(\"%a, %d %b %Y %T GMT\")\n+            self.strftime(\"%a, %d %b %Y %T GMT\").unwrap()\n         } else {\n-            self.strftime(\"%a, %d %b %Y %T %Z\")\n+            self.strftime(\"%a, %d %b %Y %T %Z\").unwrap()\n         }\n     }\n \n@@ -388,7 +390,7 @@ impl Tm {\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n      */\n     pub fn rfc822z(&self) -> String {\n-        self.strftime(\"%a, %d %b %Y %T %z\")\n+        self.strftime(\"%a, %d %b %Y %T %z\").unwrap()\n     }\n \n     /**\n@@ -400,9 +402,9 @@ impl Tm {\n      */\n     pub fn rfc3339(&self) -> String {\n         if self.tm_gmtoff == 0_i32 {\n-            self.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n+            self.strftime(\"%Y-%m-%dT%H:%M:%SZ\").unwrap()\n         } else {\n-            let s = self.strftime(\"%Y-%m-%dT%H:%M:%S\");\n+            let s = self.strftime(\"%Y-%m-%dT%H:%M:%S\").unwrap();\n             let sign = if self.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = num::abs(self.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n@@ -412,10 +414,49 @@ impl Tm {\n     }\n }\n \n+#[deriving(PartialEq)]\n+pub enum ParseError {\n+    InvalidSecond,\n+    InvalidMinute,\n+    InvalidHour,\n+    InvalidDay,\n+    InvalidMonth,\n+    InvalidYear,\n+    InvalidDayOfWeek,\n+    InvalidDayOfMonth,\n+    InvalidDayOfYear,\n+    InvalidZoneOffset,\n+    InvalidTime,\n+    MissingFormatConverter,\n+    InvalidFormatSpecifier(char),\n+    UnexpectedCharacter(char, char),\n+}\n+\n+impl Show for ParseError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            InvalidSecond => write!(f, \"Invalid second.\"),\n+            InvalidMinute => write!(f, \"Invalid minute.\"),\n+            InvalidHour => write!(f, \"Invalid hour.\"),\n+            InvalidDay => write!(f, \"Invalid day.\"),\n+            InvalidMonth => write!(f, \"Invalid month.\"),\n+            InvalidYear => write!(f, \"Invalid year.\"),\n+            InvalidDayOfWeek => write!(f, \"Invalid day of the week.\"),\n+            InvalidDayOfMonth => write!(f, \"Invalid day of the month.\"),\n+            InvalidDayOfYear => write!(f, \"Invalid day of the year.\"),\n+            InvalidZoneOffset => write!(f, \"Invalid zone offset.\"),\n+            InvalidTime => write!(f, \"Invalid time.\"),\n+            MissingFormatConverter => write!(f, \"Missing format converter after `%`\"),\n+            InvalidFormatSpecifier(ch) => write!(f, \"Invalid format specifier: %{}\", ch),\n+            UnexpectedCharacter(a, b) => write!(f, \"Expected: {}, found: {}.\", a, b),\n+        }\n+    }\n+}\n+\n /// Parses the time from the string according to the format string.\n-pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n+pub fn strptime(s: &str, format: &str) -> Result<Tm, ParseError> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n-        return s.slice_from(pos).starts_with(needle);\n+        s.slice_from(pos).starts_with(needle)\n     }\n \n     fn match_strs(ss: &str, pos: uint, strs: &[(&str, i32)])\n@@ -493,18 +534,18 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n         }\n     }\n \n-    fn parse_char(s: &str, pos: uint, c: char) -> Result<uint, String> {\n+    fn parse_char(s: &str, pos: uint, c: char) -> Result<uint, ParseError> {\n         let range = s.char_range_at(pos);\n \n         if c == range.ch {\n             Ok(range.next)\n         } else {\n-            Err(format!(\"Expected {}, found {}\", c, range.ch))\n+            Err(UnexpectedCharacter(c, range.ch))\n         }\n     }\n \n     fn parse_type(s: &str, pos: uint, ch: char, tm: &mut Tm)\n-      -> Result<uint, String> {\n+      -> Result<uint, ParseError> {\n         match ch {\n           'A' => match match_strs(s, pos, [\n               (\"Sunday\", 0_i32),\n@@ -516,7 +557,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n               (\"Saturday\", 6_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-            None => Err(\"Invalid day\".to_string())\n+            None => Err(InvalidDay)\n           },\n           'a' => match match_strs(s, pos, [\n               (\"Sun\", 0_i32),\n@@ -528,7 +569,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n               (\"Sat\", 6_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-            None => Err(\"Invalid day\".to_string())\n+            None => Err(InvalidDay)\n           },\n           'B' => match match_strs(s, pos, [\n               (\"January\", 0_i32),\n@@ -545,7 +586,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n               (\"December\", 11_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n-            None => Err(\"Invalid month\".to_string())\n+            None => Err(InvalidMonth)\n           },\n           'b' | 'h' => match match_strs(s, pos, [\n               (\"Jan\", 0_i32),\n@@ -562,7 +603,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n               (\"Dec\", 11_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n-            None => Err(\"Invalid month\".to_string())\n+            None => Err(InvalidMonth)\n           },\n           'C' => match match_digits_in_range(s, pos, 2u, false, 0_i32,\n                                              99_i32) {\n@@ -571,7 +612,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                   tm.tm_year += (v * 100_i32) - 1900_i32;\n                   Ok(pos)\n               }\n-            None => Err(\"Invalid year\".to_string())\n+            None => Err(InvalidYear)\n           },\n           'c' => {\n             parse_type(s, pos, 'a', &mut *tm)\n@@ -594,12 +635,12 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n           'd' => match match_digits_in_range(s, pos, 2u, false, 1_i32,\n                                              31_i32) {\n             Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n-            None => Err(\"Invalid day of the month\".to_string())\n+            None => Err(InvalidDayOfMonth)\n           },\n           'e' => match match_digits_in_range(s, pos, 2u, true, 1_i32,\n                                              31_i32) {\n             Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n-            None => Err(\"Invalid day of the month\".to_string())\n+            None => Err(InvalidDayOfMonth)\n           },\n           'f' => {\n             let (val, pos) = match_fractional_seconds(s, pos);\n@@ -616,7 +657,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n           'H' => {\n             match match_digits_in_range(s, pos, 2u, false, 0_i32, 23_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_hour = v; Ok(pos) }\n-              None => Err(\"Invalid hour\".to_string())\n+              None => Err(InvalidHour)\n             }\n           }\n           'I' => {\n@@ -626,7 +667,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   Ok(pos)\n               }\n-              None => Err(\"Invalid hour\".to_string())\n+              None => Err(InvalidHour)\n             }\n           }\n           'j' => {\n@@ -636,13 +677,13 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                 tm.tm_yday = v - 1_i32;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid day of year\".to_string())\n+              None => Err(InvalidDayOfYear)\n             }\n           }\n           'k' => {\n             match match_digits_in_range(s, pos, 2u, true, 0_i32, 23_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_hour = v; Ok(pos) }\n-              None => Err(\"Invalid hour\".to_string())\n+              None => Err(InvalidHour)\n             }\n           }\n           'l' => {\n@@ -652,13 +693,13 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   Ok(pos)\n               }\n-              None => Err(\"Invalid hour\".to_string())\n+              None => Err(InvalidHour)\n             }\n           }\n           'M' => {\n             match match_digits_in_range(s, pos, 2u, false, 0_i32, 59_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_min = v; Ok(pos) }\n-              None => Err(\"Invalid minute\".to_string())\n+              None => Err(InvalidMinute)\n             }\n           }\n           'm' => {\n@@ -668,21 +709,21 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                 tm.tm_mon = v - 1_i32;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid month\".to_string())\n+              None => Err(InvalidMonth)\n             }\n           }\n           'n' => parse_char(s, pos, '\\n'),\n           'P' => match match_strs(s, pos,\n                                   [(\"am\", 0_i32), (\"pm\", 12_i32)]) {\n \n             Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n-            None => Err(\"Invalid hour\".to_string())\n+            None => Err(InvalidHour)\n           },\n           'p' => match match_strs(s, pos,\n                                   [(\"AM\", 0_i32), (\"PM\", 12_i32)]) {\n \n             Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n-            None => Err(\"Invalid hour\".to_string())\n+            None => Err(InvalidHour)\n           },\n           'R' => {\n             parse_type(s, pos, 'H', &mut *tm)\n@@ -705,7 +746,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                 tm.tm_sec = v;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid second\".to_string())\n+              None => Err(InvalidSecond)\n             }\n           }\n           //'s' {}\n@@ -724,7 +765,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                 tm.tm_wday = if v == 7 { 0 } else { v };\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid day of week\".to_string())\n+              None => Err(InvalidDayOfWeek)\n             }\n           }\n           'v' => {\n@@ -738,7 +779,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n           'w' => {\n             match match_digits_in_range(s, pos, 1u, false, 0_i32, 6_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-              None => Err(\"Invalid day of week\".to_string())\n+              None => Err(InvalidDayOfWeek)\n             }\n           }\n           'Y' => {\n@@ -748,7 +789,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                 tm.tm_year = v - 1900_i32;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid year\".to_string())\n+              None => Err(InvalidYear)\n             }\n           }\n           'y' => {\n@@ -758,7 +799,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                 tm.tm_year = v;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid year\".to_string())\n+              None => Err(InvalidYear)\n             }\n           }\n           'Z' => {\n@@ -792,16 +833,14 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n \n                     Ok(pos)\n                   }\n-                  None => Err(\"Invalid zone offset\".to_string())\n+                  None => Err(InvalidZoneOffset)\n                 }\n             } else {\n-                Err(\"Invalid zone offset\".to_string())\n+                Err(InvalidZoneOffset)\n             }\n           }\n           '%' => parse_char(s, pos, '%'),\n-          ch => {\n-            Err(format!(\"unknown formatting type: {}\", ch))\n-          }\n+          ch => Err(InvalidFormatSpecifier(ch))\n         }\n     }\n \n@@ -821,7 +860,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n     };\n     let mut pos = 0u;\n     let len = s.len();\n-    let mut result = Err(\"Invalid time\".to_string());\n+    let mut result = Err(InvalidTime);\n \n     while pos < len {\n         let range = s.char_range_at(pos);\n@@ -869,7 +908,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n }\n \n /// Formats the time according to the format string.\n-pub fn strftime(format: &str, tm: &Tm) -> String {\n+pub fn strftime(format: &str, tm: &Tm) -> Result<String, ParseError> {\n     fn days_in_year(year: int) -> i32 {\n         if (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0)) {\n             366    /* Days in a leap year */\n@@ -923,157 +962,156 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n         }\n     }\n \n-    fn parse_type(ch: char, tm: &Tm) -> String {\n-      let die = || {\n-          format!(\"strftime: can't understand this format {} \", ch)\n-      };\n+    fn parse_type(ch: char, tm: &Tm) -> Result<String, ParseError> {\n         match ch {\n           'A' => match tm.tm_wday as int {\n-            0 => \"Sunday\".to_string(),\n-            1 => \"Monday\".to_string(),\n-            2 => \"Tuesday\".to_string(),\n-            3 => \"Wednesday\".to_string(),\n-            4 => \"Thursday\".to_string(),\n-            5 => \"Friday\".to_string(),\n-            6 => \"Saturday\".to_string(),\n-            _ => die()\n+            0 => Ok(\"Sunday\".to_string()),\n+            1 => Ok(\"Monday\".to_string()),\n+            2 => Ok(\"Tuesday\".to_string()),\n+            3 => Ok(\"Wednesday\".to_string()),\n+            4 => Ok(\"Thursday\".to_string()),\n+            5 => Ok(\"Friday\".to_string()),\n+            6 => Ok(\"Saturday\".to_string()),\n+            _ => Err(InvalidFormatSpecifier(ch))\n           },\n          'a' => match tm.tm_wday as int {\n-            0 => \"Sun\".to_string(),\n-            1 => \"Mon\".to_string(),\n-            2 => \"Tue\".to_string(),\n-            3 => \"Wed\".to_string(),\n-            4 => \"Thu\".to_string(),\n-            5 => \"Fri\".to_string(),\n-            6 => \"Sat\".to_string(),\n-            _ => die()\n+            0 => Ok(\"Sun\".to_string()),\n+            1 => Ok(\"Mon\".to_string()),\n+            2 => Ok(\"Tue\".to_string()),\n+            3 => Ok(\"Wed\".to_string()),\n+            4 => Ok(\"Thu\".to_string()),\n+            5 => Ok(\"Fri\".to_string()),\n+            6 => Ok(\"Sat\".to_string()),\n+            _ => Err(InvalidFormatSpecifier(ch))\n           },\n           'B' => match tm.tm_mon as int {\n-            0 => \"January\".to_string(),\n-            1 => \"February\".to_string(),\n-            2 => \"March\".to_string(),\n-            3 => \"April\".to_string(),\n-            4 => \"May\".to_string(),\n-            5 => \"June\".to_string(),\n-            6 => \"July\".to_string(),\n-            7 => \"August\".to_string(),\n-            8 => \"September\".to_string(),\n-            9 => \"October\".to_string(),\n-            10 => \"November\".to_string(),\n-            11 => \"December\".to_string(),\n-            _ => die()\n+            0 => Ok(\"January\".to_string()),\n+            1 => Ok(\"February\".to_string()),\n+            2 => Ok(\"March\".to_string()),\n+            3 => Ok(\"April\".to_string()),\n+            4 => Ok(\"May\".to_string()),\n+            5 => Ok(\"June\".to_string()),\n+            6 => Ok(\"July\".to_string()),\n+            7 => Ok(\"August\".to_string()),\n+            8 => Ok(\"September\".to_string()),\n+            9 => Ok(\"October\".to_string()),\n+            10 => Ok(\"November\".to_string()),\n+            11 => Ok(\"December\".to_string()),\n+            _ => Err(InvalidFormatSpecifier(ch))\n           },\n           'b' | 'h' => match tm.tm_mon as int {\n-            0 => \"Jan\".to_string(),\n-            1 => \"Feb\".to_string(),\n-            2 => \"Mar\".to_string(),\n-            3 => \"Apr\".to_string(),\n-            4 => \"May\".to_string(),\n-            5 => \"Jun\".to_string(),\n-            6 => \"Jul\".to_string(),\n-            7 => \"Aug\".to_string(),\n-            8 => \"Sep\".to_string(),\n-            9 => \"Oct\".to_string(),\n-            10 => \"Nov\".to_string(),\n-            11 => \"Dec\".to_string(),\n-            _  => die()\n+            0 => Ok(\"Jan\".to_string()),\n+            1 => Ok(\"Feb\".to_string()),\n+            2 => Ok(\"Mar\".to_string()),\n+            3 => Ok(\"Apr\".to_string()),\n+            4 => Ok(\"May\".to_string()),\n+            5 => Ok(\"Jun\".to_string()),\n+            6 => Ok(\"Jul\".to_string()),\n+            7 => Ok(\"Aug\".to_string()),\n+            8 => Ok(\"Sep\".to_string()),\n+            9 => Ok(\"Oct\".to_string()),\n+            10 => Ok(\"Nov\".to_string()),\n+            11 => Ok(\"Dec\".to_string()),\n+            _ => Err(InvalidFormatSpecifier(ch))\n           },\n-          'C' => format!(\"{:02d}\", (tm.tm_year as int + 1900) / 100),\n+          'C' => Ok(format!(\"{:02d}\", (tm.tm_year as int + 1900) / 100)),\n           'c' => {\n-            format!(\"{} {} {} {} {}\",\n-                parse_type('a', tm),\n-                parse_type('b', tm),\n-                parse_type('e', tm),\n-                parse_type('T', tm),\n-                parse_type('Y', tm))\n+            Ok(format!(\"{} {} {} {} {}\",\n+                parse_type('a', tm).unwrap(),\n+                parse_type('b', tm).unwrap(),\n+                parse_type('e', tm).unwrap(),\n+                parse_type('T', tm).unwrap(),\n+                parse_type('Y', tm).unwrap()))\n           }\n           'D' | 'x' => {\n-            format!(\"{}/{}/{}\",\n-                parse_type('m', tm),\n-                parse_type('d', tm),\n-                parse_type('y', tm))\n+            Ok(format!(\"{}/{}/{}\",\n+                parse_type('m', tm).unwrap(),\n+                parse_type('d', tm).unwrap(),\n+                parse_type('y', tm).unwrap()))\n           }\n-          'd' => format!(\"{:02d}\", tm.tm_mday),\n-          'e' => format!(\"{:2d}\", tm.tm_mday),\n-          'f' => format!(\"{:09d}\", tm.tm_nsec),\n+          'd' => Ok(format!(\"{:02d}\", tm.tm_mday)),\n+          'e' => Ok(format!(\"{:2d}\", tm.tm_mday)),\n           'F' => {\n-            format!(\"{}-{}-{}\",\n-                parse_type('Y', tm),\n-                parse_type('m', tm),\n-                parse_type('d', tm))\n+            Ok(format!(\"{}-{}-{}\",\n+                parse_type('Y', tm).unwrap(),\n+                parse_type('m', tm).unwrap(),\n+                parse_type('d', tm).unwrap()))\n           }\n-          'G' => iso_week('G', tm),\n-          'g' => iso_week('g', tm),\n-          'H' => format!(\"{:02d}\", tm.tm_hour),\n+          'f' => Ok(format!(\"{:09d}\", tm.tm_nsec)),\n+          'G' => Ok(iso_week('G', tm)),\n+          'g' => Ok(iso_week('g', tm)),\n+          'H' => Ok(format!(\"{:02d}\", tm.tm_hour)),\n           'I' => {\n             let mut h = tm.tm_hour;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n-            format!(\"{:02d}\", h)\n+            Ok(format!(\"{:02d}\", h))\n           }\n-          'j' => format!(\"{:03d}\", tm.tm_yday + 1),\n-          'k' => format!(\"{:2d}\", tm.tm_hour),\n+          'j' => Ok(format!(\"{:03d}\", tm.tm_yday + 1)),\n+          'k' => Ok(format!(\"{:2d}\", tm.tm_hour)),\n           'l' => {\n             let mut h = tm.tm_hour;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n-            format!(\"{:2d}\", h)\n+            Ok(format!(\"{:2d}\", h))\n           }\n-          'M' => format!(\"{:02d}\", tm.tm_min),\n-          'm' => format!(\"{:02d}\", tm.tm_mon + 1),\n-          'n' => \"\\n\".to_string(),\n-          'P' => if (tm.tm_hour as int) < 12 { \"am\".to_string() } else { \"pm\".to_string() },\n-          'p' => if (tm.tm_hour as int) < 12 { \"AM\".to_string() } else { \"PM\".to_string() },\n+          'M' => Ok(format!(\"{:02d}\", tm.tm_min)),\n+          'm' => Ok(format!(\"{:02d}\", tm.tm_mon + 1)),\n+          'n' => Ok(\"\\n\".to_string()),\n+          'P' => Ok(if (tm.tm_hour as int) < 12 { \"am\".to_string() } else { \"pm\".to_string() }),\n+          'p' => Ok(if (tm.tm_hour as int) < 12 { \"AM\".to_string() } else { \"PM\".to_string() }),\n           'R' => {\n-            format!(\"{}:{}\",\n-                parse_type('H', tm),\n-                parse_type('M', tm))\n+            Ok(format!(\"{}:{}\",\n+                parse_type('H', tm).unwrap(),\n+                parse_type('M', tm).unwrap()))\n           }\n           'r' => {\n-            format!(\"{}:{}:{} {}\",\n-                parse_type('I', tm),\n-                parse_type('M', tm),\n-                parse_type('S', tm),\n-                parse_type('p', tm))\n+            Ok(format!(\"{}:{}:{} {}\",\n+                parse_type('I', tm).unwrap(),\n+                parse_type('M', tm).unwrap(),\n+                parse_type('S', tm).unwrap(),\n+                parse_type('p', tm).unwrap()))\n           }\n-          'S' => format!(\"{:02d}\", tm.tm_sec),\n-          's' => format!(\"{}\", tm.to_timespec().sec),\n+          'S' => Ok(format!(\"{:02d}\", tm.tm_sec)),\n+          's' => Ok(format!(\"{}\", tm.to_timespec().sec)),\n           'T' | 'X' => {\n-            format!(\"{}:{}:{}\",\n-                parse_type('H', tm),\n-                parse_type('M', tm),\n-                parse_type('S', tm))\n+            Ok(format!(\"{}:{}:{}\",\n+                parse_type('H', tm).unwrap(),\n+                parse_type('M', tm).unwrap(),\n+                parse_type('S', tm).unwrap()))\n           }\n-          't' => \"\\t\".to_string(),\n-          'U' => format!(\"{:02d}\", (tm.tm_yday - tm.tm_wday + 7) / 7),\n+          't' => Ok(\"\\t\".to_string()),\n+          'U' => Ok(format!(\"{:02d}\", (tm.tm_yday - tm.tm_wday + 7) / 7)),\n           'u' => {\n             let i = tm.tm_wday as int;\n-            (if i == 0 { 7 } else { i }).to_string()\n+            Ok((if i == 0 { 7 } else { i }).to_string())\n           }\n-          'V' => iso_week('V', tm),\n+          'V' => Ok(iso_week('V', tm)),\n           'v' => {\n-            format!(\"{}-{}-{}\",\n-                parse_type('e', tm),\n-                parse_type('b', tm),\n-                parse_type('Y', tm))\n+            Ok(format!(\"{}-{}-{}\",\n+                parse_type('e', tm).unwrap(),\n+                parse_type('b', tm).unwrap(),\n+                parse_type('Y', tm).unwrap()))\n           }\n           'W' => {\n-              format!(\"{:02d}\",\n-                             (tm.tm_yday - (tm.tm_wday - 1 + 7) % 7 + 7) / 7)\n+              Ok(format!(\"{:02d}\",\n+                         (tm.tm_yday - (tm.tm_wday - 1 + 7) % 7 + 7) / 7))\n           }\n-          'w' => (tm.tm_wday as int).to_string(),\n-          'Y' => (tm.tm_year as int + 1900).to_string(),\n-          'y' => format!(\"{:02d}\", (tm.tm_year as int + 1900) % 100),\n+          'w' => Ok((tm.tm_wday as int).to_string()),\n+          'Y' => Ok((tm.tm_year as int + 1900).to_string()),\n+          'y' => Ok(format!(\"{:02d}\", (tm.tm_year as int + 1900) % 100)),\n+          'Z' => Ok(if tm.tm_gmtoff == 0_i32 { \"GMT\".to_string() }\n+                    else { \"\".to_string() }), // FIXME (#2350): support locale\n           'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = num::abs(tm.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n-            format!(\"{}{:02d}{:02d}\", sign, h, m)\n+            Ok(format!(\"{}{:02d}{:02d}\", sign, h, m))\n           }\n-          '+' => tm.rfc3339(),\n-          '%' => \"%\".to_string(),\n-          _   => die()\n+          '+' => Ok(tm.rfc3339()),\n+          '%' => Ok(\"%\".to_string()),\n+          _ => Err(InvalidFormatSpecifier(ch))\n         }\n     }\n \n@@ -1083,27 +1121,31 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n     loop {\n         let mut b = [0];\n         let ch = match rdr.read(b) {\n-            Ok(..) => b[0],\n-            Err(..) => break,\n+            Ok(_) => b[0],\n+            Err(_) => break, // EOF.\n         };\n         match ch as char {\n             '%' => {\n-                rdr.read(b).unwrap();\n-                let s = parse_type(b[0] as char, tm);\n-                buf.push_all(s.as_bytes());\n+                if rdr.read(b).is_err() {\n+                    return Err(MissingFormatConverter)\n+                }\n+                match parse_type(b[0] as char, tm) {\n+                    Ok(s) => buf.push_all(s.as_bytes()),\n+                    Err(e) => return Err(e)\n+                }\n             }\n             ch => buf.push(ch as u8)\n         }\n     }\n \n-    String::from_utf8(buf).unwrap()\n+    Ok(String::from_utf8(buf).unwrap())\n }\n \n #[cfg(test)]\n mod tests {\n     extern crate test;\n-    use super::{Timespec, get_time, precise_time_ns, precise_time_s, tzset,\n-                at_utc, at, strptime};\n+    use super::{Timespec, InvalidTime, InvalidYear, InvalidFormatSpecifier, MissingFormatConverter,\n+                get_time, precise_time_ns, precise_time_s, tzset, at_utc, at, strptime};\n \n     use std::f64;\n     use std::result::{Err, Ok};\n@@ -1259,9 +1301,9 @@ mod tests {\n         }\n \n         let format = \"%a %b %e %T.%f %Y\";\n-        assert_eq!(strptime(\"\", format), Err(\"Invalid time\".to_string()));\n+        assert_eq!(strptime(\"\", format), Err(InvalidTime));\n         assert!(strptime(\"Fri Feb 13 15:31:30\", format)\n-            == Err(\"Invalid time\".to_string()));\n+            == Err(InvalidTime));\n \n         match strptime(\"Fri Feb 13 15:31:30.01234 2009\", format) {\n           Err(e) => fail!(e),\n@@ -1282,7 +1324,7 @@ mod tests {\n \n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n-              Ok(ref tm) => tm.strftime(format) == s.to_string(),\n+              Ok(ref tm) => tm.strftime(format).unwrap() == s.to_string(),\n               Err(e) => fail!(e)\n             }\n         }\n@@ -1394,7 +1436,7 @@ mod tests {\n         assert!(test(\"%\", \"%%\"));\n \n         // Test for #7256\n-        assert_eq!(strptime(\"360\", \"%Y-%m-%d\"), Err(\"Invalid year\".to_string()))\n+        assert_eq!(strptime(\"360\", \"%Y-%m-%d\"), Err(InvalidYear));\n     }\n \n     fn test_asctime() {\n@@ -1430,49 +1472,60 @@ mod tests {\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        assert_eq!(local.strftime(\"\"), \"\".to_string());\n-        assert_eq!(local.strftime(\"%A\"), \"Friday\".to_string());\n-        assert_eq!(local.strftime(\"%a\"), \"Fri\".to_string());\n-        assert_eq!(local.strftime(\"%B\"), \"February\".to_string());\n-        assert_eq!(local.strftime(\"%b\"), \"Feb\".to_string());\n-        assert_eq!(local.strftime(\"%C\"), \"20\".to_string());\n-        assert_eq!(local.strftime(\"%c\"), \"Fri Feb 13 15:31:30 2009\".to_string());\n-        assert_eq!(local.strftime(\"%D\"), \"02/13/09\".to_string());\n-        assert_eq!(local.strftime(\"%d\"), \"13\".to_string());\n-        assert_eq!(local.strftime(\"%e\"), \"13\".to_string());\n-        assert_eq!(local.strftime(\"%f\"), \"000054321\".to_string());\n-        assert_eq!(local.strftime(\"%F\"), \"2009-02-13\".to_string());\n-        assert_eq!(local.strftime(\"%G\"), \"2009\".to_string());\n-        assert_eq!(local.strftime(\"%g\"), \"09\".to_string());\n-        assert_eq!(local.strftime(\"%H\"), \"15\".to_string());\n-        assert_eq!(local.strftime(\"%I\"), \"03\".to_string());\n-        assert_eq!(local.strftime(\"%j\"), \"044\".to_string());\n-        assert_eq!(local.strftime(\"%k\"), \"15\".to_string());\n-        assert_eq!(local.strftime(\"%l\"), \" 3\".to_string());\n-        assert_eq!(local.strftime(\"%M\"), \"31\".to_string());\n-        assert_eq!(local.strftime(\"%m\"), \"02\".to_string());\n-        assert_eq!(local.strftime(\"%n\"), \"\\n\".to_string());\n-        assert_eq!(local.strftime(\"%P\"), \"pm\".to_string());\n-        assert_eq!(local.strftime(\"%p\"), \"PM\".to_string());\n-        assert_eq!(local.strftime(\"%R\"), \"15:31\".to_string());\n-        assert_eq!(local.strftime(\"%r\"), \"03:31:30 PM\".to_string());\n-        assert_eq!(local.strftime(\"%S\"), \"30\".to_string());\n-        assert_eq!(local.strftime(\"%s\"), \"1234567890\".to_string());\n-        assert_eq!(local.strftime(\"%T\"), \"15:31:30\".to_string());\n-        assert_eq!(local.strftime(\"%t\"), \"\\t\".to_string());\n-        assert_eq!(local.strftime(\"%U\"), \"06\".to_string());\n-        assert_eq!(local.strftime(\"%u\"), \"5\".to_string());\n-        assert_eq!(local.strftime(\"%V\"), \"07\".to_string());\n-        assert_eq!(local.strftime(\"%v\"), \"13-Feb-2009\".to_string());\n-        assert_eq!(local.strftime(\"%W\"), \"06\".to_string());\n-        assert_eq!(local.strftime(\"%w\"), \"5\".to_string());\n-        assert_eq!(local.strftime(\"%X\"), \"15:31:30\".to_string()); // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%x\"), \"02/13/09\".to_string()); // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%Y\"), \"2009\".to_string());\n-        assert_eq!(local.strftime(\"%y\"), \"09\".to_string());\n-        assert_eq!(local.strftime(\"%+\"), \"2009-02-13T15:31:30-08:00\".to_string());\n-        assert_eq!(local.strftime(\"%z\"), \"-0800\".to_string());\n-        assert_eq!(local.strftime(\"%%\"), \"%\".to_string());\n+        assert_eq!(local.strftime(\"\").unwrap(), \"\".to_string());\n+        assert_eq!(local.strftime(\"%A\").unwrap(), \"Friday\".to_string());\n+        assert_eq!(local.strftime(\"%a\").unwrap(), \"Fri\".to_string());\n+        assert_eq!(local.strftime(\"%B\").unwrap(), \"February\".to_string());\n+        assert_eq!(local.strftime(\"%b\").unwrap(), \"Feb\".to_string());\n+        assert_eq!(local.strftime(\"%C\").unwrap(), \"20\".to_string());\n+        assert_eq!(local.strftime(\"%c\").unwrap(), \"Fri Feb 13 15:31:30 2009\".to_string());\n+        assert_eq!(local.strftime(\"%D\").unwrap(), \"02/13/09\".to_string());\n+        assert_eq!(local.strftime(\"%d\").unwrap(), \"13\".to_string());\n+        assert_eq!(local.strftime(\"%e\").unwrap(), \"13\".to_string());\n+        assert_eq!(local.strftime(\"%F\").unwrap(), \"2009-02-13\".to_string());\n+        assert_eq!(local.strftime(\"%f\").unwrap(), \"000054321\".to_string());\n+        assert_eq!(local.strftime(\"%G\").unwrap(), \"2009\".to_string());\n+        assert_eq!(local.strftime(\"%g\").unwrap(), \"09\".to_string());\n+        assert_eq!(local.strftime(\"%H\").unwrap(), \"15\".to_string());\n+        assert_eq!(local.strftime(\"%h\").unwrap(), \"Feb\".to_string());\n+        assert_eq!(local.strftime(\"%I\").unwrap(), \"03\".to_string());\n+        assert_eq!(local.strftime(\"%j\").unwrap(), \"044\".to_string());\n+        assert_eq!(local.strftime(\"%k\").unwrap(), \"15\".to_string());\n+        assert_eq!(local.strftime(\"%l\").unwrap(), \" 3\".to_string());\n+        assert_eq!(local.strftime(\"%M\").unwrap(), \"31\".to_string());\n+        assert_eq!(local.strftime(\"%m\").unwrap(), \"02\".to_string());\n+        assert_eq!(local.strftime(\"%n\").unwrap(), \"\\n\".to_string());\n+        assert_eq!(local.strftime(\"%P\").unwrap(), \"pm\".to_string());\n+        assert_eq!(local.strftime(\"%p\").unwrap(), \"PM\".to_string());\n+        assert_eq!(local.strftime(\"%R\").unwrap(), \"15:31\".to_string());\n+        assert_eq!(local.strftime(\"%r\").unwrap(), \"03:31:30 PM\".to_string());\n+        assert_eq!(local.strftime(\"%S\").unwrap(), \"30\".to_string());\n+        assert_eq!(local.strftime(\"%s\").unwrap(), \"1234567890\".to_string());\n+        assert_eq!(local.strftime(\"%T\").unwrap(), \"15:31:30\".to_string());\n+        assert_eq!(local.strftime(\"%t\").unwrap(), \"\\t\".to_string());\n+        assert_eq!(local.strftime(\"%U\").unwrap(), \"06\".to_string());\n+        assert_eq!(local.strftime(\"%u\").unwrap(), \"5\".to_string());\n+        assert_eq!(local.strftime(\"%V\").unwrap(), \"07\".to_string());\n+        assert_eq!(local.strftime(\"%v\").unwrap(), \"13-Feb-2009\".to_string());\n+        assert_eq!(local.strftime(\"%W\").unwrap(), \"06\".to_string());\n+        assert_eq!(local.strftime(\"%w\").unwrap(), \"5\".to_string());\n+        // FIXME (#2350): support locale\n+        assert_eq!(local.strftime(\"%X\").unwrap(), \"15:31:30\".to_string());\n+        // FIXME (#2350): support locale\n+        assert_eq!(local.strftime(\"%x\").unwrap(), \"02/13/09\".to_string());\n+        assert_eq!(local.strftime(\"%Y\").unwrap(), \"2009\".to_string());\n+        assert_eq!(local.strftime(\"%y\").unwrap(), \"09\".to_string());\n+        assert_eq!(local.strftime(\"%Z\").unwrap(), \"\".to_string()); // FIXME (#2350): support locale\n+        assert_eq!(local.strftime(\"%z\").unwrap(), \"-0800\".to_string());\n+        assert_eq!(local.strftime(\"%+\").unwrap(), \"2009-02-13T15:31:30-08:00\".to_string());\n+        assert_eq!(local.strftime(\"%%\").unwrap(), \"%\".to_string());\n+\n+        let invalid_specifiers = [\"%E\", \"%J\", \"%K\", \"%L\", \"%N\", \"%O\", \"%o\", \"%Q\", \"%q\"];\n+        for &sp in invalid_specifiers.iter() {\n+            assert_eq!(local.strftime(sp).unwrap_err(), InvalidFormatSpecifier(sp.char_at(1)));\n+        }\n+        assert_eq!(local.strftime(\"%\").unwrap_err(), MissingFormatConverter);\n+        assert_eq!(local.strftime(\"%A %\").unwrap_err(), MissingFormatConverter);\n \n         assert_eq!(local.asctime(), \"Fri Feb 13 15:31:30 2009\".to_string());\n         assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_string());"}]}