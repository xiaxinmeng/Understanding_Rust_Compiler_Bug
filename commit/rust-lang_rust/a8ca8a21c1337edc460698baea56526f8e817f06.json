{"sha": "a8ca8a21c1337edc460698baea56526f8e817f06", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4Y2E4YTIxYzEzMzdlZGM0NjA2OThiYWVhNTY1MjZmOGU4MTdmMDY=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:28:01Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:28:01Z"}, "message": "literal representation restructure 10\n\nRename DigitInfo to NumericLiteral", "tree": {"sha": "abb17d228b1f6f217ffbe1a6b0ff5f7b249e66ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abb17d228b1f6f217ffbe1a6b0ff5f7b249e66ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8ca8a21c1337edc460698baea56526f8e817f06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8ca8a21c1337edc460698baea56526f8e817f06", "html_url": "https://github.com/rust-lang/rust/commit/a8ca8a21c1337edc460698baea56526f8e817f06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8ca8a21c1337edc460698baea56526f8e817f06/comments", "author": null, "committer": null, "parents": [{"sha": "a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4", "html_url": "https://github.com/rust-lang/rust/commit/a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4"}], "stats": {"total": 46, "additions": 23, "deletions": 23}, "files": [{"sha": "287c9b7b24e8dad7202690d8f75b4ec3fd6cba6f", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ca8a21c1337edc460698baea56526f8e817f06/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ca8a21c1337edc460698baea56526f8e817f06/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=a8ca8a21c1337edc460698baea56526f8e817f06", "patch": "@@ -86,8 +86,8 @@ impl ExcessivePrecision {\n             if sym_str == s {\n                 None\n             } else {\n-                let di = super::literal_representation::DigitInfo::new(&s, None, true);\n-                Some(di.grouping_hint())\n+                let num_lit = super::literal_representation::NumericLiteral::new(&s, None, true);\n+                Some(num_lit.grouping_hint())\n             }\n         } else {\n             None"}, {"sha": "3e278ff62fef69816723324f6e35152a93a8e83e", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a8ca8a21c1337edc460698baea56526f8e817f06/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ca8a21c1337edc460698baea56526f8e817f06/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=a8ca8a21c1337edc460698baea56526f8e817f06", "patch": "@@ -123,7 +123,7 @@ impl Radix {\n }\n \n #[derive(Debug)]\n-pub(super) struct DigitInfo<'a> {\n+pub(super) struct NumericLiteral<'a> {\n     /// Which radix the literal was represented in.\n     crate radix: Radix,\n     /// The radix prefix, if present.\n@@ -140,12 +140,12 @@ pub(super) struct DigitInfo<'a> {\n     crate suffix: Option<&'a str>,\n }\n \n-impl<'a> DigitInfo<'a> {\n-    fn from_lit(src: &'a str, lit: &Lit) -> Option<DigitInfo<'a>> {\n+impl<'a> NumericLiteral<'a> {\n+    fn from_lit(src: &'a str, lit: &Lit) -> Option<NumericLiteral<'a>> {\n         if lit.kind.is_numeric() && src.chars().next().map_or(false, |c| c.is_digit(10)) {\n             let (unsuffixed, suffix) = split_suffix(&src, &lit.kind);\n             let float = if let LitKind::Float(..) = lit.kind { true } else { false };\n-            Some(DigitInfo::new(unsuffixed, suffix, float))\n+            Some(NumericLiteral::new(unsuffixed, suffix, float))\n         } else {\n             None\n         }\n@@ -400,21 +400,21 @@ impl LiteralDigitGrouping {\n \n         if_chain! {\n             if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(mut digit_info) = DigitInfo::from_lit(&src, &lit);\n+            if let Some(mut num_lit) = NumericLiteral::from_lit(&src, &lit);\n             then {\n-                if !Self::check_for_mistyped_suffix(cx, lit.span, &mut digit_info) {\n+                if !Self::check_for_mistyped_suffix(cx, lit.span, &mut num_lit) {\n                     return;\n                 }\n \n                 let result = (|| {\n \n-                    let integral_group_size = Self::get_group_size(digit_info.integer.split('_'), in_macro)?;\n-                    if let Some(fraction) = digit_info.fraction {\n+                    let integral_group_size = Self::get_group_size(num_lit.integer.split('_'), in_macro)?;\n+                    if let Some(fraction) = num_lit.fraction {\n                         let fractional_group_size = Self::get_group_size(fraction.rsplit('_'), in_macro)?;\n \n                         let consistent = Self::parts_consistent(integral_group_size,\n                                                                 fractional_group_size,\n-                                                                digit_info.integer.len(),\n+                                                                num_lit.integer.len(),\n                                                                 fraction.len());\n                         if !consistent {\n                             return Err(WarningType::InconsistentDigitGrouping);\n@@ -425,7 +425,7 @@ impl LiteralDigitGrouping {\n \n \n                 if let Err(warning_type) = result {\n-                    warning_type.display(&digit_info.grouping_hint(), cx, lit.span)\n+                    warning_type.display(&num_lit.grouping_hint(), cx, lit.span)\n                 }\n             }\n         }\n@@ -435,25 +435,25 @@ impl LiteralDigitGrouping {\n     fn check_for_mistyped_suffix(\n         cx: &EarlyContext<'_>,\n         span: syntax_pos::Span,\n-        digit_info: &mut DigitInfo<'_>,\n+        num_lit: &mut NumericLiteral<'_>,\n     ) -> bool {\n-        if digit_info.suffix.is_some() {\n+        if num_lit.suffix.is_some() {\n             return true;\n         }\n \n-        let (part, mistyped_suffixes, missing_char) = if let Some((_, exponent)) = &mut digit_info.exponent {\n+        let (part, mistyped_suffixes, missing_char) = if let Some((_, exponent)) = &mut num_lit.exponent {\n             (exponent, &[\"32\", \"64\"][..], 'f')\n-        } else if let Some(fraction) = &mut digit_info.fraction {\n+        } else if let Some(fraction) = &mut num_lit.fraction {\n             (fraction, &[\"32\", \"64\"][..], 'f')\n         } else {\n-            (&mut digit_info.integer, &[\"8\", \"16\", \"32\", \"64\"][..], 'i')\n+            (&mut num_lit.integer, &[\"8\", \"16\", \"32\", \"64\"][..], 'i')\n         };\n \n         let mut split = part.rsplit('_');\n         let last_group = split.next().expect(\"At least one group\");\n         if split.next().is_some() && mistyped_suffixes.contains(&last_group) {\n             *part = &part[..part.len() - last_group.len()];\n-            let mut hint = digit_info.grouping_hint();\n+            let mut hint = num_lit.grouping_hint();\n             hint.push('_');\n             hint.push(missing_char);\n             hint.push_str(last_group);\n@@ -539,14 +539,14 @@ impl DecimalLiteralRepresentation {\n         if_chain! {\n             if let LitKind::Int(val, _) = lit.kind;\n             if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(digit_info) = DigitInfo::from_lit(&src, &lit);\n-            if digit_info.radix == Radix::Decimal;\n+            if let Some(num_lit) = NumericLiteral::from_lit(&src, &lit);\n+            if num_lit.radix == Radix::Decimal;\n             if val >= u128::from(self.threshold);\n             then {\n                 let hex = format!(\"{:#X}\", val);\n-                let digit_info = DigitInfo::new(&hex, None, false);\n-                let _ = Self::do_lint(digit_info.integer).map_err(|warning_type| {\n-                    warning_type.display(&digit_info.grouping_hint(), cx, lit.span)\n+                let num_lit = NumericLiteral::new(&hex, None, false);\n+                let _ = Self::do_lint(num_lit.integer).map_err(|warning_type| {\n+                    warning_type.display(&num_lit.grouping_hint(), cx, lit.span)\n                 });\n             }\n         }"}]}