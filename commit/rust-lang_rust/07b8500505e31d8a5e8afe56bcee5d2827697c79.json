{"sha": "07b8500505e31d8a5e8afe56bcee5d2827697c79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3Yjg1MDA1MDVlMzFkOGE1ZThhZmU1NmJjZWU1ZDI4Mjc2OTdjNzk=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-21T13:29:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-21T13:29:08Z"}, "message": "Merge pull request #57 from oli-obk/master\n\nfix enum down casting and backtrace panics", "tree": {"sha": "5b90e002bd099c5b3cd920c5ba75b25374514231", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b90e002bd099c5b3cd920c5ba75b25374514231"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07b8500505e31d8a5e8afe56bcee5d2827697c79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07b8500505e31d8a5e8afe56bcee5d2827697c79", "html_url": "https://github.com/rust-lang/rust/commit/07b8500505e31d8a5e8afe56bcee5d2827697c79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07b8500505e31d8a5e8afe56bcee5d2827697c79/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1ae916a64395755a937fa4374f74093b1549221", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1ae916a64395755a937fa4374f74093b1549221", "html_url": "https://github.com/rust-lang/rust/commit/c1ae916a64395755a937fa4374f74093b1549221"}, {"sha": "75ccfd57a508807af636a399a6fae5da1894134f", "url": "https://api.github.com/repos/rust-lang/rust/commits/75ccfd57a508807af636a399a6fae5da1894134f", "html_url": "https://github.com/rust-lang/rust/commit/75ccfd57a508807af636a399a6fae5da1894134f"}], "stats": {"total": 535, "additions": 362, "deletions": 173}, "files": [{"sha": "9338044e53419931f8d475e3a6c274ec1dfd9e17", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07b8500505e31d8a5e8afe56bcee5d2827697c79/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b8500505e31d8a5e8afe56bcee5d2827697c79/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=07b8500505e31d8a5e8afe56bcee5d2827697c79", "patch": "@@ -907,9 +907,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Downcast(_, variant) => {\n                         use rustc::ty::layout::Layout::*;\n                         match *base_layout {\n-                            General { discr, .. } => {\n+                            General { ref variants, .. } => {\n                                 return Ok(Lvalue {\n-                                    ptr: base.ptr.offset(discr.size().bytes() as isize),\n+                                    ptr: base.ptr.offset(variants[variant].field_offset(1).bytes() as isize),\n                                     extra: LvalueExtra::DowncastVariant(variant),\n                                 });\n                             }\n@@ -1188,13 +1188,7 @@ fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n                 ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[])\n             }\n         }\n-        let inst = Instance(def_id, substs);\n-        match ::std::panic::catch_unwind(|| {\n-            format!(\"inside call to {}\", inst)\n-        }) {\n-            Ok(msg) => err.span_note(span, &msg),\n-            Err(_) => err.span_note(span, &format!(\"ppaux::parameterized failed: {:?}, {:?}\", def_id, substs)),\n-        };\n+        err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n     }\n     err.emit();\n }"}, {"sha": "e2381d59e2cd64a0376ca31b09e44d6df819537a", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/07b8500505e31d8a5e8afe56bcee5d2827697c79/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b8500505e31d8a5e8afe56bcee5d2827697c79/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=07b8500505e31d8a5e8afe56bcee5d2827697c79", "patch": "@@ -0,0 +1,251 @@\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::repr as mir;\n+use rustc::ty::layout::Layout;\n+use rustc::ty::subst::Substs;\n+use rustc::ty;\n+\n+use error::{EvalError, EvalResult};\n+use memory::Pointer;\n+use interpreter::EvalContext;\n+use primval;\n+\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    pub(super) fn call_intrinsic(\n+        &mut self,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        dest: Pointer,\n+        dest_layout: &'tcx Layout,\n+    ) -> EvalResult<'tcx, ()> {\n+        // TODO(solson): We can probably remove this _to_ptr easily.\n+        let args_res: EvalResult<Vec<Pointer>> = args.iter()\n+            .map(|arg| self.eval_operand_to_ptr(arg))\n+            .collect();\n+        let args_ptrs = args_res?;\n+        let pointer_size = self.memory.pointer_size();\n+\n+        match &self.tcx.item_name(def_id).as_str()[..] {\n+            \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n+            \"sub_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_layout)?,\n+            \"mul_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_layout)?,\n+\n+            \"arith_offset\" => {\n+                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                let offset = self.memory.read_int(args_ptrs[1], pointer_size)?;\n+                let new_ptr = ptr.offset(offset as isize);\n+                self.memory.write_ptr(dest, new_ptr)?;\n+            }\n+\n+            \"assume\" => {\n+                if !self.memory.read_bool(args_ptrs[0])? {\n+                    return Err(EvalError::AssumptionNotHeld);\n+                }\n+            }\n+\n+            \"breakpoint\" => unimplemented!(), // halt miri\n+\n+            \"copy\" |\n+            \"copy_nonoverlapping\" => {\n+                // FIXME: check whether overlapping occurs\n+                let elem_ty = substs.type_at(0);\n+                let elem_size = self.type_size(elem_ty);\n+                let elem_align = self.type_align(elem_ty);\n+                let src = self.memory.read_ptr(args_ptrs[0])?;\n+                let dest = self.memory.read_ptr(args_ptrs[1])?;\n+                let count = self.memory.read_isize(args_ptrs[2])?;\n+                self.memory.copy(src, dest, count as usize * elem_size, elem_align)?;\n+            }\n+\n+            \"ctpop\" => {\n+                let elem_ty = substs.type_at(0);\n+                let elem_size = self.type_size(elem_ty);\n+                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.count_ones();\n+                self.memory.write_uint(dest, num.into(), elem_size)?;\n+            }\n+\n+            \"ctlz\" => {\n+                let elem_ty = substs.type_at(0);\n+                let elem_size = self.type_size(elem_ty);\n+                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.leading_zeros();\n+                self.memory.write_uint(dest, num.into(), elem_size)?;\n+            }\n+\n+            \"discriminant_value\" => {\n+                let ty = substs.type_at(0);\n+                let adt_ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n+                self.memory.write_uint(dest, discr_val, 8)?;\n+            }\n+\n+            \"fabsf32\" => {\n+                let f = self.memory.read_f32(args_ptrs[0])?;\n+                self.memory.write_f32(dest, f.abs())?;\n+            }\n+\n+            \"fabsf64\" => {\n+                let f = self.memory.read_f64(args_ptrs[0])?;\n+                self.memory.write_f64(dest, f.abs())?;\n+            }\n+\n+            \"fadd_fast\" => {\n+                let ty = substs.type_at(0);\n+                let a = self.read_primval(args_ptrs[0], ty)?;\n+                let b = self.read_primval(args_ptrs[0], ty)?;\n+                let result = primval::binary_op(mir::BinOp::Add, a, b)?;\n+                self.memory.write_primval(dest, result.0)?;\n+            }\n+\n+            \"likely\" |\n+            \"unlikely\" |\n+            \"forget\" => {}\n+\n+            \"init\" => self.memory.write_repeat(dest, 0, dest_layout.size(&self.tcx.data_layout).bytes() as usize)?,\n+\n+            \"min_align_of\" => {\n+                let elem_ty = substs.type_at(0);\n+                let elem_align = self.type_align(elem_ty);\n+                self.memory.write_uint(dest, elem_align as u64, pointer_size)?;\n+            }\n+\n+            \"pref_align_of\" => {\n+                let ty = substs.type_at(0);\n+                let layout = self.type_layout(ty);\n+                let align = layout.align(&self.tcx.data_layout).pref();\n+                self.memory.write_uint(dest, align, pointer_size)?;\n+            }\n+\n+            \"move_val_init\" => {\n+                let ty = substs.type_at(0);\n+                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                self.move_(args_ptrs[1], ptr, ty)?;\n+            }\n+\n+            \"needs_drop\" => {\n+                let ty = substs.type_at(0);\n+                self.memory.write_bool(dest, self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment()))?;\n+            }\n+\n+            \"offset\" => {\n+                let pointee_ty = substs.type_at(0);\n+                let pointee_size = self.type_size(pointee_ty) as isize;\n+                let ptr_arg = args_ptrs[0];\n+                let offset = self.memory.read_isize(args_ptrs[1])?;\n+\n+                match self.memory.read_ptr(ptr_arg) {\n+                    Ok(ptr) => {\n+                        let result_ptr = ptr.offset(offset as isize * pointee_size);\n+                        self.memory.write_ptr(dest, result_ptr)?;\n+                    }\n+                    Err(EvalError::ReadBytesAsPointer) => {\n+                        let addr = self.memory.read_isize(ptr_arg)?;\n+                        let result_addr = addr + offset * pointee_size as i64;\n+                        self.memory.write_isize(dest, result_addr)?;\n+                    }\n+                    Err(e) => return Err(e),\n+                }\n+            }\n+\n+            \"overflowing_sub\" => {\n+                self.intrinsic_overflowing(mir::BinOp::Sub, &args[0], &args[1], dest)?;\n+            }\n+\n+            \"overflowing_mul\" => {\n+                self.intrinsic_overflowing(mir::BinOp::Mul, &args[0], &args[1], dest)?;\n+            }\n+\n+            \"overflowing_add\" => {\n+                self.intrinsic_overflowing(mir::BinOp::Add, &args[0], &args[1], dest)?;\n+            }\n+\n+            \"powif32\" => {\n+                let f = self.memory.read_f32(args_ptrs[0])?;\n+                let i = self.memory.read_int(args_ptrs[1], 4)?;\n+                self.memory.write_f32(dest, f.powi(i as i32))?;\n+            }\n+\n+            \"powif64\" => {\n+                let f = self.memory.read_f32(args_ptrs[0])?;\n+                let i = self.memory.read_int(args_ptrs[1], 4)?;\n+                self.memory.write_f32(dest, f.powi(i as i32))?;\n+            }\n+\n+            \"sqrtf32\" => {\n+                let f = self.memory.read_f32(args_ptrs[0])?;\n+                self.memory.write_f32(dest, f.sqrt())?;\n+            }\n+\n+            \"sqrtf64\" => {\n+                let f = self.memory.read_f64(args_ptrs[0])?;\n+                self.memory.write_f64(dest, f.sqrt())?;\n+            }\n+\n+            \"size_of\" => {\n+                let ty = substs.type_at(0);\n+                let size = self.type_size(ty) as u64;\n+                self.memory.write_uint(dest, size, pointer_size)?;\n+            }\n+\n+            \"size_of_val\" => {\n+                let ty = substs.type_at(0);\n+                if self.type_is_sized(ty) {\n+                    let size = self.type_size(ty) as u64;\n+                    self.memory.write_uint(dest, size, pointer_size)?;\n+                } else {\n+                    match ty.sty {\n+                        ty::TySlice(_) | ty::TyStr => {\n+                            let elem_ty = ty.sequence_element_type(self.tcx);\n+                            let elem_size = self.type_size(elem_ty) as u64;\n+                            let ptr_size = self.memory.pointer_size() as isize;\n+                            let n = self.memory.read_usize(args_ptrs[0].offset(ptr_size))?;\n+                            self.memory.write_uint(dest, n * elem_size, pointer_size)?;\n+                        }\n+\n+                        _ => return Err(EvalError::Unimplemented(format!(\"unimplemented: size_of_val::<{:?}>\", ty))),\n+                    }\n+                }\n+            }\n+            // FIXME: wait for eval_operand_to_ptr to be gone\n+            /*\n+            \"type_name\" => {\n+                let ty = substs.type_at(0);\n+                let ty_name = ty.to_string();\n+                let s = self.str_to_value(&ty_name)?;\n+                self.memory.write_ptr(dest, s)?;\n+            }*/\n+            \"type_id\" => {\n+                let ty = substs.type_at(0);\n+                let n = self.tcx.type_id_hash(ty);\n+                self.memory.write_uint(dest, n, 8)?;\n+            }\n+\n+            \"transmute\" => {\n+                let ty = substs.type_at(0);\n+                self.move_(args_ptrs[0], dest, ty)?;\n+            }\n+\n+            \"try\" => unimplemented!(),\n+\n+            \"uninit\" => self.memory.mark_definedness(dest, dest_layout.size(&self.tcx.data_layout).bytes() as usize, false)?,\n+\n+            \"volatile_load\" => {\n+                let ty = substs.type_at(0);\n+                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                self.move_(ptr, dest, ty)?;\n+            }\n+\n+            \"volatile_store\" => {\n+                let ty = substs.type_at(0);\n+                let dest = self.memory.read_ptr(args_ptrs[0])?;\n+                self.move_(args_ptrs[1], dest, ty)?;\n+            }\n+\n+            name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n+        }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        Ok(())\n+    }\n+}"}, {"sha": "ae7eaf2c8b660d9d1d44faf0b5cee803ce3b8a4b", "filename": "src/interpreter/terminator/mod.rs", "status": "renamed", "additions": 74, "deletions": 154, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/07b8500505e31d8a5e8afe56bcee5d2827697c79/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b8500505e31d8a5e8afe56bcee5d2827697c79/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=07b8500505e31d8a5e8afe56bcee5d2827697c79", "patch": "@@ -15,6 +15,8 @@ use error::{EvalError, EvalResult};\n use memory::Pointer;\n use super::{EvalContext, IntegerExt, StackPopCleanup};\n \n+mod intrinsics;\n+\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub(super) fn goto_block(&mut self, target: mir::BasicBlock) {\n@@ -218,7 +220,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Some((ptr, block)) => (Some(ptr), StackPopCleanup::Goto(block)),\n                     None => (None, StackPopCleanup::None),\n                 };\n-                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr, return_to_block)?;\n+                self.push_stack_frame(resolved_def_id, span, mir, resolved_substs, return_ptr, return_to_block)?;\n \n                 for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n                     let dest = self.frame().locals[i];\n@@ -270,152 +272,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(if not_null { nndiscr } else { 1 - nndiscr })\n     }\n \n-    fn call_intrinsic(\n-        &mut self,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-        args: &[mir::Operand<'tcx>],\n-        dest: Pointer,\n-        dest_layout: &'tcx Layout,\n-    ) -> EvalResult<'tcx, ()> {\n-        // TODO(solson): We can probably remove this _to_ptr easily.\n-        let args_res: EvalResult<Vec<Pointer>> = args.iter()\n-            .map(|arg| self.eval_operand_to_ptr(arg))\n-            .collect();\n-        let args_ptrs = args_res?;\n-        let pointer_size = self.memory.pointer_size();\n-\n-        match &self.tcx.item_name(def_id).as_str()[..] {\n-            \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n-            \"sub_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_layout)?,\n-            \"mul_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_layout)?,\n-\n-            \"assume\" => {\n-                if !self.memory.read_bool(args_ptrs[0])? {\n-                    return Err(EvalError::AssumptionNotHeld);\n-                }\n-            }\n-\n-            \"copy_nonoverlapping\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty);\n-                let elem_align = self.type_align(elem_ty);\n-                let src = self.memory.read_ptr(args_ptrs[0])?;\n-                let dest = self.memory.read_ptr(args_ptrs[1])?;\n-                let count = self.memory.read_isize(args_ptrs[2])?;\n-                self.memory.copy(src, dest, count as usize * elem_size, elem_align)?;\n-            }\n-\n-            \"ctpop\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty);\n-                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.count_ones();\n-                self.memory.write_uint(dest, num.into(), elem_size)?;\n-            }\n-\n-            \"ctlz\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty);\n-                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.leading_zeros();\n-                self.memory.write_uint(dest, num.into(), elem_size)?;\n-            }\n-\n-            \"discriminant_value\" => {\n-                let ty = substs.type_at(0);\n-                let adt_ptr = self.memory.read_ptr(args_ptrs[0])?;\n-                let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n-                self.memory.write_uint(dest, discr_val, 8)?;\n-            }\n-\n-            \"forget\" => {}\n-\n-            \"init\" => self.memory.write_repeat(dest, 0, dest_layout.size(&self.tcx.data_layout).bytes() as usize)?,\n-\n-            \"min_align_of\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_align = self.type_align(elem_ty);\n-                self.memory.write_uint(dest, elem_align as u64, pointer_size)?;\n-            }\n-\n-            \"move_val_init\" => {\n-                let ty = substs.type_at(0);\n-                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n-                self.move_(args_ptrs[1], ptr, ty)?;\n-            }\n-\n-            \"offset\" => {\n-                let pointee_ty = substs.type_at(0);\n-                let pointee_size = self.type_size(pointee_ty) as isize;\n-                let ptr_arg = args_ptrs[0];\n-                let offset = self.memory.read_isize(args_ptrs[1])?;\n-\n-                match self.memory.read_ptr(ptr_arg) {\n-                    Ok(ptr) => {\n-                        let result_ptr = ptr.offset(offset as isize * pointee_size);\n-                        self.memory.write_ptr(dest, result_ptr)?;\n-                    }\n-                    Err(EvalError::ReadBytesAsPointer) => {\n-                        let addr = self.memory.read_isize(ptr_arg)?;\n-                        let result_addr = addr + offset * pointee_size as i64;\n-                        self.memory.write_isize(dest, result_addr)?;\n-                    }\n-                    Err(e) => return Err(e),\n-                }\n-            }\n-\n-            \"overflowing_sub\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Sub, &args[0], &args[1], dest)?;\n-            }\n-\n-            \"overflowing_mul\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Mul, &args[0], &args[1], dest)?;\n-            }\n-\n-            \"overflowing_add\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Add, &args[0], &args[1], dest)?;\n-            }\n-\n-            \"size_of\" => {\n-                let ty = substs.type_at(0);\n-                let size = self.type_size(ty) as u64;\n-                self.memory.write_uint(dest, size, pointer_size)?;\n-            }\n-\n-            \"size_of_val\" => {\n-                let ty = substs.type_at(0);\n-                if self.type_is_sized(ty) {\n-                    let size = self.type_size(ty) as u64;\n-                    self.memory.write_uint(dest, size, pointer_size)?;\n-                } else {\n-                    match ty.sty {\n-                        ty::TySlice(_) | ty::TyStr => {\n-                            let elem_ty = ty.sequence_element_type(self.tcx);\n-                            let elem_size = self.type_size(elem_ty) as u64;\n-                            let ptr_size = self.memory.pointer_size() as isize;\n-                            let n = self.memory.read_usize(args_ptrs[0].offset(ptr_size))?;\n-                            self.memory.write_uint(dest, n * elem_size, pointer_size)?;\n-                        }\n-\n-                        _ => return Err(EvalError::Unimplemented(format!(\"unimplemented: size_of_val::<{:?}>\", ty))),\n-                    }\n-                }\n-            }\n-\n-            \"transmute\" => {\n-                let ty = substs.type_at(0);\n-                self.move_(args_ptrs[0], dest, ty)?;\n-            }\n-            \"uninit\" => self.memory.mark_definedness(dest, dest_layout.size(&self.tcx.data_layout).bytes() as usize, false)?,\n-\n-            name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n-        }\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        Ok(())\n-    }\n-\n     fn call_c_abi(\n         &mut self,\n         def_id: DefId,\n@@ -512,7 +368,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     /// Trait method, which has to be resolved to an impl method.\n     fn trait_method(\n-        &self,\n+        &mut self,\n         trait_id: DefId,\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n@@ -527,14 +383,46 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let mname = self.tcx.item_name(def_id);\n                 // Create a concatenated set of substitutions which includes those from the impl\n                 // and those from the method:\n-                let mth = get_impl_method(self.tcx, substs, impl_did, vtable_impl.substs, mname);\n-\n-                Ok((mth.method.def_id, mth.substs))\n+                let (did, substs) = find_method(self.tcx, substs, impl_did, vtable_impl.substs, mname);\n+\n+                Ok((did, substs))\n+            }\n+\n+            traits::VtableClosure(vtable_closure) => {\n+                let trait_closure_kind = self.tcx\n+                    .lang_items\n+                    .fn_trait_kind(trait_id)\n+                    .expect(\"The substitutions should have no type parameters remaining after passing through fulfill_obligation\");\n+                let closure_kind = self.tcx.closure_kind(vtable_closure.closure_def_id);\n+                trace!(\"closures {:?}, {:?}\", closure_kind, trait_closure_kind);\n+                match (closure_kind, trait_closure_kind) {\n+                    (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+                    (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+                    (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) |\n+                    (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {} // No adapter needed.\n+                    (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+                    (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+                        // The closure fn is a `fn(&self, ...)` or `fn(&mut self, ...)`.\n+                        // We want a `fn(self, ...)`.\n+                        // We can produce this by doing something like:\n+                        //\n+                        //     fn call_once(self, ...) { call_mut(&self, ...) }\n+                        //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+                        //\n+                        // These are both the same at trans time.\n+\n+                        // interpreter magic: insert an intermediate pointer, so we can skip the intermediate function call\n+                        // FIXME: this is a memory leak, should probably add the pointer to the current stack\n+                        let ptr_size = self.memory.pointer_size();\n+                        let first = self.memory.allocate(ptr_size, ptr_size)?;\n+                        self.memory.copy(args[0].0, first, ptr_size, ptr_size)?;\n+                        self.memory.write_ptr(args[0].0, first)?;\n+                    }\n+                    _ => bug!(\"cannot convert {:?} to {:?}\", closure_kind, trait_closure_kind),\n+                }\n+                Ok((vtable_closure.closure_def_id, vtable_closure.substs.func_substs))\n             }\n \n-            traits::VtableClosure(vtable_closure) =>\n-                Ok((vtable_closure.closure_def_id, vtable_closure.substs.func_substs)),\n-\n             traits::VtableFnPointer(vtable_fn_ptr) => {\n                 if let ty::TyFnDef(did, ref substs, _) = vtable_fn_ptr.fn_ty.sty {\n                     args.remove(0);\n@@ -636,3 +524,35 @@ pub(super) fn get_impl_method<'a, 'tcx>(\n         }\n     }\n }\n+\n+/// Locates the applicable definition of a method, given its name.\n+pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             substs: &'tcx Substs<'tcx>,\n+                             impl_def_id: DefId,\n+                             impl_substs: &'tcx Substs<'tcx>,\n+                             name: ast::Name)\n+                             -> (DefId, &'tcx Substs<'tcx>)\n+{\n+    assert!(!substs.needs_infer());\n+\n+    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+\n+    match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n+        Some(node_item) => {\n+            let substs = tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n+                let substs = traits::translate_substs(&infcx, impl_def_id, substs, node_item.node);\n+                tcx.lift(&substs).unwrap_or_else(|| {\n+                    bug!(\"find_method: translate_substs \\\n+                          returned {:?} which contains inference types/regions\",\n+                         substs);\n+                })\n+            });\n+            (node_item.item.def_id, substs)\n+        }\n+        None => {\n+            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n+        }\n+    }\n+}", "previous_filename": "src/interpreter/terminator.rs"}, {"sha": "8598a8e7c5719382214c8a7b258d03af62778ef2", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07b8500505e31d8a5e8afe56bcee5d2827697c79/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b8500505e31d8a5e8afe56bcee5d2827697c79/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=07b8500505e31d8a5e8afe56bcee5d2827697c79", "patch": "@@ -36,6 +36,7 @@ pub use interpreter::{\n     Frame,\n     eval_main,\n     run_mir_passes,\n+    StackPopCleanup,\n };\n \n pub use memory::{"}, {"sha": "9b379051eb774a88f12c75cd18520c89534c9be2", "filename": "tests/run-pass/closures.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/07b8500505e31d8a5e8afe56bcee5d2827697c79/tests%2Frun-pass%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b8500505e31d8a5e8afe56bcee5d2827697c79/tests%2Frun-pass%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fclosures.rs?ref=07b8500505e31d8a5e8afe56bcee5d2827697c79", "patch": "@@ -21,18 +21,28 @@ fn crazy_closure() -> (i32, i32, i32) {\n     inner(10)\n }\n \n-// TODO(solson): Implement closure argument adjustment and uncomment this test.\n-// fn closure_arg_adjustment_problem() -> i64 {\n-//     fn once<F: FnOnce(i64)>(f: F) { f(2); }\n-//     let mut y = 1;\n-//     {\n-//         let f = |x| y += x;\n-//         once(f);\n-//     }\n-//     y\n-// }\n+fn closure_arg_adjustment_problem() -> i64 {\n+    fn once<F: FnOnce(i64)>(f: F) { f(2); }\n+    let mut y = 1;\n+    {\n+        let f = |x| y += x;\n+        once(f);\n+    }\n+    y\n+}\n+\n+fn fn_once_closure_with_multiple_args() -> i64 {\n+    fn once<F: FnOnce(i64, i64) -> i64>(f: F) -> i64 { f(2, 3) }\n+    let y = 1;\n+    {\n+        let f = |x, z| x + y + z;\n+        once(f)\n+    }\n+}\n \n fn main() {\n     assert_eq!(simple(), 12);\n     assert_eq!(crazy_closure(), (84, 10, 10));\n+    assert_eq!(closure_arg_adjustment_problem(), 3);\n+    assert_eq!(fn_once_closure_with_multiple_args(), 6);\n }"}, {"sha": "3b447f36ece1ef270bf8daf6741ff085b6ae91d9", "filename": "tests/run-pass/try-operator-custom.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/07b8500505e31d8a5e8afe56bcee5d2827697c79/tests%2Frun-pass%2Ftry-operator-custom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b8500505e31d8a5e8afe56bcee5d2827697c79/tests%2Frun-pass%2Ftry-operator-custom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftry-operator-custom.rs?ref=07b8500505e31d8a5e8afe56bcee5d2827697c79", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    assert!(Ok::<i32, String>(42) == Ok(42));\n+}"}]}