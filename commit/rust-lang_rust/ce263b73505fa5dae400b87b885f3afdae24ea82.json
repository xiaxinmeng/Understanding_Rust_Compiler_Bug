{"sha": "ce263b73505fa5dae400b87b885f3afdae24ea82", "node_id": "C_kwDOAAsO6NoAKGNlMjYzYjczNTA1ZmE1ZGFlNDAwYjg3Yjg4NWYzYWZkYWUyNGVhODI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-15T00:40:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-15T00:40:47Z"}, "message": "Rollup merge of #104422 - compiler-errors:fix-suggest_associated_call_syntax, r=BoxyUwU\n\nFix suggest associated call syntax\n\nFixes #104412", "tree": {"sha": "2660a8585144c4da85c431db324ab6584b773842", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2660a8585144c4da85c431db324ab6584b773842"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce263b73505fa5dae400b87b885f3afdae24ea82", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjcuAPCRBK7hj4Ov3rIwAAKL4IAD0Y/VbxiANQhuFfWzq7AI4Z\nFZaScuH09HR/giYqHNLiY6VU0GICBiNdxYlWxJrkKS2pQLb+KH3vHY+pvqq0FxXy\nxyqo8hC1KyoKFCHXBlvJ35yPSGt7zGrnZlp3NNj3Ez3XtEdHSCHCbrOTytW59fKV\nURTSjziDA2yI4roUtrvuSx7pJxNfb5HwIeyCa38AjkYQgJQ8q2FzWe36s3mjvC2a\nFxwNbhndvOeeMtYyd3GQj09fOLW4ASaZieZn2yijPizKJSp2efS+wgEQf6rhjGjV\nIWcn0tp2bai6dO715xmdKpD+d775B+xkBsRfZncmB28l+BcO6jBfJeOF0EgxUIc=\n=0UAP\n-----END PGP SIGNATURE-----\n", "payload": "tree 2660a8585144c4da85c431db324ab6584b773842\nparent 5e753ca2b28c3854cb797b580becad8d3ce264ea\nparent 540e12f7daddec4581c5ff0f89c0172cc5005422\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1668472847 +0100\ncommitter GitHub <noreply@github.com> 1668472847 +0100\n\nRollup merge of #104422 - compiler-errors:fix-suggest_associated_call_syntax, r=BoxyUwU\n\nFix suggest associated call syntax\n\nFixes #104412\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce263b73505fa5dae400b87b885f3afdae24ea82", "html_url": "https://github.com/rust-lang/rust/commit/ce263b73505fa5dae400b87b885f3afdae24ea82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce263b73505fa5dae400b87b885f3afdae24ea82/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e753ca2b28c3854cb797b580becad8d3ce264ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e753ca2b28c3854cb797b580becad8d3ce264ea", "html_url": "https://github.com/rust-lang/rust/commit/5e753ca2b28c3854cb797b580becad8d3ce264ea"}, {"sha": "540e12f7daddec4581c5ff0f89c0172cc5005422", "url": "https://api.github.com/repos/rust-lang/rust/commits/540e12f7daddec4581c5ff0f89c0172cc5005422", "html_url": "https://github.com/rust-lang/rust/commit/540e12f7daddec4581c5ff0f89c0172cc5005422"}], "stats": {"total": 384, "additions": 239, "deletions": 145}, "files": [{"sha": "edfe12963dc635adaa85b413d0fe441c8b4e73e9", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 171, "deletions": 145, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/ce263b73505fa5dae400b87b885f3afdae24ea82/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce263b73505fa5dae400b87b885f3afdae24ea82/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=ce263b73505fa5dae400b87b885f3afdae24ea82", "patch": "@@ -20,11 +20,10 @@ use rustc_infer::infer::{\n };\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::traits::util::supertraits;\n+use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::with_crate_prefix;\n-use rustc_middle::ty::{\n-    self, DefIdTree, GenericArg, GenericArgKind, ToPredicate, Ty, TyCtxt, TypeVisitable,\n-};\n+use rustc_middle::ty::{self, DefIdTree, GenericArgKind, ToPredicate, Ty, TyCtxt, TypeVisitable};\n use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n@@ -263,15 +262,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }) => {\n                 let tcx = self.tcx;\n \n-                let actual = self.resolve_vars_if_possible(rcvr_ty);\n-                let ty_str = self.ty_to_string(actual);\n+                let rcvr_ty = self.resolve_vars_if_possible(rcvr_ty);\n+                let ty_str = self.ty_to_string(rcvr_ty);\n                 let is_method = mode == Mode::MethodCall;\n                 let item_kind = if is_method {\n                     \"method\"\n-                } else if actual.is_enum() {\n+                } else if rcvr_ty.is_enum() {\n                     \"variant or associated item\"\n                 } else {\n-                    match (item_name.as_str().chars().next(), actual.is_fresh_ty()) {\n+                    match (item_name.as_str().chars().next(), rcvr_ty.is_fresh_ty()) {\n                         (Some(name), false) if name.is_lowercase() => \"function or associated item\",\n                         (Some(_), false) => \"associated item\",\n                         (Some(_), true) | (None, false) => \"variant or associated item\",\n@@ -280,19 +279,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n \n                 if self.suggest_wrapping_range_with_parens(\n-                    tcx, actual, source, span, item_name, &ty_str,\n+                    tcx, rcvr_ty, source, span, item_name, &ty_str,\n                 ) || self.suggest_constraining_numerical_ty(\n-                    tcx, actual, source, span, item_kind, item_name, &ty_str,\n+                    tcx, rcvr_ty, source, span, item_kind, item_name, &ty_str,\n                 ) {\n                     return None;\n                 }\n                 span = item_name.span;\n \n                 // Don't show generic arguments when the method can't be found in any implementation (#81576).\n                 let mut ty_str_reported = ty_str.clone();\n-                if let ty::Adt(_, generics) = actual.kind() {\n+                if let ty::Adt(_, generics) = rcvr_ty.kind() {\n                     if generics.len() > 0 {\n-                        let mut autoderef = self.autoderef(span, actual);\n+                        let mut autoderef = self.autoderef(span, rcvr_ty);\n                         let candidate_found = autoderef.any(|(ty, _)| {\n                             if let ty::Adt(adt_def, _) = ty.kind() {\n                                 self.tcx\n@@ -321,16 +320,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     \"no {} named `{}` found for {} `{}` in the current scope\",\n                     item_kind,\n                     item_name,\n-                    actual.prefix_string(self.tcx),\n+                    rcvr_ty.prefix_string(self.tcx),\n                     ty_str_reported,\n                 );\n-                if actual.references_error() {\n+                if rcvr_ty.references_error() {\n                     err.downgrade_to_delayed_bug();\n                 }\n \n                 if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n                     self.suggest_await_before_method(\n-                        &mut err, item_name, actual, cal, span,\n+                        &mut err, item_name, rcvr_ty, cal, span,\n                     );\n                 }\n                 if let Some(span) = tcx.resolutions(()).confused_type_with_std_module.get(&span) {\n@@ -341,7 +340,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Applicability::MachineApplicable,\n                     );\n                 }\n-                if let ty::RawPtr(_) = &actual.kind() {\n+                if let ty::RawPtr(_) = &rcvr_ty.kind() {\n                     err.note(\n                         \"try using `<*const T>::as_ref()` to get a reference to the \\\n                          type behind the pointer: https://doc.rust-lang.org/std/\\\n@@ -353,7 +352,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 }\n \n-                let ty_span = match actual.kind() {\n+                let ty_span = match rcvr_ty.kind() {\n                     ty::Param(param_type) => Some(\n                         param_type.span_from_generics(self.tcx, self.body_id.owner.to_def_id()),\n                     ),\n@@ -365,7 +364,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         span,\n                         format!(\n                             \"{item_kind} `{item_name}` not found for this {}\",\n-                            actual.prefix_string(self.tcx)\n+                            rcvr_ty.prefix_string(self.tcx)\n                         ),\n                     );\n                 }\n@@ -398,122 +397,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     custom_span_label = true;\n                 }\n                 if static_candidates.len() == 1 {\n-                    let mut has_unsuggestable_args = false;\n-                    let ty_str = if let Some(CandidateSource::Impl(impl_did)) =\n-                        static_candidates.get(0)\n-                    {\n-                        // When the \"method\" is resolved through dereferencing, we really want the\n-                        // original type that has the associated function for accurate suggestions.\n-                        // (#61411)\n-                        let ty = tcx.at(span).type_of(*impl_did);\n-                        match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n-                            (ty::Adt(def, _), ty::Adt(def_actual, substs)) if def == def_actual => {\n-                                // If there are any inferred arguments, (`{integer}`), we should replace\n-                                // them with underscores to allow the compiler to infer them\n-                                let infer_substs: Vec<GenericArg<'_>> = substs\n-                                    .into_iter()\n-                                    .map(|arg| {\n-                                        if !arg.is_suggestable(tcx, true) {\n-                                            has_unsuggestable_args = true;\n-                                            match arg.unpack() {\n-                                            GenericArgKind::Lifetime(_) => self\n-                                                .next_region_var(RegionVariableOrigin::MiscVariable(\n-                                                    rustc_span::DUMMY_SP,\n-                                                ))\n-                                                .into(),\n-                                            GenericArgKind::Type(_) => self\n-                                                .next_ty_var(TypeVariableOrigin {\n-                                                    span: rustc_span::DUMMY_SP,\n-                                                    kind: TypeVariableOriginKind::MiscVariable,\n-                                                })\n-                                                .into(),\n-                                            GenericArgKind::Const(arg) => self\n-                                                .next_const_var(\n-                                                    arg.ty(),\n-                                                    ConstVariableOrigin {\n-                                                        span: rustc_span::DUMMY_SP,\n-                                                        kind: ConstVariableOriginKind::MiscVariable,\n-                                                    },\n-                                                )\n-                                                .into(),\n-                                            }\n-                                        } else {\n-                                            arg\n-                                        }\n-                                    })\n-                                    .collect::<Vec<_>>();\n-\n-                                tcx.value_path_str_with_substs(\n-                                    def_actual.did(),\n-                                    tcx.intern_substs(&infer_substs),\n-                                )\n-                            }\n-                            _ => self.ty_to_value_string(ty.peel_refs()),\n-                        }\n-                    } else {\n-                        self.ty_to_value_string(actual.peel_refs())\n-                    };\n-                    if let SelfSource::MethodCall(_) = source {\n-                        let first_arg = if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) &&\n-                            let Some(assoc) = self.associated_value(*impl_did, item_name) {\n-                            let sig = self.tcx.fn_sig(assoc.def_id);\n-                            if let Some(first) = sig.inputs().skip_binder().get(0) {\n-                                if first.peel_refs() == rcvr_ty.peel_refs() {\n-                                    None\n-                                } else {\n-                                    Some(if first.is_region_ptr() {\n-                                        if first.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n-                                    } else {\n-                                        \"\"\n-                                    })\n-                                }\n-                            } else {\n-                                None\n-                            }\n-                        } else {\n-                            None\n-                        };\n-                        let mut applicability = Applicability::MachineApplicable;\n-                        let args = if let Some((receiver, args)) = args {\n-                            // The first arg is the same kind as the receiver\n-                            let explicit_args = if first_arg.is_some() {\n-                                std::iter::once(receiver).chain(args.iter()).collect::<Vec<_>>()\n-                            } else {\n-                                // There is no `Self` kind to infer the arguments from\n-                                if has_unsuggestable_args {\n-                                    applicability = Applicability::HasPlaceholders;\n-                                }\n-                                args.iter().collect()\n-                            };\n-                            format!(\n-                                \"({}{})\",\n-                                first_arg.unwrap_or(\"\"),\n-                                explicit_args\n-                                    .iter()\n-                                    .map(|arg| tcx\n-                                        .sess\n-                                        .source_map()\n-                                        .span_to_snippet(arg.span)\n-                                        .unwrap_or_else(|_| {\n-                                            applicability = Applicability::HasPlaceholders;\n-                                            \"_\".to_owned()\n-                                        }))\n-                                    .collect::<Vec<_>>()\n-                                    .join(\", \"),\n-                            )\n-                        } else {\n-                            applicability = Applicability::HasPlaceholders;\n-                            \"(...)\".to_owned()\n-                        };\n-                        err.span_suggestion(\n-                            sugg_span,\n-                            \"use associated function syntax instead\",\n-                            format!(\"{}::{}{}\", ty_str, item_name, args),\n-                            applicability,\n-                        );\n-                    } else {\n-                        err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));\n-                    }\n+                    self.suggest_associated_call_syntax(\n+                        &mut err,\n+                        &static_candidates,\n+                        rcvr_ty,\n+                        source,\n+                        item_name,\n+                        args,\n+                        sugg_span,\n+                    );\n \n                     report_candidates(span, &mut err, &mut static_candidates, sugg_span);\n                 } else if static_candidates.len() > 1 {\n@@ -523,7 +415,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut bound_spans = vec![];\n                 let mut restrict_type_params = false;\n                 let mut unsatisfied_bounds = false;\n-                if item_name.name == sym::count && self.is_slice_ty(actual, span) {\n+                if item_name.name == sym::count && self.is_slice_ty(rcvr_ty, span) {\n                     let msg = \"consider using `len` instead\";\n                     if let SelfSource::MethodCall(_expr) = source {\n                         err.span_suggestion_short(\n@@ -537,7 +429,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     if let Some(iterator_trait) = self.tcx.get_diagnostic_item(sym::Iterator) {\n                         let iterator_trait = self.tcx.def_path_str(iterator_trait);\n-                        err.note(&format!(\"`count` is defined on `{iterator_trait}`, which `{actual}` does not implement\"));\n+                        err.note(&format!(\"`count` is defined on `{iterator_trait}`, which `{rcvr_ty}` does not implement\"));\n                     }\n                 } else if !unsatisfied_predicates.is_empty() {\n                     let mut type_params = FxHashMap::default();\n@@ -876,7 +768,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .map(|(_, path)| path)\n                             .collect::<Vec<_>>()\n                             .join(\"\\n\");\n-                        let actual_prefix = actual.prefix_string(self.tcx);\n+                        let actual_prefix = rcvr_ty.prefix_string(self.tcx);\n                         info!(\"unimplemented_traits.len() == {}\", unimplemented_traits.len());\n                         let (primary_message, label) =\n                             if unimplemented_traits.len() == 1 && unimplemented_traits_only {\n@@ -885,7 +777,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     .next()\n                                     .map(|(_, (trait_ref, obligation))| {\n                                         if trait_ref.self_ty().references_error()\n-                                            || actual.references_error()\n+                                            || rcvr_ty.references_error()\n                                         {\n                                             // Avoid crashing.\n                                             return (None, None);\n@@ -921,7 +813,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let label_span_not_found = |err: &mut Diagnostic| {\n                     if unsatisfied_predicates.is_empty() {\n                         err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n-                        let is_string_or_ref_str = match actual.kind() {\n+                        let is_string_or_ref_str = match rcvr_ty.kind() {\n                             ty::Ref(_, ty, _) => {\n                                 ty.is_str()\n                                     || matches!(\n@@ -957,7 +849,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                 // different from the received one\n                                                 // So we avoid suggestion method with Box<Self>\n                                                 // for instance\n-                                                self.tcx.at(span).type_of(*def_id) != actual\n+                                                self.tcx.at(span).type_of(*def_id) != rcvr_ty\n                                                     && self.tcx.at(span).type_of(*def_id) != rcvr_ty\n                                             }\n                                             (Mode::Path, false, _) => true,\n@@ -1017,18 +909,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Don't suggest (for example) `expr.field.clone()` if `expr.clone()`\n                 // can't be called due to `typeof(expr): Clone` not holding.\n                 if unsatisfied_predicates.is_empty() {\n-                    self.suggest_calling_method_on_field(&mut err, source, span, actual, item_name);\n+                    self.suggest_calling_method_on_field(\n+                        &mut err, source, span, rcvr_ty, item_name,\n+                    );\n                 }\n \n-                self.check_for_inner_self(&mut err, source, span, actual, item_name);\n+                self.check_for_inner_self(&mut err, source, span, rcvr_ty, item_name);\n \n                 bound_spans.sort();\n                 bound_spans.dedup();\n                 for (span, msg) in bound_spans.into_iter() {\n                     err.span_label(span, &msg);\n                 }\n \n-                if actual.is_numeric() && actual.is_fresh() || restrict_type_params {\n+                if rcvr_ty.is_numeric() && rcvr_ty.is_fresh() || restrict_type_params {\n                 } else {\n                     self.suggest_traits_to_import(\n                         &mut err,\n@@ -1046,8 +940,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 // Don't emit a suggestion if we found an actual method\n                 // that had unsatisfied trait bounds\n-                if unsatisfied_predicates.is_empty() && actual.is_enum() {\n-                    let adt_def = actual.ty_adt_def().expect(\"enum is not an ADT\");\n+                if unsatisfied_predicates.is_empty() && rcvr_ty.is_enum() {\n+                    let adt_def = rcvr_ty.ty_adt_def().expect(\"enum is not an ADT\");\n                     if let Some(suggestion) = lev_distance::find_best_match_for_name(\n                         &adt_def.variants().iter().map(|s| s.name).collect::<Vec<_>>(),\n                         item_name.name,\n@@ -1062,7 +956,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                if item_name.name == sym::as_str && actual.peel_refs().is_str() {\n+                if item_name.name == sym::as_str && rcvr_ty.peel_refs().is_str() {\n                     let msg = \"remove this method call\";\n                     let mut fallback_span = true;\n                     if let SelfSource::MethodCall(expr) = source {\n@@ -1178,6 +1072,138 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n+    /// Suggest calling `Ty::method` if `.method()` isn't found because the method\n+    /// doesn't take a `self` receiver.\n+    fn suggest_associated_call_syntax(\n+        &self,\n+        err: &mut Diagnostic,\n+        static_candidates: &Vec<CandidateSource>,\n+        rcvr_ty: Ty<'tcx>,\n+        source: SelfSource<'tcx>,\n+        item_name: Ident,\n+        args: Option<(&hir::Expr<'tcx>, &[hir::Expr<'tcx>])>,\n+        sugg_span: Span,\n+    ) {\n+        let mut has_unsuggestable_args = false;\n+        let ty_str = if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) {\n+            // When the \"method\" is resolved through dereferencing, we really want the\n+            // original type that has the associated function for accurate suggestions.\n+            // (#61411)\n+            let impl_ty = self.tcx.type_of(*impl_did);\n+            let target_ty = self\n+                .autoderef(sugg_span, rcvr_ty)\n+                .find(|(rcvr_ty, _)| {\n+                    DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer }\n+                        .types_may_unify(*rcvr_ty, impl_ty)\n+                })\n+                .map_or(impl_ty, |(ty, _)| ty)\n+                .peel_refs();\n+            if let ty::Adt(def, substs) = target_ty.kind() {\n+                // If there are any inferred arguments, (`{integer}`), we should replace\n+                // them with underscores to allow the compiler to infer them\n+                let infer_substs = self.tcx.mk_substs(substs.into_iter().map(|arg| {\n+                    if !arg.is_suggestable(self.tcx, true) {\n+                        has_unsuggestable_args = true;\n+                        match arg.unpack() {\n+                            GenericArgKind::Lifetime(_) => self\n+                                .next_region_var(RegionVariableOrigin::MiscVariable(\n+                                    rustc_span::DUMMY_SP,\n+                                ))\n+                                .into(),\n+                            GenericArgKind::Type(_) => self\n+                                .next_ty_var(TypeVariableOrigin {\n+                                    span: rustc_span::DUMMY_SP,\n+                                    kind: TypeVariableOriginKind::MiscVariable,\n+                                })\n+                                .into(),\n+                            GenericArgKind::Const(arg) => self\n+                                .next_const_var(\n+                                    arg.ty(),\n+                                    ConstVariableOrigin {\n+                                        span: rustc_span::DUMMY_SP,\n+                                        kind: ConstVariableOriginKind::MiscVariable,\n+                                    },\n+                                )\n+                                .into(),\n+                        }\n+                    } else {\n+                        arg\n+                    }\n+                }));\n+\n+                self.tcx.value_path_str_with_substs(def.did(), infer_substs)\n+            } else {\n+                self.ty_to_value_string(target_ty)\n+            }\n+        } else {\n+            self.ty_to_value_string(rcvr_ty.peel_refs())\n+        };\n+        if let SelfSource::MethodCall(_) = source {\n+            let first_arg = if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0)\n+                && let Some(assoc) = self.associated_value(*impl_did, item_name)\n+                && assoc.kind == ty::AssocKind::Fn\n+            {\n+                let sig = self.tcx.fn_sig(assoc.def_id);\n+                if let Some(first) = sig.inputs().skip_binder().get(0) {\n+                    if first.peel_refs() == rcvr_ty.peel_refs() {\n+                        None\n+                    } else {\n+                        Some(if first.is_region_ptr() {\n+                            if first.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n+                        } else {\n+                            \"\"\n+                        })\n+                    }\n+                } else {\n+                    None\n+                }\n+            } else {\n+                None\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            let args = if let Some((receiver, args)) = args {\n+                // The first arg is the same kind as the receiver\n+                let explicit_args = if first_arg.is_some() {\n+                    std::iter::once(receiver).chain(args.iter()).collect::<Vec<_>>()\n+                } else {\n+                    // There is no `Self` kind to infer the arguments from\n+                    if has_unsuggestable_args {\n+                        applicability = Applicability::HasPlaceholders;\n+                    }\n+                    args.iter().collect()\n+                };\n+                format!(\n+                    \"({}{})\",\n+                    first_arg.unwrap_or(\"\"),\n+                    explicit_args\n+                        .iter()\n+                        .map(|arg| self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(arg.span)\n+                            .unwrap_or_else(|_| {\n+                                applicability = Applicability::HasPlaceholders;\n+                                \"_\".to_owned()\n+                            }))\n+                        .collect::<Vec<_>>()\n+                        .join(\", \"),\n+                )\n+            } else {\n+                applicability = Applicability::HasPlaceholders;\n+                \"(...)\".to_owned()\n+            };\n+            err.span_suggestion(\n+                sugg_span,\n+                \"use associated function syntax instead\",\n+                format!(\"{}::{}{}\", ty_str, item_name, args),\n+                applicability,\n+            );\n+        } else {\n+            err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));\n+        }\n+    }\n+\n     /// Suggest calling a field with a type that implements the `Fn*` traits instead of a method with\n     /// the same name as the field i.e. `(a.my_fn_ptr)(10)` instead of `a.my_fn_ptr(10)`.\n     fn suggest_calling_field_as_fn("}, {"sha": "06cf243f1b4fa9293e4469bb5f58921880e03ec7", "filename": "src/test/ui/suggestions/dont-suggest-ufcs-for-const.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce263b73505fa5dae400b87b885f3afdae24ea82/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce263b73505fa5dae400b87b885f3afdae24ea82/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.rs?ref=ce263b73505fa5dae400b87b885f3afdae24ea82", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    1_u32.MAX();\n+    //~^ ERROR no method named `MAX` found for type `u32` in the current scope\n+}"}, {"sha": "04e0511d788ed160de56b1f6f05689d2527d315d", "filename": "src/test/ui/suggestions/dont-suggest-ufcs-for-const.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce263b73505fa5dae400b87b885f3afdae24ea82/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce263b73505fa5dae400b87b885f3afdae24ea82/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.stderr?ref=ce263b73505fa5dae400b87b885f3afdae24ea82", "patch": "@@ -0,0 +1,15 @@\n+error[E0599]: no method named `MAX` found for type `u32` in the current scope\n+  --> $DIR/dont-suggest-ufcs-for-const.rs:2:11\n+   |\n+LL |     1_u32.MAX();\n+   |     ------^^^--\n+   |     |     |\n+   |     |     this is an associated function, not a method\n+   |     help: use associated function syntax instead: `u32::MAX()`\n+   |\n+   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n+   = note: the candidate is defined in an impl for the type `u32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "8d96cf590c39881580492456617070a236e5bc5e", "filename": "src/test/ui/suggestions/suggest-assoc-fn-call-deref.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce263b73505fa5dae400b87b885f3afdae24ea82/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ce263b73505fa5dae400b87b885f3afdae24ea82/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.fixed?ref=ce263b73505fa5dae400b87b885f3afdae24ea82", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+struct Foo<T>(T);\n+\n+impl<T> Foo<T> {\n+    fn test() -> i32 { 1 }\n+}\n+\n+fn main() {\n+    let x = Box::new(Foo(1i32));\n+    Foo::<i32>::test();\n+    //~^ ERROR no method named `test` found for struct `Box<Foo<i32>>` in the current scope\n+}"}, {"sha": "186901f75a84ba992527e5026ca23624991c51dd", "filename": "src/test/ui/suggestions/suggest-assoc-fn-call-deref.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce263b73505fa5dae400b87b885f3afdae24ea82/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce263b73505fa5dae400b87b885f3afdae24ea82/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.rs?ref=ce263b73505fa5dae400b87b885f3afdae24ea82", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+struct Foo<T>(T);\n+\n+impl<T> Foo<T> {\n+    fn test() -> i32 { 1 }\n+}\n+\n+fn main() {\n+    let x = Box::new(Foo(1i32));\n+    x.test();\n+    //~^ ERROR no method named `test` found for struct `Box<Foo<i32>>` in the current scope\n+}"}, {"sha": "00fb96f032668087dd2385c471c38f5b5b1f4a8a", "filename": "src/test/ui/suggestions/suggest-assoc-fn-call-deref.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ce263b73505fa5dae400b87b885f3afdae24ea82/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce263b73505fa5dae400b87b885f3afdae24ea82/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.stderr?ref=ce263b73505fa5dae400b87b885f3afdae24ea82", "patch": "@@ -0,0 +1,19 @@\n+error[E0599]: no method named `test` found for struct `Box<Foo<i32>>` in the current scope\n+  --> $DIR/suggest-assoc-fn-call-deref.rs:13:7\n+   |\n+LL |     x.test();\n+   |     --^^^^--\n+   |     | |\n+   |     | this is an associated function, not a method\n+   |     help: use associated function syntax instead: `Foo::<i32>::test()`\n+   |\n+   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n+note: the candidate is defined in an impl for the type `Foo<T>`\n+  --> $DIR/suggest-assoc-fn-call-deref.rs:8:5\n+   |\n+LL |     fn test() -> i32 { 1 }\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}]}