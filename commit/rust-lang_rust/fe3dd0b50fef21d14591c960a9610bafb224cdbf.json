{"sha": "fe3dd0b50fef21d14591c960a9610bafb224cdbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlM2RkMGI1MGZlZjIxZDE0NTkxYzk2MGE5NjEwYmFmYjIyNGNkYmY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-05-21T22:37:07Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-05-21T22:37:07Z"}, "message": "Merge remote-tracking branch 'origin/master' into azure-pipelines", "tree": {"sha": "ee0b62d8e500d4ce4b6f50b4fe5d9056b9826072", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee0b62d8e500d4ce4b6f50b4fe5d9056b9826072"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe3dd0b50fef21d14591c960a9610bafb224cdbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe3dd0b50fef21d14591c960a9610bafb224cdbf", "html_url": "https://github.com/rust-lang/rust/commit/fe3dd0b50fef21d14591c960a9610bafb224cdbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe3dd0b50fef21d14591c960a9610bafb224cdbf/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e764f475ca7fffd6167ea991afc7d1b2b3f642dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e764f475ca7fffd6167ea991afc7d1b2b3f642dc", "html_url": "https://github.com/rust-lang/rust/commit/e764f475ca7fffd6167ea991afc7d1b2b3f642dc"}, {"sha": "50a0defd5a93523067ef239936cc2e0755220904", "url": "https://api.github.com/repos/rust-lang/rust/commits/50a0defd5a93523067ef239936cc2e0755220904", "html_url": "https://github.com/rust-lang/rust/commit/50a0defd5a93523067ef239936cc2e0755220904"}], "stats": {"total": 22111, "additions": 14612, "deletions": 7499}, "files": [{"sha": "63a49cd413287437a4f57c13ec5479d330d6438f", "filename": ".mailmap", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -155,6 +155,8 @@ Mark Sinclair <mark.edward.x@gmail.com> =Mark Sinclair <=125axel125@gmail.com>\n Markus Westerlind <marwes91@gmail.com> Markus <marwes91@gmail.com>\n Martin Hafskjold Thoresen <martinhath@gmail.com>\n Matej Lach <matej.lach@gmail.com> Matej \u013dach <matej.lach@gmail.com>\n+Mateusz Miku\u0142a <matti@marinelayer.io> <mati865@gmail.com>\n+Mateusz Miku\u0142a <matti@marinelayer.io> <mati865@users.noreply.github.com>\n Matt Brubeck <mbrubeck@limpet.net> <mbrubeck@cs.hmc.edu>\n Matthew Auld <matthew.auld@intel.com>\n Matthew McPherrin <matthew@mcpherrin.ca> <matt@mcpherrin.ca>"}, {"sha": "db9f0069ced0c1c41f107d2625a618fdc23944d9", "filename": "Cargo.lock", "status": "modified", "additions": 92, "deletions": 79, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -13,11 +13,19 @@ dependencies = [\n  \"memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"aho-corasick\"\n+version = \"0.7.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"alloc\"\n version = \"0.0.0\"\n dependencies = [\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_xorshift 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -115,7 +123,7 @@ version = \"0.1.27\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n@@ -181,6 +189,14 @@ dependencies = [\n  \"toml 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"bstr\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"bufstream\"\n version = \"0.1.4\"\n@@ -246,7 +262,7 @@ dependencies = [\n  \"clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core-foundation 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crates-io 0.25.0\",\n- \"crossbeam-utils 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crypto-hash 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl 0.4.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl-sys 0.4.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -261,7 +277,7 @@ dependencies = [\n  \"glob 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hex 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"home 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ignore 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ignore 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"im-rc 12.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -373,12 +389,11 @@ dependencies = [\n  \"compiletest_rs 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"derive-new 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-workspace-hack 1.0.0\",\n  \"rustc_tools_util 0.1.1\",\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -396,10 +411,9 @@ dependencies = [\n  \"matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-normalization 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -448,7 +462,7 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.12\"\n+version = \"0.1.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -461,13 +475,12 @@ version = \"0.0.0\"\n dependencies = [\n  \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"filetime 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miow 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustfix 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -486,7 +499,7 @@ dependencies = [\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miow 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustfix 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -553,13 +566,10 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.3.4\"\n+version = \"0.3.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"crossbeam-epoch 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"crossbeam-utils 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -578,7 +588,7 @@ version = \"0.6.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-epoch 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"crossbeam-utils 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -602,7 +612,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"crossbeam-utils 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -618,10 +628,11 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-utils\"\n-version = \"0.6.2\"\n+version = \"0.6.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -733,7 +744,7 @@ name = \"dlmalloc\"\n version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n@@ -749,7 +760,7 @@ version = \"2.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -781,7 +792,7 @@ dependencies = [\n  \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"humantime 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"termcolor 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -793,7 +804,7 @@ dependencies = [\n  \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"humantime 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"termcolor 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -899,7 +910,7 @@ name = \"fortanix-sgx-abi\"\n version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n \n@@ -1010,14 +1021,14 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"globset\"\n-version = \"0.4.2\"\n+version = \"0.4.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"aho-corasick 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"aho-corasick 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"bstr 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1034,7 +1045,7 @@ dependencies = [\n  \"pest 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1049,7 +1060,7 @@ dependencies = [\n  \"pest 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest_derive 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1060,7 +1071,7 @@ name = \"hashbrown\"\n version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-alloc 1.0.0\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n@@ -1135,19 +1146,19 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"ignore\"\n-version = \"0.4.6\"\n+version = \"0.4.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"crossbeam-channel 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"globset 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"globset 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"same-file 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-util 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1471,7 +1482,7 @@ dependencies = [\n  \"memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"open 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1483,7 +1494,7 @@ dependencies = [\n \n [[package]]\n name = \"measureme\"\n-version = \"0.2.1\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1761,7 +1772,7 @@ dependencies = [\n name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1771,7 +1782,7 @@ name = \"panic_unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unwind 0.0.0\",\n@@ -1956,7 +1967,7 @@ name = \"profiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -1974,7 +1985,7 @@ dependencies = [\n  \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_chacha 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_xorshift 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rusty-fork 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -2182,12 +2193,12 @@ dependencies = [\n \n [[package]]\n name = \"regex\"\n-version = \"1.1.0\"\n+version = \"1.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"aho-corasick 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"aho-corasick 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"utf8-ranges 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -2202,7 +2213,7 @@ dependencies = [\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.6.4\"\n+version = \"0.6.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"ucd-util 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2231,7 +2242,7 @@ dependencies = [\n  \"cargo 0.37.0\",\n  \"cargo_metadata 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"clippy_lints 0.0.212\",\n- \"crossbeam-channel 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2249,7 +2260,7 @@ dependencies = [\n  \"racer 2.1.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rayon 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-analysis 0.17.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-blacklist 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-data 0.19.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2348,7 +2359,7 @@ dependencies = [\n  \"jobserver 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"measureme 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"measureme 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"polonius-engine 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2481,7 +2492,7 @@ name = \"rustc-demangle\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n \n@@ -2609,7 +2620,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -2839,7 +2850,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -2901,7 +2912,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -3018,7 +3029,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -3092,11 +3103,11 @@ dependencies = [\n  \"env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ignore 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ignore 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-rustc_target 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-syntax 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-syntax_pos 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3132,7 +3143,7 @@ name = \"same-file\"\n version = \"1.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"winapi-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-util 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3287,7 +3298,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"backtrace-sys 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"dlmalloc 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fortanix-sgx-abi 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3553,7 +3564,7 @@ dependencies = [\n name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -3614,7 +3625,7 @@ name = \"tokio-executor\"\n version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"crossbeam-utils 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -3658,7 +3669,7 @@ name = \"tokio-reactor\"\n version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"crossbeam-utils 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3704,9 +3715,9 @@ name = \"tokio-threadpool\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"crossbeam-channel 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crossbeam-deque 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"crossbeam-utils 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3719,7 +3730,7 @@ name = \"tokio-timer\"\n version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"crossbeam-utils 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tokio-executor 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3792,7 +3803,7 @@ dependencies = [\n  \"error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"is-match 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -3878,7 +3889,7 @@ name = \"unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -3957,7 +3968,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"same-file 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-util 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3986,7 +3997,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"winapi-util\"\n-version = \"0.1.1\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -4003,7 +4014,7 @@ version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-util 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -4039,6 +4050,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [metadata]\n \"checksum adler32 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e522997b529f05601e05166c07ed17789691f562762c7f3b987263d2dedee5c\"\n \"checksum aho-corasick 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1e9a933f4e58658d7b12defcf96dc5c720f20832deebe3e0a19efd3b6aaeeb9e\"\n+\"checksum aho-corasick 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e6f484ae0c99fec2e858eb6134949117399f222608d84cadb3f58c1f97c2364c\"\n \"checksum ammonia 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fd4c682378117e4186a492b2252b9537990e1617f44aed9788b9a1149de45477\"\n \"checksum annotate-snippets 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8bcdcd5b291ce85a78f2b9d082a8de9676c12b1840d386d67bc5eea6f9d2b4e\"\n \"checksum ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n@@ -4055,6 +4067,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"228047a76f468627ca71776ecdebd732a3423081fcf5125585bcd7c49886ce12\"\n \"checksum blake2-rfc 0.2.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d6d530bdd2d52966a6d03b7a964add7ae1a288d25214066fd4b600f0f796400\"\n \"checksum block-buffer 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a076c298b9ecdb530ed9d967e74a6027d6a7478924520acddcddc24c1c8ab3ab\"\n+\"checksum bstr 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"853b090ce0f45d0265902666bf88039ea3da825e33796716c511a1ec9c170036\"\n \"checksum bufstream 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40e38929add23cdf8a366df9b0e088953150724bcbe5fc330b0d8eb3b328eec8\"\n \"checksum build_const 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"39092a32794787acd8525ee150305ff051b0aa6cc2abaf193924f5ab05425f39\"\n \"checksum byte-tools 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"560c32574a12a89ecd91f5e742165893f86e3ab98d21f8ea548658eb9eef5f40\"\n@@ -4074,20 +4087,20 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum colored 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b0aa3473e85a3161b59845d6096b289bb577874cafeaf75ea1b1beaa6572c7fc\"\n \"checksum commoncrypto 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d056a8586ba25a1e4d61cb090900e495952c7886786fc55f909ab2f819b69007\"\n \"checksum commoncrypto-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1fed34f46747aa73dfaa578069fd8279d2818ade2b55f38f22a9401c7f4083e2\"\n-\"checksum compiler_builtins 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6549720ae78db799196d4af8f719facb4c7946710b4b64148482553e54b56d15\"\n+\"checksum compiler_builtins 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e3f235c329e5cb9fa3d2ca2cc36256ba9a7f23fa76e0f4db6f68c23b73b2ac69\"\n \"checksum compiletest_rs 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f40ecc9332b68270998995c00f8051ee856121764a0d3230e64c9efd059d27b6\"\n \"checksum constant_time_eq 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8ff012e225ce166d4422e0e78419d901719760f62ae2b7969ca6b564d1b54a9e\"\n \"checksum core-foundation 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4e2640d6d0bf22e82bed1b73c6aef8d5dd31e5abe6666c57e6d45e2649f4f887\"\n \"checksum core-foundation-sys 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e7ca8a5221364ef15ce201e8ed2f609fc312682a8f4e0e3d4aa5879764e0fa3b\"\n \"checksum crc 1.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d663548de7f5cca343f1e0a48d14dcfb0e9eb4e079ec58883b7251539fa10aeb\"\n \"checksum crc32fast 1.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e91d5240c6975ef33aeb5f148f35275c25eda8e8a5f95abe421978b05b8bf192\"\n-\"checksum crossbeam-channel 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5b2a9ea8f77c7f9efd317a8a5645f515d903a2d86ee14d2337a5facd1bd52c12\"\n+\"checksum crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0f0ed1a4de2235cabda8558ff5840bffb97fcb64c97827f354a451307df5f72b\"\n \"checksum crossbeam-deque 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f739f8c5363aca78cfb059edf753d8f0d36908c348f3d8d1503f03d8b75d9cf3\"\n \"checksum crossbeam-deque 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"05e44b8cf3e1a625844d1750e1f7820da46044ff6d28f4d43e455ba3e5bb2c13\"\n \"checksum crossbeam-epoch 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"927121f5407de9956180ff5e936fe3cf4324279280001cd56b669d28ee7e9150\"\n \"checksum crossbeam-epoch 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f10a4f8f409aaac4b16a5474fb233624238fcdeefb9ba50d5ea059aab63ba31c\"\n \"checksum crossbeam-utils 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2760899e32a1d58d5abb31129f8fae5de75220bc2176e77ff7c627ae45c918d9\"\n-\"checksum crossbeam-utils 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e07fc155212827475223f0bcfae57e945e694fc90950ddf3f6695bbfd5555c72\"\n+\"checksum crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f8306fcef4a7b563b76b7dd949ca48f52bc1141aa067d2ea09565f3e2652aa5c\"\n \"checksum crypto-hash 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09de9ee0fc255ace04c7fa0763c9395a945c37c8292bb554f8d48361d1dcf1b4\"\n \"checksum curl 0.4.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a85f2f95f2bd277d316d1aa8a477687ab4a6942258c7db7c89c187534669979c\"\n \"checksum curl-sys 0.4.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9d91a0052d5b982887d8e829bee0faffc7218ea3c6ebd3d6c2c8f678a93c9a42\"\n@@ -4131,7 +4144,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum git2 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c7339329bfa14a00223244311560d11f8f489b453fb90092af97f267a6090ab0\"\n \"checksum git2-curl 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d58551e903ed7e2d6fe3a2f3c7efa3a784ec29b19d0fbb035aaf0497c183fbdd\"\n \"checksum glob 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9b919933a397b79c37e33b77bb2aa3dc8eb6e165ad809e58ff75bc7db2e34574\"\n-\"checksum globset 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4743617a7464bbda3c8aec8558ff2f9429047e025771037df561d383337ff865\"\n+\"checksum globset 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef4feaabe24a0a658fd9cf4a9acf6ed284f045c77df0f49020ba3245cfb7b454\"\n \"checksum handlebars 0.32.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d89ec99d1594f285d4590fc32bac5f75cdab383f1123d504d27862c644a807dd\"\n \"checksum handlebars 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d82e5750d8027a97b9640e3fefa66bbaf852a35228e1c90790efd13c4b09c166\"\n \"checksum hashbrown 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"570178d5e4952010d138b0f1d581271ff3a02406d990f887d1e87e3d6e43b0ac\"\n@@ -4143,7 +4156,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum humantime 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ca7e5f2e110db35f93b837c81797f3714500b81d517bf20c431b16d3ca4f114\"\n \"checksum idna 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38f09e0f0b1fb55fdee1f17470ad800da77af5186a1a76c026b679358b7e844e\"\n \"checksum if_chain 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4bac95d9aa0624e7b78187d6fb8ab012b41d9f6f54b1bcb61e61c4845f8357ec\"\n-\"checksum ignore 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad03ca67dc12474ecd91fdb94d758cbd20cb4e7a78ebe831df26a9b7511e1162\"\n+\"checksum ignore 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8dc57fa12805f367736a38541ac1a9fc6a52812a0ca959b1d4d4b640a89eb002\"\n \"checksum im-rc 12.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9460397452f537fd51808056ff209f4c4c4c9d20d42ae952f517708726284972\"\n \"checksum iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbe6e417e7d0975db6512b90796e8ce223145ac4e33c377e4a42882a0e88bb08\"\n \"checksum is-match 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e5b386aef33a1c677be65237cb9d32c3f3ef56bd035949710c4bb13083eb053\"\n@@ -4176,7 +4189,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n \"checksum mdbook 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90b5a8d7e341ceee5db3882a06078d42661ddcfa2b3687319cc5da76ec4e782f\"\n \"checksum mdbook 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0ba0d44cb4089c741b9a91f3e5218298a40699c2f3a070a85014eed290c60819\"\n-\"checksum measureme 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36bb2b263a6795d352035024d6b30ce465bb79a5e5280d74c3b5f8464c657bcc\"\n+\"checksum measureme 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d09de7dafa3aa334bc806447c7e4de69419723312f4b88b80b561dea66601ce8\"\n \"checksum memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2efc7bc57c883d4a4d6e3246905283d8dae951bb3bd32f49d6ef297f546e1c39\"\n \"checksum memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2ffa2c986de11a9df78620c01eeaaf27d94d3ff02bf81bfcca953102dd0c6ff\"\n \"checksum memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0f9dc261e2b62d7a622bf416ea3c5245cdd5d9a7fcc428c0d06804dfce1775b3\"\n@@ -4249,9 +4262,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum redox_termios 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e891cfe48e9100a70a3b6eb652fef28920c117d366339687bd5576160db0f76\"\n \"checksum redox_users 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"214a97e49be64fd2c86f568dd0cb2c757d2cc53de95b273b6ad0a1c908482f26\"\n \"checksum regex 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9329abc99e39129fcceabd24cf5d85b4671ef7c29c50e972bc5afe32438ec384\"\n-\"checksum regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"37e7cbbd370869ce2e8dff25c7018702d10b21a20ef7135316f8daecd6c25b7f\"\n+\"checksum regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8f0a0bcab2fd7d1d7c54fa9eae6f43eddeb9ce2e7352f8518a814a4f65d60c58\"\n \"checksum regex-syntax 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7d707a4fa2637f2dca2ef9fd02225ec7661fe01a53623c1e6515b6916511f7a7\"\n-\"checksum regex-syntax 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4e47a2ed29da7a9e1960e1639e7a982e6edc6d49be308a3b02daf511504a16d1\"\n+\"checksum regex-syntax 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcfd8681eebe297b81d98498869d4aae052137651ad7b96822f09ceb690d0a96\"\n \"checksum remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3488ba1b9a2084d38645c4c08276a1752dcbf2c7130d74f1569681ad5d2799c5\"\n \"checksum rls-analysis 0.17.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d53d49a28f75da9d02790d9256fecf6c0481e0871374326023c7a33131295579\"\n \"checksum rls-blacklist 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b8ce1fdac03e138c4617ff87b194e1ff57a39bb985a044ccbd8673d30701e411\"\n@@ -4365,7 +4378,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"92c1eb33641e276cfa214a0522acad57be5c56b10cb348b3c5117db75f3ac4b0\"\n \"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\"\n \"checksum winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n-\"checksum winapi-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afc5508759c5bf4285e61feb862b6083c8480aec864fa17a81fdec6f69b461ab\"\n+\"checksum winapi-util 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7168bab6e1daee33b4557efd0e95d5ca70a03706d39fa5f3fe7a236f584b03c9\"\n \"checksum winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \"checksum wincolor 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"561ed901ae465d6185fa7864d63fbd5720d0ef718366c9a4dc83cf6170d7e9ba\"\n \"checksum ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d59cefebd0c892fa2dd6de581e937301d8552cb44489cdff035c6187cb63fa5e\""}, {"sha": "4a130d257770af0c5ac9e13dd373e07307c8dee8", "filename": "README.md", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -130,9 +130,15 @@ build.\n #### MSVC\n [windows-msvc]: #windows-msvc\n \n-MSVC builds of Rust additionally require an installation of Visual Studio 2013\n-(or later) so `rustc` can use its linker. Make sure to check the \u201cC++ tools\u201d\n-option.\n+MSVC builds of Rust additionally require an installation of Visual Studio 2017\n+(or later) so `rustc` can use its linker.  The simplest way is to get the\n+[Visual Studio Build Tools] and check the \u201cC++ build tools\u201d workload.\n+\n+[Visual Studio Build Tools]: https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2019\n+\n+At last check (cmake 3.14.3 and msvc 16.0.3) using the 2019 tools fails to\n+build the in-tree LLVM build with a CMake error, so use 2017 instead by\n+including the \u201cMSVC v141 \u2013 VS 2017 C++ x64/x86 build tools (v14.16)\u201d component.\n \n With these dependencies installed, you can build the compiler in a `cmd.exe`\n shell with:"}, {"sha": "4185961187b395d277272a31763c25d22662df16", "filename": "RELEASES.md", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,3 +1,109 @@\n+Version 1.35.0 (2019-05-23)\n+==========================\n+\n+Language\n+--------\n+- [`FnOnce`, `FnMut`, and the `Fn` traits are now implemented for `Box<FnOnce>`,\n+  `Box<FnMut>`, and `Box<Fn>` respectively.][59500]\n+- [You can now coerce closures into unsafe function pointers.][59580] e.g.\n+  ```rust\n+  unsafe fn call_unsafe(func: unsafe fn()) {\n+      func()\n+  }\n+\n+  pub fn main() {\n+      unsafe { call_unsafe(|| {}); }\n+  }\n+  ```\n+\n+\n+Compiler\n+--------\n+- [Added the `armv6-unknown-freebsd-gnueabihf` and\n+  `armv7-unknown-freebsd-gnueabihf` targets.][58080]\n+- [Added the `wasm32-unknown-wasi` target.][59464]\n+\n+\n+Libraries\n+---------\n+- [`Thread` will now show its ID in `Debug` output.][59460]\n+- [`StdinLock`, `StdoutLock`, and `StderrLock` now implement `AsRawFd`.][59512]\n+- [`alloc::System` now implements `Default`.][59451]\n+- [Expanded `Debug` output (`{:#?}`) for structs now has a trailing comma on the\n+  last field.][59076]\n+- [`char::{ToLowercase, ToUppercase}` now\n+  implement `ExactSizeIterator`.][58778]\n+- [All `NonZero` numeric types now implement `FromStr`.][58717]\n+- [Removed the `Read` trait bounds\n+  on the `BufReader::{get_ref, get_mut, into_inner}` methods.][58423]\n+- [You can now call the `dbg!` macro without any parameters to print the file\n+  and line where it is called.][57847]\n+- [In place ASCII case conversions are now up to 4\u00d7 faster.][59283]\n+  e.g. `str::make_ascii_lowercase`\n+- [`hash_map::{OccupiedEntry, VacantEntry}` now implement `Sync`\n+  and `Send`.][58369]\n+\n+Stabilized APIs\n+---------------\n+- [`f32::copysign`]\n+- [`f64::copysign`]\n+- [`RefCell::replace_with`]\n+- [`RefCell::map_split`]\n+- [`ptr::hash`]\n+- [`Range::contains`]\n+- [`RangeFrom::contains`]\n+- [`RangeTo::contains`]\n+- [`RangeInclusive::contains`]\n+- [`RangeToInclusive::contains`]\n+- [`Option::copied`]\n+\n+Cargo\n+-----\n+- [You can now set `cargo:rustc-cdylib-link-arg` at build time to pass custom\n+  linker arguments when building a `cdylib`.][cargo/6298] Its usage is highly\n+  platform specific.\n+  \n+Misc\n+----\n+- [The Rust toolchain is now available natively for musl based distros.][58575]\n+\n+[59460]: https://github.com/rust-lang/rust/pull/59460/\n+[59464]: https://github.com/rust-lang/rust/pull/59464/\n+[59500]: https://github.com/rust-lang/rust/pull/59500/\n+[59512]: https://github.com/rust-lang/rust/pull/59512/\n+[59580]: https://github.com/rust-lang/rust/pull/59580/\n+[59283]: https://github.com/rust-lang/rust/pull/59283/\n+[59451]: https://github.com/rust-lang/rust/pull/59451/\n+[59076]: https://github.com/rust-lang/rust/pull/59076/\n+[58778]: https://github.com/rust-lang/rust/pull/58778/\n+[58717]: https://github.com/rust-lang/rust/pull/58717/\n+[58369]: https://github.com/rust-lang/rust/pull/58369/\n+[58423]: https://github.com/rust-lang/rust/pull/58423/\n+[58080]: https://github.com/rust-lang/rust/pull/58080/\n+[57847]: https://github.com/rust-lang/rust/pull/57847/\n+[58575]: https://github.com/rust-lang/rust/pull/58575\n+[cargo/6298]: https://github.com/rust-lang/cargo/pull/6298/\n+[`f32::copysign`]: https://doc.rust-lang.org/stable/std/primitive.f32.html#method.copysign\n+[`f64::copysign`]: https://doc.rust-lang.org/stable/std/primitive.f64.html#method.copysign\n+[`RefCell::replace_with`]: https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html#method.replace_with\n+[`RefCell::map_split`]: https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html#method.map_split\n+[`ptr::hash`]: https://doc.rust-lang.org/stable/std/ptr/fn.hash.html\n+[`Range::contains`]: https://doc.rust-lang.org/std/ops/struct.Range.html#method.contains\n+[`RangeFrom::contains`]: https://doc.rust-lang.org/std/ops/struct.RangeFrom.html#method.contains\n+[`RangeTo::contains`]: https://doc.rust-lang.org/std/ops/struct.RangeTo.html#method.contains\n+[`RangeInclusive::contains`]: https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html#method.contains\n+[`RangeToInclusive::contains`]: https://doc.rust-lang.org/std/ops/struct.RangeToInclusive.html#method.contains\n+[`Option::copied`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.copied\n+\n+Version 1.34.2 (2019-05-14)\n+===========================\n+\n+* [Destabilize the `Error::type_id` function due to a security\n+   vulnerability][60785] ([CVE-2019-12083])\n+\n+[60785]: https://github.com/rust-lang/rust/pull/60785\n+[CVE-2019-12083]: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12083\n+\n Version 1.34.1 (2019-04-25)\n ===========================\n "}, {"sha": "556625b531d1c96b397062fd4360446978cf0069", "filename": "config.toml.example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -480,7 +480,7 @@\n # linked binaries\n #musl-root = \"...\"\n \n-# The root location of the `wasm32-unknown-wasi` sysroot.\n+# The root location of the `wasm32-wasi` sysroot.\n #wasi-root = \"...\"\n \n # Used in testing for configuring where the QEMU images are located, you"}, {"sha": "1c2b882f66594a45254e24f2e75a12183c29d43a", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -177,7 +177,6 @@ def default_build_triple():\n     # The goal here is to come up with the same triple as LLVM would,\n     # at least for the subset of platforms we're willing to target.\n     ostype_mapper = {\n-        'Bitrig': 'unknown-bitrig',\n         'Darwin': 'apple-darwin',\n         'DragonFly': 'unknown-dragonfly',\n         'FreeBSD': 'unknown-freebsd',"}, {"sha": "e1cdd226fd6e5ba3e78152d43fec41f0ba257358", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -168,7 +168,7 @@ pub fn std_cargo(builder: &Builder<'_>,\n             .arg(\"--manifest-path\")\n             .arg(builder.src.join(\"src/liballoc/Cargo.toml\"))\n             .arg(\"--features\")\n-            .arg(\"compiler-builtins-mem\");\n+            .arg(\"compiler-builtins-mem compiler-builtins-c\");\n     } else {\n         let features = builder.std_features();\n "}, {"sha": "da2e03a1a08482e6e6f912ee249a69056c884e51", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -317,6 +317,10 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n fn configure_cmake(builder: &Builder<'_>,\n                    target: Interned<String>,\n                    cfg: &mut cmake::Config) {\n+    // Do not print installation messages for up-to-date files.\n+    // LLVM and LLD builds can produce a lot of those and hit CI limits on log size.\n+    cfg.define(\"CMAKE_INSTALL_MESSAGE\", \"LAZY\");\n+\n     if builder.config.ninja {\n         cfg.generator(\"Ninja\");\n     }"}, {"sha": "be0af8be7b272bc615aab84985faa07db286c449", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -683,7 +683,7 @@ impl Step for RustdocUi {\n             target: self.target,\n             mode: \"ui\",\n             suite: \"rustdoc-ui\",\n-            path: None,\n+            path: Some(\"src/test/rustdoc-ui\"),\n             compare_mode: None,\n         })\n     }\n@@ -1184,8 +1184,19 @@ impl Step for Compiletest {\n                     Err(_) => p,\n                 }\n             })\n-            .filter(|p| p.starts_with(suite_path) && p.is_file())\n-            .map(|p| p.strip_prefix(suite_path).unwrap().to_str().unwrap())\n+            .filter(|p| p.starts_with(suite_path) && (p.is_dir() || p.is_file()))\n+            .filter_map(|p| {\n+                // Since test suite paths are themselves directories, if we don't\n+                // specify a directory or file, we'll get an empty string here\n+                // (the result of the test suite directory without its suite prefix).\n+                // Therefore, we need to filter these out, as only the first --test-args\n+                // flag is respected, so providing an empty --test-args conflicts with\n+                // any following it.\n+                match p.strip_prefix(suite_path).ok().and_then(|p| p.to_str()) {\n+                    Some(s) if s != \"\" => Some(s),\n+                    _ => None,\n+                }\n+            })\n             .collect();\n \n         test_args.append(&mut builder.config.cmd.test_args());\n@@ -1870,6 +1881,10 @@ impl Step for CrateRustdoc {\n         cargo.arg(\"--\");\n         cargo.args(&builder.config.cmd.test_args());\n \n+        if self.host.contains(\"musl\") {\n+            cargo.arg(\"'-Ctarget-feature=-crt-static'\");\n+        }\n+\n         if !builder.config.verbose_tests {\n             cargo.arg(\"--quiet\");\n         }"}, {"sha": "60911d917899f6f338da76cd30a96dfbadd470a4", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -113,7 +113,7 @@ pub fn gnu_target(target: &str) -> &str {\n }\n \n pub fn make(host: &str) -> PathBuf {\n-    if host.contains(\"bitrig\") || host.contains(\"dragonfly\") || host.contains(\"freebsd\")\n+    if host.contains(\"dragonfly\") || host.contains(\"freebsd\")\n         || host.contains(\"netbsd\") || host.contains(\"openbsd\")\n     {\n         PathBuf::from(\"gmake\")"}, {"sha": "d19862d9c583b24c468f1f4d49901972f97775e5", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -75,7 +75,7 @@ ENV CARGO_TARGET_AARCH64_FUCHSIA_RUSTFLAGS \\\n ENV TARGETS=x86_64-fuchsia\n ENV TARGETS=$TARGETS,aarch64-fuchsia\n ENV TARGETS=$TARGETS,wasm32-unknown-unknown\n-ENV TARGETS=$TARGETS,wasm32-unknown-wasi\n+ENV TARGETS=$TARGETS,wasm32-wasi\n # FIXME(#61022) - reenable solaris\n # ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n # ENV TARGETS=$TARGETS,x86_64-sun-solaris\n@@ -87,5 +87,5 @@ ENV TARGETS=$TARGETS,nvptx64-nvidia-cuda\n ENV X86_FORTANIX_SGX_LIBS=\"/x86_64-fortanix-unknown-sgx/lib/\"\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --enable-lld --disable-docs \\\n-  --set target.wasm32-unknown-wasi.wasi-root=/wasm32-unknown-wasi\n+  --set target.wasm32-wasi.wasi-root=/wasm32-wasi\n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS"}, {"sha": "98d6df043baca1ef609ba00e1d4b39218fc2620e", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -13,7 +13,7 @@ git clone https://github.com/CraneStation/wasi-sysroot\n \n cd wasi-sysroot\n git reset --hard e5f14be38362f1ab83302895a6e74b2ffd0e2302\n-make -j$(nproc) INSTALL_DIR=/wasm32-unknown-wasi install\n+make -j$(nproc) INSTALL_DIR=/wasm32-wasi install\n \n cd ..\n rm -rf reference-sysroot-wasi"}, {"sha": "385eefde846c293b41d3f3727fec5e8fc9cc2267", "filename": "src/ci/docker/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -23,7 +23,7 @@ COPY scripts/musl-toolchain.sh /build/\n # We need to mitigate rust-lang/rust#34978 when compiling musl itself as well\n RUN CFLAGS=\"-Wa,-mrelax-relocations=no -Wa,--compress-debug-sections=none -Wl,--compress-debug-sections=none\" \\\n     CXXFLAGS=\"-Wa,-mrelax-relocations=no -Wa,--compress-debug-sections=none -Wl,--compress-debug-sections=none\" \\\n-    bash musl-toolchain.sh x86_64 && rm -rf build\n+    REPLACE_CC=1 bash musl-toolchain.sh x86_64 && rm -rf build\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n@@ -35,10 +35,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-extended \\\n       --disable-docs \\\n       --set target.x86_64-unknown-linux-musl.crt-static=false \\\n-      --build $HOSTS \\\n-      --set target.x86_64-unknown-linux-musl.cc=x86_64-linux-musl-gcc \\\n-      --set target.x86_64-unknown-linux-musl.cxx=x86_64-linux-musl-g++ \\\n-      --set target.x86_64-unknown-linux-musl.linker=x86_64-linux-musl-gcc\n+      --build $HOSTS\n \n # Newer binutils broke things on some vms/distros (i.e., linking against\n # unknown relocs disabled by the following flag), so we need to go out of our\n@@ -49,4 +46,5 @@ ENV RUST_CONFIGURE_ARGS \\\n ENV CFLAGS_x86_64_unknown_linux_musl=\"-Wa,-mrelax-relocations=no -Wa,--compress-debug-sections=none \\\n     -Wl,--compress-debug-sections=none\"\n \n+# To run native tests replace `dist` below with `test`\n ENV SCRIPT python2.7 ../x.py dist --build $HOSTS"}, {"sha": "d5988a25671a2d3109a923b7ea1de1d98968e385", "filename": "src/ci/docker/scripts/musl-toolchain.sh", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -45,6 +45,15 @@ cd -\n ln -s $OUTPUT/$TARGET/lib/libc.so /lib/ld-musl-$ARCH.so.1\n echo $OUTPUT/$TARGET/lib >> /etc/ld-musl-$ARCH.path\n \n+# Now when musl bootstraps itself create proper toolchain symlinks to make build and tests easier\n+if [ \"$REPLACE_CC\" = \"1\" ]; then\n+    for exec in cc gcc; do\n+        ln -s $TARGET-gcc /usr/local/bin/$exec\n+    done\n+    for exec in cpp c++ g++; do\n+        ln -s $TARGET-g++ /usr/local/bin/$exec\n+    done\n+fi\n \n export CC=$TARGET-gcc\n export CXX=$TARGET-g++"}, {"sha": "a0fe307cffcdb2187cfef2bace1998f6592b9bff", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -74,7 +74,9 @@ status_check() {\n     check_dispatch $1 beta nomicon src/doc/nomicon\n     check_dispatch $1 beta reference src/doc/reference\n     check_dispatch $1 beta rust-by-example src/doc/rust-by-example\n-    check_dispatch $1 beta edition-guide src/doc/edition-guide\n+    # Temporarily disabled until\n+    # https://github.com/rust-lang/rust/issues/60459 is fixed.\n+    # check_dispatch $1 beta edition-guide src/doc/edition-guide\n     check_dispatch $1 beta rls src/tools/rls\n     check_dispatch $1 beta rustfmt src/tools/rustfmt\n     check_dispatch $1 beta clippy-driver src/tools/clippy"}, {"sha": "29fe982990e43b9367be0ff47abc82fb2123fd03", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1 +1 @@\n-Subproject commit db919bc6bb9071566e9c4f05053672133eaac33e\n+Subproject commit 29fe982990e43b9367be0ff47abc82fb2123fd03"}, {"sha": "581c6cccfaf995394ea9dcac362dc8e731c18558", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1 +1 @@\n-Subproject commit c413d42a207bd082f801ec0137c31b71e4bfed4c\n+Subproject commit 581c6cccfaf995394ea9dcac362dc8e731c18558"}, {"sha": "9858872bd1b7dbba5ec27dc30d34eba00acd7ef9", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1 +1 @@\n-Subproject commit de3d55f521e657863df45260ebbca1b10527f662\n+Subproject commit 9858872bd1b7dbba5ec27dc30d34eba00acd7ef9"}, {"sha": "c656171b749b7307f21371dd0d3278efee5573b8", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1 +1 @@\n-Subproject commit fb29b147be4d9a1f8e24aba753a7e1de537abf61\n+Subproject commit c656171b749b7307f21371dd0d3278efee5573b8"}, {"sha": "862b669c395822bb0938781d74f860e5762ad4fb", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1 +1 @@\n-Subproject commit 2a2de9ce095979978ad7b582daecf94e4070b916\n+Subproject commit 862b669c395822bb0938781d74f860e5762ad4fb"}, {"sha": "811c697b232c611ed754d279ed20643a0c4096f6", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1 +1 @@\n-Subproject commit 1ff0f8e018838a710ebc0cc1a7bf74ebe73ad9f1\n+Subproject commit 811c697b232c611ed754d279ed20643a0c4096f6"}, {"sha": "3cb727b62b953d59b4360d39aa68b6dc8f157655", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1 +1 @@\n-Subproject commit 99e1b1d53656be08654df399fc200584aebb50e4\n+Subproject commit 3cb727b62b953d59b4360d39aa68b6dc8f157655"}, {"sha": "bd7f6630ea2adf988db267c5692b88266b40f6c1", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 156, "deletions": 11, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -17,28 +17,147 @@ to `#[cfg(verbose)]` and `#[cfg(feature = \"serde\")]` respectively.\n \n ## `-L`: add a directory to the library search path\n \n-When looking for external crates, a directory passed to this flag will be searched.\n+When looking for external crates or libraries, a directory passed to this flag\n+will be searched.\n+\n+The kind of search path can optionally be specified with the form `-L\n+KIND=PATH` where `KIND` may be one of:\n+\n+- `dependency` \u2014\u00a0Only search for transitive dependencies in this directory.\n+- `crate` \u2014\u00a0Only search for this crate's direct dependencies in this\n+  directory.\n+- `native` \u2014 Only search for native libraries in this directory.\n+- `framework` \u2014\u00a0Only search for macOS frameworks in this directory.\n+- `all` \u2014\u00a0Search for all library kinds in this directory. This is the default\n+  if `KIND` is not specified.\n \n ## `-l`: link the generated crate to a native library\n \n This flag allows you to specify linking to a specific native library when building\n a crate.\n \n+The kind of library can optionally be specified with the form `-l KIND=lib`\n+where `KIND` may be one of:\n+\n+- `dylib` \u2014\u00a0A native dynamic library.\n+- `static` \u2014\u00a0A native static library (such as a `.a` archive).\n+- `framework` \u2014\u00a0A macOS framework.\n+\n+The kind of library can be specified in a [`#[link]`\n+attribute][link-attribute]. If the kind is not specified in the `link`\n+attribute or on the command-line, it will link a dynamic library if available,\n+otherwise it will use a static library. If the kind is specified on the\n+command-line, it will override the kind specified in a `link` attribute.\n+\n+The name used in a `link` attribute may be overridden using the form `-l\n+ATTR_NAME:LINK_NAME` where `ATTR_NAME` is the name in the `link` attribute,\n+and `LINK_NAME` is the name of the actual library that will be linked.\n+\n+[link-attribute]: ../reference/items/external-blocks.html#the-link-attribute\n+\n ## `--crate-type`: a list of types of crates for the compiler to emit\n \n-This instructs `rustc` on which crate type to build.\n+This instructs `rustc` on which crate type to build. This flag accepts a\n+comma-separated list of values, and may be specified multiple times. The valid\n+crate types are:\n+\n+- `lib` \u2014 Generates a library kind preferred by the compiler, currently\n+  defaults to `rlib`.\n+- `rlib` \u2014 A Rust static library.\n+- `staticlib` \u2014 A native static library.\n+- `dylib` \u2014 A Rust dynamic library.\n+- `cdylib` \u2014 A native dynamic library.\n+- `bin` \u2014 A runnable executable program.\n+- `proc-macro` \u2014 Generates a format suitable for a procedural macro library\n+  that may be loaded by the compiler.\n+\n+The crate type may be specified with the [`crate_type` attribute][crate_type].\n+The `--crate-type` command-line value will override the `crate_type`\n+attribute.\n+\n+More details may be found in the [linkage chapter] of the reference.\n+\n+[linkage chapter]: ../reference/linkage.html\n+[crate_type]: ../reference/linkage.html\n \n ## `--crate-name`: specify the name of the crate being built\n \n This informs `rustc` of the name of your crate.\n \n-## `--emit`: emit output other than a crate\n-\n-Instead of producing a crate, this flag can print out things like the assembly or LLVM-IR.\n+## `--edition`: specify the edition to use\n+\n+This flag takes a value of `2015` or `2018`. The default is `2015`. More\n+information about editions may be found in the [edition guide].\n+\n+[edition guide]: ../edition-guide/introduction.html\n+\n+## `--emit`: specifies the types of output files to generate\n+\n+This flag controls the types of output files generated by the compiler. It\n+accepts a comma-separated list of values, and may be specified multiple times.\n+The valid emit kinds are:\n+\n+- `asm` \u2014 Generates a file with the crate's assembly code. The default output\n+  filename is `CRATE_NAME.s`.\n+- `dep-info` \u2014 Generates a file with Makefile syntax that indicates all the\n+  source files that were loaded to generate the crate. The default output\n+  filename is `CRATE_NAME.d`.\n+- `link` \u2014 Generates the crates specified by `--crate-type`. The default\n+  output filenames depend on the crate type and platform. This is the default\n+  if `--emit` is not specified.\n+- `llvm-bc` \u2014 Generates a binary file containing the [LLVM bitcode]. The\n+  default output filename is `CRATE_NAME.bc`.\n+- `llvm-ir` \u2014 Generates a file containing [LLVM IR]. The default output\n+  filename is `CRATE_NAME.ll`.\n+- `metadata` \u2014 Generates a file containing metadata about the crate. The\n+  default output filename is `CRATE_NAME.rmeta`.\n+- `mir` \u2014 Generates a file containing rustc's mid-level intermediate\n+  representation. The default output filename is `CRATE_NAME.mir`.\n+- `obj` \u2014 Generates a native object file. The default output filename is\n+  `CRATE_NAME.o`.\n+\n+The output filename can be set with the `-o` flag. A suffix may be added to\n+the filename with the `-C extra-filename` flag. The files are written to the\n+current directory unless the `--out-dir` flag is used. Each emission type may\n+also specify the output filename with the form `KIND=PATH`, which takes\n+precedence over the `-o` flag.\n+\n+[LLVM bitcode]: https://llvm.org/docs/BitCodeFormat.html\n+[LLVM IR]: https://llvm.org/docs/LangRef.html\n \n ## `--print`: print compiler information\n \n-This flag prints out various information about the compiler.\n+This flag prints out various information about the compiler. This flag may be\n+specified multiple times, and the information is printed in the order the\n+flags are specified. Specifying a `--print` flag will usually disable the\n+`--emit` step and will only print the requested information. The valid types\n+of print values are:\n+\n+- `crate-name` \u2014 The name of the crate.\n+- `file-names` \u2014 The names of the files created by the `link` emit kind.\n+- `sysroot` \u2014 Path to the sysroot.\n+- `cfg` \u2014 List of cfg values. See [conditional compilation] for more\n+  information about cfg values.\n+- `target-list` \u2014 List of known targets. The target may be selected with the\n+  `--target` flag.\n+- `target-cpus` \u2014 List of available CPU values for the current target. The\n+  target CPU may be selected with the `-C target-cpu=val` flag.\n+- `target-features` \u2014 List of available target features for the current\n+  target. Target features may be enabled with the `-C target-feature=val`\n+  flag.\n+- `relocation-models` \u2014 List of relocation models. Relocation models may be\n+  selected with the `-C relocation-model=val` flag.\n+- `code-models` \u2014 List of code models. Code models may be selected with the\n+  `-C code-model=val` flag.\n+- `tls-models` \u2014 List of Thread Local Storage models supported. The model may\n+  be selected with the `-Z tls-model=val` flag.\n+- `native-static-libs` \u2014 This may be used when creating a `staticlib` crate\n+  type. If this is the only flag, it will perform a full compilation and\n+  include a diagnostic note that indicates the linker flags to use when\n+  linking the resulting static library. The note starts with the text\n+  `native-static-libs:` to make it easier to fetch the output.\n+\n+[conditional compilation]: ../reference/conditional-compilation.html\n \n ## `-g`: include debug information\n \n@@ -54,7 +173,8 @@ This flag controls the output filename.\n \n ## `--out-dir`: directory to write the output in\n \n-The outputted crate will be written to this directory.\n+The outputted crate will be written to this directory. This flag is ignored if\n+the `-o` flag is used.\n \n ## `--explain`: provide a detailed explanation of an error message\n \n@@ -111,8 +231,9 @@ This flag, when combined with other flags, makes them produce extra output.\n \n ## `--extern`: specify where an external library is located\n \n-This flag allows you to pass the name and location of an external crate that will\n-be linked into the crate you're buildling.\n+This flag allows you to pass the name and location of an external crate that\n+will be linked into the crate you are building. This flag may be specified\n+multiple times. The format of the value should be `CRATENAME=PATH`.\n \n ## `--sysroot`: Override the system root\n \n@@ -121,8 +242,32 @@ distribution; this flag allows that to be overridden.\n \n ## `--error-format`: control how errors are produced\n \n-This flag lets you control the format of errors.\n+This flag lets you control the format of messages. Messages are printed to\n+stderr. The valid options are:\n+\n+- `human` \u2014 Human-readable output. This is the default.\n+- `json` \u2014 Structured JSON output.\n+- `short` \u2014 Short, one-line messages.\n \n ## `--color`: configure coloring of output\n \n-This flag lets you control color settings of the output.\n+This flag lets you control color settings of the output. The valid options\n+are:\n+\n+- `auto` \u2014 Use colors if output goes to a tty. This is the default.\n+- `always` \u2014\u00a0Always use colors.\n+- `never` \u2014\u00a0Never colorize output.\n+\n+## `--remap-path-prefix`: remap source names in output\n+\n+Remap source path prefixes in all output, including compiler diagnostics,\n+debug information, macro expansions, etc. It takes a value of the form\n+`FROM=TO` where a path prefix equal to `FROM` is rewritten to the value `TO`.\n+The `FROM` may itself contain an `=` symbol, but the `TO` value may not. This\n+flag may be specified multiple times.\n+\n+This is useful for normalizing build products, for example by removing the\n+current directory out of pathnames emitted into the object files. The\n+replacement is purely textual, with no consideration of the current system's\n+pathname syntax. For example `--remap-path-prefix foo=bar` will match\n+`foo/lib.rs` but not `./foo/lib.rs`."}, {"sha": "049e59b651722ab029e25365d6fc93e2c665cf57", "filename": "src/doc/rustc/src/lints/groups.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -21,9 +21,9 @@ Here's a list of each lint group, and the lints that they are made up of:\n | edition-2018        | Lints that will be turned into errors in Rust 2018            | tyvar-behind-raw-pointer                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n | rust-2018-idioms    | Lints to nudge you toward idiomatic features of Rust 2018     | bare-trait-object, unreachable-pub                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n | unused              | These lints detect things being declared but not used         | unused-imports, unused-variables, unused-assignments, dead-code, unused-mut, unreachable-code, unreachable-patterns, unused-must-use, unused-unsafe, path-statements, unused-attributes, unused-macros, unused-allocation, unused-doc-comment, unused-extern-crates, unused-features, unused-parens                                                                                                                                                                                    |\n-| future-incompatible | Lints that detect code that has future-compatibility problems | private-in-public, pub-use-of-private-extern-crate, patterns-in-fns-without-body, safe-extern-statics, invalid-type-param-default, legacy-directory-ownership, legacy-imports, legacy-constructor-visibility, missing-fragment-specifier, illegal-floating-point-literal-pattern, anonymous-parameters, parenthesized-params-in-types-and-modules, late-bound-lifetime-arguments, safe-packed-borrows, incoherent-fundamental-impls, tyvar-behind-raw-pointer, unstable-name-collision |\n+| future-incompatible | Lints that detect code that has future-compatibility problems | private-in-public, pub-use-of-private-extern-crate, patterns-in-fns-without-body, safe-extern-statics, invalid-type-param-default, legacy-directory-ownership, legacy-imports, legacy-constructor-visibility, missing-fragment-specifier, illegal-floating-point-literal-pattern, anonymous-parameters, parenthesized-params-in-types-and-modules, late-bound-lifetime-arguments, safe-packed-borrows, tyvar-behind-raw-pointer, unstable-name-collision |\n \n Additionally, there's a `bad-style` lint group that's a deprecated alias for `nonstandard-style`.\n \n Finally, you can also see the table above by invoking `rustc -W help`. This will give you the exact values for the specific\n-compiler you have installed.\n\\ No newline at end of file\n+compiler you have installed."}, {"sha": "c1740f272ed26d7c5dd2b1f103655d57617539ea", "filename": "src/doc/rustc/src/lints/listing/deny-by-default.md", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -222,44 +222,3 @@ error: invalid `crate_type` value\n   | ^^^^^^^^^^^^^^^^^^^^\n   |\n ```\n-\n-## incoherent-fundamental-impls\n-\n-This lint detects potentially-conflicting impls that were erroneously allowed. Some\n-example code that triggers this lint:\n-\n-```rust,ignore\n-pub trait Trait1<X> {\n-    type Output;\n-}\n-\n-pub trait Trait2<X> {}\n-\n-pub struct A;\n-\n-impl<X, T> Trait1<X> for T where T: Trait2<X> {\n-    type Output = ();\n-}\n-\n-impl<X> Trait1<Box<X>> for A {\n-    type Output = i32;\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-error: conflicting implementations of trait `Trait1<std::boxed::Box<_>>` for type `A`: (E0119)\n-  --> src/main.rs:13:1\n-   |\n-9  | impl<X, T> Trait1<X> for T where T: Trait2<X> {\n-   | --------------------------------------------- first implementation here\n-...\n-13 | impl<X> Trait1<Box<X>> for A {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `A`\n-   |\n-   = note: #[deny(incoherent_fundamental_impls)] on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46205 <https://github.com/rust-lang/rust/issues/46205>\n-   = note: downstream crates may implement trait `Trait2<std::boxed::Box<_>>` for type `A`\n-```"}, {"sha": "b165c5a6b3b937fa6cd3ca1c5925e15cad6b06ef", "filename": "src/doc/rustdoc/src/the-doc-attribute.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -92,6 +92,21 @@ the tracking issue.\n #![doc(issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n ```\n \n+### `html_root_url`\n+\n+The `#[doc(html_root_url = \"\u2026\")]` attribute value indicates the URL for\n+generating links to external crates. When rustdoc needs to generate a link to\n+an item in an external crate, it will first check if the extern crate has been\n+documented locally on-disk, and if so link directly to it. Failing that, it\n+will use the URL given by the `--extern-html-root-url` command-line flag if\n+available. If that is not available, then it will use the `html_root_url`\n+value in the extern crate if it is available. If that is not available, then\n+the extern items will not be linked.\n+\n+```rust,ignore\n+#![doc(html_root_url = \"https://docs.rs/serde/1.0\")]\n+```\n+\n ### `html_no_source`\n \n By default, `rustdoc` will include the source code of your program, with links"}, {"sha": "bbcacb7f3d5d9b05111fb1e2a1c52e105e2111c5", "filename": "src/doc/rustdoc/src/what-is-rustdoc.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fdoc%2Frustdoc%2Fsrc%2Fwhat-is-rustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fdoc%2Frustdoc%2Fsrc%2Fwhat-is-rustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fwhat-is-rustdoc.md?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -98,21 +98,21 @@ documentation for them as well!\n `rustdoc` can also generate HTML from standalone Markdown files. Let's\n give it a try: create a `README.md` file with these contents:\n \n-```text\n-    # Docs\n+````text\n+# Docs\n \n-    This is a project to test out `rustdoc`.\n+This is a project to test out `rustdoc`.\n \n-    [Here is a link!](https://www.rust-lang.org)\n+[Here is a link!](https://www.rust-lang.org)\n \n-    ## Subheading\n+## Subheading\n \n-    ```rust\n-    fn foo() -> i32 {\n-        1 + 1\n-    }\n-    ```\n+```rust\n+fn foo() -> i32 {\n+    1 + 1\n+}\n ```\n+````\n \n And call `rustdoc` on it:\n "}, {"sha": "de30b58526a138eef01dd532d0bdb66b0dbd3a8d", "filename": "src/etc/natvis/liballoc.natvis", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fliballoc.natvis?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -7,11 +7,11 @@\n       <Item Name=\"[capacity]\" ExcludeView=\"simple\">buf.cap</Item>\n       <ArrayItems>\n         <Size>len</Size>\n-        <ValuePointer>buf.ptr.pointer.__0</ValuePointer>\n+        <ValuePointer>buf.ptr.pointer</ValuePointer>\n       </ArrayItems>\n     </Expand>\n   </Type>\n-  <Type Name=\"alloc::vec_deque::VecDeque&lt;*&gt;\">\n+  <Type Name=\"alloc::collections::vec_deque::VecDeque&lt;*&gt;\">\n     <DisplayString>{{ size={tail &lt;= head ? head - tail : buf.cap - tail + head} }}</DisplayString>\n     <Expand>\n       <Item Name=\"[size]\" ExcludeView=\"simple\">tail &lt;= head ? head - tail : buf.cap - tail + head</Item>\n@@ -24,19 +24,19 @@\n           <If Condition=\"i == head\">\n             <Break/>\n           </If>\n-          <Item>buf.ptr.pointer.__0 + i</Item>\n+          <Item>buf.ptr.pointer[i]</Item>\n           <Exec>i = (i + 1 == buf.cap ? 0 : i + 1)</Exec>\n         </Loop>\n       </CustomListItems>\n     </Expand>\n   </Type>\n-  <Type Name=\"alloc::linked_list::LinkedList&lt;*&gt;\">\n+  <Type Name=\"alloc::collections::linked_list::LinkedList&lt;*&gt;\">\n     <DisplayString>{{ size={len} }}</DisplayString>\n     <Expand>\n       <LinkedListItems>\n         <Size>len</Size>\n-        <HeadPointer>*(alloc::linked_list::Node&lt;$T1&gt; **)&amp;head</HeadPointer>\n-        <NextPointer>*(alloc::linked_list::Node&lt;$T1&gt; **)&amp;next</NextPointer>\n+        <HeadPointer>*(alloc::collections::linked_list::Node&lt;$T1&gt; **)&amp;head</HeadPointer>\n+        <NextPointer>*(alloc::collections::linked_list::Node&lt;$T1&gt; **)&amp;next</NextPointer>\n         <ValueNode>element</ValueNode>\n       </LinkedListItems>\n     </Expand>"}, {"sha": "0e703b3b9502644e30dd527895736e874ba006bb", "filename": "src/etc/natvis/libcore.natvis", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fetc%2Fnatvis%2Flibcore.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fetc%2Fnatvis%2Flibcore.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibcore.natvis?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,15 +1,15 @@\n <?xml version=\"1.0\" encoding=\"utf-8\"?>\n <AutoVisualizer xmlns=\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\">\n   <Type Name=\"core::ptr::Unique&lt;*&gt;\">\n-    <DisplayString>{{ Unique {*pointer.__0} }}</DisplayString>\n+    <DisplayString>{{ Unique {pointer} }}</DisplayString>\n     <Expand>\n-      <Item Name=\"[ptr]\">pointer.__0</Item>\n+      <Item Name=\"[ptr]\">pointer</Item>\n     </Expand>\n   </Type>\n   <Type Name=\"core::ptr::Shared&lt;*&gt;\">\n-    <DisplayString>{{ Shared {*pointer.__0} }}</DisplayString>\n+    <DisplayString>{{ Shared {pointer} }}</DisplayString>\n     <Expand>\n-      <Item Name=\"[ptr]\">pointer.__0</Item>\n+      <Item Name=\"[ptr]\">pointer</Item>\n     </Expand>\n   </Type>\n   <Type Name=\"core::option::Option&lt;*&gt;\">"}, {"sha": "bcb27bb5161e2d4bfe791164586a9fe537b93517", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -33,3 +33,4 @@ harness = false\n \n [features]\n compiler-builtins-mem = ['compiler_builtins/mem']\n+compiler-builtins-c = [\"compiler_builtins/c\"]"}, {"sha": "41ff06d70ff09eb7897af0f71c5385e42807483d", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -37,6 +37,8 @@ extern \"Rust\" {\n ///\n /// Note: while this type is unstable, the functionality it provides can be\n /// accessed through the [free functions in `alloc`](index.html#functions).\n+///\n+/// [`Alloc`]: trait.Alloc.html\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Global;\n@@ -54,6 +56,10 @@ pub struct Global;\n ///\n /// See [`GlobalAlloc::alloc`].\n ///\n+/// [`Global`]: struct.Global.html\n+/// [`Alloc`]: trait.Alloc.html\n+/// [`GlobalAlloc::alloc`]: trait.GlobalAlloc.html#tymethod.alloc\n+///\n /// # Examples\n ///\n /// ```\n@@ -87,6 +93,10 @@ pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n /// # Safety\n ///\n /// See [`GlobalAlloc::dealloc`].\n+///\n+/// [`Global`]: struct.Global.html\n+/// [`Alloc`]: trait.Alloc.html\n+/// [`GlobalAlloc::dealloc`]: trait.GlobalAlloc.html#tymethod.dealloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n@@ -105,6 +115,10 @@ pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n /// # Safety\n ///\n /// See [`GlobalAlloc::realloc`].\n+///\n+/// [`Global`]: struct.Global.html\n+/// [`Alloc`]: trait.Alloc.html\n+/// [`GlobalAlloc::realloc`]: trait.GlobalAlloc.html#method.realloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n@@ -124,6 +138,10 @@ pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8\n ///\n /// See [`GlobalAlloc::alloc_zeroed`].\n ///\n+/// [`Global`]: struct.Global.html\n+/// [`Alloc`]: trait.Alloc.html\n+/// [`GlobalAlloc::alloc_zeroed`]: trait.GlobalAlloc.html#method.alloc_zeroed\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "c5a0b6e877b65f124f61e925ab8989c5e02547e1", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -231,6 +231,20 @@ use super::SpecExtend;\n /// assert_eq!(heap.pop(), Some(Reverse(5)));\n /// assert_eq!(heap.pop(), None);\n /// ```\n+///\n+/// # Time complexity\n+///\n+/// | [push] | [pop]    | [peek]/[peek\\_mut] |\n+/// |--------|----------|--------------------|\n+/// | O(1)~  | O(log n) | O(1)               |\n+///\n+/// The value for `push` is an expected cost; the method documentation gives a\n+/// more detailed analysis.\n+///\n+/// [push]: #method.push\n+/// [pop]: #method.pop\n+/// [peek]: #method.peek\n+/// [peek\\_mut]: #method.peek_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BinaryHeap<T> {\n     data: Vec<T>,\n@@ -384,6 +398,10 @@ impl<T: Ord> BinaryHeap<T> {\n     /// }\n     /// assert_eq!(heap.peek(), Some(&2));\n     /// ```\n+    ///\n+    /// # Time complexity\n+    ///\n+    /// Cost is O(1) in the worst case.\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n     pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n         if self.is_empty() {\n@@ -411,6 +429,11 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.pop(), Some(1));\n     /// assert_eq!(heap.pop(), None);\n     /// ```\n+    ///\n+    /// # Time complexity\n+    ///\n+    /// The worst case cost of `pop` on a heap containing *n* elements is O(log\n+    /// n).\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         self.data.pop().map(|mut item| {\n@@ -438,6 +461,22 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.len(), 3);\n     /// assert_eq!(heap.peek(), Some(&5));\n     /// ```\n+    ///\n+    /// # Time complexity\n+    ///\n+    /// The expected cost of `push`, averaged over every possible ordering of\n+    /// the elements being pushed, and over a sufficiently large number of\n+    /// pushes, is O(1). This is the most meaningful cost metric when pushing\n+    /// elements that are *not* already in any sorted pattern.\n+    ///\n+    /// The time complexity degrades if elements are pushed in predominantly\n+    /// ascending order. In the worst case, elements are pushed in ascending\n+    /// sorted order and the amortized cost per push is O(log n) against a heap\n+    /// containing *n* elements.\n+    ///\n+    /// The worst case cost of a *single* call to `push` is O(n). The worst case\n+    /// occurs when capacity is exhausted and needs a resize. The resize cost\n+    /// has been amortized in the previous figures.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, item: T) {\n         let old_len = self.len();\n@@ -650,6 +689,10 @@ impl<T> BinaryHeap<T> {\n     /// assert_eq!(heap.peek(), Some(&5));\n     ///\n     /// ```\n+    ///\n+    /// # Time complexity\n+    ///\n+    /// Cost is O(1) in the worst case.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n@@ -992,6 +1035,11 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1047,6 +1095,11 @@ impl<T> Iterator for IntoIter<T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1093,6 +1146,11 @@ impl<T> Iterator for Drain<'_, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]"}, {"sha": "414abb00ef1fa760161d49cbaa0327939675ce94", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1193,6 +1193,11 @@ impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.length, Some(self.length))\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<(&'a K, &'a V)> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1253,6 +1258,11 @@ impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.length, Some(self.length))\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1359,6 +1369,11 @@ impl<K, V> Iterator for IntoIter<K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.length, Some(self.length))\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<(K, V)> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1421,6 +1436,11 @@ impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a K> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1458,6 +1478,11 @@ impl<'a, K, V> Iterator for Values<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a V> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1495,6 +1520,11 @@ impl<'a, K, V> Iterator for Range<'a, K, V> {\n             unsafe { Some(self.next_unchecked()) }\n         }\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<(&'a K, &'a V)> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n@@ -1508,6 +1538,11 @@ impl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a mut V> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n@@ -1626,6 +1661,11 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n             unsafe { Some(self.next_unchecked()) }\n         }\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.next_back()\n+    }\n }\n \n impl<'a, K, V> RangeMut<'a, K, V> {"}, {"sha": "6f2467dfd6b513de6b41e7fec1a95a85f61feed9", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1019,6 +1019,11 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n@@ -1044,6 +1049,11 @@ impl<T> Iterator for IntoIter<T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<T> {\n+        self.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n@@ -1073,6 +1083,11 @@ impl<'a, T> Iterator for Range<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         self.iter.next().map(|(k, _)| k)\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]"}, {"sha": "31e49d06a7b5a963d3701ed6123ea50f8c792bf8", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1835,8 +1835,8 @@ impl<T> VecDeque<T> {\n     /// Retains only the elements specified by the predicate.\n     ///\n     /// In other words, remove all elements `e` such that `f(&e)` returns false.\n-    /// This method operates in place and preserves the order of the retained\n-    /// elements.\n+    /// This method operates in place, visiting each element exactly once in the\n+    /// original order, and preserves the order of the retained elements.\n     ///\n     /// # Examples\n     ///\n@@ -1848,6 +1848,20 @@ impl<T> VecDeque<T> {\n     /// buf.retain(|&x| x%2 == 0);\n     /// assert_eq!(buf, [2, 4]);\n     /// ```\n+    ///\n+    /// The exact order may be useful for tracking external state, like an index.\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    /// buf.extend(1..6);\n+    ///\n+    /// let keep = [false, true, true, false, true];\n+    /// let mut i = 0;\n+    /// buf.retain(|_| (keep[i], i += 1).0);\n+    /// assert_eq!(buf, [2, 3, 5]);\n+    /// ```\n     #[stable(feature = \"vec_deque_retain\", since = \"1.4.0\")]\n     pub fn retain<F>(&mut self, mut f: F)\n         where F: FnMut(&T) -> bool\n@@ -1934,8 +1948,6 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(vecdeque_rotate)]\n-    ///\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf: VecDeque<_> = (0..10).collect();\n@@ -1949,7 +1961,7 @@ impl<T> VecDeque<T> {\n     /// }\n     /// assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n     /// ```\n-    #[unstable(feature = \"vecdeque_rotate\", issue = \"56686\")]\n+    #[stable(feature = \"vecdeque_rotate\", since = \"1.36.0\")]\n     pub fn rotate_left(&mut self, mid: usize) {\n         assert!(mid <= self.len());\n         let k = self.len() - mid;\n@@ -1979,8 +1991,6 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(vecdeque_rotate)]\n-    ///\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf: VecDeque<_> = (0..10).collect();\n@@ -1994,7 +2004,7 @@ impl<T> VecDeque<T> {\n     /// }\n     /// assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n     /// ```\n-    #[unstable(feature = \"vecdeque_rotate\", issue = \"56686\")]\n+    #[stable(feature = \"vecdeque_rotate\", since = \"1.36.0\")]\n     pub fn rotate_right(&mut self, k: usize) {\n         assert!(k <= self.len());\n         let mid = self.len() - k;"}, {"sha": "d90036eaf49b8f3da6389d23e8f978f69fe5984e", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -109,7 +109,7 @@\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n-#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n+#![feature(maybe_uninit_extra, maybe_uninit_slice, maybe_uninit_array)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n #![feature(iter_nth_back)]"}, {"sha": "0dffb19476f3d318dc64968dd31d11663fededd7", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -932,6 +932,11 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n     }\n }\n \n+/// We're doing this specialization here, and not as a more general optimization on `&T`, because it\n+/// would otherwise add a cost to all equality checks on refs. We assume that `Rc`s are used to\n+/// store large values, that are slow to clone, but also heavy to check for equality, causing this\n+/// cost to pay off more easily. It's also more likely to have two `Rc` clones, that point to\n+/// the same value, than two `&T`s.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n     #[inline]"}, {"sha": "e74d37c1c2bae1b676b4c14a1dc08f4cb107efa1", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1200,8 +1200,8 @@ impl String {\n     /// Retains only the characters specified by the predicate.\n     ///\n     /// In other words, remove all characters `c` such that `f(c)` returns `false`.\n-    /// This method operates in place and preserves the order of the retained\n-    /// characters.\n+    /// This method operates in place, visiting each character exactly once in the\n+    /// original order, and preserves the order of the retained characters.\n     ///\n     /// # Examples\n     ///\n@@ -1212,6 +1212,16 @@ impl String {\n     ///\n     /// assert_eq!(s, \"foobar\");\n     /// ```\n+    ///\n+    /// The exact order may be useful for tracking external state, like an index.\n+    ///\n+    /// ```\n+    /// let mut s = String::from(\"abcde\");\n+    /// let keep = [false, true, true, false, true];\n+    /// let mut i = 0;\n+    /// s.retain(|_| (keep[i], i += 1).0);\n+    /// assert_eq!(s, \"bce\");\n+    /// ```\n     #[inline]\n     #[stable(feature = \"string_retain\", since = \"1.26.0\")]\n     pub fn retain<F>(&mut self, mut f: F)\n@@ -2179,6 +2189,14 @@ impl From<&str> for String {\n     }\n }\n \n+#[stable(feature = \"from_ref_string\", since = \"1.35.0\")]\n+impl From<&String> for String {\n+    #[inline]\n+    fn from(s: &String) -> String {\n+        s.clone()\n+    }\n+}\n+\n // note: test pulls in libstd, which causes errors here\n #[cfg(not(test))]\n #[stable(feature = \"string_from_box\", since = \"1.18.0\")]\n@@ -2367,6 +2385,10 @@ impl Iterator for Drain<'_> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+    #[inline]\n+    fn last(mut self) -> Option<char> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]"}, {"sha": "90c7859b3db9ec457acdbc4f0b0f67fea0f105bf", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1377,6 +1377,11 @@ impl<T: ?Sized + PartialEq> ArcEqIdent<T> for Arc<T> {\n     }\n }\n \n+/// We're doing this specialization here, and not as a more general optimization on `&T`, because it\n+/// would otherwise add a cost to all equality checks on refs. We assume that `Arc`s are used to\n+/// store large values, that are slow to clone, but also heavy to check for equality, causing this\n+/// cost to pay off more easily. It's also more likely to have two `Arc` clones, that point to\n+/// the same value, than two `&T`s.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n     #[inline]"}, {"sha": "989beb3b1bfd90afbfd55626953080d31016bb39", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -143,8 +143,8 @@ fn test_union() {\n #[test]\n // Only tests the simple function definition with respect to intersection\n fn test_is_disjoint() {\n-    let one = [1].into_iter().collect::<BTreeSet<_>>();\n-    let two = [2].into_iter().collect::<BTreeSet<_>>();\n+    let one = [1].iter().collect::<BTreeSet<_>>();\n+    let two = [2].iter().collect::<BTreeSet<_>>();\n     assert!(one.is_disjoint(&two));\n }\n "}, {"sha": "ddb3120e89d781635645c424a9eba34d803e85d2", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -6,7 +6,6 @@\n #![feature(repeat_generic_slice)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n-#![feature(vecdeque_rotate)]\n #![deny(rust_2018_idioms)]\n \n use std::hash::{Hash, Hasher};"}, {"sha": "c0cdffe596babc85e61fce4813ef1616682df183", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -937,8 +937,8 @@ impl<T> Vec<T> {\n     /// Retains only the elements specified by the predicate.\n     ///\n     /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n-    /// This method operates in place and preserves the order of the retained\n-    /// elements.\n+    /// This method operates in place, visiting each element exactly once in the\n+    /// original order, and preserves the order of the retained elements.\n     ///\n     /// # Examples\n     ///\n@@ -947,6 +947,16 @@ impl<T> Vec<T> {\n     /// vec.retain(|&x| x%2 == 0);\n     /// assert_eq!(vec, [2, 4]);\n     /// ```\n+    ///\n+    /// The exact order may be useful for tracking external state, like an index.\n+    ///\n+    /// ```\n+    /// let mut vec = vec![1, 2, 3, 4, 5];\n+    /// let keep = [false, true, true, false, true];\n+    /// let mut i = 0;\n+    /// vec.retain(|_| (keep[i], i += 1).0);\n+    /// assert_eq!(vec, [2, 3, 5]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn retain<F>(&mut self, mut f: F)\n         where F: FnMut(&T) -> bool\n@@ -2385,6 +2395,11 @@ impl<T> Iterator for IntoIter<T> {\n     fn count(self) -> usize {\n         self.len()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2504,6 +2519,11 @@ impl<T> Iterator for Drain<'_, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n@@ -2573,6 +2593,10 @@ impl<I: Iterator> Iterator for Splice<'_, I> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.drain.size_hint()\n     }\n+\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]"}, {"sha": "f25631e028eecb15506ddf803c80482fb4b411c4", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -99,7 +99,7 @@ impl Layout {\n     /// [`Layout::from_size_align`](#method.from_size_align).\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n-    pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n+    pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n         Layout { size_: size, align_: NonZeroUsize::new_unchecked(align) }\n     }\n \n@@ -480,7 +480,7 @@ pub unsafe trait GlobalAlloc {\n     ///   this allocator,\n     ///\n     /// * `layout` must be the same layout that was used\n-    ///   to allocated that block of memory,\n+    ///   to allocate that block of memory,\n     #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);\n \n@@ -535,7 +535,7 @@ pub unsafe trait GlobalAlloc {\n     /// * `ptr` must be currently allocated via this allocator,\n     ///\n     /// * `layout` must be the same layout that was used\n-    ///   to allocated that block of memory,\n+    ///   to allocate that block of memory,\n     ///\n     /// * `new_size` must be greater than zero.\n     ///"}, {"sha": "03094bfd3337464a81e0c890528439b456da5823", "filename": "src/libcore/array.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -8,7 +8,7 @@\n \n use crate::borrow::{Borrow, BorrowMut};\n use crate::cmp::Ordering;\n-use crate::convert::TryFrom;\n+use crate::convert::{Infallible, TryFrom};\n use crate::fmt;\n use crate::hash::{Hash, self};\n use crate::marker::Unsize;\n@@ -74,6 +74,13 @@ impl TryFromSliceError {\n     }\n }\n \n+#[stable(feature = \"try_from_slice_error\", since = \"1.36.0\")]\n+impl From<Infallible> for TryFromSliceError {\n+    fn from(x: Infallible) -> TryFromSliceError {\n+        match x {}\n+    }\n+}\n+\n macro_rules! __impl_slice_eq1 {\n     ($Lhs: ty, $Rhs: ty) => {\n         __impl_slice_eq1! { $Lhs, $Rhs, Sized }"}, {"sha": "ddee02ea232d1cf43f6428b8f82440ba21b4c943", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -117,6 +117,8 @@ impl Iterator for EscapeDefault {\n     type Item = u8;\n     fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n+    #[inline]\n+    fn last(mut self) -> Option<u8> { self.next_back() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl DoubleEndedIterator for EscapeDefault {"}, {"sha": "b3ff447be5ee4802f110e4c601b38007b9a30bef", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -104,7 +104,6 @@ pub const fn identity<T>(x: T) -> T { x }\n /// If you need to do a costly conversion it is better to implement [`From`] with type\n /// `&T` or write a custom function.\n ///\n-///\n /// `AsRef` has the same signature as [`Borrow`], but `Borrow` is different in few aspects:\n ///\n /// - Unlike `AsRef`, `Borrow` has a blanket impl for any `T`, and can be used to accept either\n@@ -133,7 +132,7 @@ pub const fn identity<T>(x: T) -> T { x }\n /// converted a the specified type `T`.\n ///\n /// For example: By creating a generic function that takes an `AsRef<str>` we express that we\n-/// want to accept all references that can be converted to &str as an argument.\n+/// want to accept all references that can be converted to `&str` as an argument.\n /// Since both [`String`] and `&str` implement `AsRef<str>` we can accept both as input argument.\n ///\n /// [`String`]: ../../std/string/struct.String.html\n@@ -149,7 +148,6 @@ pub const fn identity<T>(x: T) -> T { x }\n /// let s = \"hello\".to_string();\n /// is_hello(s);\n /// ```\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsRef<T: ?Sized> {\n     /// Performs the conversion.\n@@ -182,6 +180,7 @@ pub trait AsRef<T: ?Sized> {\n /// write a function `add_one`that takes all arguments that can be converted to `&mut u64`.\n /// Because [`Box<T>`] implements `AsMut<T>` `add_one` accepts arguments of type\n /// `&mut Box<u64>` as well:\n+///\n /// ```\n /// fn add_one<T: AsMut<u64>>(num: &mut T) {\n ///     *num.as_mut() += 1;\n@@ -191,8 +190,8 @@ pub trait AsRef<T: ?Sized> {\n /// add_one(&mut boxed_num);\n /// assert_eq!(*boxed_num, 1);\n /// ```\n-/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n ///\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsMut<T: ?Sized> {\n     /// Performs the conversion.\n@@ -203,18 +202,18 @@ pub trait AsMut<T: ?Sized> {\n /// A value-to-value conversion that consumes the input value. The\n /// opposite of [`From`].\n ///\n-/// One should only implement [`Into`] if a conversion to a type outside the current crate is\n-/// required. Otherwise one should always prefer implementing [`From`] over [`Into`] because\n-/// implementing [`From`] automatically provides one with a implementation of [`Into`] thanks to\n+/// One should only implement `Into` if a conversion to a type outside the current crate is\n+/// required. Otherwise one should always prefer implementing [`From`] over `Into` because\n+/// implementing [`From`] automatically provides one with a implementation of `Into` thanks to\n /// the blanket implementation in the standard library. [`From`] cannot do these type of\n /// conversions because of Rust's orphaning rules.\n ///\n /// **Note: This trait must not fail**. If the conversion can fail, use [`TryInto`].\n ///\n /// # Generic Implementations\n ///\n-/// - [`From<T>`]` for U` implies `Into<U> for T`\n-/// - [`Into`]` is reflexive, which means that `Into<T> for T` is implemented\n+/// - [`From`]`<T> for U` implies `Into<U> for T`\n+/// - `Into` is reflexive, which means that `Into<T> for T` is implemented\n ///\n /// # Implementing `Into` for conversions to external types\n ///\n@@ -273,7 +272,7 @@ pub trait AsMut<T: ?Sized> {\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n /// [`String`]: ../../std/string/struct.String.html\n-/// [From]: trait.From.html\n+/// [`From`]: trait.From.html\n /// [`into`]: trait.Into.html#tymethod.into\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Into<T>: Sized {\n@@ -285,18 +284,18 @@ pub trait Into<T>: Sized {\n /// Used to do value-to-value conversions while consuming the input value. It is the reciprocal of\n /// [`Into`].\n ///\n-/// One should always prefer implementing [`From`] over [`Into`]\n-/// because implementing [`From`] automatically provides one with a implementation of [`Into`]\n+/// One should always prefer implementing `From` over [`Into`]\n+/// because implementing `From` automatically provides one with a implementation of [`Into`]\n /// thanks to the blanket implementation in the standard library.\n ///\n /// Only implement [`Into`] if a conversion to a type outside the current crate is required.\n-/// [`From`] cannot do these type of conversions because of Rust's orphaning rules.\n+/// `From` cannot do these type of conversions because of Rust's orphaning rules.\n /// See [`Into`] for more details.\n ///\n-/// Prefer using [`Into`] over using [`From`] when specifying trait bounds on a generic function.\n+/// Prefer using [`Into`] over using `From` when specifying trait bounds on a generic function.\n /// This way, types that directly implement [`Into`] can be used as arguments as well.\n ///\n-/// The [`From`] is also very useful when performing error handling. When constructing a function\n+/// The `From` is also very useful when performing error handling. When constructing a function\n /// that is capable of failing, the return type will generally be of the form `Result<T, E>`.\n /// The `From` trait simplifies error handling by allowing a function to return a single error type\n /// that encapsulate multiple error types. See the \"Examples\" section and [the book][book] for more\n@@ -306,14 +305,15 @@ pub trait Into<T>: Sized {\n ///\n /// # Generic Implementations\n ///\n-/// - [`From<T>`]` for U` implies [`Into<U>`]` for T`\n-/// - [`From`] is reflexive, which means that `From<T> for T` is implemented\n+/// - `From<T> for U` implies [`Into`]`<U> for T`\n+/// - `From` is reflexive, which means that `From<T> for T` is implemented\n ///\n /// # Examples\n ///\n /// [`String`] implements `From<&str>`:\n ///\n-/// An explicit conversion from a &str to a String is done as follows:\n+/// An explicit conversion from a `&str` to a String is done as follows:\n+///\n /// ```\n /// let string = \"hello\".to_string();\n /// let other_string = String::from(\"hello\");\n@@ -361,7 +361,7 @@ pub trait Into<T>: Sized {\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n /// [`String`]: ../../std/string/struct.String.html\n-/// [`Into<U>`]: trait.Into.html\n+/// [`Into`]: trait.Into.html\n /// [`from`]: trait.From.html#tymethod.from\n /// [book]: ../../book/ch09-00-error-handling.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -422,7 +422,7 @@ pub trait TryInto<T>: Sized {\n ///\n /// # Generic Implementations\n ///\n-/// - `TryFrom<T> for U` implies [`TryInto<U>`]` for T`\n+/// - `TryFrom<T> for U` implies [`TryInto`]`<U> for T`\n /// - [`try_from`] is reflexive, which means that `TryFrom<T> for T`\n /// is implemented and cannot fail -- the associated `Error` type for\n /// calling `T::try_from()` on a value of type `T` is `Infallible`."}, {"sha": "2f6d745d146d647d3fd5716e57db7dc020964b39", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -886,7 +886,7 @@ pub trait Pointer {\n ///\n /// # Examples\n ///\n-/// Basic usage with `i32`:\n+/// Basic usage with `f64`:\n ///\n /// ```\n /// let x = 42.0; // 42.0 is '4.2e1' in scientific notation\n@@ -929,7 +929,7 @@ pub trait LowerExp {\n ///\n /// # Examples\n ///\n-/// Basic usage with `f32`:\n+/// Basic usage with `f64`:\n ///\n /// ```\n /// let x = 42.0; // 42.0 is '4.2E1' in scientific notation"}, {"sha": "3f76ac20192ba092734225342772b827165e627b", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -23,7 +23,7 @@ use crate::task::{Context, Poll};\n /// When using a future, you generally won't call `poll` directly, but instead\n /// `await!` the value.\n #[doc(spotlight)]\n-#[must_use = \"futures do nothing unless polled\"]\n+#[must_use = \"futures do nothing unless you `.await` or poll them\"]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub trait Future {\n     /// The type of value produced on completion."}, {"sha": "64e588f65b4688b5800b4c616455fc2a17b66c35", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -73,6 +73,11 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     {\n         self.iter.position(predicate)\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "38c7c9bc4d086c53e9e27eed48168dff5670b4ef", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -356,7 +356,7 @@ pub trait Iterator {\n     ///\n     /// ```\n     /// let a = [0, 1, 2, 3, 4, 5];\n-    /// let mut iter = a.into_iter().step_by(2);\n+    /// let mut iter = a.iter().step_by(2);\n     ///\n     /// assert_eq!(iter.next(), Some(&0));\n     /// assert_eq!(iter.next(), Some(&2));\n@@ -531,7 +531,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3];\n     ///\n-    /// let mut iter = a.into_iter().map(|x| 2 * x);\n+    /// let mut iter = a.iter().map(|x| 2 * x);\n     ///\n     /// assert_eq!(iter.next(), Some(2));\n     /// assert_eq!(iter.next(), Some(4));\n@@ -620,7 +620,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [0i32, 1, 2];\n     ///\n-    /// let mut iter = a.into_iter().filter(|x| x.is_positive());\n+    /// let mut iter = a.iter().filter(|x| x.is_positive());\n     ///\n     /// assert_eq!(iter.next(), Some(&1));\n     /// assert_eq!(iter.next(), Some(&2));\n@@ -634,7 +634,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [0, 1, 2];\n     ///\n-    /// let mut iter = a.into_iter().filter(|x| **x > 1); // need two *s!\n+    /// let mut iter = a.iter().filter(|x| **x > 1); // need two *s!\n     ///\n     /// assert_eq!(iter.next(), Some(&2));\n     /// assert_eq!(iter.next(), None);\n@@ -646,7 +646,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [0, 1, 2];\n     ///\n-    /// let mut iter = a.into_iter().filter(|&x| *x > 1); // both & and *\n+    /// let mut iter = a.iter().filter(|&x| *x > 1); // both & and *\n     ///\n     /// assert_eq!(iter.next(), Some(&2));\n     /// assert_eq!(iter.next(), None);\n@@ -657,7 +657,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [0, 1, 2];\n     ///\n-    /// let mut iter = a.into_iter().filter(|&&x| x > 1); // two &s\n+    /// let mut iter = a.iter().filter(|&&x| x > 1); // two &s\n     ///\n     /// assert_eq!(iter.next(), Some(&2));\n     /// assert_eq!(iter.next(), None);\n@@ -837,7 +837,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [-1i32, 0, 1];\n     ///\n-    /// let mut iter = a.into_iter().skip_while(|x| x.is_negative());\n+    /// let mut iter = a.iter().skip_while(|x| x.is_negative());\n     ///\n     /// assert_eq!(iter.next(), Some(&0));\n     /// assert_eq!(iter.next(), Some(&1));\n@@ -851,7 +851,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [-1, 0, 1];\n     ///\n-    /// let mut iter = a.into_iter().skip_while(|x| **x < 0); // need two *s!\n+    /// let mut iter = a.iter().skip_while(|x| **x < 0); // need two *s!\n     ///\n     /// assert_eq!(iter.next(), Some(&0));\n     /// assert_eq!(iter.next(), Some(&1));\n@@ -863,7 +863,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [-1, 0, 1, -2];\n     ///\n-    /// let mut iter = a.into_iter().skip_while(|x| **x < 0);\n+    /// let mut iter = a.iter().skip_while(|x| **x < 0);\n     ///\n     /// assert_eq!(iter.next(), Some(&0));\n     /// assert_eq!(iter.next(), Some(&1));\n@@ -898,7 +898,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [-1i32, 0, 1];\n     ///\n-    /// let mut iter = a.into_iter().take_while(|x| x.is_negative());\n+    /// let mut iter = a.iter().take_while(|x| x.is_negative());\n     ///\n     /// assert_eq!(iter.next(), Some(&-1));\n     /// assert_eq!(iter.next(), None);\n@@ -911,7 +911,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [-1, 0, 1];\n     ///\n-    /// let mut iter = a.into_iter().take_while(|x| **x < 0); // need two *s!\n+    /// let mut iter = a.iter().take_while(|x| **x < 0); // need two *s!\n     ///\n     /// assert_eq!(iter.next(), Some(&-1));\n     /// assert_eq!(iter.next(), None);\n@@ -922,7 +922,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [-1, 0, 1, -2];\n     ///\n-    /// let mut iter = a.into_iter().take_while(|x| **x < 0);\n+    /// let mut iter = a.iter().take_while(|x| **x < 0);\n     ///\n     /// assert_eq!(iter.next(), Some(&-1));\n     ///\n@@ -937,7 +937,7 @@ pub trait Iterator {\n     ///\n     /// ```\n     /// let a = [1, 2, 3, 4];\n-    /// let mut iter = a.into_iter();\n+    /// let mut iter = a.iter();\n     ///\n     /// let result: Vec<i32> = iter.by_ref()\n     ///                            .take_while(|n| **n != 3)\n@@ -1321,7 +1321,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3];\n     ///\n-    /// let iter = a.into_iter();\n+    /// let iter = a.iter();\n     ///\n     /// let sum: i32 = iter.take(5).fold(0, |acc, i| acc + i );\n     ///\n@@ -1334,7 +1334,7 @@ pub trait Iterator {\n     /// // let's try that again\n     /// let a = [1, 2, 3];\n     ///\n-    /// let mut iter = a.into_iter();\n+    /// let mut iter = a.iter();\n     ///\n     /// // instead, we add in a .by_ref()\n     /// let sum: i32 = iter.by_ref().take(2).fold(0, |acc, i| acc + i );\n@@ -1479,7 +1479,7 @@ pub trait Iterator {\n     /// let a = [1, 2, 3];\n     ///\n     /// let (even, odd): (Vec<i32>, Vec<i32>) = a\n-    ///     .into_iter()\n+    ///     .iter()\n     ///     .partition(|&n| n % 2 == 0);\n     ///\n     /// assert_eq!(even, vec![2]);"}, {"sha": "4a70329b64bc983a7d43b0b4214be77d892c8447", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -125,7 +125,7 @@\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n-#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n+#![feature(maybe_uninit_slice, maybe_uninit_array)]\n #![feature(external_doc)]\n \n #[prelude_import]"}, {"sha": "24bee6355a7ccfe41f9e868b32a71718b52a2fcb", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 190, "deletions": 222, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -63,62 +63,6 @@ pub use crate::intrinsics::transmute;\n /// The practical use cases for `forget` are rather specialized and mainly come\n /// up in unsafe or FFI code.\n ///\n-/// ## Use case 1\n-///\n-/// You have created an uninitialized value using [`mem::uninitialized`][uninit].\n-/// You must either initialize or `forget` it on every computation path before\n-/// Rust drops it automatically, like at the end of a scope or after a panic.\n-/// Running the destructor on an uninitialized value would be [undefined behavior][ub].\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// # let some_condition = false;\n-/// unsafe {\n-///     let mut uninit_vec: Vec<u32> = mem::uninitialized();\n-///\n-///     if some_condition {\n-///         // Initialize the variable.\n-///         ptr::write(&mut uninit_vec, Vec::new());\n-///     } else {\n-///         // Forget the uninitialized value so its destructor doesn't run.\n-///         mem::forget(uninit_vec);\n-///     }\n-/// }\n-/// ```\n-///\n-/// ## Use case 2\n-///\n-/// You have duplicated the bytes making up a value, without doing a proper\n-/// [`Clone`][clone]. You need the value's destructor to run only once,\n-/// because a double `free` is undefined behavior.\n-///\n-/// An example is a possible implementation of [`mem::swap`][swap]:\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// # #[allow(dead_code)]\n-/// fn swap<T>(x: &mut T, y: &mut T) {\n-///     unsafe {\n-///         // Give ourselves some scratch space to work with\n-///         let mut t: T = mem::uninitialized();\n-///\n-///         // Perform the swap, `&mut` pointers never alias\n-///         ptr::copy_nonoverlapping(&*x, &mut t, 1);\n-///         ptr::copy_nonoverlapping(&*y, x, 1);\n-///         ptr::copy_nonoverlapping(&t, y, 1);\n-///\n-///         // y and t now point to the same thing, but we need to completely\n-///         // forget `t` because we do not want to run the destructor for `T`\n-///         // on its value, which is still owned somewhere outside this function.\n-///         mem::forget(t);\n-///     }\n-/// }\n-/// ```\n-///\n /// [drop]: fn.drop.html\n /// [uninit]: fn.uninitialized.html\n /// [clone]: ../clone/trait.Clone.html\n@@ -465,29 +409,37 @@ pub const fn needs_drop<T>() -> bool {\n \n /// Creates a value whose bytes are all zero.\n ///\n-/// This has the same effect as allocating space with\n-/// [`mem::uninitialized`][uninit] and then zeroing it out. It is useful for\n-/// FFI sometimes, but should generally be avoided.\n+/// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n+/// It is useful for FFI sometimes, but should generally be avoided.\n ///\n /// There is no guarantee that an all-zero byte-pattern represents a valid value of\n-/// some type `T`. If `T` has a destructor and the value is destroyed (due to\n-/// a panic or the end of a scope) before being initialized, then the destructor\n-/// will run on zeroed data, likely leading to [undefined behavior][ub].\n-///\n-/// See also the documentation for [`mem::uninitialized`][uninit], which has\n-/// many of the same caveats.\n+/// some type `T`. For example, the all-zero byte-pattern is not a valid value\n+/// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n+/// causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv]\n+/// that there always is a valid value in a variable it considers initialized.\n ///\n-/// [uninit]: fn.uninitialized.html\n+/// [zeroed]: union.MaybeUninit.html#method.zeroed\n /// [ub]: ../../reference/behavior-considered-undefined.html\n+/// [inv]: union.MaybeUninit.html#initialization-invariant\n ///\n /// # Examples\n ///\n+/// Correct usage of this function: initializing an integer with zero.\n+///\n /// ```\n /// use std::mem;\n ///\n /// let x: i32 = unsafe { mem::zeroed() };\n /// assert_eq!(0, x);\n /// ```\n+///\n+/// *Incorrect* usage of this function: initializing a reference with zero.\n+///\n+/// ```no_run\n+/// use std::mem;\n+///\n+/// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn zeroed<T>() -> T {\n@@ -498,130 +450,23 @@ pub unsafe fn zeroed<T>() -> T {\n /// Bypasses Rust's normal memory-initialization checks by pretending to\n /// produce a value of type `T`, while doing nothing at all.\n ///\n-/// **This is incredibly dangerous and should not be done lightly. Deeply\n-/// consider initializing your memory with a default value instead.**\n-///\n-/// This is useful for FFI functions and initializing arrays sometimes,\n-/// but should generally be avoided.\n-///\n-/// # Undefined behavior\n-///\n-/// It is [undefined behavior][ub] to read uninitialized memory, even just an\n-/// uninitialized boolean. For instance, if you branch on the value of such\n-/// a boolean, your program may take one, both, or neither of the branches.\n-///\n-/// Writing to the uninitialized value is similarly dangerous. Rust believes the\n-/// value is initialized, and will therefore try to [`Drop`] the uninitialized\n-/// value and its fields if you try to overwrite it in a normal manner. The only way\n-/// to safely initialize an uninitialized value is with [`ptr::write`][write],\n-/// [`ptr::copy`][copy], or [`ptr::copy_nonoverlapping`][copy_no].\n-///\n-/// If the value does implement [`Drop`], it must be initialized before\n-/// it goes out of scope (and therefore would be dropped). Note that this\n-/// includes a `panic` occurring and unwinding the stack suddenly.\n+/// **This functon is deprecated.** Use [`MaybeUninit<T>`] instead.\n ///\n-/// If you partially initialize an array, you may need to use\n-/// [`ptr::drop_in_place`][drop_in_place] to remove the elements you have fully\n-/// initialized followed by [`mem::forget`][mem_forget] to prevent drop running\n-/// on the array. If a partially allocated array is dropped this will lead to\n-/// undefined behaviour.\n-///\n-/// # Examples\n-///\n-/// Here's how to safely initialize an array of [`Vec`]s.\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// // Only declare the array. This safely leaves it\n-/// // uninitialized in a way that Rust will track for us.\n-/// // However we can't initialize it element-by-element\n-/// // safely, and we can't use the `[value; 1000]`\n-/// // constructor because it only works with `Copy` data.\n-/// let mut data: [Vec<u32>; 1000];\n-///\n-/// unsafe {\n-///     // So we need to do this to initialize it.\n-///     data = mem::uninitialized();\n-///\n-///     // DANGER ZONE: if anything panics or otherwise\n-///     // incorrectly reads the array here, we will have\n-///     // Undefined Behavior.\n-///\n-///     // It's ok to mutably iterate the data, since this\n-///     // doesn't involve reading it at all.\n-///     // (ptr and len are statically known for arrays)\n-///     for elem in &mut data[..] {\n-///         // *elem = Vec::new() would try to drop the\n-///         // uninitialized memory at `elem` -- bad!\n-///         //\n-///         // Vec::new doesn't allocate or do really\n-///         // anything. It's only safe to call here\n-///         // because we know it won't panic.\n-///         ptr::write(elem, Vec::new());\n-///     }\n-///\n-///     // SAFE ZONE: everything is initialized.\n-/// }\n-///\n-/// println!(\"{:?}\", &data[0]);\n-/// ```\n-///\n-/// This example emphasizes exactly how delicate and dangerous using `mem::uninitialized`\n-/// can be. Note that the [`vec!`] macro *does* let you initialize every element with a\n-/// value that is only [`Clone`], so the following is semantically equivalent and\n-/// vastly less dangerous, as long as you can live with an extra heap\n-/// allocation:\n-///\n-/// ```\n-/// let data: Vec<Vec<u32>> = vec![Vec::new(); 1000];\n-/// println!(\"{:?}\", &data[0]);\n-/// ```\n-///\n-/// This example shows how to handle partially initialized arrays, which could\n-/// be found in low-level datastructures.\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// // Count the number of elements we have assigned.\n-/// let mut data_len: usize = 0;\n-/// let mut data: [String; 1000];\n-///\n-/// unsafe {\n-///     data = mem::uninitialized();\n-///\n-///     for elem in &mut data[0..500] {\n-///         ptr::write(elem, String::from(\"hello\"));\n-///         data_len += 1;\n-///     }\n-///\n-///     // For each item in the array, drop if we allocated it.\n-///     for i in &mut data[0..data_len] {\n-///         ptr::drop_in_place(i);\n-///     }\n-/// }\n-/// // Forget the data. If this is allowed to drop, you may see a crash such as:\n-/// // 'mem_uninit_test(2457,0x7fffb55dd380) malloc: *** error for object\n-/// // 0x7ff3b8402920: pointer being freed was not allocated'\n-/// mem::forget(data);\n-/// ```\n+/// The reason for deprecation is that the function basically cannot be used\n+/// correctly: [the Rust compiler assumes][inv] that values are properly initialized.\n+/// As a consequence, calling e.g. `mem::uninitialized::<bool>()` causes immediate\n+/// undefined behavior for returning a `bool` that is not definitely either `true`\n+/// or `false`. Worse, truly uninitialized memory like what gets returned here\n+/// is special in that the compiler knows that it does not have a fixed value.\n+/// This makes it undefined behavior to have uninitialized data in a variable even\n+/// if that variable has an integer type.\n+/// (Notice that the rules around uninitialized integers are not finalized yet, but\n+/// until they are, it is advisable to avoid them.)\n ///\n-/// [`Vec`]: ../../std/vec/struct.Vec.html\n-/// [`vec!`]: ../../std/macro.vec.html\n-/// [`Clone`]: ../../std/clone/trait.Clone.html\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-/// [write]: ../ptr/fn.write.html\n-/// [drop_in_place]: ../ptr/fn.drop_in_place.html\n-/// [mem_zeroed]: fn.zeroed.html\n-/// [mem_forget]: fn.forget.html\n-/// [copy]: ../intrinsics/fn.copy.html\n-/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n-/// [`Drop`]: ../ops/trait.Drop.html\n+/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n+/// [inv]: union.MaybeUninit.html#initialization-invariant\n #[inline]\n-#[rustc_deprecated(since = \"2.0.0\", reason = \"use `mem::MaybeUninit::uninit` instead\")]\n+#[rustc_deprecated(since = \"1.40.0\", reason = \"use `mem::MaybeUninit` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::panic_if_uninhabited::<T>();\n@@ -899,7 +744,6 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n     }\n }\n \n-// FIXME: Reference `MaybeUninit` from these docs, once that is stable.\n /// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n ///\n /// This wrapper is 0-cost.\n@@ -908,6 +752,7 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n /// As a consequence, it has *no effect* on the assumptions that the compiler makes\n /// about all values being initialized at their type.  In particular, initializing\n /// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n+/// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n ///\n /// # Examples\n ///\n@@ -942,6 +787,7 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n /// ```\n ///\n /// [`mem::zeroed`]: fn.zeroed.html\n+/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n #[lang = \"manually_drop\"]\n #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -1042,17 +888,18 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n     }\n }\n \n-/// A wrapper to construct uninitialized instances of `T`.\n+/// A wrapper type to construct uninitialized instances of `T`.\n+///\n+/// # Initialization invariant\n ///\n /// The compiler, in general, assumes that variables are properly initialized\n /// at their respective type. For example, a variable of reference type must\n /// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n /// even in unsafe code. As a consequence, zero-initializing a variable of reference\n-/// type causes instantaneous undefined behavior, no matter whether that reference\n+/// type causes instantaneous [undefined behavior][ub], no matter whether that reference\n /// ever gets used to access memory:\n ///\n /// ```rust,no_run\n-/// #![feature(maybe_uninit)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n@@ -1067,7 +914,6 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n ///\n /// ```rust,no_run\n-/// #![feature(maybe_uninit)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n@@ -1078,10 +924,9 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// Moreover, uninitialized memory is special in that the compiler knows that\n /// it does not have a fixed value. This makes it undefined behavior to have\n /// uninitialized data in a variable even if that variable has an integer type,\n-/// which otherwise can hold any bit pattern:\n+/// which otherwise can hold any *fixed* bit pattern:\n ///\n /// ```rust,no_run\n-/// #![feature(maybe_uninit)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n@@ -1091,37 +936,154 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// (Notice that the rules around uninitialized integers are not finalized yet, but\n /// until they are, it is advisable to avoid them.)\n ///\n+/// On top of that, remember that most types have additional invariants beyond merely\n+/// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n+/// is considered initialized because the only requirement the compiler knows about it\n+/// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n+/// *immediate* undefined behavior, but will cause undefined behavior with most\n+/// safe operations (including dropping it).\n+///\n+/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+///\n+/// # Examples\n+///\n /// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n /// It is a signal to the compiler indicating that the data here might *not*\n /// be initialized:\n ///\n /// ```rust\n-/// #![feature(maybe_uninit)]\n /// use std::mem::MaybeUninit;\n ///\n /// // Create an explicitly uninitialized reference. The compiler knows that data inside\n /// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n /// let mut x = MaybeUninit::<&i32>::uninit();\n /// // Set it to a valid value.\n-/// x.write(&0);\n+/// unsafe { x.as_mut_ptr().write(&0); }\n /// // Extract the initialized data -- this is only allowed *after* properly\n /// // initializing `x`!\n /// let x = unsafe { x.assume_init() };\n /// ```\n ///\n /// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n-//\n-// FIXME before stabilizing, explain how to initialize a struct field-by-field.\n+///\n+/// ## out-pointers\n+///\n+/// You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data\n+/// from a function, pass it a pointer to some (uninitialized) memory to put the\n+/// result into. This can be useful when it is important for the caller to control\n+/// how the memory the result is stored in gets allocated, and you want to avoid\n+/// unnecessary moves.\n+///\n+/// ```\n+/// use std::mem::MaybeUninit;\n+///\n+/// unsafe fn make_vec(out: *mut Vec<i32>) {\n+///     // `write` does not drop the old contents, which is important.\n+///     out.write(vec![1, 2, 3]);\n+/// }\n+///\n+/// let mut v: MaybeUninit<Vec<i32>> = MaybeUninit::uninit();\n+/// unsafe { make_vec(v.as_mut_ptr()); }\n+/// // Now we know `v` is initialized! This also makes sure the vector gets\n+/// // properly dropped.\n+/// let v = unsafe { v.assume_init() };\n+/// assert_eq!(&v, &[1, 2, 3]);\n+/// ```\n+///\n+/// ## Initializing an array element-by-element\n+///\n+/// `MaybeUninit<T>` can be used to initialize a large array element-by-element:\n+///\n+/// ```\n+/// use std::mem::{self, MaybeUninit};\n+/// use std::ptr;\n+///\n+/// let data = {\n+///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n+///     // safe because the type we are claiming to have initialized here is a\n+///     // bunch of `MaybeUninit`s, which do not require initialization.\n+///     let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {\n+///         MaybeUninit::uninit().assume_init()\n+///     };\n+///\n+///     // Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n+///     // we have a memory leak, but there is no memory safety issue.\n+///     for elem in &mut data[..] {\n+///         unsafe { ptr::write(elem.as_mut_ptr(), vec![42]); }\n+///     }\n+///\n+///     // Everything is initialized. Transmute the array to the\n+///     // initialized type.\n+///     unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\n+/// };\n+///\n+/// assert_eq!(&data[0], &[42]);\n+/// ```\n+///\n+/// You can also work with partially initialized arrays, which could\n+/// be found in low-level datastructures.\n+///\n+/// ```\n+/// use std::mem::MaybeUninit;\n+/// use std::ptr;\n+///\n+/// // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n+/// // safe because the type we are claiming to have initialized here is a\n+/// // bunch of `MaybeUninit`s, which do not require initialization.\n+/// let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };\n+/// // Count the number of elements we have assigned.\n+/// let mut data_len: usize = 0;\n+///\n+/// for elem in &mut data[0..500] {\n+///     unsafe { ptr::write(elem.as_mut_ptr(), String::from(\"hello\")); }\n+///     data_len += 1;\n+/// }\n+///\n+/// // For each item in the array, drop if we allocated it.\n+/// for elem in &mut data[0..data_len] {\n+///     unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\n+/// }\n+/// ```\n+///\n+/// ## Initializing a struct field-by-field\n+///\n+/// There is currently no supported way to create a raw pointer or reference\n+/// to a field of a struct inside `MaybeUninit<Struct>`. That means it is not possible\n+/// to create a struct by calling `MaybeUninit::uninit::<Struct>()` and then writing\n+/// to its fields.\n+///\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+///\n+/// # Layout\n+///\n+/// `MaybeUninit<T>` is guaranteed to have the same size and alignment as `T`:\n+///\n+/// ```rust\n+/// use std::mem::{MaybeUninit, size_of, align_of};\n+/// assert_eq!(size_of::<MaybeUninit<u64>>(), size_of::<u64>());\n+/// assert_eq!(align_of::<MaybeUninit<u64>>(), align_of::<u64>());\n+/// ```\n+///\n+/// However remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same\n+/// layout; Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as\n+/// a `Foo<U>` even if `T` and `U` have the same size and alignment. Furthermore because any bit\n+/// value is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling\n+/// optimizations, potentially resulting in a larger size:\n+///\n+/// ```rust\n+/// # use std::mem::{MaybeUninit, size_of, align_of};\n+/// assert_eq!(size_of::<Option<bool>>(), 1);\n+/// assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n+/// ```\n #[allow(missing_debug_implementations)]\n-#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n #[derive(Copy)]\n-// NOTE: after stabilizing `MaybeUninit`, proceed to deprecate `mem::uninitialized`.\n pub union MaybeUninit<T> {\n     uninit: (),\n     value: ManuallyDrop<T>,\n }\n \n-#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n impl<T: Copy> Clone for MaybeUninit<T> {\n     #[inline(always)]\n     fn clone(&self) -> Self {\n@@ -1132,10 +1094,13 @@ impl<T: Copy> Clone for MaybeUninit<T> {\n \n impl<T> MaybeUninit<T> {\n     /// Creates a new `MaybeUninit<T>` initialized with the given value.\n+    /// It is safe to call [`assume_init`] on the return value of this function.\n     ///\n     /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    ///\n+    /// [`assume_init`]: #method.assume_init\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub const fn new(val: T) -> MaybeUninit<T> {\n         MaybeUninit { value: ManuallyDrop::new(val) }\n@@ -1145,7 +1110,11 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    ///\n+    /// See the [type-level documentation][type] for some examples.\n+    ///\n+    /// [type]: union.MaybeUninit.html\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub const fn uninit() -> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n@@ -1166,7 +1135,6 @@ impl<T> MaybeUninit<T> {\n     /// fields of the struct can hold the bit-pattern 0 as a valid value.\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n@@ -1178,7 +1146,6 @@ impl<T> MaybeUninit<T> {\n     /// cannot hold 0 as a valid value.\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// enum NotZero { One = 1, Two = 2 };\n@@ -1188,7 +1155,7 @@ impl<T> MaybeUninit<T> {\n     /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n     /// // This is undefined behavior.\n     /// ```\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline]\n     pub fn zeroed() -> MaybeUninit<T> {\n         let mut u = MaybeUninit::<T>::uninit();\n@@ -1202,7 +1169,7 @@ impl<T> MaybeUninit<T> {\n     /// without dropping it, so be careful not to use this twice unless you want to\n     /// skip running the destructor. For your convenience, this also returns a mutable\n     /// reference to the (now safely initialized) contents of `self`.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn write(&mut self, val: T) -> &mut T {\n         unsafe {\n@@ -1213,13 +1180,14 @@ impl<T> MaybeUninit<T> {\n \n     /// Gets a pointer to the contained value. Reading from this pointer or turning it\n     /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    /// Writing to memory that this pointer (non-transitively) points to is undefined behavior\n+    /// (except inside an `UnsafeCell<T>`).\n     ///\n     /// # Examples\n     ///\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n@@ -1232,7 +1200,6 @@ impl<T> MaybeUninit<T> {\n     /// *Incorrect* usage of this method:\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let x = MaybeUninit::<Vec<u32>>::uninit();\n@@ -1242,7 +1209,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub fn as_ptr(&self) -> *const T {\n         unsafe { &*self.value as *const T }\n@@ -1256,7 +1223,6 @@ impl<T> MaybeUninit<T> {\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n@@ -1271,7 +1237,6 @@ impl<T> MaybeUninit<T> {\n     /// *Incorrect* usage of this method:\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n@@ -1281,7 +1246,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         unsafe { &mut *self.value as *mut T }\n@@ -1294,15 +1259,17 @@ impl<T> MaybeUninit<T> {\n     /// # Safety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n+    /// state. Calling this when the content is not yet fully initialized causes immediate undefined\n+    /// behavior. The [type-level documentation][inv] contains more information about\n+    /// this initialization invariant.\n+    ///\n+    /// [inv]: #initialization-invariant\n     ///\n     /// # Examples\n     ///\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<bool>::uninit();\n@@ -1314,14 +1281,13 @@ impl<T> MaybeUninit<T> {\n     /// *Incorrect* usage of this method:\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let x = MaybeUninit::<Vec<u32>>::uninit();\n     /// let x_init = unsafe { x.assume_init() };\n     /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n     /// ```\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub unsafe fn assume_init(self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n@@ -1338,21 +1304,23 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n+    /// behavior. The [type-level documentation][inv] contains more information about\n+    /// this initialization invariant.\n     ///\n     /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n     /// multiple copies of the data (by calling `read` multiple times, or first\n     /// calling `read` and then [`assume_init`]), it is your responsibility\n     /// to ensure that that data may indeed be duplicated.\n     ///\n+    /// [inv]: #initialization-invariant\n     /// [`assume_init`]: #method.assume_init\n     ///\n     /// # Examples\n     ///\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n+    /// #![feature(maybe_uninit_extra)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<u32>::uninit();\n@@ -1373,7 +1341,7 @@ impl<T> MaybeUninit<T> {\n     /// *Incorrect* usage of this method:\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n+    /// #![feature(maybe_uninit_extra)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n@@ -1383,7 +1351,7 @@ impl<T> MaybeUninit<T> {\n     /// // We now created two copies of the same vector, leading to a double-free when\n     /// // they both get dropped!\n     /// ```\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn read(&self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();"}, {"sha": "006b1e143eeec54772b4f7d06c385ad3b6c53c3f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -155,12 +155,12 @@ pub use crate::intrinsics::write_bytes;\n /// location first:\n /// ```\n /// use std::ptr;\n-/// use std::mem;\n+/// use std::mem::{self, MaybeUninit};\n ///\n /// unsafe fn drop_after_copy<T>(to_drop: *mut T) {\n-///     let mut copy: T = mem::uninitialized();\n-///     ptr::copy(to_drop, &mut copy, 1);\n-///     drop(copy);\n+///     let mut copy: MaybeUninit<T> = MaybeUninit::uninit();\n+///     ptr::copy(to_drop, copy.as_mut_ptr(), 1);\n+///     drop(copy.assume_init());\n /// }\n ///\n /// #[repr(packed, C)]\n@@ -374,10 +374,7 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n     // #[repr(simd)], even if we don't actually use this struct directly.\n     //\n     // FIXME repr(simd) broken on emscripten and redox\n-    // It's also broken on big-endian powerpc64 and s390x.  #42778\n-    #[cfg_attr(not(any(target_os = \"emscripten\", target_os = \"redox\",\n-                       target_endian = \"big\")),\n-               repr(simd))]\n+    #[cfg_attr(not(any(target_os = \"emscripten\", target_os = \"redox\")), repr(simd))]\n     struct Block(u64, u64, u64, u64);\n     struct UnalignedBlock(u64, u64, u64, u64);\n \n@@ -813,9 +810,6 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n-/// Memory accessed with `read_volatile` or [`write_volatile`] should not be\n-/// accessed with non-volatile operations.\n-///\n /// [`write_volatile`]: ./fn.write_volatile.html\n ///\n /// # Notes\n@@ -840,7 +834,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// * `src` must be properly aligned.\n ///\n-/// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n+/// Like [`read`], `read_volatile` creates a bitwise copy of `T`, regardless of\n /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership].\n /// However, storing non-[`Copy`] types in volatile memory is almost certainly\n@@ -884,9 +878,6 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n-/// Memory accessed with [`read_volatile`] or `write_volatile` should not be\n-/// accessed with non-volatile operations.\n-///\n /// `write_volatile` does not drop the contents of `dst`. This is safe, but it\n /// could leak allocations or resources, so care should be taken not to overwrite\n /// an object that should be dropped.\n@@ -2973,7 +2964,6 @@ impl<T: Sized> NonNull<T> {\n     /// some other means.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n-    #[rustc_const_unstable(feature = \"const_ptr_nonnull\")]\n     pub const fn dangling() -> Self {\n         unsafe {\n             let ptr = mem::align_of::<T>() as *mut T;\n@@ -3037,7 +3027,6 @@ impl<T: ?Sized> NonNull<T> {\n     /// Cast to a pointer of another type\n     #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n     #[inline]\n-    #[rustc_const_unstable(feature = \"const_ptr_nonnull\")]\n     pub const fn cast<U>(self) -> NonNull<U> {\n         unsafe {\n             NonNull::new_unchecked(self.as_ptr() as *mut U)"}, {"sha": "d06d107d32a41cabbe8a3fca7e35bf6ed950d277", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -359,6 +359,10 @@ impl<T> [T] {\n     /// The caller must ensure that the slice outlives the pointer this\n     /// function returns, or else it will end up pointing to garbage.\n     ///\n+    /// The caller must also ensure that the memory the pointer (non-transitively) points to\n+    /// is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n+    /// derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n+    ///\n     /// Modifying the container referenced by this slice may cause its buffer\n     /// to be reallocated, which would also make any pointers to it invalid.\n     ///\n@@ -374,6 +378,8 @@ impl<T> [T] {\n     ///     }\n     /// }\n     /// ```\n+    ///\n+    /// [`as_mut_ptr`]: #method.as_mut_ptr\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub const fn as_ptr(&self) -> *const T {\n@@ -3541,6 +3547,11 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n             (1, Some(self.v.len() + 1))\n         }\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -3639,6 +3650,11 @@ impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n             (1, Some(self.v.len() + 1))\n         }\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -3704,6 +3720,11 @@ impl<'a, T, P> Iterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n@@ -3768,6 +3789,11 @@ impl<'a, T, P> Iterator for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]"}, {"sha": "0e8a2da3c110d70a413a0a8b9ae76909116a982a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1333,6 +1333,11 @@ impl<'a> Iterator for Lines<'a> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.0.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1379,6 +1384,11 @@ impl<'a> Iterator for LinesAny<'a> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.0.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2188,7 +2198,11 @@ impl str {\n     /// [`u8`]. This pointer will be pointing to the first byte of the string\n     /// slice.\n     ///\n+    /// The caller must ensure that the returned pointer is never written to.\n+    /// If you need to mutate the contents of the string slice, use [`as_mut_ptr`].\n+    ///\n     /// [`u8`]: primitive.u8.html\n+    /// [`as_mut_ptr`]: #method.as_mut_ptr\n     ///\n     /// # Examples\n     ///\n@@ -4217,6 +4231,11 @@ impl<'a> Iterator for SplitWhitespace<'a> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n@@ -4243,6 +4262,11 @@ impl<'a> Iterator for SplitAsciiWhitespace<'a> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]"}, {"sha": "a6d611d2e93c4b83847a9791a39a28bb1a270e14", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -10,6 +10,8 @@ use crate::marker::{PhantomData, Unpin};\n ///\n /// It consists of a data pointer and a [virtual function pointer table (vtable)][vtable] that\n /// customizes the behavior of the `RawWaker`.\n+///\n+/// [`Waker`]: struct.Waker.html\n #[derive(PartialEq, Debug)]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub struct RawWaker {\n@@ -55,6 +57,8 @@ impl RawWaker {\n /// pointer of a properly constructed [`RawWaker`] object from inside the\n /// [`RawWaker`] implementation. Calling one of the contained functions using\n /// any other `data` pointer will cause undefined behavior.\n+///\n+/// [`RawWaker`]: struct.RawWaker.html\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n #[derive(PartialEq, Copy, Clone, Debug)]\n pub struct RawWakerVTable {\n@@ -65,6 +69,9 @@ pub struct RawWakerVTable {\n     /// required for this additional instance of a [`RawWaker`] and associated\n     /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup\n     /// of the same task that would have been awoken by the original [`RawWaker`].\n+    ///\n+    /// [`Waker`]: struct.Waker.html\n+    /// [`RawWaker`]: struct.RawWaker.html\n     clone: unsafe fn(*const ()) -> RawWaker,\n \n     /// This function will be called when `wake` is called on the [`Waker`].\n@@ -73,20 +80,28 @@ pub struct RawWakerVTable {\n     /// The implementation of this function must make sure to release any\n     /// resources that are associated with this instance of a [`RawWaker`] and\n     /// associated task.\n+    ///\n+    /// [`Waker`]: struct.Waker.html\n+    /// [`RawWaker`]: struct.RawWaker.html\n     wake: unsafe fn(*const ()),\n \n     /// This function will be called when `wake_by_ref` is called on the [`Waker`].\n     /// It must wake up the task associated with this [`RawWaker`].\n     ///\n     /// This function is similar to `wake`, but must not consume the provided data\n     /// pointer.\n+    ///\n+    /// [`Waker`]: struct.Waker.html\n+    /// [`RawWaker`]: struct.RawWaker.html\n     wake_by_ref: unsafe fn(*const ()),\n \n     /// This function gets called when a [`RawWaker`] gets dropped.\n     ///\n     /// The implementation of this function must make sure to release any\n     /// resources that are associated with this instance of a [`RawWaker`] and\n     /// associated task.\n+    ///\n+    /// [`RawWaker`]: struct.RawWaker.html\n     drop: unsafe fn(*const ()),\n }\n \n@@ -128,6 +143,9 @@ impl RawWakerVTable {\n     /// The implementation of this function must make sure to release any\n     /// resources that are associated with this instance of a [`RawWaker`] and\n     /// associated task.\n+    ///\n+    /// [`Waker`]: struct.Waker.html\n+    /// [`RawWaker`]: struct.RawWaker.html\n     #[rustc_promotable]\n     #[cfg_attr(stage0, unstable(feature = \"futures_api_const_fn_ptr\", issue = \"50547\"))]\n     #[cfg_attr(not(stage0), stable(feature = \"futures_api\", since = \"1.36.0\"))]\n@@ -201,6 +219,8 @@ impl fmt::Debug for Context<'_> {\n /// executor-specific wakeup behavior.\n ///\n /// Implements [`Clone`], [`Send`], and [`Sync`].\n+///\n+/// [`RawWaker`]: struct.RawWaker.html\n #[repr(transparent)]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub struct Waker {\n@@ -266,6 +286,9 @@ impl Waker {\n     /// The behavior of the returned `Waker` is undefined if the contract defined\n     /// in [`RawWaker`]'s and [`RawWakerVTable`]'s documentation is not upheld.\n     /// Therefore this method is unsafe.\n+    ///\n+    /// [`RawWaker`]: struct.RawWaker.html\n+    /// [`RawWakerVTable`]: struct.RawWakerVTable.html\n     #[inline]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub unsafe fn from_raw(waker: RawWaker) -> Waker {"}, {"sha": "63537ba23d84dc0edfabc9384a45e7a7a2249b7b", "filename": "src/libcore/tests/alloc.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Ftests%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Ftests%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Falloc.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -0,0 +1,10 @@\n+use core::alloc::Layout;\n+\n+#[test]\n+fn const_unchecked_layout() {\n+    const SIZE: usize = 0x2000;\n+    const ALIGN: usize = 0x1000;\n+    const LAYOUT: Layout = unsafe { Layout::from_size_align_unchecked(SIZE, ALIGN) };\n+    assert_eq!(LAYOUT.size(), SIZE);\n+    assert_eq!(LAYOUT.align(), ALIGN);\n+}"}, {"sha": "c617596aba80159af2ecb5f3c4967bc099897f8f", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -31,10 +31,12 @@\n #![feature(slice_partition_dedup)]\n #![feature(copy_within)]\n #![feature(int_error_matching)]\n-#![deny(rust_2018_idioms)]\n+#![feature(const_fn)]\n+#![warn(rust_2018_idioms)]\n \n extern crate test;\n \n+mod alloc;\n mod any;\n mod array;\n mod ascii;"}, {"sha": "4d50e80d4cf674e858b22701cc60222589a1c9d4", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -36,7 +36,7 @@ byteorder = { version = \"1.1\", features = [\"i128\"]}\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n-measureme = \"0.2.1\"\n+measureme = \"0.3\"\n \n # Note that these dependencies are a lie, they're just here to get linkage to\n # work."}, {"sha": "2e54165be1f1baf485b42ac331c8922ae7694b2e", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -166,47 +166,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.hir_id.local_id, &[blk_exit])\n             }\n \n-            hir::ExprKind::If(ref cond, ref then, None) => {\n-                //\n-                //     [pred]\n-                //       |\n-                //       v 1\n-                //     [cond]\n-                //       |\n-                //      / \\\n-                //     /   \\\n-                //    v 2   *\n-                //  [then]  |\n-                //    |     |\n-                //    v 3   v 4\n-                //   [..expr..]\n-                //\n-                let cond_exit = self.expr(&cond, pred);                // 1\n-                let then_exit = self.expr(&then, cond_exit);          // 2\n-                self.add_ast_node(expr.hir_id.local_id, &[cond_exit, then_exit])      // 3,4\n-            }\n-\n-            hir::ExprKind::If(ref cond, ref then, Some(ref otherwise)) => {\n-                //\n-                //     [pred]\n-                //       |\n-                //       v 1\n-                //     [cond]\n-                //       |\n-                //      / \\\n-                //     /   \\\n-                //    v 2   v 3\n-                //  [then][otherwise]\n-                //    |     |\n-                //    v 4   v 5\n-                //   [..expr..]\n-                //\n-                let cond_exit = self.expr(&cond, pred);                // 1\n-                let then_exit = self.expr(&then, cond_exit);          // 2\n-                let else_exit = self.expr(&otherwise, cond_exit);      // 3\n-                self.add_ast_node(expr.hir_id.local_id, &[then_exit, else_exit])      // 4, 5\n-            }\n-\n             hir::ExprKind::While(ref cond, ref body, _) => {\n                 //\n                 //         [pred]"}, {"sha": "b199eee6dad87a2285f099fac8a22274264fdedb", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -12,6 +12,7 @@ use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use std::fmt::{self, Display};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -95,18 +96,18 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn || target == Target::Const {\n             self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n-        } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(\"target_feature\")) {\n+        } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(sym::target_feature)) {\n             self.tcx.sess.struct_span_err(a.span, \"attribute should be applied to a function\")\n                 .span_label(item.span, \"not a function\")\n                 .emit();\n         }\n \n         for attr in &item.attrs {\n-            if attr.check_name(\"inline\") {\n+            if attr.check_name(sym::inline) {\n                 self.check_inline(attr, &item.span, target)\n-            } else if attr.check_name(\"non_exhaustive\") {\n+            } else if attr.check_name(sym::non_exhaustive) {\n                 self.check_non_exhaustive(attr, item, target)\n-            } else if attr.check_name(\"marker\") {\n+            } else if attr.check_name(sym::marker) {\n                 self.check_marker(attr, item, target)\n             }\n         }\n@@ -166,7 +167,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         // ```\n         let hints: Vec<_> = item.attrs\n             .iter()\n-            .filter(|attr| attr.check_name(\"repr\"))\n+            .filter(|attr| attr.check_name(sym::repr))\n             .filter_map(|attr| attr.meta_item_list())\n             .flatten()\n             .collect();\n@@ -177,9 +178,9 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         let mut is_transparent = false;\n \n         for hint in &hints {\n-            let (article, allowed_targets) = match hint.name_or_empty().get() {\n-                name @ \"C\" | name @ \"align\" => {\n-                    is_c |= name == \"C\";\n+            let (article, allowed_targets) = match hint.name_or_empty() {\n+                name @ sym::C | name @ sym::align => {\n+                    is_c |= name == sym::C;\n                     if target != Target::Struct &&\n                             target != Target::Union &&\n                             target != Target::Enum {\n@@ -188,33 +189,33 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                         continue\n                     }\n                 }\n-                \"packed\" => {\n+                sym::packed => {\n                     if target != Target::Struct &&\n                             target != Target::Union {\n                                 (\"a\", \"struct or union\")\n                     } else {\n                         continue\n                     }\n                 }\n-                \"simd\" => {\n+                sym::simd => {\n                     is_simd = true;\n                     if target != Target::Struct {\n                         (\"a\", \"struct\")\n                     } else {\n                         continue\n                     }\n                 }\n-                \"transparent\" => {\n+                sym::transparent => {\n                     is_transparent = true;\n                     if target != Target::Struct {\n                         (\"a\", \"struct\")\n                     } else {\n                         continue\n                     }\n                 }\n-                \"i8\"  | \"u8\"  | \"i16\" | \"u16\" |\n-                \"i32\" | \"u32\" | \"i64\" | \"u64\" |\n-                \"isize\" | \"usize\" => {\n+                sym::i8  | sym::u8  | sym::i16 | sym::u16 |\n+                sym::i32 | sym::u32 | sym::i64 | sym::u64 |\n+                sym::isize | sym::usize => {\n                     int_reprs += 1;\n                     if target != Target::Enum {\n                         (\"an\", \"enum\")\n@@ -268,10 +269,10 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         // When checking statements ignore expressions, they will be checked later\n         if let hir::StmtKind::Local(ref l) = stmt.node {\n             for attr in l.attrs.iter() {\n-                if attr.check_name(\"inline\") {\n+                if attr.check_name(sym::inline) {\n                     self.check_inline(attr, &stmt.span, Target::Statement);\n                 }\n-                if attr.check_name(\"repr\") {\n+                if attr.check_name(sym::repr) {\n                     self.emit_repr_error(\n                         attr.span,\n                         stmt.span,\n@@ -289,10 +290,10 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n             _ => Target::Expression,\n         };\n         for attr in expr.attrs.iter() {\n-            if attr.check_name(\"inline\") {\n+            if attr.check_name(sym::inline) {\n                 self.check_inline(attr, &expr.span, target);\n             }\n-            if attr.check_name(\"repr\") {\n+            if attr.check_name(sym::repr) {\n                 self.emit_repr_error(\n                     attr.span,\n                     expr.span,\n@@ -305,7 +306,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n     fn check_used(&self, item: &hir::Item, target: Target) {\n         for attr in &item.attrs {\n-            if attr.check_name(\"used\") && target != Target::Static {\n+            if attr.check_name(sym::used) && target != Target::Static {\n                 self.tcx.sess\n                     .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n             }"}, {"sha": "0c4f5fb3fc167bd701087e504c7fa5feab06c876", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 12, "deletions": 34, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -96,34 +96,20 @@ impl fmt::Display for CrateNum {\n impl serialize::UseSpecializedEncodable for CrateNum {}\n impl serialize::UseSpecializedDecodable for CrateNum {}\n \n-/// A DefIndex is an index into the hir-map for a crate, identifying a\n-/// particular definition. It should really be considered an interned\n-/// shorthand for a particular DefPath.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n-pub struct DefIndex(u32);\n-\n-/// The crate root is always assigned index 0 by the AST Map code,\n-/// thanks to `NodeCollector::new`.\n-pub const CRATE_DEF_INDEX: DefIndex = DefIndex(0);\n+newtype_index! {\n+    /// A DefIndex is an index into the hir-map for a crate, identifying a\n+    /// particular definition. It should really be considered an interned\n+    /// shorthand for a particular DefPath.\n+    pub struct DefIndex {\n+        DEBUG_FORMAT = \"DefIndex({})\",\n \n-impl fmt::Debug for DefIndex {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"DefIndex({})\", self.as_array_index())\n+        /// The crate root is always assigned index 0 by the AST Map code,\n+        /// thanks to `NodeCollector::new`.\n+        const CRATE_DEF_INDEX = 0,\n     }\n }\n \n impl DefIndex {\n-    /// Converts this DefIndex into a zero-based array index.\n-    #[inline]\n-    pub fn as_array_index(&self) -> usize {\n-        self.0 as usize\n-    }\n-\n-    #[inline]\n-    pub fn from_array_index(i: usize) -> DefIndex {\n-        DefIndex(i as u32)\n-    }\n-\n     // Proc macros from a proc-macro crate have a kind of virtual DefIndex. This\n     // function maps the index of the macro within the crate (which is also the\n     // index of the macro in the CrateMetadata::proc_macros array) to the\n@@ -132,7 +118,7 @@ impl DefIndex {\n         // DefIndex for proc macros start from FIRST_FREE_DEF_INDEX,\n         // because the first FIRST_FREE_DEF_INDEX indexes are reserved\n         // for internal use.\n-        let def_index = DefIndex::from_array_index(\n+        let def_index = DefIndex::from(\n             proc_macro_index.checked_add(FIRST_FREE_DEF_INDEX)\n                 .expect(\"integer overflow adding `proc_macro_index`\"));\n         assert!(def_index != CRATE_DEF_INDEX);\n@@ -141,19 +127,11 @@ impl DefIndex {\n \n     // This function is the reverse of from_proc_macro_index() above.\n     pub fn to_proc_macro_index(self: DefIndex) -> usize {\n-        self.as_array_index().checked_sub(FIRST_FREE_DEF_INDEX)\n+        self.index().checked_sub(FIRST_FREE_DEF_INDEX)\n             .unwrap_or_else(|| {\n                 bug!(\"using local index {:?} as proc-macro index\", self)\n             })\n     }\n-\n-    pub fn from_raw_u32(x: u32) -> DefIndex {\n-        DefIndex(x)\n-    }\n-\n-    pub fn as_raw_u32(&self) -> u32 {\n-        self.0\n-    }\n }\n \n impl serialize::UseSpecializedEncodable for DefIndex {}\n@@ -169,7 +147,7 @@ pub struct DefId {\n \n impl fmt::Debug for DefId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"DefId({}:{}\", self.krate, self.index.as_array_index())?;\n+        write!(f, \"DefId({}:{}\", self.krate, self.index.index())?;\n \n         ty::tls::with_opt(|opt_tcx| {\n             if let Some(tcx) = opt_tcx {"}, {"sha": "38d6d710868c08919821de9caf2b34a05cb2a761", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1032,11 +1032,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprKind::DropTemps(ref subexpression) => {\n             visitor.visit_expr(subexpression);\n         }\n-        ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n-            visitor.visit_expr(head_expression);\n-            visitor.visit_expr(if_block);\n-            walk_list!(visitor, visit_expr, optional_else);\n-        }\n         ExprKind::While(ref subexpression, ref block, ref opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_expr(subexpression);"}, {"sha": "3ec4d4e8cc8f68350eba397be435676d2c89fc91", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 141, "deletions": 136, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -62,8 +62,9 @@ use syntax::ext::hygiene::Mark;\n use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::source_map::{respan, CompilerDesugaringKind, Spanned};\n+use syntax::source_map::CompilerDesugaringKind::IfTemporary;\n use syntax::std_inject;\n-use syntax::symbol::{keywords, Symbol};\n+use syntax::symbol::{keywords, Symbol, sym};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::Token;\n use syntax::visit::{self, Visitor};\n@@ -72,7 +73,7 @@ use syntax_pos::Span;\n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n pub struct LoweringContext<'a> {\n-    crate_root: Option<&'static str>,\n+    crate_root: Option<Symbol>,\n \n     /// Used to assign ids to HIR nodes that do not directly correspond to an AST node.\n     sess: &'a Session,\n@@ -96,6 +97,10 @@ pub struct LoweringContext<'a> {\n     is_generator: bool,\n     is_async_body: bool,\n \n+    /// Used to get the current `fn`'s def span to point to when using `await`\n+    /// outside of an `async fn`.\n+    current_item: Option<Span>,\n+\n     catch_scopes: Vec<NodeId>,\n     loop_scopes: Vec<NodeId>,\n     is_in_loop_condition: bool,\n@@ -163,8 +168,8 @@ pub trait Resolver {\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n-        crate_root: Option<&str>,\n-        components: &[&str],\n+        crate_root: Option<Symbol>,\n+        components: &[Symbol],\n         is_value: bool,\n     ) -> hir::Path;\n }\n@@ -227,7 +232,7 @@ pub fn lower_crate(\n     dep_graph.assert_ignored();\n \n     LoweringContext {\n-        crate_root: std_inject::injected_crate_name(),\n+        crate_root: std_inject::injected_crate_name().map(Symbol::intern),\n         sess,\n         cstore,\n         resolver,\n@@ -249,6 +254,7 @@ pub fn lower_crate(\n         node_id_to_hir_id: IndexVec::new(),\n         is_generator: false,\n         is_async_body: false,\n+        current_item: None,\n         is_in_trait_impl: false,\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n@@ -849,10 +855,6 @@ impl<'a> LoweringContext<'a> {\n         self.sess.diagnostic()\n     }\n \n-    fn str_to_ident(&self, s: &'static str) -> Ident {\n-        Ident::with_empty_ctxt(Symbol::gensym(s))\n-    }\n-\n     fn with_anonymous_lifetime_mode<R>(\n         &mut self,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n@@ -1148,7 +1150,7 @@ impl<'a> LoweringContext<'a> {\n             ].into()),\n         );\n         let gen_future = self.expr_std_path(\n-            unstable_span, &[\"future\", \"from_generator\"], None, ThinVec::new());\n+            unstable_span, &[sym::future, sym::from_generator], None, ThinVec::new());\n         hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n     }\n \n@@ -2212,7 +2214,7 @@ impl<'a> LoweringContext<'a> {\n                         bindings: hir_vec![\n                             hir::TypeBinding {\n                                 hir_id: this.next_id(),\n-                                ident: Ident::from_str(FN_OUTPUT_NAME),\n+                                ident: Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n                                 ty: output\n                                     .as_ref()\n                                     .map(|ty| this.lower_ty(&ty, ImplTraitContext::disallowed()))\n@@ -2537,7 +2539,7 @@ impl<'a> LoweringContext<'a> {\n         let future_params = P(hir::GenericArgs {\n             args: hir_vec![],\n             bindings: hir_vec![hir::TypeBinding {\n-                ident: Ident::from_str(FN_OUTPUT_NAME),\n+                ident: Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n                 ty: output_ty,\n                 hir_id: self.next_id(),\n                 span,\n@@ -2547,7 +2549,7 @@ impl<'a> LoweringContext<'a> {\n \n         // ::std::future::Future<future_params>\n         let future_path =\n-            self.std_path(span, &[\"future\", \"Future\"], Some(future_params), false);\n+            self.std_path(span, &[sym::future, sym::Future], Some(future_params), false);\n \n         hir::GenericBound::Trait(\n             hir::PolyTraitRef {\n@@ -2726,7 +2728,7 @@ impl<'a> LoweringContext<'a> {\n                         self.lower_ty(x, ImplTraitContext::disallowed())\n                     }),\n                     synthetic: param.attrs.iter()\n-                                          .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n+                                          .filter(|attr| attr.check_name(sym::rustc_synthetic))\n                                           .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n                                           .next(),\n                 };\n@@ -2744,7 +2746,7 @@ impl<'a> LoweringContext<'a> {\n             hir_id: self.lower_node_id(param.id),\n             name,\n             span: param.ident.span,\n-            pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n+            pure_wrt_drop: attr::contains_name(&param.attrs, sym::may_dangle),\n             attrs: self.lower_attrs(&param.attrs),\n             bounds,\n             kind,\n@@ -3115,6 +3117,7 @@ impl<'a> LoweringContext<'a> {\n             ItemKind::Fn(ref decl, ref header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n                 self.with_new_scopes(|this| {\n+                    this.current_item = Some(ident.span);\n                     let mut lower_fn = |decl: &FnDecl| {\n                         // Note: we don't need to change the return type from `T` to\n                         // `impl Future<Output = T>` here because lower_body\n@@ -3653,6 +3656,7 @@ impl<'a> LoweringContext<'a> {\n                 } else {\n                     lower_method(sig)\n                 };\n+                self.current_item = Some(i.span);\n \n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n             }\n@@ -3772,8 +3776,8 @@ impl<'a> LoweringContext<'a> {\n         let mut vis = self.lower_visibility(&i.vis, None);\n         let attrs = self.lower_attrs(&i.attrs);\n         if let ItemKind::MacroDef(ref def) = i.node {\n-            if !def.legacy || attr::contains_name(&i.attrs, \"macro_export\") ||\n-                              attr::contains_name(&i.attrs, \"rustc_doc_only_macro\") {\n+            if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) ||\n+                              attr::contains_name(&i.attrs, sym::rustc_doc_only_macro) {\n                 let body = self.lower_token_stream(def.stream());\n                 let hir_id = self.lower_node_id(i.id);\n                 self.exported_macros.push(hir::MacroDef {\n@@ -4099,7 +4103,7 @@ impl<'a> LoweringContext<'a> {\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::Unary(op, ohs)\n             }\n-            ExprKind::Lit(ref l) => hir::ExprKind::Lit((*l).clone()),\n+            ExprKind::Lit(ref l) => hir::ExprKind::Lit(respan(l.span, l.node.clone())),\n             ExprKind::Cast(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n                 hir::ExprKind::Cast(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n@@ -4115,31 +4119,46 @@ impl<'a> LoweringContext<'a> {\n             }\n             // More complicated than you might expect because the else branch\n             // might be `if let`.\n-            ExprKind::If(ref cond, ref blk, ref else_opt) => {\n-                let else_opt = else_opt.as_ref().map(|els| {\n-                    match els.node {\n+            ExprKind::If(ref cond, ref then, ref else_opt) => {\n+                // `true => then`:\n+                let then_pat = self.pat_bool(e.span, true);\n+                let then_blk = self.lower_block(then, false);\n+                let then_expr = self.expr_block(then_blk, ThinVec::new());\n+                let then_arm = self.arm(hir_vec![then_pat], P(then_expr));\n+\n+                // `_ => else_block` where `else_block` is `{}` if there's `None`:\n+                let else_pat = self.pat_wild(e.span);\n+                let else_expr = match else_opt {\n+                    None => self.expr_block_empty(e.span),\n+                    Some(els) => match els.node {\n                         ExprKind::IfLet(..) => {\n                             // Wrap the `if let` expr in a block.\n-                            let span = els.span;\n-                            let els = P(self.lower_expr(els));\n-                            let blk = P(hir::Block {\n-                                stmts: hir_vec![],\n-                                expr: Some(els),\n-                                hir_id: self.next_id(),\n-                                rules: hir::DefaultBlock,\n-                                span,\n-                                targeted_by_break: false,\n-                            });\n-                            P(self.expr_block(blk, ThinVec::new()))\n+                            let els = self.lower_expr(els);\n+                            let blk = self.block_all(els.span, hir_vec![], Some(P(els)));\n+                            self.expr_block(P(blk), ThinVec::new())\n                         }\n-                        _ => P(self.lower_expr(els)),\n+                        _ => self.lower_expr(els),\n                     }\n-                });\n-\n-                let then_blk = self.lower_block(blk, false);\n-                let then_expr = self.expr_block(then_blk, ThinVec::new());\n+                };\n+                let else_arm = self.arm(hir_vec![else_pat], P(else_expr));\n+\n+                // Lower condition:\n+                let span_block = self\n+                    .sess\n+                    .source_map()\n+                    .mark_span_with_reason(IfTemporary, cond.span, None);\n+                let cond = self.lower_expr(cond);\n+                // Wrap in a construct equivalent to `{ let _t = $cond; _t }` to preserve drop\n+                // semantics since `if cond { ... }` don't let temporaries live outside of `cond`.\n+                let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n \n-                hir::ExprKind::If(P(self.lower_expr(cond)), P(then_expr), else_opt)\n+                hir::ExprKind::Match(\n+                    P(cond),\n+                    vec![then_arm, else_arm].into(),\n+                    hir::MatchSource::IfDesugar {\n+                        contains_else_clause: else_opt.is_some()\n+                    },\n+                )\n             }\n             ExprKind::While(ref cond, ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n                 hir::ExprKind::While(\n@@ -4178,7 +4197,7 @@ impl<'a> LoweringContext<'a> {\n                         |x: P<hir::Expr>| x.into_inner(),\n                     );\n                     block.expr = Some(this.wrap_in_try_constructor(\n-                        \"from_ok\", tail, unstable_span));\n+                        sym::from_ok, tail, unstable_span));\n                     hir::ExprKind::Block(P(block), None)\n                 })\n             }\n@@ -4254,6 +4273,7 @@ impl<'a> LoweringContext<'a> {\n                     let fn_decl = self.lower_fn_decl(decl, None, false, None);\n \n                     self.with_new_scopes(|this| {\n+                        this.current_item = Some(fn_decl_span);\n                         let mut is_generator = false;\n                         let body_id = this.lower_body(Some(decl), |this| {\n                             let e = this.lower_expr(body);\n@@ -4320,7 +4340,7 @@ impl<'a> LoweringContext<'a> {\n                 self.expr_call_std_assoc_fn(\n                     id,\n                     e.span,\n-                    &[\"ops\", \"RangeInclusive\"],\n+                    &[sym::ops, sym::RangeInclusive],\n                     \"new\",\n                     hir_vec![e1, e2],\n                 )\n@@ -4329,11 +4349,11 @@ impl<'a> LoweringContext<'a> {\n                 use syntax::ast::RangeLimits::*;\n \n                 let path = match (e1, e2, lims) {\n-                    (&None, &None, HalfOpen) => \"RangeFull\",\n-                    (&Some(..), &None, HalfOpen) => \"RangeFrom\",\n-                    (&None, &Some(..), HalfOpen) => \"RangeTo\",\n-                    (&Some(..), &Some(..), HalfOpen) => \"Range\",\n-                    (&None, &Some(..), Closed) => \"RangeToInclusive\",\n+                    (&None, &None, HalfOpen) => sym::RangeFull,\n+                    (&Some(..), &None, HalfOpen) => sym::RangeFrom,\n+                    (&None, &Some(..), HalfOpen) => sym::RangeTo,\n+                    (&Some(..), &Some(..), HalfOpen) => sym::Range,\n+                    (&None, &Some(..), Closed) => sym::RangeToInclusive,\n                     (&Some(..), &Some(..), Closed) => unreachable!(),\n                     (_, &None, Closed) => self.diagnostic()\n                         .span_fatal(e.span, \"inclusive range with no end\")\n@@ -4351,7 +4371,7 @@ impl<'a> LoweringContext<'a> {\n                     .collect::<P<[hir::Field]>>();\n \n                 let is_unit = fields.is_empty();\n-                let struct_path = [\"ops\", path];\n+                let struct_path = [sym::ops, path];\n                 let struct_path = self.std_path(e.span, &struct_path, None, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));\n \n@@ -4486,16 +4506,16 @@ impl<'a> LoweringContext<'a> {\n                     arms.push(self.arm(pats, body_expr));\n                 }\n \n-                // _ => [<else_opt>|()]\n+                // _ => [<else_opt>|{}]\n                 {\n                     let wildcard_arm: Option<&Expr> = else_opt.as_ref().map(|p| &**p);\n                     let wildcard_pattern = self.pat_wild(e.span);\n                     let body = if let Some(else_expr) = wildcard_arm {\n-                        P(self.lower_expr(else_expr))\n+                        self.lower_expr(else_expr)\n                     } else {\n-                        P(self.expr_tuple(e.span, hir_vec![]))\n+                        self.expr_block_empty(e.span)\n                     };\n-                    arms.push(self.arm(hir_vec![wildcard_pattern], body));\n+                    arms.push(self.arm(hir_vec![wildcard_pattern], P(body)));\n                 }\n \n                 let contains_else_clause = else_opt.is_some();\n@@ -4597,18 +4617,18 @@ impl<'a> LoweringContext<'a> {\n                 );\n                 head.span = desugared_span;\n \n-                let iter = self.str_to_ident(\"iter\");\n+                let iter = Ident::with_empty_ctxt(sym::iter);\n \n-                let next_ident = self.str_to_ident(\"__next\");\n+                let next_ident = Ident::with_empty_ctxt(sym::__next);\n                 let (next_pat, next_pat_hid) = self.pat_ident_binding_mode(\n                     desugared_span,\n                     next_ident,\n                     hir::BindingAnnotation::Mutable,\n                 );\n \n-                // `::std::option::Option::Some(val) => next = val`\n+                // `::std::option::Option::Some(val) => __next = val`\n                 let pat_arm = {\n-                    let val_ident = self.str_to_ident(\"val\");\n+                    let val_ident = Ident::with_empty_ctxt(sym::val);\n                     let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n                     let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_hid));\n                     let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_hid));\n@@ -4640,7 +4660,7 @@ impl<'a> LoweringContext<'a> {\n                 let match_expr = {\n                     let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n                     let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n-                    let next_path = &[\"iter\", \"Iterator\", \"next\"];\n+                    let next_path = &[sym::iter, sym::Iterator, sym::next];\n                     let next_expr = P(self.expr_call_std_path(\n                         head_sp,\n                         next_path,\n@@ -4658,11 +4678,7 @@ impl<'a> LoweringContext<'a> {\n                         ThinVec::new(),\n                     ))\n                 };\n-                let match_stmt = hir::Stmt {\n-                    hir_id: self.next_id(),\n-                    node: hir::StmtKind::Expr(match_expr),\n-                    span: head_sp,\n-                };\n+                let match_stmt = self.stmt(head_sp, hir::StmtKind::Expr(match_expr));\n \n                 let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat_hid));\n \n@@ -4685,11 +4701,7 @@ impl<'a> LoweringContext<'a> {\n \n                 let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n                 let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n-                let body_stmt = hir::Stmt {\n-                    hir_id: self.next_id(),\n-                    node: hir::StmtKind::Expr(body_expr),\n-                    span: body.span,\n-                };\n+                let body_stmt = self.stmt(body.span, hir::StmtKind::Expr(body_expr));\n \n                 let loop_block = P(self.block_all(\n                     e.span,\n@@ -4715,7 +4727,8 @@ impl<'a> LoweringContext<'a> {\n \n                 // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                 let into_iter_expr = {\n-                    let into_iter_path = &[\"iter\", \"IntoIterator\", \"into_iter\"];\n+                    let into_iter_path =\n+                        &[sym::iter, sym::IntoIterator, sym::into_iter];\n                     P(self.expr_call_std_path(\n                         head_sp,\n                         into_iter_path,\n@@ -4754,25 +4767,21 @@ impl<'a> LoweringContext<'a> {\n                 let unstable_span = self.sess.source_map().mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     e.span,\n-                    Some(vec![\n-                        Symbol::intern(\"try_trait\")\n-                    ].into()),\n+                    Some(vec![sym::try_trait].into()),\n                 );\n                 let try_span = self.sess.source_map().end_point(e.span);\n                 let try_span = self.sess.source_map().mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     try_span,\n-                    Some(vec![\n-                        Symbol::intern(\"try_trait\")\n-                    ].into()),\n+                    Some(vec![sym::try_trait].into()),\n                 );\n \n                 // `Try::into_result(<expr>)`\n                 let discr = {\n                     // expand <expr>\n                     let sub_expr = self.lower_expr(sub_expr);\n \n-                    let path = &[\"ops\", \"Try\", \"into_result\"];\n+                    let path = &[sym::ops, sym::Try, sym::into_result];\n                     P(self.expr_call_std_path(\n                         unstable_span,\n                         path,\n@@ -4784,8 +4793,9 @@ impl<'a> LoweringContext<'a> {\n                 let attr = {\n                     // `allow(unreachable_code)`\n                     let allow = {\n-                        let allow_ident = Ident::from_str(\"allow\").with_span_pos(e.span);\n-                        let uc_ident = Ident::from_str(\"unreachable_code\").with_span_pos(e.span);\n+                        let allow_ident = Ident::with_empty_ctxt(sym::allow).with_span_pos(e.span);\n+                        let uc_ident = Ident::with_empty_ctxt(sym::unreachable_code)\n+                            .with_span_pos(e.span);\n                         let uc_nested = attr::mk_nested_word_item(uc_ident);\n                         attr::mk_list_item(e.span, allow_ident, vec![uc_nested])\n                     };\n@@ -4795,7 +4805,7 @@ impl<'a> LoweringContext<'a> {\n \n                 // `Ok(val) => #[allow(unreachable_code)] val,`\n                 let ok_arm = {\n-                    let val_ident = self.str_to_ident(\"val\");\n+                    let val_ident = Ident::with_empty_ctxt(sym::val);\n                     let (val_pat, val_pat_nid) = self.pat_ident(e.span, val_ident);\n                     let val_expr = P(self.expr_ident_with_attrs(\n                         e.span,\n@@ -4811,15 +4821,15 @@ impl<'a> LoweringContext<'a> {\n                 // `Err(err) => #[allow(unreachable_code)]\n                 //              return Try::from_error(From::from(err)),`\n                 let err_arm = {\n-                    let err_ident = self.str_to_ident(\"err\");\n+                    let err_ident = Ident::with_empty_ctxt(sym::err);\n                     let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n                     let from_expr = {\n-                        let from_path = &[\"convert\", \"From\", \"from\"];\n+                        let from_path = &[sym::convert, sym::From, sym::from];\n                         let err_expr = self.expr_ident(try_span, err_ident, err_local_nid);\n                         self.expr_call_std_path(try_span, from_path, hir_vec![err_expr])\n                     };\n                     let from_err_expr =\n-                        self.wrap_in_try_constructor(\"from_error\", from_expr, unstable_span);\n+                        self.wrap_in_try_constructor(sym::from_error, from_expr, unstable_span);\n                     let thin_attrs = ThinVec::from(attrs);\n                     let catch_scope = self.catch_scopes.last().map(|x| *x);\n                     let ret_expr = if let Some(catch_node) = catch_scope {\n@@ -4869,12 +4879,7 @@ impl<'a> LoweringContext<'a> {\n                     .into_iter()\n                     .map(|item_id| {\n                         let item_id = hir::ItemId { id: self.lower_node_id(item_id) };\n-\n-                        hir::Stmt {\n-                            hir_id: self.next_id(),\n-                            node: hir::StmtKind::Item(item_id),\n-                            span: s.span,\n-                        }\n+                        self.stmt(s.span, hir::StmtKind::Item(item_id))\n                     })\n                     .collect();\n                 ids.push({\n@@ -5054,7 +5059,7 @@ impl<'a> LoweringContext<'a> {\n     fn expr_call_std_path(\n         &mut self,\n         span: Span,\n-        path_components: &[&str],\n+        path_components: &[Symbol],\n         args: hir::HirVec<hir::Expr>,\n     ) -> hir::Expr {\n         let path = P(self.expr_std_path(span, path_components, None, ThinVec::new()));\n@@ -5074,7 +5079,7 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         ty_path_id: hir::HirId,\n         span: Span,\n-        ty_path_components: &[&str],\n+        ty_path_components: &[Symbol],\n         assoc_fn_name: &str,\n         args: hir::HirVec<hir::Expr>,\n     ) -> hir::ExprKind {\n@@ -5116,7 +5121,7 @@ impl<'a> LoweringContext<'a> {\n     fn expr_std_path(\n         &mut self,\n         span: Span,\n-        components: &[&str],\n+        components: &[Symbol],\n         params: Option<P<hir::GenericArgs>>,\n         attrs: ThinVec<Attribute>,\n     ) -> hir::Expr {\n@@ -5174,28 +5179,32 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn stmt(&mut self, span: Span, node: hir::StmtKind) -> hir::Stmt {\n+        hir::Stmt { span, node, hir_id: self.next_id() }\n+    }\n+\n     fn stmt_let_pat(\n         &mut self,\n-        sp: Span,\n-        ex: Option<P<hir::Expr>>,\n+        span: Span,\n+        init: Option<P<hir::Expr>>,\n         pat: P<hir::Pat>,\n         source: hir::LocalSource,\n     ) -> hir::Stmt {\n         let local = hir::Local {\n             pat,\n             ty: None,\n-            init: ex,\n+            init,\n             hir_id: self.next_id(),\n-            span: sp,\n-            attrs: ThinVec::new(),\n+            span,\n             source,\n+            attrs: ThinVec::new()\n         };\n+        self.stmt(span, hir::StmtKind::Local(P(local)))\n+    }\n \n-        hir::Stmt {\n-            hir_id: self.next_id(),\n-            node: hir::StmtKind::Local(P(local)),\n-            span: sp\n-        }\n+    fn expr_block_empty(&mut self, span: Span) -> hir::Expr {\n+        let blk = self.block_all(span, hir_vec![], None);\n+        self.expr_block(P(blk), ThinVec::new())\n     }\n \n     fn block_expr(&mut self, expr: P<hir::Expr>) -> hir::Block {\n@@ -5235,26 +5244,33 @@ impl<'a> LoweringContext<'a> {\n         )\n     }\n \n+    /// Constructs a `true` or `false` literal pattern.\n+    fn pat_bool(&mut self, span: Span, val: bool) -> P<hir::Pat> {\n+        let lit = Spanned { span, node: LitKind::Bool(val) };\n+        let expr = self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new());\n+        self.pat(span, hir::PatKind::Lit(P(expr)))\n+    }\n+\n     fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[\"result\", \"Result\", \"Ok\"], hir_vec![pat])\n+        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Ok], hir_vec![pat])\n     }\n \n     fn pat_err(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[\"result\", \"Result\", \"Err\"], hir_vec![pat])\n+        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Err], hir_vec![pat])\n     }\n \n     fn pat_some(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[\"option\", \"Option\", \"Some\"], hir_vec![pat])\n+        self.pat_std_enum(span, &[sym::option, sym::Option, sym::Some], hir_vec![pat])\n     }\n \n     fn pat_none(&mut self, span: Span) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[\"option\", \"Option\", \"None\"], hir_vec![])\n+        self.pat_std_enum(span, &[sym::option, sym::Option, sym::None], hir_vec![])\n     }\n \n     fn pat_std_enum(\n         &mut self,\n         span: Span,\n-        components: &[&str],\n+        components: &[Symbol],\n         subpats: hir::HirVec<P<hir::Pat>>,\n     ) -> P<hir::Pat> {\n         let path = self.std_path(span, components, None, true);\n@@ -5307,7 +5323,7 @@ impl<'a> LoweringContext<'a> {\n     fn std_path(\n         &mut self,\n         span: Span,\n-        components: &[&str],\n+        components: &[Symbol],\n         params: Option<P<hir::GenericArgs>>,\n         is_value: bool,\n     ) -> hir::Path {\n@@ -5506,11 +5522,11 @@ impl<'a> LoweringContext<'a> {\n \n     fn wrap_in_try_constructor(\n         &mut self,\n-        method: &'static str,\n+        method: Symbol,\n         e: hir::Expr,\n         unstable_span: Span,\n     ) -> P<hir::Expr> {\n-        let path = &[\"ops\", \"Try\", method];\n+        let path = &[sym::ops, sym::Try, method];\n         let from_err = P(self.expr_std_path(unstable_span, path, None,\n                                             ThinVec::new()));\n         P(self.expr_call(e.span, from_err, hir_vec![e]))\n@@ -5529,20 +5545,25 @@ impl<'a> LoweringContext<'a> {\n         //         match ::std::future::poll_with_tls_context(unsafe {\n         //             ::std::pin::Pin::new_unchecked(&mut pinned)\n         //         }) {\n-        //             ::std::task::Poll::Ready(x) => break x,\n+        //             ::std::task::Poll::Ready(result) => break result,\n         //             ::std::task::Poll::Pending => {},\n         //         }\n         //         yield ();\n         //     }\n         // }\n         if !self.is_async_body {\n-            span_err!(\n+            let mut err = struct_span_err!(\n                 self.sess,\n                 await_span,\n                 E0728,\n                 \"`await` is only allowed inside `async` functions and blocks\"\n             );\n-            self.sess.abort_if_errors();\n+            err.span_label(await_span, \"only allowed inside `async` functions and blocks\");\n+            if let Some(item_sp) = self.current_item {\n+                err.span_label(item_sp, \"this is not `async`\");\n+            }\n+            err.emit();\n+            return hir::ExprKind::Err;\n         }\n         let span = self.sess.source_map().mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n@@ -5552,12 +5573,12 @@ impl<'a> LoweringContext<'a> {\n         let gen_future_span = self.sess.source_map().mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n             await_span,\n-            Some(vec![Symbol::intern(\"gen_future\")].into()),\n+            Some(vec![sym::gen_future].into()),\n         );\n \n         // let mut pinned = <expr>;\n         let expr = P(self.lower_expr(expr));\n-        let pinned_ident = self.str_to_ident(\"pinned\");\n+        let pinned_ident = Ident::with_empty_ctxt(sym::pinned);\n         let (pinned_pat, pinned_pat_hid) = self.pat_ident_binding_mode(\n             span,\n             pinned_ident,\n@@ -5580,29 +5601,29 @@ impl<'a> LoweringContext<'a> {\n             let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n                 pin_ty_id,\n                 span,\n-                &[\"pin\", \"Pin\"],\n+                &[sym::pin, sym::Pin],\n                 \"new_unchecked\",\n                 hir_vec![ref_mut_pinned],\n             );\n             let new_unchecked = P(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n             let unsafe_expr = self.expr_unsafe(new_unchecked);\n             P(self.expr_call_std_path(\n                 gen_future_span,\n-                &[\"future\", \"poll_with_tls_context\"],\n+                &[sym::future, sym::poll_with_tls_context],\n                 hir_vec![unsafe_expr],\n             ))\n         };\n \n-        // `::std::task::Poll::Ready(x) => break x`\n+        // `::std::task::Poll::Ready(result) => break result`\n         let loop_node_id = self.sess.next_node_id();\n         let loop_hir_id = self.lower_node_id(loop_node_id);\n         let ready_arm = {\n-            let x_ident = self.str_to_ident(\"x\");\n+            let x_ident = Ident::with_empty_ctxt(sym::result);\n             let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n             let x_expr = P(self.expr_ident(span, x_ident, x_pat_hid));\n             let ready_pat = self.pat_std_enum(\n                 span,\n-                &[\"task\", \"Poll\", \"Ready\"],\n+                &[sym::task, sym::Poll, sym::Ready],\n                 hir_vec![x_pat],\n             );\n             let break_x = self.with_loop_scope(loop_node_id, |this| {\n@@ -5619,18 +5640,10 @@ impl<'a> LoweringContext<'a> {\n         let pending_arm = {\n             let pending_pat = self.pat_std_enum(\n                 span,\n-                &[\"task\", \"Poll\", \"Pending\"],\n+                &[sym::task, sym::Poll, sym::Pending],\n                 hir_vec![],\n             );\n-            let empty_block = P(hir::Block {\n-                stmts: hir_vec![],\n-                expr: None,\n-                hir_id: self.next_id(),\n-                rules: hir::DefaultBlock,\n-                span,\n-                targeted_by_break: false,\n-            });\n-            let empty_block = P(self.expr_block(empty_block, ThinVec::new()));\n+            let empty_block = P(self.expr_block_empty(span));\n             self.arm(hir_vec![pending_pat], empty_block)\n         };\n \n@@ -5641,11 +5654,7 @@ impl<'a> LoweringContext<'a> {\n                 hir_vec![ready_arm, pending_arm],\n                 hir::MatchSource::AwaitDesugar,\n             ));\n-            hir::Stmt {\n-                hir_id: self.next_id(),\n-                node: hir::StmtKind::Expr(match_expr),\n-                span,\n-            }\n+            self.stmt(span, hir::StmtKind::Expr(match_expr))\n         };\n \n         let yield_stmt = {\n@@ -5655,11 +5664,7 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprKind::Yield(P(unit)),\n                 ThinVec::new(),\n             ));\n-            hir::Stmt {\n-                hir_id: self.next_id(),\n-                node: hir::StmtKind::Expr(yield_expr),\n-                span,\n-            }\n+            self.stmt(span, hir::StmtKind::Expr(yield_expr))\n         };\n \n         let loop_block = P(self.block_all("}, {"sha": "eeba628b3bf2168ad943ac41fe4cca076ed5bf72", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -226,7 +226,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n     fn insert_entry(&mut self, id: HirId, entry: Entry<'hir>) {\n         debug!(\"hir_map: {:?} => {:?}\", id, entry);\n-        let local_map = &mut self.map[id.owner.as_array_index()];\n+        let local_map = &mut self.map[id.owner.index()];\n         let i = id.local_id.as_u32() as usize;\n         if local_map.is_none() {\n             *local_map = Some(IndexVec::with_capacity(i + 1));"}, {"sha": "1cc9a2c0e8a1b9d875b7f9a31520c5644f727e76", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -17,7 +17,7 @@ use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n use syntax::ext::hygiene::Mark;\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::{Symbol, sym, InternedString};\n use syntax_pos::{Span, DUMMY_SP};\n use crate::util::nodemap::NodeMap;\n \n@@ -38,7 +38,7 @@ impl DefPathTable {\n                 def_path_hash: DefPathHash)\n                 -> DefIndex {\n         let index = {\n-            let index = DefIndex::from_array_index(self.index_to_key.len());\n+            let index = DefIndex::from(self.index_to_key.len());\n             debug!(\"DefPathTable::insert() - {:?} <-> {:?}\", key, index);\n             self.index_to_key.push(key);\n             index\n@@ -49,17 +49,17 @@ impl DefPathTable {\n     }\n \n     pub fn next_id(&self) -> DefIndex {\n-        DefIndex::from_array_index(self.index_to_key.len())\n+        DefIndex::from(self.index_to_key.len())\n     }\n \n     #[inline(always)]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.index_to_key[index.as_array_index()].clone()\n+        self.index_to_key[index.index()].clone()\n     }\n \n     #[inline(always)]\n     pub fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n-        let ret = self.def_path_hashes[index.as_array_index()];\n+        let ret = self.def_path_hashes[index.index()];\n         debug!(\"def_path_hash({:?}) = {:?}\", index, ret);\n         return ret\n     }\n@@ -74,7 +74,7 @@ impl DefPathTable {\n                 .map(|(index, &hash)| {\n                     let def_id = DefId {\n                         krate: cnum,\n-                        index: DefIndex::from_array_index(index),\n+                        index: DefIndex::from(index),\n                     };\n                     (hash, def_id)\n                 })\n@@ -387,7 +387,7 @@ impl Definitions {\n     #[inline]\n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n-            let node_id = self.def_index_to_node[def_id.index.as_array_index()];\n+            let node_id = self.def_index_to_node[def_id.index.index()];\n             if node_id != ast::DUMMY_NODE_ID {\n                 return Some(node_id);\n             }\n@@ -417,7 +417,7 @@ impl Definitions {\n \n     #[inline]\n     pub fn def_index_to_hir_id(&self, def_index: DefIndex) -> hir::HirId {\n-        let node_id = self.def_index_to_node[def_index.as_array_index()];\n+        let node_id = self.def_index_to_node[def_index.index()];\n         self.node_to_hir_id[node_id]\n     }\n \n@@ -508,7 +508,7 @@ impl Definitions {\n \n         // Create the definition.\n         let index = self.table.allocate(key, def_path_hash);\n-        assert_eq!(index.as_array_index(), self.def_index_to_node.len());\n+        assert_eq!(index.index(), self.def_index_to_node.len());\n         self.def_index_to_node.push(node_id);\n \n         // Some things for which we allocate DefIndices don't correspond to\n@@ -584,16 +584,16 @@ impl DefPathData {\n                 return name\n             }\n             // note that this does not show up in user printouts\n-            CrateRoot => \"{{crate}}\",\n-            Impl => \"{{impl}}\",\n-            Misc => \"{{misc}}\",\n-            ClosureExpr => \"{{closure}}\",\n-            Ctor => \"{{constructor}}\",\n-            AnonConst => \"{{constant}}\",\n-            ImplTrait => \"{{opaque}}\",\n+            CrateRoot => sym::double_braced_crate,\n+            Impl => sym::double_braced_impl,\n+            Misc => sym::double_braced_misc,\n+            ClosureExpr => sym::double_braced_closure,\n+            Ctor => sym::double_braced_constructor,\n+            AnonConst => sym::double_braced_constant,\n+            ImplTrait => sym::double_braced_opaque,\n         };\n \n-        Symbol::intern(s).as_interned_str()\n+        s.as_interned_str()\n     }\n \n     pub fn to_string(&self) -> String {\n@@ -653,7 +653,7 @@ macro_rules! define_global_metadata_kind {\n                                           .position(|k| *k == def_key)\n                                           .unwrap();\n \n-                DefIndex::from_array_index(index)\n+                DefIndex::from(index)\n             }\n \n             fn name(&self) -> Symbol {"}, {"sha": "4b94f772554e76910aa228856853fe0ad3e65cb0", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -189,7 +189,7 @@ pub struct Map<'hir> {\n impl<'hir> Map<'hir> {\n     #[inline]\n     fn lookup(&self, id: HirId) -> Option<&Entry<'hir>> {\n-        let local_map = self.map.get(id.owner.as_array_index())?;\n+        let local_map = self.map.get(id.owner.index())?;\n         local_map.as_ref()?.get(id.local_id)?.as_ref()\n     }\n \n@@ -1023,7 +1023,7 @@ impl<'hir> Map<'hir> {\n             local_map.iter_enumerated().filter_map(move |(i, entry)| entry.map(move |_| {\n                 // Reconstruct the HirId based on the 3 indices we used to find it\n                 HirId {\n-                    owner: DefIndex::from_array_index(array_index),\n+                    owner: DefIndex::from(array_index),\n                     local_id: i,\n                 }\n             }))\n@@ -1146,7 +1146,7 @@ impl<'a> NodesMatchingSuffix<'a> {\n                 None => return false,\n                 Some((node_id, name)) => (node_id, name),\n             };\n-            if mod_name != &**part {\n+            if mod_name.as_str() != *part {\n                 return false;\n             }\n             cursor = self.map.get_parent_item(mod_id);\n@@ -1183,7 +1183,7 @@ impl<'a> NodesMatchingSuffix<'a> {\n     // We are looking at some node `n` with a given name and parent\n     // id; do their names match what I am seeking?\n     fn matches_names(&self, parent_of_n: HirId, name: Name) -> bool {\n-        name == &**self.item_name && self.suffix_matches(parent_of_n)\n+        name.as_str() == *self.item_name && self.suffix_matches(parent_of_n)\n     }\n \n     fn matches_suffix(&self, hir: HirId) -> bool {"}, {"sha": "57304c5ed37aec722b0f860cab48ff126235fb2f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -20,7 +20,7 @@ use syntax_pos::{Span, DUMMY_SP, symbol::InternedString};\n use syntax::source_map::Spanned;\n use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n-use syntax::ast::{Attribute, Label, Lit, StrStyle, FloatTy, IntTy, UintTy};\n+use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n@@ -126,12 +126,12 @@ mod item_local_id_inner {\n     use rustc_macros::HashStable;\n     newtype_index! {\n         /// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n-        /// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n+        /// that is, within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n         /// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n         /// the node's position within the owning item in any way, but there is a\n         /// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n         /// integers starting at zero, so a mapping that maps all or most nodes within\n-        /// an \"item-like\" to something else can be implement by a `Vec` instead of a\n+        /// an \"item-like\" to something else can be implemented by a `Vec` instead of a\n         /// tree or hash map.\n         pub struct ItemLocalId {\n             derive [HashStable]\n@@ -609,9 +609,9 @@ impl Generics {\n         own_counts\n     }\n \n-    pub fn get_named(&self, name: &InternedString) -> Option<&GenericParam> {\n+    pub fn get_named(&self, name: InternedString) -> Option<&GenericParam> {\n         for param in &self.params {\n-            if *name == param.name.ident().as_interned_str() {\n+            if name == param.name.ident().as_interned_str() {\n                 return Some(param);\n             }\n         }\n@@ -1331,6 +1331,9 @@ impl BodyOwnerKind {\n     }\n }\n \n+/// A literal.\n+pub type Lit = Spanned<LitKind>;\n+\n /// A constant (expression) that's not an item or associated item,\n /// but needs its own `DefId` for type-checking, const-eval, etc.\n /// These are usually found nested inside types (e.g., array lengths)\n@@ -1353,7 +1356,7 @@ pub struct Expr {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(MEM_SIZE_OF_EXPR: std::mem::size_of::<Expr>() == 72);\n+static_assert_size!(Expr, 72);\n \n impl Expr {\n     pub fn precedence(&self) -> ExprPrecedence {\n@@ -1368,7 +1371,6 @@ impl Expr {\n             ExprKind::Lit(_) => ExprPrecedence::Lit,\n             ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n             ExprKind::DropTemps(ref expr, ..) => expr.precedence(),\n-            ExprKind::If(..) => ExprPrecedence::If,\n             ExprKind::While(..) => ExprPrecedence::While,\n             ExprKind::Loop(..) => ExprPrecedence::Loop,\n             ExprKind::Match(..) => ExprPrecedence::Match,\n@@ -1421,7 +1423,6 @@ impl Expr {\n             ExprKind::MethodCall(..) |\n             ExprKind::Struct(..) |\n             ExprKind::Tup(..) |\n-            ExprKind::If(..) |\n             ExprKind::Match(..) |\n             ExprKind::Closure(..) |\n             ExprKind::Block(..) |\n@@ -1498,10 +1499,6 @@ pub enum ExprKind {\n     /// This construct only exists to tweak the drop order in HIR lowering.\n     /// An example of that is the desugaring of `for` loops.\n     DropTemps(P<Expr>),\n-    /// An `if` block, with an optional else block.\n-    ///\n-    /// I.e., `if <expr> { <expr> } else { <expr> }`.\n-    If(P<Expr>, P<Expr>, Option<P<Expr>>),\n     /// A while loop, with an optional label\n     ///\n     /// I.e., `'label: while expr { <block> }`.\n@@ -1615,6 +1612,10 @@ pub enum LocalSource {\n pub enum MatchSource {\n     /// A `match _ { .. }`.\n     Normal,\n+    /// An `if _ { .. }` (optionally with `else { .. }`).\n+    IfDesugar {\n+        contains_else_clause: bool,\n+    },\n     /// An `if let _ = _ { .. }` (optionally with `else { .. }`).\n     IfLetDesugar {\n         contains_else_clause: bool,"}, {"sha": "8a9028e5443912471481ee6749b1065d4aadb7aa", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 14, "deletions": 100, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -5,7 +5,7 @@ use syntax::parse::ParseSess;\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n-use syntax::print::pprust::PrintState;\n+use syntax::print::pprust::{self, PrintState};\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax::util::parser::{self, AssocOp, Fixity};\n@@ -18,7 +18,6 @@ use crate::hir::{GenericParam, GenericParamKind, GenericArg};\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::io::{self, Write, Read};\n-use std::iter::Peekable;\n use std::vec;\n \n pub enum AnnNode<'a> {\n@@ -76,7 +75,6 @@ pub struct State<'a> {\n     pub s: pp::Printer<'a>,\n     cm: Option<&'a SourceMap>,\n     comments: Option<Vec<comments::Comment>>,\n-    literals: Peekable<vec::IntoIter<comments::Literal>>,\n     cur_cmnt: usize,\n     boxes: Vec<pp::Breaks>,\n     ann: &'a (dyn PpAnn + 'a),\n@@ -98,14 +96,6 @@ impl<'a> PrintState<'a> for State<'a> {\n     fn cur_cmnt(&mut self) -> &mut usize {\n         &mut self.cur_cmnt\n     }\n-\n-    fn cur_lit(&mut self) -> Option<&comments::Literal> {\n-        self.literals.peek()\n-    }\n-\n-    fn bump_lit(&mut self) -> Option<comments::Literal> {\n-        self.literals.next()\n-    }\n }\n \n #[allow(non_upper_case_globals)]\n@@ -116,18 +106,16 @@ pub const default_columns: usize = 78;\n \n \n /// Requires you to pass an input filename and reader so that\n-/// it can scan the input text for comments and literals to\n-/// copy forward.\n+/// it can scan the input text for comments to copy forward.\n pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n                        krate: &hir::Crate,\n                        filename: FileName,\n                        input: &mut dyn Read,\n                        out: Box<dyn Write + 'a>,\n-                       ann: &'a dyn PpAnn,\n-                       is_expanded: bool)\n+                       ann: &'a dyn PpAnn)\n                        -> io::Result<()> {\n-    let mut s = State::new_from_input(cm, sess, filename, input, out, ann, is_expanded);\n+    let mut s = State::new_from_input(cm, sess, filename, input, out, ann);\n \n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n@@ -143,36 +131,21 @@ impl<'a> State<'a> {\n                           filename: FileName,\n                           input: &mut dyn Read,\n                           out: Box<dyn Write + 'a>,\n-                          ann: &'a dyn PpAnn,\n-                          is_expanded: bool)\n+                          ann: &'a dyn PpAnn)\n                           -> State<'a> {\n-        let (cmnts, lits) = comments::gather_comments_and_literals(sess, filename, input);\n-\n-        State::new(cm,\n-                   out,\n-                   ann,\n-                   Some(cmnts),\n-                   // If the code is post expansion, don't use the table of\n-                   // literals, since it doesn't correspond with the literals\n-                   // in the AST anymore.\n-                   if is_expanded {\n-                       None\n-                   } else {\n-                       Some(lits)\n-                   })\n+        let comments = comments::gather_comments(sess, filename, input);\n+        State::new(cm, out, ann, Some(comments))\n     }\n \n     pub fn new(cm: &'a SourceMap,\n                out: Box<dyn Write + 'a>,\n                ann: &'a dyn PpAnn,\n-               comments: Option<Vec<comments::Comment>>,\n-               literals: Option<Vec<comments::Literal>>)\n+               comments: Option<Vec<comments::Comment>>)\n                -> State<'a> {\n         State {\n             s: pp::mk_printer(out, default_columns),\n             cm: Some(cm),\n             comments,\n-            literals: literals.unwrap_or_default().into_iter().peekable(),\n             cur_cmnt: 0,\n             boxes: Vec::new(),\n             ann,\n@@ -189,7 +162,6 @@ pub fn to_string<F>(ann: &dyn PpAnn, f: F) -> String\n             s: pp::mk_printer(Box::new(&mut wr), default_columns),\n             cm: None,\n             comments: None,\n-            literals: vec![].into_iter().peekable(),\n             cur_cmnt: 0,\n             boxes: Vec::new(),\n             ann,\n@@ -646,7 +618,6 @@ impl<'a> State<'a> {\n \n                 self.print_where_clause(&exist.generics.where_clause)?;\n                 self.s.space()?;\n-                self.word_space(\":\")?;\n                 let mut real_bounds = Vec::with_capacity(exist.bounds.len());\n                 for b in exist.bounds.iter() {\n                     if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n@@ -1093,65 +1064,6 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Block(blk))\n     }\n \n-    fn print_else(&mut self, els: Option<&hir::Expr>) -> io::Result<()> {\n-        match els {\n-            Some(_else) => {\n-                match _else.node {\n-                    // \"another else-if\"\n-                    hir::ExprKind::If(ref i, ref then, ref e) => {\n-                        self.cbox(indent_unit - 1)?;\n-                        self.ibox(0)?;\n-                        self.s.word(\" else if \")?;\n-                        self.print_expr_as_cond(&i)?;\n-                        self.s.space()?;\n-                        self.print_expr(&then)?;\n-                        self.print_else(e.as_ref().map(|e| &**e))\n-                    }\n-                    // \"final else\"\n-                    hir::ExprKind::Block(ref b, _) => {\n-                        self.cbox(indent_unit - 1)?;\n-                        self.ibox(0)?;\n-                        self.s.word(\" else \")?;\n-                        self.print_block(&b)\n-                    }\n-                    // BLEAH, constraints would be great here\n-                    _ => {\n-                        panic!(\"print_if saw if with weird alternative\");\n-                    }\n-                }\n-            }\n-            _ => Ok(()),\n-        }\n-    }\n-\n-    pub fn print_if(&mut self,\n-                    test: &hir::Expr,\n-                    blk: &hir::Expr,\n-                    elseopt: Option<&hir::Expr>)\n-                    -> io::Result<()> {\n-        self.head(\"if\")?;\n-        self.print_expr_as_cond(test)?;\n-        self.s.space()?;\n-        self.print_expr(blk)?;\n-        self.print_else(elseopt)\n-    }\n-\n-    pub fn print_if_let(&mut self,\n-                        pat: &hir::Pat,\n-                        expr: &hir::Expr,\n-                        blk: &hir::Block,\n-                        elseopt: Option<&hir::Expr>)\n-                        -> io::Result<()> {\n-        self.head(\"if let\")?;\n-        self.print_pat(pat)?;\n-        self.s.space()?;\n-        self.word_space(\"=\")?;\n-        self.print_expr_as_cond(expr)?;\n-        self.s.space()?;\n-        self.print_block(blk)?;\n-        self.print_else(elseopt)\n-    }\n-\n     pub fn print_anon_const(&mut self, constant: &hir::AnonConst) -> io::Result<()> {\n         self.ann.nested(self, Nested::Body(constant.body))\n     }\n@@ -1335,6 +1247,12 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n+    fn print_literal(&mut self, lit: &hir::Lit) -> io::Result<()> {\n+        self.maybe_print_comment(lit.span.lo())?;\n+        let (token, suffix) = lit.node.to_lit_token();\n+        self.writer().word(pprust::literal_to_string(token, suffix))\n+    }\n+\n     pub fn print_expr(&mut self, expr: &hir::Expr) -> io::Result<()> {\n         self.maybe_print_comment(expr.span.lo())?;\n         self.print_outer_attributes(&expr.attrs)?;\n@@ -1406,9 +1324,6 @@ impl<'a> State<'a> {\n                 // Print `}`:\n                 self.bclose_maybe_open(expr.span, indent_unit, true)?;\n             }\n-            hir::ExprKind::If(ref test, ref blk, ref elseopt) => {\n-                self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e))?;\n-            }\n             hir::ExprKind::While(ref test, ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;\n@@ -2414,7 +2329,6 @@ impl<'a> State<'a> {\n /// isn't parsed as (if true {...} else {...} | x) | 5\n fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     match e.node {\n-        hir::ExprKind::If(..) |\n         hir::ExprKind::Match(..) |\n         hir::ExprKind::Block(..) |\n         hir::ExprKind::While(..) |"}, {"sha": "8be610e8bf7af715691b4dd36bcd7fe1f432af6f", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -28,7 +28,7 @@ use smallvec::SmallVec;\n \n fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n     debug_assert!(ich::IGNORED_ATTRIBUTES.len() > 0);\n-    ich::IGNORED_ATTRIBUTES.iter().map(|&s| Symbol::intern(s)).collect()\n+    ich::IGNORED_ATTRIBUTES.iter().map(|&s| s).collect()\n }\n \n /// This is the context state available during incr. comp. hashing. It contains"}, {"sha": "4e5718cc5ef2a275e5057e0c42097ba040b80548", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -162,7 +162,13 @@ impl_stable_hash_for!(enum ::syntax::ast::LitIntType {\n     Unsuffixed\n });\n \n-impl_stable_hash_for_spanned!(::syntax::ast::LitKind);\n+impl_stable_hash_for!(struct ::syntax::ast::Lit {\n+    node,\n+    token,\n+    suffix,\n+    span\n+});\n+\n impl_stable_hash_for!(enum ::syntax::ast::LitKind {\n     Str(value, style),\n     Err(value),\n@@ -175,6 +181,8 @@ impl_stable_hash_for!(enum ::syntax::ast::LitKind {\n     Bool(value)\n });\n \n+impl_stable_hash_for_spanned!(::syntax::ast::LitKind);\n+\n impl_stable_hash_for!(enum ::syntax::ast::IntTy { Isize, I8, I16, I32, I64, I128 });\n impl_stable_hash_for!(enum ::syntax::ast::UintTy { Usize, U8, U16, U32, U64, U128 });\n impl_stable_hash_for!(enum ::syntax::ast::FloatTy { F32, F64 });\n@@ -280,6 +288,19 @@ for tokenstream::TokenStream {\n     }\n }\n \n+impl_stable_hash_for!(enum token::Lit {\n+    Bool(val),\n+    Byte(val),\n+    Char(val),\n+    Err(val),\n+    Integer(val),\n+    Float(val),\n+    Str_(val),\n+    ByteStr(val),\n+    StrRaw(val, n),\n+    ByteStrRaw(val, n)\n+});\n+\n fn hash_token<'a, 'gcx, W: StableHasherResult>(\n     token: &token::Token,\n     hcx: &mut StableHashingContext<'a>,\n@@ -327,22 +348,8 @@ fn hash_token<'a, 'gcx, W: StableHasherResult>(\n         token::Token::CloseDelim(delim_token) => {\n             std_hash::Hash::hash(&delim_token, hasher);\n         }\n-        token::Token::Literal(ref lit, ref opt_name) => {\n-            mem::discriminant(lit).hash_stable(hcx, hasher);\n-            match *lit {\n-                token::Lit::Byte(val) |\n-                token::Lit::Char(val) |\n-                token::Lit::Err(val) |\n-                token::Lit::Integer(val) |\n-                token::Lit::Float(val) |\n-                token::Lit::Str_(val) |\n-                token::Lit::ByteStr(val) => val.hash_stable(hcx, hasher),\n-                token::Lit::StrRaw(val, n) |\n-                token::Lit::ByteStrRaw(val, n) => {\n-                    val.hash_stable(hcx, hasher);\n-                    n.hash_stable(hcx, hasher);\n-                }\n-            };\n+        token::Token::Literal(lit, opt_name) => {\n+            lit.hash_stable(hcx, hasher);\n             opt_name.hash_stable(hcx, hasher);\n         }\n \n@@ -395,6 +402,7 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {\n });\n \n impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n+    IfTemporary,\n     Async,\n     Await,\n     QuestionMark,"}, {"sha": "f3fc7ec8fda1530b4d9fe6295e01ce1967c818d0", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -4,6 +4,8 @@ crate use rustc_data_structures::fingerprint::Fingerprint;\n pub use self::caching_source_map_view::CachingSourceMapView;\n pub use self::hcx::{StableHashingContextProvider, StableHashingContext, NodeIdHashingMode,\n                     hash_stable_trait_impls};\n+use syntax::symbol::{Symbol, sym};\n+\n mod caching_source_map_view;\n mod hcx;\n \n@@ -12,16 +14,16 @@ mod impls_misc;\n mod impls_ty;\n mod impls_syntax;\n \n-pub const ATTR_DIRTY: &str = \"rustc_dirty\";\n-pub const ATTR_CLEAN: &str = \"rustc_clean\";\n-pub const ATTR_IF_THIS_CHANGED: &str = \"rustc_if_this_changed\";\n-pub const ATTR_THEN_THIS_WOULD_NEED: &str = \"rustc_then_this_would_need\";\n-pub const ATTR_PARTITION_REUSED: &str = \"rustc_partition_reused\";\n-pub const ATTR_PARTITION_CODEGENED: &str = \"rustc_partition_codegened\";\n-pub const ATTR_EXPECTED_CGU_REUSE: &str = \"rustc_expected_cgu_reuse\";\n+pub const ATTR_DIRTY: Symbol = sym::rustc_dirty;\n+pub const ATTR_CLEAN: Symbol = sym::rustc_clean;\n+pub const ATTR_IF_THIS_CHANGED: Symbol = sym::rustc_if_this_changed;\n+pub const ATTR_THEN_THIS_WOULD_NEED: Symbol = sym::rustc_then_this_would_need;\n+pub const ATTR_PARTITION_REUSED: Symbol = sym::rustc_partition_reused;\n+pub const ATTR_PARTITION_CODEGENED: Symbol = sym::rustc_partition_codegened;\n+pub const ATTR_EXPECTED_CGU_REUSE: Symbol = sym::rustc_expected_cgu_reuse;\n \n-pub const IGNORED_ATTRIBUTES: &[&str] = &[\n-    \"cfg\",\n+pub const IGNORED_ATTRIBUTES: &[Symbol] = &[\n+    sym::cfg,\n     ATTR_IF_THIS_CHANGED,\n     ATTR_THEN_THIS_WOULD_NEED,\n     ATTR_DIRTY,"}, {"sha": "e4505a240379f0047bbde6f12e9f1e85c2f7612d", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -194,20 +194,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 let mut sp = cm.def_span(self.hir().span_by_hir_id(node));\n                 if let Some(param) = self.hir()\n                     .get_generics(scope)\n-                    .and_then(|generics| generics.get_named(&br.name))\n+                    .and_then(|generics| generics.get_named(br.name))\n                 {\n                     sp = param.span;\n                 }\n                 (format!(\"the lifetime {} as defined on\", br.name), sp)\n             }\n             ty::ReFree(ty::FreeRegion {\n-                bound_region: ty::BoundRegion::BrNamed(_, ref name),\n+                bound_region: ty::BoundRegion::BrNamed(_, name),\n                 ..\n             }) => {\n                 let mut sp = cm.def_span(self.hir().span_by_hir_id(node));\n                 if let Some(param) = self.hir()\n                     .get_generics(scope)\n-                    .and_then(|generics| generics.get_named(&name))\n+                    .and_then(|generics| generics.get_named(name))\n                 {\n                     sp = param.span;\n                 }"}, {"sha": "feade7a8f56f26d1c8b7e4b73e8bca45f4d8af60", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     ) -> Option<AnonymousArgInfo<'_>> {\n         let (id, bound_region) = match *anon_region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n-            ty::ReEarlyBound(ref ebr) => (\n+            ty::ReEarlyBound(ebr) => (\n                 self.tcx().parent(ebr.def_id).unwrap(),\n                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n             ),"}, {"sha": "1878afd581dd48746bc6fd4a2512f39ba2848d00", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -56,7 +56,7 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n     }\n \n     let requested_node = env::var(\"RUST_REGION_GRAPH_NODE\")\n-        .ok().and_then(|s| s.parse().map(DefIndex::from_raw_u32).ok());\n+        .ok().and_then(|s| s.parse().map(DefIndex::from_u32).ok());\n \n     if requested_node.is_some() && requested_node != Some(context.index) {\n         return;\n@@ -90,7 +90,7 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n             let mut new_str = String::new();\n             for c in output_template.chars() {\n                 if c == '%' {\n-                    new_str.push_str(&context.index.as_raw_u32().to_string());\n+                    new_str.push_str(&context.index.as_u32().to_string());\n                 } else {\n                     new_str.push(c);\n                 }"}, {"sha": "4351f94df2f135db586d5b7f310eaac9bd3416b2", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -284,18 +284,40 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"constrain_opaque_type: def_id={:?}\", def_id);\n         debug!(\"constrain_opaque_type: opaque_defn={:#?}\", opaque_defn);\n \n+        let tcx = self.tcx;\n+\n         let concrete_ty = self.resolve_type_vars_if_possible(&opaque_defn.concrete_ty);\n \n         debug!(\"constrain_opaque_type: concrete_ty={:?}\", concrete_ty);\n \n-        let abstract_type_generics = self.tcx.generics_of(def_id);\n+        let abstract_type_generics = tcx.generics_of(def_id);\n \n-        let span = self.tcx.def_span(def_id);\n+        let span = tcx.def_span(def_id);\n \n-        // If there are required region bounds, we can just skip\n-        // ahead.  There will already be a registered region\n-        // obligation related `concrete_ty` to those regions.\n+        // If there are required region bounds, we can use them.\n         if opaque_defn.has_required_region_bounds {\n+            let predicates_of = tcx.predicates_of(def_id);\n+            debug!(\n+                \"constrain_opaque_type: predicates: {:#?}\",\n+                predicates_of,\n+            );\n+            let bounds = predicates_of.instantiate(tcx, opaque_defn.substs);\n+            debug!(\"constrain_opaque_type: bounds={:#?}\", bounds);\n+            let opaque_type = tcx.mk_opaque(def_id, opaque_defn.substs);\n+\n+            let required_region_bounds = tcx.required_region_bounds(\n+                opaque_type,\n+                bounds.predicates.clone(),\n+            );\n+            debug_assert!(!required_region_bounds.is_empty());\n+\n+            for region in required_region_bounds {\n+                concrete_ty.visit_with(&mut OpaqueTypeOutlivesVisitor {\n+                    infcx: self,\n+                    least_region: region,\n+                    span,\n+                });\n+            }\n             return;\n         }\n \n@@ -371,7 +393,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        let least_region = least_region.unwrap_or(self.tcx.lifetimes.re_static);\n+        let least_region = least_region.unwrap_or(tcx.lifetimes.re_static);\n         debug!(\"constrain_opaque_types: least_region={:?}\", least_region);\n \n         concrete_ty.visit_with(&mut OpaqueTypeOutlivesVisitor {\n@@ -589,10 +611,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx>\n             ty::ReLateBound(..) |\n \n             // ignore `'static`, as that can appear anywhere\n-            ty::ReStatic |\n-\n-            // ignore `ReScope`, which may appear in impl Trait in bindings.\n-            ty::ReScope(..) => return r,\n+            ty::ReStatic => return r,\n \n             _ => { }\n         }\n@@ -683,6 +702,23 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx>\n                 self.tcx.mk_closure(def_id, ty::ClosureSubsts { substs })\n             }\n \n+            ty::Generator(def_id, substs, movability) => {\n+                let generics = self.tcx.generics_of(def_id);\n+                let substs = self.tcx.mk_substs(substs.substs.iter().enumerate().map(\n+                    |(index, &kind)| {\n+                        if index < generics.parent_count {\n+                            // Accommodate missing regions in the parent kinds...\n+                            self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                        } else {\n+                            // ...but not elsewhere.\n+                            self.fold_kind_normally(kind)\n+                        }\n+                    },\n+                ));\n+\n+                self.tcx.mk_generator(def_id, ty::GeneratorSubsts { substs }, movability)\n+            }\n+\n             _ => ty.super_fold_with(self),\n         }\n     }"}, {"sha": "69d865f53d469f3083a0bcd6abb6410947f3dc77", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -198,12 +198,6 @@ declare_lint! {\n     \"detects generic lifetime arguments in path segments with late bound lifetime parameters\"\n }\n \n-declare_lint! {\n-    pub INCOHERENT_FUNDAMENTAL_IMPLS,\n-    Deny,\n-    \"potentially-conflicting impls were erroneously allowed\"\n-}\n-\n declare_lint! {\n     pub ORDER_DEPENDENT_TRAIT_OBJECTS,\n     Deny,\n@@ -428,7 +422,6 @@ declare_lint_pass! {\n         MISSING_FRAGMENT_SPECIFIER,\n         PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n         LATE_BOUND_LIFETIME_ARGUMENTS,\n-        INCOHERENT_FUNDAMENTAL_IMPLS,\n         ORDER_DEPENDENT_TRAIT_OBJECTS,\n         DEPRECATED,\n         UNUSED_UNSAFE,"}, {"sha": "7e1e751e856478197de92a2e69dc2e2b86ebcea3", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -828,8 +828,8 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n \n                 // This shouldn't ever be needed, but just in case:\n                 Ok(vec![match trait_ref {\n-                    Some(trait_ref) => Symbol::intern(&format!(\"{:?}\", trait_ref)).as_str(),\n-                    None => Symbol::intern(&format!(\"<{}>\", self_ty)).as_str(),\n+                    Some(trait_ref) => LocalInternedString::intern(&format!(\"{:?}\", trait_ref)),\n+                    None => LocalInternedString::intern(&format!(\"<{}>\", self_ty)),\n                 }])\n             }\n \n@@ -845,9 +845,10 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n                 // This shouldn't ever be needed, but just in case:\n                 path.push(match trait_ref {\n                     Some(trait_ref) => {\n-                        Symbol::intern(&format!(\"<impl {} for {}>\", trait_ref, self_ty)).as_str()\n+                        LocalInternedString::intern(&format!(\"<impl {} for {}>\", trait_ref,\n+                                                    self_ty))\n                     },\n-                    None => Symbol::intern(&format!(\"<impl {}>\", self_ty)).as_str(),\n+                    None => LocalInternedString::intern(&format!(\"<impl {}>\", self_ty)),\n                 });\n \n                 Ok(path)"}, {"sha": "9c926dff325bfb5a270f090d283c43c656660d1e", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -14,7 +14,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate;\n use syntax::source_map::MultiSpan;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n \n pub struct LintLevelSets {\n     list: Vec<LintSet>,\n@@ -194,7 +194,7 @@ impl<'a> LintLevelsBuilder<'a> {\n             struct_span_err!(sess, span, E0452, \"malformed lint attribute\")\n         };\n         for attr in attrs {\n-            let level = match Level::from_str(&attr.name_or_empty()) {\n+            let level = match Level::from_symbol(attr.name_or_empty()) {\n                 None => continue,\n                 Some(lvl) => lvl,\n             };\n@@ -221,7 +221,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                 match item.node {\n                     ast::MetaItemKind::Word => {}  // actual lint names handled later\n                     ast::MetaItemKind::NameValue(ref name_value) => {\n-                        if item.path == \"reason\" {\n+                        if item.path == sym::reason {\n                             // found reason, reslice meta list to exclude it\n                             metas = &metas[0..metas.len()-1];\n                             // FIXME (#55112): issue unused-attributes lint if we thereby\n@@ -230,7 +230,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                                 if !self.sess.features_untracked().lint_reasons {\n                                     feature_gate::emit_feature_err(\n                                         &self.sess.parse_sess,\n-                                        \"lint_reasons\",\n+                                        sym::lint_reasons,\n                                         item.span,\n                                         feature_gate::GateIssue::Language,\n                                         \"lint reasons are experimental\"\n@@ -261,7 +261,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         let mut err = bad_attr(li.span());\n                         if let Some(item) = li.meta_item() {\n                             if let ast::MetaItemKind::NameValue(_) = item.node {\n-                                if item.path == \"reason\" {\n+                                if item.path == sym::reason {\n                                     err.help(\"reason in lint attribute must come last\");\n                                 }\n                             }"}, {"sha": "9c4683e094634eea384d348ff8c2b9785a6c6dfe", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -38,7 +38,7 @@ use syntax::ast;\n use syntax::source_map::{MultiSpan, ExpnFormat};\n use syntax::early_buffered_lints::BufferedEarlyLintId;\n use syntax::edition::Edition;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n \n pub use crate::lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n@@ -570,6 +570,17 @@ impl Level {\n             _ => None,\n         }\n     }\n+\n+    /// Converts a symbol to a level.\n+    pub fn from_symbol(x: Symbol) -> Option<Level> {\n+        match x {\n+            sym::allow => Some(Allow),\n+            sym::warn => Some(Warn),\n+            sym::deny => Some(Deny),\n+            sym::forbid => Some(Forbid),\n+            _ => None,\n+        }\n+    }\n }\n \n /// How a lint level was set.\n@@ -752,7 +763,7 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n \n pub fn maybe_lint_level_root(tcx: TyCtxt<'_, '_, '_>, id: hir::HirId) -> bool {\n     let attrs = tcx.hir().attrs_by_hir_id(id);\n-    attrs.iter().any(|attr| Level::from_str(&attr.name_or_empty()).is_some())\n+    attrs.iter().any(|attr| Level::from_symbol(attr.name_or_empty()).is_some())\n }\n \n fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n@@ -767,6 +778,9 @@ fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n \n     let push = builder.levels.push(&krate.attrs);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n+    for macro_def in &krate.exported_macros {\n+       builder.levels.register_id(macro_def.hir_id);\n+    }\n     intravisit::walk_crate(&mut builder, krate);\n     builder.levels.pop(push);\n "}, {"sha": "2a9928567f4dcfa2fed79a3dd44afba6ed765089", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -19,6 +19,7 @@ use rustc_data_structures::fx::FxHashMap;\n \n use syntax::{ast, source_map};\n use syntax::attr;\n+use syntax::symbol::sym;\n use syntax_pos;\n \n // Any local node that may call something in its body block should be\n@@ -304,22 +305,22 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n                                     id: hir::HirId,\n                                     attrs: &[ast::Attribute]) -> bool {\n-    if attr::contains_name(attrs, \"lang\") {\n+    if attr::contains_name(attrs, sym::lang) {\n         return true;\n     }\n \n     // Stable attribute for #[lang = \"panic_impl\"]\n-    if attr::contains_name(attrs, \"panic_handler\") {\n+    if attr::contains_name(attrs, sym::panic_handler) {\n         return true;\n     }\n \n     // (To be) stable attribute for #[lang = \"oom\"]\n-    if attr::contains_name(attrs, \"alloc_error_handler\") {\n+    if attr::contains_name(attrs, sym::alloc_error_handler) {\n         return true;\n     }\n \n     // Don't lint about global allocators\n-    if attr::contains_name(attrs, \"global_allocator\") {\n+    if attr::contains_name(attrs, sym::global_allocator) {\n         return true;\n     }\n "}, {"sha": "67db2ec2481566e512869beff6b1c6e48dee2b03", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -4,6 +4,7 @@ use crate::session::{config, Session};\n use crate::session::config::EntryFnType;\n use syntax::attr;\n use syntax::entry::EntryPointType;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n use crate::hir::{HirId, Item, ItemKind, ImplItem, TraitItem};\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n@@ -58,7 +59,7 @@ fn entry_fn(tcx: TyCtxt<'_, '_, '_>, cnum: CrateNum) -> Option<(DefId, EntryFnTy\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if attr::contains_name(&tcx.hir().krate().attrs, \"no_main\") {\n+    if attr::contains_name(&tcx.hir().krate().attrs, sym::no_main) {\n         return None;\n     }\n \n@@ -81,11 +82,11 @@ fn entry_fn(tcx: TyCtxt<'_, '_, '_>, cnum: CrateNum) -> Option<(DefId, EntryFnTy\n fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n     match item.node {\n         ItemKind::Fn(..) => {\n-            if attr::contains_name(&item.attrs, \"start\") {\n+            if attr::contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n-            } else if attr::contains_name(&item.attrs, \"main\") {\n+            } else if attr::contains_name(&item.attrs, sym::main) {\n                 EntryPointType::MainAttr\n-            } else if item.ident.name == \"main\" {\n+            } else if item.ident.name == sym::main {\n                 if at_root {\n                     // This is a top-level function so can be 'main'.\n                     EntryPointType::MainNamed"}, {"sha": "d46bba92f3fc90947c66d07b91fdfddcc2952dca", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -424,14 +424,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_exprs(exprs);\n             }\n \n-            hir::ExprKind::If(ref cond_expr, ref then_expr, ref opt_else_expr) => {\n-                self.consume_expr(&cond_expr);\n-                self.walk_expr(&then_expr);\n-                if let Some(ref else_expr) = *opt_else_expr {\n-                    self.consume_expr(&else_expr);\n-                }\n-            }\n-\n             hir::ExprKind::Match(ref discr, ref arms, _) => {\n                 let discr_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&discr)));\n                 let r = self.tcx().lifetimes.re_empty;"}, {"sha": "103580a598fcd9cea61e1c2804894fc985bf3d46", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -18,7 +18,7 @@ use crate::middle::weak_lang_items;\n use crate::util::nodemap::FxHashMap;\n \n use syntax::ast;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n use rustc_macros::HashStable;\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n@@ -209,9 +209,9 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n /// are also extracted out when found.\n pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n     attrs.iter().find_map(|attr| Some(match attr {\n-        _ if attr.check_name(\"lang\") => (attr.value_str()?, attr.span),\n-        _ if attr.check_name(\"panic_handler\") => (Symbol::intern(\"panic_impl\"), attr.span),\n-        _ if attr.check_name(\"alloc_error_handler\") => (Symbol::intern(\"oom\"), attr.span),\n+        _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n+        _ if attr.check_name(sym::panic_handler) => (Symbol::intern(\"panic_impl\"), attr.span),\n+        _ if attr.check_name(sym::alloc_error_handler) => (Symbol::intern(\"oom\"), attr.span),\n         _ => return None,\n     }))\n }"}, {"sha": "76934ddd69b1bb7d9efab259f58e669fba61a630", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -8,7 +8,7 @@ use crate::ty::TyCtxt;\n use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use syntax::symbol::Symbol;\n use syntax::ast::{Attribute, MetaItem, MetaItemKind};\n-use syntax_pos::{Span, symbols};\n+use syntax_pos::{Span, sym};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_macros::HashStable;\n use errors::DiagnosticId;\n@@ -51,7 +51,7 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n     }\n \n     fn extract(&self, attr: &Attribute) -> Option<(Symbol, Option<Symbol>, Span)> {\n-        let stab_attrs = [symbols::stable, symbols::unstable, symbols::rustc_const_unstable];\n+        let stab_attrs = [sym::stable, sym::unstable, sym::rustc_const_unstable];\n \n         // Find a stability attribute (i.e., `#[stable (..)]`, `#[unstable (..)]`,\n         // `#[rustc_const_unstable (..)]`).\n@@ -65,9 +65,9 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n                 for meta in metas {\n                     if let Some(mi) = meta.meta_item() {\n                         // Find the `feature = \"..\"` meta-item.\n-                        match (mi.name_or_empty().get(), mi.value_str()) {\n-                            (\"feature\", val) => feature = val,\n-                            (\"since\", val) => since = val,\n+                        match (mi.name_or_empty(), mi.value_str()) {\n+                            (sym::feature, val) => feature = val,\n+                            (sym::since, val) => since = val,\n                             _ => {}\n                         }\n                     }\n@@ -76,7 +76,7 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n                     // This additional check for stability is to make sure we\n                     // don't emit additional, irrelevant errors for malformed\n                     // attributes.\n-                    if *stab_attr != \"stable\" || since.is_some() {\n+                    if *stab_attr != sym::stable || since.is_some() {\n                         return Some((feature, since, attr.span));\n                     }\n                 }"}, {"sha": "cb333b5b0cba23e808ed1d3f6257c5aaef1ac081", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 26, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -112,7 +112,7 @@ use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n use syntax::ptr::P;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::Span;\n \n use crate::hir;\n@@ -362,7 +362,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     if let FnKind::Method(..) = fk {\n         let parent = ir.tcx.hir().get_parent_item(id);\n         if let Some(Node::Item(i)) = ir.tcx.hir().find_by_hir_id(parent) {\n-            if i.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n+            if i.attrs.iter().any(|a| a.check_name(sym::automatically_derived)) {\n                 return;\n             }\n         }\n@@ -500,7 +500,6 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n       }\n \n       // live nodes required for interesting control flow:\n-      hir::ExprKind::If(..) |\n       hir::ExprKind::Match(..) |\n       hir::ExprKind::While(..) |\n       hir::ExprKind::Loop(..) => {\n@@ -1040,28 +1039,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 })\n             }\n \n-            hir::ExprKind::If(ref cond, ref then, ref els) => {\n-                //\n-                //     (cond)\n-                //       |\n-                //       v\n-                //     (expr)\n-                //     /   \\\n-                //    |     |\n-                //    v     v\n-                //  (then)(els)\n-                //    |     |\n-                //    v     v\n-                //   (  succ  )\n-                //\n-                let else_ln = self.propagate_through_opt_expr(els.as_ref().map(|e| &**e), succ);\n-                let then_ln = self.propagate_through_expr(&then, succ);\n-                let ln = self.live_node(expr.hir_id, expr.span);\n-                self.init_from_succ(ln, else_ln);\n-                self.merge_from_succ(ln, then_ln, false);\n-                self.propagate_through_expr(&cond, ln)\n-            }\n-\n             hir::ExprKind::While(ref cond, ref blk, _) => {\n                 self.propagate_through_loop(expr, WhileLoop(&cond), &blk, succ)\n             }\n@@ -1523,7 +1500,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n         }\n \n         // no correctness conditions related to liveness\n-        hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) | hir::ExprKind::If(..) |\n+        hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) |\n         hir::ExprKind::Match(..) | hir::ExprKind::While(..) | hir::ExprKind::Loop(..) |\n         hir::ExprKind::Index(..) | hir::ExprKind::Field(..) |\n         hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::Binary(..) |"}, {"sha": "c7f8cf684e6b16c28c56408e92bc55b1999da574", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -72,6 +72,7 @@ use crate::hir::{MutImmutable, MutMutable, PatKind};\n use crate::hir::pat_util::EnumerateAndAdjustIterator;\n use crate::hir;\n use syntax::ast::{self, Name};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n use std::borrow::Cow;\n@@ -678,7 +679,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Closure(..) | hir::ExprKind::Ret(..) |\n             hir::ExprKind::Unary(..) | hir::ExprKind::Yield(..) |\n             hir::ExprKind::MethodCall(..) | hir::ExprKind::Cast(..) | hir::ExprKind::DropTemps(..) |\n-            hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::If(..) |\n+            hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) |\n             hir::ExprKind::Binary(..) | hir::ExprKind::While(..) |\n             hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) | hir::ExprKind::Match(..) |\n             hir::ExprKind::Lit(..) | hir::ExprKind::Break(..) |\n@@ -714,7 +715,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 // they also cannot be moved out of.\n                 let is_thread_local = self.tcx.get_attrs(def_id)[..]\n                     .iter()\n-                    .any(|attr| attr.check_name(\"thread_local\"));\n+                    .any(|attr| attr.check_name(sym::thread_local));\n \n                 let cat = if is_thread_local {\n                     let re = self.temporary_scope(hir_id.local_id);"}, {"sha": "5f355d17072b8705682073bd7377fdd681e26405", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -7,15 +7,16 @@\n \n use crate::session::Session;\n use syntax::ast;\n+use syntax::symbol::{Symbol, sym};\n \n use rustc_data_structures::sync::Once;\n \n pub fn update_limits(sess: &Session, krate: &ast::Crate) {\n-    update_limit(krate, &sess.recursion_limit, \"recursion_limit\", 64);\n-    update_limit(krate, &sess.type_length_limit, \"type_length_limit\", 1048576);\n+    update_limit(krate, &sess.recursion_limit, sym::recursion_limit, 64);\n+    update_limit(krate, &sess.type_length_limit, sym::type_length_limit, 1048576);\n }\n \n-fn update_limit(krate: &ast::Crate, limit: &Once<usize>, name: &str, default: usize) {\n+fn update_limit(krate: &ast::Crate, limit: &Once<usize>, name: Symbol, default: usize) {\n     for attr in &krate.attrs {\n         if !attr.check_name(name) {\n             continue;"}, {"sha": "37681ad7fcdd2bc51708264a8246e7a8a3ede9f0", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -158,7 +158,7 @@ newtype_index! {\n impl_stable_hash_for!(struct crate::middle::region::FirstStatementIndex { private });\n \n // compilation error if size of `ScopeData` is not the same as a `u32`\n-static_assert!(ASSERT_SCOPE_DATA: mem::size_of::<ScopeData>() == 4);\n+static_assert_size!(ScopeData, 4);\n \n impl Scope {\n     /// Returns a item-local ID associated with this scope.\n@@ -884,17 +884,6 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n                     terminating(r.hir_id.local_id);\n             }\n \n-            hir::ExprKind::If(ref expr, ref then, Some(ref otherwise)) => {\n-                terminating(expr.hir_id.local_id);\n-                terminating(then.hir_id.local_id);\n-                terminating(otherwise.hir_id.local_id);\n-            }\n-\n-            hir::ExprKind::If(ref expr, ref then, None) => {\n-                terminating(expr.hir_id.local_id);\n-                terminating(then.hir_id.local_id);\n-            }\n-\n             hir::ExprKind::Loop(ref body, _, _) => {\n                 terminating(body.hir_id.local_id);\n             }"}, {"sha": "2402d0eefde4886e0bdc5e8e077a487753b58c8b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -23,7 +23,7 @@ use std::mem::replace;\n use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::Span;\n \n use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -1285,7 +1285,7 @@ fn compute_object_lifetime_defaults(\n                 let result = object_lifetime_defaults_for_item(tcx, generics);\n \n                 // Debugging aid.\n-                if attr::contains_name(&item.attrs, \"rustc_object_lifetime_default\") {\n+                if attr::contains_name(&item.attrs, sym::rustc_object_lifetime_default) {\n                     let object_lifetime_default_reprs: String = result\n                         .iter()\n                         .map(|set| match *set {"}, {"sha": "abcf164cda6d46f783eec9251c3311f79a9c73be", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -11,7 +11,7 @@ use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::ty::query::Providers;\n use crate::middle::privacy::AccessLevels;\n use crate::session::{DiagnosticMessageId, Session};\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::{Span, MultiSpan};\n use syntax::ast::Attribute;\n use syntax::errors::Applicability;\n@@ -195,7 +195,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n             // Emit errors for non-staged-api crates.\n             for attr in attrs {\n                 let name = attr.name_or_empty();\n-                if [\"unstable\", \"stable\", \"rustc_deprecated\"].contains(&name.get()) {\n+                if [sym::unstable, sym::stable, sym::rustc_deprecated].contains(&name) {\n                     attr::mark_used(attr);\n                     self.tcx.sess.span_err(attr.span, \"stability attributes may not be used \\\n                                                         outside of the standard library\");\n@@ -669,7 +669,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         match stability {\n             Some(&Stability { level: attr::Unstable { reason, issue }, feature, .. }) => {\n-                if span.allows_unstable(&feature.as_str()) {\n+                if span.allows_unstable(feature) {\n                     debug!(\"stability: skipping span={:?} since it is internal\", span);\n                     return EvalResult::Allow;\n                 }\n@@ -686,7 +686,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // the `-Z force-unstable-if-unmarked` flag present (we're\n                 // compiling a compiler crate), then let this missing feature\n                 // annotation slide.\n-                if feature == \"rustc_private\" && issue == 27812 {\n+                if feature == sym::rustc_private && issue == 27812 {\n                     if self.sess.opts.debugging_opts.force_unstable_if_unmarked {\n                         return EvalResult::Allow;\n                     }\n@@ -739,7 +739,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 let error_id = (DiagnosticMessageId::StabilityId(issue), span_key, msg.clone());\n                 let fresh = self.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n                 if fresh {\n-                    emit_feature_err(&self.sess.parse_sess, &feature.as_str(), span,\n+                    emit_feature_err(&self.sess.parse_sess, feature, span,\n                                      GateIssue::Library(Some(issue)), &msg);\n                 }\n             }\n@@ -802,13 +802,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n                 if adt_def.has_dtor(self.tcx) {\n                     emit_feature_err(&self.tcx.sess.parse_sess,\n-                                     \"untagged_unions\", item.span, GateIssue::Language,\n+                                     sym::untagged_unions, item.span, GateIssue::Language,\n                                      \"unions with `Drop` implementations are unstable\");\n                 } else {\n                     let param_env = self.tcx.param_env(def_id);\n                     if !param_env.can_type_implement_copy(self.tcx, ty).is_ok() {\n                         emit_feature_err(&self.tcx.sess.parse_sess,\n-                                         \"untagged_unions\", item.span, GateIssue::Language,\n+                                         sym::untagged_unions, item.span, GateIssue::Language,\n                                          \"unions with non-`Copy` fields are unstable\");\n                     }\n                 }"}, {"sha": "75c21c738f7a07ae9e0da2de1d5ffcfa77c7d92f", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -6,7 +6,7 @@ use crate::middle::lang_items;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_target::spec::PanicStrategy;\n use syntax::ast;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n@@ -46,8 +46,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     lang_items::extract(attrs).and_then(|(name, _)| {\n-        $(if name == stringify!($name) {\n-            Some(Symbol::intern(stringify!($sym)))\n+        $(if name == sym::$name {\n+            Some(sym::$sym)\n         } else)* {\n             None\n         }"}, {"sha": "59b7891b90fde918284e32a82dfdf68ffa0aeeec", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -78,7 +78,7 @@ pub struct Pointer<Tag=(),Id=AllocId> {\n     pub tag: Tag,\n }\n \n-static_assert!(POINTER_SIZE: ::std::mem::size_of::<Pointer>() == 16);\n+static_assert_size!(Pointer, 16);\n \n /// Produces a `Pointer` which points to the beginning of the Allocation\n impl From<AllocId> for Pointer {"}, {"sha": "551b86390db4c43d1e0a3253cf2a16c11776c2ae", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -54,7 +54,7 @@ pub enum ConstValue<'tcx> {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(CONST_SIZE: ::std::mem::size_of::<ConstValue<'static>>() == 40);\n+static_assert_size!(ConstValue<'_>, 40);\n \n impl<'tcx> ConstValue<'tcx> {\n     #[inline]\n@@ -111,7 +111,7 @@ pub enum Scalar<Tag=(), Id=AllocId> {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(SCALAR_SIZE: ::std::mem::size_of::<Scalar>() == 24);\n+static_assert_size!(Scalar, 24);\n \n impl<Tag> fmt::Display for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "dd43cb2f18ece8d3c09ec480dc786b12f97c2295", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1738,7 +1738,7 @@ pub struct Statement<'tcx> {\n \n // `Statement` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(MEM_SIZE_OF_STATEMENT: mem::size_of::<Statement<'_>>() == 56);\n+static_assert_size!(Statement<'_>, 56);\n \n impl<'tcx> Statement<'tcx> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n@@ -1997,10 +1997,9 @@ pub type PlaceProjection<'tcx> = Projection<Place<'tcx>, Local, Ty<'tcx>>;\n /// and the index is a local.\n pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n \n-// at least on 64 bit systems, `PlaceElem` should not be larger than two pointers\n-static_assert!(PROJECTION_ELEM_IS_2_PTRS_LARGE:\n-    mem::size_of::<PlaceElem<'_>>() <= 16\n-);\n+// At least on 64 bit systems, `PlaceElem` should not be larger than two pointers.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(PlaceElem<'_>, 16);\n \n /// Alias for projections as they appear in `UserTypeProjection`, where we\n /// need neither the `V` parameter for `Index` nor the `T` for `Field`."}, {"sha": "a26468b0fb6ce0560bc1a1cb46c404dddd0a1872", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,6 +1,6 @@\n use crate::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use crate::hir::HirId;\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::InternedString;\n use crate::ty::{Instance, TyCtxt};\n use crate::util::nodemap::FxHashMap;\n use rustc_data_structures::base_n;\n@@ -280,7 +280,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> CodegenUnitNameBuilder<'a, 'gcx, 'tcx> {\n             cgu_name\n         } else {\n             let cgu_name = &cgu_name.as_str()[..];\n-            Symbol::intern(&CodegenUnit::mangle_name(cgu_name)).as_interned_str()\n+            InternedString::intern(&CodegenUnit::mangle_name(cgu_name))\n         }\n     }\n \n@@ -336,6 +336,6 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> CodegenUnitNameBuilder<'a, 'gcx, 'tcx> {\n             write!(cgu_name, \".{}\", special_suffix).unwrap();\n         }\n \n-        Symbol::intern(&cgu_name[..]).as_interned_str()\n+        InternedString::intern(&cgu_name[..])\n     }\n }"}, {"sha": "5135aeb2392cd85e054023c22c1cf6077a004bac", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -17,9 +17,9 @@ pub struct PlaceTy<'tcx> {\n     pub variant_index: Option<VariantIdx>,\n }\n \n-static_assert!(PLACE_TY_IS_3_PTRS_LARGE:\n-    mem::size_of::<PlaceTy<'_>>() <= 24\n-);\n+// At least on 64 bit systems, `PlaceTy` should not be larger than two or three pointers.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(PlaceTy<'_>, 16);\n \n impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     pub fn from_ty(ty: Ty<'tcx>) -> PlaceTy<'tcx> {"}, {"sha": "2fff4c3f109b103565cbcd910653252f57758d5e", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1052,7 +1052,7 @@ rustc_queries! {\n     }\n \n     Other {\n-        query target_features_whitelist(_: CrateNum) -> Lrc<FxHashMap<String, Option<String>>> {\n+        query target_features_whitelist(_: CrateNum) -> Lrc<FxHashMap<String, Option<Symbol>>> {\n             eval_always\n             desc { \"looking up the whitelist of target features\" }\n         }"}, {"sha": "b5e3c4cda0a66f20d13297585046b7b35e5e1944", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1744,8 +1744,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n         opt::multi_s(\n             \"\",\n             \"print\",\n-            \"Comma separated list of compiler information to \\\n-             print on stdout\",\n+            \"Compiler information to print on stdout\",\n             \"[crate-name|file-names|sysroot|cfg|target-list|\\\n              target-cpus|target-features|relocation-models|\\\n              code-models|tls-models|target-spec-json|native-static-libs]\",\n@@ -2753,6 +2752,7 @@ mod tests {\n     // another --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n+        use syntax::symbol::sym;\n         syntax::with_globals(|| {\n             let matches = &match optgroups().parse(&[\"--test\".to_string(),\n                                                      \"--cfg=test\".to_string()]) {\n@@ -2763,7 +2763,7 @@ mod tests {\n             let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n             let sess = build_session(sessopts, None, registry);\n             let cfg = build_configuration(&sess, to_crate_config(cfg));\n-            let mut test_items = cfg.iter().filter(|&&(name, _)| name == \"test\");\n+            let mut test_items = cfg.iter().filter(|&&(name, _)| name == sym::test);\n             assert!(test_items.next().is_some());\n             assert!(test_items.next().is_none());\n         });"}, {"sha": "4d47491661e8639fba50b6752de90e7eaa5bae4d", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -29,6 +29,7 @@ use syntax::feature_gate::{self, AttributeType};\n use syntax::json::JsonEmitter;\n use syntax::source_map;\n use syntax::parse::{self, ParseSess};\n+use syntax::symbol::Symbol;\n use syntax_pos::{MultiSpan, Span};\n use crate::util::profiling::SelfProfiler;\n \n@@ -86,7 +87,7 @@ pub struct Session {\n     /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n     pub one_time_diagnostics: Lock<FxHashSet<(DiagnosticMessageId, Option<Span>, String)>>,\n     pub plugin_llvm_passes: OneThread<RefCell<Vec<String>>>,\n-    pub plugin_attributes: Lock<Vec<(String, AttributeType)>>,\n+    pub plugin_attributes: Lock<Vec<(Symbol, AttributeType)>>,\n     pub crate_types: Once<Vec<config::CrateType>>,\n     pub dependency_formats: Once<dependency_format::Dependencies>,\n     /// The crate_disambiguator is constructed out of all the `-C metadata`"}, {"sha": "afbce5a4f0a49170e83fd41347281b9eeca6e368", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -4,17 +4,16 @@\n //! [trait-resolution]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n //! [trait-specialization]: https://rust-lang.github.io/rustc-guide/traits/specialization.html\n \n-use crate::infer::CombinedSnapshot;\n+use crate::infer::{CombinedSnapshot, InferOk};\n use crate::hir::def_id::{DefId, LOCAL_CRATE};\n-use syntax_pos::DUMMY_SP;\n use crate::traits::{self, Normalized, SelectionContext, Obligation, ObligationCause};\n use crate::traits::IntercrateMode;\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::Subst;\n-\n-use crate::infer::{InferOk};\n+use syntax::symbol::sym;\n+use syntax_pos::DUMMY_SP;\n \n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n@@ -233,7 +232,7 @@ pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n pub fn trait_ref_is_local_or_fundamental<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                          trait_ref: ty::TraitRef<'tcx>)\n                                                          -> bool {\n-    trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, \"fundamental\")\n+    trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, sym::fundamental)\n }\n \n pub enum OrphanCheckErr<'tcx> {"}, {"sha": "9019c4a0575d40b9c5c12df1aa7fb6335cd946cf", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -35,6 +35,7 @@ use crate::util::nodemap::{FxHashMap, FxHashSet};\n use errors::{Applicability, DiagnosticBuilder};\n use std::fmt;\n use syntax::ast;\n+use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, Span, ExpnInfo, ExpnFormat};\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n@@ -329,7 +330,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             return None\n         };\n \n-        if tcx.has_attr(impl_def_id, \"rustc_on_unimplemented\") {\n+        if tcx.has_attr(impl_def_id, sym::rustc_on_unimplemented) {\n             Some(impl_def_id)\n         } else {\n             None\n@@ -642,13 +643,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             .map(|s| &s == \"?\")\n                             .unwrap_or(false);\n                         let is_from = format!(\"{}\", trait_ref).starts_with(\"std::convert::From<\");\n-                        let message = if is_try && is_from {\n-                            Some(format!(\n+                        let (message, note) = if is_try && is_from {\n+                            (Some(format!(\n                                 \"`?` couldn't convert the error to `{}`\",\n                                 trait_ref.self_ty(),\n+                            )), Some(\n+                                \"the question mark operation (`?`) implicitly performs a \\\n+                                 conversion on the error value using the `From` trait\".to_owned()\n                             ))\n                         } else {\n-                            message\n+                            (message, note)\n                         };\n \n                         let mut err = struct_span_err!("}, {"sha": "55216f644a180626fdf1eb15369ce64999fe8c1a", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -18,7 +18,8 @@ use crate::ty::{self, Ty, TyCtxt, TypeFoldable, Predicate, ToPredicate};\n use crate::ty::subst::{Subst, InternalSubsts};\n use std::borrow::Cow;\n use std::iter::{self};\n-use syntax::ast::{self, Name};\n+use syntax::ast::{self};\n+use syntax::symbol::InternedString;\n use syntax_pos::Span;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n@@ -539,7 +540,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         // are implemented\n         let unsized_self_ty: Ty<'tcx> = self.mk_ty_param(\n             ::std::u32::MAX,\n-            Name::intern(\"RustaceansAreAwesome\").as_interned_str(),\n+            InternedString::intern(\"RustaceansAreAwesome\"),\n         );\n \n         // `Receiver[Self => U]`"}, {"sha": "7ba7429f465a6642604d307dc05bd0b30b40d3a1", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -7,6 +7,7 @@ use crate::util::nodemap::FxHashMap;\n \n use syntax::ast::{MetaItem, NestedMetaItem};\n use syntax::attr;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n use syntax_pos::symbol::LocalInternedString;\n \n@@ -84,25 +85,25 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n         let mut note = None;\n         let mut subcommands = vec![];\n         for item in item_iter {\n-            if item.check_name(\"message\") && message.is_none() {\n+            if item.check_name(sym::message) && message.is_none() {\n                 if let Some(message_) = item.value_str() {\n                     message = Some(OnUnimplementedFormatString::try_parse(\n                         tcx, trait_def_id, message_.as_str(), span)?);\n                     continue;\n                 }\n-            } else if item.check_name(\"label\") && label.is_none() {\n+            } else if item.check_name(sym::label) && label.is_none() {\n                 if let Some(label_) = item.value_str() {\n                     label = Some(OnUnimplementedFormatString::try_parse(\n                         tcx, trait_def_id, label_.as_str(), span)?);\n                     continue;\n                 }\n-            } else if item.check_name(\"note\") && note.is_none() {\n+            } else if item.check_name(sym::note) && note.is_none() {\n                 if let Some(note_) = item.value_str() {\n                     note = Some(OnUnimplementedFormatString::try_parse(\n                         tcx, trait_def_id, note_.as_str(), span)?);\n                     continue;\n                 }\n-            } else if item.check_name(\"on\") && is_root &&\n+            } else if item.check_name(sym::on) && is_root &&\n                 message.is_none() && label.is_none() && note.is_none()\n             {\n                 if let Some(items) = item.meta_item_list() {\n@@ -139,7 +140,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n     {\n         let attrs = tcx.get_attrs(impl_def_id);\n \n-        let attr = if let Some(item) = attr::find_by_name(&attrs, \"rustc_on_unimplemented\") {\n+        let attr = if let Some(item) = attr::find_by_name(&attrs, sym::rustc_on_unimplemented) {\n             item\n         } else {\n             return Ok(None);"}, {"sha": "67e76f7625ceee237c6ef5f5018603365ad80f83", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -19,6 +19,7 @@ use crate::mir::interpret::{GlobalId, ConstValue};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use rustc_macros::HashStable;\n use syntax::ast::Ident;\n+use syntax::symbol::sym;\n use crate::ty::subst::{Subst, InternalSubsts};\n use crate::ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n@@ -1318,9 +1319,9 @@ fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n                                             gen_sig)\n         .map_bound(|(trait_ref, yield_ty, return_ty)| {\n             let name = tcx.associated_item(obligation.predicate.item_def_id).ident.name;\n-            let ty = if name == \"Return\" {\n+            let ty = if name == sym::Return {\n                 return_ty\n-            } else if name == \"Yield\" {\n+            } else if name == sym::Yield {\n                 yield_ty\n             } else {\n                 bug!()\n@@ -1420,7 +1421,7 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n                 projection_ty: ty::ProjectionTy::from_ref_and_name(\n                     tcx,\n                     trait_ref,\n-                    Ident::from_str(FN_OUTPUT_NAME),\n+                    Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n                 ),\n                 ty: ret_type\n             }"}, {"sha": "c4be85050dbc2a04b9a82ef2c70bc419458ca0c9", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -43,6 +43,7 @@ use crate::hir;\n use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::Lock;\n use rustc_target::spec::abi::Abi;\n+use std::cell::Cell;\n use std::cmp;\n use std::fmt::{self, Display};\n use std::iter;\n@@ -153,6 +154,36 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n     /// selection-context's freshener. Used to check for recursion.\n     fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n \n+    /// Starts out as false -- if, during evaluation, we encounter a\n+    /// cycle, then we will set this flag to true for all participants\n+    /// in the cycle (apart from the \"head\" node). These participants\n+    /// will then forego caching their results. This is not the most\n+    /// efficient solution, but it addresses #60010. The problem we\n+    /// are trying to prevent:\n+    ///\n+    /// - If you have `A: AutoTrait` requires `B: AutoTrait` and `C: NonAutoTrait`\n+    /// - `B: AutoTrait` requires `A: AutoTrait` (coinductive cycle, ok)\n+    /// - `C: NonAutoTrait` requires `A: AutoTrait` (non-coinductive cycle, not ok)\n+    ///\n+    /// you don't want to cache that `B: AutoTrait` or `A: AutoTrait`\n+    /// is `EvaluatedToOk`; this is because they were only considered\n+    /// ok on the premise that if `A: AutoTrait` held, but we indeed\n+    /// encountered a problem (later on) with `A: AutoTrait. So we\n+    /// currently set a flag on the stack node for `B: AutoTrait` (as\n+    /// well as the second instance of `A: AutoTrait`) to supress\n+    /// caching.\n+    ///\n+    /// This is a simple, targeted fix. A more-performant fix requires\n+    /// deeper changes, but would permit more caching: we could\n+    /// basically defer caching until we have fully evaluated the\n+    /// tree, and then cache the entire tree at once. In any case, the\n+    /// performance impact here shouldn't be so horrible: every time\n+    /// this is hit, we do cache at least one trait, so we only\n+    /// evaluate each member of a cycle up to N times, where N is the\n+    /// length of the cycle. This means the performance impact is\n+    /// bounded and we shouldn't have any terrible worst-cases.\n+    in_cycle: Cell<bool>,\n+\n     previous: TraitObligationStackList<'prev, 'tcx>,\n }\n \n@@ -840,8 +871,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack));\n         let result = result?;\n \n-        debug!(\"CACHE MISS: EVAL({:?})={:?}\", fresh_trait_ref, result);\n-        self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n+        if !stack.in_cycle.get() {\n+            debug!(\"CACHE MISS: EVAL({:?})={:?}\", fresh_trait_ref, result);\n+            self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n+        } else {\n+            debug!(\n+                \"evaluate_trait_predicate_recursively: skipping cache because {:?} \\\n+                 is a cycle participant\",\n+                fresh_trait_ref,\n+            );\n+        }\n \n         Ok(result)\n     }\n@@ -948,6 +987,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         {\n             debug!(\"evaluate_stack({:?}) --> recursive\", stack.fresh_trait_ref);\n \n+            // If we have a stack like `A B C D E A`, where the top of\n+            // the stack is the final `A`, then this will iterate over\n+            // `A, E, D, C, B` -- i.e., all the participants apart\n+            // from the cycle head. We mark them as participating in a\n+            // cycle. This suppresses caching for those nodes. See\n+            // `in_cycle` field for more details.\n+            for item in stack.iter().take(rec_index + 1) {\n+                debug!(\"evaluate_stack: marking {:?} as cycle participant\", item.fresh_trait_ref);\n+                item.in_cycle.set(true);\n+            }\n+\n             // Subtle: when checking for a coinductive cycle, we do\n             // not compare using the \"freshened trait refs\" (which\n             // have erased regions) but rather the fully explicit\n@@ -3690,6 +3740,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         TraitObligationStack {\n             obligation,\n             fresh_trait_ref,\n+            in_cycle: Cell::new(false),\n             previous: previous_stack,\n         }\n     }"}, {"sha": "fdd1a821e31b56964bae3db7af15581bc05fd1a7", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -298,7 +298,7 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(\n     // negated `CrateNum` (so remote definitions are visited first) and then\n     // by a flattened version of the `DefIndex`.\n     trait_impls.sort_unstable_by_key(|def_id| {\n-        (-(def_id.krate.as_u32() as i64), def_id.index.as_array_index())\n+        (-(def_id.krate.as_u32() as i64), def_id.index.index())\n     });\n \n     for impl_def_id in trait_impls {\n@@ -319,29 +319,34 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(\n                         String::new(), |ty| {\n                             format!(\" for type `{}`\", ty)\n                         }),\n-                    if used_to_be_allowed.is_some() { \" (E0119)\" } else { \"\" }\n+                    match used_to_be_allowed {\n+                        Some(FutureCompatOverlapErrorKind::Issue33140) => \" (E0119)\",\n+                        _ => \"\",\n+                    }\n                 );\n                 let impl_span = tcx.sess.source_map().def_span(\n                     tcx.span_of_impl(impl_def_id).unwrap()\n                 );\n-                let mut err = if let Some(kind) = used_to_be_allowed {\n-                    let lint = match kind {\n-                        FutureCompatOverlapErrorKind::Issue43355 =>\n-                            lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n-                        FutureCompatOverlapErrorKind::Issue33140 =>\n-                            lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS,\n-                    };\n-                    tcx.struct_span_lint_hir(\n-                        lint,\n-                        tcx.hir().as_local_hir_id(impl_def_id).unwrap(),\n-                        impl_span,\n-                        &msg)\n-                } else {\n-                    struct_span_err!(tcx.sess,\n-                                     impl_span,\n-                                     E0119,\n-                                     \"{}\",\n-                                     msg)\n+                let mut err = match used_to_be_allowed {\n+                    Some(FutureCompatOverlapErrorKind::Issue43355) | None =>\n+                        struct_span_err!(tcx.sess,\n+                                         impl_span,\n+                                         E0119,\n+                                         \"{}\",\n+                                         msg),\n+                    Some(kind) => {\n+                        let lint = match kind {\n+                            FutureCompatOverlapErrorKind::Issue43355 =>\n+                                unreachable!(\"converted to hard error above\"),\n+                            FutureCompatOverlapErrorKind::Issue33140 =>\n+                                lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS,\n+                        };\n+                        tcx.struct_span_lint_hir(\n+                            lint,\n+                            tcx.hir().as_local_hir_id(impl_def_id).unwrap(),\n+                            impl_span,\n+                            &msg)\n+                    }\n                 };\n \n                 match tcx.span_of_impl(overlap.with_impl) {"}, {"sha": "404fadbc78afce2119335eff2afcfde7e9876c04", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -312,17 +312,15 @@ impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n     }\n \n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-        use syntax::symbol::Symbol;\n-\n         match t.sty {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n                 self.types.insert(\n                     bound_ty.var.as_u32(),\n                     match bound_ty.kind {\n                         ty::BoundTyKind::Param(name) => name,\n-                        ty::BoundTyKind::Anon => Symbol::intern(\n-                            &format!(\"^{}\", bound_ty.var.as_u32())\n-                        ).as_interned_str(),\n+                        ty::BoundTyKind::Anon =>\n+                            InternedString::intern(&format!(\"^{}\", bound_ty.var.as_u32()),\n+                        ),\n                     }\n                 );\n             }\n@@ -334,8 +332,6 @@ impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n     }\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        use syntax::symbol::Symbol;\n-\n         match r {\n             ty::ReLateBound(index, br) if *index == self.binder_index => {\n                 match br {\n@@ -344,9 +340,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n                     }\n \n                     ty::BoundRegion::BrAnon(var) => {\n-                        self.regions.insert(Symbol::intern(\n-                            &format!(\"'^{}\", var)\n-                        ).as_interned_str());\n+                        self.regions.insert(InternedString::intern(&format!(\"'^{}\", var)));\n                     }\n \n                     _ => (),"}, {"sha": "c9fee02f66bbdf19970bd270fddf25bbfda9bda0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -74,7 +74,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map::MultiSpan;\n use syntax::feature_gate;\n-use syntax::symbol::{Symbol, keywords, InternedString};\n+use syntax::symbol::{Symbol, keywords, InternedString, sym};\n use syntax_pos::Span;\n \n use crate::hir;\n@@ -1213,7 +1213,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n             span_bug!(attr.span, \"no arguments to `rustc_layout_scalar_valid_range` attribute\");\n         };\n-        (get(\"rustc_layout_scalar_valid_range_start\"), get(\"rustc_layout_scalar_valid_range_end\"))\n+        (get(sym::rustc_layout_scalar_valid_range_start),\n+         get(sym::rustc_layout_scalar_valid_range_end))\n     }\n \n     pub fn lift<T: ?Sized + Lift<'tcx>>(self, value: &T) -> Option<T::Lifted> {\n@@ -3102,10 +3103,10 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n     providers.is_panic_runtime = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir().krate_attrs(), \"panic_runtime\")\n+        attr::contains_name(tcx.hir().krate_attrs(), sym::panic_runtime)\n     };\n     providers.is_compiler_builtins = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir().krate_attrs(), \"compiler_builtins\")\n+        attr::contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins)\n     };\n }"}, {"sha": "be1d973c2cdd58363b7c15e855daffacb60c0c31", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -113,9 +113,14 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         substs: SubstsRef<'tcx>) -> DefIdForest\n     {\n-        DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n-            v.uninhabited_from(tcx, substs, self.adt_kind())\n-        }))\n+        // Non-exhaustive ADTs from other crates are always considered inhabited.\n+        if self.is_variant_list_non_exhaustive() && !self.did.is_local() {\n+            DefIdForest::empty()\n+        } else {\n+            DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n+                v.uninhabited_from(tcx, substs, self.adt_kind())\n+            }))\n+        }\n     }\n }\n \n@@ -134,9 +139,14 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n             AdtKind::Enum => true,\n             AdtKind::Struct => false,\n         };\n-        DefIdForest::union(tcx, self.fields.iter().map(|f| {\n-            f.uninhabited_from(tcx, substs, is_enum)\n-        }))\n+        // Non-exhaustive variants from other crates are always considered inhabited.\n+        if self.is_field_list_non_exhaustive() && !self.def_id.is_local() {\n+            DefIdForest::empty()\n+        } else {\n+            DefIdForest::union(tcx, self.fields.iter().map(|f| {\n+                f.uninhabited_from(tcx, substs, is_enum)\n+            }))\n+        }\n     }\n }\n "}, {"sha": "6d7b0926c7ae26527fbb131fbec4f251104bbc04", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -19,6 +19,12 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n pub use rustc_target::abi::*;\n+use rustc_target::spec::{HasTargetSpec, abi::Abi as SpecAbi};\n+use rustc_target::abi::call::{\n+    ArgAttribute, ArgAttributes, ArgType, Conv, FnType, IgnoreMode, PassMode, Reg, RegKind\n+};\n+\n+\n \n pub trait IntegerExt {\n     fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, signed: bool) -> Ty<'tcx>;\n@@ -2259,3 +2265,380 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for LayoutError<'gcx>\n         }\n     }\n }\n+\n+pub trait FnTypeExt<'tcx, C>\n+where\n+    C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+        + HasDataLayout\n+        + HasTargetSpec\n+        + HasTyCtxt<'tcx>\n+        + HasParamEnv<'tcx>,\n+{\n+    fn of_instance(cx: &C, instance: &ty::Instance<'tcx>) -> Self;\n+    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n+    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n+    fn new_internal(\n+        cx: &C,\n+        sig: ty::FnSig<'tcx>,\n+        extra_args: &[Ty<'tcx>],\n+        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n+    ) -> Self;\n+    fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi);\n+}\n+\n+impl<'tcx, C> FnTypeExt<'tcx, C> for call::FnType<'tcx, Ty<'tcx>>\n+where\n+    C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+        + HasDataLayout\n+        + HasTargetSpec\n+        + HasTyCtxt<'tcx>\n+        + HasParamEnv<'tcx>,\n+{\n+    fn of_instance(cx: &C, instance: &ty::Instance<'tcx>) -> Self {\n+        let sig = instance.fn_sig(cx.tcx());\n+        let sig = cx\n+            .tcx()\n+            .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        call::FnType::new(cx, sig, &[])\n+    }\n+\n+    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n+        call::FnType::new_internal(cx, sig, extra_args, |ty, _| ArgType::new(cx.layout_of(ty)))\n+    }\n+\n+    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n+        FnTypeExt::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n+            let mut layout = cx.layout_of(ty);\n+            // Don't pass the vtable, it's not an argument of the virtual fn.\n+            // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n+            // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n+            if arg_idx == Some(0) {\n+                let fat_pointer_ty = if layout.is_unsized() {\n+                    // unsized `self` is passed as a pointer to `self`\n+                    // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n+                    cx.tcx().mk_mut_ptr(layout.ty)\n+                } else {\n+                    match layout.abi {\n+                        Abi::ScalarPair(..) => (),\n+                        _ => bug!(\"receiver type has unsupported layout: {:?}\", layout),\n+                    }\n+\n+                    // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n+                    // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n+                    // elsewhere in the compiler as a method on a `dyn Trait`.\n+                    // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n+                    // get a built-in pointer type\n+                    let mut fat_pointer_layout = layout;\n+                    'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n+                        && !fat_pointer_layout.ty.is_region_ptr()\n+                    {\n+                        'iter_fields: for i in 0..fat_pointer_layout.fields.count() {\n+                            let field_layout = fat_pointer_layout.field(cx, i);\n+\n+                            if !field_layout.is_zst() {\n+                                fat_pointer_layout = field_layout;\n+                                continue 'descend_newtypes;\n+                            }\n+                        }\n+\n+                        bug!(\n+                            \"receiver has no non-zero-sized fields {:?}\",\n+                            fat_pointer_layout\n+                        );\n+                    }\n+\n+                    fat_pointer_layout.ty\n+                };\n+\n+                // we now have a type like `*mut RcBox<dyn Trait>`\n+                // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n+                // this is understood as a special case elsewhere in the compiler\n+                let unit_pointer_ty = cx.tcx().mk_mut_ptr(cx.tcx().mk_unit());\n+                layout = cx.layout_of(unit_pointer_ty);\n+                layout.ty = fat_pointer_ty;\n+            }\n+            ArgType::new(layout)\n+        })\n+    }\n+\n+    fn new_internal(\n+        cx: &C,\n+        sig: ty::FnSig<'tcx>,\n+        extra_args: &[Ty<'tcx>],\n+        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n+    ) -> Self {\n+        debug!(\"FnType::new_internal({:?}, {:?})\", sig, extra_args);\n+\n+        use rustc_target::spec::abi::Abi::*;\n+        let conv = match cx.tcx().sess.target.target.adjust_abi(sig.abi) {\n+            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::C,\n+\n+            // It's the ABI's job to select this, not ours.\n+            System => bug!(\"system abi should be selected elsewhere\"),\n+\n+            Stdcall => Conv::X86Stdcall,\n+            Fastcall => Conv::X86Fastcall,\n+            Vectorcall => Conv::X86VectorCall,\n+            Thiscall => Conv::X86ThisCall,\n+            C => Conv::C,\n+            Unadjusted => Conv::C,\n+            Win64 => Conv::X86_64Win64,\n+            SysV64 => Conv::X86_64SysV,\n+            Aapcs => Conv::ArmAapcs,\n+            PtxKernel => Conv::PtxKernel,\n+            Msp430Interrupt => Conv::Msp430Intr,\n+            X86Interrupt => Conv::X86Intr,\n+            AmdGpuKernel => Conv::AmdGpuKernel,\n+\n+            // These API constants ought to be more specific...\n+            Cdecl => Conv::C,\n+        };\n+\n+        let mut inputs = sig.inputs();\n+        let extra_args = if sig.abi == RustCall {\n+            assert!(!sig.c_variadic && extra_args.is_empty());\n+\n+            match sig.inputs().last().unwrap().sty {\n+                ty::Tuple(tupled_arguments) => {\n+                    inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n+                    tupled_arguments.iter().map(|k| k.expect_ty()).collect()\n+                }\n+                _ => {\n+                    bug!(\n+                        \"argument to function with \\\"rust-call\\\" ABI \\\n+                         is not a tuple\"\n+                    );\n+                }\n+            }\n+        } else {\n+            assert!(sig.c_variadic || extra_args.is_empty());\n+            extra_args.to_vec()\n+        };\n+\n+        let target = &cx.tcx().sess.target.target;\n+        let win_x64_gnu =\n+            target.target_os == \"windows\" && target.arch == \"x86_64\" && target.target_env == \"gnu\";\n+        let linux_s390x =\n+            target.target_os == \"linux\" && target.arch == \"s390x\" && target.target_env == \"gnu\";\n+        let linux_sparc64 =\n+            target.target_os == \"linux\" && target.arch == \"sparc64\" && target.target_env == \"gnu\";\n+        let rust_abi = match sig.abi {\n+            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => true,\n+            _ => false,\n+        };\n+\n+        // Handle safe Rust thin and fat pointers.\n+        let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n+                                      scalar: &Scalar,\n+                                      layout: TyLayout<'tcx>,\n+                                      offset: Size,\n+                                      is_return: bool| {\n+            // Booleans are always an i1 that needs to be zero-extended.\n+            if scalar.is_bool() {\n+                attrs.set(ArgAttribute::ZExt);\n+                return;\n+            }\n+\n+            // Only pointer types handled below.\n+            if scalar.value != Pointer {\n+                return;\n+            }\n+\n+            if scalar.valid_range.start() < scalar.valid_range.end() {\n+                if *scalar.valid_range.start() > 0 {\n+                    attrs.set(ArgAttribute::NonNull);\n+                }\n+            }\n+\n+            if let Some(pointee) = layout.pointee_info_at(cx, offset) {\n+                if let Some(kind) = pointee.safe {\n+                    attrs.pointee_size = pointee.size;\n+                    attrs.pointee_align = Some(pointee.align);\n+\n+                    // `Box` pointer parameters never alias because ownership is transferred\n+                    // `&mut` pointer parameters never alias other parameters,\n+                    // or mutable global data\n+                    //\n+                    // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n+                    // and can be marked as both `readonly` and `noalias`, as\n+                    // LLVM's definition of `noalias` is based solely on memory\n+                    // dependencies rather than pointer equality\n+                    let no_alias = match kind {\n+                        PointerKind::Shared => false,\n+                        PointerKind::UniqueOwned => true,\n+                        PointerKind::Frozen | PointerKind::UniqueBorrowed => !is_return,\n+                    };\n+                    if no_alias {\n+                        attrs.set(ArgAttribute::NoAlias);\n+                    }\n+\n+                    if kind == PointerKind::Frozen && !is_return {\n+                        attrs.set(ArgAttribute::ReadOnly);\n+                    }\n+                }\n+            }\n+        };\n+\n+        // Store the index of the last argument. This is useful for working with\n+        // C-compatible variadic arguments.\n+        let last_arg_idx = if sig.inputs().is_empty() {\n+            None\n+        } else {\n+            Some(sig.inputs().len() - 1)\n+        };\n+\n+        let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n+            let is_return = arg_idx.is_none();\n+            let mut arg = mk_arg_type(ty, arg_idx);\n+            if arg.layout.is_zst() {\n+                // For some forsaken reason, x86_64-pc-windows-gnu\n+                // doesn't ignore zero-sized struct arguments.\n+                // The same is true for s390x-unknown-linux-gnu\n+                // and sparc64-unknown-linux-gnu.\n+                if is_return || rust_abi || (!win_x64_gnu && !linux_s390x && !linux_sparc64) {\n+                    arg.mode = PassMode::Ignore(IgnoreMode::Zst);\n+                }\n+            }\n+\n+            // If this is a C-variadic function, this is not the return value,\n+            // and there is one or more fixed arguments; ensure that the `VaList`\n+            // is ignored as an argument.\n+            if sig.c_variadic {\n+                match (last_arg_idx, arg_idx) {\n+                    (Some(last_idx), Some(cur_idx)) if last_idx == cur_idx => {\n+                        let va_list_did = match cx.tcx().lang_items().va_list() {\n+                            Some(did) => did,\n+                            None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n+                        };\n+                        match ty.sty {\n+                            ty::Adt(def, _) if def.did == va_list_did => {\n+                                // This is the \"spoofed\" `VaList`. Set the arguments mode\n+                                // so that it will be ignored.\n+                                arg.mode = PassMode::Ignore(IgnoreMode::CVarArgs);\n+                            }\n+                            _ => (),\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            // FIXME(eddyb) other ABIs don't have logic for scalar pairs.\n+            if !is_return && rust_abi {\n+                if let Abi::ScalarPair(ref a, ref b) = arg.layout.abi {\n+                    let mut a_attrs = ArgAttributes::new();\n+                    let mut b_attrs = ArgAttributes::new();\n+                    adjust_for_rust_scalar(&mut a_attrs, a, arg.layout, Size::ZERO, false);\n+                    adjust_for_rust_scalar(\n+                        &mut b_attrs,\n+                        b,\n+                        arg.layout,\n+                        a.value.size(cx).align_to(b.value.align(cx).abi),\n+                        false,\n+                    );\n+                    arg.mode = PassMode::Pair(a_attrs, b_attrs);\n+                    return arg;\n+                }\n+            }\n+\n+            if let Abi::Scalar(ref scalar) = arg.layout.abi {\n+                if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                    adjust_for_rust_scalar(attrs, scalar, arg.layout, Size::ZERO, is_return);\n+                }\n+            }\n+\n+            arg\n+        };\n+\n+        let mut fn_ty = FnType {\n+            ret: arg_of(sig.output(), None),\n+            args: inputs\n+                .iter()\n+                .cloned()\n+                .chain(extra_args)\n+                .enumerate()\n+                .map(|(i, ty)| arg_of(ty, Some(i)))\n+                .collect(),\n+            c_variadic: sig.c_variadic,\n+            conv,\n+        };\n+        fn_ty.adjust_for_abi(cx, sig.abi);\n+        fn_ty\n+    }\n+\n+    fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi) {\n+        if abi == SpecAbi::Unadjusted {\n+            return;\n+        }\n+\n+        if abi == SpecAbi::Rust\n+            || abi == SpecAbi::RustCall\n+            || abi == SpecAbi::RustIntrinsic\n+            || abi == SpecAbi::PlatformIntrinsic\n+        {\n+            let fixup = |arg: &mut ArgType<'tcx, Ty<'tcx>>| {\n+                if arg.is_ignore() {\n+                    return;\n+                }\n+\n+                match arg.layout.abi {\n+                    Abi::Aggregate { .. } => {}\n+\n+                    // This is a fun case! The gist of what this is doing is\n+                    // that we want callers and callees to always agree on the\n+                    // ABI of how they pass SIMD arguments. If we were to *not*\n+                    // make these arguments indirect then they'd be immediates\n+                    // in LLVM, which means that they'd used whatever the\n+                    // appropriate ABI is for the callee and the caller. That\n+                    // means, for example, if the caller doesn't have AVX\n+                    // enabled but the callee does, then passing an AVX argument\n+                    // across this boundary would cause corrupt data to show up.\n+                    //\n+                    // This problem is fixed by unconditionally passing SIMD\n+                    // arguments through memory between callers and callees\n+                    // which should get them all to agree on ABI regardless of\n+                    // target feature sets. Some more information about this\n+                    // issue can be found in #44367.\n+                    //\n+                    // Note that the platform intrinsic ABI is exempt here as\n+                    // that's how we connect up to LLVM and it's unstable\n+                    // anyway, we control all calls to it in libstd.\n+                    Abi::Vector { .. }\n+                        if abi != SpecAbi::PlatformIntrinsic\n+                            && cx.tcx().sess.target.target.options.simd_types_indirect =>\n+                    {\n+                        arg.make_indirect();\n+                        return;\n+                    }\n+\n+                    _ => return,\n+                }\n+\n+                let size = arg.layout.size;\n+                if arg.layout.is_unsized() || size > Pointer.size(cx) {\n+                    arg.make_indirect();\n+                } else {\n+                    // We want to pass small aggregates as immediates, but using\n+                    // a LLVM aggregate type for this leads to bad optimizations,\n+                    // so we pick an appropriately sized integer type instead.\n+                    arg.cast_to(Reg {\n+                        kind: RegKind::Integer,\n+                        size,\n+                    });\n+                }\n+            };\n+            fixup(&mut self.ret);\n+            for arg in &mut self.args {\n+                fixup(arg);\n+            }\n+            if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n+                attrs.set(ArgAttribute::StructRet);\n+            }\n+            return;\n+        }\n+\n+        if let Err(msg) = self.adjust_for_cabi(cx, abi) {\n+            cx.tcx().sess.fatal(&msg);\n+        }\n+    }\n+}"}, {"sha": "91e996178e7d54904cbdde900e8524bf60d1f5da", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -47,7 +47,7 @@ use std::ops::Range;\n use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n use syntax::ext::hygiene::Mark;\n-use syntax::symbol::{keywords, Symbol, LocalInternedString, InternedString};\n+use syntax::symbol::{keywords, sym, Symbol, LocalInternedString, InternedString};\n use syntax_pos::Span;\n \n use smallvec;\n@@ -510,7 +510,7 @@ pub struct TyS<'tcx> {\n \n // `TyS` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(MEM_SIZE_OF_TY_S: ::std::mem::size_of::<TyS<'_>>() == 32);\n+static_assert_size!(TyS<'_>, 32);\n \n impl<'tcx> Ord for TyS<'tcx> {\n     fn cmp(&self, other: &TyS<'tcx>) -> Ordering {\n@@ -1875,11 +1875,11 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n         );\n \n         let mut flags = VariantFlags::NO_VARIANT_FLAGS;\n-        if adt_kind == AdtKind::Struct && tcx.has_attr(parent_did, \"non_exhaustive\") {\n+        if adt_kind == AdtKind::Struct && tcx.has_attr(parent_did, sym::non_exhaustive) {\n             debug!(\"found non-exhaustive field list for {:?}\", parent_did);\n             flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n         } else if let Some(variant_did) = variant_did {\n-            if tcx.has_attr(variant_did, \"non_exhaustive\") {\n+            if tcx.has_attr(variant_did, sym::non_exhaustive) {\n                 debug!(\"found non-exhaustive field list for {:?}\", variant_did);\n                 flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n             }\n@@ -2156,7 +2156,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n \n-        if kind == AdtKind::Enum && tcx.has_attr(did, \"non_exhaustive\") {\n+        if kind == AdtKind::Enum && tcx.has_attr(did, sym::non_exhaustive) {\n             debug!(\"found non-exhaustive variant list for {:?}\", did);\n             flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n         }\n@@ -2172,7 +2172,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n \n         let attrs = tcx.get_attrs(did);\n-        if attr::contains_name(&attrs, \"fundamental\") {\n+        if attr::contains_name(&attrs, sym::fundamental) {\n             flags |= AdtFlags::IS_FUNDAMENTAL;\n         }\n         if Some(did) == tcx.lang_items().phantom_data() {\n@@ -3030,7 +3030,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Determines whether an item is annotated with an attribute.\n-    pub fn has_attr(self, did: DefId, attr: &str) -> bool {\n+    pub fn has_attr(self, did: DefId, attr: Symbol) -> bool {\n         attr::contains_name(&self.get_attrs(did), attr)\n     }\n \n@@ -3405,7 +3405,7 @@ impl_stable_hash_for!(struct self::SymbolName {\n impl SymbolName {\n     pub fn new(name: &str) -> SymbolName {\n         SymbolName {\n-            name: Symbol::intern(name).as_interned_str()\n+            name: InternedString::intern(name)\n         }\n     }\n "}, {"sha": "91b708d7dbe10339d00813f79f85cfd108a4f57b", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -7,10 +7,8 @@ use crate::middle::region;\n use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n use crate::ty::subst::{Kind, Subst, UnpackedKind};\n use crate::mir::interpret::ConstValue;\n-use syntax::symbol::{keywords, Symbol};\n-\n use rustc_target::spec::abi::Abi;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::{keywords, InternedString};\n \n use std::cell::Cell;\n use std::fmt::{self, Write as _};\n@@ -1285,10 +1283,10 @@ impl<F: fmt::Write> FmtPrinter<'_, 'gcx, 'tcx, F> {\n     {\n         fn name_by_region_index(index: usize) -> InternedString {\n             match index {\n-                0 => Symbol::intern(\"'r\"),\n-                1 => Symbol::intern(\"'s\"),\n-                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n-            }.as_interned_str()\n+                0 => InternedString::intern(\"'r\"),\n+                1 => InternedString::intern(\"'s\"),\n+                i => InternedString::intern(&format!(\"'t{}\", i-2)),\n+            }\n         }\n \n         // Replace any anonymous late-bound regions with named"}, {"sha": "2fb318a47befd80f6919cd0b22c9eb56bbe3f8f4", "filename": "src/librustc/ty/query/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,7 +1,7 @@\n use crate::ty::{self, Ty, TyCtxt, AdtSizedConstraint};\n use crate::ty::util::NeedsDrop;\n \n-use syntax::symbol::Symbol;\n+use syntax::symbol::InternedString;\n \n pub(super) trait Value<'tcx>: Sized {\n     fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n@@ -28,7 +28,7 @@ impl<'tcx> Value<'tcx> for Ty<'tcx> {\n \n impl<'tcx> Value<'tcx> for ty::SymbolName {\n     fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        ty::SymbolName { name: Symbol::intern(\"<error>\").as_interned_str() }\n+        ty::SymbolName { name: InternedString::intern(\"<error>\") }\n     }\n }\n "}, {"sha": "e8f3bad4d3ee32832666fd66f72f4cc502707da8", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -211,7 +211,7 @@ pub enum TyKind<'tcx> {\n \n // `TyKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(MEM_SIZE_OF_TY_KIND: ::std::mem::size_of::<TyKind<'_>>() == 24);\n+static_assert_size!(TyKind<'_>, 24);\n \n /// A closure can be modeled as a struct that looks like:\n ///\n@@ -1136,7 +1136,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n         // FIXME(#50125): Ignoring `Self` with `index != 0` might lead to weird behavior elsewhere,\n         // but this should only be possible when using `-Z continue-parse-after-error` like\n         // `compile-fail/issue-36638.rs`.\n-        self.name == keywords::SelfUpper.name().as_str() && self.index == 0\n+        self.name.as_symbol() == keywords::SelfUpper.name() && self.index == 0\n     }\n }\n \n@@ -2207,7 +2207,7 @@ pub struct Const<'tcx> {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(CONST_SIZE: ::std::mem::size_of::<Const<'static>>() == 48);\n+static_assert_size!(Const<'_>, 48);\n \n impl<'tcx> Const<'tcx> {\n     #[inline]"}, {"sha": "926c0f8b949193cc9376b75259d7bf936df00bca", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -22,6 +22,7 @@ use rustc_macros::HashStable;\n use std::{cmp, fmt};\n use syntax::ast;\n use syntax::attr::{self, SignedInt, UnsignedInt};\n+use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Copy, Clone, Debug)]\n@@ -447,7 +448,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Such access can be in plain sight (e.g., dereferencing\n         // `*foo.0` of `Foo<'a>(&'a u32)`) or indirectly hidden\n         // (e.g., calling `foo.0.clone()` of `Foo<T:Clone>`).\n-        if self.has_attr(dtor, \"unsafe_destructor_blind_to_params\") {\n+        if self.has_attr(dtor, sym::unsafe_destructor_blind_to_params) {\n             debug!(\"destructor_constraint({:?}) - blind\", def.did);\n             return vec![];\n         }"}, {"sha": "67eaa19c080b5ec80d7976f2ca1ee2a2194f1081", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -11,14 +11,15 @@ use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n use syntax_pos::{SpanData};\n+use syntax::symbol::{Symbol, sym};\n use rustc_macros::HashStable;\n use crate::ty::TyCtxt;\n use crate::dep_graph::{DepNode};\n use lazy_static;\n use crate::session::Session;\n \n // The name of the associated type for `Fn` return types\n-pub const FN_OUTPUT_NAME: &str = \"Output\";\n+pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n \n // Useful type to use with `Result<>` indicate that an error has already\n // been reported to the user, so no need to continue checking."}, {"sha": "6931b3542f7614c25a7314e7dbbd107da9f27697", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -19,7 +19,7 @@ use syntax::{\n     mut_visit::{self, MutVisitor},\n     parse::ParseSess,\n     ptr::P,\n-    symbol::Symbol\n+    symbol::{keywords, Symbol, sym}\n };\n use syntax_pos::Span;\n \n@@ -58,7 +58,7 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n     fn flat_map_item(&mut self, item: P<Item>) -> SmallVec<[P<Item>; 1]> {\n         debug!(\"in submodule {}\", self.in_submod);\n \n-        let name = if attr::contains_name(&item.attrs, \"global_allocator\") {\n+        let name = if attr::contains_name(&item.attrs, sym::global_allocator) {\n             \"global_allocator\"\n         } else {\n             return mut_visit::noop_flat_map_item(item, self);\n@@ -110,13 +110,14 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n             span,\n             kind: AllocatorKind::Global,\n             global: item.ident,\n-            core: Ident::from_str(\"core\"),\n+            core: Ident::with_empty_ctxt(sym::core),\n             cx: ExtCtxt::new(self.sess, ecfg, self.resolver),\n         };\n \n         // We will generate a new submodule. To `use` the static from that module, we need to get\n         // the `super::...` path.\n-        let super_path = f.cx.path(f.span, vec![Ident::from_str(\"super\"), f.global]);\n+        let super_path =\n+            f.cx.path(f.span, vec![Ident::with_empty_ctxt(keywords::Super.name()), f.global]);\n \n         // Generate the items in the submodule\n         let mut items = vec![\n@@ -139,7 +140,7 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n \n         // Generate the submodule itself\n         let name = f.kind.fn_name(\"allocator_abi\");\n-        let allocator_abi = Ident::with_empty_ctxt(Symbol::gensym(&name));\n+        let allocator_abi = Ident::from_str(&name).gensym();\n         let module = f.cx.item_mod(span, span, allocator_abi, Vec::new(), items);\n         let module = f.cx.monotonic_expander().flat_map_item(module).pop().unwrap();\n \n@@ -236,7 +237,7 @@ impl AllocFnFactory<'_> {\n     ) -> P<Expr> {\n         match *ty {\n             AllocatorTy::Layout => {\n-                let usize = self.cx.path_ident(self.span, Ident::from_str(\"usize\"));\n+                let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n                 let ty_usize = self.cx.ty_path(usize);\n                 let size = ident();\n                 let align = ident();\n@@ -298,12 +299,12 @@ impl AllocFnFactory<'_> {\n     }\n \n     fn usize(&self) -> P<Ty> {\n-        let usize = self.cx.path_ident(self.span, Ident::from_str(\"usize\"));\n+        let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n         self.cx.ty_path(usize)\n     }\n \n     fn ptr_u8(&self) -> P<Ty> {\n-        let u8 = self.cx.path_ident(self.span, Ident::from_str(\"u8\"));\n+        let u8 = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::u8));\n         let ty_u8 = self.cx.ty_path(u8);\n         self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n     }"}, {"sha": "38d4b7e3f9d85504db9548447f19f8e294fec49f", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 5, "deletions": 386, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -11,9 +11,9 @@ use rustc_target::abi::call::ArgType;\n \n use rustc_codegen_ssa::traits::*;\n \n-use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n-use rustc::ty::{self, Ty, Instance};\n-use rustc::ty::layout::{self, PointerKind};\n+use rustc_target::abi::{HasDataLayout, LayoutOf};\n+use rustc::ty::{Ty};\n+use rustc::ty::layout::{self};\n \n use libc::c_uint;\n \n@@ -294,380 +294,15 @@ impl ArgTypeMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-pub trait FnTypeExt<'tcx> {\n-    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self;\n-    fn new(cx: &CodegenCx<'ll, 'tcx>,\n-           sig: ty::FnSig<'tcx>,\n-           extra_args: &[Ty<'tcx>]) -> Self;\n-    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n-                  sig: ty::FnSig<'tcx>,\n-                  extra_args: &[Ty<'tcx>]) -> Self;\n-    fn new_internal(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        sig: ty::FnSig<'tcx>,\n-        extra_args: &[Ty<'tcx>],\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n-    ) -> Self;\n-    fn adjust_for_abi(&mut self,\n-                      cx: &CodegenCx<'ll, 'tcx>,\n-                      abi: Abi);\n+pub trait FnTypeLlvmExt<'tcx> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn ptr_to_llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn llvm_cconv(&self) -> llvm::CallConv;\n     fn apply_attrs_llfn(&self, llfn: &'ll Value);\n     fn apply_attrs_callsite(&self, bx: &mut Builder<'a, 'll, 'tcx>, callsite: &'ll Value);\n }\n \n-impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n-    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self {\n-        let sig = instance.fn_sig(cx.tcx);\n-        let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        FnType::new(cx, sig, &[])\n-    }\n-\n-    fn new(cx: &CodegenCx<'ll, 'tcx>,\n-           sig: ty::FnSig<'tcx>,\n-           extra_args: &[Ty<'tcx>]) -> Self {\n-        FnType::new_internal(cx, sig, extra_args, |ty, _| {\n-            ArgType::new(cx.layout_of(ty))\n-        })\n-    }\n-\n-    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n-                  sig: ty::FnSig<'tcx>,\n-                  extra_args: &[Ty<'tcx>]) -> Self {\n-        FnType::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n-            let mut layout = cx.layout_of(ty);\n-            // Don't pass the vtable, it's not an argument of the virtual fn.\n-            // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n-            // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n-            if arg_idx == Some(0) {\n-                let fat_pointer_ty = if layout.is_unsized() {\n-                    // unsized `self` is passed as a pointer to `self`\n-                    // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n-                    cx.tcx.mk_mut_ptr(layout.ty)\n-                } else {\n-                    match layout.abi {\n-                        LayoutAbi::ScalarPair(..) => (),\n-                        _ => bug!(\"receiver type has unsupported layout: {:?}\", layout)\n-                    }\n-\n-                    // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n-                    // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n-                    // elsewhere in the compiler as a method on a `dyn Trait`.\n-                    // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n-                    // get a built-in pointer type\n-                    let mut fat_pointer_layout = layout;\n-                    'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n-                        && !fat_pointer_layout.ty.is_region_ptr()\n-                    {\n-                        'iter_fields: for i in 0..fat_pointer_layout.fields.count() {\n-                            let field_layout = fat_pointer_layout.field(cx, i);\n-\n-                            if !field_layout.is_zst() {\n-                                fat_pointer_layout = field_layout;\n-                                continue 'descend_newtypes\n-                            }\n-                        }\n-\n-                        bug!(\"receiver has no non-zero-sized fields {:?}\", fat_pointer_layout);\n-                    }\n-\n-                    fat_pointer_layout.ty\n-                };\n-\n-                // we now have a type like `*mut RcBox<dyn Trait>`\n-                // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n-                // this is understood as a special case elsewhere in the compiler\n-                let unit_pointer_ty = cx.tcx.mk_mut_ptr(cx.tcx.mk_unit());\n-                layout = cx.layout_of(unit_pointer_ty);\n-                layout.ty = fat_pointer_ty;\n-            }\n-            ArgType::new(layout)\n-        })\n-    }\n-\n-    fn new_internal(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        sig: ty::FnSig<'tcx>,\n-        extra_args: &[Ty<'tcx>],\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n-    ) -> Self {\n-        debug!(\"FnType::new_internal({:?}, {:?})\", sig, extra_args);\n-\n-        use self::Abi::*;\n-        let conv = match cx.sess().target.target.adjust_abi(sig.abi) {\n-            RustIntrinsic | PlatformIntrinsic |\n-            Rust | RustCall => Conv::C,\n-\n-            // It's the ABI's job to select this, not ours.\n-            System => bug!(\"system abi should be selected elsewhere\"),\n-\n-            Stdcall => Conv::X86Stdcall,\n-            Fastcall => Conv::X86Fastcall,\n-            Vectorcall => Conv::X86VectorCall,\n-            Thiscall => Conv::X86ThisCall,\n-            C => Conv::C,\n-            Unadjusted => Conv::C,\n-            Win64 => Conv::X86_64Win64,\n-            SysV64 => Conv::X86_64SysV,\n-            Aapcs => Conv::ArmAapcs,\n-            PtxKernel => Conv::PtxKernel,\n-            Msp430Interrupt => Conv::Msp430Intr,\n-            X86Interrupt => Conv::X86Intr,\n-            AmdGpuKernel => Conv::AmdGpuKernel,\n-\n-            // These API constants ought to be more specific...\n-            Cdecl => Conv::C,\n-        };\n-\n-        let mut inputs = sig.inputs();\n-        let extra_args = if sig.abi == RustCall {\n-            assert!(!sig.c_variadic && extra_args.is_empty());\n-\n-            match sig.inputs().last().unwrap().sty {\n-                ty::Tuple(tupled_arguments) => {\n-                    inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n-                    tupled_arguments.iter().map(|k| k.expect_ty()).collect()\n-                }\n-                _ => {\n-                    bug!(\"argument to function with \\\"rust-call\\\" ABI \\\n-                          is not a tuple\");\n-                }\n-            }\n-        } else {\n-            assert!(sig.c_variadic || extra_args.is_empty());\n-            extra_args.to_vec()\n-        };\n-\n-        let target = &cx.sess().target.target;\n-        let win_x64_gnu = target.target_os == \"windows\"\n-                       && target.arch == \"x86_64\"\n-                       && target.target_env == \"gnu\";\n-        let linux_s390x = target.target_os == \"linux\"\n-                       && target.arch == \"s390x\"\n-                       && target.target_env == \"gnu\";\n-        let linux_sparc64 = target.target_os == \"linux\"\n-                       && target.arch == \"sparc64\"\n-                       && target.target_env == \"gnu\";\n-        let rust_abi = match sig.abi {\n-            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => true,\n-            _ => false\n-        };\n-\n-        // Handle safe Rust thin and fat pointers.\n-        let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n-                                      scalar: &layout::Scalar,\n-                                      layout: TyLayout<'tcx, Ty<'tcx>>,\n-                                      offset: Size,\n-                                      is_return: bool| {\n-            // Booleans are always an i1 that needs to be zero-extended.\n-            if scalar.is_bool() {\n-                attrs.set(ArgAttribute::ZExt);\n-                return;\n-            }\n-\n-            // Only pointer types handled below.\n-            if scalar.value != layout::Pointer {\n-                return;\n-            }\n-\n-            if scalar.valid_range.start() < scalar.valid_range.end() {\n-                if *scalar.valid_range.start() > 0 {\n-                    attrs.set(ArgAttribute::NonNull);\n-                }\n-            }\n-\n-            if let Some(pointee) = layout.pointee_info_at(cx, offset) {\n-                if let Some(kind) = pointee.safe {\n-                    attrs.pointee_size = pointee.size;\n-                    attrs.pointee_align = Some(pointee.align);\n-\n-                    // `Box` pointer parameters never alias because ownership is transferred\n-                    // `&mut` pointer parameters never alias other parameters,\n-                    // or mutable global data\n-                    //\n-                    // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n-                    // and can be marked as both `readonly` and `noalias`, as\n-                    // LLVM's definition of `noalias` is based solely on memory\n-                    // dependencies rather than pointer equality\n-                    let no_alias = match kind {\n-                        PointerKind::Shared => false,\n-                        PointerKind::UniqueOwned => true,\n-                        PointerKind::Frozen |\n-                        PointerKind::UniqueBorrowed => !is_return\n-                    };\n-                    if no_alias {\n-                        attrs.set(ArgAttribute::NoAlias);\n-                    }\n-\n-                    if kind == PointerKind::Frozen && !is_return {\n-                        attrs.set(ArgAttribute::ReadOnly);\n-                    }\n-                }\n-            }\n-        };\n-\n-        // Store the index of the last argument. This is useful for working with\n-        // C-compatible variadic arguments.\n-        let last_arg_idx = if sig.inputs().is_empty() {\n-            None\n-        } else {\n-            Some(sig.inputs().len() - 1)\n-        };\n-\n-        let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n-            let is_return = arg_idx.is_none();\n-            let mut arg = mk_arg_type(ty, arg_idx);\n-            if arg.layout.is_zst() {\n-                // For some forsaken reason, x86_64-pc-windows-gnu\n-                // doesn't ignore zero-sized struct arguments.\n-                // The same is true for s390x-unknown-linux-gnu\n-                // and sparc64-unknown-linux-gnu.\n-                if is_return || rust_abi || (!win_x64_gnu && !linux_s390x && !linux_sparc64) {\n-                    arg.mode = PassMode::Ignore(IgnoreMode::Zst);\n-                }\n-            }\n-\n-            // If this is a C-variadic function, this is not the return value,\n-            // and there is one or more fixed arguments; ensure that the `VaList`\n-            // is ignored as an argument.\n-            if sig.c_variadic {\n-                match (last_arg_idx, arg_idx) {\n-                    (Some(last_idx), Some(cur_idx)) if last_idx == cur_idx => {\n-                        let va_list_did = match cx.tcx.lang_items().va_list() {\n-                            Some(did) => did,\n-                            None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n-                        };\n-                        match ty.sty {\n-                            ty::Adt(def, _) if def.did == va_list_did => {\n-                                // This is the \"spoofed\" `VaList`. Set the arguments mode\n-                                // so that it will be ignored.\n-                                arg.mode = PassMode::Ignore(IgnoreMode::CVarArgs);\n-                            },\n-                            _ => (),\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            // FIXME(eddyb) other ABIs don't have logic for scalar pairs.\n-            if !is_return && rust_abi {\n-                if let layout::Abi::ScalarPair(ref a, ref b) = arg.layout.abi {\n-                    let mut a_attrs = ArgAttributes::new();\n-                    let mut b_attrs = ArgAttributes::new();\n-                    adjust_for_rust_scalar(&mut a_attrs,\n-                                           a,\n-                                           arg.layout,\n-                                           Size::ZERO,\n-                                           false);\n-                    adjust_for_rust_scalar(&mut b_attrs,\n-                                           b,\n-                                           arg.layout,\n-                                           a.value.size(cx).align_to(b.value.align(cx).abi),\n-                                           false);\n-                    arg.mode = PassMode::Pair(a_attrs, b_attrs);\n-                    return arg;\n-                }\n-            }\n-\n-            if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n-                if let PassMode::Direct(ref mut attrs) = arg.mode {\n-                    adjust_for_rust_scalar(attrs,\n-                                           scalar,\n-                                           arg.layout,\n-                                           Size::ZERO,\n-                                           is_return);\n-                }\n-            }\n-\n-            arg\n-        };\n-\n-        let mut fn_ty = FnType {\n-            ret: arg_of(sig.output(), None),\n-            args: inputs.iter().cloned().chain(extra_args).enumerate().map(|(i, ty)| {\n-                arg_of(ty, Some(i))\n-            }).collect(),\n-            c_variadic: sig.c_variadic,\n-            conv,\n-        };\n-        fn_ty.adjust_for_abi(cx, sig.abi);\n-        fn_ty\n-    }\n-\n-    fn adjust_for_abi(&mut self,\n-                      cx: &CodegenCx<'ll, 'tcx>,\n-                      abi: Abi) {\n-        if abi == Abi::Unadjusted { return }\n-\n-        if abi == Abi::Rust || abi == Abi::RustCall ||\n-           abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-            let fixup = |arg: &mut ArgType<'tcx, Ty<'tcx>>| {\n-                if arg.is_ignore() { return; }\n-\n-                match arg.layout.abi {\n-                    layout::Abi::Aggregate { .. } => {}\n-\n-                    // This is a fun case! The gist of what this is doing is\n-                    // that we want callers and callees to always agree on the\n-                    // ABI of how they pass SIMD arguments. If we were to *not*\n-                    // make these arguments indirect then they'd be immediates\n-                    // in LLVM, which means that they'd used whatever the\n-                    // appropriate ABI is for the callee and the caller. That\n-                    // means, for example, if the caller doesn't have AVX\n-                    // enabled but the callee does, then passing an AVX argument\n-                    // across this boundary would cause corrupt data to show up.\n-                    //\n-                    // This problem is fixed by unconditionally passing SIMD\n-                    // arguments through memory between callers and callees\n-                    // which should get them all to agree on ABI regardless of\n-                    // target feature sets. Some more information about this\n-                    // issue can be found in #44367.\n-                    //\n-                    // Note that the platform intrinsic ABI is exempt here as\n-                    // that's how we connect up to LLVM and it's unstable\n-                    // anyway, we control all calls to it in libstd.\n-                    layout::Abi::Vector { .. }\n-                        if abi != Abi::PlatformIntrinsic &&\n-                            cx.sess().target.target.options.simd_types_indirect =>\n-                    {\n-                        arg.make_indirect();\n-                        return\n-                    }\n-\n-                    _ => return\n-                }\n-\n-                let size = arg.layout.size;\n-                if arg.layout.is_unsized() || size > layout::Pointer.size(cx) {\n-                    arg.make_indirect();\n-                } else {\n-                    // We want to pass small aggregates as immediates, but using\n-                    // a LLVM aggregate type for this leads to bad optimizations,\n-                    // so we pick an appropriately sized integer type instead.\n-                    arg.cast_to(Reg {\n-                        kind: RegKind::Integer,\n-                        size\n-                    });\n-                }\n-            };\n-            fixup(&mut self.ret);\n-            for arg in &mut self.args {\n-                fixup(arg);\n-            }\n-            if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n-                attrs.set(ArgAttribute::StructRet);\n-            }\n-            return;\n-        }\n-\n-        if let Err(msg) = self.adjust_for_cabi(cx, abi) {\n-            cx.sess().fatal(&msg);\n-        }\n-    }\n-\n+impl<'tcx> FnTypeLlvmExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         let args_capacity: usize = self.args.iter().map(|arg|\n             if arg.pad.is_some() { 1 } else { 0 } +\n@@ -836,22 +471,6 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n     }\n }\n \n-impl AbiMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn new_fn_type(&self, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> FnType<'tcx, Ty<'tcx>> {\n-        FnType::new(&self, sig, extra_args)\n-    }\n-    fn new_vtable(\n-        &self,\n-        sig: ty::FnSig<'tcx>,\n-        extra_args: &[Ty<'tcx>]\n-    ) -> FnType<'tcx, Ty<'tcx>> {\n-        FnType::new_vtable(&self, sig, extra_args)\n-    }\n-    fn fn_type_of_instance(&self, instance: &Instance<'tcx>) -> FnType<'tcx, Ty<'tcx>> {\n-        FnType::of_instance(&self, instance)\n-    }\n-}\n-\n impl AbiBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn apply_attrs_callsite(\n         &mut self,"}, {"sha": "f26684d9ef04ae4a46c4ee87f1884a1f33af350b", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -321,12 +321,12 @@ pub fn provide(providers: &mut Providers<'_>) {\n             // rustdoc needs to be able to document functions that use all the features, so\n             // whitelist them all\n             Lrc::new(llvm_util::all_known_features()\n-                .map(|(a, b)| (a.to_string(), b.map(|s| s.to_string())))\n+                .map(|(a, b)| (a.to_string(), b))\n                 .collect())\n         } else {\n             Lrc::new(llvm_util::target_feature_whitelist(tcx.sess)\n                 .iter()\n-                .map(|&(a, b)| (a.to_string(), b.map(|s| s.to_string())))\n+                .map(|&(a, b)| (a.to_string(), b))\n                 .collect())\n         }\n     };"}, {"sha": "66ba95810a62516a109462f740955fed5c54afb8", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -795,10 +795,10 @@ fn create_msvc_imps(\n         return\n     }\n     // The x86 ABI seems to require that leading underscores are added to symbol\n-    // names, so we need an extra underscore on 32-bit. There's also a leading\n+    // names, so we need an extra underscore on x86. There's also a leading\n     // '\\x01' here which disables LLVM's symbol mangling (e.g., no extra\n     // underscores added in front).\n-    let prefix = if cgcx.target_pointer_width == \"32\" {\n+    let prefix = if cgcx.target_arch == \"x86\" {\n         \"\\x01__imp__\"\n     } else {\n         \"\\x01__imp_\""}, {"sha": "48808eea3045ea892382cf08046db9297eb4c466", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -18,6 +18,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::base::to_immediate;\n use rustc_codegen_ssa::mir::operand::{OperandValue, OperandRef};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n use std::ops::{Deref, Range};\n use std::ptr;\n@@ -72,6 +73,12 @@ impl ty::layout::HasParamEnv<'tcx> for Builder<'_, '_, 'tcx> {\n     }\n }\n \n+impl HasTargetSpec for Builder<'_, '_, 'tcx> {\n+    fn target_spec(&self) -> &Target {\n+        &self.cx.target_spec()\n+    }\n+}\n+\n impl ty::layout::LayoutOf for Builder<'_, '_, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = TyLayout<'tcx>;"}, {"sha": "5f47108309fbfdac3749da165bba96e0682c90c5", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -14,6 +14,7 @@ use rustc::mir::interpret::{ConstValue, Allocation, read_target_uint,\n use rustc::hir::Node;\n use syntax_pos::Span;\n use rustc_target::abi::HasDataLayout;\n+use syntax::symbol::sym;\n use syntax_pos::symbol::LocalInternedString;\n use rustc::ty::{self, Ty};\n use rustc_codegen_ssa::traits::*;\n@@ -248,7 +249,7 @@ impl CodegenCx<'ll, 'tcx> {\n             debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n \n             for attr in attrs {\n-                if attr.check_name(\"thread_local\") {\n+                if attr.check_name(sym::thread_local) {\n                     llvm::set_thread_local_mode(g, self.tls_model);\n                 }\n             }"}, {"sha": "04c9e93c7a527cf79c41c18d035706cc740ca987", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -9,6 +9,7 @@ use rustc::session::config::DebugInfo;\n use rustc_codegen_ssa::traits::*;\n \n use syntax::attr;\n+use syntax::symbol::sym;\n \n \n /// Inserts a side-effect free instruction sequence that makes sure that the\n@@ -66,8 +67,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx<'_, '_>) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        attr::contains_name(&cx.tcx.hir().krate_attrs(),\n-                            \"omit_gdb_pretty_printer_section\");\n+        attr::contains_name(&cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n \n     !omit_gdb_pretty_printer_section &&\n     cx.sess().opts.debuginfo != DebugInfo::None &&"}, {"sha": "bcb14b8899ec245bb728af3535bc91e0557bf1f8", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -13,13 +13,13 @@\n \n use crate::llvm;\n use crate::llvm::AttributePlace::Function;\n-use crate::abi::{FnType, FnTypeExt};\n+use crate::abi::{FnType, FnTypeLlvmExt};\n use crate::attributes;\n use crate::context::CodegenCx;\n use crate::type_::Type;\n use crate::value::Value;\n use rustc::ty::{self, PolyFnSig};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::{FnTypeExt, LayoutOf};\n use rustc::session::config::Sanitizer;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_codegen_ssa::traits::*;"}, {"sha": "9ae0e26196d94fb142ef516b6a2942fca28c5cb9", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, Primitive};\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc::hir;\n use syntax::ast::{self, FloatTy};\n-use syntax::symbol::Symbol;\n+use syntax::symbol::LocalInternedString;\n \n use rustc_codegen_ssa::traits::*;\n \n@@ -213,7 +213,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n             \"type_name\" => {\n                 let tp_ty = substs.type_at(0);\n-                let ty_name = Symbol::intern(&tp_ty.to_string()).as_str();\n+                let ty_name = LocalInternedString::intern(&tp_ty.to_string());\n                 self.const_str_slice(ty_name)\n             }\n             \"type_id\" => {"}, {"sha": "274c89659628d207125710f69cc65b72af37eb0a", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 68, "deletions": 67, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -7,6 +7,7 @@ use rustc_target::spec::MergeFunctions;\n use libc::c_int;\n use std::ffi::CString;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::symbol::sym;\n \n use std::str;\n use std::slice;\n@@ -93,114 +94,114 @@ unsafe fn configure_llvm(sess: &Session) {\n // to LLVM or the feature detection code will walk past the end of the feature\n // array, leading to crashes.\n \n-const ARM_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"aclass\", Some(\"arm_target_feature\")),\n-    (\"mclass\", Some(\"arm_target_feature\")),\n-    (\"rclass\", Some(\"arm_target_feature\")),\n-    (\"dsp\", Some(\"arm_target_feature\")),\n-    (\"neon\", Some(\"arm_target_feature\")),\n-    (\"v5te\", Some(\"arm_target_feature\")),\n-    (\"v6\", Some(\"arm_target_feature\")),\n-    (\"v6k\", Some(\"arm_target_feature\")),\n-    (\"v6t2\", Some(\"arm_target_feature\")),\n-    (\"v7\", Some(\"arm_target_feature\")),\n-    (\"v8\", Some(\"arm_target_feature\")),\n-    (\"vfp2\", Some(\"arm_target_feature\")),\n-    (\"vfp3\", Some(\"arm_target_feature\")),\n-    (\"vfp4\", Some(\"arm_target_feature\")),\n+const ARM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"aclass\", Some(sym::arm_target_feature)),\n+    (\"mclass\", Some(sym::arm_target_feature)),\n+    (\"rclass\", Some(sym::arm_target_feature)),\n+    (\"dsp\", Some(sym::arm_target_feature)),\n+    (\"neon\", Some(sym::arm_target_feature)),\n+    (\"v5te\", Some(sym::arm_target_feature)),\n+    (\"v6\", Some(sym::arm_target_feature)),\n+    (\"v6k\", Some(sym::arm_target_feature)),\n+    (\"v6t2\", Some(sym::arm_target_feature)),\n+    (\"v7\", Some(sym::arm_target_feature)),\n+    (\"v8\", Some(sym::arm_target_feature)),\n+    (\"vfp2\", Some(sym::arm_target_feature)),\n+    (\"vfp3\", Some(sym::arm_target_feature)),\n+    (\"vfp4\", Some(sym::arm_target_feature)),\n ];\n \n-const AARCH64_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"fp\", Some(\"aarch64_target_feature\")),\n-    (\"neon\", Some(\"aarch64_target_feature\")),\n-    (\"sve\", Some(\"aarch64_target_feature\")),\n-    (\"crc\", Some(\"aarch64_target_feature\")),\n-    (\"crypto\", Some(\"aarch64_target_feature\")),\n-    (\"ras\", Some(\"aarch64_target_feature\")),\n-    (\"lse\", Some(\"aarch64_target_feature\")),\n-    (\"rdm\", Some(\"aarch64_target_feature\")),\n-    (\"fp16\", Some(\"aarch64_target_feature\")),\n-    (\"rcpc\", Some(\"aarch64_target_feature\")),\n-    (\"dotprod\", Some(\"aarch64_target_feature\")),\n-    (\"v8.1a\", Some(\"aarch64_target_feature\")),\n-    (\"v8.2a\", Some(\"aarch64_target_feature\")),\n-    (\"v8.3a\", Some(\"aarch64_target_feature\")),\n+const AARCH64_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"fp\", Some(sym::aarch64_target_feature)),\n+    (\"neon\", Some(sym::aarch64_target_feature)),\n+    (\"sve\", Some(sym::aarch64_target_feature)),\n+    (\"crc\", Some(sym::aarch64_target_feature)),\n+    (\"crypto\", Some(sym::aarch64_target_feature)),\n+    (\"ras\", Some(sym::aarch64_target_feature)),\n+    (\"lse\", Some(sym::aarch64_target_feature)),\n+    (\"rdm\", Some(sym::aarch64_target_feature)),\n+    (\"fp16\", Some(sym::aarch64_target_feature)),\n+    (\"rcpc\", Some(sym::aarch64_target_feature)),\n+    (\"dotprod\", Some(sym::aarch64_target_feature)),\n+    (\"v8.1a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.2a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.3a\", Some(sym::aarch64_target_feature)),\n ];\n \n-const X86_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"adx\", Some(\"adx_target_feature\")),\n+const X86_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"adx\", Some(sym::adx_target_feature)),\n     (\"aes\", None),\n     (\"avx\", None),\n     (\"avx2\", None),\n-    (\"avx512bw\", Some(\"avx512_target_feature\")),\n-    (\"avx512cd\", Some(\"avx512_target_feature\")),\n-    (\"avx512dq\", Some(\"avx512_target_feature\")),\n-    (\"avx512er\", Some(\"avx512_target_feature\")),\n-    (\"avx512f\", Some(\"avx512_target_feature\")),\n-    (\"avx512ifma\", Some(\"avx512_target_feature\")),\n-    (\"avx512pf\", Some(\"avx512_target_feature\")),\n-    (\"avx512vbmi\", Some(\"avx512_target_feature\")),\n-    (\"avx512vl\", Some(\"avx512_target_feature\")),\n-    (\"avx512vpopcntdq\", Some(\"avx512_target_feature\")),\n+    (\"avx512bw\", Some(sym::avx512_target_feature)),\n+    (\"avx512cd\", Some(sym::avx512_target_feature)),\n+    (\"avx512dq\", Some(sym::avx512_target_feature)),\n+    (\"avx512er\", Some(sym::avx512_target_feature)),\n+    (\"avx512f\", Some(sym::avx512_target_feature)),\n+    (\"avx512ifma\", Some(sym::avx512_target_feature)),\n+    (\"avx512pf\", Some(sym::avx512_target_feature)),\n+    (\"avx512vbmi\", Some(sym::avx512_target_feature)),\n+    (\"avx512vl\", Some(sym::avx512_target_feature)),\n+    (\"avx512vpopcntdq\", Some(sym::avx512_target_feature)),\n     (\"bmi1\", None),\n     (\"bmi2\", None),\n-    (\"cmpxchg16b\", Some(\"cmpxchg16b_target_feature\")),\n-    (\"f16c\", Some(\"f16c_target_feature\")),\n+    (\"cmpxchg16b\", Some(sym::cmpxchg16b_target_feature)),\n+    (\"f16c\", Some(sym::f16c_target_feature)),\n     (\"fma\", None),\n     (\"fxsr\", None),\n     (\"lzcnt\", None),\n-    (\"mmx\", Some(\"mmx_target_feature\")),\n-    (\"movbe\", Some(\"movbe_target_feature\")),\n+    (\"mmx\", Some(sym::mmx_target_feature)),\n+    (\"movbe\", Some(sym::movbe_target_feature)),\n     (\"pclmulqdq\", None),\n     (\"popcnt\", None),\n     (\"rdrand\", None),\n     (\"rdseed\", None),\n-    (\"rtm\", Some(\"rtm_target_feature\")),\n+    (\"rtm\", Some(sym::rtm_target_feature)),\n     (\"sha\", None),\n     (\"sse\", None),\n     (\"sse2\", None),\n     (\"sse3\", None),\n     (\"sse4.1\", None),\n     (\"sse4.2\", None),\n-    (\"sse4a\", Some(\"sse4a_target_feature\")),\n+    (\"sse4a\", Some(sym::sse4a_target_feature)),\n     (\"ssse3\", None),\n-    (\"tbm\", Some(\"tbm_target_feature\")),\n+    (\"tbm\", Some(sym::tbm_target_feature)),\n     (\"xsave\", None),\n     (\"xsavec\", None),\n     (\"xsaveopt\", None),\n     (\"xsaves\", None),\n ];\n \n-const HEXAGON_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"hvx\", Some(\"hexagon_target_feature\")),\n-    (\"hvx-double\", Some(\"hexagon_target_feature\")),\n+const HEXAGON_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"hvx\", Some(sym::hexagon_target_feature)),\n+    (\"hvx-double\", Some(sym::hexagon_target_feature)),\n ];\n \n-const POWERPC_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"altivec\", Some(\"powerpc_target_feature\")),\n-    (\"power8-altivec\", Some(\"powerpc_target_feature\")),\n-    (\"power9-altivec\", Some(\"powerpc_target_feature\")),\n-    (\"power8-vector\", Some(\"powerpc_target_feature\")),\n-    (\"power9-vector\", Some(\"powerpc_target_feature\")),\n-    (\"vsx\", Some(\"powerpc_target_feature\")),\n+const POWERPC_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power8-altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power9-altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power8-vector\", Some(sym::powerpc_target_feature)),\n+    (\"power9-vector\", Some(sym::powerpc_target_feature)),\n+    (\"vsx\", Some(sym::powerpc_target_feature)),\n ];\n \n-const MIPS_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"fp64\", Some(\"mips_target_feature\")),\n-    (\"msa\", Some(\"mips_target_feature\")),\n+const MIPS_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"fp64\", Some(sym::mips_target_feature)),\n+    (\"msa\", Some(sym::mips_target_feature)),\n ];\n \n-const WASM_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"simd128\", Some(\"wasm_target_feature\")),\n-    (\"atomics\", Some(\"wasm_target_feature\")),\n+const WASM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"simd128\", Some(sym::wasm_target_feature)),\n+    (\"atomics\", Some(sym::wasm_target_feature)),\n ];\n \n /// When rustdoc is running, provide a list of all known features so that all their respective\n /// primitives may be documented.\n ///\n /// IMPORTANT: If you're adding another whitelist to the above lists, make sure to add it to this\n /// iterator!\n-pub fn all_known_features() -> impl Iterator<Item=(&'static str, Option<&'static str>)> {\n+pub fn all_known_features() -> impl Iterator<Item=(&'static str, Option<Symbol>)> {\n     ARM_WHITELIST.iter().cloned()\n         .chain(AARCH64_WHITELIST.iter().cloned())\n         .chain(X86_WHITELIST.iter().cloned())\n@@ -247,7 +248,7 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n }\n \n pub fn target_feature_whitelist(sess: &Session)\n-    -> &'static [(&'static str, Option<&'static str>)]\n+    -> &'static [(&'static str, Option<Symbol>)]\n {\n     match &*sess.target.target.arch {\n         \"arm\" => ARM_WHITELIST,"}, {"sha": "a3d3f0756a5f3997405faf73485934f3bd9987de", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -10,7 +10,7 @@ use rustc_codegen_ssa::traits::*;\n \n use crate::common;\n use crate::type_of::LayoutLlvmExt;\n-use crate::abi::{LlvmType, FnTypeExt};\n+use crate::abi::{LlvmType, FnTypeLlvmExt};\n use syntax::ast;\n use rustc::ty::Ty;\n use rustc::ty::layout::{self, Align, Size, TyLayout};"}, {"sha": "800bf505125d677842d88e8023848b91edb342fa", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,8 +1,8 @@\n-use crate::abi::{FnType, FnTypeExt};\n+use crate::abi::{FnType};\n use crate::common::*;\n use crate::type_::Type;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, Align, LayoutOf, PointeeInfo, Size, TyLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, FnTypeExt, PointeeInfo, Size, TyLayout};\n use rustc_target::abi::{FloatTy, TyLayoutMethods};\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use rustc_codegen_ssa::traits::*;"}, {"sha": "1c793996c83db65cc1cc2960546f358197812253", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -28,7 +28,7 @@ use rustc_target::spec::MergeFunctions;\n use syntax::attr;\n use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n-use syntax_pos::symbol::Symbol;\n+use syntax_pos::symbol::{Symbol, sym};\n use jobserver::{Client, Acquired};\n \n use std::any::Any;\n@@ -248,6 +248,7 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub tm_factory: TargetMachineFactory<B>,\n     pub msvc_imps_needed: bool,\n     pub target_pointer_width: String,\n+    pub target_arch: String,\n     pub debuginfo: config::DebugInfo,\n \n     // Number of cgus excluding the allocator/metadata modules\n@@ -382,11 +383,11 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n-    let no_builtins = attr::contains_name(&tcx.hir().krate().attrs, \"no_builtins\");\n+    let no_builtins = attr::contains_name(&tcx.hir().krate().attrs, sym::no_builtins);\n     let subsystem = attr::first_attr_value_str_by_name(&tcx.hir().krate().attrs,\n-                                                       \"windows_subsystem\");\n+                                                       sym::windows_subsystem);\n     let windows_subsystem = subsystem.map(|subsystem| {\n-        if subsystem != \"windows\" && subsystem != \"console\" {\n+        if subsystem != sym::windows && subsystem != sym::console {\n             tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\\n                                      `windows` and `console` are allowed\",\n                                     subsystem));\n@@ -1103,6 +1104,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         total_cgus,\n         msvc_imps_needed: msvc_imps_needed(tcx),\n         target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),\n+        target_arch: tcx.sess.target.target.arch.clone(),\n         debuginfo: tcx.sess.opts.debuginfo,\n         assembler_cmd,\n     };"}, {"sha": "06d7b6c78f14bffa866945f2a03f251030180e73", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -243,9 +243,8 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             }\n \n             PlaceContext::MutatingUse(MutatingUseContext::Drop) => {\n-                let ty = mir::Place::Base(mir::PlaceBase::Local(local)).ty(self.fx.mir,\n-                                                                           self.fx.cx.tcx());\n-                let ty = self.fx.monomorphize(&ty.ty);\n+                let ty = self.fx.mir.local_decls[local].ty;\n+                let ty = self.fx.monomorphize(&ty);\n \n                 // Only need the place if we're actually dropping it.\n                 if self.fx.cx.type_needs_drop(ty) {"}, {"sha": "c7dd019fc3eb8abb464c0bcca87e15059a312c76", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,6 +1,6 @@\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n+use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, FnTypeExt};\n use rustc::mir::{self, Place, PlaceBase, Static, StaticKind};\n use rustc::mir::interpret::InterpError;\n use rustc_target::abi::call::{ArgType, FnType, PassMode, IgnoreMode};\n@@ -15,7 +15,7 @@ use crate::traits::*;\n \n use std::borrow::Cow;\n \n-use syntax::symbol::Symbol;\n+use syntax::symbol::LocalInternedString;\n use syntax_pos::Pos;\n \n use super::{FunctionCx, LocalRef};\n@@ -334,14 +334,14 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     ty::ParamEnv::reveal_all(),\n                     &sig,\n                 );\n-                let fn_ty = bx.new_vtable(sig, &[]);\n+                let fn_ty = FnType::new_vtable(&bx, sig, &[]);\n                 let vtable = args[1];\n                 args = &args[..1];\n                 (meth::DESTRUCTOR.get_fn(&mut bx, vtable, &fn_ty), fn_ty)\n             }\n             _ => {\n                 (bx.get_fn(drop_fn),\n-                 bx.fn_type_of_instance(&drop_fn))\n+                 FnType::of_instance(&bx, &drop_fn))\n             }\n         };\n         helper.do_call(self, &mut bx, fn_ty, drop_fn, args,\n@@ -401,7 +401,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Get the location information.\n         let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n-        let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n+        let filename = LocalInternedString::intern(&loc.file.name.to_string());\n         let line = bx.const_u32(loc.line as u32);\n         let col = bx.const_u32(loc.col.to_usize() as u32 + 1);\n \n@@ -423,7 +423,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n             _ => {\n                 let str = msg.description();\n-                let msg_str = Symbol::intern(str).as_str();\n+                let msg_str = LocalInternedString::intern(str);\n                 let msg_file_line_col = bx.static_panic_msg(\n                     Some(msg_str),\n                     filename,\n@@ -439,7 +439,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Obtain the panic entry point.\n         let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n         let instance = ty::Instance::mono(bx.tcx(), def_id);\n-        let fn_ty = bx.fn_type_of_instance(&instance);\n+        let fn_ty = FnType::of_instance(&bx, &instance);\n         let llfn = bx.get_fn(instance);\n \n         // Codegen the actual panic invoke/call.\n@@ -518,15 +518,15 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let fn_ty = match def {\n             Some(ty::InstanceDef::Virtual(..)) => {\n-                bx.new_vtable(sig, &extra_args)\n+                FnType::new_vtable(&bx, sig, &extra_args)\n             }\n             Some(ty::InstanceDef::DropGlue(_, None)) => {\n                 // Empty drop glue; a no-op.\n                 let &(_, target) = destination.as_ref().unwrap();\n                 helper.funclet_br(self, &mut bx, target);\n                 return;\n             }\n-            _ => bx.new_fn_type(sig, &extra_args)\n+            _ => FnType::new(&bx, sig, &extra_args)\n         };\n \n         // Emit a panic or a no-op for `panic_if_uninhabited`.\n@@ -535,15 +535,15 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let layout = bx.layout_of(ty);\n             if layout.abi.is_uninhabited() {\n                 let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n-                let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n+                let filename = LocalInternedString::intern(&loc.file.name.to_string());\n                 let line = bx.const_u32(loc.line as u32);\n                 let col = bx.const_u32(loc.col.to_usize() as u32 + 1);\n \n                 let str = format!(\n                     \"Attempted to instantiate uninhabited type {}\",\n                     ty\n                 );\n-                let msg_str = Symbol::intern(&str).as_str();\n+                let msg_str = LocalInternedString::intern(&str);\n                 let msg_file_line_col = bx.static_panic_msg(\n                     Some(msg_str),\n                     filename,\n@@ -556,7 +556,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let def_id =\n                     common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let fn_ty = bx.fn_type_of_instance(&instance);\n+                let fn_ty = FnType::of_instance(&bx, &instance);\n                 let llfn = bx.get_fn(instance);\n \n                 // Codegen the actual panic invoke/call."}, {"sha": "060d7d18625fcd358323405f1570db82a632d9cc", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,5 +1,5 @@\n use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts};\n-use rustc::ty::layout::{TyLayout, HasTyCtxt};\n+use rustc::ty::layout::{TyLayout, HasTyCtxt, FnTypeExt};\n use rustc::mir::{self, Mir};\n use rustc::session::config::DebugInfo;\n use rustc_mir::monomorphize::Instance;\n@@ -202,7 +202,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n ) {\n     assert!(!instance.substs.needs_infer());\n \n-    let fn_ty = cx.new_fn_type(sig, &[]);\n+    let fn_ty = FnType::new(cx, sig, &[]);\n     debug!(\"fn_ty: {:?}\", fn_ty);\n     let mut debug_context =\n         cx.create_function_debug_context(instance, sig, llfn, mir);"}, {"sha": "586db5cfabea44c83c1e4bafdeffca034818b86d", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -5,6 +5,7 @@ use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n use std::{u128, i128};\n+use syntax::symbol::sym;\n \n use crate::base;\n use crate::MemFlags;\n@@ -181,9 +182,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     mir::CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n                         match operand.layout.ty.sty {\n                             ty::FnDef(def_id, substs) => {\n-                                if bx.cx().tcx().has_attr(def_id, \"rustc_args_required_const\") {\n-                                    bug!(\"reifying a fn ptr that requires \\\n-                                          const arguments\");\n+                                if bx.cx().tcx().has_attr(def_id, sym::rustc_args_required_const) {\n+                                    bug!(\"reifying a fn ptr that requires const arguments\");\n                                 }\n                                 OperandValue::Immediate(\n                                     callee::resolve_and_get_fn(bx.cx(), def_id, substs))"}, {"sha": "509255c37be701853dd2f00e15406fa77c0d189e", "filename": "src/librustc_codegen_ssa/traits/abi.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,13 +1,7 @@\n use super::BackendTypes;\n-use rustc::ty::{FnSig, Instance, Ty};\n+use rustc::ty::{Ty};\n use rustc_target::abi::call::FnType;\n \n-pub trait AbiMethods<'tcx> {\n-    fn new_fn_type(&self, sig: FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> FnType<'tcx, Ty<'tcx>>;\n-    fn new_vtable(&self, sig: FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> FnType<'tcx, Ty<'tcx>>;\n-    fn fn_type_of_instance(&self, instance: &Instance<'tcx>) -> FnType<'tcx, Ty<'tcx>>;\n-}\n-\n pub trait AbiBuilderMethods<'tcx>: BackendTypes {\n     fn apply_attrs_callsite(&mut self, ty: &FnType<'tcx, Ty<'tcx>>, callsite: Self::Value);\n     fn get_param(&self, index: usize) -> Self::Value;"}, {"sha": "0c4c4547a7955a1f0ad3ffdd391ea11d678509b4", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -11,6 +11,7 @@ use crate::mir::place::PlaceRef;\n use crate::MemFlags;\n use rustc::ty::Ty;\n use rustc::ty::layout::{Align, Size, HasParamEnv};\n+use rustc_target::spec::{HasTargetSpec};\n use std::ops::Range;\n use std::iter::TrustedLen;\n \n@@ -30,6 +31,7 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     + AsmBuilderMethods<'tcx>\n     + StaticBuilderMethods<'tcx>\n     + HasParamEnv<'tcx>\n+    + HasTargetSpec\n \n {\n     fn new_block<'b>(cx: &'a Self::CodegenCx, llfn: Self::Value, name: &'b str) -> Self;"}, {"sha": "2bb619e79f5e06ee0b0781c46463e0433d94ca41", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -27,7 +27,7 @@ mod statics;\n mod type_;\n mod write;\n \n-pub use self::abi::{AbiBuilderMethods, AbiMethods};\n+pub use self::abi::{AbiBuilderMethods};\n pub use self::asm::{AsmBuilderMethods, AsmMethods};\n pub use self::backend::{Backend, BackendTypes, ExtraBackendMethods};\n pub use self::builder::{BuilderMethods, OverflowOp};\n@@ -41,7 +41,8 @@ pub use self::type_::{\n     ArgTypeMethods, BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods, TypeMethods,\n };\n pub use self::write::{ModuleBufferMethods, ThinBufferMethods, WriteBackendMethods};\n-use rustc::ty::layout::{HasParamEnv};\n+use rustc::ty::layout::{HasParamEnv, HasTyCtxt};\n+use rustc_target::spec::{HasTargetSpec};\n \n \n use std::fmt;\n@@ -56,11 +57,12 @@ pub trait CodegenMethods<'tcx>:\n     + ConstMethods<'tcx>\n     + StaticMethods\n     + DebugInfoMethods<'tcx>\n-    + AbiMethods<'tcx>\n     + DeclareMethods<'tcx>\n     + AsmMethods<'tcx>\n     + PreDefineMethods<'tcx>\n     + HasParamEnv<'tcx>\n+    + HasTyCtxt<'tcx>\n+    + HasTargetSpec\n {\n }\n \n@@ -71,11 +73,12 @@ impl<'tcx, T> CodegenMethods<'tcx> for T where\n         + ConstMethods<'tcx>\n         + StaticMethods\n         + DebugInfoMethods<'tcx>\n-        + AbiMethods<'tcx>\n         + DeclareMethods<'tcx>\n         + AsmMethods<'tcx>\n         + PreDefineMethods<'tcx>\n         + HasParamEnv<'tcx>\n+        + HasTyCtxt<'tcx>\n+        + HasTargetSpec\n {\n }\n "}, {"sha": "b4ba90c61f65054fb2242d9825eba54466f96227", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -23,6 +23,7 @@ extern crate rustc;\n \n use rustc::ty::TyCtxt;\n use rustc::hir::def_id::LOCAL_CRATE;\n+use syntax::symbol::sym;\n \n pub mod link;\n pub mod codegen_backend;\n@@ -35,7 +36,7 @@ pub mod symbol_names_test;\n /// reporting an error.\n pub fn check_for_rustc_errors_attr(tcx: TyCtxt<'_, '_, '_>) {\n     if let Some((def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n-        if tcx.has_attr(def_id, \"rustc_error\") {\n+        if tcx.has_attr(def_id, sym::rustc_error) {\n             tcx.sess.span_fatal(tcx.def_span(def_id), \"compilation successful\");\n         }\n     }"}, {"sha": "a2ac64fa7e0c659501ed309b202d20e9326b0561", "filename": "src/librustc_codegen_utils/link.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flink.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -2,6 +2,7 @@ use rustc::session::config::{self, OutputFilenames, Input, OutputType};\n use rustc::session::Session;\n use std::path::{Path, PathBuf};\n use syntax::{ast, attr};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n pub fn out_filename(sess: &Session,\n@@ -49,13 +50,13 @@ pub fn find_crate_name(sess: Option<&Session>,\n     // as used. After doing this, however, we still prioritize a crate name from\n     // the command line over one found in the #[crate_name] attribute. If we\n     // find both we ensure that they're the same later on as well.\n-    let attr_crate_name = attr::find_by_name(attrs, \"crate_name\")\n+    let attr_crate_name = attr::find_by_name(attrs, sym::crate_name)\n         .and_then(|at| at.value_str().map(|s| (at, s)));\n \n     if let Some(sess) = sess {\n         if let Some(ref s) = sess.opts.crate_name {\n             if let Some((attr, name)) = attr_crate_name {\n-                if name != &**s {\n+                if name.as_str() != *s {\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);"}, {"sha": "6915687ceba930d0bde8a5844293a7e7465ca89e", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -101,7 +101,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_mir::monomorphize::item::{InstantiationMode, MonoItem, MonoItemExt};\n use rustc_mir::monomorphize::Instance;\n \n-use syntax_pos::symbol::{Symbol, InternedString};\n+use syntax_pos::symbol::InternedString;\n \n use log::debug;\n \n@@ -238,13 +238,13 @@ fn compute_symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) ->\n     if def_id.is_local() {\n         if tcx.plugin_registrar_fn(LOCAL_CRATE) == Some(def_id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n-            return Symbol::intern(&tcx.sess.generate_plugin_registrar_symbol(disambiguator))\n-                .as_interned_str();\n+            return\n+                InternedString::intern(&tcx.sess.generate_plugin_registrar_symbol(disambiguator));\n         }\n         if tcx.proc_macro_decls_static(LOCAL_CRATE) == Some(def_id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n-            return Symbol::intern(&tcx.sess.generate_proc_macro_decls_symbol(disambiguator))\n-                .as_interned_str();\n+            return\n+                InternedString::intern(&tcx.sess.generate_proc_macro_decls_symbol(disambiguator));\n         }\n     }\n \n@@ -322,7 +322,7 @@ fn compute_symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) ->\n         let _ = printer.write_str(\"{{vtable-shim}}\");\n     }\n \n-    Symbol::intern(&printer.path.finish(hash)).as_interned_str()\n+    InternedString::intern(&printer.path.finish(hash))\n }\n \n // Follow C++ namespace-mangling style, see"}, {"sha": "27ae0b97e59452f406c34d87ecfb133f74d7e8c4", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -6,11 +6,11 @@\n \n use rustc::hir;\n use rustc::ty::TyCtxt;\n-\n use rustc_mir::monomorphize::Instance;\n+use syntax::symbol::{Symbol, sym};\n \n-const SYMBOL_NAME: &'static str = \"rustc_symbol_name\";\n-const DEF_PATH: &'static str = \"rustc_def_path\";\n+const SYMBOL_NAME: Symbol = sym::rustc_symbol_name;\n+const DEF_PATH: Symbol = sym::rustc_def_path;\n \n pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // if the `rustc_attrs` feature is not enabled, then the"}, {"sha": "b63701dbc0967d1209718f55b6511c86b8134961", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -44,7 +44,6 @@ cfg_if! {\n         }\n \n         #[cfg(any(target_os = \"dragonfly\",\n-                  target_os = \"bitrig\",\n                   target_os = \"netbsd\",\n                   target_os = \"openbsd\"))]\n         mod os {"}, {"sha": "7fc23999284a71681dc53506aba56a12bc42f526", "filename": "src/librustc_data_structures/macros.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_data_structures%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_data_structures%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fmacros.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -10,3 +10,12 @@ macro_rules! static_assert {\n         static $name: () = [()][!($test: bool) as usize];\n     }\n }\n+\n+/// Type size assertion. The first argument is a type and the second argument is its expected size.\n+#[macro_export]\n+#[allow_internal_unstable(underscore_const_names)]\n+macro_rules! static_assert_size {\n+    ($ty:ty, $size:expr) => {\n+        const _: [(); $size] = [(); ::std::mem::size_of::<$ty>()];\n+    }\n+}"}, {"sha": "2b844aa24d49c92a6d5bdbd165762f5a00908b31", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -15,7 +15,6 @@ use crate::bit_set;\n /// extended to 64 bits if needed.\n pub struct StableHasher<W> {\n     state: SipHasher128,\n-    bytes_hashed: u64,\n     width: PhantomData<W>,\n }\n \n@@ -33,7 +32,6 @@ impl<W: StableHasherResult> StableHasher<W> {\n     pub fn new() -> Self {\n         StableHasher {\n             state: SipHasher128::new_with_keys(0, 0),\n-            bytes_hashed: 0,\n             width: PhantomData,\n         }\n     }\n@@ -61,11 +59,6 @@ impl<W> StableHasher<W> {\n     pub fn finalize(self) -> (u64, u64) {\n         self.state.finish128()\n     }\n-\n-    #[inline]\n-    pub fn bytes_hashed(&self) -> u64 {\n-        self.bytes_hashed\n-    }\n }\n \n impl<W> Hasher for StableHasher<W> {\n@@ -76,37 +69,31 @@ impl<W> Hasher for StableHasher<W> {\n     #[inline]\n     fn write(&mut self, bytes: &[u8]) {\n         self.state.write(bytes);\n-        self.bytes_hashed += bytes.len() as u64;\n     }\n \n     #[inline]\n     fn write_u8(&mut self, i: u8) {\n         self.state.write_u8(i);\n-        self.bytes_hashed += 1;\n     }\n \n     #[inline]\n     fn write_u16(&mut self, i: u16) {\n         self.state.write_u16(i.to_le());\n-        self.bytes_hashed += 2;\n     }\n \n     #[inline]\n     fn write_u32(&mut self, i: u32) {\n         self.state.write_u32(i.to_le());\n-        self.bytes_hashed += 4;\n     }\n \n     #[inline]\n     fn write_u64(&mut self, i: u64) {\n         self.state.write_u64(i.to_le());\n-        self.bytes_hashed += 8;\n     }\n \n     #[inline]\n     fn write_u128(&mut self, i: u128) {\n         self.state.write_u128(i.to_le());\n-        self.bytes_hashed += 16;\n     }\n \n     #[inline]\n@@ -115,37 +102,31 @@ impl<W> Hasher for StableHasher<W> {\n         // platforms. This is important for symbol hashes when cross compiling,\n         // for example.\n         self.state.write_u64((i as u64).to_le());\n-        self.bytes_hashed += 8;\n     }\n \n     #[inline]\n     fn write_i8(&mut self, i: i8) {\n         self.state.write_i8(i);\n-        self.bytes_hashed += 1;\n     }\n \n     #[inline]\n     fn write_i16(&mut self, i: i16) {\n         self.state.write_i16(i.to_le());\n-        self.bytes_hashed += 2;\n     }\n \n     #[inline]\n     fn write_i32(&mut self, i: i32) {\n         self.state.write_i32(i.to_le());\n-        self.bytes_hashed += 4;\n     }\n \n     #[inline]\n     fn write_i64(&mut self, i: i64) {\n         self.state.write_i64(i.to_le());\n-        self.bytes_hashed += 8;\n     }\n \n     #[inline]\n     fn write_i128(&mut self, i: i128) {\n         self.state.write_i128(i.to_le());\n-        self.bytes_hashed += 16;\n     }\n \n     #[inline]\n@@ -154,12 +135,35 @@ impl<W> Hasher for StableHasher<W> {\n         // platforms. This is important for symbol hashes when cross compiling,\n         // for example.\n         self.state.write_i64((i as i64).to_le());\n-        self.bytes_hashed += 8;\n     }\n }\n \n /// Something that implements `HashStable<CTX>` can be hashed in a way that is\n /// stable across multiple compilation sessions.\n+///\n+/// Note that `HashStable` imposes rather more strict requirements than usual\n+/// hash functions:\n+///\n+/// - Stable hashes are sometimes used as identifiers. Therefore they must\n+///   conform to the corresponding `PartialEq` implementations:\n+///\n+///     - `x == y` implies `hash_stable(x) == hash_stable(y)`, and\n+///     - `x != y` implies `hash_stable(x) != hash_stable(y)`.\n+///\n+///   That second condition is usually not required for hash functions\n+///   (e.g. `Hash`). In practice this means that `hash_stable` must feed any\n+///   information into the hasher that a `PartialEq` comparision takes into\n+///   account. See [#49300](https://github.com/rust-lang/rust/issues/49300)\n+///   for an example where violating this invariant has caused trouble in the\n+///   past.\n+///\n+/// - `hash_stable()` must be independent of the current\n+///    compilation session. E.g. they must not hash memory addresses or other\n+///    things that are \"randomly\" assigned per compilation session.\n+///\n+/// - `hash_stable()` must be independent of the host architecture. The\n+///   `StableHasher` takes care of endianness and `isize`/`usize` platform\n+///   differences.\n pub trait HashStable<CTX> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut CTX,"}, {"sha": "02f8eee67b15118ffed36a9b0b19f79054a286f7", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -63,6 +63,7 @@ use syntax::ast;\n use syntax::source_map::FileLoader;\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n+use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n \n pub mod pretty;\n@@ -669,7 +670,7 @@ impl RustcDefaultCalls {\n                         // through to build scripts.\n                         let value = value.as_ref().map(|s| s.as_str());\n                         let value = value.as_ref().map(|s| s.as_ref());\n-                        if name != \"target_feature\" || value != Some(\"crt-static\") {\n+                        if name != sym::target_feature || value != Some(\"crt-static\") {\n                             if !allow_unstable_cfg && gated_cfg.is_some() {\n                                 return None\n                             }"}, {"sha": "812321ff5e6c36f8fd16f772752f03b6d25eb5c2", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -648,7 +648,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n     // have to be user friendly.\n     let name = format!(\n         \"hir_id_{}_{}\",\n-        hir_id.owner.as_array_index(),\n+        hir_id.owner.index(),\n         hir_id.local_id.index(),\n     );\n     let lcfg = LabelledCFG {\n@@ -805,8 +805,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                                             src_name,\n                                             &mut rdr,\n                                             box out,\n-                                            annotation.pp_ann(),\n-                                            true)\n+                                            annotation.pp_ann())\n                 })\n             }\n \n@@ -829,8 +828,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                                                                          src_name,\n                                                                          &mut rdr,\n                                                                          box out,\n-                                                                         annotation.pp_ann(),\n-                                                                         true);\n+                                                                         annotation.pp_ann());\n                     for node_id in uii.all_matching_node_ids(hir_map) {\n                         let node = hir_map.get(node_id);\n                         pp_state.print_node(node)?;"}, {"sha": "31f697a724a0357385bfb81487c7684c32f84041", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -100,6 +100,18 @@ impl<'a> DiagnosticBuilder<'a> {\n         self.cancel();\n     }\n \n+    /// Emit the diagnostic unless `delay` is true,\n+    /// in which case the emission will be delayed as a bug.\n+    ///\n+    /// See `emit` and `delay_as_bug` for details.\n+    pub fn emit_unless(&mut self, delay: bool) {\n+        if delay {\n+            self.delay_as_bug()\n+        } else {\n+            self.emit()\n+        }\n+    }\n+\n     /// Buffers the diagnostic for later emission, unless handler\n     /// has disabled such buffering.\n     pub fn buffer(mut self, buffered_diagnostics: &mut Vec<Diagnostic>) {"}, {"sha": "04dad9c5355c5b6028416a6a8cac8633660d8335", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -27,12 +27,13 @@ use rustc::mir::mono::CodegenUnitNameBuilder;\n use rustc::ty::TyCtxt;\n use std::collections::BTreeSet;\n use syntax::ast;\n+use syntax::symbol::{Symbol, sym};\n use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED,\n                  ATTR_EXPECTED_CGU_REUSE};\n \n-const MODULE: &str = \"module\";\n-const CFG: &str = \"cfg\";\n-const KIND: &str = \"kind\";\n+const MODULE: Symbol = sym::module;\n+const CFG: Symbol = sym::cfg;\n+const KIND: Symbol = sym::kind;\n \n pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.dep_graph.with_ignore(|| {\n@@ -146,7 +147,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n                                                         comp_kind);\n     }\n \n-    fn field(&self, attr: &ast::Attribute, name: &str) -> ast::Name {\n+    fn field(&self, attr: &ast::Attribute, name: Symbol) -> ast::Name {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(name) {\n                 if let Some(value) = item.value_str() {"}, {"sha": "f404a4f82e672a1e76958d45b3b72bb31ddac777", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -23,14 +23,15 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit;\n use rustc::ich::{ATTR_DIRTY, ATTR_CLEAN};\n-use syntax::ast::{self, Attribute, NestedMetaItem};\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashSet;\n+use syntax::ast::{self, Attribute, NestedMetaItem};\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n-use rustc::ty::TyCtxt;\n \n-const EXCEPT: &str = \"except\";\n-const LABEL: &str = \"label\";\n-const CFG: &str = \"cfg\";\n+const EXCEPT: Symbol = sym::except;\n+const LABEL: Symbol = sym::label;\n+const CFG: Symbol = sym::cfg;\n \n // Base and Extra labels to build up the labels\n \n@@ -591,7 +592,7 @@ fn expect_associated_value(tcx: TyCtxt<'_, '_, '_>, item: &NestedMetaItem) -> as\n // nodes.\n pub struct FindAllAttrs<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    attr_names: Vec<&'static str>,\n+    attr_names: Vec<Symbol>,\n     found_attrs: Vec<&'tcx Attribute>,\n }\n "}, {"sha": "c5ac8860ccd9b079db0146dc386df0c92fa398f8", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -230,7 +230,7 @@ impl BoxedResolver {\n \n pub struct PluginInfo {\n     syntax_exts: Vec<NamedSyntaxExtension>,\n-    attributes: Vec<(String, AttributeType)>,\n+    attributes: Vec<(Symbol, AttributeType)>,\n }\n \n pub fn register_plugins<'a>("}, {"sha": "e9f2f0410d440bb7889e27bcdc0eee798dfc3d52", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -4,6 +4,7 @@ use rustc::hir;\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n use syntax::attr;\n+use syntax::symbol::sym;\n \n pub fn find<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> Option<DefId> {\n     tcx.proc_macro_decls_static(LOCAL_CRATE)\n@@ -27,7 +28,7 @@ struct Finder {\n \n impl<'v> ItemLikeVisitor<'v> for Finder {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if attr::contains_name(&item.attrs, \"rustc_proc_macro_decls\") {\n+        if attr::contains_name(&item.attrs, sym::rustc_proc_macro_decls) {\n             self.decls = Some(item.hir_id);\n         }\n     }"}, {"sha": "d2d0d19180783bfd5b8fc557553514bbf0fb6731", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -35,7 +35,7 @@ use syntax::mut_visit::{*, MutVisitor, visit_clobber};\n use syntax::ast::BlockCheckMode;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::source_map::{FileLoader, RealFileLoader, SourceMap};\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::{self, ast, attr};\n #[cfg(not(parallel_compiler))]\n use std::{thread, panic};\n@@ -495,24 +495,24 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n     let attr_types: Vec<config::CrateType> = attrs\n         .iter()\n         .filter_map(|a| {\n-            if a.check_name(\"crate_type\") {\n+            if a.check_name(sym::crate_type) {\n                 match a.value_str() {\n-                    Some(ref n) if *n == \"rlib\" => Some(config::CrateType::Rlib),\n-                    Some(ref n) if *n == \"dylib\" => Some(config::CrateType::Dylib),\n-                    Some(ref n) if *n == \"cdylib\" => Some(config::CrateType::Cdylib),\n-                    Some(ref n) if *n == \"lib\" => Some(config::default_lib_output()),\n-                    Some(ref n) if *n == \"staticlib\" => Some(config::CrateType::Staticlib),\n-                    Some(ref n) if *n == \"proc-macro\" => Some(config::CrateType::ProcMacro),\n-                    Some(ref n) if *n == \"bin\" => Some(config::CrateType::Executable),\n-                    Some(ref n) => {\n+                    Some(sym::rlib) => Some(config::CrateType::Rlib),\n+                    Some(sym::dylib) => Some(config::CrateType::Dylib),\n+                    Some(sym::cdylib) => Some(config::CrateType::Cdylib),\n+                    Some(sym::lib) => Some(config::default_lib_output()),\n+                    Some(sym::staticlib) => Some(config::CrateType::Staticlib),\n+                    Some(sym::proc_dash_macro) => Some(config::CrateType::ProcMacro),\n+                    Some(sym::bin) => Some(config::CrateType::Executable),\n+                    Some(n) => {\n                         let crate_types = vec![\n-                            Symbol::intern(\"rlib\"),\n-                            Symbol::intern(\"dylib\"),\n-                            Symbol::intern(\"cdylib\"),\n-                            Symbol::intern(\"lib\"),\n-                            Symbol::intern(\"staticlib\"),\n-                            Symbol::intern(\"proc-macro\"),\n-                            Symbol::intern(\"bin\")\n+                            sym::rlib,\n+                            sym::dylib,\n+                            sym::cdylib,\n+                            sym::lib,\n+                            sym::staticlib,\n+                            sym::proc_dash_macro,\n+                            sym::bin\n                         ];\n \n                         if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().node {"}, {"sha": "af4f1b88b0fb0ac8e8e6938c545f58d8b70b3f2e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -42,7 +42,7 @@ use syntax::edition::Edition;\n use syntax::feature_gate::{AttributeGate, AttributeTemplate, AttributeType};\n use syntax::feature_gate::{Stability, deprecated_attributes};\n use syntax_pos::{BytePos, Span, SyntaxContext};\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax::errors::{Applicability, DiagnosticBuilder};\n use syntax::print::pprust::expr_to_string;\n use syntax::visit::FnKind;\n@@ -207,7 +207,7 @@ impl UnsafeCode {\n \n impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n-        if attr.check_name(\"allow_internal_unsafe\") {\n+        if attr.check_name(sym::allow_internal_unsafe) {\n             self.report_unsafe(cx, attr.span, \"`allow_internal_unsafe` allows defining \\\n                                                macros using unsafe without triggering \\\n                                                the `unsafe_code` lint at their call site\");\n@@ -285,7 +285,7 @@ pub struct MissingDoc {\n impl_lint_pass!(MissingDoc => [MISSING_DOCS]);\n \n fn has_doc(attr: &ast::Attribute) -> bool {\n-    if !attr.check_name(\"doc\") {\n+    if !attr.check_name(sym::doc) {\n         return false;\n     }\n \n@@ -295,7 +295,7 @@ fn has_doc(attr: &ast::Attribute) -> bool {\n \n     if let Some(list) = attr.meta_item_list() {\n         for meta in list {\n-            if meta.check_name(\"include\") || meta.check_name(\"hidden\") {\n+            if meta.check_name(sym::include) || meta.check_name(sym::hidden) {\n                 return true;\n             }\n         }\n@@ -355,10 +355,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext<'_, '_>, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() ||\n                          attrs.iter().any(|attr| {\n-            attr.check_name(\"doc\") &&\n+            attr.check_name(sym::doc) &&\n             match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::list_contains_name(&l, \"hidden\"),\n+                Some(l) => attr::list_contains_name(&l, sym::hidden),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -723,7 +723,7 @@ impl UnusedDocComment {\n \n             let span = sugared_span.take().unwrap_or_else(|| attr.span);\n \n-            if attr.check_name(\"doc\") {\n+            if attr.check_name(sym::doc) {\n                 let mut err = cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, \"unused doc comment\");\n \n                 err.span_label(\n@@ -829,7 +829,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         match it.node {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n-                if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, \"no_mangle\") {\n+                if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                     for param in &generics.params {\n                         match param.kind {\n                             GenericParamKind::Lifetime { .. } => {}\n@@ -856,7 +856,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                 }\n             }\n             hir::ItemKind::Const(..) => {\n-                if attr::contains_name(&it.attrs, \"no_mangle\") {\n+                if attr::contains_name(&it.attrs, sym::no_mangle) {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n                     let msg = \"const items should never be #[no_mangle]\";\n@@ -947,7 +947,7 @@ declare_lint_pass!(\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n     fn check_attribute(&mut self, ctx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n-        if attr.check_name(\"feature\") {\n+        if attr.check_name(sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n                     ctx.span_lint(UNSTABLE_FEATURES, item.span(), \"unstable feature\");\n@@ -1382,7 +1382,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n             return;\n         }\n \n-        if let Some(attr) = attr::find_by_name(&it.attrs, \"rustc_test_marker\") {\n+        if let Some(attr) = attr::find_by_name(&it.attrs, sym::rustc_test_marker) {\n             cx.struct_span_lint(\n                 UNNAMEABLE_TEST_ITEMS,\n                 attr.span,"}, {"sha": "ba72beecc1a1800204902670d19e725959355e24", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -371,11 +371,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             reference: \"issue #46043 <https://github.com/rust-lang/rust/issues/46043>\",\n             edition: None,\n         },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(INCOHERENT_FUNDAMENTAL_IMPLS),\n-            reference: \"issue #46205 <https://github.com/rust-lang/rust/issues/46205>\",\n-            edition: None,\n-        },\n         FutureIncompatibleInfo {\n             id: LintId::of(ORDER_DEPENDENT_TRAIT_OBJECTS),\n             reference: \"issue #56484 <https://github.com/rust-lang/rust/issues/56484>\",\n@@ -491,6 +486,8 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         \"replaced with a generic attribute input check\");\n     store.register_removed(\"duplicate_matcher_binding_name\",\n         \"converted into hard error, see https://github.com/rust-lang/rust/issues/57742\");\n+    store.register_removed(\"incoherent_fundamental_impls\",\n+        \"converted into hard error, see https://github.com/rust-lang/rust/issues/46205\");\n }\n \n pub fn register_internals(store: &mut lint::LintStore, sess: Option<&Session>) {"}, {"sha": "551eded9858a35021fb31d24ccf9a6bdc860f442", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -9,6 +9,7 @@ use lint::{EarlyLintPass, LintPass, LateLintPass};\n use syntax::ast;\n use syntax::attr;\n use syntax::errors::Applicability;\n+use syntax::symbol::sym;\n use syntax_pos::{BytePos, symbol::Ident, Span};\n \n #[derive(PartialEq)]\n@@ -253,7 +254,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         let crate_ident = if let Some(name) = &cx.tcx.sess.opts.crate_name {\n             Some(Ident::from_str(name))\n         } else {\n-            attr::find_by_name(&cx.tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID), \"crate_name\")\n+            attr::find_by_name(&cx.tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID), sym::crate_name)\n                 .and_then(|attr| attr.meta())\n                 .and_then(|meta| {\n                     meta.name_value_literal().and_then(|lit| {\n@@ -315,7 +316,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n             }\n             FnKind::ItemFn(ident, _, header, _, attrs) => {\n                 // Skip foreign-ABI #[no_mangle] functions (Issue #31924)\n-                if header.abi != Abi::Rust && attr::contains_name(attrs, \"no_mangle\") {\n+                if header.abi != Abi::Rust && attr::contains_name(attrs, sym::no_mangle) {\n                     return;\n                 }\n                 self.check_snake_case(cx, \"function\", ident);\n@@ -390,7 +391,7 @@ impl NonUpperCaseGlobals {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         match it.node {\n-            hir::ItemKind::Static(..) if !attr::contains_name(&it.attrs, \"no_mangle\") => {\n+            hir::ItemKind::Static(..) if !attr::contains_name(&it.attrs, sym::no_mangle) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n             }\n             hir::ItemKind::Const(..) => {"}, {"sha": "38b6e2c197939769be2d3f3238bf2f9672b7df7c", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -62,7 +62,7 @@ impl TypeLimits {\n /// Returns `true` iff the lint was overridden.\n fn lint_overflowing_range_endpoint<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    lit: &ast::Lit,\n+    lit: &hir::Lit,\n     lit_val: u128,\n     max: u128,\n     expr: &'tcx hir::Expr,\n@@ -132,7 +132,7 @@ fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n     }\n }\n \n-fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &ast::Lit) -> Option<String> {\n+fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &hir::Lit) -> Option<String> {\n     let src = cx.sess().source_map().span_to_snippet(lit.span).ok()?;\n     let firstch = src.chars().next()?;\n \n@@ -249,7 +249,7 @@ fn lint_int_literal<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     type_limits: &TypeLimits,\n     e: &'tcx hir::Expr,\n-    lit: &ast::Lit,\n+    lit: &hir::Lit,\n     t: ast::IntTy,\n     v: u128,\n ) {\n@@ -301,7 +301,7 @@ fn lint_int_literal<'a, 'tcx>(\n fn lint_uint_literal<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     e: &'tcx hir::Expr,\n-    lit: &ast::Lit,\n+    lit: &hir::Lit,\n     t: ast::UintTy,\n ) {\n     let uint_type = if let ast::UintTy::Usize = t {\n@@ -363,7 +363,7 @@ fn lint_literal<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     type_limits: &TypeLimits,\n     e: &'tcx hir::Expr,\n-    lit: &ast::Lit,\n+    lit: &hir::Lit,\n ) {\n     match cx.tables.node_type(e.hir_id).sty {\n         ty::Int(t) => {"}, {"sha": "c3dfd44ad8572f46ebc4ebc67411296924d30c59", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -12,7 +12,7 @@ use syntax::attr;\n use syntax::errors::Applicability;\n use syntax::feature_gate::{AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use syntax::print::pprust;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::symbol::Symbol;\n use syntax::util::parser;\n use syntax_pos::Span;\n@@ -170,7 +170,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             descr_post_path: &str,\n         ) -> bool {\n             for attr in cx.tcx.get_attrs(def_id).iter() {\n-                if attr.check_name(\"must_use\") {\n+                if attr.check_name(sym::must_use) {\n                     let msg = format!(\"unused {}`{}`{} that must be used\",\n                         descr_pre_path, cx.tcx.def_path_str(def_id), descr_post_path);\n                     let mut err = cx.struct_span_lint(UNUSED_MUST_USE, sp, &msg);\n@@ -243,8 +243,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n         }\n \n         let plugin_attributes = cx.sess().plugin_attributes.borrow_mut();\n-        for &(ref name, ty) in plugin_attributes.iter() {\n-            if ty == AttributeType::Whitelisted && attr.check_name(&**name) {\n+        for &(name, ty) in plugin_attributes.iter() {\n+            if ty == AttributeType::Whitelisted && attr.check_name(name) {\n                 debug!(\"{:?} (plugin attr) is whitelisted with ty {:?}\", name, ty);\n                 break;\n             }\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n             // Has a plugin registered this attribute as one that must be used at\n             // the crate level?\n             let plugin_crate = plugin_attributes.iter()\n-                .find(|&&(ref x, t)| name == x.as_str() && AttributeType::CrateLevel == t)\n+                .find(|&&(x, t)| name == x && AttributeType::CrateLevel == t)\n                 .is_some();\n             if known_crate || plugin_crate {\n                 let msg = match attr.style {"}, {"sha": "a4c7daf088ff2c9e14e052bcd9cd21ffad50f64a", "filename": "src/librustc_macros/src/symbols.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -11,7 +11,7 @@ use quote::quote;\n #[allow(non_camel_case_types)]\n mod kw {\n     syn::custom_keyword!(Keywords);\n-    syn::custom_keyword!(Other);\n+    syn::custom_keyword!(Symbols);\n }\n \n struct Keyword {\n@@ -33,14 +33,24 @@ impl Parse for Keyword {\n     }\n }\n \n-struct Symbol(Ident);\n+struct Symbol {\n+    name: Ident,\n+    value: Option<LitStr>,\n+}\n \n impl Parse for Symbol {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        let ident: Ident = input.parse()?;\n+        let name = input.parse()?;\n+        let value = match input.parse::<Token![:]>() {\n+            Ok(_) => Some(input.parse()?),\n+            Err(_) => None,\n+        };\n         input.parse::<Token![,]>()?;\n \n-        Ok(Symbol(ident))\n+        Ok(Symbol {\n+            name,\n+            value,\n+        })\n     }\n }\n \n@@ -69,7 +79,7 @@ impl Parse for Input {\n         braced!(content in input);\n         let keywords = content.parse()?;\n \n-        input.parse::<kw::Other>()?;\n+        input.parse::<kw::Symbols>()?;\n         let content;\n         braced!(content in input);\n         let symbols = content.parse()?;\n@@ -116,19 +126,22 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n     }\n \n     for symbol in &input.symbols.0 {\n-        let value = &symbol.0;\n-        let value_str = value.to_string();\n-        check_dup(&value_str);\n+        let name = &symbol.name;\n+        let value = match &symbol.value {\n+            Some(value) => value.value(),\n+            None => name.to_string(),\n+        };\n+        check_dup(&value);\n         prefill_stream.extend(quote! {\n-            #value_str,\n+            #value,\n         });\n         symbols_stream.extend(quote! {\n-            pub const #value: Symbol = Symbol::new(#counter);\n+            pub const #name: Symbol = Symbol::new(#counter);\n         });\n         counter += 1;\n     }\n \n-    TokenStream::from(quote! {\n+    let tt = TokenStream::from(quote! {\n         macro_rules! keywords {\n             () => {\n                 #keyword_stream\n@@ -159,5 +172,11 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n                 ])\n             }\n         }\n-    })\n+    });\n+\n+    // To see the generated code generated, uncomment this line, recompile, and\n+    // run the resulting output through `rustfmt`.\n+    //eprintln!(\"{}\", tt);\n+\n+    tt\n }"}, {"sha": "3e00ba3c62004bf435cea8598604e15a7a274b55", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -27,7 +27,7 @@ use std::{cmp, fs};\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::visit;\n use syntax::{span_err, span_fatal};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -95,7 +95,7 @@ enum LoadError<'a> {\n impl<'a> LoadError<'a> {\n     fn report(self) -> ! {\n         match self {\n-            LoadError::LocatorError(mut locate_ctxt) => locate_ctxt.report_errs(),\n+            LoadError::LocatorError(locate_ctxt) => locate_ctxt.report_errs(),\n         }\n     }\n }\n@@ -365,8 +365,8 @@ impl<'a> CrateLoader<'a> {\n                 span,\n                 ident,\n                 crate_name: name,\n-                hash: hash.map(|a| &*a),\n-                extra_filename: extra_filename,\n+                hash,\n+                extra_filename,\n                 filesearch: self.sess.target_filesearch(path_kind),\n                 target: &self.sess.target.target,\n                 triple: self.sess.opts.target_triple.clone(),\n@@ -650,9 +650,8 @@ impl<'a> CrateLoader<'a> {\n     /// SVH and DefIndex of the registrar function.\n     pub fn find_plugin_registrar(&mut self,\n                                  span: Span,\n-                                 name: &str)\n+                                 name: Symbol)\n                                  -> Option<(PathBuf, CrateDisambiguator)> {\n-        let name = Symbol::intern(name);\n         let ekrate = self.read_extension_crate(span, name, name);\n \n         if ekrate.target_only {\n@@ -704,7 +703,7 @@ impl<'a> CrateLoader<'a> {\n         let desired_strategy = self.sess.panic_strategy();\n         let mut runtime_found = false;\n         let mut needs_panic_runtime = attr::contains_name(&krate.attrs,\n-                                                          \"needs_panic_runtime\");\n+                                                          sym::needs_panic_runtime);\n \n         self.cstore.iter_crate_data(|cnum, data| {\n             needs_panic_runtime = needs_panic_runtime ||\n@@ -837,7 +836,7 @@ impl<'a> CrateLoader<'a> {\n \n             let mut uses_std = false;\n             self.cstore.iter_crate_data(|_, data| {\n-                if data.name == \"std\" {\n+                if data.name == sym::std {\n                     uses_std = true;\n                 }\n             });\n@@ -898,7 +897,7 @@ impl<'a> CrateLoader<'a> {\n         // about through the `#![needs_allocator]` attribute and is typically\n         // written down in liballoc.\n         let mut needs_allocator = attr::contains_name(&krate.attrs,\n-                                                      \"needs_allocator\");\n+                                                      sym::needs_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n             needs_allocator = needs_allocator || data.root.needs_allocator;\n         });\n@@ -964,7 +963,7 @@ impl<'a> CrateLoader<'a> {\n         // allocator. At this point our allocator request is typically fulfilled\n         // by the standard library, denoted by the `#![default_lib_allocator]`\n         // attribute.\n-        let mut has_default = attr::contains_name(&krate.attrs, \"default_lib_allocator\");\n+        let mut has_default = attr::contains_name(&krate.attrs, sym::default_lib_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n             if data.root.has_default_lib_allocator {\n                 has_default = true;\n@@ -987,7 +986,7 @@ impl<'a> CrateLoader<'a> {\n \n             impl<'ast> visit::Visitor<'ast> for Finder {\n                 fn visit_item(&mut self, i: &'ast ast::Item) {\n-                    if attr::contains_name(&i.attrs, \"global_allocator\") {\n+                    if attr::contains_name(&i.attrs, sym::global_allocator) {\n                         self.0 = true;\n                     }\n                     visit::walk_item(self, i)\n@@ -1065,7 +1064,7 @@ impl<'a> CrateLoader<'a> {\n                     }\n                     None => item.ident.name,\n                 };\n-                let dep_kind = if attr::contains_name(&item.attrs, \"no_link\") {\n+                let dep_kind = if attr::contains_name(&item.attrs, sym::no_link) {\n                     DepKind::UnexportedMacrosOnly\n                 } else {\n                     DepKind::Explicit"}, {"sha": "087256a971056ba410d58fdf9fe7b357e277ae55", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -31,7 +31,7 @@ use syntax::source_map;\n use syntax::edition::Edition;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n@@ -432,7 +432,7 @@ impl cstore::CStore {\n         let data = self.get_crate_data(id.krate);\n         if let Some(ref proc_macros) = data.proc_macros {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n-        } else if data.name == \"proc_macro\" && data.item_name(id.index) == \"quote\" {\n+        } else if data.name == sym::proc_macro && data.item_name(id.index) == \"quote\" {\n             use syntax::ext::base::SyntaxExtension;\n             use syntax_ext::proc_macro_impl::BangProcMacro;\n "}, {"sha": "d882fe6f27ecc7a8f115306a43066b0a428cbb73", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -29,7 +29,7 @@ use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::source_map;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::{InternedString, sym};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::hygiene::Mark;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n@@ -264,7 +264,7 @@ impl<'a, 'tcx> SpecializedDecoder<DefId> for DecodeContext<'a, 'tcx> {\n impl<'a, 'tcx> SpecializedDecoder<DefIndex> for DecodeContext<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<DefIndex, Self::Error> {\n-        Ok(DefIndex::from_raw_u32(self.read_u32()?))\n+        Ok(DefIndex::from_u32(self.read_u32()?))\n     }\n }\n \n@@ -841,7 +841,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                 // for other constructors correct visibilities\n                                 // were already encoded in metadata.\n                                 let attrs = self.get_item_attrs(def_id.index, sess);\n-                                if attr::contains_name(&attrs, \"non_exhaustive\") {\n+                                if attr::contains_name(&attrs, sym::non_exhaustive) {\n                                     let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n                                     vis = ty::Visibility::Restricted(crate_def_id);\n                                 }"}, {"sha": "939aadcc9ec9bfeefd0b44d1fca11df5060d0298", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -33,7 +33,7 @@ use std::u32;\n use syntax::ast;\n use syntax::attr;\n use syntax::source_map::Spanned;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::{self, hygiene, FileName, SourceFile, Span};\n use log::{debug, trace};\n \n@@ -134,7 +134,7 @@ impl<'a, 'tcx> SpecializedEncoder<DefId> for EncodeContext<'a, 'tcx> {\n impl<'a, 'tcx> SpecializedEncoder<DefIndex> for EncodeContext<'a, 'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, def_index: &DefIndex) -> Result<(), Self::Error> {\n-        self.emit_u32(def_index.as_raw_u32())\n+        self.emit_u32(def_index.as_u32())\n     }\n }\n \n@@ -469,7 +469,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let attrs = tcx.hir().krate_attrs();\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n-        let has_default_lib_allocator = attr::contains_name(&attrs, \"default_lib_allocator\");\n+        let has_default_lib_allocator = attr::contains_name(&attrs, sym::default_lib_allocator);\n         let has_global_allocator = *tcx.sess.has_global_allocator.get();\n         let has_panic_handler = *tcx.sess.has_panic_handler.try_get().unwrap_or(&false);\n \n@@ -496,13 +496,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             } else {\n                 None\n             },\n-            compiler_builtins: attr::contains_name(&attrs, \"compiler_builtins\"),\n-            needs_allocator: attr::contains_name(&attrs, \"needs_allocator\"),\n-            needs_panic_runtime: attr::contains_name(&attrs, \"needs_panic_runtime\"),\n-            no_builtins: attr::contains_name(&attrs, \"no_builtins\"),\n-            panic_runtime: attr::contains_name(&attrs, \"panic_runtime\"),\n-            profiler_runtime: attr::contains_name(&attrs, \"profiler_runtime\"),\n-            sanitizer_runtime: attr::contains_name(&attrs, \"sanitizer_runtime\"),\n+            compiler_builtins: attr::contains_name(&attrs, sym::compiler_builtins),\n+            needs_allocator: attr::contains_name(&attrs, sym::needs_allocator),\n+            needs_panic_runtime: attr::contains_name(&attrs, sym::needs_panic_runtime),\n+            no_builtins: attr::contains_name(&attrs, sym::no_builtins),\n+            panic_runtime: attr::contains_name(&attrs, sym::panic_runtime),\n+            profiler_runtime: attr::contains_name(&attrs, sym::profiler_runtime),\n+            sanitizer_runtime: attr::contains_name(&attrs, sym::sanitizer_runtime),\n \n             crate_deps,\n             dylib_dependency_formats,"}, {"sha": "934e871559c79939010ffb30377007afc5b96ba6", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -93,7 +93,7 @@ impl Index {\n     pub fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry<'_>>) {\n         assert!(entry.position < (u32::MAX as usize));\n         let position = entry.position as u32;\n-        let array_index = item.as_array_index();\n+        let array_index = item.index();\n \n         let positions = &mut self.positions;\n         assert!(u32::read_from_bytes_at(positions, array_index) == u32::MAX,\n@@ -126,7 +126,7 @@ impl<'tcx> LazySeq<Index> {\n                def_index,\n                self.len);\n \n-        let position = u32::read_from_bytes_at(bytes, 1 + def_index.as_array_index());\n+        let position = u32::read_from_bytes_at(bytes, 1 + def_index.index());\n         if position == u32::MAX {\n             debug!(\"Index::lookup: position=u32::MAX\");\n             None"}, {"sha": "f4682465a659ae32bbaaba0dc4799ab9b6f5f3fa", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -2,6 +2,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n use rustc::ty::TyCtxt;\n use rustc_target::spec::abi::Abi;\n+use syntax::symbol::sym;\n \n pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<String> {\n     let mut collector = Collector {\n@@ -10,7 +11,7 @@ pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<String> {\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n     for attr in tcx.hir().krate().attrs.iter() {\n-        if attr.path == \"link_args\" {\n+        if attr.path == sym::link_args {\n             if let Some(linkarg) = attr.value_str() {\n                 collector.add_link_args(&linkarg.as_str());\n             }\n@@ -37,7 +38,7 @@ impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n         }\n \n         // First, add all of the custom #[link_args] attributes\n-        for m in it.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n+        for m in it.attrs.iter().filter(|a| a.check_name(sym::link_args)) {\n             if let Some(linkarg) = m.value_str() {\n                 self.add_link_args(&linkarg.as_str());\n             }"}, {"sha": "3832c8ee227de1208bab95dd5bf864d93ccc964f", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -225,7 +225,7 @@ use rustc::session::search_paths::PathKind;\n use rustc::util::nodemap::FxHashMap;\n \n use errors::DiagnosticBuilder;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::struct_span_err;\n use syntax_pos::Span;\n use rustc_target::spec::{Target, TargetTriple};\n@@ -321,7 +321,7 @@ impl<'a> Context<'a> {\n         }\n     }\n \n-    pub fn report_errs(&mut self) -> ! {\n+    pub fn report_errs(self) -> ! {\n         let add = match self.root {\n             &None => String::new(),\n             &Some(ref r) => format!(\" which `{}` depends on\", r.ident),\n@@ -408,7 +408,7 @@ impl<'a> Context<'a> {\n                                            self.ident,\n                                            add);\n \n-            if (self.ident == \"std\" || self.ident == \"core\")\n+            if (self.ident == sym::std || self.ident == sym::core)\n                 && self.triple != TargetTriple::from_triple(config::host_triple()) {\n                 err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n             }\n@@ -901,8 +901,7 @@ fn get_metadata_section_imp(target: &Target,\n             let mut inflated = Vec::new();\n             match DeflateDecoder::new(compressed_bytes).read_to_end(&mut inflated) {\n                 Ok(_) => {\n-                    let buf = unsafe { OwningRef::new_assert_stable_address(inflated) };\n-                    rustc_erase_owner!(buf.map_owner_box())\n+                    rustc_erase_owner!(OwningRef::new(inflated).map_owner_box())\n                 }\n                 Err(_) => {\n                     return Err(format!(\"failed to decompress metadata: {}\", filename.display()));"}, {"sha": "fee08f421549dc9811954d6af4ec85d84a282744", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -8,7 +8,7 @@ use rustc_target::spec::abi::Abi;\n use syntax::attr;\n use syntax::source_map::Span;\n use syntax::feature_gate::{self, GateIssue};\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::{span_err, struct_span_err};\n \n pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<NativeLibrary> {\n@@ -47,7 +47,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n         }\n \n         // Process all of the #[link(..)]-style arguments\n-        for m in it.attrs.iter().filter(|a| a.check_name(\"link\")) {\n+        for m in it.attrs.iter().filter(|a| a.check_name(sym::link)) {\n             let items = match m.meta_item_list() {\n                 Some(item) => item,\n                 None => continue,\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n             let mut kind_specified = false;\n \n             for item in items.iter() {\n-                if item.check_name(\"kind\") {\n+                if item.check_name(sym::kind) {\n                     kind_specified = true;\n                     let kind = match item.value_str() {\n                         Some(name) => name,\n@@ -81,9 +81,9 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n                             cstore::NativeUnknown\n                         }\n                     };\n-                } else if item.check_name(\"name\") {\n+                } else if item.check_name(sym::name) {\n                     lib.name = item.value_str();\n-                } else if item.check_name(\"cfg\") {\n+                } else if item.check_name(sym::cfg) {\n                     let cfg = match item.meta_item_list() {\n                         Some(list) => list,\n                         None => continue, // skip like historical compilers\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n                     } else {\n                         self.tcx.sess.span_err(cfg[0].span(), \"invalid argument for `cfg(..)`\");\n                     }\n-                } else if item.check_name(\"wasm_import_module\") {\n+                } else if item.check_name(sym::wasm_import_module) {\n                     match item.value_str() {\n                         Some(s) => lib.wasm_import_module = Some(s),\n                         None => {\n@@ -156,15 +156,15 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n         }\n         if lib.cfg.is_some() && !self.tcx.features().link_cfg {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n-                                           \"link_cfg\",\n+                                           sym::link_cfg,\n                                            span.unwrap(),\n                                            GateIssue::Language,\n                                            \"is feature gated\");\n         }\n         if lib.kind == cstore::NativeStaticNobundle &&\n            !self.tcx.features().static_nobundle {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n-                                           \"static_nobundle\",\n+                                           sym::static_nobundle,\n                                            span.unwrap_or_else(|| syntax_pos::DUMMY_SP),\n                                            GateIssue::Language,\n                                            \"kind=\\\"static-nobundle\\\" is feature gated\");\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n                 let any_duplicate = self.libs\n                     .iter()\n                     .filter_map(|lib| lib.name.as_ref())\n-                    .any(|n| n == name);\n+                    .any(|n| n.as_str() == *name);\n                 if new_name.is_empty() {\n                     self.tcx.sess.err(\n                         &format!(\"an empty renaming target was specified for library `{}`\",name));\n@@ -212,7 +212,7 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n             // can move them to the end of the list below.\n             let mut existing = self.libs.drain_filter(|lib| {\n                 if let Some(lib_name) = lib.name {\n-                    if lib_name == name as &str {\n+                    if lib_name.as_str() == *name {\n                         if let Some(k) = kind {\n                             lib.kind = k;\n                         }"}, {"sha": "1a1000f0bb41db9eaab73ab76d13ba7f562b213d", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -20,6 +20,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n use syntax::source_map::CompilerDesugaringKind;\n+use syntax::symbol::sym;\n \n use super::borrow_set::BorrowData;\n use super::{MirBorrowckCtxt};\n@@ -825,18 +826,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         let borrow_span = borrow_spans.var_or_use();\n         if let BorrowExplanation::MustBeValidFor {\n-            category: ConstraintCategory::Return,\n+            category,\n             span,\n             ref opt_place_desc,\n             from_closure: false,\n             ..\n         } = explanation {\n-            return self.report_cannot_return_reference_to_local(\n+            if let Some(diag) = self.try_report_cannot_return_reference_to_local(\n                 borrow,\n                 borrow_span,\n                 span,\n+                category,\n                 opt_place_desc.as_ref(),\n-            );\n+            ) {\n+                return diag;\n+            }\n         }\n \n         let mut err = self.infcx.tcx.path_does_not_live_long_enough(\n@@ -1014,17 +1018,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         if let BorrowExplanation::MustBeValidFor {\n-            category: ConstraintCategory::Return,\n+            category,\n             span,\n             from_closure: false,\n             ..\n         } = explanation {\n-            return self.report_cannot_return_reference_to_local(\n+            if let Some(diag) = self.try_report_cannot_return_reference_to_local(\n                 borrow,\n                 proper_span,\n                 span,\n+                category,\n                 None,\n-            );\n+            ) {\n+                return diag;\n+            }\n         }\n \n         let tcx = self.infcx.tcx;\n@@ -1063,15 +1070,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err\n     }\n \n-    fn report_cannot_return_reference_to_local(\n+    fn try_report_cannot_return_reference_to_local(\n         &self,\n         borrow: &BorrowData<'tcx>,\n         borrow_span: Span,\n         return_span: Span,\n+        category: ConstraintCategory,\n         opt_place_desc: Option<&String>,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> Option<DiagnosticBuilder<'cx>> {\n         let tcx = self.infcx.tcx;\n \n+        let return_kind = match category {\n+            ConstraintCategory::Return => \"return\",\n+            ConstraintCategory::Yield => \"yield\",\n+            _ => return None,\n+        };\n+\n         // FIXME use a better heuristic than Spans\n         let reference_desc = if return_span == self.mir.source_info(borrow.reserve_location).span {\n             \"reference to\"\n@@ -1109,7 +1123,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let local = if let Place::Base(PlaceBase::Local(local)) = *root_place {\n                 local\n             } else {\n-                bug!(\"report_cannot_return_reference_to_local: not a local\")\n+                bug!(\"try_report_cannot_return_reference_to_local: not a local\")\n             };\n             match self.mir.local_kind(local) {\n                 LocalKind::ReturnPointer | LocalKind::Temp => {\n@@ -1130,6 +1144,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         let mut err = tcx.cannot_return_reference_to_local(\n             return_span,\n+            return_kind,\n             reference_desc,\n             &place_desc,\n             Origin::Mir,\n@@ -1139,7 +1154,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             err.span_label(borrow_span, note);\n         }\n \n-        err\n+        Some(err)\n     }\n \n     fn report_escaping_closure_capture(\n@@ -1839,7 +1854,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })\n         ) = place {\n             let attrs = self.infcx.tcx.get_attrs(*def_id);\n-            let is_thread_local = attrs.iter().any(|attr| attr.check_name(\"thread_local\"));\n+            let is_thread_local = attrs.iter().any(|attr| attr.check_name(sym::thread_local));\n \n             debug!(\n                 \"is_place_thread_local: attrs={:?} is_thread_local={:?}\","}, {"sha": "35efc6195be39709d4bfcdd273afe53e07a838bc", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -310,9 +310,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             opt_place_desc,\n                         }\n                     } else {\n+                        debug!(\"explain_why_borrow_contains_point: \\\n+                                Could not generate a region name\");\n                         BorrowExplanation::Unexplained\n                     }\n                 } else {\n+                    debug!(\"explain_why_borrow_contains_point: \\\n+                            Could not generate an error region vid\");\n                     BorrowExplanation::Unexplained\n                 }\n             }"}, {"sha": "fa490c108c8965f647caaa8a6c7509834d45fc14", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -20,6 +20,7 @@ use std::io;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::str::FromStr;\n+use syntax::symbol::sym;\n \n use self::mir_util::PassWhere;\n use polonius_engine::{Algorithm, Output};\n@@ -280,7 +281,7 @@ fn dump_annotation<'a, 'gcx, 'tcx>(\n ) {\n     let tcx = infcx.tcx;\n     let base_def_id = tcx.closure_base_def_id(mir_def_id);\n-    if !tcx.has_attr(base_def_id, \"rustc_regions\") {\n+    if !tcx.has_attr(base_def_id, sym::rustc_regions) {\n         return;\n     }\n "}, {"sha": "4d8acd241acd893f17910c81d87d8b09d8b979b6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 72, "deletions": 12, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -12,7 +12,6 @@ use rustc::ty::subst::{SubstsRef, UnpackedKind};\n use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n use rustc::ty::print::RegionHighlightMode;\n use rustc_errors::DiagnosticBuilder;\n-use syntax::ast::Name;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n use syntax_pos::symbol::InternedString;\n@@ -34,6 +33,7 @@ crate enum RegionNameSource {\n     MatchedAdtAndSegment(Span),\n     AnonRegionFromUpvar(Span, String),\n     AnonRegionFromOutput(Span, String, String),\n+    AnonRegionFromYieldTy(Span, String),\n }\n \n impl RegionName {\n@@ -48,7 +48,8 @@ impl RegionName {\n             RegionNameSource::MatchedHirTy(..) |\n             RegionNameSource::MatchedAdtAndSegment(..) |\n             RegionNameSource::AnonRegionFromUpvar(..) |\n-            RegionNameSource::AnonRegionFromOutput(..) => false,\n+            RegionNameSource::AnonRegionFromOutput(..) |\n+            RegionNameSource::AnonRegionFromYieldTy(..) => false,\n         }\n     }\n \n@@ -58,8 +59,8 @@ impl RegionName {\n     }\n \n     #[allow(dead_code)]\n-    crate fn name(&self) -> &InternedString {\n-        &self.name\n+    crate fn name(&self) -> InternedString {\n+        self.name\n     }\n \n     crate fn highlight_region_name(\n@@ -105,6 +106,12 @@ impl RegionName {\n                     format!(\"return type{} is {}\", mir_description, type_name),\n                 );\n             },\n+            RegionNameSource::AnonRegionFromYieldTy(span, type_name) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\"yield type is {}\", type_name),\n+                );\n+            }\n             RegionNameSource::Static => {},\n         }\n     }\n@@ -170,6 +177,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 self.give_name_if_anonymous_region_appears_in_output(\n                     infcx, mir, mir_def_id, fr, counter,\n                 )\n+            })\n+            .or_else(|| {\n+                self.give_name_if_anonymous_region_appears_in_yield_ty(\n+                    infcx, mir, mir_def_id, fr, counter,\n+                )\n             });\n \n         debug!(\"give_region_a_name: gave name {:?}\", value);\n@@ -193,7 +205,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         match error_region {\n             ty::ReEarlyBound(ebr) => {\n                 if ebr.has_name() {\n-                    let span = self.get_named_span(tcx, error_region, &ebr.name);\n+                    let span = self.get_named_span(tcx, error_region, ebr.name);\n                     Some(RegionName {\n                         name: ebr.name,\n                         source: RegionNameSource::NamedEarlyBoundRegion(span)\n@@ -210,7 +222,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             ty::ReFree(free_region) => match free_region.bound_region {\n                 ty::BoundRegion::BrNamed(_, name) => {\n-                    let span = self.get_named_span(tcx, error_region, &name);\n+                    let span = self.get_named_span(tcx, error_region, name);\n                     Some(RegionName {\n                         name,\n                         source: RegionNameSource::NamedFreeRegion(span),\n@@ -293,7 +305,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         error_region: &RegionKind,\n-        name: &InternedString,\n+        name: InternedString,\n     ) -> Span {\n         let scope = error_region.free_region_binding_scope(tcx);\n         let node = tcx.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n@@ -676,10 +688,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             \"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\",\n             return_ty\n         );\n-        if !infcx\n-            .tcx\n-            .any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr)\n-        {\n+        if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n             return None;\n         }\n \n@@ -724,12 +733,63 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         })\n     }\n \n+    fn give_name_if_anonymous_region_appears_in_yield_ty(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n+        fr: RegionVid,\n+        counter: &mut usize,\n+    ) -> Option<RegionName> {\n+        // Note: generators from `async fn` yield `()`, so we don't have to\n+        // worry about them here.\n+        let yield_ty = self.universal_regions.yield_ty?;\n+        debug!(\n+            \"give_name_if_anonymous_region_appears_in_yield_ty: yield_ty = {:?}\",\n+            yield_ty,\n+        );\n+\n+        let tcx = infcx.tcx;\n+\n+        if !tcx.any_free_region_meets(&yield_ty, |r| r.to_region_vid() == fr) {\n+            return None;\n+        }\n+\n+        let mut highlight = RegionHighlightMode::default();\n+        highlight.highlighting_region_vid(fr, *counter);\n+        let type_name = infcx.extract_type_name(&yield_ty, Some(highlight));\n+\n+        let mir_node_id = tcx.hir().as_local_node_id(mir_def_id).expect(\"non-local mir\");\n+\n+        let yield_span = match tcx.hir().get(mir_node_id) {\n+            hir::Node::Expr(hir::Expr {\n+                node: hir::ExprKind::Closure(_, _, _, span, _),\n+                ..\n+            }) => (\n+                tcx.sess.source_map().end_point(*span)\n+            ),\n+            _ => mir.span,\n+        };\n+\n+        debug!(\n+            \"give_name_if_anonymous_region_appears_in_yield_ty: \\\n+             type_name = {:?}, yield_span = {:?}\",\n+            yield_span,\n+            type_name,\n+        );\n+\n+        Some(RegionName {\n+            name: self.synthesize_region_name(counter),\n+            source: RegionNameSource::AnonRegionFromYieldTy(yield_span, type_name),\n+        })\n+    }\n+\n     /// Creates a synthetic region named `'1`, incrementing the\n     /// counter.\n     fn synthesize_region_name(&self, counter: &mut usize) -> InternedString {\n         let c = *counter;\n         *counter += 1;\n \n-        Name::intern(&format!(\"'{:?}\", c)).as_interned_str()\n+        InternedString::intern(&format!(\"'{:?}\", c))\n     }\n }"}, {"sha": "5f444d4ceeb8895fe40bae33b69969bad3ac3942", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -192,7 +192,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             | ExprKind::Pointer { .. }\n             | ExprKind::Repeat { .. }\n             | ExprKind::Borrow { .. }\n-            | ExprKind::If { .. }\n             | ExprKind::Match { .. }\n             | ExprKind::Loop { .. }\n             | ExprKind::Block { .. }"}, {"sha": "fbc4835a6557b4e2a7b34f744286a8c2c424fd72", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -345,7 +345,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Literal { .. }\n             | ExprKind::Block { .. }\n             | ExprKind::Match { .. }\n-            | ExprKind::If { .. }\n             | ExprKind::NeverToAny { .. }\n             | ExprKind::Use { .. }\n             | ExprKind::Loop { .. }"}, {"sha": "222ce6d1c968eaaf716c5bc2b3543a8539b76f9d", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -45,7 +45,6 @@ impl Category {\n             | ExprKind::ValueTypeAscription { .. } => Some(Category::Place),\n \n             ExprKind::LogicalOp { .. }\n-            | ExprKind::If { .. }\n             | ExprKind::Match { .. }\n             | ExprKind::NeverToAny { .. }\n             | ExprKind::Use { .. }"}, {"sha": "15795a64e3b7dcea2703280b12c3fc6024ff40dc", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -76,43 +76,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     end_block.unit()\n                 }\n             }\n-            ExprKind::If {\n-                condition: cond_expr,\n-                then: then_expr,\n-                otherwise: else_expr,\n-            } => {\n-                let operand = unpack!(block = this.as_local_operand(block, cond_expr));\n-\n-                let mut then_block = this.cfg.start_new_block();\n-                let mut else_block = this.cfg.start_new_block();\n-                let term = TerminatorKind::if_(this.hir.tcx(), operand, then_block, else_block);\n-                this.cfg.terminate(block, source_info, term);\n-\n-                unpack!(then_block = this.into(destination, then_block, then_expr));\n-                else_block = if let Some(else_expr) = else_expr {\n-                    unpack!(this.into(destination, else_block, else_expr))\n-                } else {\n-                    // Body of the `if` expression without an `else` clause must return `()`, thus\n-                    // we implicitly generate a `else {}` if it is not specified.\n-                    this.cfg\n-                        .push_assign_unit(else_block, source_info, destination);\n-                    else_block\n-                };\n-\n-                let join_block = this.cfg.start_new_block();\n-                this.cfg.terminate(\n-                    then_block,\n-                    source_info,\n-                    TerminatorKind::Goto { target: join_block },\n-                );\n-                this.cfg.terminate(\n-                    else_block,\n-                    source_info,\n-                    TerminatorKind::Goto { target: join_block },\n-                );\n-\n-                join_block.unit()\n-            }\n             ExprKind::LogicalOp { op, lhs, rhs } => {\n                 // And:\n                 //"}, {"sha": "a9d23a0afeabcc3a6ef79a0fd9ddd1ccea0ac1ad", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,4 +1,5 @@\n use syntax::ast::{self, MetaItem};\n+use syntax::symbol::{Symbol, sym};\n \n use rustc_data_structures::bit_set::{BitSet, BitSetOperator, HybridBitSet};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -100,9 +101,9 @@ where\n     fn propagate(&mut self) { self.flow_state.propagate(); }\n }\n \n-pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<MetaItem> {\n+pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Option<MetaItem> {\n     for attr in attrs {\n-        if attr.check_name(\"rustc_mir\") {\n+        if attr.check_name(sym::rustc_mir) {\n             let items = attr.meta_item_list();\n             for item in items.iter().flat_map(|l| l.iter()) {\n                 match item.meta_item() {\n@@ -158,10 +159,8 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitD\n             return None;\n         };\n \n-        let print_preflow_to =\n-            name_found(tcx.sess, attributes, \"borrowck_graphviz_preflow\");\n-        let print_postflow_to =\n-            name_found(tcx.sess, attributes, \"borrowck_graphviz_postflow\");\n+        let print_preflow_to = name_found(tcx.sess, attributes, sym::borrowck_graphviz_preflow);\n+        let print_postflow_to = name_found(tcx.sess, attributes, sym::borrowck_graphviz_postflow);\n \n         let mut mbcx = DataflowBuilder {\n             def_id,"}, {"sha": "50140880a368df329bdbf08b35f3cb833cffb9a4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -601,13 +601,6 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n             }\n         }\n-        hir::ExprKind::If(ref cond, ref then, ref otherwise) => {\n-            ExprKind::If {\n-                condition: cond.to_ref(),\n-                then: then.to_ref(),\n-                otherwise: otherwise.to_ref(),\n-            }\n-        }\n         hir::ExprKind::While(ref cond, ref body, _) => {\n             ExprKind::Loop {\n                 condition: Some(cond.to_ref()),"}, {"sha": "e8070b21bb8c7d9e0350fc244b391ca9439dae6a", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::subst::{Kind, InternalSubsts};\n use rustc::ty::layout::VariantIdx;\n use syntax::ast;\n use syntax::attr;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use rustc::hir;\n use crate::hair::constant::{lit_to_const, LitToConstError};\n \n@@ -67,7 +67,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n         // the settings for the crate they are codegened in.\n-        let mut check_overflow = attr::contains_name(attrs, \"rustc_inherit_overflow_checks\");\n+        let mut check_overflow = attr::contains_name(attrs, sym::rustc_inherit_overflow_checks);\n \n         // Respect -C overflow-checks.\n         check_overflow |= tcx.sess.overflow_checks();"}, {"sha": "d4f139e103a641a12d665f0e8cf05ec2e96f0255", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -185,11 +185,6 @@ pub enum ExprKind<'tcx> {\n         cast: PointerCast,\n         source: ExprRef<'tcx>,\n     },\n-    If {\n-        condition: ExprRef<'tcx>,\n-        then: ExprRef<'tcx>,\n-        otherwise: Option<ExprRef<'tcx>>,\n-    },\n     Loop {\n         condition: Option<ExprRef<'tcx>>,\n         body: ExprRef<'tcx>,"}, {"sha": "fd4416fc2b7632acfd07a8efc5d50dc3cf108c19", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -388,6 +388,18 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn is_non_exhaustive_variant<'p>(&self, pattern: &'p Pattern<'tcx>) -> bool\n+        where 'a: 'p\n+    {\n+        match *pattern.kind {\n+            PatternKind::Variant { adt_def, variant_index, .. } => {\n+                let ref variant = adt_def.variants[variant_index];\n+                variant.is_field_list_non_exhaustive()\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::Adt(adt_def, ..) => adt_def.is_variant_list_non_exhaustive(),\n@@ -1097,10 +1109,17 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v[0]);\n \n     if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n-        debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n-        split_grouped_constructors(cx.tcx, constructors, matrix, pcx.ty).into_iter().map(|c|\n-            is_useful_specialized(cx, matrix, v, c, pcx.ty, witness)\n-        ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n+        let is_declared_nonexhaustive = cx.is_non_exhaustive_variant(v[0]) && !cx.is_local(pcx.ty);\n+        debug!(\"is_useful - expanding constructors: {:#?}, is_declared_nonexhaustive: {:?}\",\n+               constructors, is_declared_nonexhaustive);\n+\n+        if is_declared_nonexhaustive {\n+            Useful\n+        } else {\n+            split_grouped_constructors(cx.tcx, constructors, matrix, pcx.ty).into_iter().map(|c|\n+                is_useful_specialized(cx, matrix, v, c, pcx.ty, witness)\n+            ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n+        }\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n "}, {"sha": "a1b2e6461e5ba24c2f4cf9c86a0161cc0fc94838", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -208,7 +208,11 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                                     .map(|variant| variant.ident)\n                                     .collect();\n                             }\n-                            def.variants.is_empty()\n+\n+                            let is_non_exhaustive_and_non_local =\n+                                def.is_variant_list_non_exhaustive() && !def.did.is_local();\n+\n+                            !(is_non_exhaustive_and_non_local) && def.variants.is_empty()\n                         },\n                         _ => false\n                     }\n@@ -365,6 +369,7 @@ fn check_arms<'a, 'tcx>(\n             match is_useful(cx, &seen, &v, LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n+                        hir::MatchSource::IfDesugar { .. } => bug!(),\n                         hir::MatchSource::IfLetDesugar { .. } => {\n                             cx.tcx.lint_hir(\n                                 lint::builtin::IRREFUTABLE_LET_PATTERNS,"}, {"sha": "0576bb53d8f4219268ff2e1eb02dd97abe500723", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -27,6 +27,7 @@ use std::cmp::Ordering;\n use std::fmt;\n use syntax::ast;\n use syntax::ptr::P;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n #[derive(Clone, Debug)]\n@@ -978,7 +979,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n                 PatternKind::Wild\n             }\n-            ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n+            ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n                 let path = self.tcx.def_path_str(adt_def.did);\n                 let msg = format!(\n                     \"to use a constant of type `{}` in a pattern, \\\n@@ -990,7 +991,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 PatternKind::Wild\n             }\n             ty::Ref(_, ty::TyS { sty: ty::Adt(adt_def, _), .. }, _)\n-            if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n+            if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n                 // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n                 // would be wrong. Returnging `PatternKind::Wild` is not technically correct.\n                 let path = self.tcx.def_path_str(adt_def.did);"}, {"sha": "2512525b4bb7e56ffff5caf4384f65870625d77d", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -2,6 +2,7 @@ use rustc::ty::{self, Ty, TypeAndMut};\n use rustc::ty::layout::{self, TyLayout, Size};\n use rustc::ty::adjustment::{PointerCast};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n+use syntax::symbol::sym;\n \n use rustc_apfloat::ieee::{Single, Double};\n use rustc::mir::interpret::{\n@@ -76,9 +77,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.sty {\n                     ty::FnDef(def_id, substs) => {\n-                        if self.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n-                            bug!(\"reifying a fn ptr that requires \\\n-                                    const arguments\");\n+                        if self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n+                            bug!(\"reifying a fn ptr that requires const arguments\");\n                         }\n                         let instance: EvalResult<'tcx, _> = ty::Instance::resolve(\n                             *self.tcx,"}, {"sha": "d4c1e5416d565c50232d271ac1ec800c2c899f3b", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -613,7 +613,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         trace!(\"{:?} is now live\", local);\n \n         let local_val = LocalValue::Uninitialized;\n-        // StorageLive *always* kills the value that's currently stored\n+        // StorageLive *always* kills the value that's currently stored.\n+        // However, we do not error if the variable already is live;\n+        // see <https://github.com/rust-lang/rust/issues/42371>.\n         Ok(mem::replace(&mut self.frame_mut().locals[local].value, local_val))\n     }\n "}, {"sha": "6b40245d39a8eae5fb7c094cb85f3d8bd0d122d0", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -10,7 +10,7 @@ use syntax::attr::InlineAttr;\n use std::fmt::{self, Write};\n use std::iter;\n use rustc::mir::mono::Linkage;\n-use syntax_pos::symbol::Symbol;\n+use syntax_pos::symbol::InternedString;\n use syntax::source_map::Span;\n pub use rustc::mir::mono::MonoItem;\n \n@@ -61,7 +61,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n             MonoItem::GlobalAsm(hir_id) => {\n                 let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n                 ty::SymbolName {\n-                    name: Symbol::intern(&format!(\"global_asm_{:?}\", def_id)).as_interned_str()\n+                    name: InternedString::intern(&format!(\"global_asm_{:?}\", def_id))\n                 }\n             }\n         }"}, {"sha": "394d1f06029cb6459f2e579b50d770d9dddbd32a", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -12,7 +12,7 @@ use rustc::lint::builtin::{SAFE_EXTERN_STATICS, SAFE_PACKED_BORROWS, UNUSED_UNSA\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext};\n \n-use syntax::symbol::Symbol;\n+use syntax::symbol::{InternedString, sym};\n \n use std::ops::Bound;\n \n@@ -167,9 +167,9 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     (CastTy::FnPtr, CastTy::Int(_)) => {\n                         self.register_violations(&[UnsafetyViolation {\n                             source_info: self.source_info,\n-                            description: Symbol::intern(\"cast of pointer to int\").as_interned_str(),\n-                            details: Symbol::intern(\"casting pointers to integers in constants\")\n-                                     .as_interned_str(),\n+                            description: InternedString::intern(\"cast of pointer to int\"),\n+                            details: InternedString::intern(\n+                                \"casting pointers to integers in constants\"),\n                             kind: UnsafetyViolationKind::General,\n                         }], &[]);\n                     },\n@@ -185,9 +185,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.mir, self.tcx).sty {\n                     self.register_violations(&[UnsafetyViolation {\n                         source_info: self.source_info,\n-                        description: Symbol::intern(\"pointer operation\").as_interned_str(),\n-                        details: Symbol::intern(\"operations on pointers in constants\")\n-                                 .as_interned_str(),\n+                        description: InternedString::intern(\"pointer operation\"),\n+                        details: InternedString::intern(\"operations on pointers in constants\"),\n                         kind: UnsafetyViolationKind::General,\n                     }], &[]);\n                 }\n@@ -212,13 +211,11 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                             self.source_scope_local_data[source_info.scope].lint_root;\n                         self.register_violations(&[UnsafetyViolation {\n                             source_info,\n-                            description: Symbol::intern(\"borrow of packed field\").as_interned_str(),\n-                            details:\n-                                Symbol::intern(\"fields of packed structs might be misaligned: \\\n-                                                dereferencing a misaligned pointer or even just \\\n-                                                creating a misaligned reference is undefined \\\n-                                                behavior\")\n-                                    .as_interned_str(),\n+                            description: InternedString::intern(\"borrow of packed field\"),\n+                            details: InternedString::intern(\n+                                \"fields of packed structs might be misaligned: dereferencing a \\\n+                                misaligned pointer or even just creating a misaligned reference \\\n+                                is undefined behavior\"),\n                             kind: UnsafetyViolationKind::BorrowPacked(lint_root)\n                         }], &[]);\n                     }\n@@ -315,12 +312,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         self.source_scope_local_data[source_info.scope].lint_root;\n                     self.register_violations(&[UnsafetyViolation {\n                         source_info,\n-                        description: Symbol::intern(\"use of extern static\").as_interned_str(),\n-                        details:\n-                            Symbol::intern(\"extern statics are not controlled by the Rust type \\\n-                                            system: invalid data, aliasing violations or data \\\n-                                            races will cause undefined behavior\")\n-                                .as_interned_str(),\n+                        description: InternedString::intern(\"use of extern static\"),\n+                        details: InternedString::intern(\n+                            \"extern statics are not controlled by the Rust type system: invalid \\\n+                            data, aliasing violations or data races will cause undefined behavior\"),\n                         kind: UnsafetyViolationKind::ExternStatic(lint_root)\n                     }], &[]);\n                 }\n@@ -340,8 +335,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         let source_info = self.source_info;\n         self.register_violations(&[UnsafetyViolation {\n             source_info,\n-            description: Symbol::intern(description).as_interned_str(),\n-            details: Symbol::intern(details).as_interned_str(),\n+            description: InternedString::intern(description),\n+            details: InternedString::intern(details),\n             kind,\n         }], &[]);\n     }\n@@ -441,8 +436,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                                 let source_info = self.source_info;\n                                 self.register_violations(&[UnsafetyViolation {\n                                     source_info,\n-                                    description: Symbol::intern(description).as_interned_str(),\n-                                    details: Symbol::intern(details).as_interned_str(),\n+                                    description: InternedString::intern(description),\n+                                    details: InternedString::intern(details),\n                                     kind: UnsafetyViolationKind::GeneralAndConstFn,\n                                 }], &[]);\n                             }\n@@ -612,7 +607,7 @@ fn report_unused_unsafe(tcx: TyCtxt<'_, '_, '_>,\n fn builtin_derive_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n     debug!(\"builtin_derive_def_id({:?})\", def_id);\n     if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n-        if tcx.has_attr(impl_def_id, \"automatically_derived\") {\n+        if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n             debug!(\"builtin_derive_def_id({:?}) - is {:?}\", def_id, impl_def_id);\n             Some(impl_def_id)\n         } else {"}, {"sha": "8f3dd72c4f2450a82ca151b53d8ebbe9128b72d6", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 169, "deletions": 75, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -3,23 +3,25 @@\n \n use rustc::hir::def::DefKind;\n use rustc::mir::{\n-    Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local,\n+    AggregateKind, Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local,\n     NullOp, UnOp, StatementKind, Statement, LocalKind, Static, StaticKind,\n     TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo, BinOp, ProjectionElem,\n     SourceScope, SourceScopeLocalData, LocalDecl, Promoted,\n };\n-use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n+use rustc::mir::visit::{\n+    Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n+};\n use rustc::mir::interpret::{InterpError, Scalar, GlobalId, EvalResult};\n use rustc::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n-use syntax::source_map::DUMMY_SP;\n+use syntax_pos::{Span, DUMMY_SP};\n use rustc::ty::subst::InternalSubsts;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::ty::layout::{\n     LayoutOf, TyLayout, LayoutError,\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n-use crate::interpret::{InterpretCx, ScalarMaybeUndef, Immediate, OpTy, ImmTy, MemoryKind};\n+use crate::interpret::{self, InterpretCx, ScalarMaybeUndef, Immediate, OpTy, ImmTy, MemoryKind};\n use crate::const_eval::{\n     CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_eval_cx,\n };\n@@ -497,6 +499,57 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             },\n         }\n     }\n+\n+    fn operand_from_scalar(&self, scalar: Scalar, ty: Ty<'tcx>, span: Span) -> Operand<'tcx> {\n+        Operand::Constant(Box::new(\n+            Constant {\n+                span,\n+                ty,\n+                user_ty: None,\n+                literal: self.tcx.mk_const(ty::Const::from_scalar(\n+                    scalar,\n+                    ty,\n+                ))\n+            }\n+        ))\n+    }\n+\n+    fn replace_with_const(&self, rval: &mut Rvalue<'tcx>, value: Const<'tcx>, span: Span) {\n+        self.ecx.validate_operand(\n+            value,\n+            vec![],\n+            None,\n+            true,\n+        ).expect(\"value should already be a valid const\");\n+\n+        if let interpret::Operand::Immediate(im) = *value {\n+            match im {\n+                interpret::Immediate::Scalar(ScalarMaybeUndef::Scalar(scalar)) => {\n+                    *rval = Rvalue::Use(self.operand_from_scalar(scalar, value.layout.ty, span));\n+                },\n+                Immediate::ScalarPair(\n+                    ScalarMaybeUndef::Scalar(one),\n+                    ScalarMaybeUndef::Scalar(two)\n+                ) => {\n+                    let ty = &value.layout.ty.sty;\n+                    if let ty::Tuple(substs) = ty {\n+                        *rval = Rvalue::Aggregate(\n+                            Box::new(AggregateKind::Tuple),\n+                            vec![\n+                                self.operand_from_scalar(one, substs[0].expect_ty(), span),\n+                                self.operand_from_scalar(two, substs[1].expect_ty(), span),\n+                            ],\n+                        );\n+                    }\n+                },\n+                _ => { }\n+            }\n+        }\n+    }\n+\n+    fn should_const_prop(&self) -> bool {\n+        self.tcx.sess.opts.debugging_opts.mir_opt_level >= 2\n+    }\n }\n \n fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -560,10 +613,10 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n     }\n }\n \n-impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n+impl<'b, 'a, 'tcx> MutVisitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n     fn visit_constant(\n         &mut self,\n-        constant: &Constant<'tcx>,\n+        constant: &mut Constant<'tcx>,\n         location: Location,\n     ) {\n         trace!(\"visit_constant: {:?}\", constant);\n@@ -573,11 +626,11 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n \n     fn visit_statement(\n         &mut self,\n-        statement: &Statement<'tcx>,\n+        statement: &mut Statement<'tcx>,\n         location: Location,\n     ) {\n         trace!(\"visit_statement: {:?}\", statement);\n-        if let StatementKind::Assign(ref place, ref rval) = statement.kind {\n+        if let StatementKind::Assign(ref place, ref mut rval) = statement.kind {\n             let place_ty: Ty<'tcx> = place\n                 .ty(&self.local_decls, self.tcx)\n                 .ty;\n@@ -589,6 +642,10 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             trace!(\"storing {:?} to {:?}\", value, local);\n                             assert!(self.places[local].is_none());\n                             self.places[local] = Some(value);\n+\n+                            if self.should_const_prop() {\n+                                self.replace_with_const(rval, value, statement.source_info.span);\n+                            }\n                         }\n                     }\n                 }\n@@ -599,79 +656,116 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n \n     fn visit_terminator(\n         &mut self,\n-        terminator: &Terminator<'tcx>,\n+        terminator: &mut Terminator<'tcx>,\n         location: Location,\n     ) {\n         self.super_terminator(terminator, location);\n-        let source_info = terminator.source_info;;\n-        if let TerminatorKind::Assert { expected, msg, cond, .. } = &terminator.kind {\n-            if let Some(value) = self.eval_operand(&cond, source_info) {\n-                trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                let expected = ScalarMaybeUndef::from(Scalar::from_bool(*expected));\n-                if expected != self.ecx.read_scalar(value).unwrap() {\n-                    // poison all places this operand references so that further code\n-                    // doesn't use the invalid value\n-                    match cond {\n-                        Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                            let mut place = place;\n-                            while let Place::Projection(ref proj) = *place {\n-                                place = &proj.base;\n-                            }\n-                            if let Place::Base(PlaceBase::Local(local)) = *place {\n-                                self.places[local] = None;\n+        let source_info = terminator.source_info;\n+        match &mut terminator.kind {\n+            TerminatorKind::Assert { expected, msg, ref mut cond, .. } => {\n+                if let Some(value) = self.eval_operand(&cond, source_info) {\n+                    trace!(\"assertion on {:?} should be {:?}\", value, expected);\n+                    let expected = ScalarMaybeUndef::from(Scalar::from_bool(*expected));\n+                    let value_const = self.ecx.read_scalar(value).unwrap();\n+                    if expected != value_const {\n+                        // poison all places this operand references so that further code\n+                        // doesn't use the invalid value\n+                        match cond {\n+                            Operand::Move(ref place) | Operand::Copy(ref place) => {\n+                                let mut place = place;\n+                                while let Place::Projection(ref proj) = *place {\n+                                    place = &proj.base;\n+                                }\n+                                if let Place::Base(PlaceBase::Local(local)) = *place {\n+                                    self.places[local] = None;\n+                                }\n+                            },\n+                            Operand::Constant(_) => {}\n+                        }\n+                        let span = terminator.source_info.span;\n+                        let hir_id = self\n+                            .tcx\n+                            .hir()\n+                            .as_local_hir_id(self.source.def_id())\n+                            .expect(\"some part of a failing const eval must be local\");\n+                        use rustc::mir::interpret::InterpError::*;\n+                        let msg = match msg {\n+                            Overflow(_) |\n+                            OverflowNeg |\n+                            DivisionByZero |\n+                            RemainderByZero => msg.description().to_owned(),\n+                            BoundsCheck { ref len, ref index } => {\n+                                let len = self\n+                                    .eval_operand(len, source_info)\n+                                    .expect(\"len must be const\");\n+                                let len = match self.ecx.read_scalar(len) {\n+                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                                        bits, ..\n+                                    })) => bits,\n+                                    other => bug!(\"const len not primitive: {:?}\", other),\n+                                };\n+                                let index = self\n+                                    .eval_operand(index, source_info)\n+                                    .expect(\"index must be const\");\n+                                let index = match self.ecx.read_scalar(index) {\n+                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                                        bits, ..\n+                                    })) => bits,\n+                                    other => bug!(\"const index not primitive: {:?}\", other),\n+                                };\n+                                format!(\n+                                    \"index out of bounds: \\\n+                                    the len is {} but the index is {}\",\n+                                    len,\n+                                    index,\n+                                )\n+                            },\n+                            // Need proper const propagator for these\n+                            _ => return,\n+                        };\n+                        self.tcx.lint_hir(\n+                            ::rustc::lint::builtin::CONST_ERR,\n+                            hir_id,\n+                            span,\n+                            &msg,\n+                        );\n+                    } else {\n+                        if self.should_const_prop() {\n+                            if let ScalarMaybeUndef::Scalar(scalar) = value_const {\n+                                *cond = self.operand_from_scalar(\n+                                    scalar,\n+                                    self.tcx.types.bool,\n+                                    source_info.span,\n+                                );\n                             }\n-                        },\n-                        Operand::Constant(_) => {}\n+                        }\n                     }\n-                    let span = terminator.source_info.span;\n-                    let hir_id = self\n-                        .tcx\n-                        .hir()\n-                        .as_local_hir_id(self.source.def_id())\n-                        .expect(\"some part of a failing const eval must be local\");\n-                    use rustc::mir::interpret::InterpError::*;\n-                    let msg = match msg {\n-                        Overflow(_) |\n-                        OverflowNeg |\n-                        DivisionByZero |\n-                        RemainderByZero => msg.description().to_owned(),\n-                        BoundsCheck { ref len, ref index } => {\n-                            let len = self\n-                                .eval_operand(len, source_info)\n-                                .expect(\"len must be const\");\n-                            let len = match self.ecx.read_scalar(len) {\n-                                Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-                                    bits, ..\n-                                })) => bits,\n-                                other => bug!(\"const len not primitive: {:?}\", other),\n-                            };\n-                            let index = self\n-                                .eval_operand(index, source_info)\n-                                .expect(\"index must be const\");\n-                            let index = match self.ecx.read_scalar(index) {\n-                                Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-                                    bits, ..\n-                                })) => bits,\n-                                other => bug!(\"const index not primitive: {:?}\", other),\n-                            };\n-                            format!(\n-                                \"index out of bounds: \\\n-                                the len is {} but the index is {}\",\n-                                len,\n-                                index,\n-                            )\n-                        },\n-                        // Need proper const propagator for these\n-                        _ => return,\n-                    };\n-                    self.tcx.lint_hir(\n-                        ::rustc::lint::builtin::CONST_ERR,\n-                        hir_id,\n-                        span,\n-                        &msg,\n-                    );\n                 }\n-            }\n+            },\n+            TerminatorKind::SwitchInt { ref mut discr, switch_ty, .. } => {\n+                if self.should_const_prop() {\n+                    if let Some(value) = self.eval_operand(&discr, source_info) {\n+                        if let ScalarMaybeUndef::Scalar(scalar) =\n+                                self.ecx.read_scalar(value).unwrap() {\n+                            *discr = self.operand_from_scalar(scalar, switch_ty, source_info.span);\n+                        }\n+                    }\n+                }\n+            },\n+            //none of these have Operands to const-propagate\n+            TerminatorKind::Goto { .. } |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Abort |\n+            TerminatorKind::Return |\n+            TerminatorKind::Unreachable |\n+            TerminatorKind::Drop { .. } |\n+            TerminatorKind::DropAndReplace { .. } |\n+            TerminatorKind::Yield { .. } |\n+            TerminatorKind::GeneratorDrop |\n+            TerminatorKind::FalseEdges { .. } |\n+            TerminatorKind::FalseUnwind { .. } => { }\n+            //FIXME(wesleywiser) Call does have Operands that could be const-propagated\n+            TerminatorKind::Call { .. } => { }\n         }\n     }\n }"}, {"sha": "579f75ba516571a9ece7da2a60285c10efd77191", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -22,6 +22,7 @@ use rustc::middle::lang_items;\n use rustc::session::config::nightly_options;\n use syntax::ast::LitKind;\n use syntax::feature_gate::{emit_feature_err, GateIssue};\n+use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::fmt;\n@@ -380,8 +381,8 @@ impl Qualif for IsNotPromotable {\n \n                 !allowed ||\n                     cx.tcx.get_attrs(def_id).iter().any(\n-                        |attr| attr.check_name(\"thread_local\"\n-                    ))\n+                        |attr| attr.check_name(sym::thread_local)\n+                    )\n             }\n         }\n     }\n@@ -939,7 +940,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 if self.tcx\n                        .get_attrs(def_id)\n                        .iter()\n-                       .any(|attr| attr.check_name(\"thread_local\")) {\n+                       .any(|attr| attr.check_name(sym::thread_local)) {\n                     if self.mode != Mode::Fn {\n                         span_err!(self.tcx.sess, self.span, E0625,\n                                   \"thread-local statics cannot be \\\n@@ -994,7 +995,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                 if let ty::RawPtr(_) = base_ty.sty {\n                                     if !self.tcx.features().const_raw_ptr_deref {\n                                         emit_feature_err(\n-                                            &self.tcx.sess.parse_sess, \"const_raw_ptr_deref\",\n+                                            &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n                                             self.span, GateIssue::Language,\n                                             &format!(\n                                                 \"dereferencing raw pointers in {}s is unstable\",\n@@ -1018,7 +1019,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     Mode::ConstFn => {\n                                         if !self.tcx.features().const_fn_union {\n                                             emit_feature_err(\n-                                                &self.tcx.sess.parse_sess, \"const_fn_union\",\n+                                                &self.tcx.sess.parse_sess, sym::const_fn_union,\n                                                 self.span, GateIssue::Language,\n                                                 \"unions in const fn are unstable\",\n                                             );\n@@ -1123,7 +1124,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                             // in const fn and constants require the feature gate\n                             // FIXME: make it unsafe inside const fn and constants\n                             emit_feature_err(\n-                                &self.tcx.sess.parse_sess, \"const_raw_ptr_to_usize_cast\",\n+                                &self.tcx.sess.parse_sess, sym::const_raw_ptr_to_usize_cast,\n                                 self.span, GateIssue::Language,\n                                 &format!(\n                                     \"casting pointers to integers in {}s is unstable\",\n@@ -1149,7 +1150,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         // FIXME: make it unsafe to use these operations\n                         emit_feature_err(\n                             &self.tcx.sess.parse_sess,\n-                            \"const_compare_raw_pointers\",\n+                            sym::const_compare_raw_pointers,\n                             self.span,\n                             GateIssue::Language,\n                             &format!(\"comparing raw pointers inside {}\", self.mode),\n@@ -1210,7 +1211,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                         // const eval transmute calls only with the feature gate\n                                         if !self.tcx.features().const_transmute {\n                                             emit_feature_err(\n-                                                &self.tcx.sess.parse_sess, \"const_transmute\",\n+                                                &self.tcx.sess.parse_sess, sym::const_transmute,\n                                                 self.span, GateIssue::Language,\n                                                 &format!(\"The use of std::mem::transmute() \\\n                                                 is gated in {}s\", self.mode));\n@@ -1249,7 +1250,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                         // Don't allow panics in constants without the feature gate.\n                                         emit_feature_err(\n                                             &self.tcx.sess.parse_sess,\n-                                            \"const_panic\",\n+                                            sym::const_panic,\n                                             self.span,\n                                             GateIssue::Language,\n                                             &format!(\"panicking in {}s is unstable\", self.mode),\n@@ -1260,7 +1261,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     // Check `#[unstable]` const fns or `#[rustc_const_unstable]`\n                                     // functions without the feature gate active in this crate in\n                                     // order to report a better error message than the one below.\n-                                    if !self.span.allows_unstable(&feature.as_str()) {\n+                                    if !self.span.allows_unstable(feature) {\n                                         let mut err = self.tcx.sess.struct_span_err(self.span,\n                                             &format!(\"`{}` is not yet stable as a const fn\",\n                                                     self.tcx.def_path_str(def_id)));\n@@ -1592,7 +1593,7 @@ impl MirPass for QualifyAndPromoteConstants {\n         if mode == Mode::Static {\n             // `#[thread_local]` statics don't have to be `Sync`.\n             for attr in &tcx.get_attrs(def_id)[..] {\n-                if attr.check_name(\"thread_local\") {\n+                if attr.check_name(sym::thread_local) {\n                     return;\n                 }\n             }\n@@ -1616,7 +1617,7 @@ impl MirPass for QualifyAndPromoteConstants {\n \n fn args_required_const(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<FxHashSet<usize>> {\n     let attrs = tcx.get_attrs(def_id);\n-    let attr = attrs.iter().find(|a| a.check_name(\"rustc_args_required_const\"))?;\n+    let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n     let mut ret = FxHashSet::default();\n     for meta in attr.meta_item_list()? {\n         match meta.literal()?.node {"}, {"sha": "815821f6ff0337eb6bf72906485e398917d9d41a", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,5 +1,6 @@\n use rustc_target::spec::abi::{Abi};\n use syntax::ast;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt};\n@@ -27,7 +28,7 @@ impl MirPass for SanityCheck {\n     fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>, mir: &mut Mir<'tcx>) {\n         let def_id = src.def_id();\n-        if !tcx.has_attr(def_id, \"rustc_mir\") {\n+        if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n             return;\n         } else {\n@@ -52,16 +53,16 @@ impl MirPass for SanityCheck {\n                         DefinitelyInitializedPlaces::new(tcx, mir, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n \n-        if has_rustc_mir_with(&attributes, \"rustc_peek_maybe_init\").is_some() {\n+        if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_init).is_some() {\n             sanity_check_via_rustc_peek(tcx, mir, def_id, &attributes, &flow_inits);\n         }\n-        if has_rustc_mir_with(&attributes, \"rustc_peek_maybe_uninit\").is_some() {\n+        if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_uninit).is_some() {\n             sanity_check_via_rustc_peek(tcx, mir, def_id, &attributes, &flow_uninits);\n         }\n-        if has_rustc_mir_with(&attributes, \"rustc_peek_definite_init\").is_some() {\n+        if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n             sanity_check_via_rustc_peek(tcx, mir, def_id, &attributes, &flow_def_inits);\n         }\n-        if has_rustc_mir_with(&attributes, \"stop_after_dataflow\").is_some() {\n+        if has_rustc_mir_with(&attributes, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n         }\n     }"}, {"sha": "a5dfb736b819c08762e55271fb496a69da20ad3b", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -634,6 +634,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n     fn cannot_return_reference_to_local(\n         self,\n         span: Span,\n+        return_kind: &str,\n         reference_desc: &str,\n         path_desc: &str,\n         o: Origin,\n@@ -642,15 +643,16 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n             self,\n             span,\n             E0515,\n-            \"cannot return {REFERENCE} {LOCAL}{OGN}\",\n+            \"cannot {RETURN} {REFERENCE} {LOCAL}{OGN}\",\n+            RETURN=return_kind,\n             REFERENCE=reference_desc,\n             LOCAL=path_desc,\n             OGN = o\n         );\n \n         err.span_label(\n             span,\n-            format!(\"returns a {} data owned by the current function\", reference_desc),\n+            format!(\"{}s a {} data owned by the current function\", return_kind, reference_desc),\n         );\n \n         self.cancel_if_wrong_origin(err, o)"}, {"sha": "fc4c6b3fd3f244afc5a41d37239e39c31ba8f987", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -27,7 +27,7 @@ pub fn graphviz_safe_def_name(def_id: DefId) -> String {\n     format!(\n         \"{}_{}\",\n         def_id.krate.index(),\n-        def_id.index.as_array_index(),\n+        def_id.index.index(),\n     )\n }\n \n@@ -167,7 +167,7 @@ fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             write!(w, r#\"{:?}: {}; // {}<br align=\"left\"/>\"#,\n                    Place::Base(PlaceBase::Local(local)), escape(&decl.ty), name)?;\n         } else {\n-            write!(w, r#\"let mut {:?}: {};<br align=\"left\"/>\"#,\n+            write!(w, r#\"{:?}: {};<br align=\"left\"/>\"#,\n                    Place::Base(PlaceBase::Local(local)), escape(&decl.ty))?;\n         }\n     }"}, {"sha": "2bea1db841ae918db916e9e2ba15f6f67255ddf9", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::source_map::Spanned;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n use syntax::{span_err, struct_span_err, walk_list};\n@@ -54,21 +54,21 @@ struct AstValidator<'a> {\n     has_proc_macro_decls: bool,\n     has_global_allocator: bool,\n \n-    // Used to ban nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n-    // Nested `impl Trait` _is_ allowed in associated type position,\n-    // e.g `impl Iterator<Item=impl Debug>`\n+    /// Used to ban nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n+    /// Nested `impl Trait` _is_ allowed in associated type position,\n+    /// e.g `impl Iterator<Item=impl Debug>`\n     outer_impl_trait: Option<OuterImplTrait>,\n \n-    // Used to ban `impl Trait` in path projections like `<impl Iterator>::Item`\n-    // or `Foo::Bar<impl Trait>`\n+    /// Used to ban `impl Trait` in path projections like `<impl Iterator>::Item`\n+    /// or `Foo::Bar<impl Trait>`\n     is_impl_trait_banned: bool,\n \n-    // rust-lang/rust#57979: the ban of nested `impl Trait` was buggy\n-    // until PRs #57730 and #57981 landed: it would jump directly to\n-    // walk_ty rather than visit_ty (or skip recurring entirely for\n-    // impl trait in projections), and thus miss some cases. We track\n-    // whether we should downgrade to a warning for short-term via\n-    // these booleans.\n+    /// rust-lang/rust#57979: the ban of nested `impl Trait` was buggy\n+    /// until PRs #57730 and #57981 landed: it would jump directly to\n+    /// walk_ty rather than visit_ty (or skip recurring entirely for\n+    /// impl trait in projections), and thus miss some cases. We track\n+    /// whether we should downgrade to a warning for short-term via\n+    /// these booleans.\n     warning_period_57979_didnt_record_next_impl_trait: bool,\n     warning_period_57979_impl_trait_in_proj: bool,\n }\n@@ -565,7 +565,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.has_proc_macro_decls = true;\n         }\n \n-        if attr::contains_name(&item.attrs, \"global_allocator\") {\n+        if attr::contains_name(&item.attrs, sym::global_allocator) {\n             self.has_global_allocator = true;\n         }\n \n@@ -676,8 +676,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n-                attr::first_attr_value_str_by_name(&item.attrs, \"path\");\n-                if attr::contains_name(&item.attrs, \"warn_directory_ownership\") {\n+                attr::first_attr_value_str_by_name(&item.attrs, sym::path);\n+                if attr::contains_name(&item.attrs, sym::warn_directory_ownership) {\n                     let lint = lint::builtin::LEGACY_DIRECTORY_OWNERSHIP;\n                     let msg = \"cannot declare a new module at this location\";\n                     self.session.buffer_lint(lint, item.id, item.span, msg);"}, {"sha": "dea5774aa6eb7c64a00f39545bcf1aece4f9c293", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -12,6 +12,7 @@ use rustc::ty::ParamEnv;\n use rustc::ty::Ty;\n use rustc::ty::TyCtxt;\n use syntax::ast::Attribute;\n+use syntax::symbol::sym;\n \n pub fn test_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     if tcx.features().rustc_attrs {\n@@ -32,7 +33,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n \n         if let ItemKind::Ty(..) = item.node {\n             for attr in self.tcx.get_attrs(item_def_id).iter() {\n-                if attr.check_name(\"rustc_layout\") {\n+                if attr.check_name(sym::rustc_layout) {\n                     self.dump_layout_of(item_def_id, item, attr);\n                 }\n             }\n@@ -54,26 +55,26 @@ impl<'a, 'tcx> VarianceTest<'a, 'tcx> {\n                 // The `..` are the names of fields to dump.\n                 let meta_items = attr.meta_item_list().unwrap_or_default();\n                 for meta_item in meta_items {\n-                    match meta_item.name_or_empty().get() {\n-                        \"abi\" => {\n+                    match meta_item.name_or_empty() {\n+                        sym::abi => {\n                             self.tcx\n                                 .sess\n                                 .span_err(item.span, &format!(\"abi: {:?}\", ty_layout.abi));\n                         }\n \n-                        \"align\" => {\n+                        sym::align => {\n                             self.tcx\n                                 .sess\n                                 .span_err(item.span, &format!(\"align: {:?}\", ty_layout.align));\n                         }\n \n-                        \"size\" => {\n+                        sym::size => {\n                             self.tcx\n                                 .sess\n                                 .span_err(item.span, &format!(\"size: {:?}\", ty_layout.size));\n                         }\n \n-                        \"homogeneous_aggregate\" => {\n+                        sym::homogeneous_aggregate => {\n                             self.tcx.sess.span_err(\n                                 item.span,\n                                 &format!("}, {"sha": "37917aaa4a80f4c2c7b39adcf6a2edee2319d60f", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -25,6 +25,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::util::nodemap::{ItemLocalSet, HirIdSet};\n use rustc::hir;\n+use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n use log::debug;\n use Promotability::*;\n@@ -335,7 +336,7 @@ fn check_expr_kind<'a, 'tcx>(\n \n                     if v.in_static {\n                         for attr in &v.tcx.get_attrs(did)[..] {\n-                            if attr.check_name(\"thread_local\") {\n+                            if attr.check_name(sym::thread_local) {\n                                 debug!(\"Reference to Static(id={:?}) is unpromotable \\\n                                        due to a #[thread_local] attribute\", did);\n                                 return NotPromotable;\n@@ -518,15 +519,6 @@ fn check_expr_kind<'a, 'tcx>(\n             NotPromotable\n         }\n \n-        hir::ExprKind::If(ref lhs, ref rhs, ref option_expr) => {\n-            let _ = v.check_expr(lhs);\n-            let _ = v.check_expr(rhs);\n-            if let Some(ref expr) = option_expr {\n-                let _ = v.check_expr(&expr);\n-            }\n-            NotPromotable\n-        }\n-\n         // Loops (not very meaningful in constants).\n         hir::ExprKind::While(ref expr, ref box_block, ref _option_label) => {\n             let _ = v.check_expr(expr);"}, {"sha": "8259419c64aeb17d67baed9a87ce70d6e243b374", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,6 +1,7 @@\n //! Used by `rustc` when compiling a plugin crate.\n \n use syntax::attr;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n@@ -15,8 +16,7 @@ struct RegistrarFinder {\n impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemKind::Fn(..) = item.node {\n-            if attr::contains_name(&item.attrs,\n-                                   \"plugin_registrar\") {\n+            if attr::contains_name(&item.attrs, sym::plugin_registrar) {\n                 self.registrars.push((item.hir_id, item.span));\n             }\n         }"}, {"sha": "680bdcc4bbe9763f687b3c97685198f8705500ff", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -11,6 +11,7 @@ use std::mem;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::span_err;\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n /// Pointer to a registrar function.\n@@ -45,7 +46,7 @@ pub fn load_plugins(sess: &Session,\n     // the feature enabled will result in an error later...\n     if sess.features_untracked().plugin {\n         for attr in &krate.attrs {\n-            if !attr.check_name(\"plugin\") {\n+            if !attr.check_name(sym::plugin) {\n                 continue;\n             }\n \n@@ -57,9 +58,9 @@ pub fn load_plugins(sess: &Session,\n             for plugin in plugins {\n                 // plugins must have a name and can't be key = value\n                 let name = plugin.name_or_empty();\n-                if !name.is_empty() && !plugin.is_value_str() {\n+                if name != keywords::Invalid.name() && !plugin.is_value_str() {\n                     let args = plugin.meta_item_list().map(ToOwned::to_owned);\n-                    loader.load_plugin(plugin.span(), &name, args.unwrap_or_default());\n+                    loader.load_plugin(plugin.span(), name, args.unwrap_or_default());\n                 } else {\n                     call_malformed_plugin_attribute(sess, attr.span);\n                 }\n@@ -69,7 +70,7 @@ pub fn load_plugins(sess: &Session,\n \n     if let Some(plugins) = addl_plugins {\n         for plugin in plugins {\n-            loader.load_plugin(DUMMY_SP, &plugin, vec![]);\n+            loader.load_plugin(DUMMY_SP, Symbol::intern(&plugin), vec![]);\n         }\n     }\n \n@@ -85,7 +86,7 @@ impl<'a> PluginLoader<'a> {\n         }\n     }\n \n-    fn load_plugin(&mut self, span: Span, name: &str, args: Vec<ast::NestedMetaItem>) {\n+    fn load_plugin(&mut self, span: Span, name: Symbol, args: Vec<ast::NestedMetaItem>) {\n         let registrar = self.reader.find_plugin_registrar(span, name);\n \n         if let Some((lib, disambiguator)) = registrar {"}, {"sha": "c2d1d5fa65af299b242b708009a9d0f0878499c8", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -7,7 +7,7 @@ use rustc::util::nodemap::FxHashMap;\n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT, IdentTT};\n use syntax::ext::base::MacroExpanderFn;\n use syntax::ext::hygiene;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n use syntax_pos::Span;\n@@ -49,7 +49,7 @@ pub struct Registry<'a> {\n     pub llvm_passes: Vec<String>,\n \n     #[doc(hidden)]\n-    pub attributes: Vec<(String, AttributeType)>,\n+    pub attributes: Vec<(Symbol, AttributeType)>,\n }\n \n impl<'a> Registry<'a> {\n@@ -86,7 +86,7 @@ impl<'a> Registry<'a> {\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n     pub fn register_syntax_extension(&mut self, name: ast::Name, extension: SyntaxExtension) {\n-        if name == \"macro_rules\" {\n+        if name == sym::macro_rules {\n             panic!(\"user-defined macros may not be named `macro_rules`\");\n         }\n         self.syntax_exts.push((name, match extension {\n@@ -169,7 +169,7 @@ impl<'a> Registry<'a> {\n     /// Registered attributes will bypass the `custom_attribute` feature gate.\n     /// `Whitelisted` attributes will additionally not trigger the `unused_attribute`\n     /// lint. `CrateLevel` attributes will not be allowed on anything other than a crate.\n-    pub fn register_attribute(&mut self, name: String, ty: AttributeType) {\n+    pub fn register_attribute(&mut self, name: Symbol, ty: AttributeType) {\n         self.attributes.push((name, ty));\n     }\n }"}, {"sha": "cd21713cddf97364da7657f09c16a375b416f452", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -27,7 +27,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::Ident;\n use syntax::attr;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::Span;\n \n use std::{cmp, fmt, mem};\n@@ -260,7 +260,8 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                                 ctor_vis = ty::Visibility::Restricted(\n                                     DefId::local(CRATE_DEF_INDEX));\n                                 let attrs = tcx.get_attrs(variant.def_id);\n-                                span = attr::find_by_name(&attrs, \"non_exhaustive\").unwrap().span;\n+                                span = attr::find_by_name(&attrs, sym::non_exhaustive)\n+                                    .unwrap().span;\n                                 descr = \"crate-visible\";\n                             }\n \n@@ -291,7 +292,7 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                                 if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n                                     ctor_vis =\n                                         ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                                    span = attr::find_by_name(&item.attrs, \"non_exhaustive\")\n+                                    span = attr::find_by_name(&item.attrs, sym::non_exhaustive)\n                                                 .unwrap().span;\n                                     descr = \"crate-visible\";\n                                 }"}, {"sha": "3b58a99d19fe00b8389af4716511bd535327ec32", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -37,7 +37,7 @@ use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n use syntax::span_err;\n use syntax::std_inject::injected_crate_name;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -257,7 +257,7 @@ impl<'a> Resolver<'a> {\n             }\n             ast::UseTreeKind::Glob => {\n                 let subclass = GlobImport {\n-                    is_prelude: attr::contains_name(&item.attrs, \"prelude_import\"),\n+                    is_prelude: attr::contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(ty::Visibility::Invisible),\n                 };\n                 self.add_import_directive(\n@@ -314,7 +314,7 @@ impl<'a> Resolver<'a> {\n                             Ident::new(keywords::SelfLower.name(), new_span)\n                         ),\n                         kind: ast::UseTreeKind::Simple(\n-                            Some(Ident::new(Name::gensym(\"__dummy\"), new_span)),\n+                            Some(Ident::from_str_and_span(\"__dummy\", new_span).gensym()),\n                             ast::DUMMY_NODE_ID,\n                             ast::DUMMY_NODE_ID,\n                         ),\n@@ -369,7 +369,7 @@ impl<'a> Resolver<'a> {\n                 };\n \n                 self.populate_module_if_necessary(module);\n-                if injected_crate_name().map_or(false, |name| ident.name == name) {\n+                if injected_crate_name().map_or(false, |name| ident.name.as_str() == name) {\n                     self.injected_crate = Some(module);\n                 }\n \n@@ -427,7 +427,7 @@ impl<'a> Resolver<'a> {\n                 let module_kind = ModuleKind::Def(DefKind::Mod, def_id, ident.name);\n                 let module = self.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n-                        attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n+                        attr::contains_name(&item.attrs, sym::no_implicit_prelude)\n                     },\n                     ..ModuleData::new(Some(parent), module_kind, def_id, expansion, item.span)\n                 });\n@@ -456,12 +456,12 @@ impl<'a> Resolver<'a> {\n \n                 // Functions introducing procedural macros reserve a slot\n                 // in the macro namespace as well (see #52225).\n-                if attr::contains_name(&item.attrs, \"proc_macro\") ||\n-                   attr::contains_name(&item.attrs, \"proc_macro_attribute\") {\n+                if attr::contains_name(&item.attrs, sym::proc_macro) ||\n+                   attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n                     let res = Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), res.def_id());\n                     self.define(parent, ident, MacroNS, (res, vis, sp, expansion));\n                 }\n-                if let Some(attr) = attr::find_by_name(&item.attrs, \"proc_macro_derive\") {\n+                if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n                     if let Some(trait_attr) =\n                             attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n                         if let Some(ident) = trait_attr.ident() {\n@@ -518,7 +518,7 @@ impl<'a> Resolver<'a> {\n \n                 let mut ctor_vis = vis;\n \n-                let has_non_exhaustive = attr::contains_name(&item.attrs, \"non_exhaustive\");\n+                let has_non_exhaustive = attr::contains_name(&item.attrs, sym::non_exhaustive);\n \n                 // If the structure is marked as non_exhaustive then lower the visibility\n                 // to within the crate.\n@@ -599,7 +599,7 @@ impl<'a> Resolver<'a> {\n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n         // crate.\n         let mut ctor_vis = vis;\n-        let has_non_exhaustive = attr::contains_name(&variant.node.attrs, \"non_exhaustive\");\n+        let has_non_exhaustive = attr::contains_name(&variant.node.attrs, sym::non_exhaustive);\n         if has_non_exhaustive && vis == ty::Visibility::Public {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n@@ -825,7 +825,7 @@ impl<'a> Resolver<'a> {\n         let mut import_all = None;\n         let mut single_imports = Vec::new();\n         for attr in &item.attrs {\n-            if attr.check_name(\"macro_use\") {\n+            if attr.check_name(sym::macro_use) {\n                 if self.current_module.parent.is_some() {\n                     span_err!(self.session, item.span, E0468,\n                         \"an `extern crate` loading macros must be at the crate root\");\n@@ -908,15 +908,15 @@ impl<'a> Resolver<'a> {\n     /// Returns `true` if this attribute list contains `macro_use`.\n     fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n         for attr in attrs {\n-            if attr.check_name(\"macro_escape\") {\n+            if attr.check_name(sym::macro_escape) {\n                 let msg = \"macro_escape is a deprecated synonym for macro_use\";\n                 let mut err = self.session.struct_span_warn(attr.span, msg);\n                 if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n                 } else {\n                     err.emit();\n                 }\n-            } else if !attr.check_name(\"macro_use\") {\n+            } else if !attr.check_name(sym::macro_use) {\n                 continue;\n             }\n "}, {"sha": "c4a4dd306055bb92db05298eebe2bba46db2ef20", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -43,7 +43,7 @@ use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n@@ -1812,8 +1812,8 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n-        crate_root: Option<&str>,\n-        components: &[&str],\n+        crate_root: Option<Symbol>,\n+        components: &[Symbol],\n         is_value: bool\n     ) -> hir::Path {\n         let root = if crate_root.is_some() {\n@@ -1825,7 +1825,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n-                    .map(Ident::from_str)\n+                    .map(Ident::with_empty_ctxt)\n             ).map(|i| self.new_ast_path_segment(i)).collect::<Vec<_>>();\n \n \n@@ -1964,7 +1964,7 @@ impl<'a> Resolver<'a> {\n             keywords::Invalid.name(),\n         );\n         let graph_root = arenas.alloc_module(ModuleData {\n-            no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n+            no_implicit_prelude: attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n             ..ModuleData::new(None, root_module_kind, root_def_id, Mark::root(), krate.span)\n         });\n         let mut module_map = FxHashMap::default();\n@@ -1978,12 +1978,12 @@ impl<'a> Resolver<'a> {\n             session.opts.externs.iter().map(|kv| (Ident::from_str(kv.0), Default::default()))\n                                        .collect();\n \n-        if !attr::contains_name(&krate.attrs, \"no_core\") {\n-            extern_prelude.insert(Ident::from_str(\"core\"), Default::default());\n-            if !attr::contains_name(&krate.attrs, \"no_std\") {\n-                extern_prelude.insert(Ident::from_str(\"std\"), Default::default());\n+        if !attr::contains_name(&krate.attrs, sym::no_core) {\n+            extern_prelude.insert(Ident::with_empty_ctxt(sym::core), Default::default());\n+            if !attr::contains_name(&krate.attrs, sym::no_std) {\n+                extern_prelude.insert(Ident::with_empty_ctxt(sym::std), Default::default());\n                 if session.rust_2018() {\n-                    extern_prelude.insert(Ident::from_str(\"meta\"), Default::default());\n+                    extern_prelude.insert(Ident::with_empty_ctxt(sym::meta), Default::default());\n                 }\n             }\n         }\n@@ -3374,7 +3374,7 @@ impl<'a> Resolver<'a> {\n                     self.trait_map.insert(id, traits);\n                 }\n \n-                let mut std_path = vec![Segment::from_ident(Ident::from_str(\"std\"))];\n+                let mut std_path = vec![Segment::from_ident(Ident::with_empty_ctxt(sym::std))];\n                 std_path.extend(path);\n                 if self.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n                     let cl = CrateLint::No;\n@@ -4225,7 +4225,7 @@ impl<'a> Resolver<'a> {\n         let add_module_candidates = |module: Module<'_>, names: &mut Vec<TypoSuggestion>| {\n             for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n                 if let Some(binding) = resolution.borrow().binding {\n-                    if !ident.name.is_gensymed() && filter_fn(binding.res()) {\n+                    if !ident.is_gensymed() && filter_fn(binding.res()) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: binding.res().article(),\n@@ -4243,7 +4243,7 @@ impl<'a> Resolver<'a> {\n             for rib in self.ribs[ns].iter().rev() {\n                 // Locals and type parameters\n                 for (ident, &res) in &rib.bindings {\n-                    if !ident.name.is_gensymed() && filter_fn(res) {\n+                    if !ident.is_gensymed() && filter_fn(res) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: res.article(),\n@@ -4273,7 +4273,7 @@ impl<'a> Resolver<'a> {\n                                             },\n                                         );\n \n-                                        if !ident.name.is_gensymed() && filter_fn(crate_mod) {\n+                                        if !ident.is_gensymed() && filter_fn(crate_mod) {\n                                             Some(TypoSuggestion {\n                                                 candidate: ident.name,\n                                                 article: \"a\",\n@@ -4298,7 +4298,6 @@ impl<'a> Resolver<'a> {\n                 names.extend(\n                     self.primitive_type_table.primitive_types\n                         .iter()\n-                        .filter(|(name, _)| !name.is_gensymed())\n                         .map(|(name, _)| {\n                             TypoSuggestion {\n                                 candidate: *name,"}, {"sha": "e34a33ef8fad9b2a7476e2d8a096e11b5e610ceb", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -22,7 +22,7 @@ use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{\n     feature_err, is_builtin_attr_name, AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES,\n };\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax::visit::Visitor;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -172,7 +172,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>) {\n         let def_id = DefId {\n             krate: CrateNum::BuiltinMacros,\n-            index: DefIndex::from_array_index(self.macro_map.len()),\n+            index: DefIndex::from(self.macro_map.len()),\n         };\n         let kind = ext.kind();\n         self.macro_map.insert(def_id, ext);\n@@ -313,7 +313,8 @@ impl<'a> Resolver<'a> {\n                             if !features.rustc_attrs {\n                                 let msg = \"unless otherwise specified, attributes with the prefix \\\n                                            `rustc_` are reserved for internal compiler diagnostics\";\n-                                self.report_unknown_attribute(path.span, &name, msg, \"rustc_attrs\");\n+                                self.report_unknown_attribute(path.span, &name, msg,\n+                                                              sym::rustc_attrs);\n                             }\n                         } else if !features.custom_attribute {\n                             let msg = format!(\"The attribute `{}` is currently unknown to the \\\n@@ -323,7 +324,7 @@ impl<'a> Resolver<'a> {\n                                 path.span,\n                                 &name,\n                                 &msg,\n-                                \"custom_attribute\",\n+                                sym::custom_attribute,\n                             );\n                         }\n                     }\n@@ -345,7 +346,7 @@ impl<'a> Resolver<'a> {\n         Ok((res, self.get_macro(res)))\n     }\n \n-    fn report_unknown_attribute(&self, span: Span, name: &str, msg: &str, feature: &str) {\n+    fn report_unknown_attribute(&self, span: Span, name: &str, msg: &str, feature: Symbol) {\n         let mut err = feature_err(\n             &self.session.parse_sess,\n             feature,\n@@ -693,7 +694,7 @@ impl<'a> Resolver<'a> {\n                 WhereToResolve::LegacyPluginHelpers => {\n                     if (use_prelude || rust_2015) &&\n                        self.session.plugin_attributes.borrow().iter()\n-                                                     .any(|(name, _)| ident.name == &**name) {\n+                                                     .any(|(name, _)| ident.name == *name) {\n                         let binding = (Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n                                        ty::Visibility::Public, DUMMY_SP, Mark::root())\n                                        .to_name_binding(self.arenas);\n@@ -981,7 +982,7 @@ impl<'a> Resolver<'a> {\n                     let msg =\n                         format!(\"cannot find {} `{}{}` in this scope\", kind.descr(), ident, bang);\n                     let mut err = self.session.struct_span_err(ident.span, &msg);\n-                    self.suggest_macro_name(&ident.as_str(), kind, &mut err, ident.span);\n+                    self.suggest_macro_name(ident.name, kind, &mut err, ident.span);\n                     err.emit();\n                 }\n             }\n@@ -1009,11 +1010,12 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,\n+    fn suggest_macro_name(&mut self, name: Symbol, kind: MacroKind,\n                           err: &mut DiagnosticBuilder<'a>, span: Span) {\n         // First check if this is a locally-defined bang macro.\n         let suggestion = if let MacroKind::Bang = kind {\n-            find_best_match_for_name(self.macro_names.iter().map(|ident| &ident.name), name, None)\n+            find_best_match_for_name(\n+                self.macro_names.iter().map(|ident| &ident.name), &name.as_str(), None)\n         } else {\n             None\n         // Then check global macros.\n@@ -1022,7 +1024,7 @@ impl<'a> Resolver<'a> {\n                                                   .filter_map(|(name, binding)| {\n                 if binding.macro_kind() == Some(kind) { Some(name) } else { None }\n             });\n-            find_best_match_for_name(names, name, None)\n+            find_best_match_for_name(names, &name.as_str(), None)\n         // Then check modules.\n         }).or_else(|| {\n             let is_macro = |res| {\n@@ -1032,7 +1034,7 @@ impl<'a> Resolver<'a> {\n                     false\n                 }\n             };\n-            let ident = Ident::new(Symbol::intern(name), span);\n+            let ident = Ident::new(name, span);\n             self.lookup_typo_candidate(&[Segment::from_ident(ident)], MacroNS, is_macro, span)\n                 .map(|suggestion| suggestion.candidate)\n         });\n@@ -1091,7 +1093,7 @@ impl<'a> Resolver<'a> {\n                         current_legacy_scope: &mut LegacyScope<'a>) {\n         self.local_macro_def_scopes.insert(item.id, self.current_module);\n         let ident = item.ident;\n-        if ident.name == \"macro_rules\" {\n+        if ident.name == sym::macro_rules {\n             self.session.span_err(item.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n \n@@ -1106,7 +1108,7 @@ impl<'a> Resolver<'a> {\n             let ident = ident.modern();\n             self.macro_names.insert(ident);\n             let res = Res::Def(DefKind::Macro(MacroKind::Bang), def_id);\n-            let is_macro_export = attr::contains_name(&item.attrs, \"macro_export\");\n+            let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n@@ -1124,7 +1126,7 @@ impl<'a> Resolver<'a> {\n                 self.define(module, ident, MacroNS,\n                             (res, vis, item.span, expansion, IsMacroExport));\n             } else {\n-                if !attr::contains_name(&item.attrs, \"rustc_doc_only_macro\") {\n+                if !attr::contains_name(&item.attrs, sym::rustc_doc_only_macro) {\n                     self.check_reserved_macro_name(ident, MacroNS);\n                 }\n                 self.unused_macros.insert(def_id);"}, {"sha": "3a6a8b56ff35d875b695f8d2c644ddaec78be745", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -29,7 +29,7 @@ use rustc::{bug, span_bug};\n use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::{struct_span_err, unwrap_or};\n use syntax_pos::{MultiSpan, Span};\n@@ -496,7 +496,8 @@ impl<'a> Resolver<'a> {\n         // Reserve some names that are not quite covered by the general check\n         // performed on `Resolver::builtin_attrs`.\n         if ns == MacroNS &&\n-           (ident.name == \"cfg\" || ident.name == \"cfg_attr\" || ident.name == \"derive\") {\n+           (ident.name == sym::cfg || ident.name == sym::cfg_attr ||\n+            ident.name == sym::derive) {\n             self.session.span_err(ident.span,\n                                   &format!(\"name `{}` is reserved in macro namespace\", ident));\n         }\n@@ -706,7 +707,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 has_errors = true;\n \n                 if let SingleImport { source, ref source_bindings, .. } = import.subclass {\n-                    if source.name == \"self\" {\n+                    if source.name == keywords::SelfLower.name() {\n                         // Silence `unresolved import` error if E0429 is already emitted\n                         if let Err(Determined) = source_bindings.value_ns.get() {\n                             continue;\n@@ -1041,7 +1042,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     let initial_res = source_bindings[ns].get().map(|initial_binding| {\n                         all_ns_err = false;\n                         if let Some(target_binding) = target_bindings[ns].get() {\n-                            if target.name == \"_\" &&\n+                            // Note that as_str() de-gensyms the Symbol\n+                            if target.name.as_str() == \"_\" &&\n                                initial_binding.is_extern_crate() && !initial_binding.is_import() {\n                                 this.record_use(ident, ns, target_binding,\n                                                 directive.module_path.is_empty());\n@@ -1392,7 +1394,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // (e.g. implicitly injected `std`) cannot be properly encoded in metadata,\n             // so they can cause name conflict errors downstream.\n             let is_good_import = binding.is_import() && !binding.is_ambiguity() &&\n-                                 !(ident.name.is_gensymed() && ident.name != \"_\");\n+                                 // Note that as_str() de-gensyms the Symbol\n+                                 !(ident.is_gensymed() && ident.name.as_str() != \"_\");\n             if is_good_import || binding.is_macro_def() {\n                 let res = binding.res();\n                 if res != Res::Err {"}, {"sha": "1e65f868ebac0bea2b75f4c301105c5a9cd0e0fa", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -463,10 +463,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n \n         // walk type and init value\n-        self.visit_ty(typ);\n-        if let Some(expr) = expr {\n-            self.visit_expr(expr);\n-        }\n+        self.nest_tables(id, |v| {\n+            v.visit_ty(typ);\n+            if let Some(expr) = expr {\n+                v.visit_expr(expr);\n+            }\n+        });\n     }\n \n     // FIXME tuple structs should generate tuple-specific data."}, {"sha": "d34f5633946bfa281773da81d21cab2b44013bcc", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -879,7 +879,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let mut result = String::new();\n \n         for attr in attrs {\n-            if attr.check_name(\"doc\") {\n+            if attr.check_name(sym::doc) {\n                 if let Some(val) = attr.value_str() {\n                     if attr.is_sugared_doc {\n                         result.push_str(&strip_doc_comment_decoration(&val.as_str()));\n@@ -889,10 +889,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     result.push('\\n');\n                 } else if let Some(meta_list) = attr.meta_item_list() {\n                     meta_list.into_iter()\n-                             .filter(|it| it.check_name(\"include\"))\n+                             .filter(|it| it.check_name(sym::include))\n                              .filter_map(|it| it.meta_item_list().map(|l| l.to_owned()))\n                              .flat_map(|it| it)\n-                             .filter(|meta| meta.check_name(\"contents\"))\n+                             .filter(|meta| meta.check_name(sym::contents))\n                              .filter_map(|meta| meta.value_str())\n                              .for_each(|val| {\n                                  result.push_str(&val.as_str());\n@@ -1170,7 +1170,7 @@ fn generated_code(span: Span) -> bool {\n fn id_from_def_id(id: DefId) -> rls_data::Id {\n     rls_data::Id {\n         krate: id.krate.as_u32(),\n-        index: id.index.as_raw_u32(),\n+        index: id.index.as_u32(),\n     }\n }\n \n@@ -1197,7 +1197,7 @@ fn null_id() -> rls_data::Id {\n fn lower_attributes(attrs: Vec<Attribute>, scx: &SaveContext<'_, '_>) -> Vec<rls_data::Attribute> {\n     attrs.into_iter()\n     // Only retain real attributes. Doc comments are lowered separately.\n-    .filter(|attr| attr.path != \"doc\")\n+    .filter(|attr| attr.path != sym::doc)\n     .map(|mut attr| {\n         // Remove the surrounding '#[..]' or '#![..]' of the pretty printed\n         // attribute. First normalize all inner attribute (#![..]) to outer"}, {"sha": "53364e72bfe3ad70e71e49efe893799c8d4ed8b5", "filename": "src/librustc_target/spec/apple_base.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_target%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_target%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_base.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -14,7 +14,7 @@ pub fn opts() -> TargetOptions {\n     //\n     // Here we detect what version is being requested, defaulting to 10.7. ELF\n     // TLS is flagged as enabled if it looks to be supported.\n-    let version = macos_deployment_target().unwrap_or((10, 7));\n+    let version = macos_deployment_target();\n \n     TargetOptions {\n         // macOS has -dead_strip, which doesn't rely on function_sections\n@@ -35,7 +35,7 @@ pub fn opts() -> TargetOptions {\n     }\n }\n \n-fn macos_deployment_target() -> Option<(u32, u32)> {\n+fn macos_deployment_target() -> (u32, u32) {\n     let deployment_target = env::var(\"MACOSX_DEPLOYMENT_TARGET\").ok();\n     let version = deployment_target.as_ref().and_then(|s| {\n         let mut i = s.splitn(2, '.');\n@@ -44,17 +44,10 @@ fn macos_deployment_target() -> Option<(u32, u32)> {\n         a.parse::<u32>().and_then(|a| b.parse::<u32>().map(|b| (a, b))).ok()\n     });\n \n-    version\n+    version.unwrap_or((10, 7))\n }\n \n pub fn macos_llvm_target(arch: &str) -> String {\n-    let version = macos_deployment_target();\n-    let llvm_target = match version {\n-        Some((major, minor)) => {\n-            format!(\"{}-apple-macosx{}.{}.0\", arch, major, minor)\n-        },\n-        None => format!(\"{}-apple-darwin\", arch)\n-    };\n-\n-    llvm_target\n+    let (major, minor) = macos_deployment_target();\n+    format!(\"{}-apple-macosx{}.{}.0\", arch, major, minor)\n }"}, {"sha": "9b34119fc00c9f9484f7aed38989d6b20003d410", "filename": "src/librustc_target/spec/bitrig_base.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibrustc_target%2Fspec%2Fbitrig_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibrustc_target%2Fspec%2Fbitrig_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fbitrig_base.rs?ref=e764f475ca7fffd6167ea991afc7d1b2b3f642dc", "patch": "@@ -1,16 +0,0 @@\n-use crate::spec::{TargetOptions, RelroLevel};\n-use std::default::Default;\n-\n-pub fn opts() -> TargetOptions {\n-    TargetOptions {\n-        dynamic_linking: true,\n-        executables: true,\n-        target_family: Some(\"unix\".to_string()),\n-        linker_is_gnu: true,\n-        has_rpath: true,\n-        position_independent_executables: true,\n-        relro_level: RelroLevel::Full,\n-\n-        .. Default::default()\n-    }\n-}"}, {"sha": "844edbb946a515f9899974e64ee1acecc79ef50d", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -47,7 +47,6 @@ mod android_base;\n mod apple_base;\n mod apple_ios_base;\n mod arm_base;\n-mod bitrig_base;\n mod cloudabi_base;\n mod dragonfly_base;\n mod freebsd_base;\n@@ -390,8 +389,6 @@ supported_targets! {\n     (\"i686-unknown-dragonfly\", i686_unknown_dragonfly),\n     (\"x86_64-unknown-dragonfly\", x86_64_unknown_dragonfly),\n \n-    (\"x86_64-unknown-bitrig\", x86_64_unknown_bitrig),\n-\n     (\"aarch64-unknown-openbsd\", aarch64_unknown_openbsd),\n     (\"i686-unknown-openbsd\", i686_unknown_openbsd),\n     (\"x86_64-unknown-openbsd\", x86_64_unknown_openbsd),\n@@ -444,7 +441,7 @@ supported_targets! {\n     (\"asmjs-unknown-emscripten\", asmjs_unknown_emscripten),\n     (\"wasm32-unknown-emscripten\", wasm32_unknown_emscripten),\n     (\"wasm32-unknown-unknown\", wasm32_unknown_unknown),\n-    (\"wasm32-unknown-wasi\", wasm32_unknown_wasi),\n+    (\"wasm32-wasi\", wasm32_wasi),\n     (\"wasm32-experimental-emscripten\", wasm32_experimental_emscripten),\n \n     (\"thumbv6m-none-eabi\", thumbv6m_none_eabi),"}, {"sha": "bb33493a7733368311e59380522eab34bc878594", "filename": "src/librustc_target/spec/wasm32_wasi.rs", "status": "renamed", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_target%2Fspec%2Fwasm32_wasi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_target%2Fspec%2Fwasm32_wasi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_wasi.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,4 +1,4 @@\n-//! The `wasm32-unknown-wasi` target is a new and still (as of March 2019)\n+//! The `wasm32-wasi` target is a new and still (as of April 2019) an\n //! experimental target. The definition in this file is likely to be tweaked\n //! over time and shouldn't be relied on too much.\n //!\n@@ -13,14 +13,14 @@\n //! serve two use cases here with this target:\n //!\n //! * First, we want Rust usage of the target to be as hassle-free as possible,\n-//!   ideally avoiding the need to configure and install a local\n-//!   wasm32-unknown-wasi toolchain.\n+//!   ideally avoiding the need to configure and install a local wasm32-wasi\n+//!   toolchain.\n //!\n //! * Second, one of the primary use cases of LLVM's new wasm backend and the\n //!   wasm support in LLD is that any compiled language can interoperate with\n-//!   any other. To that the `wasm32-unknown-wasi` target is the first with a\n-//!   viable C standard library and sysroot common definition, so we want Rust\n-//!   and C/C++ code to interoperate when compiled to `wasm32-unknown-unknown`.\n+//!   any other. To that the `wasm32-wasi` target is the first with a viable C\n+//!   standard library and sysroot common definition, so we want Rust and C/C++\n+//!   code to interoperate when compiled to `wasm32-unknown-unknown`.\n //!\n //! You'll note, however, that the two goals above are somewhat at odds with one\n //! another. To attempt to solve both use cases in one go we define a target\n@@ -39,8 +39,8 @@\n //! necessary.\n //!\n //! All in all, by default, no external dependencies are required. You can\n-//! compile `wasm32-unknown-wasi` binaries straight out of the box. You can't,\n-//! however, reliably interoperate with C code in this mode (yet).\n+//! compile `wasm32-wasi` binaries straight out of the box. You can't, however,\n+//! reliably interoperate with C code in this mode (yet).\n //!\n //! ## Interop with C required\n //!\n@@ -53,17 +53,17 @@\n //!\n //! 2. If you're using rustc to build a linked artifact then you'll need to\n //!    specify `-C linker` to a `clang` binary that supports\n-//!    `wasm32-unknown-wasi` and is configured with the `wasm32-unknown-wasi`\n-//!    sysroot. This will cause Rust code to be linked against the libc.a that\n-//!    the specified `clang` provides.\n+//!    `wasm32-wasi` and is configured with the `wasm32-wasi` sysroot. This\n+//!    will cause Rust code to be linked against the libc.a that the specified\n+//!    `clang` provides.\n //!\n //! 3. If you're building a staticlib and integrating Rust code elsewhere, then\n //!    compiling with `-C target-feature=-crt-static` is all you need to do.\n //!\n //! You can configure the linker via Cargo using the\n-//! `CARGO_TARGET_WASM32_UNKNOWN_WASI_LINKER` env var. Be sure to also set\n-//! `CC_wasm32-unknown-wasi` if any crates in the dependency graph are using\n-//! the `cc` crate.\n+//! `CARGO_TARGET_WASM32_WASI_LINKER` env var. Be sure to also set\n+//! `CC_wasm32-wasi` if any crates in the dependency graph are using the `cc`\n+//! crate.\n //!\n //! ## Remember, this is all in flux\n //!\n@@ -82,7 +82,7 @@ pub fn target() -> Result<Target, String> {\n         .pre_link_args\n         .entry(LinkerFlavor::Gcc)\n         .or_insert(Vec::new())\n-        .push(\"--target=wasm32-unknown-wasi\".to_string());\n+        .push(\"--target=wasm32-wasi\".to_string());\n \n     // When generating an executable be sure to put the startup object at the\n     // front so the main function is correctly hooked up.\n@@ -98,13 +98,13 @@ pub fn target() -> Result<Target, String> {\n     options.crt_static_respected = true;\n \n     Ok(Target {\n-        llvm_target: \"wasm32-unknown-wasi\".to_string(),\n+        llvm_target: \"wasm32-wasi\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n         target_c_int_width: \"32\".to_string(),\n         target_os: \"wasi\".to_string(),\n         target_env: String::new(),\n-        target_vendor: \"unknown\".to_string(),\n+        target_vendor: String::new(),\n         data_layout: \"e-m:e-p:32:32-i64:64-n32:64-S128\".to_string(),\n         arch: \"wasm32\".to_string(),\n         linker_flavor: LinkerFlavor::Lld(LldFlavor::Wasm),", "previous_filename": "src/librustc_target/spec/wasm32_unknown_wasi.rs"}, {"sha": "999d93a7e60902d876692819bb78db70fdaa68a9", "filename": "src/librustc_target/spec/x86_64_unknown_bitrig.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_bitrig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_bitrig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_bitrig.rs?ref=e764f475ca7fffd6167ea991afc7d1b2b3f642dc", "patch": "@@ -1,23 +0,0 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n-\n-pub fn target() -> TargetResult {\n-    let mut base = super::bitrig_base::opts();\n-    base.cpu = \"x86-64\".to_string();\n-    base.max_atomic_width = Some(64);\n-    base.pre_link_args.insert(LinkerFlavor::Gcc, vec![\"-m64\".to_string()]);\n-    base.stack_probes = true;\n-\n-    Ok(Target {\n-        llvm_target: \"x86_64-unknown-bitrig\".to_string(),\n-        target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n-        target_c_int_width: \"32\".to_string(),\n-        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n-        arch: \"x86_64\".to_string(),\n-        target_os: \"bitrig\".to_string(),\n-        target_env: String::new(),\n-        target_vendor: \"unknown\".to_string(),\n-        linker_flavor: LinkerFlavor::Gcc,\n-        options: base,\n-    })\n-}"}, {"sha": "580b1571e52bb1dd55bc5254ecf05e87806b9e20", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -21,6 +21,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::{self, List, TyCtxt};\n use rustc::ty::subst::{Subst, InternalSubsts};\n use syntax::ast;\n+use syntax::symbol::sym;\n \n use std::iter;\n \n@@ -640,11 +641,11 @@ impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n         for attr in attrs {\n             let mut clauses = None;\n \n-            if attr.check_name(\"rustc_dump_program_clauses\") {\n+            if attr.check_name(sym::rustc_dump_program_clauses) {\n                 clauses = Some(self.tcx.program_clauses_for(def_id));\n             }\n \n-            if attr.check_name(\"rustc_dump_env_program_clauses\") {\n+            if attr.check_name(sym::rustc_dump_env_program_clauses) {\n                 let environment = self.tcx.environment(def_id);\n                 clauses = Some(self.tcx.program_clauses_for_env(environment));\n             }"}, {"sha": "4b052aec5fc2f3be0472421fb253bd40a803d394", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -25,6 +25,7 @@ use syntax::ast;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, Span, MultiSpan};\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::FxHashMap;\n@@ -289,6 +290,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         }\n \n         // Prohibit explicit lifetime arguments if late-bound lifetime parameters are present.\n+        let mut reported_late_bound_region_err = None;\n         if !infer_lifetimes {\n             if let Some(span_late) = def.has_late_bound_regions {\n                 let msg = \"cannot specify lifetime arguments explicitly \\\n@@ -300,13 +302,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     let mut err = tcx.sess.struct_span_err(span, msg);\n                     err.span_note(span_late, note);\n                     err.emit();\n-                    return (true, None);\n+                    reported_late_bound_region_err = Some(true);\n                 } else {\n                     let mut multispan = MultiSpan::from_span(span);\n                     multispan.push_span_label(span_late, note.to_string());\n                     tcx.lint_hir(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n                                  args.args[0].id(), multispan, msg);\n-                    return (false, None);\n+                    reported_late_bound_region_err = Some(false);\n                 }\n             }\n         }\n@@ -324,7 +326,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             // For kinds without defaults (i.e., lifetimes), `required == permitted`.\n             // For other kinds (i.e., types), `permitted` may be greater than `required`.\n             if required <= provided && provided <= permitted {\n-                return (false, None);\n+                return (reported_late_bound_region_err.unwrap_or(false), None);\n             }\n \n             // Unfortunately lifetime and type parameter mismatches are typically styled\n@@ -379,7 +381,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n              potential_assoc_types)\n         };\n \n-        if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n+        if reported_late_bound_region_err.is_none()\n+            && (!infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes) {\n             check_kind_count(\n                 \"lifetime\",\n                 param_counts.lifetimes,\n@@ -409,7 +412,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 arg_counts.lifetimes,\n             )\n         } else {\n-            (false, None)\n+            (reported_late_bound_region_err.unwrap_or(false), None)\n         }\n     }\n \n@@ -802,7 +805,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             } else {\n                 \"parenthetical notation is only stable when used with `Fn`-family traits\"\n             };\n-            emit_feature_err(&self.tcx().sess.parse_sess, \"unboxed_closures\",\n+            emit_feature_err(&self.tcx().sess.parse_sess, sym::unboxed_closures,\n                              span, GateIssue::Language, msg);\n         }\n \n@@ -1902,7 +1905,18 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             ty,\n         };\n \n-        let expr = &tcx.hir().body(ast_const.body).value;\n+        let mut expr = &tcx.hir().body(ast_const.body).value;\n+\n+        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n+        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n+        if let ExprKind::Block(block, _) = &expr.node {\n+            if block.stmts.is_empty() {\n+                if let Some(trailing) = &block.expr {\n+                    expr = &trailing;\n+                }\n+            }\n+        }\n+\n         if let ExprKind::Path(ref qpath) = expr.node {\n             if let hir::QPath::Resolved(_, ref path) = qpath {\n                 if let Res::Def(DefKind::ConstParam, def_id) = path.res {"}, {"sha": "a69f639e8941f51d3aca9290fd553f7b7e27551b", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 329, "deletions": 138, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -2,30 +2,30 @@ use crate::check::{FnCtxt, Expectation, Diverges, Needs};\n use crate::check::coercion::CoerceMany;\n use crate::util::nodemap::FxHashMap;\n use errors::{Applicability, DiagnosticBuilder};\n-use rustc::hir::{self, PatKind, Pat};\n+use rustc::hir::{self, PatKind, Pat, ExprKind};\n use rustc::hir::def::{Res, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer;\n use rustc::infer::type_variable::TypeVariableOrigin;\n-use rustc::traits::ObligationCauseCode;\n+use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::subst::Kind;\n use syntax::ast;\n use syntax::source_map::Spanned;\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n+use syntax_pos::hygiene::CompilerDesugaringKind;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n \n use super::report_unexpected_variant_res;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    /// `match_discrim_span` argument having a `Span` indicates that this pattern is part of\n-    /// a match expression arm guard, and it points to the match discriminant to add context\n-    /// in type errors. In the folloowing example, `match_discrim_span` corresponds to the\n-    /// `a + b` expression:\n+    /// `discrim_span` argument having a `Span` indicates that this pattern is part of a match\n+    /// expression arm guard, and it points to the match discriminant to add context in type errors.\n+    /// In the following example, `discrim_span` corresponds to the `a + b` expression:\n     ///\n     /// ```text\n     /// error[E0308]: mismatched types\n@@ -44,7 +44,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         pat: &'gcx hir::Pat,\n         mut expected: Ty<'tcx>,\n         mut def_bm: ty::BindingMode,\n-        match_discrim_span: Option<Span>,\n+        discrim_span: Option<Span>,\n     ) {\n         let tcx = self.tcx;\n \n@@ -176,7 +176,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 //     &'static str <: expected\n                 //\n                 // that's equivalent to there existing a LUB.\n-                self.demand_suptype(pat.span, expected, pat_ty);\n+                if let Some(mut err) = self.demand_suptype_diag(pat.span, expected, pat_ty) {\n+                    err.emit_unless(discrim_span\n+                        .filter(|&s| s.is_compiler_desugaring(CompilerDesugaringKind::IfTemporary))\n+                        .is_some());\n+                }\n+\n                 pat_ty\n             }\n             PatKind::Range(ref begin, ref end, _) => {\n@@ -224,8 +229,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let common_type = self.resolve_type_vars_if_possible(&lhs_ty);\n \n                 // subtyping doesn't matter here, as the value is some kind of scalar\n-                self.demand_eqtype_pat(pat.span, expected, lhs_ty, match_discrim_span);\n-                self.demand_eqtype_pat(pat.span, expected, rhs_ty, match_discrim_span);\n+                self.demand_eqtype_pat(pat.span, expected, lhs_ty, discrim_span);\n+                self.demand_eqtype_pat(pat.span, expected, rhs_ty, discrim_span);\n                 common_type\n             }\n             PatKind::Binding(ba, var_id, _, ref sub) => {\n@@ -254,25 +259,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n                         // required. However, we use equality, which is stronger. See (*) for\n                         // an explanation.\n-                        self.demand_eqtype_pat(pat.span, region_ty, local_ty, match_discrim_span);\n+                        self.demand_eqtype_pat(pat.span, region_ty, local_ty, discrim_span);\n                     }\n                     // otherwise the type of x is the expected type T\n                     ty::BindByValue(_) => {\n                         // As above, `T <: typeof(x)` is required but we\n                         // use equality, see (*) below.\n-                        self.demand_eqtype_pat(pat.span, expected, local_ty, match_discrim_span);\n+                        self.demand_eqtype_pat(pat.span, expected, local_ty, discrim_span);\n                     }\n                 }\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n                 if var_id != pat.hir_id {\n                     let vt = self.local_ty(pat.span, var_id).decl_ty;\n-                    self.demand_eqtype_pat(pat.span, vt, local_ty, match_discrim_span);\n+                    self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n                 }\n \n                 if let Some(ref p) = *sub {\n-                    self.check_pat_walk(&p, expected, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&p, expected, def_bm, discrim_span);\n                 }\n \n                 local_ty\n@@ -285,14 +290,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ddpos,\n                     expected,\n                     def_bm,\n-                    match_discrim_span,\n+                    discrim_span,\n                 )\n             }\n             PatKind::Path(ref qpath) => {\n                 self.check_pat_path(pat, qpath, expected)\n             }\n             PatKind::Struct(ref qpath, ref fields, etc) => {\n-                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, match_discrim_span)\n+                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, discrim_span)\n             }\n             PatKind::Tuple(ref elements, ddpos) => {\n                 let mut expected_len = elements.len();\n@@ -318,7 +323,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // further errors being emitted when using the bindings. #50333\n                     let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n                     for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(elem, &tcx.types.err, def_bm, match_discrim_span);\n+                        self.check_pat_walk(elem, &tcx.types.err, def_bm, discrim_span);\n                     }\n                     tcx.mk_tup(element_tys_iter)\n                 } else {\n@@ -327,7 +332,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             elem,\n                             &element_tys[i].expect_ty(),\n                             def_bm,\n-                            match_discrim_span,\n+                            discrim_span,\n                         );\n                     }\n                     pat_ty\n@@ -341,11 +346,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // Here, `demand::subtype` is good enough, but I don't\n                     // think any errors can be introduced by using\n                     // `demand::eqtype`.\n-                    self.demand_eqtype_pat(pat.span, expected, uniq_ty, match_discrim_span);\n-                    self.check_pat_walk(&inner, inner_ty, def_bm, match_discrim_span);\n+                    self.demand_eqtype_pat(pat.span, expected, uniq_ty, discrim_span);\n+                    self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n                     uniq_ty\n                 } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n                     tcx.types.err\n                 }\n             }\n@@ -384,10 +389,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     };\n \n-                    self.check_pat_walk(&inner, inner_ty, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n                     rptr_ty\n                 } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n                     tcx.types.err\n                 }\n             }\n@@ -445,13 +450,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n \n                 for elt in before {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n                 }\n                 if let Some(ref slice) = *slice {\n-                    self.check_pat_walk(&slice, slice_ty, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&slice, slice_ty, def_bm, discrim_span);\n                 }\n                 for elt in after {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, match_discrim_span);\n+                    self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n                 }\n                 expected_ty\n             }\n@@ -595,73 +600,26 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n-        // Not entirely obvious: if matches may create ref bindings, we want to\n-        // use the *precise* type of the discriminant, *not* some supertype, as\n-        // the \"discriminant type\" (issue #23116).\n-        //\n-        // arielb1 [writes here in this comment thread][c] that there\n-        // is certainly *some* potential danger, e.g., for an example\n-        // like:\n-        //\n-        // [c]: https://github.com/rust-lang/rust/pull/43399#discussion_r130223956\n-        //\n-        // ```\n-        // let Foo(x) = f()[0];\n-        // ```\n-        //\n-        // Then if the pattern matches by reference, we want to match\n-        // `f()[0]` as a lexpr, so we can't allow it to be\n-        // coerced. But if the pattern matches by value, `f()[0]` is\n-        // still syntactically a lexpr, but we *do* want to allow\n-        // coercions.\n-        //\n-        // However, *likely* we are ok with allowing coercions to\n-        // happen if there are no explicit ref mut patterns - all\n-        // implicit ref mut patterns must occur behind a reference, so\n-        // they will have the \"correct\" variance and lifetime.\n-        //\n-        // This does mean that the following pattern would be legal:\n-        //\n-        // ```\n-        // struct Foo(Bar);\n-        // struct Bar(u32);\n-        // impl Deref for Foo {\n-        //     type Target = Bar;\n-        //     fn deref(&self) -> &Bar { &self.0 }\n-        // }\n-        // impl DerefMut for Foo {\n-        //     fn deref_mut(&mut self) -> &mut Bar { &mut self.0 }\n-        // }\n-        // fn foo(x: &mut Foo) {\n-        //     {\n-        //         let Bar(z): &mut Bar = x;\n-        //         *z = 42;\n-        //     }\n-        //     assert_eq!(foo.0.0, 42);\n-        // }\n-        // ```\n-        //\n-        // FIXME(tschottdorf): don't call contains_explicit_ref_binding, which\n-        // is problematic as the HIR is being scraped, but ref bindings may be\n-        // implicit after #42640. We need to make sure that pat_adjustments\n-        // (once introduced) is populated by the time we get here.\n-        //\n-        // See #44848.\n-        let contains_ref_bindings = arms.iter()\n-                                        .filter_map(|a| a.contains_explicit_ref_binding())\n-                                        .max_by_key(|m| match *m {\n-                                            hir::MutMutable => 1,\n-                                            hir::MutImmutable => 0,\n-                                        });\n-        let discrim_ty;\n-        if let Some(m) = contains_ref_bindings {\n-            discrim_ty = self.check_expr_with_needs(discrim, Needs::maybe_mut_place(m));\n+        use hir::MatchSource::*;\n+        let (source_if, if_no_else, if_desugar) = match match_src {\n+            IfDesugar { contains_else_clause } => (true, !contains_else_clause, true),\n+            IfLetDesugar { contains_else_clause } => (true, !contains_else_clause, false),\n+            _ => (false, false, false),\n+        };\n+\n+        // Type check the descriminant and get its type.\n+        let discrim_ty = if if_desugar {\n+            // Here we want to ensure:\n+            //\n+            // 1. That default match bindings are *not* accepted in the condition of an\n+            //    `if` expression. E.g. given `fn foo() -> &bool;` we reject `if foo() { .. }`.\n+            //\n+            // 2. By expecting `bool` for `expr` we get nice diagnostics for e.g. `if x = y { .. }`.\n+            //\n+            // FIXME(60707): Consider removing hack with principled solution.\n+            self.check_expr_has_type_or_error(discrim, self.tcx.types.bool)\n         } else {\n-            // ...but otherwise we want to use any supertype of the\n-            // discriminant. This is sort of a workaround, see note (*) in\n-            // `check_pat` for some details.\n-            discrim_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(discrim.span));\n-            self.check_expr_has_type_or_error(discrim, discrim_ty);\n+            self.demand_discriminant_type(arms, discrim)\n         };\n \n         // If there are no arms, that is a diverging match; a special case.\n@@ -670,11 +628,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             return tcx.types.never;\n         }\n \n-        if self.diverges.get().always() {\n-            for arm in arms {\n-                self.warn_if_unreachable(arm.body.hir_id, arm.body.span, \"arm\");\n-            }\n-        }\n+        self.warn_arms_when_scrutinee_diverges(arms, source_if);\n \n         // Otherwise, we have to union together the types that the\n         // arms produce and so forth.\n@@ -687,12 +641,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             let mut all_pats_diverge = Diverges::WarnedAlways;\n             for p in &arm.pats {\n                 self.diverges.set(Diverges::Maybe);\n-                self.check_pat_walk(\n-                    &p,\n-                    discrim_ty,\n-                    ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n-                    Some(discrim.span),\n-                );\n+                let binding_mode = ty::BindingMode::BindByValue(hir::Mutability::MutImmutable);\n+                self.check_pat_walk(&p, discrim_ty, binding_mode, Some(discrim.span));\n                 all_pats_diverge &= self.diverges.get();\n             }\n \n@@ -734,7 +684,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let mut other_arms = vec![];  // used only for diagnostics\n         let mut prior_arm_ty = None;\n         for (i, (arm, pats_diverge)) in arms.iter().zip(all_arm_pats_diverge).enumerate() {\n-            if let Some(ref g) = arm.guard {\n+            if let Some(g) = &arm.guard {\n                 self.diverges.set(pats_diverge);\n                 match g {\n                     hir::Guard::If(e) => self.check_expr_has_type_or_error(e, tcx.types.bool),\n@@ -745,43 +695,44 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n             all_arms_diverge &= self.diverges.get();\n \n-            // Handle the fallback arm of a desugared if-let like a missing else.\n-            let is_if_let_fallback = match match_src {\n-                hir::MatchSource::IfLetDesugar { contains_else_clause: false } => {\n-                    i == arms.len() - 1 && arm_ty.is_unit()\n+            let span = expr.span;\n+\n+            if source_if {\n+                let then_expr = &arms[0].body;\n+                match (i, if_no_else) {\n+                    (0, _) => coercion.coerce(self, &self.misc(span), then_expr, arm_ty),\n+                    (_, true) => self.if_fallback_coercion(span, then_expr, &mut coercion),\n+                    (_, _) => {\n+                        let then_ty = prior_arm_ty.unwrap();\n+                        let cause = self.if_cause(span, then_expr, &arm.body, then_ty, arm_ty);\n+                        coercion.coerce(self, &cause, &arm.body, arm_ty);\n+                    }\n                 }\n-                _ => false\n-            };\n-\n-            let arm_span = if let hir::ExprKind::Block(ref blk, _) = arm.body.node {\n-                // Point at the block expr instead of the entire block\n-                blk.expr.as_ref().map(|e| e.span).unwrap_or(arm.body.span)\n-            } else {\n-                arm.body.span\n-            };\n-            if is_if_let_fallback {\n-                let cause = self.cause(expr.span, ObligationCauseCode::IfExpressionWithNoElse);\n-                assert!(arm_ty.is_unit());\n-                coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n             } else {\n-                let cause = if i == 0 {\n+                let arm_span = if let hir::ExprKind::Block(blk, _) = &arm.body.node {\n+                    // Point at the block expr instead of the entire block\n+                    blk.expr.as_ref().map(|e| e.span).unwrap_or(arm.body.span)\n+                } else {\n+                    arm.body.span\n+                };\n+                let (span, code) = match i {\n                     // The reason for the first arm to fail is not that the match arms diverge,\n                     // but rather that there's a prior obligation that doesn't hold.\n-                    self.cause(arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id))\n-                } else {\n-                    self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {\n+                    0 => (arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id)),\n+                    _ => (span, ObligationCauseCode::MatchExpressionArm {\n                         arm_span,\n                         source: match_src,\n                         prior_arms: other_arms.clone(),\n                         last_ty: prior_arm_ty.unwrap(),\n                         discrim_hir_id: discrim.hir_id,\n-                    })\n+                    }),\n                 };\n+                let cause = self.cause(span, code);\n                 coercion.coerce(self, &cause, &arm.body, arm_ty);\n-            }\n-            other_arms.push(arm_span);\n-            if other_arms.len() > 5 {\n-                other_arms.remove(0);\n+                other_arms.push(arm_span);\n+                if other_arms.len() > 5 {\n+                    other_arms.remove(0);\n+                }\n             }\n             prior_arm_ty = Some(arm_ty);\n         }\n@@ -792,6 +743,251 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         coercion.complete(self)\n     }\n \n+    /// When the previously checked expression (the scrutinee) diverges,\n+    /// warn the user about the match arms being unreachable.\n+    fn warn_arms_when_scrutinee_diverges(&self, arms: &'gcx [hir::Arm], source_if: bool) {\n+        if self.diverges.get().always() {\n+            let msg = if source_if { \"block in `if` expression\" } else { \"arm\" };\n+            for arm in arms {\n+                self.warn_if_unreachable(arm.body.hir_id, arm.body.span, msg);\n+            }\n+        }\n+    }\n+\n+    /// Handle the fallback arm of a desugared if(-let) like a missing else.\n+    fn if_fallback_coercion(\n+        &self,\n+        span: Span,\n+        then_expr: &'gcx hir::Expr,\n+        coercion: &mut CoerceMany<'gcx, 'tcx, '_, rustc::hir::Arm>,\n+    ) {\n+        // If this `if` expr is the parent's function return expr,\n+        // the cause of the type coercion is the return type, point at it. (#25228)\n+        let ret_reason = self.maybe_get_coercion_reason(then_expr.hir_id, span);\n+        let cause = self.cause(span, ObligationCauseCode::IfExpressionWithNoElse);\n+        coercion.coerce_forced_unit(self, &cause, &mut |err| {\n+            if let Some((span, msg)) = &ret_reason {\n+                err.span_label(*span, msg.as_str());\n+            } else if let ExprKind::Block(block, _) = &then_expr.node {\n+                if let Some(expr) = &block.expr {\n+                    err.span_label(expr.span, \"found here\".to_string());\n+                }\n+            }\n+            err.note(\"`if` expressions without `else` evaluate to `()`\");\n+            err.help(\"consider adding an `else` block that evaluates to the expected type\");\n+        }, ret_reason.is_none());\n+    }\n+\n+    fn maybe_get_coercion_reason(&self, hir_id: hir::HirId, span: Span) -> Option<(Span, String)> {\n+        use hir::Node::{Block, Item, Local};\n+\n+        let node = self.tcx.hir().get_by_hir_id(self.tcx.hir().get_parent_node_by_hir_id(\n+            self.tcx.hir().get_parent_node_by_hir_id(hir_id),\n+        ));\n+        if let Block(block) = node {\n+            // check that the body's parent is an fn\n+            let parent = self.tcx.hir().get_by_hir_id(\n+                self.tcx.hir().get_parent_node_by_hir_id(\n+                    self.tcx.hir().get_parent_node_by_hir_id(block.hir_id),\n+                ),\n+            );\n+            if let (Some(expr), Item(hir::Item {\n+                node: hir::ItemKind::Fn(..), ..\n+            })) = (&block.expr, parent) {\n+                // check that the `if` expr without `else` is the fn body's expr\n+                if expr.span == span {\n+                    return self.get_fn_decl(hir_id).map(|(fn_decl, _)| (\n+                        fn_decl.output.span(),\n+                        format!(\"expected `{}` because of this return type\", fn_decl.output),\n+                    ));\n+                }\n+            }\n+        }\n+        if let Local(hir::Local { ty: Some(_), pat, .. }) = node {\n+            return Some((pat.span, \"expected because of this assignment\".to_string()));\n+        }\n+        None\n+    }\n+\n+    fn if_cause(\n+        &self,\n+        span: Span,\n+        then_expr: &'gcx hir::Expr,\n+        else_expr: &'gcx hir::Expr,\n+        then_ty: Ty<'tcx>,\n+        else_ty: Ty<'tcx>,\n+    ) -> ObligationCause<'tcx> {\n+        let mut outer_sp = if self.tcx.sess.source_map().is_multiline(span) {\n+            // The `if`/`else` isn't in one line in the output, include some context to make it\n+            // clear it is an if/else expression:\n+            // ```\n+            // LL |      let x = if true {\n+            //    | _____________-\n+            // LL ||         10i32\n+            //    ||         ----- expected because of this\n+            // LL ||     } else {\n+            // LL ||         10u32\n+            //    ||         ^^^^^ expected i32, found u32\n+            // LL ||     };\n+            //    ||_____- if and else have incompatible types\n+            // ```\n+            Some(span)\n+        } else {\n+            // The entire expression is in one line, only point at the arms\n+            // ```\n+            // LL |     let x = if true { 10i32 } else { 10u32 };\n+            //    |                       -----          ^^^^^ expected i32, found u32\n+            //    |                       |\n+            //    |                       expected because of this\n+            // ```\n+            None\n+        };\n+\n+        let mut remove_semicolon = None;\n+        let error_sp = if let ExprKind::Block(block, _) = &else_expr.node {\n+            if let Some(expr) = &block.expr {\n+                expr.span\n+            } else if let Some(stmt) = block.stmts.last() {\n+                // possibly incorrect trailing `;` in the else arm\n+                remove_semicolon = self.could_remove_semicolon(block, then_ty);\n+                stmt.span\n+            } else {  // empty block, point at its entirety\n+                // Avoid overlapping spans that aren't as readable:\n+                // ```\n+                // 2 |        let x = if true {\n+                //   |   _____________-\n+                // 3 |  |         3\n+                //   |  |         - expected because of this\n+                // 4 |  |     } else {\n+                //   |  |____________^\n+                // 5 | ||\n+                // 6 | ||     };\n+                //   | ||     ^\n+                //   | ||_____|\n+                //   | |______if and else have incompatible types\n+                //   |        expected integer, found ()\n+                // ```\n+                // by not pointing at the entire expression:\n+                // ```\n+                // 2 |       let x = if true {\n+                //   |               ------- if and else have incompatible types\n+                // 3 |           3\n+                //   |           - expected because of this\n+                // 4 |       } else {\n+                //   |  ____________^\n+                // 5 | |\n+                // 6 | |     };\n+                //   | |_____^ expected integer, found ()\n+                // ```\n+                if outer_sp.is_some() {\n+                    outer_sp = Some(self.tcx.sess.source_map().def_span(span));\n+                }\n+                else_expr.span\n+            }\n+        } else { // shouldn't happen unless the parser has done something weird\n+            else_expr.span\n+        };\n+\n+        // Compute `Span` of `then` part of `if`-expression:\n+        let then_sp = if let ExprKind::Block(block, _) = &then_expr.node {\n+            if let Some(expr) = &block.expr {\n+                expr.span\n+            } else if let Some(stmt) = block.stmts.last() {\n+                // possibly incorrect trailing `;` in the else arm\n+                remove_semicolon = remove_semicolon.or(self.could_remove_semicolon(block, else_ty));\n+                stmt.span\n+            } else {  // empty block, point at its entirety\n+                outer_sp = None;  // same as in `error_sp`, cleanup output\n+                then_expr.span\n+            }\n+        } else {  // shouldn't happen unless the parser has done something weird\n+            then_expr.span\n+        };\n+\n+        // Finally construct the cause:\n+        self.cause(error_sp, ObligationCauseCode::IfExpression {\n+            then: then_sp,\n+            outer: outer_sp,\n+            semicolon: remove_semicolon,\n+        })\n+    }\n+\n+    fn demand_discriminant_type(\n+        &self,\n+        arms: &'gcx [hir::Arm],\n+        discrim: &'gcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        // Not entirely obvious: if matches may create ref bindings, we want to\n+        // use the *precise* type of the discriminant, *not* some supertype, as\n+        // the \"discriminant type\" (issue #23116).\n+        //\n+        // arielb1 [writes here in this comment thread][c] that there\n+        // is certainly *some* potential danger, e.g., for an example\n+        // like:\n+        //\n+        // [c]: https://github.com/rust-lang/rust/pull/43399#discussion_r130223956\n+        //\n+        // ```\n+        // let Foo(x) = f()[0];\n+        // ```\n+        //\n+        // Then if the pattern matches by reference, we want to match\n+        // `f()[0]` as a lexpr, so we can't allow it to be\n+        // coerced. But if the pattern matches by value, `f()[0]` is\n+        // still syntactically a lexpr, but we *do* want to allow\n+        // coercions.\n+        //\n+        // However, *likely* we are ok with allowing coercions to\n+        // happen if there are no explicit ref mut patterns - all\n+        // implicit ref mut patterns must occur behind a reference, so\n+        // they will have the \"correct\" variance and lifetime.\n+        //\n+        // This does mean that the following pattern would be legal:\n+        //\n+        // ```\n+        // struct Foo(Bar);\n+        // struct Bar(u32);\n+        // impl Deref for Foo {\n+        //     type Target = Bar;\n+        //     fn deref(&self) -> &Bar { &self.0 }\n+        // }\n+        // impl DerefMut for Foo {\n+        //     fn deref_mut(&mut self) -> &mut Bar { &mut self.0 }\n+        // }\n+        // fn foo(x: &mut Foo) {\n+        //     {\n+        //         let Bar(z): &mut Bar = x;\n+        //         *z = 42;\n+        //     }\n+        //     assert_eq!(foo.0.0, 42);\n+        // }\n+        // ```\n+        //\n+        // FIXME(tschottdorf): don't call contains_explicit_ref_binding, which\n+        // is problematic as the HIR is being scraped, but ref bindings may be\n+        // implicit after #42640. We need to make sure that pat_adjustments\n+        // (once introduced) is populated by the time we get here.\n+        //\n+        // See #44848.\n+        let contains_ref_bindings = arms.iter()\n+                                        .filter_map(|a| a.contains_explicit_ref_binding())\n+                                        .max_by_key(|m| match *m {\n+                                            hir::MutMutable => 1,\n+                                            hir::MutImmutable => 0,\n+                                        });\n+\n+        if let Some(m) = contains_ref_bindings {\n+            self.check_expr_with_needs(discrim, Needs::maybe_mut_place(m))\n+        } else {\n+            // ...but otherwise we want to use any supertype of the\n+            // discriminant. This is sort of a workaround, see note (*) in\n+            // `check_pat` for some details.\n+            let discrim_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(discrim.span));\n+            self.check_expr_has_type_or_error(discrim, discrim_ty);\n+            discrim_ty\n+        }\n+    }\n+\n     fn check_pat_struct(\n         &self,\n         pat: &'gcx hir::Pat,\n@@ -800,7 +996,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         etc: bool,\n         expected: Ty<'tcx>,\n         def_bm: ty::BindingMode,\n-        match_discrim_span: Option<Span>,\n+        discrim_span: Option<Span>,\n     ) -> Ty<'tcx>\n     {\n         // Resolve the path and check the definition for errors.\n@@ -809,18 +1005,13 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             variant_ty\n         } else {\n             for field in fields {\n-                self.check_pat_walk(\n-                    &field.node.pat,\n-                    self.tcx.types.err,\n-                    def_bm,\n-                    match_discrim_span,\n-                );\n+                self.check_pat_walk(&field.node.pat, self.tcx.types.err, def_bm, discrim_span);\n             }\n             return self.tcx.types.err;\n         };\n \n         // Type-check the path.\n-        self.demand_eqtype_pat(pat.span, expected, pat_ty, match_discrim_span);\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, discrim_span);\n \n         // Type-check subpatterns.\n         if self.check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm)"}, {"sha": "90b2643d165bea7f2ab6e23cfacbb56ae5a53a85", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -68,6 +68,7 @@ use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n use syntax::feature_gate;\n use syntax::ptr::P;\n+use syntax::symbol::sym;\n use syntax_pos;\n \n struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -620,7 +621,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         if has_unsized_tuple_coercion && !self.tcx.features().unsized_tuple_coercion {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n-                                           \"unsized_tuple_coercion\",\n+                                           sym::unsized_tuple_coercion,\n                                            self.cause.span,\n                                            feature_gate::GateIssue::Language,\n                                            feature_gate::EXPLAIN_UNSIZED_TUPLE_COERCION);\n@@ -1248,12 +1249,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                     augment_error(&mut db);\n                 }\n \n-                if expression.filter(|e| fcx.is_assign_to_bool(e, expected)).is_some() {\n-                    // Error reported in `check_assign` so avoid emitting error again.\n-                    db.delay_as_bug();\n-                } else {\n-                    db.emit();\n-                }\n+                // Error possibly reported in `check_assign` so avoid emitting error again.\n+                db.emit_unless(expression.filter(|e| fcx.is_assign_to_bool(e, expected)).is_some());\n \n                 self.final_ty = Some(fcx.tcx.types.err);\n             }"}, {"sha": "8d68179b495c6015738344919f05b2af1a07daca", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -2,6 +2,7 @@ use crate::check::FnCtxt;\n use rustc::infer::InferOk;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n \n+use syntax::symbol::sym;\n use syntax::util::parser::PREC_POSTFIX;\n use syntax_pos::Span;\n use rustc::hir;\n@@ -197,7 +198,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 //\n                 // FIXME? Other potential candidate methods: `as_ref` and\n                 // `as_mut`?\n-                .find(|a| a.check_name(\"rustc_conversion_suggestion\")).is_some()\n+                .find(|a| a.check_name(sym::rustc_conversion_suggestion)).is_some()\n         });\n \n         methods"}, {"sha": "c6191e6b579ce45c036876db9c47656585997c97", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::subst::Subst;\n use crate::require_same_types;\n \n use rustc_target::spec::abi::Abi;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::InternedString;\n \n use rustc::hir;\n \n@@ -80,7 +80,7 @@ pub fn intrisic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n /// and in libcore/intrinsics.rs\n pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       it: &hir::ForeignItem) {\n-    let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)).as_interned_str());\n+    let param = |n| tcx.mk_ty_param(n, InternedString::intern(&format!(\"P{}\", n)));\n     let name = it.ident.as_str();\n \n     let mk_va_list_ty = || {\n@@ -397,7 +397,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                it: &hir::ForeignItem) {\n     let param = |n| {\n-        let name = Symbol::intern(&format!(\"P{}\", n)).as_interned_str();\n+        let name = InternedString::intern(&format!(\"P{}\", n));\n         tcx.mk_ty_param(n, name)\n     };\n "}, {"sha": "77d2ffab8efb4e1bb32c8b9a64f52afe2c9b10f8", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -91,14 +91,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     CandidateSource::ImplSource(impl_did) => {\n                         // Provide the best span we can. Use the item, if local to crate, else\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n-                        let item = self.associated_item(impl_did, item_name, Namespace::Value)\n-                            .or_else(|| {\n-                                self.associated_item(\n-                                    self.tcx.impl_trait_ref(impl_did).unwrap().def_id,\n-                                    item_name,\n-                                    Namespace::Value,\n-                                )\n-                            }).unwrap();\n+                        let item = match self.associated_item(\n+                            impl_did,\n+                            item_name,\n+                            Namespace::Value,\n+                        ).or_else(|| {\n+                            let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n+                            self.associated_item(\n+                                impl_trait_ref.def_id,\n+                                item_name,\n+                                Namespace::Value,\n+                            )\n+                        }) {\n+                            Some(item) => item,\n+                            None => continue,\n+                        };\n                         let note_span = self.tcx.hir().span_if_local(item.def_id).or_else(|| {\n                             self.tcx.hir().span_if_local(impl_did)\n                         });\n@@ -132,9 +139,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n-                        let item = self\n-                            .associated_item(trait_did, item_name, Namespace::Value)\n-                            .unwrap();\n+                        let item = match self.associated_item(\n+                            trait_did,\n+                            item_name,\n+                            Namespace::Value)\n+                        {\n+                            Some(item) => item,\n+                            None => continue,\n+                        };\n                         let item_span = self.tcx.sess.source_map()\n                             .def_span(self.tcx.def_span(item.def_id));\n                         if sources.len() > 1 {\n@@ -251,8 +263,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 if let &QPath::Resolved(_, ref path) = &qpath {\n                                     if let hir::def::Res::Local(hir_id) = path.res {\n                                         let span = tcx.hir().span_by_hir_id(hir_id);\n-                                        let snippet = tcx.sess.source_map().span_to_snippet(span)\n-                                            .unwrap();\n+                                        let snippet = tcx.sess.source_map().span_to_snippet(span);\n                                         let filename = tcx.sess.source_map().span_to_filename(span);\n \n                                         let parent_node = self.tcx.hir().get_by_hir_id(\n@@ -263,12 +274,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             concrete_type,\n                                         );\n \n-                                        match (filename, parent_node) {\n+                                        match (filename, parent_node, snippet) {\n                                             (FileName::Real(_), Node::Local(hir::Local {\n                                                 source: hir::LocalSource::Normal,\n                                                 ty,\n                                                 ..\n-                                            })) => {\n+                                            }), Ok(ref snippet)) => {\n                                                 err.span_suggestion(\n                                                     // account for `let x: _ = 42;`\n                                                     //                  ^^^^\n@@ -375,14 +386,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     self.tcx.hir().get_parent_node_by_hir_id(expr.hir_id),\n                                 );\n \n-                                let span = call_expr.span.trim_start(item_name.span).unwrap();\n-\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"remove the arguments\",\n-                                    String::new(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n+                                if let Some(span) = call_expr.span.trim_start(item_name.span) {\n+                                    err.span_suggestion(\n+                                        span,\n+                                        \"remove the arguments\",\n+                                        String::new(),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                }\n                             }\n                         }\n "}, {"sha": "362b6f0504d99aed306f7bba354acad944a04182", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 27, "deletions": 220, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -117,12 +117,13 @@ use rustc::ty::subst::{UnpackedKind, Subst, InternalSubsts, SubstsRef, UserSelfT\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n use rustc::ty::layout::VariantIdx;\n use syntax_pos::{self, BytePos, Span, MultiSpan};\n+use syntax_pos::hygiene::CompilerDesugaringKind;\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::source_map::{DUMMY_SP, original_sp};\n-use syntax::symbol::{Symbol, LocalInternedString, keywords};\n+use syntax::symbol::{Symbol, LocalInternedString, keywords, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::cell::{Cell, RefCell, Ref, RefMut};\n@@ -1086,12 +1087,8 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     // Add formal parameters.\n     for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n         // Check the pattern.\n-        fcx.check_pat_walk(\n-            &arg.pat,\n-            arg_ty,\n-            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n-            None,\n-        );\n+        let binding_mode = ty::BindingMode::BindByValue(hir::Mutability::MutImmutable);\n+        fcx.check_pat_walk(&arg.pat, arg_ty, binding_mode, None);\n \n         // Check that argument is Sized.\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n@@ -1843,7 +1840,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if vs.is_empty() {\n         let attributes = tcx.get_attrs(def_id);\n-        if let Some(attr) = attr::find_by_name(&attributes, \"repr\") {\n+        if let Some(attr) = attr::find_by_name(&attributes, sym::repr) {\n             struct_span_err!(\n                 tcx.sess, attr.span, E0084,\n                 \"unsupported representation for zero-variant enum\")\n@@ -1856,7 +1853,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if repr_type_ty == tcx.types.i128 || repr_type_ty == tcx.types.u128 {\n         if !tcx.features().repr128 {\n             emit_feature_err(&tcx.sess.parse_sess,\n-                             \"repr128\",\n+                             sym::repr128,\n                              sp,\n                              GateIssue::Language,\n                              \"repr with 128-bit type is unstable\");\n@@ -2045,15 +2042,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Produces warning on the given node, if the current point in the\n     /// function is unreachable, and there hasn't been another warning.\n     fn warn_if_unreachable(&self, id: hir::HirId, span: Span, kind: &str) {\n-        if self.diverges.get() == Diverges::Always {\n+        if self.diverges.get() == Diverges::Always &&\n+            // If span arose from a desugaring of `if` then it is the condition itself,\n+            // which diverges, that we are about to lint on. This gives suboptimal diagnostics\n+            // and so we stop here and allow the block of the `if`-expression to be linted instead.\n+            !span.is_compiler_desugaring(CompilerDesugaringKind::IfTemporary) {\n             self.diverges.set(Diverges::WarnedAlways);\n \n             debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);\n \n-            self.tcx().lint_hir(\n-                lint::builtin::UNREACHABLE_CODE,\n-                id, span,\n-                &format!(\"unreachable {}\", kind));\n+            let msg = format!(\"unreachable {}\", kind);\n+            self.tcx().lint_hir(lint::builtin::UNREACHABLE_CODE, id, span, &msg);\n         }\n     }\n \n@@ -3084,7 +3083,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     // AST fragment checking\n     fn check_lit(&self,\n-                 lit: &ast::Lit,\n+                 lit: &hir::Lit,\n                  expected: Expectation<'tcx>)\n                  -> Ty<'tcx>\n     {\n@@ -3161,13 +3160,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            if self.is_assign_to_bool(expr, expected_ty) {\n-                // Error reported in `check_assign` so avoid emitting error again.\n-                // FIXME(centril): Consider removing if/when `if` desugars to `match`.\n-                err.delay_as_bug();\n-            } else {\n-                err.emit();\n-            }\n+            let expr = match &expr.node {\n+                ExprKind::DropTemps(expr) => expr,\n+                _ => expr,\n+            };\n+            // Error possibly reported in `check_assign` so avoid emitting error again.\n+            err.emit_unless(self.is_assign_to_bool(expr, expected_ty));\n         }\n         ty\n     }\n@@ -3330,194 +3328,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             return_expr_ty);\n     }\n \n-    // A generic function for checking the 'then' and 'else' clauses in an 'if'\n-    // or 'if-else' expression.\n-    fn check_then_else(&self,\n-                       cond_expr: &'gcx hir::Expr,\n-                       then_expr: &'gcx hir::Expr,\n-                       opt_else_expr: Option<&'gcx hir::Expr>,\n-                       sp: Span,\n-                       expected: Expectation<'tcx>) -> Ty<'tcx> {\n-        let cond_ty = self.check_expr_has_type_or_error(cond_expr, self.tcx.types.bool);\n-        let cond_diverges = self.diverges.get();\n-        self.diverges.set(Diverges::Maybe);\n-\n-        let expected = expected.adjust_for_branches(self);\n-        let then_ty = self.check_expr_with_expectation(then_expr, expected);\n-        let then_diverges = self.diverges.get();\n-        self.diverges.set(Diverges::Maybe);\n-\n-        // We've already taken the expected type's preferences\n-        // into account when typing the `then` branch. To figure\n-        // out the initial shot at a LUB, we thus only consider\n-        // `expected` if it represents a *hard* constraint\n-        // (`only_has_type`); otherwise, we just go with a\n-        // fresh type variable.\n-        let coerce_to_ty = expected.coercion_target_type(self, sp);\n-        let mut coerce: DynamicCoerceMany<'_, '_> = CoerceMany::new(coerce_to_ty);\n-\n-        coerce.coerce(self, &self.misc(sp), then_expr, then_ty);\n-\n-        if let Some(else_expr) = opt_else_expr {\n-            let else_ty = self.check_expr_with_expectation(else_expr, expected);\n-            let else_diverges = self.diverges.get();\n-\n-            let mut outer_sp = if self.tcx.sess.source_map().is_multiline(sp) {\n-                // The `if`/`else` isn't in one line in the output, include some context to make it\n-                // clear it is an if/else expression:\n-                // ```\n-                // LL |      let x = if true {\n-                //    | _____________-\n-                // LL ||         10i32\n-                //    ||         ----- expected because of this\n-                // LL ||     } else {\n-                // LL ||         10u32\n-                //    ||         ^^^^^ expected i32, found u32\n-                // LL ||     };\n-                //    ||_____- if and else have incompatible types\n-                // ```\n-                Some(sp)\n-            } else {\n-                // The entire expression is in one line, only point at the arms\n-                // ```\n-                // LL |     let x = if true { 10i32 } else { 10u32 };\n-                //    |                       -----          ^^^^^ expected i32, found u32\n-                //    |                       |\n-                //    |                       expected because of this\n-                // ```\n-                None\n-            };\n-            let mut remove_semicolon = None;\n-            let error_sp = if let ExprKind::Block(block, _) = &else_expr.node {\n-                if let Some(expr) = &block.expr {\n-                    expr.span\n-                } else if let Some(stmt) = block.stmts.last() {\n-                    // possibly incorrect trailing `;` in the else arm\n-                    remove_semicolon = self.could_remove_semicolon(block, then_ty);\n-                    stmt.span\n-                } else {  // empty block, point at its entirety\n-                    // Avoid overlapping spans that aren't as readable:\n-                    // ```\n-                    // 2 |        let x = if true {\n-                    //   |   _____________-\n-                    // 3 |  |         3\n-                    //   |  |         - expected because of this\n-                    // 4 |  |     } else {\n-                    //   |  |____________^\n-                    // 5 | ||\n-                    // 6 | ||     };\n-                    //   | ||     ^\n-                    //   | ||_____|\n-                    //   | |______if and else have incompatible types\n-                    //   |        expected integer, found ()\n-                    // ```\n-                    // by not pointing at the entire expression:\n-                    // ```\n-                    // 2 |       let x = if true {\n-                    //   |               ------- if and else have incompatible types\n-                    // 3 |           3\n-                    //   |           - expected because of this\n-                    // 4 |       } else {\n-                    //   |  ____________^\n-                    // 5 | |\n-                    // 6 | |     };\n-                    //   | |_____^ expected integer, found ()\n-                    // ```\n-                    if outer_sp.is_some() {\n-                        outer_sp = Some(self.tcx.sess.source_map().def_span(sp));\n-                    }\n-                    else_expr.span\n-                }\n-            } else { // shouldn't happen unless the parser has done something weird\n-                else_expr.span\n-            };\n-            let then_sp = if let ExprKind::Block(block, _) = &then_expr.node {\n-                if let Some(expr) = &block.expr {\n-                    expr.span\n-                } else if let Some(stmt) = block.stmts.last() {\n-                    // possibly incorrect trailing `;` in the else arm\n-                    remove_semicolon = remove_semicolon.or(\n-                        self.could_remove_semicolon(block, else_ty));\n-                    stmt.span\n-                } else {  // empty block, point at its entirety\n-                    outer_sp = None;  // same as in `error_sp`, cleanup output\n-                    then_expr.span\n-                }\n-            } else {  // shouldn't happen unless the parser has done something weird\n-                then_expr.span\n-            };\n-\n-            let if_cause = self.cause(error_sp, ObligationCauseCode::IfExpression {\n-                then: then_sp,\n-                outer: outer_sp,\n-                semicolon: remove_semicolon,\n-            });\n-\n-            coerce.coerce(self, &if_cause, else_expr, else_ty);\n-\n-            // We won't diverge unless both branches do (or the condition does).\n-            self.diverges.set(cond_diverges | then_diverges & else_diverges);\n-        } else {\n-            // If this `if` expr is the parent's function return expr, the cause of the type\n-            // coercion is the return type, point at it. (#25228)\n-            let ret_reason = self.maybe_get_coercion_reason(then_expr.hir_id, sp);\n-\n-            let else_cause = self.cause(sp, ObligationCauseCode::IfExpressionWithNoElse);\n-            coerce.coerce_forced_unit(self, &else_cause, &mut |err| {\n-                if let Some((sp, msg)) = &ret_reason {\n-                    err.span_label(*sp, msg.as_str());\n-                } else if let ExprKind::Block(block, _) = &then_expr.node {\n-                    if let Some(expr) = &block.expr {\n-                        err.span_label(expr.span, \"found here\".to_string());\n-                    }\n-                }\n-                err.note(\"`if` expressions without `else` evaluate to `()`\");\n-                err.help(\"consider adding an `else` block that evaluates to the expected type\");\n-            }, ret_reason.is_none());\n-\n-            // If the condition is false we can't diverge.\n-            self.diverges.set(cond_diverges);\n-        }\n-\n-        let result_ty = coerce.complete(self);\n-        if cond_ty.references_error() {\n-            self.tcx.types.err\n-        } else {\n-            result_ty\n-        }\n-    }\n-\n-    fn maybe_get_coercion_reason(&self, hir_id: hir::HirId, sp: Span) -> Option<(Span, String)> {\n-        let node = self.tcx.hir().get_by_hir_id(self.tcx.hir().get_parent_node_by_hir_id(\n-            self.tcx.hir().get_parent_node_by_hir_id(hir_id),\n-        ));\n-        if let Node::Block(block) = node {\n-            // check that the body's parent is an fn\n-            let parent = self.tcx.hir().get_by_hir_id(\n-                self.tcx.hir().get_parent_node_by_hir_id(\n-                    self.tcx.hir().get_parent_node_by_hir_id(block.hir_id),\n-                ),\n-            );\n-            if let (Some(expr), Node::Item(hir::Item {\n-                node: hir::ItemKind::Fn(..), ..\n-            })) = (&block.expr, parent) {\n-                // check that the `if` expr without `else` is the fn body's expr\n-                if expr.span == sp {\n-                    return self.get_fn_decl(hir_id).map(|(fn_decl, _)| (\n-                        fn_decl.output.span(),\n-                        format!(\"expected `{}` because of this return type\", fn_decl.output),\n-                    ));\n-                }\n-            }\n-        }\n-        if let Node::Local(hir::Local {\n-            ty: Some(_), pat, ..\n-        }) = node {\n-            return Some((pat.span, \"expected because of this assignment\".to_string()));\n-        }\n-        None\n-    }\n-\n     // Check field access expressions\n     fn check_field(&self,\n                    expr: &'gcx hir::Expr,\n@@ -4062,7 +3872,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match expr.node {\n             ExprKind::Block(..) |\n             ExprKind::Loop(..) | ExprKind::While(..) |\n-            ExprKind::If(..) | ExprKind::Match(..) => {}\n+            ExprKind::Match(..) => {}\n \n             _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\")\n         }\n@@ -4387,7 +4197,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // ... except when we try to 'break rust;'.\n                         // ICE this expression in particular (see #43162).\n                         if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n-                            if path.segments.len() == 1 && path.segments[0].ident.name == \"rust\" {\n+                            if path.segments.len() == 1 &&\n+                               path.segments[0].ident.name == sym::rust {\n                                 fatally_break_rust(self.tcx.sess);\n                             }\n                         }\n@@ -4444,10 +4255,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.check_assign(expr, expected, lhs, rhs)\n             }\n-            ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n-                self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n-                                     expr.span, expected)\n-            }\n             ExprKind::While(ref cond, ref body, _) => {\n                 let ctxt = BreakableCtxt {\n                     // cannot use break with a value from a while loop\n@@ -5261,7 +5068,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match expression.node {\n                 ExprKind::Call(..) |\n                 ExprKind::MethodCall(..) |\n-                ExprKind::If(..) |\n                 ExprKind::While(..) |\n                 ExprKind::Loop(..) |\n                 ExprKind::Match(..) |\n@@ -5669,10 +5475,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match self.at(&self.misc(span), self.param_env).sup(impl_ty, self_ty) {\n                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {\n-                    span_bug!(span,\n+                    self.tcx.sess.delay_span_bug(span, &format!(\n                         \"instantiate_value_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n                         self_ty,\n-                        impl_ty);\n+                        impl_ty,\n+                    ));\n                 }\n             }\n         }\n@@ -5693,7 +5500,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                       span: Span) {\n         // We're only interested in functions tagged with\n         // #[rustc_args_required_const], so ignore anything that's not.\n-        if !self.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n+        if !self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n             return\n         }\n "}, {"sha": "cd207478f8f6f86e5c701df44e4257a01b2d7761", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 60, "deletions": 23, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -305,8 +305,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             };\n                             if let Some(missing_trait) = missing_trait {\n                                 if op.node == hir::BinOpKind::Add &&\n-                                    self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n-                                                            rhs_ty, &mut err, true, op) {\n+                                    self.check_str_addition(\n+                                        lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, true, op) {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" += \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n@@ -400,8 +400,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             };\n                             if let Some(missing_trait) = missing_trait {\n                                 if op.node == hir::BinOpKind::Add &&\n-                                    self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n-                                                            rhs_ty, &mut err, false, op) {\n+                                    self.check_str_addition(\n+                                        lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, false, op) {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n@@ -502,9 +502,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         false\n     }\n \n+    /// Provide actionable suggestions when trying to add two strings with incorrect types,\n+    /// like `&str + &str`, `String + String` and `&str + &String`.\n+    ///\n+    /// If this function returns `true` it means a note was printed, so we don't need\n+    /// to print the normal \"implementation of `std::ops::Add` might be missing\" note\n     fn check_str_addition(\n         &self,\n-        expr: &'gcx hir::Expr,\n         lhs_expr: &'gcx hir::Expr,\n         rhs_expr: &'gcx hir::Expr,\n         lhs_ty: Ty<'tcx>,\n@@ -514,45 +518,78 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         op: hir::BinOp,\n     ) -> bool {\n         let source_map = self.tcx.sess.source_map();\n+        let remove_borrow_msg = \"String concatenation appends the string on the right to the \\\n+                                 string on the left and may require reallocation. This \\\n+                                 requires ownership of the string on the left\";\n+\n         let msg = \"`to_owned()` can be used to create an owned `String` \\\n                    from a string reference. String concatenation \\\n                    appends the string on the right to the string \\\n                    on the left and may require reallocation. This \\\n                    requires ownership of the string on the left\";\n-        // If this function returns true it means a note was printed, so we don't need\n-        // to print the normal \"implementation of `std::ops::Add` might be missing\" note\n+\n+        let is_std_string = |ty| &format!(\"{:?}\", ty) == \"std::string::String\";\n+\n         match (&lhs_ty.sty, &rhs_ty.sty) {\n-            (&Ref(_, l_ty, _), &Ref(_, r_ty, _))\n-            if l_ty.sty == Str && r_ty.sty == Str => {\n-                if !is_assign {\n-                    err.span_label(op.span,\n-                                   \"`+` can't be used to concatenate two `&str` strings\");\n+            (&Ref(_, l_ty, _), &Ref(_, r_ty, _)) // &str or &String + &str, &String or &&str\n+                if (l_ty.sty == Str || is_std_string(l_ty)) && (\n+                        r_ty.sty == Str || is_std_string(r_ty) ||\n+                        &format!(\"{:?}\", rhs_ty) == \"&&str\"\n+                    ) =>\n+            {\n+                if !is_assign { // Do not supply this message if `&str += &str`\n+                    err.span_label(\n+                        op.span,\n+                        \"`+` cannot be used to concatenate two `&str` strings\",\n+                    );\n                     match source_map.span_to_snippet(lhs_expr.span) {\n-                        Ok(lstring) => err.span_suggestion(\n-                            lhs_expr.span,\n-                            msg,\n-                            format!(\"{}.to_owned()\", lstring),\n-                            Applicability::MachineApplicable,\n-                        ),\n+                        Ok(lstring) => {\n+                            err.span_suggestion(\n+                                lhs_expr.span,\n+                                if lstring.starts_with(\"&\") {\n+                                    remove_borrow_msg\n+                                } else {\n+                                    msg\n+                                },\n+                                if lstring.starts_with(\"&\") {\n+                                    // let a = String::new();\n+                                    // let _ = &a + \"bar\";\n+                                    format!(\"{}\", &lstring[1..])\n+                                } else {\n+                                    format!(\"{}.to_owned()\", lstring)\n+                                },\n+                                Applicability::MachineApplicable,\n+                            )\n+                        }\n                         _ => err.help(msg),\n                     };\n                 }\n                 true\n             }\n-            (&Ref(_, l_ty, _), &Adt(..))\n-            if l_ty.sty == Str && &format!(\"{:?}\", rhs_ty) == \"std::string::String\" => {\n-                err.span_label(expr.span,\n-                    \"`+` can't be used to concatenate a `&str` with a `String`\");\n+            (&Ref(_, l_ty, _), &Adt(..)) // Handle `&str` & `&String` + `String`\n+                if (l_ty.sty == Str || is_std_string(l_ty)) && is_std_string(rhs_ty) =>\n+            {\n+                err.span_label(\n+                    op.span,\n+                    \"`+` cannot be used to concatenate a `&str` with a `String`\",\n+                );\n                 match (\n                     source_map.span_to_snippet(lhs_expr.span),\n                     source_map.span_to_snippet(rhs_expr.span),\n                     is_assign,\n                 ) {\n                     (Ok(l), Ok(r), false) => {\n+                        let to_string = if l.starts_with(\"&\") {\n+                            // let a = String::new(); let b = String::new();\n+                            // let _ = &a + b;\n+                            format!(\"{}\", &l[1..])\n+                        } else {\n+                            format!(\"{}.to_owned()\", l)\n+                        };\n                         err.multipart_suggestion(\n                             msg,\n                             vec![\n-                                (lhs_expr.span, format!(\"{}.to_owned()\", l)),\n+                                (lhs_expr.span, to_string),\n                                 (rhs_expr.span, format!(\"&{}\", r)),\n                             ],\n                             Applicability::MachineApplicable,"}, {"sha": "b009c8ea6dce17a3d28b22da83ac9f2eb1fab053", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -13,6 +13,7 @@ use rustc::infer::opaque_types::may_define_existential_type;\n use syntax::ast;\n use syntax::feature_gate::{self, GateIssue};\n use syntax_pos::Span;\n+use syntax::symbol::sym;\n use errors::{DiagnosticBuilder, DiagnosticId};\n \n use rustc::hir::itemlikevisit::ParItemLikeVisitor;\n@@ -796,7 +797,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                 // report error, would have worked with arbitrary_self_types\n                 feature_gate::feature_err(\n                     &fcx.tcx.sess.parse_sess,\n-                    \"arbitrary_self_types\",\n+                    sym::arbitrary_self_types,\n                     span,\n                     GateIssue::Language,\n                     &format!("}, {"sha": "13baf667808f817293c72f6f13ed44dac147ae29", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -16,6 +16,7 @@ use rustc::mir::interpret::ConstValue;\n use rustc::util::nodemap::DefIdSet;\n use rustc_data_structures::sync::Lrc;\n use std::mem;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -36,8 +37,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let item_def_id = self.tcx.hir().local_def_id(item_id);\n \n         // This attribute causes us to dump some writeback information\n-        // in the form of errors, which is used for unit tests.\n-        let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, \"rustc_dump_user_substs\");\n+        // in the form of errors, which is uSymbolfor unit tests.\n+        let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, sym::rustc_dump_user_substs);\n \n         let mut wbcx = WritebackCx::new(self, body, rustc_dump_user_substs);\n         for arg in &body.arguments {\n@@ -465,6 +466,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             let hir_id = self.tcx().hir().as_local_hir_id(def_id).unwrap();\n             let instantiated_ty = self.resolve(&opaque_defn.concrete_ty, &hir_id);\n \n+            debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n+\n             let generics = self.tcx().generics_of(def_id);\n \n             let definition_ty = if generics.parent.is_some() {\n@@ -523,8 +526,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     },\n                     lt_op: |region| {\n                         match region {\n-                            // ignore static regions\n-                            ty::ReStatic => region,\n+                            // Skip static and bound regions: they don't\n+                            // require substitution.\n+                            ty::ReStatic | ty::ReLateBound(..) => region,\n                             _ => {\n                                 trace!(\"checking {:?}\", region);\n                                 for (subst, p) in opaque_defn.substs.iter().zip(&generics.params) {\n@@ -611,26 +615,33 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            let new = ty::ResolvedOpaqueTy {\n-                concrete_type: definition_ty,\n-                substs: self.tcx().lift_to_global(&opaque_defn.substs).unwrap(),\n-            };\n-\n-            let old = self.tables\n-                .concrete_existential_types\n-                .insert(def_id, new);\n-            if let Some(old) = old {\n-                if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n-                    span_bug!(\n-                        span,\n-                        \"visit_opaque_types tried to write \\\n-                        different types for the same existential type: {:?}, {:?}, {:?}, {:?}\",\n-                        def_id,\n-                        definition_ty,\n-                        opaque_defn,\n-                        old,\n-                    );\n+            if let Some(substs) = self.tcx().lift_to_global(&opaque_defn.substs) {\n+                let new = ty::ResolvedOpaqueTy {\n+                    concrete_type: definition_ty,\n+                    substs,\n+                };\n+\n+                let old = self.tables\n+                    .concrete_existential_types\n+                    .insert(def_id, new);\n+                if let Some(old) = old {\n+                    if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n+                        span_bug!(\n+                            span,\n+                            \"visit_opaque_types tried to write \\\n+                            different types for the same existential type: {:?}, {:?}, {:?}, {:?}\",\n+                            def_id,\n+                            definition_ty,\n+                            opaque_defn,\n+                            old,\n+                        );\n+                    }\n                 }\n+            } else {\n+                self.tcx().sess.delay_span_bug(\n+                    span,\n+                    \"cannot lift `opaque_defn` substs to global type context\",\n+                );\n             }\n         }\n     }"}, {"sha": "3c3509f24ce1eb97000433d6245363ec14f114dd", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -158,6 +158,13 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n             continue;\n         }\n \n+        // If the extern crate is renamed, then we cannot suggest replacing it with a use as this\n+        // would not insert the new name into the prelude, where other imports in the crate may be\n+        // expecting it.\n+        if extern_crate.orig_name.is_some() {\n+            continue;\n+        }\n+\n         // If the extern crate has any attributes, they may have funky\n         // semantics we can't faithfully represent using `use` (most\n         // notably `#[macro_use]`). Ignore it."}, {"sha": "a9951c7fe447952616e1854e649f4f9ae2f92685", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -5,8 +5,6 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::traits::{self, IntercrateMode};\n use rustc::ty::TyCtxt;\n \n-use crate::lint;\n-\n pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);\n@@ -20,8 +18,7 @@ struct InherentOverlapChecker<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n     fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n-                                       overlap: traits::OverlapResult<'_>,\n-                                       used_to_be_allowed: bool) {\n+                                       overlap: traits::OverlapResult<'_>) {\n \n         let name_and_namespace = |def_id| {\n             let item = self.tcx.associated_item(def_id);\n@@ -36,22 +33,12 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n-                    let hir_id = self.tcx.hir().as_local_hir_id(impl1);\n-                    let mut err = if used_to_be_allowed && hir_id.is_some() {\n-                        self.tcx.struct_span_lint_hir(\n-                            lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n-                            hir_id.unwrap(),\n-                            self.tcx.span_of_impl(item1).unwrap(),\n-                            &format!(\"duplicate definitions with name `{}` (E0592)\", name)\n-                        )\n-                    } else {\n+                    let mut err =\n                         struct_span_err!(self.tcx.sess,\n                                          self.tcx.span_of_impl(item1).unwrap(),\n                                          E0592,\n                                          \"duplicate definitions with name `{}`\",\n-                                         name)\n-                    };\n-\n+                                         name);\n                     err.span_label(self.tcx.span_of_impl(item1).unwrap(),\n                                    format!(\"duplicate definitions for `{}`\", name));\n                     err.span_label(self.tcx.span_of_impl(item2).unwrap(),\n@@ -76,7 +63,7 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                let used_to_be_allowed = traits::overlapping_impls(\n+                traits::overlapping_impls(\n                     self.tcx,\n                     impl1_def_id,\n                     impl2_def_id,\n@@ -86,28 +73,11 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n                             impl1_def_id,\n                             impl2_def_id,\n                             overlap,\n-                            false,\n                         );\n                         false\n                     },\n                     || true,\n                 );\n-\n-                if used_to_be_allowed {\n-                    traits::overlapping_impls(\n-                        self.tcx,\n-                        impl1_def_id,\n-                        impl2_def_id,\n-                        IntercrateMode::Fixed,\n-                        |overlap| self.check_for_common_items_in_impls(\n-                            impl1_def_id,\n-                            impl2_def_id,\n-                            overlap,\n-                            true,\n-                        ),\n-                        || (),\n-                    );\n-                }\n             }\n         }\n     }"}, {"sha": "711d79f95f53a658d42a1fff866a78c9a78ff4e5", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 67, "deletions": 49, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -39,7 +39,7 @@ use syntax::ast::{Ident, MetaItemKind};\n use syntax::attr::{InlineAttr, OptimizeAttr, list_contains_name, mark_used};\n use syntax::source_map::Spanned;\n use syntax::feature_gate;\n-use syntax::symbol::{keywords, Symbol};\n+use syntax::symbol::{InternedString, keywords, Symbol, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir::def::{CtorKind, Res, DefKind};\n@@ -750,7 +750,7 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::\n         _ => span_bug!(item.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n-    let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n+    let paren_sugar = tcx.has_attr(def_id, sym::rustc_paren_sugar);\n     if paren_sugar && !tcx.features().unboxed_closures {\n         let mut err = tcx.sess.struct_span_err(\n             item.span,\n@@ -765,7 +765,7 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::\n         err.emit();\n     }\n \n-    let is_marker = tcx.has_attr(def_id, \"marker\");\n+    let is_marker = tcx.has_attr(def_id, sym::marker);\n     let def_path_hash = tcx.def_path_hash(def_id);\n     let def = ty::TraitDef::new(def_id, unsafety, paren_sugar, is_auto, is_marker, def_path_hash);\n     tcx.alloc_trait_def(def)\n@@ -1082,7 +1082,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                 .enumerate()\n                 .map(|(i, &arg)| ty::GenericParamDef {\n                     index: type_start + i as u32,\n-                    name: Symbol::intern(arg).as_interned_str(),\n+                    name: InternedString::intern(arg),\n                     def_id,\n                     pure_wrt_drop: false,\n                     kind: ty::GenericParamDefKind::Type {\n@@ -1097,7 +1097,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n             params.extend(upvars.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n                 ty::GenericParamDef {\n                     index: type_start + i,\n-                    name: Symbol::intern(\"<upvar>\").as_interned_str(),\n+                    name: InternedString::intern(\"<upvar>\"),\n                     def_id,\n                     pure_wrt_drop: false,\n                     kind: ty::GenericParamDefKind::Type {\n@@ -1404,15 +1404,27 @@ pub fn checked_type_of<'a, 'tcx>(\n                                     if !fail {\n                                         return None;\n                                     }\n-                                    bug!(\"unexpected const parent path def {:?}\", x);\n+                                    tcx.sess.delay_span_bug(\n+                                        DUMMY_SP,\n+                                        &format!(\n+                                            \"unexpected const parent path def {:?}\", x\n+                                        ),\n+                                    );\n+                                    tcx.types.err\n                                 }\n                             }\n                         }\n                         x => {\n                             if !fail {\n                                 return None;\n                             }\n-                            bug!(\"unexpected const parent path {:?}\", x);\n+                            tcx.sess.delay_span_bug(\n+                                DUMMY_SP,\n+                                &format!(\n+                                    \"unexpected const parent path {:?}\", x\n+                                ),\n+                            );\n+                            tcx.types.err\n                         }\n                     }\n                 }\n@@ -1421,7 +1433,13 @@ pub fn checked_type_of<'a, 'tcx>(\n                     if !fail {\n                         return None;\n                     }\n-                    bug!(\"unexpected const parent in type_of_def_id(): {:?}\", x);\n+                    tcx.sess.delay_span_bug(\n+                        DUMMY_SP,\n+                        &format!(\n+                            \"unexpected const parent in type_of_def_id(): {:?}\", x\n+                        ),\n+                    );\n+                    tcx.types.err\n                 }\n             }\n         }\n@@ -2382,7 +2400,7 @@ fn from_target_feature(\n     tcx: TyCtxt<'_, '_, '_>,\n     id: DefId,\n     attr: &ast::Attribute,\n-    whitelist: &FxHashMap<String, Option<String>>,\n+    whitelist: &FxHashMap<String, Option<Symbol>>,\n     target_features: &mut Vec<Symbol>,\n ) {\n     let list = match attr.meta_item_list() {\n@@ -2392,7 +2410,7 @@ fn from_target_feature(\n     let rust_features = tcx.features();\n     for item in list {\n         // Only `enable = ...` is accepted in the meta item list\n-        if !item.check_name(\"enable\") {\n+        if !item.check_name(sym::enable) {\n             let msg = \"#[target_feature(..)] only accepts sub-keys of `enable` \\\n                        currently\";\n             tcx.sess.span_err(item.span(), &msg);\n@@ -2435,29 +2453,29 @@ fn from_target_feature(\n             };\n \n             // Only allow features whose feature gates have been enabled\n-            let allowed = match feature_gate.as_ref().map(|s| &**s) {\n-                Some(\"arm_target_feature\") => rust_features.arm_target_feature,\n-                Some(\"aarch64_target_feature\") => rust_features.aarch64_target_feature,\n-                Some(\"hexagon_target_feature\") => rust_features.hexagon_target_feature,\n-                Some(\"powerpc_target_feature\") => rust_features.powerpc_target_feature,\n-                Some(\"mips_target_feature\") => rust_features.mips_target_feature,\n-                Some(\"avx512_target_feature\") => rust_features.avx512_target_feature,\n-                Some(\"mmx_target_feature\") => rust_features.mmx_target_feature,\n-                Some(\"sse4a_target_feature\") => rust_features.sse4a_target_feature,\n-                Some(\"tbm_target_feature\") => rust_features.tbm_target_feature,\n-                Some(\"wasm_target_feature\") => rust_features.wasm_target_feature,\n-                Some(\"cmpxchg16b_target_feature\") => rust_features.cmpxchg16b_target_feature,\n-                Some(\"adx_target_feature\") => rust_features.adx_target_feature,\n-                Some(\"movbe_target_feature\") => rust_features.movbe_target_feature,\n-                Some(\"rtm_target_feature\") => rust_features.rtm_target_feature,\n-                Some(\"f16c_target_feature\") => rust_features.f16c_target_feature,\n+            let allowed = match feature_gate.as_ref().map(|s| *s) {\n+                Some(sym::arm_target_feature) => rust_features.arm_target_feature,\n+                Some(sym::aarch64_target_feature) => rust_features.aarch64_target_feature,\n+                Some(sym::hexagon_target_feature) => rust_features.hexagon_target_feature,\n+                Some(sym::powerpc_target_feature) => rust_features.powerpc_target_feature,\n+                Some(sym::mips_target_feature) => rust_features.mips_target_feature,\n+                Some(sym::avx512_target_feature) => rust_features.avx512_target_feature,\n+                Some(sym::mmx_target_feature) => rust_features.mmx_target_feature,\n+                Some(sym::sse4a_target_feature) => rust_features.sse4a_target_feature,\n+                Some(sym::tbm_target_feature) => rust_features.tbm_target_feature,\n+                Some(sym::wasm_target_feature) => rust_features.wasm_target_feature,\n+                Some(sym::cmpxchg16b_target_feature) => rust_features.cmpxchg16b_target_feature,\n+                Some(sym::adx_target_feature) => rust_features.adx_target_feature,\n+                Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n+                Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n+                Some(sym::f16c_target_feature) => rust_features.f16c_target_feature,\n                 Some(name) => bug!(\"unknown target feature gate {}\", name),\n                 None => true,\n             };\n             if !allowed && id.is_local() {\n                 feature_gate::emit_feature_err(\n                     &tcx.sess.parse_sess,\n-                    feature_gate.as_ref().unwrap(),\n+                    feature_gate.unwrap(),\n                     item.span(),\n                     feature_gate::GateIssue::Language,\n                     &format!(\"the target feature `{}` is currently unstable\", feature),\n@@ -2512,13 +2530,13 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n \n     let mut inline_span = None;\n     for attr in attrs.iter() {\n-        if attr.check_name(\"cold\") {\n+        if attr.check_name(sym::cold) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n-        } else if attr.check_name(\"allocator\") {\n+        } else if attr.check_name(sym::allocator) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n-        } else if attr.check_name(\"unwind\") {\n+        } else if attr.check_name(sym::unwind) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::UNWIND;\n-        } else if attr.check_name(\"ffi_returns_twice\") {\n+        } else if attr.check_name(sym::ffi_returns_twice) {\n             if tcx.is_foreign_item(id) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n             } else {\n@@ -2530,21 +2548,21 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                     \"`#[ffi_returns_twice]` may only be used on foreign functions\"\n                 ).emit();\n             }\n-        } else if attr.check_name(\"rustc_allocator_nounwind\") {\n+        } else if attr.check_name(sym::rustc_allocator_nounwind) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND;\n-        } else if attr.check_name(\"naked\") {\n+        } else if attr.check_name(sym::naked) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n-        } else if attr.check_name(\"no_mangle\") {\n+        } else if attr.check_name(sym::no_mangle) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-        } else if attr.check_name(\"rustc_std_internal_symbol\") {\n+        } else if attr.check_name(sym::rustc_std_internal_symbol) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-        } else if attr.check_name(\"no_debug\") {\n+        } else if attr.check_name(sym::no_debug) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_DEBUG;\n-        } else if attr.check_name(\"used\") {\n+        } else if attr.check_name(sym::used) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n-        } else if attr.check_name(\"thread_local\") {\n+        } else if attr.check_name(sym::thread_local) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n-        } else if attr.check_name(\"export_name\") {\n+        } else if attr.check_name(sym::export_name) {\n             if let Some(s) = attr.value_str() {\n                 if s.as_str().contains(\"\\0\") {\n                     // `#[export_name = ...]` will be converted to a null-terminated string,\n@@ -2558,7 +2576,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 }\n                 codegen_fn_attrs.export_name = Some(s);\n             }\n-        } else if attr.check_name(\"target_feature\") {\n+        } else if attr.check_name(sym::target_feature) {\n             if tcx.fn_sig(id).unsafety() == Unsafety::Normal {\n                 let msg = \"#[target_feature(..)] can only be applied to \\\n                            `unsafe` function\";\n@@ -2571,11 +2589,11 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 &whitelist,\n                 &mut codegen_fn_attrs.target_features,\n             );\n-        } else if attr.check_name(\"linkage\") {\n+        } else if attr.check_name(sym::linkage) {\n             if let Some(val) = attr.value_str() {\n                 codegen_fn_attrs.linkage = Some(linkage_by_name(tcx, id, &val.as_str()));\n             }\n-        } else if attr.check_name(\"link_section\") {\n+        } else if attr.check_name(sym::link_section) {\n             if let Some(val) = attr.value_str() {\n                 if val.as_str().bytes().any(|b| b == 0) {\n                     let msg = format!(\n@@ -2588,13 +2606,13 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                     codegen_fn_attrs.link_section = Some(val);\n                 }\n             }\n-        } else if attr.check_name(\"link_name\") {\n+        } else if attr.check_name(sym::link_name) {\n             codegen_fn_attrs.link_name = attr.value_str();\n         }\n     }\n \n     codegen_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n-        if attr.path != \"inline\" {\n+        if attr.path != sym::inline {\n             return ia;\n         }\n         match attr.meta().map(|i| i.node) {\n@@ -2613,9 +2631,9 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                         \"expected one argument\"\n                     );\n                     InlineAttr::None\n-                } else if list_contains_name(&items[..], \"always\") {\n+                } else if list_contains_name(&items[..], sym::always) {\n                     InlineAttr::Always\n-                } else if list_contains_name(&items[..], \"never\") {\n+                } else if list_contains_name(&items[..], sym::never) {\n                     InlineAttr::Never\n                 } else {\n                     span_err!(\n@@ -2634,7 +2652,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n     });\n \n     codegen_fn_attrs.optimize = attrs.iter().fold(OptimizeAttr::None, |ia, attr| {\n-        if attr.path != \"optimize\" {\n+        if attr.path != sym::optimize {\n             return ia;\n         }\n         let err = |sp, s| span_err!(tcx.sess.diagnostic(), sp, E0722, \"{}\", s);\n@@ -2649,9 +2667,9 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 if items.len() != 1 {\n                     err(attr.span, \"expected one argument\");\n                     OptimizeAttr::None\n-                } else if list_contains_name(&items[..], \"size\") {\n+                } else if list_contains_name(&items[..], sym::size) {\n                     OptimizeAttr::Size\n-                } else if list_contains_name(&items[..], \"speed\") {\n+                } else if list_contains_name(&items[..], sym::speed) {\n                     OptimizeAttr::Speed\n                 } else {\n                     err(items[0].span(), \"invalid argument\");"}, {"sha": "a6b5b99982ec6b5ba8a4cb72b36446268a17999c", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -5,6 +5,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, CratePredicatesMap, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n+use syntax::symbol::sym;\n \n mod explicit;\n mod implicit_infer;\n@@ -40,7 +41,7 @@ fn inferred_outlives_of<'a, 'tcx>(\n                     .map(|p| *p)\n                     .unwrap_or(&[]);\n \n-                if tcx.has_attr(item_def_id, \"rustc_outlives\") {\n+                if tcx.has_attr(item_def_id, sym::rustc_outlives) {\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n                         .map(|out_pred| match out_pred {"}, {"sha": "54fd4fad1d1956c95284e8a2a5287f8c2c8008ac", "filename": "src/librustc_typeck/outlives/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::TyCtxt;\n+use syntax::symbol::sym;\n \n pub fn test_inferred_outlives<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.hir()\n@@ -18,7 +19,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for OutlivesTest<'a, 'tcx> {\n \n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id, \"rustc_outlives\") {\n+        if self.tcx.has_attr(item_def_id, sym::rustc_outlives) {\n             let inferred_outlives_of = self.tcx.inferred_outlives_of(item_def_id);\n             span_err!(\n                 self.tcx.sess,"}, {"sha": "b5195826b8631a4a6278660107442ff309c14590", "filename": "src/librustc_typeck/variance/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::TyCtxt;\n+use syntax::symbol::sym;\n \n pub fn test_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.hir().krate().visit_all_item_likes(&mut VarianceTest { tcx });\n@@ -16,7 +17,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n \n         // For unit testing: check for a special \"rustc_variance\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id, \"rustc_variance\") {\n+        if self.tcx.has_attr(item_def_id, sym::rustc_variance) {\n             let variances_of = self.tcx.variances_of(item_def_id);\n             span_err!(self.tcx.sess,\n                       item.span,"}, {"sha": "61399e0568cb10bf2ca8406a7c1af04ca88c6854", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -7,7 +7,7 @@ use std::mem;\n use std::fmt::{self, Write};\n use std::ops;\n \n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::ast::{MetaItem, MetaItemKind, NestedMetaItem, LitKind};\n use syntax::parse::ParseSess;\n use syntax::feature_gate::Features;\n@@ -186,7 +186,7 @@ impl Cfg {\n \n     fn should_use_with_in_description(&self) -> bool {\n         match *self {\n-            Cfg::Cfg(ref name, _) if name == &\"target_feature\" => true,\n+            Cfg::Cfg(name, _) if name == sym::target_feature => true,\n             _ => false,\n         }\n     }\n@@ -338,7 +338,6 @@ impl<'a> fmt::Display for Html<'a> {\n                     (\"debug_assertions\", None) => \"debug-assertions enabled\",\n                     (\"target_os\", Some(os)) => match &*os.as_str() {\n                         \"android\" => \"Android\",\n-                        \"bitrig\" => \"Bitrig\",\n                         \"dragonfly\" => \"DragonFly BSD\",\n                         \"emscripten\" => \"Emscripten\",\n                         \"freebsd\" => \"FreeBSD\",\n@@ -414,10 +413,11 @@ impl<'a> fmt::Display for Html<'a> {\n mod test {\n     use super::Cfg;\n \n-    use syntax::symbol::Symbol;\n+    use syntax_pos::DUMMY_SP;\n     use syntax::ast::*;\n+    use syntax::attr;\n     use syntax::source_map::dummy_spanned;\n-    use syntax_pos::DUMMY_SP;\n+    use syntax::symbol::Symbol;\n     use syntax::with_globals;\n \n     fn word_cfg(s: &str) -> Cfg {\n@@ -592,14 +592,10 @@ mod test {\n             let mi = dummy_meta_item_word(\"all\");\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n \n-            let mi = MetaItem {\n-                path: Path::from_ident(Ident::from_str(\"all\")),\n-                node: MetaItemKind::NameValue(dummy_spanned(LitKind::Str(\n-                    Symbol::intern(\"done\"),\n-                    StrStyle::Cooked,\n-                ))),\n-                span: DUMMY_SP,\n-            };\n+            let mi = attr::mk_name_value_item_str(\n+                Ident::from_str(\"all\"),\n+                dummy_spanned(Symbol::intern(\"done\"))\n+            );\n             assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n \n             let mi = dummy_meta_item_list!(all, [a, b]);\n@@ -627,11 +623,12 @@ mod test {\n     #[test]\n     fn test_parse_err() {\n         with_globals(|| {\n-            let mi = MetaItem {\n-                path: Path::from_ident(Ident::from_str(\"foo\")),\n-                node: MetaItemKind::NameValue(dummy_spanned(LitKind::Bool(false))),\n-                span: DUMMY_SP,\n-            };\n+            let mi = attr::mk_name_value_item(\n+                DUMMY_SP,\n+                Ident::from_str(\"foo\"),\n+                LitKind::Bool(false),\n+                DUMMY_SP,\n+            );\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = dummy_meta_item_list!(not, [a, b]);"}, {"sha": "15108a7dbb91c392836ea59e926961ce55f79721", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -4,6 +4,7 @@ use std::iter::once;\n \n use syntax::ast;\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n use rustc::hir;\n@@ -186,7 +187,7 @@ pub fn build_external_trait(cx: &DocContext<'_>, did: DefId) -> clean::Trait {\n     let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n-    let is_spotlight = load_attrs(cx, did).has_doc_flag(\"spotlight\");\n+    let is_spotlight = load_attrs(cx, did).has_doc_flag(sym::spotlight);\n     let is_auto = cx.tcx.trait_is_auto(did);\n     clean::Trait {\n         auto: auto_trait,"}, {"sha": "e434623d4a12759fe3f1bb82cef4fa0cd11fca18", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -32,6 +32,7 @@ use syntax::ext::base::MacroKind;\n use syntax::source_map::{dummy_spanned, Spanned};\n use syntax::ptr::P;\n use syntax::symbol::keywords::{self, Keyword};\n+use syntax::symbol::{Symbol, sym};\n use syntax::symbol::InternedString;\n use syntax_pos::{self, Pos, FileName};\n \n@@ -170,7 +171,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     // `compiler_builtins` should be masked too, but we can't apply\n                     // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n                     if it.is_extern_crate()\n-                        && (it.attrs.has_doc_flag(\"masked\")\n+                        && (it.attrs.has_doc_flag(sym::masked)\n                             || self.cx.tcx.is_compiler_builtins(it.def_id.krate))\n                     {\n                         masked_crates.insert(it.def_id.krate);\n@@ -261,9 +262,9 @@ impl Clean<ExternalCrate> for CrateNum {\n             if let Res::Def(DefKind::Mod, def_id) = res {\n                 let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n                 let mut prim = None;\n-                for attr in attrs.lists(\"doc\") {\n+                for attr in attrs.lists(sym::doc) {\n                     if let Some(v) = attr.value_str() {\n-                        if attr.check_name(\"primitive\") {\n+                        if attr.check_name(sym::primitive) {\n                             prim = PrimitiveType::from_str(&v.as_str());\n                             if prim.is_some() {\n                                 break;\n@@ -305,9 +306,9 @@ impl Clean<ExternalCrate> for CrateNum {\n             if let Res::Def(DefKind::Mod, def_id) = res {\n                 let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n                 let mut keyword = None;\n-                for attr in attrs.lists(\"doc\") {\n+                for attr in attrs.lists(sym::doc) {\n                     if let Some(v) = attr.value_str() {\n-                        if attr.check_name(\"keyword\") {\n+                        if attr.check_name(sym::keyword) {\n                             keyword = Keyword::from_str(&v.as_str()).ok()\n                                                                     .map(|x| x.name().to_string());\n                             if keyword.is_some() {\n@@ -501,7 +502,7 @@ impl Item {\n \n     pub fn is_non_exhaustive(&self) -> bool {\n         self.attrs.other_attrs.iter()\n-            .any(|a| a.check_name(\"non_exhaustive\"))\n+            .any(|a| a.check_name(sym::non_exhaustive))\n     }\n \n     /// Returns a documentation-level item type from the item.\n@@ -669,7 +670,7 @@ impl Clean<Item> for doctree::Module {\n pub struct ListAttributesIter<'a> {\n     attrs: slice::Iter<'a, ast::Attribute>,\n     current_list: vec::IntoIter<ast::NestedMetaItem>,\n-    name: &'a str\n+    name: Symbol,\n }\n \n impl<'a> Iterator for ListAttributesIter<'a> {\n@@ -702,11 +703,11 @@ impl<'a> Iterator for ListAttributesIter<'a> {\n \n pub trait AttributesExt {\n     /// Finds an attribute as List and returns the list of attributes nested inside.\n-    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a>;\n+    fn lists<'a>(&'a self, name: Symbol) -> ListAttributesIter<'a>;\n }\n \n impl AttributesExt for [ast::Attribute] {\n-    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a> {\n+    fn lists<'a>(&'a self, name: Symbol) -> ListAttributesIter<'a> {\n         ListAttributesIter {\n             attrs: self.iter(),\n             current_list: Vec::new().into_iter(),\n@@ -717,11 +718,11 @@ impl AttributesExt for [ast::Attribute] {\n \n pub trait NestedAttributesExt {\n     /// Returns `true` if the attribute list contains a specific `Word`\n-    fn has_word(self, word: &str) -> bool;\n+    fn has_word(self, word: Symbol) -> bool;\n }\n \n impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n-    fn has_word(self, word: &str) -> bool {\n+    fn has_word(self, word: Symbol) -> bool {\n         self.into_iter().any(|attr| attr.is_word() && attr.check_name(word))\n     }\n }\n@@ -803,7 +804,7 @@ impl Attributes {\n         if let ast::MetaItemKind::List(ref nmis) = mi.node {\n             if nmis.len() == 1 {\n                 if let MetaItem(ref cfg_mi) = nmis[0] {\n-                    if cfg_mi.check_name(\"cfg\") {\n+                    if cfg_mi.check_name(sym::cfg) {\n                         if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.node {\n                             if cfg_nmis.len() == 1 {\n                                 if let MetaItem(ref content_mi) = cfg_nmis[0] {\n@@ -827,7 +828,7 @@ impl Attributes {\n     {\n         mi.meta_item_list().and_then(|list| {\n             for meta in list {\n-                if meta.check_name(\"include\") {\n+                if meta.check_name(sym::include) {\n                     // the actual compiled `#[doc(include=\"filename\")]` gets expanded to\n                     // `#[doc(include(file=\"filename\", contents=\"file contents\")]` so we need to\n                     // look for that instead\n@@ -836,11 +837,11 @@ impl Attributes {\n                         let mut contents: Option<String> = None;\n \n                         for it in list {\n-                            if it.check_name(\"file\") {\n+                            if it.check_name(sym::file) {\n                                 if let Some(name) = it.value_str() {\n                                     filename = Some(name.to_string());\n                                 }\n-                            } else if it.check_name(\"contents\") {\n+                            } else if it.check_name(sym::contents) {\n                                 if let Some(docs) = it.value_str() {\n                                     contents = Some(docs.to_string());\n                                 }\n@@ -860,9 +861,9 @@ impl Attributes {\n         })\n     }\n \n-    pub fn has_doc_flag(&self, flag: &str) -> bool {\n+    pub fn has_doc_flag(&self, flag: Symbol) -> bool {\n         for attr in &self.other_attrs {\n-            if !attr.check_name(\"doc\") { continue; }\n+            if !attr.check_name(sym::doc) { continue; }\n \n             if let Some(items) = attr.meta_item_list() {\n                 if items.iter().filter_map(|i| i.meta_item()).any(|it| it.check_name(flag)) {\n@@ -883,7 +884,7 @@ impl Attributes {\n \n         let other_attrs = attrs.iter().filter_map(|attr| {\n             attr.with_desugared_doc(|attr| {\n-                if attr.check_name(\"doc\") {\n+                if attr.check_name(sym::doc) {\n                     if let Some(mi) = attr.meta() {\n                         if let Some(value) = mi.value_str() {\n                             // Extracted #[doc = \"...\"]\n@@ -925,11 +926,12 @@ impl Attributes {\n \n         // treat #[target_feature(enable = \"feat\")] attributes as if they were\n         // #[doc(cfg(target_feature = \"feat\"))] attributes as well\n-        for attr in attrs.lists(\"target_feature\") {\n-            if attr.check_name(\"enable\") {\n+        for attr in attrs.lists(sym::target_feature) {\n+            if attr.check_name(sym::enable) {\n                 if let Some(feat) = attr.value_str() {\n-                    let meta = attr::mk_name_value_item_str(Ident::from_str(\"target_feature\"),\n-                                                            dummy_spanned(feat));\n+                    let meta = attr::mk_name_value_item_str(\n+                        Ident::with_empty_ctxt(sym::target_feature),\n+                        dummy_spanned(feat));\n                     if let Ok(feat_cfg) = Cfg::parse(&meta) {\n                         cfg &= feat_cfg;\n                     }\n@@ -938,7 +940,7 @@ impl Attributes {\n         }\n \n         let inner_docs = attrs.iter()\n-                              .filter(|a| a.check_name(\"doc\"))\n+                              .filter(|a| a.check_name(sym::doc))\n                               .next()\n                               .map_or(true, |a| a.style == AttrStyle::Inner);\n \n@@ -1039,7 +1041,7 @@ impl Hash for Attributes {\n }\n \n impl AttributesExt for Attributes {\n-    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a> {\n+    fn lists<'a>(&'a self, name: Symbol) -> ListAttributesIter<'a> {\n         self.other_attrs.lists(name)\n     }\n }\n@@ -2133,7 +2135,7 @@ pub struct Trait {\n impl Clean<Item> for doctree::Trait {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n-        let is_spotlight = attrs.has_doc_flag(\"spotlight\");\n+        let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: attrs,\n@@ -3147,7 +3149,10 @@ impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> Constant {\n         Constant {\n             type_: self.ty.clean(cx),\n-            expr: format!(\"{:?}\", self.val), // FIXME(const_generics)\n+            expr: match self.val {\n+                ConstValue::Param(ty::ParamConst { name, .. }) => format!(\"{}\", name),\n+                e => format!(\"{:?}\", e), // FIXME generic consts with expressions\n+            },\n         }\n     }\n }\n@@ -3403,6 +3408,7 @@ pub struct Span {\n     pub locol: usize,\n     pub hiline: usize,\n     pub hicol: usize,\n+    pub original: syntax_pos::Span,\n }\n \n impl Span {\n@@ -3411,8 +3417,13 @@ impl Span {\n             filename: FileName::Anon(0),\n             loline: 0, locol: 0,\n             hiline: 0, hicol: 0,\n+            original: syntax_pos::DUMMY_SP,\n         }\n     }\n+\n+    pub fn span(&self) -> syntax_pos::Span {\n+        self.original\n+    }\n }\n \n impl Clean<Span> for syntax_pos::Span {\n@@ -3431,6 +3442,7 @@ impl Clean<Span> for syntax_pos::Span {\n             locol: lo.col.to_usize(),\n             hiline: hi.line,\n             hicol: hi.col.to_usize(),\n+            original: *self,\n         }\n     }\n }\n@@ -3893,8 +3905,8 @@ impl Clean<Vec<Item>> for doctree::ExternCrate {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n \n         let please_inline = self.vis.node.is_pub() && self.attrs.iter().any(|a| {\n-            a.check_name(\"doc\") && match a.meta_item_list() {\n-                Some(l) => attr::list_contains_name(&l, \"inline\"),\n+            a.check_name(sym::doc) && match a.meta_item_list() {\n+                Some(l) => attr::list_contains_name(&l, sym::inline),\n                 None => false,\n             }\n         });\n@@ -3935,15 +3947,15 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let mut denied = !self.vis.node.is_pub() || self.attrs.iter().any(|a| {\n-            a.check_name(\"doc\") && match a.meta_item_list() {\n-                Some(l) => attr::list_contains_name(&l, \"no_inline\") ||\n-                           attr::list_contains_name(&l, \"hidden\"),\n+            a.check_name(sym::doc) && match a.meta_item_list() {\n+                Some(l) => attr::list_contains_name(&l, sym::no_inline) ||\n+                           attr::list_contains_name(&l, sym::hidden),\n                 None => false,\n             }\n         });\n         // Also check whether imports were asked to be inlined, in case we're trying to re-export a\n         // crate in Rust 2018+\n-        let please_inline = self.attrs.lists(\"doc\").has_word(\"inline\");\n+        let please_inline = self.attrs.lists(sym::doc).has_word(sym::inline);\n         let path = self.path.clean(cx);\n         let inner = if self.glob {\n             if !denied {\n@@ -4382,7 +4394,7 @@ where\n \n // Start of code copied from rust-clippy\n \n-pub fn path_to_def_local(tcx: TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n+pub fn path_to_def_local(tcx: TyCtxt<'_, '_, '_>, path: &[Symbol]) -> Option<DefId> {\n     let krate = tcx.hir().krate();\n     let mut items = krate.module.item_ids.clone();\n     let mut path_it = path.iter().peekable();\n@@ -4407,7 +4419,7 @@ pub fn path_to_def_local(tcx: TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId\n     }\n }\n \n-pub fn path_to_def(tcx: TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n+pub fn path_to_def(tcx: TyCtxt<'_, '_, '_>, path: &[Symbol]) -> Option<DefId> {\n     let crates = tcx.crates();\n \n     let krate = crates"}, {"sha": "6b490f730afa0c951cab05c7dd5fcb79841321a7", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -13,7 +13,7 @@ use rustc::session::config::{nightly_options, build_codegen_options, build_debug\n use rustc::session::search_paths::SearchPath;\n use rustc_driver;\n use rustc_target::spec::TargetTriple;\n-use syntax::edition::Edition;\n+use syntax::edition::{Edition, DEFAULT_EDITION};\n \n use crate::core::new_handler;\n use crate::externalfiles::ExternalHtml;\n@@ -386,27 +386,31 @@ impl Options {\n             }\n         }\n \n+        let edition = if let Some(e) = matches.opt_str(\"edition\") {\n+            match e.parse() {\n+                Ok(e) => e,\n+                Err(_) => {\n+                    diag.struct_err(\"could not parse edition\").emit();\n+                    return Err(1);\n+                }\n+            }\n+        } else {\n+            DEFAULT_EDITION\n+        };\n+\n         let mut id_map = html::markdown::IdMap::new();\n         id_map.populate(html::render::initial_ids());\n         let external_html = match ExternalHtml::load(\n                 &matches.opt_strs(\"html-in-header\"),\n                 &matches.opt_strs(\"html-before-content\"),\n                 &matches.opt_strs(\"html-after-content\"),\n                 &matches.opt_strs(\"markdown-before-content\"),\n-                &matches.opt_strs(\"markdown-after-content\"), &diag, &mut id_map) {\n+                &matches.opt_strs(\"markdown-after-content\"),\n+                &diag, &mut id_map, edition) {\n             Some(eh) => eh,\n             None => return Err(3),\n         };\n \n-        let edition = matches.opt_str(\"edition\").unwrap_or(\"2015\".to_string());\n-        let edition = match edition.parse() {\n-            Ok(e) => e,\n-            Err(_) => {\n-                diag.struct_err(\"could not parse edition\").emit();\n-                return Err(1);\n-            }\n-        };\n-\n         match matches.opt_str(\"r\").as_ref().map(|s| &**s) {\n             Some(\"rust\") | None => {}\n             Some(s) => {\n@@ -538,7 +542,7 @@ fn check_deprecated_options(matches: &getopts::Matches, diag: &errors::Handler)\n        \"passes\",\n     ];\n \n-    for flag in deprecated_flags.into_iter() {\n+    for flag in deprecated_flags.iter() {\n         if matches.opt_present(flag) {\n             let mut err = diag.struct_warn(&format!(\"the '{}' flag is considered deprecated\",\n                                                     flag));"}, {"sha": "2a3bc5e99617f468375a834110a7e7cf45e431ed", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -18,6 +18,7 @@ use rustc_target::spec::TargetTriple;\n use syntax::source_map;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::json::JsonEmitter;\n+use syntax::symbol::sym;\n use errors;\n use errors::emitter::{Emitter, EmitterWriter};\n use parking_lot::ReentrantMutex;\n@@ -142,7 +143,7 @@ impl<'tcx> DocContext<'tcx> {\n             crate_num,\n             DefId {\n                 krate: crate_num,\n-                index: DefIndex::from_array_index(def_id.index.as_array_index() + 1),\n+                index: DefIndex::from(def_id.index.index() + 1),\n             },\n         );\n \n@@ -367,9 +368,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             };\n \n             let send_trait = if crate_name == Some(\"core\".to_string()) {\n-                clean::path_to_def_local(tcx, &[\"marker\", \"Send\"])\n+                clean::path_to_def_local(tcx, &[sym::marker, sym::Send])\n             } else {\n-                clean::path_to_def(tcx, &[\"core\", \"marker\", \"Send\"])\n+                clean::path_to_def(tcx, &[sym::core, sym::marker, sym::Send])\n             };\n \n             let mut renderinfo = RenderInfo::default();\n@@ -415,24 +416,24 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n             // Process all of the crate attributes, extracting plugin metadata along\n             // with the passes which we are supposed to run.\n-            for attr in krate.module.as_ref().unwrap().attrs.lists(\"doc\") {\n+            for attr in krate.module.as_ref().unwrap().attrs.lists(sym::doc) {\n                 let diag = ctxt.sess().diagnostic();\n \n                 let name = attr.name_or_empty();\n                 if attr.is_word() {\n-                    if name == \"no_default_passes\" {\n+                    if name == sym::no_default_passes {\n                         report_deprecated_attr(\"no_default_passes\", diag);\n                         if default_passes == passes::DefaultPassOption::Default {\n                             default_passes = passes::DefaultPassOption::None;\n                         }\n                     }\n                 } else if let Some(value) = attr.value_str() {\n-                    let sink = match name.get() {\n-                        \"passes\" => {\n+                    let sink = match name {\n+                        sym::passes => {\n                             report_deprecated_attr(\"passes = \\\"...\\\"\", diag);\n                             &mut manual_passes\n                         },\n-                        \"plugins\" => {\n+                        sym::plugins => {\n                             report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n                             eprintln!(\"WARNING: #![doc(plugins = \\\"...\\\")] no longer functions; \\\n                                       see CVE-2018-1000622\");\n@@ -445,7 +446,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                     }\n                 }\n \n-                if attr.is_word() && name == \"document_private_items\" {\n+                if attr.is_word() && name == sym::document_private_items {\n                     if default_passes == passes::DefaultPassOption::Default {\n                         default_passes = passes::DefaultPassOption::Private;\n                     }"}, {"sha": "d604ba11d41860fd39f0b70d56dd6051a9bb9424", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -3,6 +3,7 @@ use std::path::Path;\n use std::str;\n use errors;\n use crate::syntax::feature_gate::UnstableFeatures;\n+use crate::syntax::edition::Edition;\n use crate::html::markdown::{IdMap, ErrorCodes, Markdown};\n \n use std::cell::RefCell;\n@@ -23,7 +24,7 @@ pub struct ExternalHtml {\n impl ExternalHtml {\n     pub fn load(in_header: &[String], before_content: &[String], after_content: &[String],\n                 md_before_content: &[String], md_after_content: &[String], diag: &errors::Handler,\n-                id_map: &mut IdMap)\n+                id_map: &mut IdMap, edition: Edition)\n             -> Option<ExternalHtml> {\n         let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n         load_external_files(in_header, diag)\n@@ -34,7 +35,8 @@ impl ExternalHtml {\n             .and_then(|(ih, bc)|\n                 load_external_files(md_before_content, diag)\n                     .map(|m_bc| (ih,\n-                            format!(\"{}{}\", bc, Markdown(&m_bc, &[], RefCell::new(id_map), codes))))\n+                            format!(\"{}{}\", bc, Markdown(&m_bc, &[], RefCell::new(id_map),\n+                                    codes, edition))))\n             )\n             .and_then(|(ih, bc)|\n                 load_external_files(after_content, diag)\n@@ -43,7 +45,8 @@ impl ExternalHtml {\n             .and_then(|(ih, bc, ac)|\n                 load_external_files(md_after_content, diag)\n                     .map(|m_ac| (ih, bc,\n-                            format!(\"{}{}\", ac, Markdown(&m_ac, &[], RefCell::new(id_map), codes))))\n+                            format!(\"{}{}\", ac, Markdown(&m_ac, &[], RefCell::new(id_map),\n+                                    codes, edition))))\n             )\n             .map(|(ih, bc, ac)|\n                 ExternalHtml {"}, {"sha": "2784d5b3e10a0bbf85e5c46e9ea56afe54131c06", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -262,9 +262,7 @@ impl fmt::Display for clean::Lifetime {\n \n impl fmt::Display for clean::Constant {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(&self.expr, f)?;\n-        f.write_str(\": \")?;\n-        fmt::Display::fmt(&self.type_, f)\n+        fmt::Display::fmt(&self.expr, f)\n     }\n }\n "}, {"sha": "5bb06516ac49e81ebaf917d4ea9b9dcb8fd6a407", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -318,6 +318,8 @@ impl<'a> Classifier<'a> {\n \n                     // Number literals.\n                     token::Integer(..) | token::Float(..) => Class::Number,\n+\n+                    token::Bool(..) => panic!(\"literal token contains `Lit::Bool`\"),\n                 }\n             }\n "}, {"sha": "ae0bd1aafa8f159393fce8482bc54eb47e314e27", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -182,14 +182,14 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n         let p = SlashChecker(&p);\n         if layout.logo.is_empty() {\n             format!(\"<a href='{path}index.html'>\\\n-                     <img src='{static_root_path}rust-logo{suffix}.png' \\\n-                          alt='logo' width='100'></a>\",\n+                     <div class='logo-container'>\\\n+                     <img src='{static_root_path}rust-logo{suffix}.png' alt='logo'></div></a>\",\n                     path=p,\n                     static_root_path=static_root_path,\n                     suffix=page.resource_suffix)\n         } else {\n             format!(\"<a href='{}index.html'>\\\n-                     <img src='{}' alt='logo' width='100'></a>\",\n+                     <div class='logo-container'><img src='{}' alt='logo'></div></a>\",\n                     p,\n                     layout.logo)\n         }"}, {"sha": "12d10254c4d09ecf7574ca63ed0d75643dd7c393", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -8,12 +8,16 @@\n //! ```\n //! #![feature(rustc_private)]\n //!\n+//! extern crate syntax;\n+//!\n+//! use syntax::edition::Edition;\n //! use rustdoc::html::markdown::{IdMap, Markdown, ErrorCodes};\n //! use std::cell::RefCell;\n //!\n //! let s = \"My *markdown* _text_\";\n //! let mut id_map = IdMap::new();\n-//! let html = format!(\"{}\", Markdown(s, &[], RefCell::new(&mut id_map), ErrorCodes::Yes));\n+//! let html = format!(\"{}\", Markdown(s, &[], RefCell::new(&mut id_map),\n+//!                                   ErrorCodes::Yes, Edition::Edition2015));\n //! // ... something using html\n //! ```\n \n@@ -42,14 +46,21 @@ fn opts() -> Options {\n /// A unit struct which has the `fmt::Display` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n-/// The second parameter is a list of link replacements\n+///\n+/// The second parameter is a list of link replacements.\n+///\n+/// The third is the current list of used header IDs.\n+///\n+/// The fourth is whether to allow the use of explicit error codes in doctest lang strings.\n+///\n+/// The fifth is what default edition to use when parsing doctests (to add a `fn main`).\n pub struct Markdown<'a>(\n-    pub &'a str, pub &'a [(String, String)], pub RefCell<&'a mut IdMap>, pub ErrorCodes);\n+    pub &'a str, pub &'a [(String, String)], pub RefCell<&'a mut IdMap>, pub ErrorCodes, pub Edition);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n-pub struct MarkdownWithToc<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes);\n+pub struct MarkdownWithToc<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes, pub Edition);\n /// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n-pub struct MarkdownHtml<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes);\n+pub struct MarkdownHtml<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes, pub Edition);\n /// A unit struct like `Markdown`, that renders only the first paragraph.\n pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [(String, String)]);\n \n@@ -146,13 +157,15 @@ thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> =\n struct CodeBlocks<'a, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n     check_error_codes: ErrorCodes,\n+    edition: Edition,\n }\n \n impl<'a, I: Iterator<Item = Event<'a>>> CodeBlocks<'a, I> {\n-    fn new(iter: I, error_codes: ErrorCodes) -> Self {\n+    fn new(iter: I, error_codes: ErrorCodes, edition: Edition) -> Self {\n         CodeBlocks {\n             inner: iter,\n             check_error_codes: error_codes,\n+            edition,\n         }\n     }\n }\n@@ -177,6 +190,9 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n             return event;\n         }\n \n+        let explicit_edition = edition.is_some();\n+        let edition = edition.unwrap_or(self.edition);\n+\n         let mut origtext = String::new();\n         for event in &mut self.inner {\n             match event {\n@@ -202,22 +218,14 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                     .collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n                 let krate = krate.as_ref().map(|s| &**s);\n                 let (test, _) = test::make_test(&test, krate, false,\n-                                           &Default::default());\n+                                           &Default::default(), edition);\n                 let channel = if test.contains(\"#![feature(\") {\n                     \"&amp;version=nightly\"\n                 } else {\n                     \"\"\n                 };\n \n-                let edition_string = if let Some(e @ Edition::Edition2018) = edition {\n-                    format!(\"&amp;edition={}{}\", e,\n-                            if channel == \"&amp;version=nightly\" { \"\" }\n-                            else { \"&amp;version=nightly\" })\n-                } else if let Some(e) = edition {\n-                    format!(\"&amp;edition={}\", e)\n-                } else {\n-                    \"\".to_owned()\n-                };\n+                let edition_string = format!(\"&amp;edition={}\", edition);\n \n                 // These characters don't need to be escaped in a URI.\n                 // FIXME: use a library function for percent encoding.\n@@ -247,8 +255,8 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                 Some((\"This example is not tested\".to_owned(), \"ignore\"))\n             } else if compile_fail {\n                 Some((\"This example deliberately fails to compile\".to_owned(), \"compile_fail\"))\n-            } else if let Some(e) = edition {\n-                Some((format!(\"This code runs with edition {}\", e), \"edition\"))\n+            } else if explicit_edition {\n+                Some((format!(\"This code runs with edition {}\", edition), \"edition\"))\n             } else {\n                 None\n             };\n@@ -259,7 +267,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                     Some(&format!(\"rust-example-rendered{}\",\n                                   if ignore { \" ignore\" }\n                                   else if compile_fail { \" compile_fail\" }\n-                                  else if edition.is_some() { \" edition \" }\n+                                  else if explicit_edition { \" edition \" }\n                                   else { \"\" })),\n                     playground_button.as_ref().map(String::as_str),\n                     Some((s1.as_str(), s2))));\n@@ -270,7 +278,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                     Some(&format!(\"rust-example-rendered{}\",\n                                   if ignore { \" ignore\" }\n                                   else if compile_fail { \" compile_fail\" }\n-                                  else if edition.is_some() { \" edition \" }\n+                                  else if explicit_edition { \" edition \" }\n                                   else { \"\" })),\n                     playground_button.as_ref().map(String::as_str),\n                     None));\n@@ -659,7 +667,7 @@ impl LangString {\n \n impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let Markdown(md, links, ref ids, codes) = *self;\n+        let Markdown(md, links, ref ids, codes, edition) = *self;\n         let mut ids = ids.borrow_mut();\n \n         // This is actually common enough to special-case\n@@ -678,7 +686,7 @@ impl<'a> fmt::Display for Markdown<'a> {\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n         let p = LinkReplacer::new(p, links);\n-        let p = CodeBlocks::new(p, codes);\n+        let p = CodeBlocks::new(p, codes, edition);\n         let p = Footnotes::new(p);\n         html::push_html(&mut s, p);\n \n@@ -688,7 +696,7 @@ impl<'a> fmt::Display for Markdown<'a> {\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let MarkdownWithToc(md, ref ids, codes) = *self;\n+        let MarkdownWithToc(md, ref ids, codes, edition) = *self;\n         let mut ids = ids.borrow_mut();\n \n         let p = Parser::new_ext(md, opts());\n@@ -699,7 +707,7 @@ impl<'a> fmt::Display for MarkdownWithToc<'a> {\n \n         {\n             let p = HeadingLinks::new(p, Some(&mut toc), &mut ids);\n-            let p = CodeBlocks::new(p, codes);\n+            let p = CodeBlocks::new(p, codes, edition);\n             let p = Footnotes::new(p);\n             html::push_html(&mut s, p);\n         }\n@@ -712,7 +720,7 @@ impl<'a> fmt::Display for MarkdownWithToc<'a> {\n \n impl<'a> fmt::Display for MarkdownHtml<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let MarkdownHtml(md, ref ids, codes) = *self;\n+        let MarkdownHtml(md, ref ids, codes, edition) = *self;\n         let mut ids = ids.borrow_mut();\n \n         // This is actually common enough to special-case\n@@ -728,7 +736,7 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = CodeBlocks::new(p, codes);\n+        let p = CodeBlocks::new(p, codes, edition);\n         let p = Footnotes::new(p);\n         html::push_html(&mut s, p);\n \n@@ -1046,7 +1054,7 @@ mod tests {\n     use super::{ErrorCodes, LangString, Markdown, MarkdownHtml, IdMap};\n     use super::plain_summary_line;\n     use std::cell::RefCell;\n-    use syntax::edition::Edition;\n+    use syntax::edition::{Edition, DEFAULT_EDITION};\n \n     #[test]\n     fn test_lang_string_parse() {\n@@ -1098,7 +1106,8 @@ mod tests {\n     fn test_header() {\n         fn t(input: &str, expect: &str) {\n             let mut map = IdMap::new();\n-            let output = Markdown(input, &[], RefCell::new(&mut map), ErrorCodes::Yes).to_string();\n+            let output = Markdown(input, &[], RefCell::new(&mut map),\n+                                  ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n@@ -1120,7 +1129,8 @@ mod tests {\n     fn test_header_ids_multiple_blocks() {\n         let mut map = IdMap::new();\n         fn t(map: &mut IdMap, input: &str, expect: &str) {\n-            let output = Markdown(input, &[], RefCell::new(map), ErrorCodes::Yes).to_string();\n+            let output = Markdown(input, &[], RefCell::new(map),\n+                                  ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n@@ -1157,7 +1167,8 @@ mod tests {\n     fn test_markdown_html_escape() {\n         fn t(input: &str, expect: &str) {\n             let mut idmap = IdMap::new();\n-            let output = MarkdownHtml(input, RefCell::new(&mut idmap), ErrorCodes::Yes).to_string();\n+            let output = MarkdownHtml(input, RefCell::new(&mut idmap),\n+                                      ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n "}, {"sha": "b628bd450d314b8a690dea5e0beae786db59a0ef", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 77, "deletions": 53, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -47,9 +47,11 @@ use std::rc::Rc;\n use errors;\n use serialize::json::{ToJson, Json, as_json};\n use syntax::ast;\n+use syntax::edition::Edition;\n use syntax::ext::base::MacroKind;\n use syntax::source_map::FileName;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::symbol::{Symbol, sym};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n@@ -107,6 +109,8 @@ struct Context {\n     /// publicly reused items to redirect to the right location.\n     pub render_redirect_pages: bool,\n     pub codes: ErrorCodes,\n+    /// The default edition used to parse doctests.\n+    pub edition: Edition,\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n@@ -505,15 +509,16 @@ pub fn initial_ids() -> Vec<String> {\n      \"methods\",\n      \"deref-methods\",\n      \"implementations\",\n-    ].into_iter().map(|id| (String::from(*id))).collect()\n+    ].iter().map(|id| (String::from(*id))).collect()\n }\n \n /// Generates the documentation for `crate` into the directory `dst`\n pub fn run(mut krate: clean::Crate,\n            options: RenderOptions,\n            passes: FxHashSet<String>,\n            renderinfo: RenderInfo,\n-           diag: &errors::Handler) -> Result<(), Error> {\n+           diag: &errors::Handler,\n+           edition: Edition) -> Result<(), Error> {\n     // need to save a copy of the options for rendering the index page\n     let md_opts = options.clone();\n     let RenderOptions {\n@@ -571,24 +576,24 @@ pub fn run(mut krate: clean::Crate,\n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n     if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n-        for attr in attrs.lists(\"doc\") {\n-            match (attr.name_or_empty().get(), attr.value_str()) {\n-                (\"html_favicon_url\", Some(s)) => {\n+        for attr in attrs.lists(sym::doc) {\n+            match (attr.name_or_empty(), attr.value_str()) {\n+                (sym::html_favicon_url, Some(s)) => {\n                     scx.layout.favicon = s.to_string();\n                 }\n-                (\"html_logo_url\", Some(s)) => {\n+                (sym::html_logo_url, Some(s)) => {\n                     scx.layout.logo = s.to_string();\n                 }\n-                (\"html_playground_url\", Some(s)) => {\n+                (sym::html_playground_url, Some(s)) => {\n                     markdown::PLAYGROUND.with(|slot| {\n                         let name = krate.name.clone();\n                         *slot.borrow_mut() = Some((Some(name), s.to_string()));\n                     });\n                 }\n-                (\"issue_tracker_base_url\", Some(s)) => {\n+                (sym::issue_tracker_base_url, Some(s)) => {\n                     scx.issue_tracker_base_url = Some(s.to_string());\n                 }\n-                (\"html_no_source\", None) if attr.is_word() => {\n+                (sym::html_no_source, None) if attr.is_word() => {\n                     scx.include_sources = false;\n                 }\n                 _ => {}\n@@ -603,6 +608,7 @@ pub fn run(mut krate: clean::Crate,\n         dst,\n         render_redirect_pages: false,\n         codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n+        edition,\n         id_map: Rc::new(RefCell::new(id_map)),\n         shared: Arc::new(scx),\n     };\n@@ -1127,7 +1133,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n             md_opts.output = cx.dst.clone();\n             md_opts.external_html = (*cx.shared).layout.external_html.clone();\n \n-            crate::markdown::render(index_page, md_opts, diag);\n+            crate::markdown::render(index_page, md_opts, diag, cx.edition);\n         } else {\n             let dst = cx.dst.join(\"index.html\");\n             let mut w = BufWriter::new(try_err!(File::create(&dst), &dst));\n@@ -1388,8 +1394,8 @@ fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Pat\n \n     // Failing that, see if there's an attribute specifying where to find this\n     // external crate\n-    e.attrs.lists(\"doc\")\n-     .filter(|a| a.check_name(\"html_root_url\"))\n+    e.attrs.lists(sym::doc)\n+     .filter(|a| a.check_name(sym::html_root_url))\n      .filter_map(|a| a.value_str())\n      .map(|url| {\n         let mut url = url.to_string();\n@@ -1779,8 +1785,8 @@ impl<'a> Cache {\n             let path = self.paths.get(&item.def_id)\n                                  .map(|p| p.0[..p.0.len() - 1].join(\"::\"))\n                                  .unwrap_or(\"std\".to_owned());\n-            for alias in item.attrs.lists(\"doc\")\n-                                   .filter(|a| a.check_name(\"alias\"))\n+            for alias in item.attrs.lists(sym::doc)\n+                                   .filter(|a| a.check_name(sym::alias))\n                                    .filter_map(|a| a.value_str()\n                                                     .map(|s| s.to_string().replace(\"\\\"\", \"\")))\n                                    .filter(|v| !v.is_empty())\n@@ -2552,7 +2558,7 @@ fn render_markdown(w: &mut fmt::Formatter<'_>,\n            if is_hidden { \" hidden\" } else { \"\" },\n            prefix,\n            Markdown(md_text, &links, RefCell::new(&mut ids),\n-           cx.codes))\n+           cx.codes, cx.edition))\n }\n \n fn document_short(\n@@ -2917,7 +2923,7 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n \n         if let Some(note) = note {\n             let mut ids = cx.id_map.borrow_mut();\n-            let html = MarkdownHtml(&note, RefCell::new(&mut ids), error_codes);\n+            let html = MarkdownHtml(&note, RefCell::new(&mut ids), error_codes, cx.edition);\n             message.push_str(&format!(\": {}\", html));\n         }\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", message));\n@@ -2966,7 +2972,7 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n             message = format!(\n                 \"<details><summary>{}</summary>{}</details>\",\n                 message,\n-                MarkdownHtml(&unstable_reason, RefCell::new(&mut ids), error_codes)\n+                MarkdownHtml(&unstable_reason, RefCell::new(&mut ids), error_codes, cx.edition)\n             );\n         }\n \n@@ -2991,7 +2997,7 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n fn item_constant(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                  c: &clean::Constant) -> fmt::Result {\n     write!(w, \"<pre class='rust const'>\")?;\n-    render_attributes(w, it)?;\n+    render_attributes(w, it, false)?;\n     write!(w, \"{vis}const \\\n                {name}: {typ}</pre>\",\n            vis = VisSpace(&it.visibility),\n@@ -3003,7 +3009,7 @@ fn item_constant(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n fn item_static(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                s: &clean::Static) -> fmt::Result {\n     write!(w, \"<pre class='rust static'>\")?;\n-    render_attributes(w, it)?;\n+    render_attributes(w, it, false)?;\n     write!(w, \"{vis}static {mutability}\\\n                {name}: {typ}</pre>\",\n            vis = VisSpace(&it.visibility),\n@@ -3026,7 +3032,7 @@ fn item_function(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n         f.generics\n     ).len();\n     write!(w, \"{}<pre class='rust fn'>\", render_spotlight_traits(it)?)?;\n-    render_attributes(w, it)?;\n+    render_attributes(w, it, false)?;\n     write!(w,\n            \"{vis}{constness}{unsafety}{asyncness}{abi}fn \\\n            {name}{generics}{decl}{where_clause}</pre>\",\n@@ -3115,7 +3121,7 @@ fn item_trait(\n     // Output the trait definition\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust trait'>\")?;\n-        render_attributes(w, it)?;\n+        render_attributes(w, it, true)?;\n         write!(w, \"{}{}{}trait {}{}{}\",\n                VisSpace(&it.visibility),\n                UnsafetySpace(t.unsafety),\n@@ -3378,8 +3384,10 @@ fn assoc_const(w: &mut fmt::Formatter<'_>,\n                it: &clean::Item,\n                ty: &clean::Type,\n                _default: Option<&String>,\n-               link: AssocItemLink<'_>) -> fmt::Result {\n-    write!(w, \"{}const <a href='{}' class=\\\"constant\\\"><b>{}</b></a>: {}\",\n+               link: AssocItemLink<'_>,\n+               extra: &str) -> fmt::Result {\n+    write!(w, \"{}{}const <a href='{}' class=\\\"constant\\\"><b>{}</b></a>: {}\",\n+           extra,\n            VisSpace(&it.visibility),\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap(),\n@@ -3390,8 +3398,10 @@ fn assoc_const(w: &mut fmt::Formatter<'_>,\n fn assoc_type<W: fmt::Write>(w: &mut W, it: &clean::Item,\n                              bounds: &[clean::GenericBound],\n                              default: Option<&clean::Type>,\n-                             link: AssocItemLink<'_>) -> fmt::Result {\n-    write!(w, \"type <a href='{}' class=\\\"type\\\">{}</a>\",\n+                             link: AssocItemLink<'_>,\n+                             extra: &str) -> fmt::Result {\n+    write!(w, \"{}type <a href='{}' class=\\\"type\\\">{}</a>\",\n+           extra,\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap())?;\n     if !bounds.is_empty() {\n@@ -3468,7 +3478,7 @@ fn render_assoc_item(w: &mut fmt::Formatter<'_>,\n         } else {\n             (0, true)\n         };\n-        render_attributes(w, meth)?;\n+        render_attributes(w, meth, false)?;\n         write!(w, \"{}{}{}{}{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n                if parent == ItemType::Trait { \"    \" } else { \"\" },\n@@ -3502,10 +3512,12 @@ fn render_assoc_item(w: &mut fmt::Formatter<'_>,\n             method(w, item, m.header, &m.generics, &m.decl, link, parent)\n         }\n         clean::AssociatedConstItem(ref ty, ref default) => {\n-            assoc_const(w, item, ty, default.as_ref(), link)\n+            assoc_const(w, item, ty, default.as_ref(), link,\n+                        if parent == ItemType::Trait { \"    \" } else { \"\" })\n         }\n         clean::AssociatedTypeItem(ref bounds, ref default) => {\n-            assoc_type(w, item, bounds, default.as_ref(), link)\n+            assoc_type(w, item, bounds, default.as_ref(), link,\n+                       if parent == ItemType::Trait { \"    \" } else { \"\" })\n         }\n         _ => panic!(\"render_assoc_item called on non-associated-item\")\n     }\n@@ -3515,7 +3527,7 @@ fn item_struct(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                s: &clean::Struct) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust struct'>\")?;\n-        render_attributes(w, it)?;\n+        render_attributes(w, it, true)?;\n         render_struct(w,\n                       it,\n                       Some(&s.generics),\n@@ -3566,7 +3578,7 @@ fn item_union(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                s: &clean::Union) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust union'>\")?;\n-        render_attributes(w, it)?;\n+        render_attributes(w, it, true)?;\n         render_union(w,\n                      it,\n                      Some(&s.generics),\n@@ -3611,7 +3623,7 @@ fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust enum'>\")?;\n-        render_attributes(w, it)?;\n+        render_attributes(w, it, true)?;\n         write!(w, \"{}enum {}{}{}\",\n                VisSpace(&it.visibility),\n                it.name.as_ref().unwrap(),\n@@ -3761,30 +3773,39 @@ fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n     }\n }\n \n-const ATTRIBUTE_WHITELIST: &'static [&'static str] = &[\n-    \"export_name\",\n-    \"lang\",\n-    \"link_section\",\n-    \"must_use\",\n-    \"no_mangle\",\n-    \"repr\",\n-    \"unsafe_destructor_blind_to_params\",\n-    \"non_exhaustive\"\n+const ATTRIBUTE_WHITELIST: &'static [Symbol] = &[\n+    sym::export_name,\n+    sym::lang,\n+    sym::link_section,\n+    sym::must_use,\n+    sym::no_mangle,\n+    sym::repr,\n+    sym::unsafe_destructor_blind_to_params,\n+    sym::non_exhaustive\n ];\n \n-fn render_attributes(w: &mut dyn fmt::Write, it: &clean::Item) -> fmt::Result {\n+// The `top` parameter is used when generating the item declaration to ensure it doesn't have a\n+// left padding. For example:\n+//\n+// #[foo] <----- \"top\" attribute\n+// struct Foo {\n+//     #[bar] <---- not \"top\" attribute\n+//     bar: usize,\n+// }\n+fn render_attributes(w: &mut dyn fmt::Write, it: &clean::Item, top: bool) -> fmt::Result {\n     let mut attrs = String::new();\n \n     for attr in &it.attrs.other_attrs {\n-        if !ATTRIBUTE_WHITELIST.contains(&attr.name_or_empty().get()) {\n+        if !ATTRIBUTE_WHITELIST.contains(&attr.name_or_empty()) {\n             continue;\n         }\n         if let Some(s) = render_attribute(&attr.meta().unwrap()) {\n             attrs.push_str(&format!(\"#[{}]\\n\", s));\n         }\n     }\n     if attrs.len() > 0 {\n-        write!(w, \"<div class=\\\"docblock attributes\\\">{}</div>\", &attrs)?;\n+        write!(w, \"<div class=\\\"docblock attributes{}\\\">{}</div>\",\n+               if top { \" top-attr\" } else { \"\" }, &attrs)?;\n     }\n     Ok(())\n }\n@@ -4117,7 +4138,8 @@ fn spotlight_decl(decl: &clean::FnDecl) -> Result<String, fmt::Error> {\n                             out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n                             assoc_type(&mut out, it, &[],\n                                        Some(&tydef.type_),\n-                                       AssocItemLink::GotoSource(t_did, &FxHashSet::default()))?;\n+                                       AssocItemLink::GotoSource(t_did, &FxHashSet::default()),\n+                                       \"\")?;\n                             out.push_str(\";</span>\");\n                         }\n                     }\n@@ -4157,7 +4179,8 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n                     if let clean::TypedefItem(ref tydef, _) = it.inner {\n                         write!(w, \"<span class=\\\"where fmt-newline\\\">  \")?;\n                         assoc_type(w, it, &vec![], Some(&tydef.type_),\n-                                   AssocItemLink::Anchor(None))?;\n+                                   AssocItemLink::Anchor(None),\n+                                   \"\")?;\n                         write!(w, \";</span>\")?;\n                     }\n                 }\n@@ -4179,7 +4202,8 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n         if let Some(ref dox) = cx.shared.maybe_collapsed_doc_value(&i.impl_item) {\n             let mut ids = cx.id_map.borrow_mut();\n             write!(w, \"<div class='docblock'>{}</div>\",\n-                   Markdown(&*dox, &i.impl_item.links(), RefCell::new(&mut ids), cx.codes))?;\n+                   Markdown(&*dox, &i.impl_item.links(), RefCell::new(&mut ids),\n+                            cx.codes, cx.edition))?;\n         }\n     }\n \n@@ -4227,15 +4251,15 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n                 let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                 write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class)?;\n                 write!(w, \"<code id='{}'>\", ns_id)?;\n-                assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id))?;\n+                assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id), \"\")?;\n                 write!(w, \"</code></h4>\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n                 let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                 let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                 write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class)?;\n                 write!(w, \"<code id='{}'>\", ns_id)?;\n-                assoc_const(w, item, ty, default.as_ref(), link.anchor(&id))?;\n+                assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\")?;\n                 write!(w, \"</code>\")?;\n                 render_stability_since_raw(w, item.stable_since(), outer_version)?;\n                 if let Some(l) = (Item { cx, item }).src_href() {\n@@ -4249,7 +4273,7 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n                 let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                 write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class)?;\n                 write!(w, \"<code id='{}'>\", ns_id)?;\n-                assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id))?;\n+                assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id), \"\")?;\n                 write!(w, \"</code></h4>\")?;\n             }\n             clean::StrippedItem(..) => return Ok(()),\n@@ -4337,7 +4361,7 @@ fn item_existential(\n     t: &clean::Existential,\n ) -> fmt::Result {\n     write!(w, \"<pre class='rust existential'>\")?;\n-    render_attributes(w, it)?;\n+    render_attributes(w, it, false)?;\n     write!(w, \"existential type {}{}{where_clause}: {bounds};</pre>\",\n            it.name.as_ref().unwrap(),\n            t.generics,\n@@ -4356,7 +4380,7 @@ fn item_existential(\n fn item_trait_alias(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                     t: &clean::TraitAlias) -> fmt::Result {\n     write!(w, \"<pre class='rust trait-alias'>\")?;\n-    render_attributes(w, it)?;\n+    render_attributes(w, it, false)?;\n     write!(w, \"trait {}{}{} = {};</pre>\",\n            it.name.as_ref().unwrap(),\n            t.generics,\n@@ -4375,7 +4399,7 @@ fn item_trait_alias(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n fn item_typedef(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n     write!(w, \"<pre class='rust typedef'>\")?;\n-    render_attributes(w, it)?;\n+    render_attributes(w, it, false)?;\n     write!(w, \"type {}{}{where_clause} = {type_};</pre>\",\n            it.name.as_ref().unwrap(),\n            t.generics,\n@@ -4393,7 +4417,7 @@ fn item_typedef(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n \n fn item_foreign_type(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item) -> fmt::Result {\n     writeln!(w, \"<pre class='rust foreigntype'>extern {{\")?;\n-    render_attributes(w, it)?;\n+    render_attributes(w, it, false)?;\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\","}, {"sha": "72a01a49bc66dc2d8ddaf1cda6195062f2bea2eb", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -2325,7 +2325,11 @@ if (!DOMTokenList.prototype.remove) {\n     }\n     var attributesToggle = createToggleWrapper(createSimpleToggle(false));\n     onEachLazy(main.getElementsByClassName(\"attributes\"), function(i_e) {\n-        i_e.parentNode.insertBefore(attributesToggle.cloneNode(true), i_e);\n+        var attr_tog = attributesToggle.cloneNode(true);\n+        if (hasClass(i_e, \"top-attr\") === true) {\n+            addClass(attr_tog, \"top-attr\");\n+        }\n+        i_e.parentNode.insertBefore(attr_tog, i_e);\n         itemAttributesFunc(i_e);\n     });\n "}, {"sha": "0493bf7c5c0f51c9045f89337db911f0c1a2d0a6", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 239, "deletions": 213, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -182,12 +182,25 @@ nav.sub {\n \tdisplay: none !important;\n }\n \n-.sidebar img {\n+.logo-container {\n+\theight: 100px;\n+\twidth: 100px;\n+\tposition: relative;\n \tmargin: 20px auto;\n \tdisplay: block;\n \tmargin-top: 10px;\n }\n \n+.logo-container > img {\n+\tmax-width: 100px;\n+\tmax-height: 100px;\n+\tposition: absolute;\n+\tleft: 50%;\n+\ttop: 50%;\n+\ttransform: translate(-50%, -50%);\n+\tdisplay: block;\n+}\n+\n .sidebar .location {\n \tborder: 1px solid;\n \tfont-size: 17px;\n@@ -658,18 +671,18 @@ a {\n \ttransition: border-color 300ms ease;\n \ttransition: border-radius 300ms ease-in-out;\n \ttransition: box-shadow 300ms ease-in-out;\n-\twidth: calc(100% - 32px);\n+\twidth: 100%;\n }\n \n #crate-search + .search-input {\n \tborder-radius: 0 1px 1px 0;\n+\twidth: calc(100% - 32px);\n }\n \n .search-input:focus {\n \tborder-radius: 2px;\n \tborder: 0;\n \toutline: 0;\n-\tbox-shadow: 0 0 8px #078dd8;\n }\n \n .search-results .desc {\n@@ -998,6 +1011,195 @@ h3 > .collapse-toggle, h4 > .collapse-toggle {\n \topacity: 1;\n }\n \n+.information {\n+\tposition: absolute;\n+\tleft: -20px;\n+\tmargin-top: 7px;\n+\tz-index: 1;\n+}\n+\n+.tooltip {\n+\tposition: relative;\n+\tdisplay: inline-block;\n+\tcursor: pointer;\n+}\n+\n+.tooltip .tooltiptext {\n+\twidth: 120px;\n+\tdisplay: none;\n+\ttext-align: center;\n+\tpadding: 5px 3px;\n+\tborder-radius: 6px;\n+\tmargin-left: 5px;\n+\ttop: -5px;\n+\tleft: 105%;\n+\tz-index: 10;\n+}\n+\n+.tooltip:hover .tooltiptext {\n+\tdisplay: inline;\n+}\n+\n+.tooltip .tooltiptext::after {\n+\tcontent: \" \";\n+\tposition: absolute;\n+\ttop: 50%;\n+\tleft: 11px;\n+\tmargin-top: -5px;\n+\tborder-width: 5px;\n+\tborder-style: solid;\n+}\n+\n+.important-traits .tooltip .tooltiptext {\n+\tborder: 1px solid;\n+}\n+\n+pre.rust {\n+\tposition: relative;\n+\ttab-width: 4;\n+\t-moz-tab-width: 4;\n+}\n+\n+.search-failed {\n+\ttext-align: center;\n+\tmargin-top: 20px;\n+}\n+\n+.search-failed > ul {\n+\ttext-align: left;\n+\tmax-width: 570px;\n+\tmargin-left: auto;\n+\tmargin-right: auto;\n+}\n+\n+#titles {\n+\theight: 35px;\n+}\n+\n+#titles > div {\n+\tfloat: left;\n+\twidth: 33.3%;\n+\ttext-align: center;\n+\tfont-size: 18px;\n+\tcursor: pointer;\n+\tborder-top: 2px solid;\n+}\n+\n+#titles > div:not(:last-child) {\n+\tmargin-right: 1px;\n+\twidth: calc(33.3% - 1px);\n+}\n+\n+#titles > div > div.count {\n+\tdisplay: inline-block;\n+\tfont-size: 16px;\n+}\n+\n+.important-traits {\n+\tcursor: pointer;\n+\tz-index: 2;\n+}\n+\n+h4 > .important-traits {\n+\tposition: absolute;\n+\tleft: -44px;\n+\ttop: 2px;\n+}\n+\n+#all-types {\n+\ttext-align: center;\n+\tborder: 1px solid;\n+\tmargin: 0 10px;\n+\tmargin-bottom: 10px;\n+\tdisplay: block;\n+\tborder-radius: 7px;\n+}\n+#all-types > p {\n+\tmargin: 5px 0;\n+}\n+\n+#sidebar-toggle {\n+\tposition: fixed;\n+\ttop: 30px;\n+\tleft: 300px;\n+\tz-index: 10;\n+\tpadding: 3px;\n+\tborder-top-right-radius: 3px;\n+\tborder-bottom-right-radius: 3px;\n+\tcursor: pointer;\n+\tfont-weight: bold;\n+\ttransition: left .5s;\n+\tfont-size: 1.2em;\n+\tborder: 1px solid;\n+\tborder-left: 0;\n+}\n+#source-sidebar {\n+\tposition: fixed;\n+\ttop: 0;\n+\tbottom: 0;\n+\tleft: 0;\n+\twidth: 300px;\n+\tz-index: 1;\n+\toverflow: auto;\n+\ttransition: left .5s;\n+\tborder-right: 1px solid;\n+}\n+#source-sidebar > .title {\n+\tfont-size: 1.5em;\n+\ttext-align: center;\n+\tborder-bottom: 1px solid;\n+\tmargin-bottom: 6px;\n+}\n+\n+.theme-picker {\n+\tposition: absolute;\n+\tleft: 211px;\n+\ttop: 19px;\n+}\n+\n+.theme-picker button {\n+\toutline: none;\n+}\n+\n+#settings-menu {\n+\tposition: absolute;\n+\tright: 0;\n+\ttop: 10px;\n+\toutline: none;\n+}\n+\n+#theme-picker, #settings-menu {\n+\tpadding: 4px;\n+\twidth: 27px;\n+\theight: 29px;\n+\tborder: 1px solid;\n+\tborder-radius: 3px;\n+\tcursor: pointer;\n+}\n+\n+#theme-choices {\n+\tdisplay: none;\n+\tposition: absolute;\n+\tleft: 0;\n+\ttop: 28px;\n+\tborder: 1px solid;\n+\tborder-radius: 3px;\n+\tz-index: 1;\n+\tcursor: pointer;\n+}\n+\n+#theme-choices > button {\n+\tborder: none;\n+\twidth: 100%;\n+\tpadding: 4px;\n+\ttext-align: center;\n+\tbackground: rgba(0,0,0,0);\n+}\n+\n+#theme-choices > button:not(:first-child) {\n+\tborder-top: 1px solid;\n+}\n+\n /* Media Queries */\n \n @media (max-width: 700px) {\n@@ -1030,14 +1232,20 @@ h3 > .collapse-toggle, h4 > .collapse-toggle {\n \t\tpadding: 0;\n \t}\n \n-\t.sidebar img {\n+\t.sidebar .logo-container {\n \t\twidth: 35px;\n+\t\theight: 35px;\n \t\tmargin-top: 5px;\n \t\tmargin-bottom: 5px;\n \t\tfloat: left;\n \t\tmargin-left: 50px;\n \t}\n \n+\t.sidebar .logo-container > img {\n+\t\tmax-width: 35px;\n+\t\tmax-height: 35px;\n+\t}\n+\n \t.sidebar-menu {\n \t\tposition: fixed;\n \t\tz-index: 10;\n@@ -1118,125 +1326,12 @@ h3 > .collapse-toggle, h4 > .collapse-toggle {\n \t\toverflow: initial;\n \t}\n \n-\t#main > .line-numbers {\n-\t\tmargin-top: 0;\n-\t}\n-}\n-\n-@media print {\n-\tnav.sub, .content .out-of-band, .collapse-toggle {\n-\t\tdisplay: none;\n+\t.theme-picker {\n+\t\tleft: 10px;\n+\t\ttop: 54px;\n+\t\tz-index: 1;\n \t}\n-}\n \n-.information {\n-\tposition: absolute;\n-\tleft: -20px;\n-\tmargin-top: 7px;\n-\tz-index: 1;\n-}\n-\n-.tooltip {\n-\tposition: relative;\n-\tdisplay: inline-block;\n-\tcursor: pointer;\n-}\n-\n-.tooltip .tooltiptext {\n-\twidth: 120px;\n-\tdisplay: none;\n-\ttext-align: center;\n-\tpadding: 5px 3px;\n-\tborder-radius: 6px;\n-\tmargin-left: 5px;\n-\ttop: -5px;\n-\tleft: 105%;\n-\tz-index: 10;\n-}\n-\n-.tooltip:hover .tooltiptext {\n-\tdisplay: inline;\n-}\n-\n-.tooltip .tooltiptext::after {\n-\tcontent: \" \";\n-\tposition: absolute;\n-\ttop: 50%;\n-\tleft: 11px;\n-\tmargin-top: -5px;\n-\tborder-width: 5px;\n-\tborder-style: solid;\n-}\n-\n-.important-traits .tooltip .tooltiptext {\n-\tborder: 1px solid;\n-}\n-\n-pre.rust {\n-\tposition: relative;\n-\ttab-width: 4;\n-\t-moz-tab-width: 4;\n-}\n-\n-.search-failed {\n-\ttext-align: center;\n-\tmargin-top: 20px;\n-}\n-\n-.search-failed > ul {\n-\ttext-align: left;\n-\tmax-width: 570px;\n-\tmargin-left: auto;\n-\tmargin-right: auto;\n-}\n-\n-#titles {\n-\theight: 35px;\n-}\n-\n-#titles > div {\n-\tfloat: left;\n-\twidth: 33.3%;\n-\ttext-align: center;\n-\tfont-size: 18px;\n-\tcursor: pointer;\n-\tborder-top: 2px solid;\n-}\n-\n-#titles > div:not(:last-child) {\n-\tmargin-right: 1px;\n-\twidth: calc(33.3% - 1px);\n-}\n-\n-#titles > div > div.count {\n-\tdisplay: inline-block;\n-\tfont-size: 16px;\n-}\n-\n-.important-traits {\n-\tcursor: pointer;\n-\tz-index: 2;\n-}\n-\n-h4 > .important-traits {\n-\tposition: absolute;\n-\tleft: -44px;\n-\ttop: 2px;\n-}\n-\n-#all-types {\n-\ttext-align: center;\n-\tborder: 1px solid;\n-\tmargin: 0 10px;\n-\tmargin-bottom: 10px;\n-\tdisplay: block;\n-\tborder-radius: 7px;\n-}\n-#all-types > p {\n-\tmargin: 5px 0;\n-}\n-\n-@media (max-width: 700px) {\n \th4 > .important-traits {\n \t\tposition: absolute;\n \t\tleft: -22px;\n@@ -1311,8 +1406,29 @@ h4 > .important-traits {\n \t#all-types {\n \t\tmargin: 10px;\n \t}\n+\n+\t#sidebar-toggle {\n+\t\ttop: 100px;\n+\t\twidth: 30px;\n+\t\tfont-size: 1.5rem;\n+\t\ttext-align: center;\n+\t\tpadding: 0;\n+\t}\n+\n+\t#source-sidebar {\n+\t\tz-index: 11;\n+\t}\n+\n+\t#main > .line-numbers {\n+\t\tmargin-top: 0;\n+\t}\n }\n \n+@media print {\n+\tnav.sub, .content .out-of-band, .collapse-toggle {\n+\t\tdisplay: none;\n+\t}\n+}\n \n @media (max-width: 416px) {\n \t#titles {\n@@ -1412,63 +1528,6 @@ kbd {\n \tcursor: default;\n }\n \n-.theme-picker {\n-\tposition: absolute;\n-\tleft: 211px;\n-\ttop: 19px;\n-}\n-\n-.theme-picker button {\n-\toutline: none;\n-}\n-\n-#settings-menu {\n-\tposition: absolute;\n-\tright: 0;\n-\ttop: 10px;\n-\toutline: none;\n-}\n-\n-#theme-picker, #settings-menu {\n-\tpadding: 4px;\n-\twidth: 27px;\n-\theight: 29px;\n-\tborder: 1px solid;\n-\tborder-radius: 3px;\n-\tcursor: pointer;\n-}\n-\n-#theme-choices {\n-\tdisplay: none;\n-\tposition: absolute;\n-\tleft: 0;\n-\ttop: 28px;\n-\tborder: 1px solid;\n-\tborder-radius: 3px;\n-\tz-index: 1;\n-\tcursor: pointer;\n-}\n-\n-#theme-choices > button {\n-\tborder: none;\n-\twidth: 100%;\n-\tpadding: 4px;\n-\ttext-align: center;\n-\tbackground: rgba(0,0,0,0);\n-}\n-\n-#theme-choices > button:not(:first-child) {\n-\tborder-top: 1px solid;\n-}\n-\n-@media (max-width: 700px) {\n-\t.theme-picker {\n-\t\tleft: 10px;\n-\t\ttop: 54px;\n-\t\tz-index: 1;\n-\t}\n-}\n-\n .hidden-by-impl-hider,\n .hidden-by-usual-hider {\n \t/* important because of conflicting rule for small screens */\n@@ -1520,39 +1579,6 @@ kbd {\n \tmargin-bottom: 1em;\n }\n \n-#sidebar-toggle {\n-\tposition: fixed;\n-\ttop: 30px;\n-\tleft: 300px;\n-\tz-index: 10;\n-\tpadding: 3px;\n-\tborder-top-right-radius: 3px;\n-\tborder-bottom-right-radius: 3px;\n-\tcursor: pointer;\n-\tfont-weight: bold;\n-\ttransition: left .5s;\n-\tfont-size: 1.2em;\n-\tborder: 1px solid;\n-\tborder-left: 0;\n-}\n-#source-sidebar {\n-\tposition: fixed;\n-\ttop: 0;\n-\tbottom: 0;\n-\tleft: 0;\n-\twidth: 300px;\n-\tz-index: 1;\n-\toverflow: auto;\n-\ttransition: left .5s;\n-\tborder-right: 1px solid;\n-}\n-#source-sidebar > .title {\n-\tfont-size: 1.5em;\n-\ttext-align: center;\n-\tborder-bottom: 1px solid;\n-\tmargin-bottom: 6px;\n-}\n-\n div.children {\n \tpadding-left: 27px;\n \tdisplay: none;\n@@ -1587,10 +1613,10 @@ div.name.expand::before {\n }\n \n /* This part is to fix the \"Expand attributes\" part in the type declaration. */\n-.type-decl > pre > :first-child {\n+.type-decl > pre > .toggle-wrapper.toggle-attributes.top-attr {\n \tmargin-left: 0 !important;\n }\n-.type-decl > pre > :nth-child(2) {\n+.type-decl > pre > .docblock.attributes.top-attr {\n \tmargin-left: 1.8em !important;\n }\n .type-decl > pre > .toggle-attributes {"}, {"sha": "e44ae2ad10cee286cba893f9ac63cffd2f96e6de", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -164,20 +164,21 @@ a.test-arrow {\n \tcolor: #111;\n \tbackground-color: #f0f0f0;\n \tborder-color: #000;\n+\tbox-shadow: 0 0 0 1px #000, 0 0 0 2px transparent;\n }\n \n .search-input {\n \tcolor: #111;\n-\tbox-shadow: 0 0 0 1px #000, 0 0 0 2px transparent;\n \tbackground-color: #f0f0f0;\n+\tbox-shadow: 0 0 0 1px #000, 0 0 0 2px transparent;\n }\n \n .search-input:focus {\n \tborder-color: #008dfd;\n }\n \n-#crate-search + .search-input {\n-\tbox-shadow: 1px 0 0 1px #000, 0 0 0 2px transparent;\n+#crate-search + .search-input:focus {\n+\tbox-shadow: 0 0 8px 4px #078dd8;\n }\n \n .module-item .stab {"}, {"sha": "4c37000dde2c5e4f6840309b237eae17d85e0461", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -164,21 +164,21 @@ a.test-arrow {\n \tcolor: #555;\n \tbackground-color: white;\n \tborder-color: #e0e0e0;\n-\tbox-shadow: 0px 0 0 1px #e0e0e0, 0 0 0 2px transparent;\n+\tbox-shadow: 0 0 0 1px #e0e0e0, 0 0 0 2px transparent;\n }\n \n .search-input {\n \tcolor: #555;\n-\tbox-shadow: 0 0 0 1px #e0e0e0, 0 0 0 2px transparent;\n \tbackground-color: white;\n+\tbox-shadow: 0 0 0 1px #e0e0e0, 0 0 0 2px transparent;\n }\n \n .search-input:focus {\n \tborder-color: #66afe9;\n }\n \n-#crate-search + .search-input {\n-\tbox-shadow: 1px 0 0 1px #e0e0e0, 0 0 0 2px transparent;\n+#crate-search + .search-input:focus {\n+\tbox-shadow: 0 0 8px #078dd8;\n }\n \n .module-item .stab {"}, {"sha": "f5061b671828e04e704509fa535b531ba6cc941d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -391,15 +391,19 @@ fn main_args(args: &[String]) -> i32 {\n     match (options.should_test, options.markdown_input()) {\n         (true, true) => return markdown::test(options, &diag),\n         (true, false) => return test::run(options),\n-        (false, true) => return markdown::render(options.input, options.render_options, &diag),\n+        (false, true) => return markdown::render(options.input,\n+                                                 options.render_options,\n+                                                 &diag,\n+                                                 options.edition),\n         (false, false) => {}\n     }\n \n     // need to move these items separately because we lose them by the time the closure is called,\n     // but we can't crates the Handler ahead of time because it's not Send\n     let diag_opts = (options.error_format,\n                      options.debugging_options.treat_err_as_bug,\n-                     options.debugging_options.ui_testing);\n+                     options.debugging_options.ui_testing,\n+                     options.edition);\n     let show_coverage = options.show_coverage;\n     rust_input(options, move |out| {\n         if show_coverage {\n@@ -410,14 +414,15 @@ fn main_args(args: &[String]) -> i32 {\n \n         let Output { krate, passes, renderinfo, renderopts } = out;\n         info!(\"going to format\");\n-        let (error_format, treat_err_as_bug, ui_testing) = diag_opts;\n+        let (error_format, treat_err_as_bug, ui_testing, edition) = diag_opts;\n         let diag = core::new_handler(error_format, None, treat_err_as_bug, ui_testing);\n         match html::render::run(\n             krate,\n             renderopts,\n             passes.into_iter().collect(),\n             renderinfo,\n             &diag,\n+            edition,\n         ) {\n             Ok(_) => rustc_driver::EXIT_SUCCESS,\n             Err(e) => {"}, {"sha": "b0a37ea9c8081f50025fad2cfa5d50f5b0e80e1d", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -5,6 +5,7 @@ use std::cell::RefCell;\n \n use errors;\n use testing;\n+use syntax::edition::Edition;\n use syntax::source_map::DUMMY_SP;\n use syntax::feature_gate::UnstableFeatures;\n \n@@ -36,7 +37,12 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n \n /// Render `input` (e.g., \"foo.md\") into an HTML file in `output`\n /// (e.g., output = \"bar\" => \"bar/foo.html\").\n-pub fn render(input: PathBuf, options: RenderOptions, diag: &errors::Handler) -> i32 {\n+pub fn render(\n+    input: PathBuf,\n+    options: RenderOptions,\n+    diag: &errors::Handler,\n+    edition: Edition\n+) -> i32 {\n     let mut output = options.output;\n     output.push(input.file_stem().unwrap());\n     output.set_extension(\"html\");\n@@ -76,9 +82,9 @@ pub fn render(input: PathBuf, options: RenderOptions, diag: &errors::Handler) ->\n     let mut ids = IdMap::new();\n     let error_codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n     let text = if !options.markdown_no_toc {\n-        MarkdownWithToc(text, RefCell::new(&mut ids), error_codes).to_string()\n+        MarkdownWithToc(text, RefCell::new(&mut ids), error_codes, edition).to_string()\n     } else {\n-        Markdown(text, &[], RefCell::new(&mut ids), error_codes).to_string()\n+        Markdown(text, &[], RefCell::new(&mut ids), error_codes, edition).to_string()\n     };\n \n     let err = write!("}, {"sha": "4ee09f7096b6163a90162d7057085d80b3aa658f", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -5,6 +5,7 @@ use crate::passes::Pass;\n \n use syntax::attr;\n use syntax_pos::FileName;\n+use syntax::symbol::sym;\n \n use std::collections::BTreeMap;\n use std::ops;\n@@ -131,7 +132,7 @@ impl fold::DocFolder for CoverageCalculator {\n                 return Some(i);\n             }\n             clean::ImplItem(ref impl_)\n-                if attr::contains_name(&i.attrs.other_attrs, \"automatically_derived\")\n+                if attr::contains_name(&i.attrs.other_attrs, sym::automatically_derived)\n                     || impl_.synthetic || impl_.blanket_impl.is_some() =>\n             {\n                 // built-in derives get the `#[automatically_derived]` attribute, and"}, {"sha": "2c382a1c1759632806bb316f621aa582564b9fe0", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             // Try looking for methods and associated items.\n             let mut split = path_str.rsplitn(2, \"::\");\n             let item_name = if let Some(first) = split.next() {\n-                first\n+                Symbol::intern(first)\n             } else {\n                 return Err(())\n             };\n@@ -321,7 +321,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         if let Ok(res) = self.resolve(path_str, ns, &current_item, parent_node) {\n                             res\n                         } else {\n-                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            resolution_failure(cx, &item, path_str, &dox, link_range);\n                             // This could just be a normal link or a broken link\n                             // we could potentially check if something is\n                             // \"intra-doc-link-like\" and warn in that case.\n@@ -332,7 +332,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         if let Ok(res) = self.resolve(path_str, ns, &current_item, parent_node) {\n                             res\n                         } else {\n-                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            resolution_failure(cx, &item, path_str, &dox, link_range);\n                             // This could just be a normal link.\n                             continue;\n                         }\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         };\n \n                         if candidates.is_empty() {\n-                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            resolution_failure(cx, &item, path_str, &dox, link_range);\n                             // this could just be a normal link\n                             continue;\n                         }\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         } else {\n                             ambiguity_error(\n                                 cx,\n-                                &item.attrs,\n+                                &item,\n                                 path_str,\n                                 &dox,\n                                 link_range,\n@@ -381,7 +381,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         if let Some(res) = macro_resolve(cx, path_str) {\n                             (res, None)\n                         } else {\n-                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            resolution_failure(cx, &item, path_str, &dox, link_range);\n                             continue\n                         }\n                     }\n@@ -452,16 +452,24 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n /// line containing the failure as a note as well.\n fn resolution_failure(\n     cx: &DocContext<'_>,\n-    attrs: &Attributes,\n+    item: &Item,\n     path_str: &str,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n ) {\n+    let hir_id = match cx.as_local_hir_id(item.def_id) {\n+        Some(hir_id) => hir_id,\n+        None => {\n+            // If non-local, no need to check anything.\n+            return;\n+        }\n+    };\n+    let attrs = &item.attrs;\n     let sp = span_of_attrs(attrs);\n \n     let mut diag = cx.tcx.struct_span_lint_hir(\n         lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-        hir::CRATE_HIR_ID,\n+        hir_id,\n         sp,\n         &format!(\"`[{}]` cannot be resolved, ignoring it...\", path_str),\n     );\n@@ -495,12 +503,20 @@ fn resolution_failure(\n \n fn ambiguity_error(\n     cx: &DocContext<'_>,\n-    attrs: &Attributes,\n+    item: &Item,\n     path_str: &str,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n     candidates: PerNS<Option<Res>>,\n ) {\n+    let hir_id = match cx.as_local_hir_id(item.def_id) {\n+        Some(hir_id) => hir_id,\n+        None => {\n+            // If non-local, no need to check anything.\n+            return;\n+        }\n+    };\n+    let attrs = &item.attrs;\n     let sp = span_of_attrs(attrs);\n \n     let mut msg = format!(\"`{}` is \", path_str);\n@@ -532,7 +548,7 @@ fn ambiguity_error(\n \n     let mut diag = cx.tcx.struct_span_lint_hir(\n         lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-        hir::CRATE_HIR_ID,\n+        hir_id,\n         sp,\n         &msg,\n     );"}, {"sha": "70cd4b72199bca2f73a97531f38fd02c9201032b", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -5,6 +5,7 @@ use super::Pass;\n \n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::def_id::DefId;\n+use syntax::symbol::sym;\n \n pub const COLLECT_TRAIT_IMPLS: Pass = Pass {\n     name: \"collect-trait-impls\",\n@@ -68,7 +69,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n             inline::build_impl(cx, def_id, &mut new_items);\n \n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n-            if !cx.tcx.get_attrs(def_id).lists(\"doc\").has_word(\"hidden\") {\n+            if !cx.tcx.get_attrs(def_id).lists(sym::doc).has_word(sym::hidden) {\n                 let self_ty = cx.tcx.type_of(def_id);\n                 let impls = get_auto_trait_and_blanket_impls(cx, self_ty, def_id);\n                 let mut renderinfo = cx.renderinfo.borrow_mut();\n@@ -154,7 +155,7 @@ impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n-            if !self.cx.tcx.get_attrs(i.def_id).lists(\"doc\").has_word(\"hidden\") {\n+            if !self.cx.tcx.get_attrs(i.def_id).lists(sym::doc).has_word(sym::hidden) {\n                 self.impls.extend(get_auto_trait_and_blanket_impls(\n                     self.cx,\n                     self.cx.tcx.type_of(i.def_id),"}, {"sha": "d9af33ac5b622a39f288c14b3eca760c02900245", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,7 +1,6 @@\n //! Contains information about \"passes\", used to modify crate information during the documentation\n //! process.\n \n-use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::lint as lint;\n use rustc::middle::privacy::AccessLevels;\n@@ -314,10 +313,13 @@ pub fn look_for_tests<'tcx>(\n     item: &Item,\n     check_missing_code: bool,\n ) {\n-    if cx.as_local_hir_id(item.def_id).is_none() {\n-        // If non-local, no need to check anything.\n-        return;\n-    }\n+    let hir_id = match cx.as_local_hir_id(item.def_id) {\n+        Some(hir_id) => hir_id,\n+        None => {\n+            // If non-local, no need to check anything.\n+            return;\n+        }\n+    };\n \n     struct Tests {\n         found_tests: usize,\n@@ -336,18 +338,19 @@ pub fn look_for_tests<'tcx>(\n     find_testable_code(&dox, &mut tests, ErrorCodes::No);\n \n     if check_missing_code == true && tests.found_tests == 0 {\n+        let sp = span_of_attrs(&item.attrs).substitute_dummy(item.source.span());\n         let mut diag = cx.tcx.struct_span_lint_hir(\n             lint::builtin::MISSING_DOC_CODE_EXAMPLES,\n-            hir::CRATE_HIR_ID,\n-            span_of_attrs(&item.attrs),\n+            hir_id,\n+            sp,\n             \"Missing code example in this documentation\");\n         diag.emit();\n     } else if check_missing_code == false &&\n               tests.found_tests > 0 &&\n               !cx.renderinfo.borrow().access_levels.is_doc_reachable(item.def_id) {\n         let mut diag = cx.tcx.struct_span_lint_hir(\n             lint::builtin::PRIVATE_DOC_TESTS,\n-            hir::CRATE_HIR_ID,\n+            hir_id,\n             span_of_attrs(&item.attrs),\n             \"Documentation test in private item\");\n         diag.emit();"}, {"sha": "da8977544f64bc17da8a968c0252ad2f03581607", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,5 +1,6 @@\n use rustc::util::nodemap::DefIdSet;\n use std::mem;\n+use syntax::symbol::sym;\n \n use crate::clean::{self, AttributesExt, NestedAttributesExt};\n use crate::clean::Item;\n@@ -37,7 +38,7 @@ struct Stripper<'a> {\n \n impl<'a> DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if i.attrs.lists(\"doc\").has_word(\"hidden\") {\n+        if i.attrs.lists(sym::doc).has_word(sym::hidden) {\n             debug!(\"strip_hidden: stripping {} {:?}\", i.type_(), i.name);\n             // use a dedicated hidden item for given item type if any\n             match i.inner {"}, {"sha": "0cc99da64079c006efb0df5493b1c210ac6cecf0", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -11,10 +11,6 @@ use syntax::ast;\n use syntax::source_map::SourceMap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax_pos::{BytePos, DUMMY_SP, Pos, Span, FileName};\n-use tempfile::Builder as TempFileBuilder;\n-use testing;\n-\n use std::env;\n use std::io::prelude::*;\n use std::io;\n@@ -23,6 +19,10 @@ use std::path::PathBuf;\n use std::process::Command;\n use std::str;\n use std::sync::{Arc, Mutex};\n+use syntax::symbol::sym;\n+use syntax_pos::{BytePos, DUMMY_SP, Pos, Span, FileName};\n+use tempfile::Builder as TempFileBuilder;\n+use testing;\n \n use crate::clean::Attributes;\n use crate::config::Options;\n@@ -137,17 +137,17 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n     };\n \n     let test_attrs: Vec<_> = krate.attrs.iter()\n-        .filter(|a| a.check_name(\"doc\"))\n+        .filter(|a| a.check_name(sym::doc))\n         .flat_map(|a| a.meta_item_list().unwrap_or_else(Vec::new))\n-        .filter(|a| a.check_name(\"test\"))\n+        .filter(|a| a.check_name(sym::test))\n         .collect();\n     let attrs = test_attrs.iter().flat_map(|a| a.meta_item_list().unwrap_or(&[]));\n \n     for attr in attrs {\n-        if attr.check_name(\"no_crate_inject\") {\n+        if attr.check_name(sym::no_crate_inject) {\n             opts.no_crate_inject = true;\n         }\n-        if attr.check_name(\"attr\") {\n+        if attr.check_name(sym::attr) {\n             if let Some(l) = attr.meta_item_list() {\n                 for item in l {\n                     opts.attrs.push(pprust::meta_list_item_to_string(item));\n@@ -167,7 +167,7 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n             maybe_sysroot: Option<PathBuf>, linker: Option<PathBuf>, edition: Edition,\n             persist_doctests: Option<PathBuf>) {\n     let (test, line_offset) = match panic::catch_unwind(|| {\n-        make_test(test, Some(cratename), as_test_harness, opts)\n+        make_test(test, Some(cratename), as_test_harness, opts, edition)\n     }) {\n         Ok((test, line_offset)) => (test, line_offset),\n         Err(cause) if cause.is::<errors::FatalErrorMarker>() => {\n@@ -356,7 +356,8 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n pub fn make_test(s: &str,\n                  cratename: Option<&str>,\n                  dont_insert_main: bool,\n-                 opts: &TestOptions)\n+                 opts: &TestOptions,\n+                 edition: Edition)\n                  -> (String, usize) {\n     let (crate_attrs, everything_else, crates) = partition_source(s);\n     let everything_else = everything_else.trim();\n@@ -390,13 +391,16 @@ pub fn make_test(s: &str,\n         use errors::emitter::EmitterWriter;\n         use errors::Handler;\n \n+        syntax::ext::hygiene::set_default_edition(edition);\n+\n         let filename = FileName::anon_source_code(s);\n         let source = crates + &everything_else;\n \n         // Any errors in parsing should also appear when the doctest is compiled for real, so just\n         // send all the errors that libsyntax emits directly into a `Sink` instead of stderr.\n         let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let emitter = EmitterWriter::new(box io::sink(), None, false, false, false);\n+        // FIXME(misdreavus): pass `-Z treat-err-as-bug` to the doctest parser\n         let handler = Handler::with_emitter(false, None, box emitter);\n         let sess = ParseSess::with_span_handler(handler, cm);\n \n@@ -880,6 +884,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n #[cfg(test)]\n mod tests {\n     use super::{TestOptions, make_test};\n+    use syntax::edition::DEFAULT_EDITION;\n \n     #[test]\n     fn make_test_basic() {\n@@ -892,7 +897,7 @@ mod tests {\n fn main() {\n assert_eq!(2+2, 4);\n }\".to_string();\n-        let output = make_test(input, None, false, &opts);\n+        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 2));\n     }\n \n@@ -908,7 +913,7 @@ assert_eq!(2+2, 4);\n fn main() {\n assert_eq!(2+2, 4);\n }\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts);\n+        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 2));\n     }\n \n@@ -927,7 +932,7 @@ fn main() {\n use asdf::qwop;\n assert_eq!(2+2, 4);\n }\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts);\n+        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 3));\n     }\n \n@@ -949,7 +954,7 @@ fn main() {\n use asdf::qwop;\n assert_eq!(2+2, 4);\n }\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts);\n+        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 2));\n     }\n \n@@ -968,7 +973,7 @@ fn main() {\n use std::*;\n assert_eq!(2+2, 4);\n }\".to_string();\n-        let output = make_test(input, Some(\"std\"), false, &opts);\n+        let output = make_test(input, Some(\"std\"), false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 2));\n     }\n \n@@ -988,7 +993,7 @@ fn main() {\n use asdf::qwop;\n assert_eq!(2+2, 4);\n }\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts);\n+        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 2));\n     }\n \n@@ -1006,7 +1011,7 @@ fn main() {\n use asdf::qwop;\n assert_eq!(2+2, 4);\n }\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts);\n+        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 2));\n     }\n \n@@ -1026,7 +1031,7 @@ fn main() {\n use asdf::qwop;\n assert_eq!(2+2, 4);\n }\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts);\n+        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 3));\n \n         // Adding more will also bump the returned line offset.\n@@ -1039,7 +1044,7 @@ fn main() {\n use asdf::qwop;\n assert_eq!(2+2, 4);\n }\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts);\n+        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 4));\n     }\n \n@@ -1057,7 +1062,7 @@ assert_eq!(2+2, 4);\";\n fn main() {\n assert_eq!(2+2, 4);\n }\".to_string();\n-        let output = make_test(input, None, false, &opts);\n+        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 2));\n     }\n \n@@ -1074,7 +1079,7 @@ assert_eq!(2+2, 4);\n fn main() {\n     assert_eq!(2+2, 4);\n }\".to_string();\n-        let output = make_test(input, None, false, &opts);\n+        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 1));\n     }\n \n@@ -1091,7 +1096,7 @@ assert_eq!(2+2, 4);\";\n fn main() {\n assert_eq!(2+2, 4);\n }\".to_string();\n-        let output = make_test(input, None, false, &opts);\n+        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 2));\n     }\n \n@@ -1106,7 +1111,7 @@ assert_eq!(2+2, 4);\";\n \"#![allow(unused)]\n //Ceci n'est pas une `fn main`\n assert_eq!(2+2, 4);\".to_string();\n-        let output = make_test(input, None, true, &opts);\n+        let output = make_test(input, None, true, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 1));\n     }\n \n@@ -1121,7 +1126,7 @@ assert_eq!(2+2, 4);\".to_string();\n \"fn main() {\n assert_eq!(2+2, 4);\n }\".to_string();\n-        let output = make_test(input, None, false, &opts);\n+        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 1));\n     }\n \n@@ -1140,7 +1145,7 @@ fn main() {\n assert_eq!(2+2, 4);\n }\".to_string();\n \n-        let output = make_test(input, None, false, &opts);\n+        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 2));\n \n         let input =\n@@ -1155,7 +1160,7 @@ fn main() {\n assert_eq!(asdf::foo, 4);\n }\".to_string();\n \n-        let output = make_test(input, Some(\"asdf\"), false, &opts);\n+        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 3));\n     }\n \n@@ -1174,7 +1179,7 @@ test_wrapper! {\n     fn main() {}\n }\".to_string();\n \n-        let output = make_test(input, Some(\"my_crate\"), false, &opts);\n+        let output = make_test(input, Some(\"my_crate\"), false, &opts, DEFAULT_EDITION);\n         assert_eq!(output, (expected, 1));\n     }\n }"}, {"sha": "eb9de43e388618ab67736d4812da305bf3832817", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -10,6 +10,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::MacroKind;\n use syntax::source_map::Spanned;\n+use syntax::symbol::sym;\n use syntax_pos::{self, Span};\n \n use std::mem;\n@@ -165,11 +166,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     body: hir::BodyId) {\n         debug!(\"Visiting fn\");\n         let macro_kind = item.attrs.iter().filter_map(|a| {\n-            if a.check_name(\"proc_macro\") {\n+            if a.check_name(sym::proc_macro) {\n                 Some(MacroKind::Bang)\n-            } else if a.check_name(\"proc_macro_derive\") {\n+            } else if a.check_name(sym::proc_macro_derive) {\n                 Some(MacroKind::Derive)\n-            } else if a.check_name(\"proc_macro_attribute\") {\n+            } else if a.check_name(sym::proc_macro_attribute) {\n                 Some(MacroKind::Attr)\n             } else {\n                 None\n@@ -178,7 +179,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         match macro_kind {\n             Some(kind) => {\n                 let name = if kind == MacroKind::Derive {\n-                    item.attrs.lists(\"proc_macro_derive\")\n+                    item.attrs.lists(sym::proc_macro_derive)\n                               .filter_map(|mi| mi.ident())\n                               .next()\n                               .expect(\"proc-macro derives require a name\")\n@@ -188,8 +189,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n \n                 let mut helpers = Vec::new();\n-                for mi in item.attrs.lists(\"proc_macro_derive\") {\n-                    if !mi.check_name(\"attributes\") {\n+                for mi in item.attrs.lists(sym::proc_macro_derive) {\n+                    if !mi.check_name(sym::attributes) {\n                         continue;\n                     }\n \n@@ -274,7 +275,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         fn inherits_doc_hidden(cx: &core::DocContext<'_>, mut node: hir::HirId) -> bool {\n             while let Some(id) = cx.tcx.hir().get_enclosing_scope(node) {\n                 node = id;\n-                if cx.tcx.hir().attrs_by_hir_id(node).lists(\"doc\").has_word(\"hidden\") {\n+                if cx.tcx.hir().attrs_by_hir_id(node)\n+                    .lists(sym::doc).has_word(sym::hidden) {\n                     return true;\n                 }\n                 if node == hir::CRATE_HIR_ID {\n@@ -295,16 +297,16 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         let use_attrs = tcx.hir().attrs_by_hir_id(id);\n         // Don't inline `doc(hidden)` imports so they can be stripped at a later stage.\n-        let is_no_inline = use_attrs.lists(\"doc\").has_word(\"no_inline\") ||\n-                           use_attrs.lists(\"doc\").has_word(\"hidden\");\n+        let is_no_inline = use_attrs.lists(sym::doc).has_word(sym::no_inline) ||\n+                           use_attrs.lists(sym::doc).has_word(sym::hidden);\n \n         // For cross-crate impl inlining we need to know whether items are\n         // reachable in documentation -- a previously nonreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront).\n         if !res_did.is_local() && !is_no_inline {\n             let attrs = clean::inline::load_attrs(self.cx, res_did);\n-            let self_is_hidden = attrs.lists(\"doc\").has_word(\"hidden\");\n+            let self_is_hidden = attrs.lists(sym::doc).has_word(sym::hidden);\n             match res {\n                 Res::Def(DefKind::Trait, did) |\n                 Res::Def(DefKind::Struct, did) |\n@@ -432,8 +434,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 if item.vis.node.is_pub() && self.inside_public_path {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n-                            Some(ref list) if item.check_name(\"doc\") => {\n-                                list.iter().any(|i| i.check_name(\"inline\"))\n+                            Some(ref list) if item.check_name(sym::doc) => {\n+                                list.iter().any(|i| i.check_name(sym::inline))\n                             }\n                             _ => false,\n                         }"}, {"sha": "2547e3a06e9efbbe71b1e309c23cc9ecb1679fe0", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -3,6 +3,7 @@ use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty::Visibility;\n use rustc::util::nodemap::FxHashSet;\n+use syntax::symbol::sym;\n \n use std::cell::RefMut;\n \n@@ -42,7 +43,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n \n     // Updates node level and returns the updated level\n     fn update(&mut self, did: DefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n-        let is_hidden = self.cx.tcx.get_attrs(did).lists(\"doc\").has_word(\"hidden\");\n+        let is_hidden = self.cx.tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden);\n \n         let old_level = self.access_levels.map.get(&did).cloned();\n         // Accessibility levels can only grow"}, {"sha": "55e8b39974e09be7611e658533fab45cae204b55", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -3,7 +3,7 @@ authors = [\"The Rust Project Developers\"]\n name = \"std\"\n version = \"0.0.0\"\n build = \"build.rs\"\n-license = \"MIT/Apache-2.0\"\n+license = \"MIT OR Apache-2.0\"\n repository = \"https://github.com/rust-lang/rust.git\"\n description = \"The Rust Standard Library\"\n edition = \"2018\"\n@@ -19,7 +19,7 @@ panic_unwind = { path = \"../libpanic_unwind\", optional = true }\n panic_abort = { path = \"../libpanic_abort\" }\n core = { path = \"../libcore\" }\n libc = { version = \"0.2.51\", default-features = false, features = ['rustc-dep-of-std'] }\n-compiler_builtins = { version = \"0.1.12\" }\n+compiler_builtins = { version = \"0.1.14\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n unwind = { path = \"../libunwind\" }\n hashbrown = { version = \"0.3.0\", features = ['rustc-dep-of-std'] }\n@@ -54,7 +54,7 @@ default = [\"compiler_builtins_c\", \"std_detect_file_io\", \"std_detect_dlsym_getaux\n backtrace = [\"backtrace-sys\"]\n panic-unwind = [\"panic_unwind\"]\n profiler = [\"profiler_builtins\"]\n-compiler_builtins_c = [\"compiler_builtins/c\"]\n+compiler_builtins_c = [\"alloc/compiler-builtins-c\"]\n llvm-libunwind = [\"unwind/llvm-libunwind\"]\n \n # Make panics and failed asserts immediately abort without formatting any message"}, {"sha": "ff52974775b05268e1a4b3b49a704340a6f24d50", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -173,6 +173,9 @@ static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n /// about the allocation that failed.\n ///\n /// The allocation error hook is a global resource.\n+///\n+/// [`set_alloc_error_hook`]: fn.set_alloc_error_hook.html\n+/// [`take_alloc_error_hook`]: fn.take_alloc_error_hook.html\n #[unstable(feature = \"alloc_error_hook\", issue = \"51245\")]\n pub fn set_alloc_error_hook(hook: fn(Layout)) {\n     HOOK.store(hook as *mut (), Ordering::SeqCst);\n@@ -183,6 +186,8 @@ pub fn set_alloc_error_hook(hook: fn(Layout)) {\n /// *See also the function [`set_alloc_error_hook`].*\n ///\n /// If no custom hook is registered, the default hook will be returned.\n+///\n+/// [`set_alloc_error_hook`]: fn.set_alloc_error_hook.html\n #[unstable(feature = \"alloc_error_hook\", issue = \"51245\")]\n pub fn take_alloc_error_hook() -> fn(Layout) {\n     let hook = HOOK.swap(ptr::null_mut(), Ordering::SeqCst);"}, {"sha": "7a6c97ebaa226093156aadc472cc93f95e6d9254", "filename": "src/libstd/build.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -20,8 +20,7 @@ fn main() {\n     } else if target.contains(\"netbsd\") {\n         println!(\"cargo:rustc-link-lib=pthread\");\n         println!(\"cargo:rustc-link-lib=rt\");\n-    } else if target.contains(\"dragonfly\") || target.contains(\"bitrig\") ||\n-              target.contains(\"openbsd\") {\n+    } else if target.contains(\"dragonfly\") || target.contains(\"openbsd\") {\n         println!(\"cargo:rustc-link-lib=pthread\");\n     } else if target.contains(\"solaris\") {\n         println!(\"cargo:rustc-link-lib=socket\");"}, {"sha": "5a2fe2b244f556d16127daf3244da70fed785ecc", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1225,11 +1225,13 @@ pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n ///\n /// This is a lower-level version of [`Entry`].\n ///\n-/// This `enum` is constructed from the [`raw_entry`] method on [`HashMap`].\n+/// This `enum` is constructed through the [`raw_entry_mut`] method on [`HashMap`],\n+/// then calling one of the methods of that [`RawEntryBuilderMut`].\n ///\n /// [`HashMap`]: struct.HashMap.html\n /// [`Entry`]: enum.Entry.html\n-/// [`raw_entry`]: struct.HashMap.html#method.raw_entry\n+/// [`raw_entry_mut`]: struct.HashMap.html#method.raw_entry_mut\n+/// [`RawEntryBuilderMut`]: struct.RawEntryBuilderMut.html\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n     /// An occupied entry.\n@@ -2492,7 +2494,10 @@ impl DefaultHasher {\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n impl Default for DefaultHasher {\n-    /// Creates a new `DefaultHasher` using [`new`][DefaultHasher::new].\n+    // FIXME: here should link `new` to [DefaultHasher::new], but it occurs intra-doc link\n+    // resolution failure when re-exporting libstd items. When #56922 fixed,\n+    // link `new` to [DefaultHasher::new] again.\n+    /// Creates a new `DefaultHasher` using `new`.\n     /// See its documentation for more.\n     fn default() -> DefaultHasher {\n         DefaultHasher::new()"}, {"sha": "403914c070780a4822f14afd9f7056c5c2251532", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -618,6 +618,62 @@ impl<T, S> HashSet<T, S>\n         self.map.get_key_value(value).map(|(k, _)| k)\n     }\n \n+    /// Inserts the given `value` into the set if it is not present, then\n+    /// returns a reference to the value in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(hash_set_entry)]\n+    ///\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// assert_eq!(set.len(), 3);\n+    /// assert_eq!(set.get_or_insert(2), &2);\n+    /// assert_eq!(set.get_or_insert(100), &100);\n+    /// assert_eq!(set.len(), 4); // 100 was inserted\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"hash_set_entry\", issue = \"60896\")]\n+    pub fn get_or_insert(&mut self, value: T) -> &T {\n+        // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n+        // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n+        self.map.raw_entry_mut().from_key(&value).or_insert(value, ()).0\n+    }\n+\n+    /// Inserts a value computed from `f` into the set if the given `value` is\n+    /// not present, then returns a reference to the value in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(hash_set_entry)]\n+    ///\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set: HashSet<String> = [\"cat\", \"dog\", \"horse\"]\n+    ///     .iter().map(|&pet| pet.to_owned()).collect();\n+    ///\n+    /// assert_eq!(set.len(), 3);\n+    /// for &pet in &[\"cat\", \"dog\", \"fish\"] {\n+    ///     let value = set.get_or_insert_with(pet, str::to_owned);\n+    ///     assert_eq!(value, pet);\n+    /// }\n+    /// assert_eq!(set.len(), 4); // a new \"fish\" was inserted\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"hash_set_entry\", issue = \"60896\")]\n+    pub fn get_or_insert_with<Q: ?Sized, F>(&mut self, value: &Q, f: F) -> &T\n+        where T: Borrow<Q>,\n+              Q: Hash + Eq,\n+              F: FnOnce(&Q) -> T\n+    {\n+        // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n+        // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n+        self.map.raw_entry_mut().from_key(value).or_insert_with(|| (f(value), ())).0\n+    }\n+\n     /// Returns `true` if `self` has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     ///"}, {"sha": "260624a8bd8594945fde8d6923159bad3b31c7dc", "filename": "src/libstd/env.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -746,6 +746,10 @@ impl Iterator for Args {\n         self.inner.next().map(|s| s.into_string().unwrap())\n     }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn last(mut self) -> Option<String> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"env\", since = \"1.0.0\")]\n@@ -781,6 +785,8 @@ impl Iterator for ArgsOs {\n     type Item = OsString;\n     fn next(&mut self) -> Option<OsString> { self.inner.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn last(mut self) -> Option<OsString> { self.next_back() }\n }\n \n #[stable(feature = \"env\", since = \"1.0.0\")]\n@@ -845,7 +851,6 @@ pub mod consts {\n     /// - ios\n     /// - freebsd\n     /// - dragonfly\n-    /// - bitrig\n     /// - netbsd\n     /// - openbsd\n     /// - solaris"}, {"sha": "aeb822fa99e66a6fd1920de1c16aea4203ff4677", "filename": "src/libstd/error.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -197,16 +197,29 @@ pub trait Error: Debug + Display {\n     fn source(&self) -> Option<&(dyn Error + 'static)> { None }\n \n     /// Gets the `TypeId` of `self`\n-    #[stable(feature = \"error_type_id\", since = \"1.34.0\")]\n-    fn type_id(&self) -> TypeId where Self: 'static {\n+    #[doc(hidden)]\n+    #[unstable(feature = \"error_type_id\",\n+               reason = \"this is memory unsafe to override in user code\",\n+               issue = \"60784\")]\n+    fn type_id(&self, _: private::Internal) -> TypeId where Self: 'static {\n         TypeId::of::<Self>()\n     }\n }\n \n+mod private {\n+    // This is a hack to prevent `type_id` from being overridden by `Error`\n+    // implementations, since that can enable unsound downcasting.\n+    #[unstable(feature = \"error_type_id\", issue = \"60784\")]\n+    #[derive(Debug)]\n+    pub struct Internal;\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, E: Error + 'a> From<E> for Box<dyn Error + 'a> {\n     /// Converts a type of [`Error`] into a box of dyn [`Error`].\n     ///\n+    /// [`Error`]: ../error/trait.Error.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -244,6 +257,8 @@ impl<'a, E: Error + Send + Sync + 'a> From<E> for Box<dyn Error + Send + Sync +\n     /// Converts a type of [`Error`] + [`Send`] + [`Sync`] into a box of dyn [`Error`] +\n     /// [`Send`] + [`Sync`].\n     ///\n+    /// [`Error`]: ../error/trait.Error.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -285,6 +300,8 @@ impl<'a, E: Error + Send + Sync + 'a> From<E> for Box<dyn Error + Send + Sync +\n impl From<String> for Box<dyn Error + Send + Sync> {\n     /// Converts a [`String`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n     ///\n+    /// [`Error`]: ../error/trait.Error.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -318,6 +335,8 @@ impl From<String> for Box<dyn Error + Send + Sync> {\n impl From<String> for Box<dyn Error> {\n     /// Converts a [`String`] into a box of dyn [`Error`].\n     ///\n+    /// [`Error`]: ../error/trait.Error.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -339,6 +358,8 @@ impl From<String> for Box<dyn Error> {\n impl<'a> From<&str> for Box<dyn Error + Send + Sync + 'a> {\n     /// Converts a [`str`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n     ///\n+    /// [`Error`]: ../error/trait.Error.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -359,6 +380,8 @@ impl<'a> From<&str> for Box<dyn Error + Send + Sync + 'a> {\n impl From<&str> for Box<dyn Error> {\n     /// Converts a [`str`] into a box of dyn [`Error`].\n     ///\n+    /// [`Error`]: ../error/trait.Error.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -378,6 +401,9 @@ impl From<&str> for Box<dyn Error> {\n impl<'a, 'b> From<Cow<'b, str>> for Box<dyn Error + Send + Sync + 'a> {\n     /// Converts a [`Cow`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n     ///\n+    /// [`Cow`]: ../borrow/enum.Cow.html\n+    /// [`Error`]: ../error/trait.Error.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -399,6 +425,9 @@ impl<'a, 'b> From<Cow<'b, str>> for Box<dyn Error + Send + Sync + 'a> {\n impl<'a> From<Cow<'a, str>> for Box<dyn Error> {\n     /// Converts a [`Cow`] into a box of dyn [`Error`].\n     ///\n+    /// [`Cow`]: ../borrow/enum.Cow.html\n+    /// [`Error`]: ../error/trait.Error.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -572,7 +601,7 @@ impl dyn Error + 'static {\n         let t = TypeId::of::<T>();\n \n         // Get TypeId of the type in the trait object\n-        let boxed = self.type_id();\n+        let boxed = self.type_id(private::Internal);\n \n         // Compare both TypeIds on equality\n         t == boxed"}, {"sha": "5c6c43017cf6402be3528a88c17dde88ad3fb055", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -43,7 +43,9 @@ use crate::sys;\n /// `CString` implements a [`as_ptr`] method through the [`Deref`]\n /// trait. This method will give you a `*const c_char` which you can\n /// feed directly to extern functions that expect a nul-terminated\n-/// string, like C's `strdup()`.\n+/// string, like C's `strdup()`. Notice that [`as_ptr`] returns a\n+/// read-only pointer; if the C code writes to it, that causes\n+/// undefined behavior.\n ///\n /// # Extracting a slice of the whole C string\n ///\n@@ -61,7 +63,7 @@ use crate::sys;\n ///\n /// Once you have the kind of slice you need (with or without a nul\n /// terminator), you can call the slice's own\n-/// [`as_ptr`][slice.as_ptr] method to get a raw pointer to pass to\n+/// [`as_ptr`][slice.as_ptr] method to get a read-only raw pointer to pass to\n /// extern functions. See the documentation for that function for a\n /// discussion on ensuring the lifetime of the raw pointer.\n ///\n@@ -1043,6 +1045,9 @@ impl CStr {\n     ///\n     /// **WARNING**\n     ///\n+    /// The returned pointer is read-only; writing to it (including passing it\n+    /// to C code that writes to it) causes undefined behavior.\n+    ///\n     /// It is your responsibility to make sure that the underlying memory is not\n     /// freed too early. For example, the following code will cause undefined\n     /// behavior when `ptr` is used inside the `unsafe` block:"}, {"sha": "c7c5849a00fa03e7ded2fe25de405f195575d0f2", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -351,6 +351,8 @@ impl From<String> for OsString {\n     /// Converts a [`String`] into a [`OsString`].\n     ///\n     /// The conversion copies the data, and includes an allocation on the heap.\n+    ///\n+    /// [`OsString`]: ../../std/ffi/struct.OsString.html\n     fn from(s: String) -> OsString {\n         OsString { inner: Buf::from_string(s) }\n     }"}, {"sha": "616b5eb836ffd6c8c20163cd752790ade30ef170", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1812,6 +1812,8 @@ pub fn canonicalize<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n ///   function.)\n /// * `path` already exists.\n ///\n+/// [`create_dir_all`]: fn.create_dir_all.html\n+///\n /// # Examples\n ///\n /// ```no_run"}, {"sha": "e309f81192cf3ffb7322bd4540da7beb5c384461", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -754,7 +754,7 @@ impl<W> fmt::Display for IntoInnerError<W> {\n /// completed, rather than the entire buffer at once. Enter `LineWriter`. It\n /// does exactly that.\n ///\n-/// Like [`BufWriter`], a `LineWriter`\u2019s buffer will also be flushed when the\n+/// Like [`BufWriter`][bufwriter], a `LineWriter`\u2019s buffer will also be flushed when the\n /// `LineWriter` goes out of scope or when its internal buffer is full.\n ///\n /// [bufwriter]: struct.BufWriter.html"}, {"sha": "917199f8ea8d03fe770c6a806a59d54ae207eac4", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1579,18 +1579,13 @@ pub trait BufRead: Read {\n     /// let stdin = io::stdin();\n     /// let mut stdin = stdin.lock();\n     ///\n-    /// // we can't have two `&mut` references to `stdin`, so use a block\n-    /// // to end the borrow early.\n-    /// let length = {\n-    ///     let buffer = stdin.fill_buf().unwrap();\n+    /// let buffer = stdin.fill_buf().unwrap();\n     ///\n-    ///     // work with buffer\n-    ///     println!(\"{:?}\", buffer);\n-    ///\n-    ///     buffer.len()\n-    /// };\n+    /// // work with buffer\n+    /// println!(\"{:?}\", buffer);\n     ///\n     /// // ensure the bytes we worked with aren't returned again later\n+    /// let length = buffer.len();\n     /// stdin.consume(length);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "d133c2f5cb11ca07c5797795696d02f4463e5474", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 279, "deletions": 15, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1,6 +1,6 @@\n #[doc(keyword = \"as\")]\n //\n-/// The keyword for casting a value to a type.\n+/// Cast between types, or rename an import.\n ///\n /// `as` is most commonly used to turn primitive types into other primitive types, but it has other\n /// uses that include turning pointers into addresses, addresses into pointers, and pointers into\n@@ -29,9 +29,18 @@\n /// [`crate`]: keyword.crate.html\n mod as_keyword { }\n \n+#[doc(keyword = \"break\")]\n+//\n+/// Exit early from a loop.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod break_keyword { }\n+\n #[doc(keyword = \"const\")]\n //\n-/// The keyword for defining constants.\n+/// Compile-time constants and deterministic functions.\n ///\n /// Sometimes a certain value is used many times throughout a program, and it can become\n /// inconvenient to copy it over and over. What's more, it's not always possible or desirable to\n@@ -83,9 +92,18 @@ mod as_keyword { }\n /// [Reference]: ../reference/items/constant-items.html\n mod const_keyword { }\n \n+#[doc(keyword = \"continue\")]\n+//\n+/// Skip to the next iteration of a loop.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod continue_keyword { }\n+\n #[doc(keyword = \"crate\")]\n //\n-/// The `crate` keyword.\n+/// A Rust binary or library.\n ///\n /// The primary use of the `crate` keyword is as a part of `extern crate` declarations, which are\n /// used to specify a dependency on a crate external to the one it's declared in. Crates are the\n@@ -116,14 +134,24 @@ mod const_keyword { }\n /// [Reference]: ../reference/items/extern-crates.html\n mod crate_keyword { }\n \n+#[doc(keyword = \"else\")]\n+//\n+/// What to do when an [`if`] condition does not hold.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [`if`]: keyword.if.html\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod else_keyword { }\n+\n #[doc(keyword = \"enum\")]\n //\n-/// For defining enumerations.\n+/// A type that can be any one of several variants.\n ///\n /// Enums in Rust are similar to those of other compiled languages like C, but have important\n /// differences that make them considerably more powerful. What Rust calls enums are more commonly\n-/// known as [Algebraic Data Types] if you're coming from a functional programming background. The\n-/// important detail is that each enum variant can have data to go along with it.\n+/// known as [Algebraic Data Types][ADT] if you're coming from a functional programming background.\n+/// The important detail is that each enum variant can have data to go along with it.\n ///\n /// ```rust\n /// # struct Coord;\n@@ -166,15 +194,15 @@ mod crate_keyword { }\n ///\n /// For more information, take a look at the [Rust Book] or the [Reference]\n ///\n-/// [Algebraic Data Types]: https://en.wikipedia.org/wiki/Algebraic_data_type\n+/// [ADT]: https://en.wikipedia.org/wiki/Algebraic_data_type\n /// [`Option`]: option/enum.Option.html\n /// [Rust Book]: ../book/ch06-01-defining-an-enum.html\n /// [Reference]: ../reference/items/enumerations.html\n mod enum_keyword { }\n \n #[doc(keyword = \"extern\")]\n //\n-/// For external connections in Rust code.\n+/// Link to or import external code.\n ///\n /// The `extern` keyword is used in two places in Rust. One is in conjunction with the [`crate`]\n /// keyword to make your Rust code aware of other Rust crates in your project, i.e., `extern crate\n@@ -214,9 +242,19 @@ mod enum_keyword { }\n /// [Reference]: ../reference/items/external-blocks.html\n mod extern_keyword { }\n \n+#[doc(keyword = \"false\")]\n+//\n+/// A value of type [`bool`] representing logical **false**.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [`bool`]: primitive.bool.html\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod false_keyword { }\n+\n #[doc(keyword = \"fn\")]\n //\n-/// The keyword for defining functions.\n+/// A function or function pointer.\n ///\n /// Functions are the primary way code is executed within Rust. Function blocks, usually just\n /// called functions, can be defined in a variety of different places and be assigned many\n@@ -283,7 +321,8 @@ mod fn_keyword { }\n \n #[doc(keyword = \"for\")]\n //\n-/// The `for` keyword.\n+/// Iteration with [`in`], trait implementation with [`impl`], or [higher-ranked trait bounds]\n+/// (`for<'a>`).\n ///\n /// The `for` keyword is used in many syntactic locations:\n ///\n@@ -350,6 +389,7 @@ mod fn_keyword { }\n ///\n /// For more information on for-loops, see the [Rust book] or the [Reference].\n ///\n+/// [`in`]: keyword.in.html\n /// [`impl`]: keyword.impl.html\n /// [higher-ranked trait bounds]: ../reference/trait-bounds.html#higher-ranked-trait-bounds\n /// [`IntoIterator`]: iter/trait.IntoIterator.html\n@@ -360,7 +400,7 @@ mod for_keyword { }\n \n #[doc(keyword = \"if\")]\n //\n-/// If statements and expressions.\n+/// Evaluate a block if a condition holds.\n ///\n /// `if` is a familiar construct to most programmers, and is the main way you'll often do logic in\n /// your code. However, unlike in most languages, `if` blocks can also act as expressions.\n@@ -434,7 +474,7 @@ mod if_keyword { }\n \n #[doc(keyword = \"impl\")]\n //\n-/// The implementation-defining keyword.\n+/// Implement some functionality for a type.\n ///\n /// The `impl` keyword is primarily used to define implementations on types. Inherent\n /// implementations are standalone, while trait implementations are used to implement traits for\n@@ -495,9 +535,19 @@ mod if_keyword { }\n /// [book2]: ../book/ch10-02-traits.html#returning-types-that-implement-traits\n mod impl_keyword { }\n \n+#[doc(keyword = \"in\")]\n+//\n+/// Iterate over a series of values with [`for`].\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [`for`]: keyword.for.html\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod in_keyword { }\n+\n #[doc(keyword = \"let\")]\n //\n-/// The variable binding keyword.\n+/// Bind a value to a variable.\n ///\n /// The primary use for the `let` keyword is in `let` statements, which are used to introduce a new\n /// set of variables into the current scope, as given by a pattern.\n@@ -560,7 +610,7 @@ mod let_keyword { }\n \n #[doc(keyword = \"loop\")]\n //\n-/// The loop-defining keyword.\n+/// Loop indefinitely.\n ///\n /// `loop` is used to define the simplest kind of loop supported in Rust. It runs the code inside\n /// it until the code uses `break` or the program exits.\n@@ -603,9 +653,104 @@ mod let_keyword { }\n /// [Reference]: ../reference/expressions/loop-expr.html\n mod loop_keyword { }\n \n+#[doc(keyword = \"match\")]\n+//\n+/// Control flow based on pattern matching.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod match_keyword { }\n+\n+#[doc(keyword = \"mod\")]\n+//\n+/// Organize code into [modules].\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [modules]: ../reference/items/modules.html\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod mod_keyword { }\n+\n+#[doc(keyword = \"move\")]\n+//\n+/// Capture a [closure]'s environment by value.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [closure]: ../book/second-edition/ch13-01-closures.html\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod move_keyword { }\n+\n+#[doc(keyword = \"mut\")]\n+//\n+/// A mutable binding, reference, or pointer.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod mut_keyword { }\n+\n+#[doc(keyword = \"pub\")]\n+//\n+/// Make an item visible to others.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod pub_keyword { }\n+\n+#[doc(keyword = \"ref\")]\n+//\n+/// Bind by reference during pattern matching.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod ref_keyword { }\n+\n+#[doc(keyword = \"return\")]\n+//\n+/// Return a value from a function.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod return_keyword { }\n+\n+#[doc(keyword = \"self\")]\n+//\n+/// The receiver of a method, or the current module.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod self_keyword { }\n+\n+#[doc(keyword = \"Self\")]\n+//\n+/// The implementing type within a [`trait`] or [`impl`] block, or the current type within a type\n+/// definition.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [`impl`]: keyword.impl.html\n+/// [`trait`]: keyword.trait.html\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod self_upper_keyword { }\n+\n+#[doc(keyword = \"static\")]\n+//\n+/// A place that is valid for the duration of a program.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod static_keyword { }\n+\n #[doc(keyword = \"struct\")]\n //\n-/// The keyword used to define structs.\n+/// A type that is composed of other types.\n ///\n /// Structs in Rust come in three flavors: Structs with named fields, tuple structs, and unit\n /// structs.\n@@ -710,3 +855,122 @@ mod loop_keyword { }\n /// [book]: ../book/ch05-01-defining-structs.html\n /// [reference]: ../reference/items/structs.html\n mod struct_keyword { }\n+\n+#[doc(keyword = \"super\")]\n+//\n+/// The parent of the current [module].\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [module]: ../reference/items/modules.html\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod super_keyword { }\n+\n+#[doc(keyword = \"trait\")]\n+//\n+/// A common interface for a class of types.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod trait_keyword { }\n+\n+#[doc(keyword = \"true\")]\n+//\n+/// A value of type [`bool`] representing logical **true**.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [`bool`]: primitive.bool.html\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod true_keyword { }\n+\n+#[doc(keyword = \"type\")]\n+//\n+/// Define an alias for an existing type.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod type_keyword { }\n+\n+#[doc(keyword = \"unsafe\")]\n+//\n+/// Code or interfaces whose [memory safety] cannot be verified by the type system.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [memory safety]: ../book/ch19-01-unsafe-rust.html\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod unsafe_keyword { }\n+\n+#[doc(keyword = \"use\")]\n+//\n+/// Import or rename items from other crates or modules.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod use_keyword { }\n+\n+#[doc(keyword = \"where\")]\n+//\n+/// Add constraints that must be upheld to use an item.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod where_keyword { }\n+\n+#[doc(keyword = \"while\")]\n+//\n+/// Loop while a condition is upheld.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod while_keyword { }\n+\n+// 2018 Edition keywords\n+\n+#[unstable(feature = \"async_await\", issue = \"50547\")]\n+#[doc(keyword = \"async\")]\n+//\n+/// Return a [`Future`] instead of blocking the current thread.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [`Future`]: ./future/trait.Future.html\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod async_keyword { }\n+\n+#[unstable(feature = \"async_await\", issue = \"50547\")]\n+#[doc(keyword = \"await\")]\n+//\n+/// Suspend execution until the result of a [`Future`] is ready.\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [`Future`]: ./future/trait.Future.html\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod await_keyword { }\n+\n+#[doc(keyword = \"dyn\")]\n+//\n+/// Name the type of a [trait object].\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [trait object]: ../book/ch17-02-trait-objects.html\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod dyn_keyword { }\n+\n+#[doc(keyword = \"union\")]\n+//\n+/// The [Rust equivalent of a C-style union][union].\n+///\n+/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+///\n+/// [union]: ../reference/items/unions.html\n+/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+mod union_keyword { }"}, {"sha": "e044b46e0d0763252baf5254a69fe57f88d1e5b8", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -223,6 +223,7 @@\n #![cfg_attr(all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n             feature(global_asm, slice_index_methods,\n                     decl_macro, coerce_unsized, sgx_platform, ptr_wrapping_offset_from))]\n+#![cfg_attr(all(test, target_vendor = \"fortanix\", target_env = \"sgx\"), feature(fixed_size_array))]\n \n // std is implemented with unstable features, many of which are internal\n // compiler details that will never be stable\n@@ -271,7 +272,6 @@\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(linkage)]\n-#![feature(maybe_uninit)]\n #![feature(needs_panic_runtime)]\n #![feature(never_type)]\n #![feature(nll)]"}, {"sha": "9af7bba97aa58de06daab2106874f17909a16cd6", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -357,61 +357,6 @@ macro_rules! dbg {\n     };\n }\n \n-/// Selects the first successful receive event from a number of receivers.\n-///\n-/// This macro is used to wait for the first event to occur on a number of\n-/// receivers. It places no restrictions on the types of receivers given to\n-/// this macro, this can be viewed as a heterogeneous select.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(mpsc_select)]\n-///\n-/// use std::thread;\n-/// use std::sync::mpsc;\n-///\n-/// // two placeholder functions for now\n-/// fn long_running_thread() {}\n-/// fn calculate_the_answer() -> u32 { 42 }\n-///\n-/// let (tx1, rx1) = mpsc::channel();\n-/// let (tx2, rx2) = mpsc::channel();\n-///\n-/// thread::spawn(move|| { long_running_thread(); tx1.send(()).unwrap(); });\n-/// thread::spawn(move|| { tx2.send(calculate_the_answer()).unwrap(); });\n-///\n-/// select! {\n-///     _ = rx1.recv() => println!(\"the long running thread finished first\"),\n-///     answer = rx2.recv() => {\n-///         println!(\"the answer was: {}\", answer.unwrap());\n-///     }\n-/// }\n-/// # drop(rx1.recv());\n-/// # drop(rx2.recv());\n-/// ```\n-///\n-/// For more information about select, see the `std::sync::mpsc::Select` structure.\n-#[macro_export]\n-#[unstable(feature = \"mpsc_select\", issue = \"27800\")]\n-#[rustc_deprecated(since = \"1.32.0\",\n-                   reason = \"channel selection will be removed in a future release\")]\n-macro_rules! select {\n-    (\n-        $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n-    ) => ({\n-        use $crate::sync::mpsc::Select;\n-        let sel = Select::new();\n-        $( let mut $rx = sel.handle(&$rx); )+\n-        unsafe {\n-            $( $rx.add(); )+\n-        }\n-        let ret = sel.wait();\n-        $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n-        { unreachable!() }\n-    })\n-}\n-\n #[cfg(test)]\n macro_rules! assert_approx_eq {\n     ($a:expr, $b:expr) => ({"}, {"sha": "ca86a175058b512dd2259349393a2c200565f920", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -546,6 +546,9 @@ impl FromInner<c::sockaddr_in6> for SocketAddrV6 {\n #[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n impl From<SocketAddrV4> for SocketAddr {\n     /// Converts a [`SocketAddrV4`] into a [`SocketAddr::V4`].\n+    ///\n+    /// [`SocketAddrV4`]: ../../std/net/struct.SocketAddrV4.html\n+    /// [`SocketAddr::V4`]: ../../std/net/enum.SocketAddr.html#variant.V4\n     fn from(sock4: SocketAddrV4) -> SocketAddr {\n         SocketAddr::V4(sock4)\n     }\n@@ -554,6 +557,9 @@ impl From<SocketAddrV4> for SocketAddr {\n #[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n impl From<SocketAddrV6> for SocketAddr {\n     /// Converts a [`SocketAddrV6`] into a [`SocketAddr::V6`].\n+    ///\n+    /// [`SocketAddrV6`]: ../../std/net/struct.SocketAddrV6.html\n+    /// [`SocketAddr::V6`]: ../../std/net/enum.SocketAddr.html#variant.V6\n     fn from(sock6: SocketAddrV6) -> SocketAddr {\n         SocketAddr::V6(sock6)\n     }\n@@ -567,6 +573,13 @@ impl<I: Into<IpAddr>> From<(I, u16)> for SocketAddr {\n     /// and creates a [`SocketAddr::V6`] for a [`IpAddr::V6`].\n     ///\n     /// `u16` is treated as port of the newly created [`SocketAddr`].\n+    ///\n+    /// [`IpAddr`]: ../../std/net/enum.IpAddr.html\n+    /// [`IpAddr::V4`]: ../../std/net/enum.IpAddr.html#variant.V4\n+    /// [`IpAddr::V6`]: ../../std/net/enum.IpAddr.html#variant.V6\n+    /// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n+    /// [`SocketAddr::V4`]: ../../std/net/enum.SocketAddr.html#variant.V4\n+    /// [`SocketAddr::V6`]: ../../std/net/enum.SocketAddr.html#variant.V6\n     fn from(pieces: (I, u16)) -> SocketAddr {\n         SocketAddr::new(pieces.0.into(), pieces.1)\n     }\n@@ -974,9 +987,9 @@ mod tests {\n         // s has been moved into the tsa call\n     }\n \n-    // FIXME: figure out why this fails on openbsd and bitrig and fix it\n+    // FIXME: figure out why this fails on openbsd and fix it\n     #[test]\n-    #[cfg(not(any(windows, target_os = \"openbsd\", target_os = \"bitrig\")))]\n+    #[cfg(not(any(windows, target_os = \"openbsd\")))]\n     fn to_socket_addr_str_bad() {\n         assert!(tsa(\"1200::AB00:1234::2552:7777:1313:34300\").is_err());\n     }"}, {"sha": "cdffa390223a2c48fa0a458d88bfcc3de3819686", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1595,9 +1595,9 @@ mod tests {\n         assert_eq!(format!(\"{:?}\", stream), compare);\n     }\n \n-    // FIXME: re-enabled bitrig/openbsd tests once their socket timeout code\n+    // FIXME: re-enabled openbsd tests once their socket timeout code\n     //        no longer has rounding errors.\n-    #[cfg_attr(any(target_os = \"bitrig\", target_os = \"netbsd\", target_os = \"openbsd\"), ignore)]\n+    #[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\"), ignore)]\n     #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     #[test]\n     fn timeouts() {"}, {"sha": "61d9149952ee5e2994119d13606c46f2b66fff0d", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -1024,9 +1024,9 @@ mod tests {\n         assert_eq!(format!(\"{:?}\", udpsock), compare);\n     }\n \n-    // FIXME: re-enabled bitrig/openbsd/netbsd tests once their socket timeout code\n+    // FIXME: re-enabled openbsd/netbsd tests once their socket timeout code\n     //        no longer has rounding errors.\n-    #[cfg_attr(any(target_os = \"bitrig\", target_os = \"netbsd\", target_os = \"openbsd\"), ignore)]\n+    #[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\"), ignore)]\n     #[test]\n     fn timeouts() {\n         let addr = next_test_ip4();"}, {"sha": "b5c6903c41047df11320f8cce2d552b24f0f0452", "filename": "src/libstd/os/bitrig/fs.rs", "status": "removed", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibstd%2Fos%2Fbitrig%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibstd%2Fos%2Fbitrig%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fbitrig%2Ffs.rs?ref=e764f475ca7fffd6167ea991afc7d1b2b3f642dc", "patch": "@@ -1,138 +0,0 @@\n-#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-\n-use crate::fs::Metadata;\n-use crate::sys_common::AsInner;\n-\n-#[allow(deprecated)]\n-use crate::os::bitrig::raw;\n-\n-/// OS-specific extensions to [`fs::Metadata`].\n-///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n-#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-pub trait MetadataExt {\n-    /// Gain a reference to the underlying `stat` structure which contains\n-    /// the raw information returned by the OS.\n-    ///\n-    /// The contents of the returned `stat` are **not** consistent across\n-    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n-    /// cross-Unix abstractions contained within the raw stat.\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n-    #[allow(deprecated)]\n-    fn as_raw_stat(&self) -> &raw::stat;\n-\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_dev(&self) -> u64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_ino(&self) -> u64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_mode(&self) -> u32;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_nlink(&self) -> u64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_uid(&self) -> u32;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_gid(&self) -> u32;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_rdev(&self) -> u64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_size(&self) -> u64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_atime(&self) -> i64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_atime_nsec(&self) -> i64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_mtime(&self) -> i64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_mtime_nsec(&self) -> i64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_ctime(&self) -> i64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_ctime_nsec(&self) -> i64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_birthtime(&self) -> i64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_birthtime_nsec(&self) -> i64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_blksize(&self) -> u64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_blocks(&self) -> u64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_flags(&self) -> u32;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_gen(&self) -> u32;\n-}\n-\n-#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-impl MetadataExt for Metadata {\n-    #[allow(deprecated)]\n-    fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat\n-                                          as *const raw::stat)\n-        }\n-    }\n-    fn st_dev(&self) -> u64 {\n-        self.as_inner().as_inner().st_dev as u64\n-    }\n-    fn st_ino(&self) -> u64 {\n-        self.as_inner().as_inner().st_ino as u64\n-    }\n-    fn st_mode(&self) -> u32 {\n-        self.as_inner().as_inner().st_mode as u32\n-    }\n-    fn st_nlink(&self) -> u64 {\n-        self.as_inner().as_inner().st_nlink as u64\n-    }\n-    fn st_uid(&self) -> u32 {\n-        self.as_inner().as_inner().st_uid as u32\n-    }\n-    fn st_gid(&self) -> u32 {\n-        self.as_inner().as_inner().st_gid as u32\n-    }\n-    fn st_rdev(&self) -> u64 {\n-        self.as_inner().as_inner().st_rdev as u64\n-    }\n-    fn st_size(&self) -> u64 {\n-        self.as_inner().as_inner().st_size as u64\n-    }\n-    fn st_atime(&self) -> i64 {\n-        self.as_inner().as_inner().st_atime as i64\n-    }\n-    fn st_atime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_atime_nsec as i64\n-    }\n-    fn st_mtime(&self) -> i64 {\n-        self.as_inner().as_inner().st_mtime as i64\n-    }\n-    fn st_mtime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_mtime_nsec as i64\n-    }\n-    fn st_ctime(&self) -> i64 {\n-        self.as_inner().as_inner().st_ctime as i64\n-    }\n-    fn st_ctime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_ctime_nsec as i64\n-    }\n-    fn st_birthtime(&self) -> i64 {\n-        self.as_inner().as_inner().st_birthtime as i64\n-    }\n-    fn st_birthtime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_birthtime_nsec as i64\n-    }\n-    fn st_blksize(&self) -> u64 {\n-        self.as_inner().as_inner().st_blksize as u64\n-    }\n-    fn st_blocks(&self) -> u64 {\n-        self.as_inner().as_inner().st_blocks as u64\n-    }\n-    fn st_gen(&self) -> u32 {\n-        self.as_inner().as_inner().st_gen as u32\n-    }\n-    fn st_flags(&self) -> u32 {\n-        self.as_inner().as_inner().st_flags as u32\n-    }\n-}"}, {"sha": "0bc105bb2b40a34db3612d04a435715358ca0350", "filename": "src/libstd/os/bitrig/mod.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs?ref=e764f475ca7fffd6167ea991afc7d1b2b3f642dc", "patch": "@@ -1,6 +0,0 @@\n-//! Bitrig-specific definitions\n-\n-#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-\n-pub mod raw;\n-pub mod fs;"}, {"sha": "c966d5a8e5b4938caaa4748407e771b04fd332a2", "filename": "src/libstd/os/bitrig/raw.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibstd%2Fos%2Fbitrig%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibstd%2Fos%2Fbitrig%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fbitrig%2Fraw.rs?ref=e764f475ca7fffd6167ea991afc7d1b2b3f642dc", "patch": "@@ -1,71 +0,0 @@\n-//! Bitrig-specific raw type definitions\n-\n-#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n-#![allow(deprecated)]\n-\n-use crate::os::raw::c_long;\n-use crate::os::unix::raw::{uid_t, gid_t};\n-\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type fflags_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n-\n-#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n-pub type pthread_t = usize;\n-\n-#[repr(C)]\n-#[derive(Clone)]\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-pub struct stat {\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_mode: u32,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_dev: i32,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_ino: u64,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_nlink: u32,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_uid: u32,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_gid: u32,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_rdev: i32,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_atime: i64,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_atime_nsec: i64,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_mtime: u64,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_mtime_nsec: i64,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_ctime: i64,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_ctime_nsec: i64,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_size: i64,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_blocks: i64,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_blksize: u32,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_flags: u32,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_gen: u32,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_birthtime: i64,\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub st_birthtime_nsec: i64,\n-}"}, {"sha": "44cbc180b8b01563d280ff0e9958d9abd86cb15d", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -39,7 +39,6 @@ cfg_if! {\n }\n \n #[cfg(target_os = \"android\")]    pub mod android;\n-#[cfg(target_os = \"bitrig\")]     pub mod bitrig;\n #[cfg(target_os = \"dragonfly\")]  pub mod dragonfly;\n #[cfg(target_os = \"freebsd\")]    pub mod freebsd;\n #[cfg(target_os = \"haiku\")]      pub mod haiku;"}, {"sha": "59f9e439add244a4955c74191188b02d15740582", "filename": "src/libstd/path.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -888,6 +888,11 @@ impl<'a> Iterator for Iter<'a> {\n     fn next(&mut self) -> Option<&'a OsStr> {\n         self.inner.next().map(Component::as_os_str)\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a OsStr> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -951,6 +956,11 @@ impl<'a> Iterator for Components<'a> {\n         }\n         None\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "69ecd201063b034baf0f8d5df0074823a89ecda6", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 2, "deletions": 83, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -116,7 +116,6 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![allow(deprecated)] // for mpsc_select\n \n // A description of how Rust's channel implementation works\n //\n@@ -263,6 +262,8 @@\n // believe that there is anything fundamental that needs to change about these\n // channels, however, in order to support a more efficient select().\n //\n+// FIXME: Select is now removed, so these factors are ready to be cleaned up!\n+//\n // # Conclusion\n //\n // And now that you've seen all the races that I found and attempted to fix,\n@@ -275,18 +276,8 @@ use crate::mem;\n use crate::cell::UnsafeCell;\n use crate::time::{Duration, Instant};\n \n-#[unstable(feature = \"mpsc_select\", issue = \"27800\")]\n-pub use self::select::{Select, Handle};\n-use self::select::StartResult;\n-use self::select::StartResult::*;\n-use self::blocking::SignalToken;\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod select_tests;\n-\n mod blocking;\n mod oneshot;\n-mod select;\n mod shared;\n mod stream;\n mod sync;\n@@ -1514,78 +1505,6 @@ impl<T> Receiver<T> {\n \n }\n \n-impl<T> select::Packet for Receiver<T> {\n-    fn can_recv(&self) -> bool {\n-        loop {\n-            let new_port = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => {\n-                    match p.can_recv() {\n-                        Ok(ret) => return ret,\n-                        Err(upgrade) => upgrade,\n-                    }\n-                }\n-                Flavor::Stream(ref p) => {\n-                    match p.can_recv() {\n-                        Ok(ret) => return ret,\n-                        Err(upgrade) => upgrade,\n-                    }\n-                }\n-                Flavor::Shared(ref p) => return p.can_recv(),\n-                Flavor::Sync(ref p) => return p.can_recv(),\n-            };\n-            unsafe {\n-                mem::swap(self.inner_mut(),\n-                          new_port.inner_mut());\n-            }\n-        }\n-    }\n-\n-    fn start_selection(&self, mut token: SignalToken) -> StartResult {\n-        loop {\n-            let (t, new_port) = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => {\n-                    match p.start_selection(token) {\n-                        oneshot::SelSuccess => return Installed,\n-                        oneshot::SelCanceled => return Abort,\n-                        oneshot::SelUpgraded(t, rx) => (t, rx),\n-                    }\n-                }\n-                Flavor::Stream(ref p) => {\n-                    match p.start_selection(token) {\n-                        stream::SelSuccess => return Installed,\n-                        stream::SelCanceled => return Abort,\n-                        stream::SelUpgraded(t, rx) => (t, rx),\n-                    }\n-                }\n-                Flavor::Shared(ref p) => return p.start_selection(token),\n-                Flavor::Sync(ref p) => return p.start_selection(token),\n-            };\n-            token = t;\n-            unsafe {\n-                mem::swap(self.inner_mut(), new_port.inner_mut());\n-            }\n-        }\n-    }\n-\n-    fn abort_selection(&self) -> bool {\n-        let mut was_upgrade = false;\n-        loop {\n-            let result = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => p.abort_selection(),\n-                Flavor::Stream(ref p) => p.abort_selection(was_upgrade),\n-                Flavor::Shared(ref p) => return p.abort_selection(was_upgrade),\n-                Flavor::Sync(ref p) => return p.abort_selection(),\n-            };\n-            let new_port = match result { Ok(b) => return b, Err(p) => p };\n-            was_upgrade = true;\n-            unsafe {\n-                mem::swap(self.inner_mut(),\n-                          new_port.inner_mut());\n-            }\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = T;"}, {"sha": "e7a5cc46b31a857912e23bc880fac2c97d4580e2", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -24,7 +24,6 @@\n \n pub use self::Failure::*;\n pub use self::UpgradeResult::*;\n-pub use self::SelectionResult::*;\n use self::MyUpgrade::*;\n \n use crate::sync::mpsc::Receiver;\n@@ -66,12 +65,6 @@ pub enum UpgradeResult {\n     UpWoke(SignalToken),\n }\n \n-pub enum SelectionResult<T> {\n-    SelCanceled,\n-    SelUpgraded(SignalToken, Receiver<T>),\n-    SelSuccess,\n-}\n-\n enum MyUpgrade<T> {\n     NothingSent,\n     SendUsed,\n@@ -264,71 +257,6 @@ impl<T> Packet<T> {\n     // select implementation\n     ////////////////////////////////////////////////////////////////////////////\n \n-    // If Ok, the value is whether this port has data, if Err, then the upgraded\n-    // port needs to be checked instead of this one.\n-    pub fn can_recv(&self) -> Result<bool, Receiver<T>> {\n-        unsafe {\n-            match self.state.load(Ordering::SeqCst) {\n-                EMPTY => Ok(false), // Welp, we tried\n-                DATA => Ok(true),   // we have some un-acquired data\n-                DISCONNECTED if (*self.data.get()).is_some() => Ok(true), // we have data\n-                DISCONNECTED => {\n-                    match ptr::replace(self.upgrade.get(), SendUsed) {\n-                        // The other end sent us an upgrade, so we need to\n-                        // propagate upwards whether the upgrade can receive\n-                        // data\n-                        GoUp(upgrade) => Err(upgrade),\n-\n-                        // If the other end disconnected without sending an\n-                        // upgrade, then we have data to receive (the channel is\n-                        // disconnected).\n-                        up => { ptr::write(self.upgrade.get(), up); Ok(true) }\n-                    }\n-                }\n-                _ => unreachable!(), // we're the \"one blocker\"\n-            }\n-        }\n-    }\n-\n-    // Attempts to start selection on this port. This can either succeed, fail\n-    // because there is data, or fail because there is an upgrade pending.\n-    pub fn start_selection(&self, token: SignalToken) -> SelectionResult<T> {\n-        unsafe {\n-            let ptr = token.cast_to_usize();\n-            match self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) {\n-                EMPTY => SelSuccess,\n-                DATA => {\n-                    drop(SignalToken::cast_from_usize(ptr));\n-                    SelCanceled\n-                }\n-                DISCONNECTED if (*self.data.get()).is_some() => {\n-                    drop(SignalToken::cast_from_usize(ptr));\n-                    SelCanceled\n-                }\n-                DISCONNECTED => {\n-                    match ptr::replace(self.upgrade.get(), SendUsed) {\n-                        // The other end sent us an upgrade, so we need to\n-                        // propagate upwards whether the upgrade can receive\n-                        // data\n-                        GoUp(upgrade) => {\n-                            SelUpgraded(SignalToken::cast_from_usize(ptr), upgrade)\n-                        }\n-\n-                        // If the other end disconnected without sending an\n-                        // upgrade, then we have data to receive (the channel is\n-                        // disconnected).\n-                        up => {\n-                            ptr::write(self.upgrade.get(), up);\n-                            drop(SignalToken::cast_from_usize(ptr));\n-                            SelCanceled\n-                        }\n-                    }\n-                }\n-                _ => unreachable!(), // we're the \"one blocker\"\n-            }\n-        }\n-    }\n-\n     // Remove a previous selecting thread from this port. This ensures that the\n     // blocked thread will no longer be visible to any other threads.\n     //"}, {"sha": "d1b5f2deccc1c40e7194eeea8a509fa18e6c6f03", "filename": "src/libstd/sync/mpsc/select.rs", "status": "removed", "additions": 0, "deletions": 352, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=e764f475ca7fffd6167ea991afc7d1b2b3f642dc", "patch": "@@ -1,352 +0,0 @@\n-//! Selection over an array of receivers\n-//!\n-//! This module contains the implementation machinery necessary for selecting\n-//! over a number of receivers. One large goal of this module is to provide an\n-//! efficient interface to selecting over any receiver of any type.\n-//!\n-//! This is achieved through an architecture of a \"receiver set\" in which\n-//! receivers are added to a set and then the entire set is waited on at once.\n-//! The set can be waited on multiple times to prevent re-adding each receiver\n-//! to the set.\n-//!\n-//! Usage of this module is currently encouraged to go through the use of the\n-//! `select!` macro. This macro allows naturally binding of variables to the\n-//! received values of receivers in a much more natural syntax then usage of the\n-//! `Select` structure directly.\n-//!\n-//! # Examples\n-//!\n-//! ```rust\n-//! #![feature(mpsc_select)]\n-//!\n-//! use std::sync::mpsc::channel;\n-//!\n-//! let (tx1, rx1) = channel();\n-//! let (tx2, rx2) = channel();\n-//!\n-//! tx1.send(1).unwrap();\n-//! tx2.send(2).unwrap();\n-//!\n-//! select! {\n-//!     val = rx1.recv() => {\n-//!         assert_eq!(val.unwrap(), 1);\n-//!     },\n-//!     val = rx2.recv() => {\n-//!         assert_eq!(val.unwrap(), 2);\n-//!     }\n-//! }\n-//! ```\n-\n-#![allow(dead_code)]\n-#![unstable(feature = \"mpsc_select\",\n-            reason = \"This implementation, while likely sufficient, is unsafe and \\\n-                      likely to be error prone. At some point in the future this \\\n-                      module will be removed.\",\n-            issue = \"27800\")]\n-#![rustc_deprecated(since = \"1.32.0\",\n-                    reason = \"channel selection will be removed in a future release\")]\n-\n-use core::cell::{Cell, UnsafeCell};\n-use core::marker;\n-use core::ptr;\n-use core::usize;\n-\n-use crate::fmt;\n-use crate::sync::mpsc::{Receiver, RecvError};\n-use crate::sync::mpsc::blocking::{self, SignalToken};\n-\n-/// The \"receiver set\" of the select interface. This structure is used to manage\n-/// a set of receivers which are being selected over.\n-pub struct Select {\n-    inner: UnsafeCell<SelectInner>,\n-    next_id: Cell<usize>,\n-}\n-\n-struct SelectInner {\n-    head: *mut Handle<'static, ()>,\n-    tail: *mut Handle<'static, ()>,\n-}\n-\n-impl !marker::Send for Select {}\n-\n-/// A handle to a receiver which is currently a member of a `Select` set of\n-/// receivers. This handle is used to keep the receiver in the set as well as\n-/// interact with the underlying receiver.\n-pub struct Handle<'rx, T:Send+'rx> {\n-    /// The ID of this handle, used to compare against the return value of\n-    /// `Select::wait()`.\n-    id: usize,\n-    selector: *mut SelectInner,\n-    next: *mut Handle<'static, ()>,\n-    prev: *mut Handle<'static, ()>,\n-    added: bool,\n-    packet: &'rx (dyn Packet+'rx),\n-\n-    // due to our fun transmutes, we be sure to place this at the end. (nothing\n-    // previous relies on T)\n-    rx: &'rx Receiver<T>,\n-}\n-\n-struct Packets { cur: *mut Handle<'static, ()> }\n-\n-#[doc(hidden)]\n-#[derive(PartialEq, Eq)]\n-pub enum StartResult {\n-    Installed,\n-    Abort,\n-}\n-\n-#[doc(hidden)]\n-pub trait Packet {\n-    fn can_recv(&self) -> bool;\n-    fn start_selection(&self, token: SignalToken) -> StartResult;\n-    fn abort_selection(&self) -> bool;\n-}\n-\n-impl Select {\n-    /// Creates a new selection structure. This set is initially empty.\n-    ///\n-    /// Usage of this struct directly can sometimes be burdensome, and usage is much easier through\n-    /// the `select!` macro.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(mpsc_select)]\n-    ///\n-    /// use std::sync::mpsc::Select;\n-    ///\n-    /// let select = Select::new();\n-    /// ```\n-    pub fn new() -> Select {\n-        Select {\n-            inner: UnsafeCell::new(SelectInner {\n-                head: ptr::null_mut(),\n-                tail: ptr::null_mut(),\n-            }),\n-            next_id: Cell::new(1),\n-        }\n-    }\n-\n-    /// Creates a new handle into this receiver set for a new receiver. Note\n-    /// that this does *not* add the receiver to the receiver set, for that you\n-    /// must call the `add` method on the handle itself.\n-    pub fn handle<'a, T: Send>(&'a self, rx: &'a Receiver<T>) -> Handle<'a, T> {\n-        let id = self.next_id.get();\n-        self.next_id.set(id + 1);\n-        Handle {\n-            id,\n-            selector: self.inner.get(),\n-            next: ptr::null_mut(),\n-            prev: ptr::null_mut(),\n-            added: false,\n-            rx,\n-            packet: rx,\n-        }\n-    }\n-\n-    /// Waits for an event on this receiver set. The returned value is *not* an\n-    /// index, but rather an ID. This ID can be queried against any active\n-    /// `Handle` structures (each one has an `id` method). The handle with\n-    /// the matching `id` will have some sort of event available on it. The\n-    /// event could either be that data is available or the corresponding\n-    /// channel has been closed.\n-    pub fn wait(&self) -> usize {\n-        self.wait2(true)\n-    }\n-\n-    /// Helper method for skipping the preflight checks during testing\n-    pub(super) fn wait2(&self, do_preflight_checks: bool) -> usize {\n-        // Note that this is currently an inefficient implementation. We in\n-        // theory have knowledge about all receivers in the set ahead of time,\n-        // so this method shouldn't really have to iterate over all of them yet\n-        // again. The idea with this \"receiver set\" interface is to get the\n-        // interface right this time around, and later this implementation can\n-        // be optimized.\n-        //\n-        // This implementation can be summarized by:\n-        //\n-        //      fn select(receivers) {\n-        //          if any receiver ready { return ready index }\n-        //          deschedule {\n-        //              block on all receivers\n-        //          }\n-        //          unblock on all receivers\n-        //          return ready index\n-        //      }\n-        //\n-        // Most notably, the iterations over all of the receivers shouldn't be\n-        // necessary.\n-        unsafe {\n-            // Stage 1: preflight checks. Look for any packets ready to receive\n-            if do_preflight_checks {\n-                for handle in self.iter() {\n-                    if (*handle).packet.can_recv() {\n-                        return (*handle).id();\n-                    }\n-                }\n-            }\n-\n-            // Stage 2: begin the blocking process\n-            //\n-            // Create a number of signal tokens, and install each one\n-            // sequentially until one fails. If one fails, then abort the\n-            // selection on the already-installed tokens.\n-            let (wait_token, signal_token) = blocking::tokens();\n-            for (i, handle) in self.iter().enumerate() {\n-                match (*handle).packet.start_selection(signal_token.clone()) {\n-                    StartResult::Installed => {}\n-                    StartResult::Abort => {\n-                        // Go back and abort the already-begun selections\n-                        for handle in self.iter().take(i) {\n-                            (*handle).packet.abort_selection();\n-                        }\n-                        return (*handle).id;\n-                    }\n-                }\n-            }\n-\n-            // Stage 3: no messages available, actually block\n-            wait_token.wait();\n-\n-            // Stage 4: there *must* be message available; find it.\n-            //\n-            // Abort the selection process on each receiver. If the abort\n-            // process returns `true`, then that means that the receiver is\n-            // ready to receive some data. Note that this also means that the\n-            // receiver may have yet to have fully read the `to_wake` field and\n-            // woken us up (although the wakeup is guaranteed to fail).\n-            //\n-            // This situation happens in the window of where a sender invokes\n-            // increment(), sees -1, and then decides to wake up the thread. After\n-            // all this is done, the sending thread will set `selecting` to\n-            // `false`. Until this is done, we cannot return. If we were to\n-            // return, then a sender could wake up a receiver which has gone\n-            // back to sleep after this call to `select`.\n-            //\n-            // Note that it is a \"fairly small window\" in which an increment()\n-            // views that it should wake a thread up until the `selecting` bit\n-            // is set to false. For now, the implementation currently just spins\n-            // in a yield loop. This is very distasteful, but this\n-            // implementation is already nowhere near what it should ideally be.\n-            // A rewrite should focus on avoiding a yield loop, and for now this\n-            // implementation is tying us over to a more efficient \"don't\n-            // iterate over everything every time\" implementation.\n-            let mut ready_id = usize::MAX;\n-            for handle in self.iter() {\n-                if (*handle).packet.abort_selection() {\n-                    ready_id = (*handle).id;\n-                }\n-            }\n-\n-            // We must have found a ready receiver\n-            assert!(ready_id != usize::MAX);\n-            return ready_id;\n-        }\n-    }\n-\n-    fn iter(&self) -> Packets { Packets { cur: unsafe { &*self.inner.get() }.head } }\n-}\n-\n-impl<'rx, T: Send> Handle<'rx, T> {\n-    /// Retrieves the ID of this handle.\n-    #[inline]\n-    pub fn id(&self) -> usize { self.id }\n-\n-    /// Blocks to receive a value on the underlying receiver, returning `Some` on\n-    /// success or `None` if the channel disconnects. This function has the same\n-    /// semantics as `Receiver.recv`\n-    pub fn recv(&mut self) -> Result<T, RecvError> { self.rx.recv() }\n-\n-    /// Adds this handle to the receiver set that the handle was created from. This\n-    /// method can be called multiple times, but it has no effect if `add` was\n-    /// called previously.\n-    ///\n-    /// This method is unsafe because it requires that the `Handle` is not moved\n-    /// while it is added to the `Select` set.\n-    pub unsafe fn add(&mut self) {\n-        if self.added { return }\n-        let selector = &mut *self.selector;\n-        let me = self as *mut Handle<'rx, T> as *mut Handle<'static, ()>;\n-\n-        if selector.head.is_null() {\n-            selector.head = me;\n-            selector.tail = me;\n-        } else {\n-            (*me).prev = selector.tail;\n-            assert!((*me).next.is_null());\n-            (*selector.tail).next = me;\n-            selector.tail = me;\n-        }\n-        self.added = true;\n-    }\n-\n-    /// Removes this handle from the `Select` set. This method is unsafe because\n-    /// it has no guarantee that the `Handle` was not moved since `add` was\n-    /// called.\n-    pub unsafe fn remove(&mut self) {\n-        if !self.added { return }\n-\n-        let selector = &mut *self.selector;\n-        let me = self as *mut Handle<'rx, T> as *mut Handle<'static, ()>;\n-\n-        if self.prev.is_null() {\n-            assert_eq!(selector.head, me);\n-            selector.head = self.next;\n-        } else {\n-            (*self.prev).next = self.next;\n-        }\n-        if self.next.is_null() {\n-            assert_eq!(selector.tail, me);\n-            selector.tail = self.prev;\n-        } else {\n-            (*self.next).prev = self.prev;\n-        }\n-\n-        self.next = ptr::null_mut();\n-        self.prev = ptr::null_mut();\n-\n-        self.added = false;\n-    }\n-}\n-\n-impl Drop for Select {\n-    fn drop(&mut self) {\n-        unsafe {\n-            assert!((&*self.inner.get()).head.is_null());\n-            assert!((&*self.inner.get()).tail.is_null());\n-        }\n-    }\n-}\n-\n-impl<T: Send> Drop for Handle<'_, T> {\n-    fn drop(&mut self) {\n-        unsafe { self.remove() }\n-    }\n-}\n-\n-impl Iterator for Packets {\n-    type Item = *mut Handle<'static, ()>;\n-\n-    fn next(&mut self) -> Option<*mut Handle<'static, ()>> {\n-        if self.cur.is_null() {\n-            None\n-        } else {\n-            let ret = Some(self.cur);\n-            unsafe { self.cur = (*self.cur).next; }\n-            ret\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for Select {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Select\").finish()\n-    }\n-}\n-\n-impl<T: Send> fmt::Debug for Handle<'_, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Handle\").finish()\n-    }\n-}"}, {"sha": "18d93462c78db4b6d789eac898c40d2aea631784", "filename": "src/libstd/sync/mpsc/select_tests.rs", "status": "removed", "additions": 0, "deletions": 413, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibstd%2Fsync%2Fmpsc%2Fselect_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e764f475ca7fffd6167ea991afc7d1b2b3f642dc/src%2Flibstd%2Fsync%2Fmpsc%2Fselect_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect_tests.rs?ref=e764f475ca7fffd6167ea991afc7d1b2b3f642dc", "patch": "@@ -1,413 +0,0 @@\n-#![allow(unused_imports)]\n-\n-/// This file exists to hack around https://github.com/rust-lang/rust/issues/47238\n-\n-use crate::thread;\n-use crate::sync::mpsc::*;\n-\n-// Don't use the libstd version so we can pull in the right Select structure\n-// (std::comm points at the wrong one)\n-macro_rules! select {\n-    (\n-        $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n-    ) => ({\n-        let sel = Select::new();\n-        $( let mut $rx = sel.handle(&$rx); )+\n-        unsafe {\n-            $( $rx.add(); )+\n-        }\n-        let ret = sel.wait();\n-        $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n-        { unreachable!() }\n-    })\n-}\n-\n-#[test]\n-fn smoke() {\n-    let (tx1, rx1) = channel::<i32>();\n-    let (tx2, rx2) = channel::<i32>();\n-    tx1.send(1).unwrap();\n-    select! {\n-        foo = rx1.recv() => { assert_eq!(foo.unwrap(), 1); },\n-        _bar = rx2.recv() => { panic!() }\n-    }\n-    tx2.send(2).unwrap();\n-    select! {\n-        _foo = rx1.recv() => { panic!() },\n-        bar = rx2.recv() => { assert_eq!(bar.unwrap(), 2) }\n-    }\n-    drop(tx1);\n-    select! {\n-        foo = rx1.recv() => { assert!(foo.is_err()); },\n-        _bar = rx2.recv() => { panic!() }\n-    }\n-    drop(tx2);\n-    select! {\n-        bar = rx2.recv() => { assert!(bar.is_err()); }\n-    }\n-}\n-\n-#[test]\n-fn smoke2() {\n-    let (_tx1, rx1) = channel::<i32>();\n-    let (_tx2, rx2) = channel::<i32>();\n-    let (_tx3, rx3) = channel::<i32>();\n-    let (_tx4, rx4) = channel::<i32>();\n-    let (tx5, rx5) = channel::<i32>();\n-    tx5.send(4).unwrap();\n-    select! {\n-        _foo = rx1.recv() => { panic!(\"1\") },\n-        _foo = rx2.recv() => { panic!(\"2\") },\n-        _foo = rx3.recv() => { panic!(\"3\") },\n-        _foo = rx4.recv() => { panic!(\"4\") },\n-        foo = rx5.recv() => { assert_eq!(foo.unwrap(), 4); }\n-    }\n-}\n-\n-#[test]\n-fn closed() {\n-    let (_tx1, rx1) = channel::<i32>();\n-    let (tx2, rx2) = channel::<i32>();\n-    drop(tx2);\n-\n-    select! {\n-        _a1 = rx1.recv() => { panic!() },\n-        a2 = rx2.recv() => { assert!(a2.is_err()); }\n-    }\n-}\n-\n-#[test]\n-fn unblocks() {\n-    let (tx1, rx1) = channel::<i32>();\n-    let (_tx2, rx2) = channel::<i32>();\n-    let (tx3, rx3) = channel::<i32>();\n-\n-    let _t = thread::spawn(move|| {\n-        for _ in 0..20 { thread::yield_now(); }\n-        tx1.send(1).unwrap();\n-        rx3.recv().unwrap();\n-        for _ in 0..20 { thread::yield_now(); }\n-    });\n-\n-    select! {\n-        a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n-        _b = rx2.recv() => { panic!() }\n-    }\n-    tx3.send(1).unwrap();\n-    select! {\n-        a = rx1.recv() => { assert!(a.is_err()) },\n-        _b = rx2.recv() => { panic!() }\n-    }\n-}\n-\n-#[test]\n-fn both_ready() {\n-    let (tx1, rx1) = channel::<i32>();\n-    let (tx2, rx2) = channel::<i32>();\n-    let (tx3, rx3) = channel::<()>();\n-\n-    let _t = thread::spawn(move|| {\n-        for _ in 0..20 { thread::yield_now(); }\n-        tx1.send(1).unwrap();\n-        tx2.send(2).unwrap();\n-        rx3.recv().unwrap();\n-    });\n-\n-    select! {\n-        a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n-        a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n-    }\n-    select! {\n-        a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n-        a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n-    }\n-    assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n-    assert_eq!(rx2.try_recv(), Err(TryRecvError::Empty));\n-    tx3.send(()).unwrap();\n-}\n-\n-#[test]\n-fn stress() {\n-    const AMT: i32 = 10000;\n-    let (tx1, rx1) = channel::<i32>();\n-    let (tx2, rx2) = channel::<i32>();\n-    let (tx3, rx3) = channel::<()>();\n-\n-    let _t = thread::spawn(move|| {\n-        for i in 0..AMT {\n-            if i % 2 == 0 {\n-                tx1.send(i).unwrap();\n-            } else {\n-                tx2.send(i).unwrap();\n-            }\n-            rx3.recv().unwrap();\n-        }\n-    });\n-\n-    for i in 0..AMT {\n-        select! {\n-            i1 = rx1.recv() => { assert!(i % 2 == 0 && i == i1.unwrap()); },\n-            i2 = rx2.recv() => { assert!(i % 2 == 1 && i == i2.unwrap()); }\n-        }\n-        tx3.send(()).unwrap();\n-    }\n-}\n-\n-#[allow(unused_must_use)]\n-#[test]\n-fn cloning() {\n-    let (tx1, rx1) = channel::<i32>();\n-    let (_tx2, rx2) = channel::<i32>();\n-    let (tx3, rx3) = channel::<()>();\n-\n-    let _t = thread::spawn(move|| {\n-        rx3.recv().unwrap();\n-        tx1.clone();\n-        assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n-        tx1.send(2).unwrap();\n-        rx3.recv().unwrap();\n-    });\n-\n-    tx3.send(()).unwrap();\n-    select! {\n-        _i1 = rx1.recv() => {},\n-        _i2 = rx2.recv() => panic!()\n-    }\n-    tx3.send(()).unwrap();\n-}\n-\n-#[allow(unused_must_use)]\n-#[test]\n-fn cloning2() {\n-    let (tx1, rx1) = channel::<i32>();\n-    let (_tx2, rx2) = channel::<i32>();\n-    let (tx3, rx3) = channel::<()>();\n-\n-    let _t = thread::spawn(move|| {\n-        rx3.recv().unwrap();\n-        tx1.clone();\n-        assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n-        tx1.send(2).unwrap();\n-        rx3.recv().unwrap();\n-    });\n-\n-    tx3.send(()).unwrap();\n-    select! {\n-        _i1 = rx1.recv() => {},\n-        _i2 = rx2.recv() => panic!()\n-    }\n-    tx3.send(()).unwrap();\n-}\n-\n-#[test]\n-fn cloning3() {\n-    let (tx1, rx1) = channel::<()>();\n-    let (tx2, rx2) = channel::<()>();\n-    let (tx3, rx3) = channel::<()>();\n-    let _t = thread::spawn(move|| {\n-        let s = Select::new();\n-        let mut h1 = s.handle(&rx1);\n-        let mut h2 = s.handle(&rx2);\n-        unsafe { h2.add(); }\n-        unsafe { h1.add(); }\n-        assert_eq!(s.wait(), h2.id());\n-        tx3.send(()).unwrap();\n-    });\n-\n-    for _ in 0..1000 { thread::yield_now(); }\n-    drop(tx1.clone());\n-    tx2.send(()).unwrap();\n-    rx3.recv().unwrap();\n-}\n-\n-#[test]\n-fn preflight1() {\n-    let (tx, rx) = channel();\n-    tx.send(()).unwrap();\n-    select! {\n-        _n = rx.recv() => {}\n-    }\n-}\n-\n-#[test]\n-fn preflight2() {\n-    let (tx, rx) = channel();\n-    tx.send(()).unwrap();\n-    tx.send(()).unwrap();\n-    select! {\n-        _n = rx.recv() => {}\n-    }\n-}\n-\n-#[test]\n-fn preflight3() {\n-    let (tx, rx) = channel();\n-    drop(tx.clone());\n-    tx.send(()).unwrap();\n-    select! {\n-        _n = rx.recv() => {}\n-    }\n-}\n-\n-#[test]\n-fn preflight4() {\n-    let (tx, rx) = channel();\n-    tx.send(()).unwrap();\n-    let s = Select::new();\n-    let mut h = s.handle(&rx);\n-    unsafe { h.add(); }\n-    assert_eq!(s.wait2(false), h.id());\n-}\n-\n-#[test]\n-fn preflight5() {\n-    let (tx, rx) = channel();\n-    tx.send(()).unwrap();\n-    tx.send(()).unwrap();\n-    let s = Select::new();\n-    let mut h = s.handle(&rx);\n-    unsafe { h.add(); }\n-    assert_eq!(s.wait2(false), h.id());\n-}\n-\n-#[test]\n-fn preflight6() {\n-    let (tx, rx) = channel();\n-    drop(tx.clone());\n-    tx.send(()).unwrap();\n-    let s = Select::new();\n-    let mut h = s.handle(&rx);\n-    unsafe { h.add(); }\n-    assert_eq!(s.wait2(false), h.id());\n-}\n-\n-#[test]\n-fn preflight7() {\n-    let (tx, rx) = channel::<()>();\n-    drop(tx);\n-    let s = Select::new();\n-    let mut h = s.handle(&rx);\n-    unsafe { h.add(); }\n-    assert_eq!(s.wait2(false), h.id());\n-}\n-\n-#[test]\n-fn preflight8() {\n-    let (tx, rx) = channel();\n-    tx.send(()).unwrap();\n-    drop(tx);\n-    rx.recv().unwrap();\n-    let s = Select::new();\n-    let mut h = s.handle(&rx);\n-    unsafe { h.add(); }\n-    assert_eq!(s.wait2(false), h.id());\n-}\n-\n-#[test]\n-fn preflight9() {\n-    let (tx, rx) = channel();\n-    drop(tx.clone());\n-    tx.send(()).unwrap();\n-    drop(tx);\n-    rx.recv().unwrap();\n-    let s = Select::new();\n-    let mut h = s.handle(&rx);\n-    unsafe { h.add(); }\n-    assert_eq!(s.wait2(false), h.id());\n-}\n-\n-#[test]\n-fn oneshot_data_waiting() {\n-    let (tx1, rx1) = channel();\n-    let (tx2, rx2) = channel();\n-    let _t = thread::spawn(move|| {\n-        select! {\n-            _n = rx1.recv() => {}\n-        }\n-        tx2.send(()).unwrap();\n-    });\n-\n-    for _ in 0..100 { thread::yield_now() }\n-    tx1.send(()).unwrap();\n-    rx2.recv().unwrap();\n-}\n-\n-#[test]\n-fn stream_data_waiting() {\n-    let (tx1, rx1) = channel();\n-    let (tx2, rx2) = channel();\n-    tx1.send(()).unwrap();\n-    tx1.send(()).unwrap();\n-    rx1.recv().unwrap();\n-    rx1.recv().unwrap();\n-    let _t = thread::spawn(move|| {\n-        select! {\n-            _n = rx1.recv() => {}\n-        }\n-        tx2.send(()).unwrap();\n-    });\n-\n-    for _ in 0..100 { thread::yield_now() }\n-    tx1.send(()).unwrap();\n-    rx2.recv().unwrap();\n-}\n-\n-#[test]\n-fn shared_data_waiting() {\n-    let (tx1, rx1) = channel();\n-    let (tx2, rx2) = channel();\n-    drop(tx1.clone());\n-    tx1.send(()).unwrap();\n-    rx1.recv().unwrap();\n-    let _t = thread::spawn(move|| {\n-        select! {\n-            _n = rx1.recv() => {}\n-        }\n-        tx2.send(()).unwrap();\n-    });\n-\n-    for _ in 0..100 { thread::yield_now() }\n-    tx1.send(()).unwrap();\n-    rx2.recv().unwrap();\n-}\n-\n-#[test]\n-fn sync1() {\n-    let (tx, rx) = sync_channel::<i32>(1);\n-    tx.send(1).unwrap();\n-    select! {\n-        n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n-    }\n-}\n-\n-#[test]\n-fn sync2() {\n-    let (tx, rx) = sync_channel::<i32>(0);\n-    let _t = thread::spawn(move|| {\n-        for _ in 0..100 { thread::yield_now() }\n-        tx.send(1).unwrap();\n-    });\n-    select! {\n-        n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n-    }\n-}\n-\n-#[test]\n-fn sync3() {\n-    let (tx1, rx1) = sync_channel::<i32>(0);\n-    let (tx2, rx2): (Sender<i32>, Receiver<i32>) = channel();\n-    let _t = thread::spawn(move|| { tx1.send(1).unwrap(); });\n-    let _t = thread::spawn(move|| { tx2.send(2).unwrap(); });\n-    select! {\n-        n = rx1.recv() => {\n-            let n = n.unwrap();\n-            assert_eq!(n, 1);\n-            assert_eq!(rx2.recv().unwrap(), 2);\n-        },\n-        n = rx2.recv() => {\n-            let n = n.unwrap();\n-            assert_eq!(n, 2);\n-            assert_eq!(rx1.recv().unwrap(), 1);\n-        }\n-    }\n-}"}, {"sha": "dbcdcdac9326855330847013db2d442e233e5623", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -9,6 +9,7 @@\n /// channels are quite similar, and this is no coincidence!\n \n pub use self::Failure::*;\n+use self::StartResult::*;\n \n use core::cmp;\n use core::intrinsics::abort;\n@@ -19,8 +20,6 @@ use crate::ptr;\n use crate::sync::atomic::{AtomicUsize, AtomicIsize, AtomicBool, Ordering};\n use crate::sync::mpsc::blocking::{self, SignalToken};\n use crate::sync::mpsc::mpsc_queue as mpsc;\n-use crate::sync::mpsc::select::StartResult::*;\n-use crate::sync::mpsc::select::StartResult;\n use crate::sync::{Mutex, MutexGuard};\n use crate::thread;\n use crate::time::Instant;\n@@ -57,6 +56,12 @@ pub enum Failure {\n     Disconnected,\n }\n \n+#[derive(PartialEq, Eq)]\n+enum StartResult {\n+    Installed,\n+    Abort,\n+}\n+\n impl<T> Packet<T> {\n     // Creation of a packet *must* be followed by a call to postinit_lock\n     // and later by inherit_blocker\n@@ -394,16 +399,6 @@ impl<T> Packet<T> {\n     // select implementation\n     ////////////////////////////////////////////////////////////////////////////\n \n-    // Helper function for select, tests whether this port can receive without\n-    // blocking (obviously not an atomic decision).\n-    //\n-    // This is different than the stream version because there's no need to peek\n-    // at the queue, we can just look at the local count.\n-    pub fn can_recv(&self) -> bool {\n-        let cnt = self.cnt.load(Ordering::SeqCst);\n-        cnt == DISCONNECTED || cnt - unsafe { *self.steals.get() } > 0\n-    }\n-\n     // increment the count on the channel (used for selection)\n     fn bump(&self, amt: isize) -> isize {\n         match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n@@ -415,22 +410,6 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    // Inserts the signal token for selection on this port, returning true if\n-    // blocking should proceed.\n-    //\n-    // The code here is the same as in stream.rs, except that it doesn't need to\n-    // peek at the channel to see if an upgrade is pending.\n-    pub fn start_selection(&self, token: SignalToken) -> StartResult {\n-        match self.decrement(token) {\n-            Installed => Installed,\n-            Abort => {\n-                let prev = self.bump(1);\n-                assert!(prev == DISCONNECTED || prev >= 0);\n-                Abort\n-            }\n-        }\n-    }\n-\n     // Cancels a previous thread waiting on this port, returning whether there's\n     // data on the port.\n     //"}, {"sha": "40877282761790cd78c989d9eb37fad0cd92c181", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -9,7 +9,6 @@\n \n pub use self::Failure::*;\n pub use self::UpgradeResult::*;\n-pub use self::SelectionResult::*;\n use self::Message::*;\n \n use core::cmp;\n@@ -60,12 +59,6 @@ pub enum UpgradeResult {\n     UpWoke(SignalToken),\n }\n \n-pub enum SelectionResult<T> {\n-    SelSuccess,\n-    SelCanceled,\n-    SelUpgraded(SignalToken, Receiver<T>),\n-}\n-\n // Any message could contain an \"upgrade request\" to a new shared port, so the\n // internal queue it's a queue of T, but rather Message<T>\n enum Message<T> {\n@@ -338,27 +331,6 @@ impl<T> Packet<T> {\n     // select implementation\n     ////////////////////////////////////////////////////////////////////////////\n \n-    // Tests to see whether this port can receive without blocking. If Ok is\n-    // returned, then that's the answer. If Err is returned, then the returned\n-    // port needs to be queried instead (an upgrade happened)\n-    pub fn can_recv(&self) -> Result<bool, Receiver<T>> {\n-        // We peek at the queue to see if there's anything on it, and we use\n-        // this return value to determine if we should pop from the queue and\n-        // upgrade this channel immediately. If it looks like we've got an\n-        // upgrade pending, then go through the whole recv rigamarole to update\n-        // the internal state.\n-        match self.queue.peek() {\n-            Some(&mut GoUp(..)) => {\n-                match self.recv(None) {\n-                    Err(Upgraded(port)) => Err(port),\n-                    _ => unreachable!(),\n-                }\n-            }\n-            Some(..) => Ok(true),\n-            None => Ok(false)\n-        }\n-    }\n-\n     // increment the count on the channel (used for selection)\n     fn bump(&self, amt: isize) -> isize {\n         match self.queue.producer_addition().cnt.fetch_add(amt, Ordering::SeqCst) {\n@@ -370,31 +342,6 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    // Attempts to start selecting on this port. Like a oneshot, this can fail\n-    // immediately because of an upgrade.\n-    pub fn start_selection(&self, token: SignalToken) -> SelectionResult<T> {\n-        match self.decrement(token) {\n-            Ok(()) => SelSuccess,\n-            Err(token) => {\n-                let ret = match self.queue.peek() {\n-                    Some(&mut GoUp(..)) => {\n-                        match self.queue.pop() {\n-                            Some(GoUp(port)) => SelUpgraded(token, port),\n-                            _ => unreachable!(),\n-                        }\n-                    }\n-                    Some(..) => SelCanceled,\n-                    None => SelCanceled,\n-                };\n-                // Undo our decrement above, and we should be guaranteed that the\n-                // previous value is positive because we're not going to sleep\n-                let prev = self.bump(1);\n-                assert!(prev == DISCONNECTED || prev >= 0);\n-                ret\n-            }\n-        }\n-    }\n-\n     // Removes a previous thread from being blocked in this port\n     pub fn abort_selection(&self,\n                            was_upgrade: bool) -> Result<bool, Receiver<T>> {"}, {"sha": "3c4f8e077c922ee536340b607fc3e2c2b29179cc", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -33,7 +33,6 @@ use core::ptr;\n \n use crate::sync::atomic::{Ordering, AtomicUsize};\n use crate::sync::mpsc::blocking::{self, WaitToken, SignalToken};\n-use crate::sync::mpsc::select::StartResult::{self, Installed, Abort};\n use crate::sync::{Mutex, MutexGuard};\n use crate::time::Instant;\n \n@@ -406,42 +405,6 @@ impl<T> Packet<T> {\n         while let Some(token) = queue.dequeue() { token.signal(); }\n         waiter.map(|t| t.signal());\n     }\n-\n-    ////////////////////////////////////////////////////////////////////////////\n-    // select implementation\n-    ////////////////////////////////////////////////////////////////////////////\n-\n-    // If Ok, the value is whether this port has data, if Err, then the upgraded\n-    // port needs to be checked instead of this one.\n-    pub fn can_recv(&self) -> bool {\n-        let guard = self.lock.lock().unwrap();\n-        guard.disconnected || guard.buf.size() > 0\n-    }\n-\n-    // Attempts to start selection on this port. This can either succeed or fail\n-    // because there is data waiting.\n-    pub fn start_selection(&self, token: SignalToken) -> StartResult {\n-        let mut guard = self.lock.lock().unwrap();\n-        if guard.disconnected || guard.buf.size() > 0 {\n-            Abort\n-        } else {\n-            match mem::replace(&mut guard.blocker, BlockedReceiver(token)) {\n-                NoneBlocked => {}\n-                BlockedSender(..) => unreachable!(),\n-                BlockedReceiver(..) => unreachable!(),\n-            }\n-            Installed\n-        }\n-    }\n-\n-    // Remove a previous selecting thread from this port. This ensures that the\n-    // blocked thread will no longer be visible to any other threads.\n-    //\n-    // The return value indicates whether there's data on this port.\n-    pub fn abort_selection(&self) -> bool {\n-        let mut guard = self.lock.lock().unwrap();\n-        abort_selection(&mut guard)\n-    }\n }\n \n impl<T> Drop for Packet<T> {"}, {"sha": "87c2318a9377c56ff3b3922915d664cd2aeaeaa8", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -376,6 +376,8 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Mutex<T> {\n impl<T> From<T> for Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n     /// This is equivalent to [`Mutex::new`].\n+    ///\n+    /// [`Mutex::new`]: ../../std/sync/struct.Mutex.html#method.new\n     fn from(t: T) -> Self {\n         Mutex::new(t)\n     }"}, {"sha": "b1b56f321fc6b8fb162c68a7ba2362de91621ab3", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -453,6 +453,8 @@ impl<T: Default> Default for RwLock<T> {\n impl<T> From<T> for RwLock<T> {\n     /// Creates a new instance of an `RwLock<T>` which is unlocked.\n     /// This is equivalent to [`RwLock::new`].\n+    ///\n+    /// [`RwLock::new`]: ../../std/sync/struct.RwLock.html#method.new\n     fn from(t: T) -> Self {\n         RwLock::new(t)\n     }"}, {"sha": "6ba947d4598b1da1163214923bbf24dbacc854c8", "filename": "src/libstd/sys/unix/args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -35,6 +35,8 @@ impl Iterator for Args {\n     type Item = OsString;\n     fn next(&mut self) -> Option<OsString> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    #[inline]\n+    fn last(mut self) -> Option<OsString> { self.next_back() }\n }\n \n impl ExactSizeIterator for Args {\n@@ -49,7 +51,6 @@ impl DoubleEndedIterator for Args {\n           target_os = \"android\",\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n           target_os = \"netbsd\",\n           target_os = \"openbsd\",\n           target_os = \"solaris\","}, {"sha": "891013406a1699cead6ea8630ba4ba89a96b1e58", "filename": "src/libstd/sys/unix/env.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fenv.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -53,17 +53,6 @@ pub mod os {\n     pub const EXE_EXTENSION: &str = \"\";\n }\n \n-#[cfg(target_os = \"bitrig\")]\n-pub mod os {\n-    pub const FAMILY: &str = \"unix\";\n-    pub const OS: &str = \"bitrig\";\n-    pub const DLL_PREFIX: &str = \"lib\";\n-    pub const DLL_SUFFIX: &str = \".so\";\n-    pub const DLL_EXTENSION: &str = \"so\";\n-    pub const EXE_SUFFIX: &str = \"\";\n-    pub const EXE_EXTENSION: &str = \"\";\n-}\n-\n #[cfg(target_os = \"netbsd\")]\n pub mod os {\n     pub const FAMILY: &str = \"unix\";"}, {"sha": "3ccb0a1b1abc7c547b023be8dc0a67c0f24fd55e", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -32,12 +32,12 @@ use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n #[cfg(any(target_os = \"linux\", target_os = \"android\",\n           target_os = \"dragonfly\", target_os = \"freebsd\",\n           target_os = \"openbsd\", target_os = \"netbsd\",\n-          target_os = \"haiku\", target_os = \"bitrig\"))]\n+          target_os = \"haiku\"))]\n use libc::MSG_NOSIGNAL;\n #[cfg(not(any(target_os = \"linux\", target_os = \"android\",\n               target_os = \"dragonfly\", target_os = \"freebsd\",\n               target_os = \"openbsd\", target_os = \"netbsd\",\n-              target_os = \"haiku\", target_os = \"bitrig\")))]\n+              target_os = \"haiku\")))]\n const MSG_NOSIGNAL: libc::c_int = 0x0;\n \n fn sun_path_offset() -> usize {"}, {"sha": "cc1f0790d4334fbb3266a6abe70e942eb9d5aa32", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -147,8 +147,7 @@ impl FileAttr {\n         }))\n     }\n \n-    #[cfg(any(target_os = \"bitrig\",\n-              target_os = \"freebsd\",\n+    #[cfg(any(target_os = \"freebsd\",\n               target_os = \"openbsd\",\n               target_os = \"macos\",\n               target_os = \"ios\"))]\n@@ -159,8 +158,7 @@ impl FileAttr {\n         }))\n     }\n \n-    #[cfg(not(any(target_os = \"bitrig\",\n-                  target_os = \"freebsd\",\n+    #[cfg(not(any(target_os = \"freebsd\",\n                   target_os = \"openbsd\",\n                   target_os = \"macos\",\n                   target_os = \"ios\")))]\n@@ -355,7 +353,6 @@ impl DirEntry {\n \n     #[cfg(any(target_os = \"freebsd\",\n               target_os = \"openbsd\",\n-              target_os = \"bitrig\",\n               target_os = \"netbsd\",\n               target_os = \"dragonfly\"))]\n     pub fn ino(&self) -> u64 {\n@@ -367,8 +364,7 @@ impl DirEntry {\n               target_os = \"netbsd\",\n               target_os = \"openbsd\",\n               target_os = \"freebsd\",\n-              target_os = \"dragonfly\",\n-              target_os = \"bitrig\"))]\n+              target_os = \"dragonfly\"))]\n     fn name_bytes(&self) -> &[u8] {\n         use crate::slice;\n         unsafe {"}, {"sha": "c2b264ff8de1154788c3cbce34ff466732ba0c30", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -5,7 +5,6 @@ use crate::io::ErrorKind;\n #[cfg(any(rustdoc, target_os = \"linux\"))] pub use crate::os::linux as platform;\n \n #[cfg(all(not(rustdoc), target_os = \"android\"))]   pub use crate::os::android as platform;\n-#[cfg(all(not(rustdoc), target_os = \"bitrig\"))]    pub use crate::os::bitrig as platform;\n #[cfg(all(not(rustdoc), target_os = \"dragonfly\"))] pub use crate::os::dragonfly as platform;\n #[cfg(all(not(rustdoc), target_os = \"freebsd\"))]   pub use crate::os::freebsd as platform;\n #[cfg(all(not(rustdoc), target_os = \"haiku\"))]     pub use crate::os::haiku as platform;"}, {"sha": "dad19eabf7db79bd87ba8827dc8e45f2ab1c9bf4", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -33,8 +33,7 @@ extern {\n                    target_os = \"fuchsia\",\n                    target_os = \"l4re\"),\n                link_name = \"__errno_location\")]\n-    #[cfg_attr(any(target_os = \"bitrig\",\n-                   target_os = \"netbsd\",\n+    #[cfg_attr(any(target_os = \"netbsd\",\n                    target_os = \"openbsd\",\n                    target_os = \"android\",\n                    target_os = \"hermit\",\n@@ -257,7 +256,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     sysctl().or_else(|_| procfs())\n }\n \n-#[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n+#[cfg(target_os = \"openbsd\")]\n pub fn current_exe() -> io::Result<PathBuf> {\n     unsafe {\n         let mut mib = [libc::CTL_KERN,"}, {"sha": "71c62461ee9cb4aef5aa6e01652c37165842f25e", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -13,7 +13,6 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n \n #[cfg(all(unix,\n           not(target_os = \"ios\"),\n-          not(all(target_os = \"macos\", miri)),\n           not(target_os = \"openbsd\"),\n           not(target_os = \"freebsd\"),\n           not(target_os = \"fuchsia\")))]\n@@ -48,7 +47,12 @@ mod imp {\n                 let err = errno() as libc::c_int;\n                 if err == libc::EINTR {\n                     continue;\n-                } else if err == libc::ENOSYS {\n+                } else if err == libc::ENOSYS || err == libc::EPERM {\n+                    // Fall back to reading /dev/urandom if `getrandom` is not\n+                    // supported on the current kernel.\n+                    //\n+                    // Also fall back in case it is disabled by something like\n+                    // seccomp or inside of virtual machines.\n                     GETRANDOM_UNAVAILABLE.store(true, Ordering::Relaxed);\n                     return false;\n                 } else if err == libc::EAGAIN {\n@@ -107,9 +111,7 @@ mod imp {\n // once per thread in `hashmap_random_keys`. Therefore `SecRandomCopyBytes` is\n // only used on iOS where direct access to `/dev/urandom` is blocked by the\n // sandbox.\n-// HACK: However, we do use this when running in Miri on macOS; intercepting this is much\n-// easier than intercepting accesses to /dev/urandom.\n-#[cfg(any(target_os = \"ios\", all(target_os = \"macos\", miri)))]\n+#[cfg(target_os = \"ios\")]\n mod imp {\n     use crate::io;\n     use crate::ptr;"}, {"sha": "fe1095fa0c2f65596fba38711f38cbb1b43b0fd4", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -25,7 +25,6 @@ impl Drop for Handler {\n \n #[cfg(any(target_os = \"linux\",\n           target_os = \"macos\",\n-          target_os = \"bitrig\",\n           target_os = \"dragonfly\",\n           target_os = \"freebsd\",\n           target_os = \"solaris\",\n@@ -139,7 +138,6 @@ mod imp {\n \n     #[cfg(any(target_os = \"linux\",\n               target_os = \"macos\",\n-              target_os = \"bitrig\",\n               target_os = \"freebsd\",\n               target_os = \"netbsd\",\n               target_os = \"openbsd\",\n@@ -185,7 +183,6 @@ mod imp {\n \n #[cfg(not(any(target_os = \"linux\",\n               target_os = \"macos\",\n-              target_os = \"bitrig\",\n               target_os = \"dragonfly\",\n               target_os = \"freebsd\",\n               target_os = \"solaris\","}, {"sha": "f4a1783ce8903d202fe5cafe2d1e8b25148caa3c", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -99,7 +99,6 @@ impl Thread {\n \n     #[cfg(any(target_os = \"freebsd\",\n               target_os = \"dragonfly\",\n-              target_os = \"bitrig\",\n               target_os = \"openbsd\"))]\n     pub fn set_name(name: &CStr) {\n         unsafe {\n@@ -189,7 +188,6 @@ impl Drop for Thread {\n #[cfg(all(not(all(target_os = \"linux\", not(target_env = \"musl\"))),\n           not(target_os = \"freebsd\"),\n           not(target_os = \"macos\"),\n-          not(target_os = \"bitrig\"),\n           not(all(target_os = \"netbsd\", not(target_vendor = \"rumprun\"))),\n           not(target_os = \"openbsd\"),\n           not(target_os = \"solaris\")))]\n@@ -205,7 +203,6 @@ pub mod guard {\n #[cfg(any(all(target_os = \"linux\", not(target_env = \"musl\")),\n           target_os = \"freebsd\",\n           target_os = \"macos\",\n-          target_os = \"bitrig\",\n           all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n           target_os = \"openbsd\",\n           target_os = \"solaris\"))]\n@@ -236,16 +233,15 @@ pub mod guard {\n         Some(stackaddr as *mut libc::c_void)\n     }\n \n-    #[cfg(any(target_os = \"openbsd\", target_os = \"bitrig\"))]\n+    #[cfg(target_os = \"openbsd\")]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n         let mut current_stack: libc::stack_t = crate::mem::zeroed();\n         assert_eq!(libc::pthread_stackseg_np(libc::pthread_self(),\n                                              &mut current_stack), 0);\n \n-        let extra = if cfg!(target_os = \"bitrig\") {3} else {1} * PAGE_SIZE;\n         let stackaddr = if libc::pthread_main_np() == 1 {\n             // main thread\n-            current_stack.ss_sp as usize - current_stack.ss_size + extra\n+            current_stack.ss_sp as usize - current_stack.ss_size + PAGE_SIZE\n         } else {\n             // new thread\n             current_stack.ss_sp as usize - current_stack.ss_size\n@@ -343,7 +339,6 @@ pub mod guard {\n     }\n \n     #[cfg(any(target_os = \"macos\",\n-              target_os = \"bitrig\",\n               target_os = \"openbsd\",\n               target_os = \"solaris\"))]\n     pub unsafe fn current() -> Option<Guard> {"}, {"sha": "6766099c1ece13d05520f6f5ba04ed1c453f7adc", "filename": "src/libstd/sys/wasm/args.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -37,6 +37,10 @@ impl Iterator for Args {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+    #[inline]\n+    fn last(mut self) -> Option<OsString> {\n+        self.next_back()\n+    }\n }\n \n impl ExactSizeIterator for Args {"}, {"sha": "744d7ec59d3a3e76303da40a4589bf099af936d1", "filename": "src/libstd/sys/windows/args.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -181,6 +181,8 @@ impl Iterator for Args {\n     type Item = OsString;\n     fn next(&mut self) -> Option<OsString> { self.parsed_args_list.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.parsed_args_list.size_hint() }\n+    #[inline]\n+    fn last(mut self) -> Option<OsString> { self.next_back() }\n }\n \n impl DoubleEndedIterator for Args {"}, {"sha": "391f670346f2ad92e1e63e98f8edf0b5dac44551", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -37,12 +37,12 @@ use crate::sys::net::netc::IPV6_DROP_MEMBERSHIP;\n #[cfg(any(target_os = \"linux\", target_os = \"android\",\n           target_os = \"dragonfly\", target_os = \"freebsd\",\n           target_os = \"openbsd\", target_os = \"netbsd\",\n-          target_os = \"haiku\", target_os = \"bitrig\"))]\n+          target_os = \"haiku\"))]\n use libc::MSG_NOSIGNAL;\n #[cfg(not(any(target_os = \"linux\", target_os = \"android\",\n               target_os = \"dragonfly\", target_os = \"freebsd\",\n               target_os = \"openbsd\", target_os = \"netbsd\",\n-              target_os = \"haiku\", target_os = \"bitrig\")))]\n+              target_os = \"haiku\")))]\n const MSG_NOSIGNAL: c_int = 0x0;\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "35de4f4008b6723a67aa2c567ee4fde6987c0067", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -443,6 +443,7 @@ impl Builder {\n     /// [`Builder::spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n     /// [`io::Result`]: ../../std/io/type.Result.html\n     /// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n+    /// [`JoinHandle::join`]: ../../std/thread/struct.JoinHandle.html#method.join\n     #[unstable(feature = \"thread_spawn_unchecked\", issue = \"55132\")]\n     pub unsafe fn spawn_unchecked<'a, F, T>(self, f: F) -> io::Result<JoinHandle<T>> where\n         F: FnOnce() -> T, F: Send + 'a, T: Send + 'a"}, {"sha": "a6bb47bef87e0ad5a9fc20fd4bf4abc3bd9d5023", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -6,6 +6,7 @@ pub use crate::symbol::{Ident, Symbol as Name};\n pub use crate::util::parser::ExprPrecedence;\n \n use crate::ext::hygiene::{Mark, SyntaxContext};\n+use crate::parse::token;\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::{dummy_spanned, respan, Spanned};\n@@ -15,7 +16,7 @@ use crate::ThinVec;\n \n use rustc_data_structures::indexed_vec::Idx;\n #[cfg(target_arch = \"x86_64\")]\n-use rustc_data_structures::static_assert;\n+use rustc_data_structures::static_assert_size;\n use rustc_target::spec::abi::Abi;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -71,21 +72,11 @@ pub struct Path {\n impl PartialEq<Symbol> for Path {\n     fn eq(&self, symbol: &Symbol) -> bool {\n         self.segments.len() == 1 && {\n-            let name = self.segments[0].ident.name;\n-            // Make sure these symbols are pure strings\n-            debug_assert!(!symbol.is_gensymed());\n-            debug_assert!(!name.is_gensymed());\n-            name == *symbol\n+            self.segments[0].ident.name == *symbol\n         }\n     }\n }\n \n-impl<'a> PartialEq<&'a str> for Path {\n-    fn eq(&self, string: &&'a str) -> bool {\n-        self.segments.len() == 1 && self.segments[0].ident.name == *string\n-    }\n-}\n-\n impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"path({})\", pprust::path_to_string(self))\n@@ -969,7 +960,7 @@ pub struct Expr {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(MEM_SIZE_OF_EXPR: std::mem::size_of::<Expr>() == 96);\n+static_assert_size!(Expr, 96);\n \n impl Expr {\n     /// Whether this expression would be valid somewhere that expects a value; for example, an `if`\n@@ -1350,8 +1341,19 @@ pub enum StrStyle {\n     Raw(u16),\n }\n \n-/// A literal.\n-pub type Lit = Spanned<LitKind>;\n+/// An AST literal.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct Lit {\n+    /// The original literal token as written in source code.\n+    pub token: token::Lit,\n+    /// The original literal suffix as written in source code.\n+    pub suffix: Option<Symbol>,\n+    /// The \"semantic\" representation of the literal lowered from the original tokens.\n+    /// Strings are unescaped, hexadecimal forms are eliminated, etc.\n+    /// FIXME: Remove this and only create the semantic representation during lowering to HIR.\n+    pub node: LitKind,\n+    pub span: Span,\n+}\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, PartialEq)]\n pub enum LitIntType {"}, {"sha": "65ca96afab1292be47cf18688b1f0708ec6da054", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 59, "deletions": 62, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -5,7 +5,7 @@ use crate::feature_gate::{Features, GatedCfg};\n use crate::parse::ParseSess;\n \n use errors::{Applicability, Handler};\n-use syntax_pos::{symbol::Symbol, Span};\n+use syntax_pos::{symbol::Symbol, symbol::sym, Span};\n \n use super::{mark_used, MetaItemKind};\n \n@@ -80,13 +80,13 @@ pub enum UnwindAttr {\n /// Determine what `#[unwind]` attribute is present in `attrs`, if any.\n pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Option<UnwindAttr> {\n     attrs.iter().fold(None, |ia, attr| {\n-        if attr.check_name(\"unwind\") {\n+        if attr.check_name(sym::unwind) {\n             if let Some(meta) = attr.meta() {\n                 if let MetaItemKind::List(items) = meta.node {\n                     if items.len() == 1 {\n-                        if items[0].check_name(\"allowed\") {\n+                        if items[0].check_name(sym::allowed) {\n                             return Some(UnwindAttr::Allowed);\n-                        } else if items[0].check_name(\"aborts\") {\n+                        } else if items[0].check_name(sym::aborts) {\n                             return Some(UnwindAttr::Aborts);\n                         }\n                     }\n@@ -153,9 +153,9 @@ pub struct RustcDeprecation {\n \n /// Checks if `attrs` contains an attribute like `#![feature(feature_name)]`.\n /// This will not perform any \"sanity checks\" on the form of the attributes.\n-pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n+pub fn contains_feature_attr(attrs: &[Attribute], feature_name: Symbol) -> bool {\n     attrs.iter().any(|item| {\n-        item.check_name(\"feature\") &&\n+        item.check_name(sym::feature) &&\n         item.meta_item_list().map(|list| {\n             list.iter().any(|mi| mi.is_word() && mi.check_name(feature_name))\n         }).unwrap_or(false)\n@@ -185,12 +185,12 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n \n     'outer: for attr in attrs_iter {\n         if ![\n-            \"rustc_deprecated\",\n-            \"rustc_const_unstable\",\n-            \"unstable\",\n-            \"stable\",\n-            \"rustc_promotable\",\n-            \"rustc_allow_const_fn_ptr\",\n+            sym::rustc_deprecated,\n+            sym::rustc_const_unstable,\n+            sym::unstable,\n+            sym::stable,\n+            sym::rustc_promotable,\n+            sym::rustc_allow_const_fn_ptr,\n         ].iter().any(|&s| attr.path == s) {\n             continue // not a stability level\n         }\n@@ -199,10 +199,10 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n \n         let meta = attr.meta();\n \n-        if attr.path == \"rustc_promotable\" {\n+        if attr.path == sym::rustc_promotable {\n             promotable = true;\n         }\n-        if attr.path == \"rustc_allow_const_fn_ptr\" {\n+        if attr.path == sym::rustc_allow_const_fn_ptr {\n             allow_const_fn_ptr = true;\n         }\n         // attributes with data\n@@ -229,10 +229,9 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                     )+\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match mi.name_or_empty().get() {\n+                            match mi.name_or_empty() {\n                                 $(\n-                                    stringify!($name)\n-                                        => if !get(mi, &mut $name) { continue 'outer },\n+                                    sym::$name => if !get(mi, &mut $name) { continue 'outer },\n                                 )+\n                                 _ => {\n                                     let expected = &[ $( stringify!($name) ),+ ];\n@@ -259,8 +258,8 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                 }\n             }\n \n-            match meta.name_or_empty().get() {\n-                \"rustc_deprecated\" => {\n+            match meta.name_or_empty() {\n+                sym::rustc_deprecated => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n                                   \"multiple rustc_deprecated attributes\");\n@@ -287,7 +286,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                         }\n                     }\n                 }\n-                \"rustc_const_unstable\" => {\n+                sym::rustc_const_unstable => {\n                     if rustc_const_unstable.is_some() {\n                         span_err!(diagnostic, item_sp, E0553,\n                                   \"multiple rustc_const_unstable attributes\");\n@@ -302,7 +301,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                         continue\n                     }\n                 }\n-                \"unstable\" => {\n+                sym::unstable => {\n                     if stab.is_some() {\n                         handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n                         break\n@@ -313,10 +312,10 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                     let mut issue = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match mi.name_or_empty().get() {\n-                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n-                                \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n-                                \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n+                            match mi.name_or_empty() {\n+                                sym::feature => if !get(mi, &mut feature) { continue 'outer },\n+                                sym::reason => if !get(mi, &mut reason) { continue 'outer },\n+                                sym::issue => if !get(mi, &mut issue) { continue 'outer },\n                                 _ => {\n                                     handle_errors(\n                                         sess,\n@@ -374,7 +373,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                         }\n                     }\n                 }\n-                \"stable\" => {\n+                sym::stable => {\n                     if stab.is_some() {\n                         handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n                         break\n@@ -385,11 +384,9 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                     for meta in metas {\n                         match meta {\n                             NestedMetaItem::MetaItem(mi) => {\n-                                match mi.name_or_empty().get() {\n-                                    \"feature\" =>\n-                                        if !get(mi, &mut feature) { continue 'outer },\n-                                    \"since\" =>\n-                                        if !get(mi, &mut since) { continue 'outer },\n+                                match mi.name_or_empty() {\n+                                    sym::feature => if !get(mi, &mut feature) { continue 'outer },\n+                                    sym::since => if !get(mi, &mut since) { continue 'outer },\n                                     _ => {\n                                         handle_errors(\n                                             sess,\n@@ -482,7 +479,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n }\n \n pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n-    super::first_attr_value_str_by_name(attrs, \"crate_name\")\n+    super::first_attr_value_str_by_name(attrs, sym::crate_name)\n }\n \n /// Tests if a cfg-pattern matches the cfg set\n@@ -542,14 +539,14 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n \n             // The unwraps below may look dangerous, but we've already asserted\n             // that they won't fail with the loop above.\n-            match cfg.name_or_empty().get() {\n-                \"any\" => mis.iter().any(|mi| {\n+            match cfg.name_or_empty() {\n+                sym::any => mis.iter().any(|mi| {\n                     eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n-                \"all\" => mis.iter().all(|mi| {\n+                sym::all => mis.iter().all(|mi| {\n                     eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n-                \"not\" => {\n+                sym::not => {\n                     if mis.len() != 1 {\n                         span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n                         return false;\n@@ -593,7 +590,7 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n     let diagnostic = &sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n-        if !attr.check_name(\"deprecated\") {\n+        if !attr.check_name(sym::deprecated) {\n             continue;\n         }\n \n@@ -645,9 +642,9 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n                 for meta in list {\n                     match meta {\n                         NestedMetaItem::MetaItem(mi) => {\n-                            match mi.name_or_empty().get() {\n-                                \"since\" => if !get(mi, &mut since) { continue 'outer },\n-                                \"note\" => if !get(mi, &mut note) { continue 'outer },\n+                            match mi.name_or_empty() {\n+                                sym::since => if !get(mi, &mut since) { continue 'outer },\n+                                sym::note => if !get(mi, &mut note) { continue 'outer },\n                                 _ => {\n                                     handle_errors(\n                                         sess,\n@@ -721,7 +718,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n \n     let mut acc = Vec::new();\n     let diagnostic = &sess.span_diagnostic;\n-    if attr.path == \"repr\" {\n+    if attr.path == sym::repr {\n         if let Some(items) = attr.meta_item_list() {\n             mark_used(attr);\n             for item in items {\n@@ -739,11 +736,11 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n \n                 let mut recognised = false;\n                 if item.is_word() {\n-                    let hint = match item.name_or_empty().get() {\n-                        \"C\" => Some(ReprC),\n-                        \"packed\" => Some(ReprPacked(1)),\n-                        \"simd\" => Some(ReprSimd),\n-                        \"transparent\" => Some(ReprTransparent),\n+                    let hint = match item.name_or_empty() {\n+                        sym::C => Some(ReprC),\n+                        sym::packed => Some(ReprPacked(1)),\n+                        sym::simd => Some(ReprSimd),\n+                        sym::transparent => Some(ReprTransparent),\n                         name => int_type_of_word(name).map(ReprInt),\n                     };\n \n@@ -770,14 +767,14 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                     };\n \n                     let mut literal_error = None;\n-                    if name == \"align\" {\n+                    if name == sym::align {\n                         recognised = true;\n                         match parse_alignment(&value.node) {\n                             Ok(literal) => acc.push(ReprAlign(literal)),\n                             Err(message) => literal_error = Some(message)\n                         };\n                     }\n-                    else if name == \"packed\" {\n+                    else if name == sym::packed {\n                         recognised = true;\n                         match parse_alignment(&value.node) {\n                             Ok(literal) => acc.push(ReprPacked(literal)),\n@@ -790,7 +787,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                     }\n                 } else {\n                     if let Some(meta_item) = item.meta_item() {\n-                        if meta_item.check_name(\"align\") {\n+                        if meta_item.check_name(sym::align) {\n                             if let MetaItemKind::NameValue(ref value) = meta_item.node {\n                                 recognised = true;\n                                 let mut err = struct_span_err!(diagnostic, item.span(), E0693,\n@@ -830,22 +827,22 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n     acc\n }\n \n-fn int_type_of_word(s: &str) -> Option<IntType> {\n+fn int_type_of_word(s: Symbol) -> Option<IntType> {\n     use IntType::*;\n \n     match s {\n-        \"i8\" => Some(SignedInt(ast::IntTy::I8)),\n-        \"u8\" => Some(UnsignedInt(ast::UintTy::U8)),\n-        \"i16\" => Some(SignedInt(ast::IntTy::I16)),\n-        \"u16\" => Some(UnsignedInt(ast::UintTy::U16)),\n-        \"i32\" => Some(SignedInt(ast::IntTy::I32)),\n-        \"u32\" => Some(UnsignedInt(ast::UintTy::U32)),\n-        \"i64\" => Some(SignedInt(ast::IntTy::I64)),\n-        \"u64\" => Some(UnsignedInt(ast::UintTy::U64)),\n-        \"i128\" => Some(SignedInt(ast::IntTy::I128)),\n-        \"u128\" => Some(UnsignedInt(ast::UintTy::U128)),\n-        \"isize\" => Some(SignedInt(ast::IntTy::Isize)),\n-        \"usize\" => Some(UnsignedInt(ast::UintTy::Usize)),\n+        sym::i8 => Some(SignedInt(ast::IntTy::I8)),\n+        sym::u8 => Some(UnsignedInt(ast::UintTy::U8)),\n+        sym::i16 => Some(SignedInt(ast::IntTy::I16)),\n+        sym::u16 => Some(UnsignedInt(ast::UintTy::U16)),\n+        sym::i32 => Some(SignedInt(ast::IntTy::I32)),\n+        sym::u32 => Some(UnsignedInt(ast::UintTy::U32)),\n+        sym::i64 => Some(SignedInt(ast::IntTy::I64)),\n+        sym::u64 => Some(UnsignedInt(ast::UintTy::U64)),\n+        sym::i128 => Some(SignedInt(ast::IntTy::I128)),\n+        sym::u128 => Some(UnsignedInt(ast::UintTy::U128)),\n+        sym::isize => Some(SignedInt(ast::IntTy::Isize)),\n+        sym::usize => Some(UnsignedInt(ast::UintTy::Usize)),\n         _ => None\n     }\n }"}, {"sha": "592b40df1764e36c8fec5a757481480bcbb1b5f2", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 29, "deletions": 112, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -14,15 +14,15 @@ pub use StabilityLevel::*;\n use crate::ast;\n use crate::ast::{AttrId, Attribute, AttrStyle, Name, Ident, Path, PathSegment};\n use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem};\n-use crate::ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind, GenericParam};\n+use crate::ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n-use crate::source_map::{BytePos, Spanned, respan, dummy_spanned};\n+use crate::source_map::{BytePos, Spanned, dummy_spanned};\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::parser::Parser;\n use crate::parse::{self, ParseSess, PResult};\n use crate::parse::token::{self, Token};\n use crate::ptr::P;\n-use crate::symbol::{keywords, LocalInternedString, Symbol};\n+use crate::symbol::{keywords, Symbol, sym};\n use crate::ThinVec;\n use crate::tokenstream::{TokenStream, TokenTree, DelimSpan};\n use crate::GLOBALS;\n@@ -81,19 +81,16 @@ impl NestedMetaItem {\n     }\n \n     /// Returns `true` if this list item is a MetaItem with a name of `name`.\n-    pub fn check_name<T>(&self, name: T) -> bool\n-    where\n-        Path: PartialEq<T>,\n-    {\n+    pub fn check_name(&self, name: Symbol) -> bool {\n         self.meta_item().map_or(false, |meta_item| meta_item.check_name(name))\n     }\n \n     /// For a single-segment meta-item returns its name, otherwise returns `None`.\n     pub fn ident(&self) -> Option<Ident> {\n         self.meta_item().and_then(|meta_item| meta_item.ident())\n     }\n-    pub fn name_or_empty(&self) -> LocalInternedString {\n-        self.ident().unwrap_or(keywords::Invalid.ident()).name.as_str()\n+    pub fn name_or_empty(&self) -> Symbol {\n+        self.ident().unwrap_or(keywords::Invalid.ident()).name\n     }\n \n     /// Gets the string value if self is a MetaItem and the MetaItem is a\n@@ -154,10 +151,7 @@ impl Attribute {\n     /// attribute is marked as used.\n     ///\n     /// To check the attribute name without marking it used, use the `path` field directly.\n-    pub fn check_name<T>(&self, name: T) -> bool\n-    where\n-        Path: PartialEq<T>,\n-    {\n+    pub fn check_name(&self, name: Symbol) -> bool {\n         let matches = self.path == name;\n         if matches {\n             mark_used(self);\n@@ -173,8 +167,8 @@ impl Attribute {\n             None\n         }\n     }\n-    pub fn name_or_empty(&self) -> LocalInternedString {\n-        self.ident().unwrap_or(keywords::Invalid.ident()).name.as_str()\n+    pub fn name_or_empty(&self) -> Symbol {\n+        self.ident().unwrap_or(keywords::Invalid.ident()).name\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n@@ -211,8 +205,8 @@ impl MetaItem {\n             None\n         }\n     }\n-    pub fn name_or_empty(&self) -> LocalInternedString {\n-        self.ident().unwrap_or(keywords::Invalid.ident()).name.as_str()\n+    pub fn name_or_empty(&self) -> Symbol {\n+        self.ident().unwrap_or(keywords::Invalid.ident()).name\n     }\n \n     // #[attribute(name = \"value\")]\n@@ -250,10 +244,7 @@ impl MetaItem {\n         }\n     }\n \n-    pub fn check_name<T>(&self, name: T) -> bool\n-    where\n-        Path: PartialEq<T>,\n-    {\n+    pub fn check_name(&self, name: Symbol) -> bool {\n         self.path == name\n     }\n \n@@ -332,7 +323,7 @@ impl Attribute {\n         if self.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n-                Ident::from_str(\"doc\"),\n+                Ident::with_empty_ctxt(sym::doc),\n                 dummy_spanned(Symbol::intern(&strip_doc_comment_decoration(&comment.as_str()))));\n             let mut attr = if self.style == ast::AttrStyle::Outer {\n                 mk_attr_outer(self.span, self.id, meta)\n@@ -350,12 +341,13 @@ impl Attribute {\n /* Constructors */\n \n pub fn mk_name_value_item_str(ident: Ident, value: Spanned<Symbol>) -> MetaItem {\n-    let value = respan(value.span, LitKind::Str(value.node, ast::StrStyle::Cooked));\n-    mk_name_value_item(ident.span.to(value.span), ident, value)\n+    let lit_kind = LitKind::Str(value.node, ast::StrStyle::Cooked);\n+    mk_name_value_item(ident.span.to(value.span), ident, lit_kind, value.span)\n }\n \n-pub fn mk_name_value_item(span: Span, ident: Ident, value: ast::Lit) -> MetaItem {\n-    MetaItem { path: Path::from_ident(ident), span, node: MetaItemKind::NameValue(value) }\n+pub fn mk_name_value_item(span: Span, ident: Ident, lit_kind: LitKind, lit_span: Span) -> MetaItem {\n+    let lit = Lit::from_lit_kind(lit_kind, lit_span);\n+    MetaItem { path: Path::from_ident(ident), span, node: MetaItemKind::NameValue(lit) }\n }\n \n pub fn mk_list_item(span: Span, ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n@@ -417,39 +409,40 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n \n pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute {\n     let style = doc_comment_style(&text.as_str());\n-    let lit = respan(span, LitKind::Str(text, ast::StrStyle::Cooked));\n+    let lit_kind = LitKind::Str(text, ast::StrStyle::Cooked);\n+    let lit = Lit::from_lit_kind(lit_kind, span);\n     Attribute {\n         id,\n         style,\n-        path: Path::from_ident(Ident::from_str(\"doc\").with_span_pos(span)),\n+        path: Path::from_ident(Ident::with_empty_ctxt(sym::doc).with_span_pos(span)),\n         tokens: MetaItemKind::NameValue(lit).tokens(span),\n         is_sugared_doc: true,\n         span,\n     }\n }\n \n-pub fn list_contains_name(items: &[NestedMetaItem], name: &str) -> bool {\n+pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n     items.iter().any(|item| {\n         item.check_name(name)\n     })\n }\n \n-pub fn contains_name(attrs: &[Attribute], name: &str) -> bool {\n+pub fn contains_name(attrs: &[Attribute], name: Symbol) -> bool {\n     attrs.iter().any(|item| {\n         item.check_name(name)\n     })\n }\n \n-pub fn find_by_name<'a>(attrs: &'a [Attribute], name: &str) -> Option<&'a Attribute> {\n+pub fn find_by_name<'a>(attrs: &'a [Attribute], name: Symbol) -> Option<&'a Attribute> {\n     attrs.iter().find(|attr| attr.check_name(name))\n }\n \n-pub fn filter_by_name<'a>(attrs: &'a [Attribute], name: &'a str)\n+pub fn filter_by_name<'a>(attrs: &'a [Attribute], name: Symbol)\n     -> impl Iterator<Item = &'a Attribute> {\n     attrs.iter().filter(move |attr| attr.check_name(name))\n }\n \n-pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str) -> Option<Symbol> {\n+pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: Symbol) -> Option<Symbol> {\n     attrs.iter()\n         .find(|at| at.check_name(name))\n         .and_then(|at| at.value_str())\n@@ -561,8 +554,7 @@ impl MetaItemKind {\n             Some(TokenTree::Token(_, token::Eq)) => {\n                 tokens.next();\n                 return if let Some(TokenTree::Token(span, token)) = tokens.next() {\n-                    LitKind::from_token(token)\n-                        .map(|lit| MetaItemKind::NameValue(Spanned { node: lit, span: span }))\n+                    Lit::from_token(&token, span, None).map(MetaItemKind::NameValue)\n                 } else {\n                     None\n                 };\n@@ -607,91 +599,16 @@ impl NestedMetaItem {\n         where I: Iterator<Item = TokenTree>,\n     {\n         if let Some(TokenTree::Token(span, token)) = tokens.peek().cloned() {\n-            if let Some(node) = LitKind::from_token(token) {\n+            if let Some(lit) = Lit::from_token(&token, span, None) {\n                 tokens.next();\n-                return Some(NestedMetaItem::Literal(respan(span, node)));\n+                return Some(NestedMetaItem::Literal(lit));\n             }\n         }\n \n         MetaItem::from_tokens(tokens).map(NestedMetaItem::MetaItem)\n     }\n }\n \n-impl Lit {\n-    crate fn tokens(&self) -> TokenStream {\n-        TokenTree::Token(self.span, self.node.token()).into()\n-    }\n-}\n-\n-impl LitKind {\n-    fn token(&self) -> Token {\n-        use std::ascii;\n-\n-        match *self {\n-            LitKind::Str(string, ast::StrStyle::Cooked) => {\n-                let escaped = string.as_str().escape_default().to_string();\n-                Token::Literal(token::Lit::Str_(Symbol::intern(&escaped)), None)\n-            }\n-            LitKind::Str(string, ast::StrStyle::Raw(n)) => {\n-                Token::Literal(token::Lit::StrRaw(string, n), None)\n-            }\n-            LitKind::ByteStr(ref bytes) => {\n-                let string = bytes.iter().cloned().flat_map(ascii::escape_default)\n-                    .map(Into::<char>::into).collect::<String>();\n-                Token::Literal(token::Lit::ByteStr(Symbol::intern(&string)), None)\n-            }\n-            LitKind::Byte(byte) => {\n-                let string: String = ascii::escape_default(byte).map(Into::<char>::into).collect();\n-                Token::Literal(token::Lit::Byte(Symbol::intern(&string)), None)\n-            }\n-            LitKind::Char(ch) => {\n-                let string: String = ch.escape_default().map(Into::<char>::into).collect();\n-                Token::Literal(token::Lit::Char(Symbol::intern(&string)), None)\n-            }\n-            LitKind::Int(n, ty) => {\n-                let suffix = match ty {\n-                    ast::LitIntType::Unsigned(ty) => Some(Symbol::intern(ty.ty_to_string())),\n-                    ast::LitIntType::Signed(ty) => Some(Symbol::intern(ty.ty_to_string())),\n-                    ast::LitIntType::Unsuffixed => None,\n-                };\n-                Token::Literal(token::Lit::Integer(Symbol::intern(&n.to_string())), suffix)\n-            }\n-            LitKind::Float(symbol, ty) => {\n-                Token::Literal(token::Lit::Float(symbol), Some(Symbol::intern(ty.ty_to_string())))\n-            }\n-            LitKind::FloatUnsuffixed(symbol) => Token::Literal(token::Lit::Float(symbol), None),\n-            LitKind::Bool(value) => Token::Ident(Ident::with_empty_ctxt(Symbol::intern(if value {\n-                \"true\"\n-            } else {\n-                \"false\"\n-            })), false),\n-            LitKind::Err(val) => Token::Literal(token::Lit::Err(val), None),\n-        }\n-    }\n-\n-    fn from_token(token: Token) -> Option<LitKind> {\n-        match token {\n-            Token::Ident(ident, false) if ident.name == \"true\" => Some(LitKind::Bool(true)),\n-            Token::Ident(ident, false) if ident.name == \"false\" => Some(LitKind::Bool(false)),\n-            Token::Interpolated(nt) => match *nt {\n-                token::NtExpr(ref v) | token::NtLiteral(ref v) => match v.node {\n-                    ExprKind::Lit(ref lit) => Some(lit.node.clone()),\n-                    _ => None,\n-                },\n-                _ => None,\n-            },\n-            Token::Literal(lit, suf) => {\n-                let (suffix_illegal, result) = parse::lit_token(lit, suf, None);\n-                if suffix_illegal && suf.is_some() {\n-                    return None;\n-                }\n-                result\n-            }\n-            _ => None,\n-        }\n-    }\n-}\n-\n pub trait HasAttrs: Sized {\n     fn attrs(&self) -> &[ast::Attribute];\n     fn visit_attrs<F: FnOnce(&mut Vec<ast::Attribute>)>(&mut self, f: F);"}, {"sha": "c82936afa3d9f0f96d815a36eddb05c326901a2c", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -12,6 +12,7 @@ use crate::edition::Edition;\n use crate::mut_visit::*;\n use crate::parse::{token, ParseSess};\n use crate::ptr::P;\n+use crate::symbol::sym;\n use crate::util::map_in_place::MapInPlace;\n \n use errors::Applicability;\n@@ -90,7 +91,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect.\n     fn process_cfg_attr(&mut self, attr: ast::Attribute) -> Vec<ast::Attribute> {\n-        if !attr.check_name(\"cfg_attr\") {\n+        if !attr.check_name(sym::cfg_attr) {\n             return vec![attr];\n         }\n \n@@ -205,7 +206,7 @@ impl<'a> StripUnconfigured<'a> {\n     pub fn maybe_emit_expr_attr_err(&self, attr: &ast::Attribute) {\n         if !self.features.map(|features| features.stmt_expr_attributes).unwrap_or(true) {\n             let mut err = feature_err(self.sess,\n-                                      \"stmt_expr_attributes\",\n+                                      sym::stmt_expr_attributes,\n                                       attr.span,\n                                       GateIssue::Language,\n                                       EXPLAIN_STMT_ATTR_SYNTAX);\n@@ -285,9 +286,9 @@ impl<'a> StripUnconfigured<'a> {\n     /// See issue #51279.\n     pub fn disallow_cfg_on_generic_param(&mut self, param: &ast::GenericParam) {\n         for attr in param.attrs() {\n-            let offending_attr = if attr.check_name(\"cfg\") {\n+            let offending_attr = if attr.check_name(sym::cfg) {\n                 \"cfg\"\n-            } else if attr.check_name(\"cfg_attr\") {\n+            } else if attr.check_name(sym::cfg_attr) {\n                 \"cfg_attr\"\n             } else {\n                 continue;\n@@ -350,5 +351,5 @@ impl<'a> MutVisitor for StripUnconfigured<'a> {\n }\n \n fn is_cfg(attr: &ast::Attribute) -> bool {\n-    attr.check_name(\"cfg\")\n+    attr.check_name(sym::cfg)\n }"}, {"sha": "c988dc61bec449034082097b18c8ab4e7582a311", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3dd0b50fef21d14591c960a9610bafb224cdbf/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=fe3dd0b50fef21d14591c960a9610bafb224cdbf", "patch": "@@ -7,7 +7,7 @@ use crate::ext::base::{ExtCtxt, MacEager, MacResult};\n use crate::ext::build::AstBuilder;\n use crate::parse::token;\n use crate::ptr::P;\n-use crate::symbol::{keywords, Symbol};\n+use crate::symbol::keywords;\n use crate::tokenstream::{TokenTree};\n \n use smallvec::smallvec;\n@@ -121,13 +121,13 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n \n     let span = span.apply_mark(ecx.current_expansion.mark);\n \n-    let sym = Ident::new(Symbol::gensym(&format!(\"__register_diagnostic_{}\", code)), span);\n+    let name = Ident::from_str_and_span(&format!(\"__register_diagnostic_{}\", code), span).gensym();\n \n     MacEager::items(smallvec![\n         ecx.item_mod(\n             span,\n             span,\n-            sym,\n+            name,\n             vec![],\n             vec![],\n         )"}]}