{"sha": "ef2cbec5a601f7f4414808034c93a8cbbb2066f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMmNiZWM1YTYwMWY3ZjQ0MTQ4MDgwMzRjOTNhOGNiYmIyMDY2Zjc=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-23T17:31:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-23T17:31:50Z"}, "message": "Rollup merge of #55869 - SimonSapin:iterate, r=alexcrichton\n\nAdd std::iter::unfold\n\nThis adds an **unstable** ~`std::iter::iterate`~ `std::iter::unfold` function and ~`std::iter::Iterate`~ `std::iter::Unfold` type that trivially wrap a ~`FnMut() -> Option<T>`~ `FnMut(&mut State) -> Option<T>` closure to create an iterator. ~Iterator state can be kept in the closure\u2019s environment or captures.~\n\nThis is intended to help reduce amount of boilerplate needed when defining an iterator that is only created in one place. Compare the existing example of the `std::iter` module: (explanatory comments elided)\n\n```rust\nstruct Counter {\n    count: usize,\n}\n\nimpl Counter {\n    fn new() -> Counter {\n        Counter { count: 0 }\n    }\n}\n\nimpl Iterator for Counter {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        self.count += 1;\n        if self.count < 6 {\n            Some(self.count)\n        } else {\n            None\n        }\n    }\n}\n```\n\n\u2026 with the same algorithm rewritten to use this new API:\n\n```rust\nfn counter() -> impl Iterator<Item=usize> {\n    std::iter::unfold(0, |count| {\n        *count += 1;\n        if *count < 6 {\n            Some(*count)\n        } else {\n            None\n        }\n    })\n}\n```\n\n-----\n\nThis also add unstable `std::iter::successors` which takes an (optional) initial item and a closure that takes an item and computes the next one (its successor).\n\n```rust\nlet powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\nassert_eq!(powers_of_10.collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n```", "tree": {"sha": "252f1df7df1a39b46056fbde0ad1251291c1e5c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/252f1df7df1a39b46056fbde0ad1251291c1e5c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef2cbec5a601f7f4414808034c93a8cbbb2066f7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb+DmGCRBK7hj4Ov3rIwAAdHIIAItgI/wzJOsNtWh6n+rXscr5\nFDqinqFoQBQuPsaVY7n8OmaeMPCMERzz9FzH8SJr3hrjcsfdGBYwMmxMRSbZoXZR\nOtCahDRnVlomBDpStJYrNjjwdtahli6s872h8Rdku2odoJYN138XPJOSlYjPtJx7\nJHD8skwj99KrftVKSmX0bRnklf6o2wwrnZr8cwO0926QJK2QQwvZlHkNE/a2govJ\nI5Hupr1AGiPuct377t6kGP2FEJR0CZ4xr/Xx6jAOI2E3S1Z4aNRxfM3OYiPQwl6l\nHD9LmSgL1sutr+CPdWXdVPvry5m0BIjD1KG8p7HizQBXzCzNLFKUwG/IXLrAEWE=\n=78e9\n-----END PGP SIGNATURE-----\n", "payload": "tree 252f1df7df1a39b46056fbde0ad1251291c1e5c5\nparent 738afd4f69587791a779e583969034edc569541c\nparent a4279a07e29091fd8a72b13b2109c8969e713ffd\nauthor kennytm <kennytm@gmail.com> 1542994310 +0800\ncommitter GitHub <noreply@github.com> 1542994310 +0800\n\nRollup merge of #55869 - SimonSapin:iterate, r=alexcrichton\n\nAdd std::iter::unfold\n\nThis adds an **unstable** ~`std::iter::iterate`~ `std::iter::unfold` function and ~`std::iter::Iterate`~ `std::iter::Unfold` type that trivially wrap a ~`FnMut() -> Option<T>`~ `FnMut(&mut State) -> Option<T>` closure to create an iterator. ~Iterator state can be kept in the closure\u2019s environment or captures.~\n\nThis is intended to help reduce amount of boilerplate needed when defining an iterator that is only created in one place. Compare the existing example of the `std::iter` module: (explanatory comments elided)\n\n```rust\nstruct Counter {\n    count: usize,\n}\n\nimpl Counter {\n    fn new() -> Counter {\n        Counter { count: 0 }\n    }\n}\n\nimpl Iterator for Counter {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        self.count += 1;\n        if self.count < 6 {\n            Some(self.count)\n        } else {\n            None\n        }\n    }\n}\n```\n\n\u2026 with the same algorithm rewritten to use this new API:\n\n```rust\nfn counter() -> impl Iterator<Item=usize> {\n    std::iter::unfold(0, |count| {\n        *count += 1;\n        if *count < 6 {\n            Some(*count)\n        } else {\n            None\n        }\n    })\n}\n```\n\n-----\n\nThis also add unstable `std::iter::successors` which takes an (optional) initial item and a closure that takes an item and computes the next one (its successor).\n\n```rust\nlet powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\nassert_eq!(powers_of_10.collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef2cbec5a601f7f4414808034c93a8cbbb2066f7", "html_url": "https://github.com/rust-lang/rust/commit/ef2cbec5a601f7f4414808034c93a8cbbb2066f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef2cbec5a601f7f4414808034c93a8cbbb2066f7/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "738afd4f69587791a779e583969034edc569541c", "url": "https://api.github.com/repos/rust-lang/rust/commits/738afd4f69587791a779e583969034edc569541c", "html_url": "https://github.com/rust-lang/rust/commit/738afd4f69587791a779e583969034edc569541c"}, {"sha": "a4279a07e29091fd8a72b13b2109c8969e713ffd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4279a07e29091fd8a72b13b2109c8969e713ffd", "html_url": "https://github.com/rust-lang/rust/commit/a4279a07e29091fd8a72b13b2109c8969e713ffd"}], "stats": {"total": 179, "additions": 177, "deletions": 2}, "files": [{"sha": "62e1f9fcb640c7c59e46b71e90559568b9ea5934", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef2cbec5a601f7f4414808034c93a8cbbb2066f7/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2cbec5a601f7f4414808034c93a8cbbb2066f7/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=ef2cbec5a601f7f4414808034c93a8cbbb2066f7", "patch": "@@ -112,10 +112,10 @@\n //!\n //!     // next() is the only required method\n //!     fn next(&mut self) -> Option<usize> {\n-//!         // increment our count. This is why we started at zero.\n+//!         // Increment our count. This is why we started at zero.\n //!         self.count += 1;\n //!\n-//!         // check to see if we've finished counting or not.\n+//!         // Check to see if we've finished counting or not.\n //!         if self.count < 6 {\n //!             Some(self.count)\n //!         } else {\n@@ -339,6 +339,8 @@ pub use self::sources::{RepeatWith, repeat_with};\n pub use self::sources::{Empty, empty};\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n pub use self::sources::{Once, once};\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+pub use self::sources::{Unfold, unfold, Successors, successors};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::traits::{FromIterator, IntoIterator, DoubleEndedIterator, Extend};"}, {"sha": "f6a4a7a6fa80a36bc617ca6f6ed2430309d085b9", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/ef2cbec5a601f7f4414808034c93a8cbbb2066f7/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2cbec5a601f7f4414808034c93a8cbbb2066f7/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=ef2cbec5a601f7f4414808034c93a8cbbb2066f7", "patch": "@@ -386,3 +386,164 @@ impl<T> FusedIterator for Once<T> {}\n pub fn once<T>(value: T) -> Once<T> {\n     Once { inner: Some(value).into_iter() }\n }\n+\n+/// Creates a new iterator where each iteration calls the provided closure\n+/// `F: FnMut(&mut St) -> Option<T>`.\n+///\n+/// This allows creating a custom iterator with any behavior\n+/// without using the more verbose syntax of creating a dedicated type\n+/// and implementing the `Iterator` trait for it.\n+///\n+/// In addition to its captures and environment,\n+/// the closure is given a mutable reference to some state\n+/// that is preserved across iterations.\n+/// That state starts as the given `initial_state` value.\n+///\n+/// Note that the `Unfold` iterator doesn\u2019t make assumptions about the behavior of the closure,\n+/// and therefore conservatively does not implement [`FusedIterator`],\n+/// or override [`Iterator::size_hint`] from its default `(0, None)`.\n+///\n+/// [`FusedIterator`]: trait.FusedIterator.html\n+/// [`Iterator::size_hint`]: trait.Iterator.html#method.size_hint\n+///\n+/// # Examples\n+///\n+/// Let\u2019s re-implement the counter iterator from [module-level documentation]:\n+///\n+/// [module-level documentation]: index.html\n+///\n+/// ```\n+/// #![feature(iter_unfold)]\n+/// let counter = std::iter::unfold(0, |count| {\n+///     // Increment our count. This is why we started at zero.\n+///     *count += 1;\n+///\n+///     // Check to see if we've finished counting or not.\n+///     if *count < 6 {\n+///         Some(*count)\n+///     } else {\n+///         None\n+///     }\n+/// });\n+/// assert_eq!(counter.collect::<Vec<_>>(), &[1, 2, 3, 4, 5]);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+pub fn unfold<St, T, F>(initial_state: St, f: F) -> Unfold<St, F>\n+    where F: FnMut(&mut St) -> Option<T>\n+{\n+    Unfold {\n+        state: initial_state,\n+        f,\n+    }\n+}\n+\n+/// An iterator where each iteration calls the provided closure `F: FnMut(&mut St) -> Option<T>`.\n+///\n+/// This `struct` is created by the [`unfold`] function.\n+/// See its documentation for more.\n+///\n+/// [`unfold`]: fn.unfold.html\n+#[derive(Clone)]\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+pub struct Unfold<St, F> {\n+    state: St,\n+    f: F,\n+}\n+\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+impl<St, T, F> Iterator for Unfold<St, F>\n+    where F: FnMut(&mut St) -> Option<T>\n+{\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        (self.f)(&mut self.state)\n+    }\n+}\n+\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+impl<St: fmt::Debug, F> fmt::Debug for Unfold<St, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Unfold\")\n+            .field(\"state\", &self.state)\n+            .finish()\n+    }\n+}\n+\n+/// Creates a new iterator where each successive item is computed based on the preceding one.\n+///\n+/// The iterator starts with the given first item (if any)\n+/// and calls the given `FnMut(&T) -> Option<T>` closure to compute each item\u2019s successor.\n+///\n+/// ```\n+/// #![feature(iter_unfold)]\n+/// use std::iter::successors;\n+///\n+/// let powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n+/// assert_eq!(powers_of_10.collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n+/// ```\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+pub fn successors<T, F>(first: Option<T>, succ: F) -> Successors<T, F>\n+    where F: FnMut(&T) -> Option<T>\n+{\n+    // If this function returned `impl Iterator<Item=T>`\n+    // it could be based on `unfold` and not need a dedicated type.\n+    // However having a named `Successors<T, F>` type allows it to be `Clone` when `T` and `F` are.\n+    Successors {\n+        next: first,\n+        succ,\n+    }\n+}\n+\n+/// An new iterator where each successive item is computed based on the preceding one.\n+///\n+/// This `struct` is created by the [`successors`] function.\n+/// See its documentation for more.\n+///\n+/// [`successors`]: fn.successors.html\n+#[derive(Clone)]\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+pub struct Successors<T, F> {\n+    next: Option<T>,\n+    succ: F,\n+}\n+\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+impl<T, F> Iterator for Successors<T, F>\n+    where F: FnMut(&T) -> Option<T>\n+{\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.next.take().map(|item| {\n+            self.next = (self.succ)(&item);\n+            item\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.next.is_some() {\n+            (1, None)\n+        } else {\n+            (0, Some(0))\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+impl<T, F> FusedIterator for Successors<T, F>\n+    where F: FnMut(&T) -> Option<T>\n+{}\n+\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+impl<T: fmt::Debug, F> fmt::Debug for Successors<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Successors\")\n+            .field(\"next\", &self.next)\n+            .finish()\n+    }\n+}"}, {"sha": "495483db5551cc5ff8ff792605e83f59ab8c744a", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef2cbec5a601f7f4414808034c93a8cbbb2066f7/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2cbec5a601f7f4414808034c93a8cbbb2066f7/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=ef2cbec5a601f7f4414808034c93a8cbbb2066f7", "patch": "@@ -1759,6 +1759,17 @@ fn test_repeat_with_take_collect() {\n     assert_eq!(v, vec![1, 2, 4, 8, 16]);\n }\n \n+#[test]\n+fn test_successors() {\n+    let mut powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n+    assert_eq!(powers_of_10.by_ref().collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n+    assert_eq!(powers_of_10.next(), None);\n+\n+    let mut empty = successors(None::<u32>, |_| unimplemented!());\n+    assert_eq!(empty.next(), None);\n+    assert_eq!(empty.next(), None);\n+}\n+\n #[test]\n fn test_fuse() {\n     let mut it = 0..3;"}, {"sha": "7d62b4fa90f203cbb4f6c682cc1a7666194ffa63", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef2cbec5a601f7f4414808034c93a8cbbb2066f7/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2cbec5a601f7f4414808034c93a8cbbb2066f7/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=ef2cbec5a601f7f4414808034c93a8cbbb2066f7", "patch": "@@ -19,6 +19,7 @@\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n #![feature(hashmap_internals)]\n+#![feature(iter_unfold)]\n #![feature(pattern)]\n #![feature(range_is_empty)]\n #![feature(raw)]"}]}