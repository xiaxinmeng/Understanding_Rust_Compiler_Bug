{"sha": "775b64c955b9b61117c7bb8acf489e0311d8351b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3NWI2NGM5NTViOWI2MTExN2M3YmI4YWNmNDg5ZTAzMTFkODM1MWI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-31T23:45:52Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-01T19:14:31Z"}, "message": "Remove the estr #fmt. Issue #855", "tree": {"sha": "a09209192df5eac14d564806e7ac049f6a69ac89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a09209192df5eac14d564806e7ac049f6a69ac89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/775b64c955b9b61117c7bb8acf489e0311d8351b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/775b64c955b9b61117c7bb8acf489e0311d8351b", "html_url": "https://github.com/rust-lang/rust/commit/775b64c955b9b61117c7bb8acf489e0311d8351b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/775b64c955b9b61117c7bb8acf489e0311d8351b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a45068cf2760c886ce439ba26d0769b635fb3e57", "url": "https://api.github.com/repos/rust-lang/rust/commits/a45068cf2760c886ce439ba26d0769b635fb3e57", "html_url": "https://github.com/rust-lang/rust/commit/a45068cf2760c886ce439ba26d0769b635fb3e57"}], "stats": {"total": 795, "additions": 0, "deletions": 795}, "files": [{"sha": "4a3a42e289b5a879b5a35ad3cdb6bd5e934f23cf", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/775b64c955b9b61117c7bb8acf489e0311d8351b/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/775b64c955b9b61117c7bb8acf489e0311d8351b/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=775b64c955b9b61117c7bb8acf489e0311d8351b", "patch": "@@ -63,7 +63,6 @@ mod syntax {\n         mod base;\n         mod expand;\n \n-        mod fmt;\n         mod ifmt;\n         mod env;\n         mod simplext;"}, {"sha": "051c667e38fbc6b9cd90e1c2a24da3336c3f0348", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/775b64c955b9b61117c7bb8acf489e0311d8351b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/775b64c955b9b61117c7bb8acf489e0311d8351b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=775b64c955b9b61117c7bb8acf489e0311d8351b", "patch": "@@ -22,7 +22,6 @@ tag syntax_extension {\n // AST nodes into full ASTs\n fn syntax_expander_table() -> hashmap<istr, syntax_extension> {\n     let syntax_expanders = new_str_hash::<syntax_extension>();\n-    syntax_expanders.insert(~\"fmt\", normal(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(~\"ifmt\", normal(ext::ifmt::expand_syntax_ext));\n     syntax_expanders.insert(~\"env\", normal(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(~\"macro\","}, {"sha": "59bc277c7417549975b195dde6843e32664839ef", "filename": "src/comp/syntax/ext/fmt.rs", "status": "removed", "additions": 0, "deletions": 364, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/a45068cf2760c886ce439ba26d0769b635fb3e57/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45068cf2760c886ce439ba26d0769b635fb3e57/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=a45068cf2760c886ce439ba26d0769b635fb3e57", "patch": "@@ -1,364 +0,0 @@\n-\n-\n-/*\n- * The compiler code necessary to support the #ifmt extension. Eventually this\n- * should all get sucked into either the standard library extfmt module or the\n- * compiler syntax extension plugin interface.\n- */\n-import std::vec;\n-import std::str;\n-import std::istr;\n-import std::option;\n-import std::option::none;\n-import std::option::some;\n-import std::extfmt::ct::*;\n-import base::*;\n-import codemap::span;\n-export expand_syntax_ext;\n-\n-fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n-                     _body: &option::t<istr>) -> @ast::expr {\n-    let args: [@ast::expr] =\n-        alt arg.node {\n-          ast::expr_vec(elts, _) { elts }\n-          _ {\n-            cx.span_fatal(\n-                sp, ~\"#ifmt requires arguments of the form `[...]`.\")\n-          }\n-        };\n-    if vec::len::<@ast::expr>(args) == 0u {\n-        cx.span_fatal(sp, ~\"#ifmt requires a format string\");\n-    }\n-    let fmt =\n-        expr_to_str(cx, args[0],\n-                    ~\"first argument to #ifmt must be a \"\n-                    + ~\"string literal.\");\n-    let fmtspan = args[0].span;\n-    log \"Format string:\";\n-    log fmt;\n-    fn parse_fmt_err_(cx: &ext_ctxt, sp: span, msg: str) -> ! {\n-        cx.span_fatal(sp, istr::from_estr(msg));\n-    }\n-    let parse_fmt_err = bind parse_fmt_err_(cx, fmtspan, _);\n-    let pieces = parse_fmt_string(istr::to_estr(fmt), parse_fmt_err);\n-    ret pieces_to_expr(cx, sp, pieces, args);\n-}\n-\n-// FIXME: A lot of these functions for producing expressions can probably\n-// be factored out in common with other code that builds expressions.\n-// FIXME: Cleanup the naming of these functions\n-fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n-                  args: &[@ast::expr]) -> @ast::expr {\n-    fn make_new_lit(cx: &ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n-        let sp_lit = @{node: lit, span: sp};\n-        ret @{id: cx.next_id(), node: ast::expr_lit(sp_lit), span: sp};\n-    }\n-    fn make_new_str(cx: &ext_ctxt, sp: span, s: &istr) -> @ast::expr {\n-        let lit = ast::lit_str(s, ast::sk_rc);\n-        ret make_new_lit(cx, sp, lit);\n-    }\n-    fn make_new_int(cx: &ext_ctxt, sp: span, i: int) -> @ast::expr {\n-        let lit = ast::lit_int(i);\n-        ret make_new_lit(cx, sp, lit);\n-    }\n-    fn make_new_uint(cx: &ext_ctxt, sp: span, u: uint) -> @ast::expr {\n-        let lit = ast::lit_uint(u);\n-        ret make_new_lit(cx, sp, lit);\n-    }\n-    fn make_add_expr(cx: &ext_ctxt, sp: span, lhs: @ast::expr,\n-                     rhs: @ast::expr) -> @ast::expr {\n-        let binexpr = ast::expr_binary(ast::add, lhs, rhs);\n-        ret @{id: cx.next_id(), node: binexpr, span: sp};\n-    }\n-    fn make_path_expr(cx: &ext_ctxt, sp: span, idents: &[ast::ident]) ->\n-       @ast::expr {\n-        let path = {global: false, idents: idents, types: []};\n-        let sp_path = {node: path, span: sp};\n-        let pathexpr = ast::expr_path(sp_path);\n-        ret @{id: cx.next_id(), node: pathexpr, span: sp};\n-    }\n-    fn make_vec_expr(cx: &ext_ctxt, sp: span, exprs: &[@ast::expr]) ->\n-       @ast::expr {\n-        let vecexpr = ast::expr_vec(exprs, ast::imm);\n-        ret @{id: cx.next_id(), node: vecexpr, span: sp};\n-    }\n-    fn make_call(cx: &ext_ctxt, sp: span, fn_path: &[ast::ident],\n-                 args: &[@ast::expr]) -> @ast::expr {\n-        let pathexpr = make_path_expr(cx, sp, fn_path);\n-        let callexpr = ast::expr_call(pathexpr, args);\n-        ret @{id: cx.next_id(), node: callexpr, span: sp};\n-    }\n-    fn make_rec_expr(cx: &ext_ctxt, sp: span,\n-                     fields: &[{ident: ast::ident, ex: @ast::expr}]) ->\n-       @ast::expr {\n-        let astfields: [ast::field] = [];\n-        for field: {ident: ast::ident, ex: @ast::expr} in fields {\n-            let ident = field.ident;\n-            let val = field.ex;\n-            let astfield =\n-                {node: {mut: ast::imm, ident: ident, expr: val}, span: sp};\n-            astfields += [astfield];\n-        }\n-        let recexpr = ast::expr_rec(astfields, option::none::<@ast::expr>);\n-        ret @{id: cx.next_id(), node: recexpr, span: sp};\n-    }\n-    fn make_path_vec(cx: &ext_ctxt, ident: &ast::ident) -> [ast::ident] {\n-        fn compiling_std(cx: &ext_ctxt) -> bool {\n-            ret istr::find(cx.crate_file_name(), ~\"std.rc\") >= 0;\n-        }\n-        if compiling_std(cx) {\n-            ret [~\"extfmt\", ~\"rt\", ident];\n-        } else { ret [~\"std\", ~\"extfmt\", ~\"rt\", ident]; }\n-    }\n-    fn make_rt_path_expr(cx: &ext_ctxt, sp: span,\n-                         ident: &istr) -> @ast::expr {\n-        let path = make_path_vec(cx, ident);\n-        ret make_path_expr(cx, sp, path);\n-    }\n-    // Produces an AST expression that represents a RT::conv record,\n-    // which tells the RT::conv* functions how to perform the conversion\n-\n-    fn make_rt_conv_expr(cx: &ext_ctxt, sp: span, cnv: &conv) -> @ast::expr {\n-        fn make_flags(cx: &ext_ctxt, sp: span, flags: &[flag]) -> @ast::expr {\n-            let flagexprs: [@ast::expr] = [];\n-            for f: flag in flags {\n-                let fstr;\n-                alt f {\n-                  flag_left_justify. { fstr = ~\"flag_left_justify\"; }\n-                  flag_left_zero_pad. { fstr = ~\"flag_left_zero_pad\"; }\n-                  flag_space_for_sign. { fstr = ~\"flag_space_for_sign\"; }\n-                  flag_sign_always. { fstr = ~\"flag_sign_always\"; }\n-                  flag_alternate. { fstr = ~\"flag_alternate\"; }\n-                }\n-                flagexprs += [make_rt_path_expr(cx, sp, fstr)];\n-            }\n-            // FIXME: 0-length vectors can't have their type inferred\n-            // through the rec that these flags are a member of, so\n-            // this is a hack placeholder flag\n-\n-            if vec::len::<@ast::expr>(flagexprs) == 0u {\n-                flagexprs += [make_rt_path_expr(cx, sp, ~\"flag_none\")];\n-            }\n-            ret make_vec_expr(cx, sp, flagexprs);\n-        }\n-        fn make_count(cx: &ext_ctxt, sp: span, cnt: &count) -> @ast::expr {\n-            alt cnt {\n-              count_implied. {\n-                ret make_rt_path_expr(cx, sp, ~\"count_implied\");\n-              }\n-              count_is(c) {\n-                let count_lit = make_new_int(cx, sp, c);\n-                let count_is_path = make_path_vec(cx, ~\"count_is\");\n-                let count_is_args = [count_lit];\n-                ret make_call(cx, sp, count_is_path, count_is_args);\n-              }\n-              _ { cx.span_unimpl(sp, ~\"unimplemented #ifmt conversion\"); }\n-            }\n-        }\n-        fn make_ty(cx: &ext_ctxt, sp: span, t: &ty) -> @ast::expr {\n-            let rt_type;\n-            alt t {\n-              ty_hex(c) {\n-                alt c {\n-                  case_upper. { rt_type = ~\"ty_hex_upper\"; }\n-                  case_lower. { rt_type = ~\"ty_hex_lower\"; }\n-                }\n-              }\n-              ty_bits. { rt_type = ~\"ty_bits\"; }\n-              ty_octal. { rt_type = ~\"ty_octal\"; }\n-              _ { rt_type = ~\"ty_default\"; }\n-            }\n-            ret make_rt_path_expr(cx, sp, rt_type);\n-        }\n-        fn make_conv_rec(cx: &ext_ctxt, sp: span, flags_expr: @ast::expr,\n-                         width_expr: @ast::expr, precision_expr: @ast::expr,\n-                         ty_expr: @ast::expr) -> @ast::expr {\n-            ret make_rec_expr(cx, sp,\n-                              [{ident: ~\"flags\", ex: flags_expr},\n-                               {ident: ~\"width\", ex: width_expr},\n-                               {ident: ~\"precision\", ex: precision_expr},\n-                               {ident: ~\"ty\", ex: ty_expr}]);\n-        }\n-        let rt_conv_flags = make_flags(cx, sp, cnv.flags);\n-        let rt_conv_width = make_count(cx, sp, cnv.width);\n-        let rt_conv_precision = make_count(cx, sp, cnv.precision);\n-        let rt_conv_ty = make_ty(cx, sp, cnv.ty);\n-        ret make_conv_rec(cx, sp, rt_conv_flags, rt_conv_width,\n-                          rt_conv_precision, rt_conv_ty);\n-    }\n-    fn make_conv_call(cx: &ext_ctxt, sp: span, conv_type: &istr,\n-                      cnv: &conv, arg: @ast::expr) -> @ast::expr {\n-        let fname = ~\"conv_\" + conv_type;\n-        let path = make_path_vec(cx, fname);\n-        let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n-        let args = [cnv_expr, arg];\n-        ret make_call(cx, arg.span, path, args);\n-    }\n-    fn make_new_conv(cx: &ext_ctxt, sp: span, cnv: conv, arg: @ast::expr) ->\n-       @ast::expr {\n-        // FIXME: Extract all this validation into extfmt::ct\n-\n-        fn is_signed_type(cnv: conv) -> bool {\n-            alt cnv.ty {\n-              ty_int(s) {\n-                alt s { signed. { ret true; } unsigned. { ret false; } }\n-              }\n-              _ { ret false; }\n-            }\n-        }\n-        let unsupported = ~\"conversion not supported in #ifmt string\";\n-        alt cnv.param {\n-          option::none. { }\n-          _ { cx.span_unimpl(sp, unsupported); }\n-        }\n-        for f: flag in cnv.flags {\n-            alt f {\n-              flag_left_justify. { }\n-              flag_sign_always. {\n-                if !is_signed_type(cnv) {\n-                    cx.span_fatal(sp,\n-                                  ~\"+ flag only valid in \" +\n-                                      ~\"signed #ifmt conversion\");\n-                }\n-              }\n-              flag_space_for_sign. {\n-                if !is_signed_type(cnv) {\n-                    cx.span_fatal(sp,\n-                                  ~\"space flag only valid in \" +\n-                                      ~\"signed #ifmt conversions\");\n-                }\n-              }\n-              flag_left_zero_pad. { }\n-              _ { cx.span_unimpl(sp, unsupported); }\n-            }\n-        }\n-        alt cnv.width {\n-          count_implied. { }\n-          count_is(_) { }\n-          _ { cx.span_unimpl(sp, unsupported); }\n-        }\n-        alt cnv.precision {\n-          count_implied. { }\n-          count_is(_) { }\n-          _ { cx.span_unimpl(sp, unsupported); }\n-        }\n-        alt cnv.ty {\n-          ty_str. { ret make_conv_call(cx, arg.span, ~\"str\", cnv, arg); }\n-          ty_int(sign) {\n-            alt sign {\n-              signed. { ret make_conv_call(cx, arg.span, ~\"int\", cnv, arg); }\n-              unsigned. {\n-                ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg);\n-              }\n-            }\n-          }\n-          ty_bool. { ret make_conv_call(cx, arg.span, ~\"bool\", cnv, arg); }\n-          ty_char. { ret make_conv_call(cx, arg.span, ~\"char\", cnv, arg); }\n-          ty_hex(_) { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n-          ty_bits. { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n-          ty_octal. { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n-          _ { cx.span_unimpl(sp, unsupported); }\n-        }\n-    }\n-    fn log_conv(c: conv) {\n-        alt c.param {\n-          some(p) {\n-            log \"param: \"\n-                + istr::to_estr(std::int::to_str(p, 10u));\n-          }\n-          _ { log \"param: none\"; }\n-        }\n-        for f: flag in c.flags {\n-            alt f {\n-              flag_left_justify. { log \"flag: left justify\"; }\n-              flag_left_zero_pad. { log \"flag: left zero pad\"; }\n-              flag_space_for_sign. { log \"flag: left space pad\"; }\n-              flag_sign_always. { log \"flag: sign always\"; }\n-              flag_alternate. { log \"flag: alternate\"; }\n-            }\n-        }\n-        alt c.width {\n-          count_is(i) { log \"width: count is \"\n-              + istr::to_estr(std::int::to_str(i, 10u)); }\n-          count_is_param(i) {\n-            log \"width: count is param \"\n-                + istr::to_estr(std::int::to_str(i, 10u));\n-          }\n-          count_is_next_param. { log \"width: count is next param\"; }\n-          count_implied. { log \"width: count is implied\"; }\n-        }\n-        alt c.precision {\n-          count_is(i) { log \"prec: count is \"\n-              + istr::to_estr(std::int::to_str(i, 10u)); }\n-          count_is_param(i) {\n-            log \"prec: count is param \"\n-                + istr::to_estr(std::int::to_str(i, 10u));\n-          }\n-          count_is_next_param. { log \"prec: count is next param\"; }\n-          count_implied. { log \"prec: count is implied\"; }\n-        }\n-        alt c.ty {\n-          ty_bool. { log \"type: bool\"; }\n-          ty_str. { log \"type: str\"; }\n-          ty_char. { log \"type: char\"; }\n-          ty_int(s) {\n-            alt s {\n-              signed. { log \"type: signed\"; }\n-              unsigned. { log \"type: unsigned\"; }\n-            }\n-          }\n-          ty_bits. { log \"type: bits\"; }\n-          ty_hex(cs) {\n-            alt cs {\n-              case_upper. { log \"type: uhex\"; }\n-              case_lower. { log \"type: lhex\"; }\n-            }\n-          }\n-          ty_octal. { log \"type: octal\"; }\n-        }\n-    }\n-    let fmt_sp = args[0].span;\n-    let n = 0u;\n-    let tmp_expr = make_new_str(cx, sp, ~\"\");\n-    let nargs = vec::len::<@ast::expr>(args);\n-    for pc: piece in pieces {\n-        alt pc {\n-          piece_string(s) {\n-            let s_expr = make_new_str(cx, fmt_sp, istr::from_estr(s));\n-            tmp_expr = make_add_expr(cx, fmt_sp, tmp_expr, s_expr);\n-          }\n-          piece_conv(conv) {\n-            n += 1u;\n-            if n >= nargs {\n-                cx.span_fatal(sp,\n-                              ~\"not enough arguments to #ifmt \" +\n-                                  ~\"for the given format string\");\n-            }\n-            log \"Building conversion:\";\n-            log_conv(conv);\n-            let arg_expr = args[n];\n-            let c_expr = make_new_conv(cx, fmt_sp, conv, arg_expr);\n-            tmp_expr = make_add_expr(cx, fmt_sp, tmp_expr, c_expr);\n-          }\n-        }\n-    }\n-    let expected_nargs = n + 1u; // n conversions + the fmt string\n-\n-    if expected_nargs < nargs {\n-        cx.span_fatal(\n-            sp,\n-            #ifmt[\"too many arguments to #fmt. found %u, expected %u\",\n-                 nargs, expected_nargs]);\n-    }\n-    ret tmp_expr;\n-}\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//"}, {"sha": "c66ab2ad5e0790c3cd34610f9f6a3449553b2a15", "filename": "src/lib/extfmt.rs", "status": "removed", "additions": 0, "deletions": 428, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/a45068cf2760c886ce439ba26d0769b635fb3e57/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45068cf2760c886ce439ba26d0769b635fb3e57/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=a45068cf2760c886ce439ba26d0769b635fb3e57", "patch": "@@ -1,428 +0,0 @@\n-\n-\n-/* The 'fmt' extension is modeled on the posix printf system.\n- *\n- * A posix conversion ostensibly looks like this:\n- *\n- * %[parameter][flags][width][.precision][length]type\n- *\n- * Given the different numeric type bestiary we have, we omit the 'length'\n- * parameter and support slightly different conversions for 'type':\n- *\n- * %[parameter][flags][width][.precision]type\n- *\n- * we also only support translating-to-rust a tiny subset of the possible\n- * combinations at the moment.\n- */\n-import option::none;\n-import option::some;\n-\n-\n-/*\n- * We have a 'ct' (compile-time) module that parses format strings into a\n- * sequence of conversions. From those conversions AST fragments are built\n- * that call into properly-typed functions in the 'rt' (run-time) module.\n- * Each of those run-time conversion functions accepts another conversion\n- * description that specifies how to format its output.\n- *\n- * The building of the AST is currently done in a module inside the compiler,\n- * but should migrate over here as the plugin interface is defined.\n- */\n-\n-// Functions used by the fmt extension at compile time\n-mod ct {\n-    tag signedness { signed; unsigned; }\n-    tag caseness { case_upper; case_lower; }\n-    tag ty {\n-        ty_bool;\n-        ty_str;\n-        ty_char;\n-        ty_int(signedness);\n-        ty_bits;\n-        ty_hex(caseness);\n-        ty_octal;\n-        // FIXME: More types\n-    }\n-    tag flag {\n-        flag_left_justify;\n-        flag_left_zero_pad;\n-        flag_space_for_sign;\n-        flag_sign_always;\n-        flag_alternate;\n-    }\n-    tag count {\n-        count_is(int);\n-        count_is_param(int);\n-        count_is_next_param;\n-        count_implied;\n-    }\n-\n-    // A formatted conversion from an expression to a string\n-    type conv =\n-        {param: option::t<int>,\n-         flags: [flag],\n-         width: count,\n-         precision: count,\n-         ty: ty};\n-\n-\n-    // A fragment of the output sequence\n-    tag piece { piece_string(str); piece_conv(conv); }\n-    type error_fn = fn(str) -> ! ;\n-\n-    fn parse_fmt_string(s: str, error: error_fn) -> [piece] {\n-        let pieces: [piece] = [];\n-        let lim = str::byte_len(s);\n-        let buf = \"\";\n-        fn flush_buf(buf: str, pieces: &mutable [piece]) -> str {\n-            if str::byte_len(buf) > 0u {\n-                let piece = piece_string(buf);\n-                pieces += [piece];\n-            }\n-            ret \"\";\n-        }\n-        let i = 0u;\n-        while i < lim {\n-            let curr = str::substr(s, i, 1u);\n-            if str::eq(curr, \"%\") {\n-                i += 1u;\n-                if i >= lim {\n-                    error(\"unterminated conversion at end of string\");\n-                }\n-                let curr2 = str::substr(s, i, 1u);\n-                if str::eq(curr2, \"%\") {\n-                    i += 1u;\n-                } else {\n-                    buf = flush_buf(buf, pieces);\n-                    let rs = parse_conversion(s, i, lim, error);\n-                    pieces += [rs.piece];\n-                    i = rs.next;\n-                }\n-            } else { buf += curr; i += 1u; }\n-        }\n-        buf = flush_buf(buf, pieces);\n-        ret pieces;\n-    }\n-    fn peek_num(s: str, i: uint, lim: uint) ->\n-       option::t<{num: uint, next: uint}> {\n-        if i >= lim { ret none; }\n-        let c = s[i];\n-        if !('0' as u8 <= c && c <= '9' as u8) { ret option::none; }\n-        let n = c - ('0' as u8) as uint;\n-        ret alt peek_num(s, i + 1u, lim) {\n-              none. { some({num: n, next: i + 1u}) }\n-              some(next) {\n-                let m = next.num;\n-                let j = next.next;\n-                some({num: n * 10u + m, next: j})\n-              }\n-            };\n-    }\n-    fn parse_conversion(s: str, i: uint, lim: uint, error: error_fn) ->\n-       {piece: piece, next: uint} {\n-        let parm = parse_parameter(s, i, lim);\n-        let flags = parse_flags(s, parm.next, lim);\n-        let width = parse_count(s, flags.next, lim);\n-        let prec = parse_precision(s, width.next, lim);\n-        let ty = parse_type(s, prec.next, lim, error);\n-        ret {piece:\n-                 piece_conv({param: parm.param,\n-                             flags: flags.flags,\n-                             width: width.count,\n-                             precision: prec.count,\n-                             ty: ty.ty}),\n-             next: ty.next};\n-    }\n-    fn parse_parameter(s: str, i: uint, lim: uint) ->\n-       {param: option::t<int>, next: uint} {\n-        if i >= lim { ret {param: none, next: i}; }\n-        let num = peek_num(s, i, lim);\n-        ret alt num {\n-              none. { {param: none, next: i} }\n-              some(t) {\n-                let n = t.num;\n-                let j = t.next;\n-                if j < lim && s[j] == '$' as u8 {\n-                    {param: some(n as int), next: j + 1u}\n-                } else { {param: none, next: i} }\n-              }\n-            };\n-    }\n-    fn parse_flags(s: str, i: uint, lim: uint) ->\n-       {flags: [flag], next: uint} {\n-        let noflags: [flag] = [];\n-        if i >= lim { ret {flags: noflags, next: i}; }\n-\n-        // FIXME: This recursion generates illegal instructions if the return\n-        // value isn't boxed. Only started happening after the ivec conversion\n-        fn more_(f: flag, s: str, i: uint, lim: uint) ->\n-           @{flags: [flag], next: uint} {\n-            let next = parse_flags(s, i + 1u, lim);\n-            let rest = next.flags;\n-            let j = next.next;\n-            let curr: [flag] = [f];\n-            ret @{flags: curr + rest, next: j};\n-        }\n-        let more = bind more_(_, s, i, lim);\n-        let f = s[i];\n-        ret if f == '-' as u8 {\n-                *more(flag_left_justify)\n-            } else if f == '0' as u8 {\n-                *more(flag_left_zero_pad)\n-            } else if f == ' ' as u8 {\n-                *more(flag_space_for_sign)\n-            } else if f == '+' as u8 {\n-                *more(flag_sign_always)\n-            } else if f == '#' as u8 {\n-                *more(flag_alternate)\n-            } else { {flags: noflags, next: i} };\n-    }\n-    fn parse_count(s: str, i: uint, lim: uint) -> {count: count, next: uint} {\n-        ret if i >= lim {\n-                {count: count_implied, next: i}\n-            } else if s[i] == '*' as u8 {\n-                let param = parse_parameter(s, i + 1u, lim);\n-                let j = param.next;\n-                alt param.param {\n-                  none. { {count: count_is_next_param, next: j} }\n-                  some(n) { {count: count_is_param(n), next: j} }\n-                }\n-            } else {\n-                let num = peek_num(s, i, lim);\n-                alt num {\n-                  none. { {count: count_implied, next: i} }\n-                  some(num) {\n-                    {count: count_is(num.num as int), next: num.next}\n-                  }\n-                }\n-            };\n-    }\n-    fn parse_precision(s: str, i: uint, lim: uint) ->\n-       {count: count, next: uint} {\n-        ret if i >= lim {\n-                {count: count_implied, next: i}\n-            } else if s[i] == '.' as u8 {\n-                let count = parse_count(s, i + 1u, lim);\n-\n-\n-                // If there were no digits specified, i.e. the precision\n-                // was \".\", then the precision is 0\n-                alt count.count {\n-                  count_implied. { {count: count_is(0), next: count.next} }\n-                  _ { count }\n-                }\n-            } else { {count: count_implied, next: i} };\n-    }\n-    fn parse_type(s: str, i: uint, lim: uint, error: error_fn) ->\n-       {ty: ty, next: uint} {\n-        if i >= lim { error(\"missing type in conversion\"); }\n-        let tstr = str::substr(s, i, 1u);\n-        // TODO: Do we really want two signed types here?\n-        // How important is it to be printf compatible?\n-        let t =\n-            if str::eq(tstr, \"b\") {\n-                ty_bool\n-            } else if str::eq(tstr, \"s\") {\n-                ty_str\n-            } else if str::eq(tstr, \"c\") {\n-                ty_char\n-            } else if str::eq(tstr, \"d\") || str::eq(tstr, \"i\") {\n-                ty_int(signed)\n-            } else if str::eq(tstr, \"u\") {\n-                ty_int(unsigned)\n-            } else if str::eq(tstr, \"x\") {\n-                ty_hex(case_lower)\n-            } else if str::eq(tstr, \"X\") {\n-                ty_hex(case_upper)\n-            } else if str::eq(tstr, \"t\") {\n-                ty_bits\n-            } else if str::eq(tstr, \"o\") {\n-                ty_octal\n-            } else { error(\"unknown type in conversion: \" + tstr) };\n-        ret {ty: t, next: i + 1u};\n-    }\n-}\n-\n-\n-// Functions used by the fmt extension at runtime. For now there are a lot of\n-// decisions made a runtime. If it proves worthwhile then some of these\n-// conditions can be evaluated at compile-time. For now though it's cleaner to\n-// implement it this way, I think.\n-mod rt {\n-    tag flag {\n-        flag_left_justify;\n-        flag_left_zero_pad;\n-        flag_space_for_sign;\n-        flag_sign_always;\n-        flag_alternate;\n-\n-\n-        // FIXME: This is a hack to avoid creating 0-length vec exprs,\n-        // which have some difficulty typechecking currently. See\n-        // comments in front::extfmt::make_flags\n-        flag_none;\n-    }\n-    tag count { count_is(int); count_implied; }\n-    tag ty { ty_default; ty_bits; ty_hex_upper; ty_hex_lower; ty_octal; }\n-\n-    // FIXME: May not want to use a vector here for flags;\n-    // instead just use a bool per flag\n-    type conv = {flags: [flag], width: count, precision: count, ty: ty};\n-\n-    fn conv_int(cv: &conv, i: int) -> str {\n-        let radix = 10u;\n-        let prec = get_int_precision(cv);\n-        let s = int_to_str_prec(i, radix, prec);\n-        if 0 <= i {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                s = \"+\" + s;\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                s = \" \" + s;\n-            }\n-        }\n-        ret pad(cv, s, pad_signed);\n-    }\n-    fn conv_uint(cv: &conv, u: uint) -> str {\n-        let prec = get_int_precision(cv);\n-        let rs =\n-            alt cv.ty {\n-              ty_default. { uint_to_str_prec(u, 10u, prec) }\n-              ty_hex_lower. { uint_to_str_prec(u, 16u, prec) }\n-              ty_hex_upper. { str::to_upper(uint_to_str_prec(u, 16u, prec)) }\n-              ty_bits. { uint_to_str_prec(u, 2u, prec) }\n-              ty_octal. { uint_to_str_prec(u, 8u, prec) }\n-            };\n-        ret pad(cv, rs, pad_unsigned);\n-    }\n-    fn conv_bool(cv: &conv, b: bool) -> str {\n-        let s = if b { \"true\" } else { \"false\" };\n-        // run the boolean conversion through the string conversion logic,\n-        // giving it the same rules for precision, etc.\n-\n-        ret conv_str(cv, s);\n-    }\n-    fn conv_char(cv: &conv, c: char) -> str {\n-        ret pad(cv, str::from_char(c), pad_nozero);\n-    }\n-    fn conv_str(cv: &conv, s: str) -> str {\n-        // For strings, precision is the maximum characters\n-        // displayed\n-\n-        // FIXME: substr works on bytes, not chars!\n-        let unpadded =\n-            alt cv.precision {\n-              count_implied. { s }\n-              count_is(max) {\n-                if max as uint < str::char_len(s) {\n-                    str::substr(s, 0u, max as uint)\n-                } else { s }\n-              }\n-            };\n-        ret pad(cv, unpadded, pad_nozero);\n-    }\n-\n-    // Convert an int to string with minimum number of digits. If precision is\n-    // 0 and num is 0 then the result is the empty string.\n-    fn int_to_str_prec(num: int, radix: uint, prec: uint) -> str {\n-        ret if num < 0 {\n-                \"-\" + uint_to_str_prec(-num as uint, radix, prec)\n-            } else { uint_to_str_prec(num as uint, radix, prec) };\n-    }\n-\n-    // Convert a uint to string with a minimum number of digits.  If precision\n-    // is 0 and num is 0 then the result is the empty string. Could move this\n-    // to uint: but it doesn't seem all that useful.\n-    fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> str {\n-        ret if prec == 0u && num == 0u {\n-                \"\"\n-            } else {\n-                let s = istr::to_estr(uint::to_str(num, radix));\n-                let len = str::char_len(s);\n-                if len < prec {\n-                    let diff = prec - len;\n-                    let pad = str_init_elt('0', diff);\n-                    pad + s\n-                } else { s }\n-            };\n-    }\n-    fn get_int_precision(cv: &conv) -> uint {\n-        ret alt cv.precision {\n-              count_is(c) { c as uint }\n-              count_implied. { 1u }\n-            };\n-    }\n-\n-    // FIXME: This might be useful in str: but needs to be utf8 safe first\n-    fn str_init_elt(c: char, n_elts: uint) -> str {\n-        let svec = vec::init_elt::<u8>(c as u8, n_elts);\n-\n-        ret str::unsafe_from_bytes(svec);\n-    }\n-    tag pad_mode { pad_signed; pad_unsigned; pad_nozero; }\n-    fn pad(cv: &conv, s: str, mode: pad_mode) -> str {\n-        let uwidth;\n-        alt cv.width {\n-          count_implied. { ret s; }\n-          count_is(width) {\n-            // FIXME: Maybe width should be uint\n-\n-            uwidth = width as uint;\n-          }\n-        }\n-        let strlen = str::char_len(s);\n-        if uwidth <= strlen { ret s; }\n-        let padchar = ' ';\n-        let diff = uwidth - strlen;\n-        if have_flag(cv.flags, flag_left_justify) {\n-            let padstr = str_init_elt(padchar, diff);\n-            ret s + padstr;\n-        }\n-        let might_zero_pad = false;\n-        let signed = false;\n-        alt mode {\n-          pad_nozero. {\n-            // fallthrough\n-\n-          }\n-          pad_signed. { might_zero_pad = true; signed = true; }\n-          pad_unsigned. { might_zero_pad = true; }\n-        }\n-        fn have_precision(cv: &conv) -> bool {\n-            ret alt cv.precision { count_implied. { false } _ { true } };\n-        }\n-        let zero_padding = false;\n-        if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n-               !have_precision(cv) {\n-            padchar = '0';\n-            zero_padding = true;\n-        }\n-        let padstr = str_init_elt(padchar, diff);\n-        // This is completely heinous. If we have a signed value then\n-        // potentially rip apart the intermediate result and insert some\n-        // zeros. It may make sense to convert zero padding to a precision\n-        // instead.\n-\n-        if signed && zero_padding && str::byte_len(s) > 0u {\n-            let head = s[0];\n-            if head == '+' as u8 || head == '-' as u8 || head == ' ' as u8 {\n-                let headstr = str::unsafe_from_bytes([head]);\n-                let bytelen = str::byte_len(s);\n-                let numpart = str::substr(s, 1u, bytelen - 1u);\n-                ret headstr + padstr + numpart;\n-            }\n-        }\n-        ret padstr + s;\n-    }\n-    fn have_flag(flags: &[flag], f: flag) -> bool {\n-        for candidate: flag in flags { if candidate == f { ret true; } }\n-        ret false;\n-    }\n-}\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:"}, {"sha": "36244838f4c654320ae0fc6d51011b2f10df9947", "filename": "src/lib/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/775b64c955b9b61117c7bb8acf489e0311d8351b/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/775b64c955b9b61117c7bb8acf489e0311d8351b/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=775b64c955b9b61117c7bb8acf489e0311d8351b", "patch": "@@ -86,7 +86,6 @@ mod sort;\n mod sha1;\n mod ebml;\n mod ufind;\n-mod extfmt;\n mod extifmt;\n mod box;\n mod getopts;"}]}