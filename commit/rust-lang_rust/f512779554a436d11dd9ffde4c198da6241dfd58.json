{"sha": "f512779554a436d11dd9ffde4c198da6241dfd58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MTI3Nzk1NTRhNDM2ZDExZGQ5ZmZkZTRjMTk4ZGE2MjQxZGZkNTg=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-05T05:30:39Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-09T07:06:29Z"}, "message": "lexer: lex WS/COMMENT/SHEBANG rather than skipping\n\nNow, the lexer will categorize every byte in its input according to the\ngrammar. The parser skips over these while parsing, thus avoiding their\npresence in the input to syntax extensions.", "tree": {"sha": "6431e33802c11c3ba27484028fb93d2451e3373e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6431e33802c11c3ba27484028fb93d2451e3373e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f512779554a436d11dd9ffde4c198da6241dfd58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f512779554a436d11dd9ffde4c198da6241dfd58", "html_url": "https://github.com/rust-lang/rust/commit/f512779554a436d11dd9ffde4c198da6241dfd58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f512779554a436d11dd9ffde4c198da6241dfd58/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc4213418e3ab225867d8e3911f592481b1bbffc", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc4213418e3ab225867d8e3911f592481b1bbffc", "html_url": "https://github.com/rust-lang/rust/commit/cc4213418e3ab225867d8e3911f592481b1bbffc"}], "stats": {"total": 221, "additions": 134, "deletions": 87}, "files": [{"sha": "3cb5cdc04396227677bc8cdfd9e09636e5f8f133", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f512779554a436d11dd9ffde4c198da6241dfd58/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f512779554a436d11dd9ffde4c198da6241dfd58/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=f512779554a436d11dd9ffde4c198da6241dfd58", "patch": "@@ -18,7 +18,6 @@ use std::io;\n \n use syntax::parse;\n use syntax::parse::lexer;\n-use syntax::codemap::{BytePos, Span};\n \n use html::escape::Escape;\n \n@@ -59,38 +58,30 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n         None => {}\n     }\n     try!(write!(out, \"class='rust {}'>\\n\", class.unwrap_or(\"\")));\n-    let mut last = BytePos(0);\n     let mut is_attribute = false;\n     let mut is_macro = false;\n     let mut is_macro_nonterminal = false;\n     loop {\n         let next = lexer.next_token();\n-        let test = if next.tok == t::EOF {lexer.pos} else {next.sp.lo};\n-\n-        // The lexer consumes all whitespace and non-doc-comments when iterating\n-        // between tokens. If this token isn't directly adjacent to our last\n-        // token, then we need to emit the whitespace/comment.\n-        //\n-        // If the gap has any '/' characters then we consider the whole thing a\n-        // comment. This will classify some whitespace as a comment, but that\n-        // doesn't matter too much for syntax highlighting purposes.\n-        if test > last {\n-            let snip = sess.span_diagnostic.cm.span_to_snippet(Span {\n-                lo: last,\n-                hi: test,\n-                expn_info: None,\n-            }).unwrap();\n-            if snip.as_slice().contains(\"/\") {\n-                try!(write!(out, \"<span class='comment'>{}</span>\",\n-                              Escape(snip.as_slice())));\n-            } else {\n-                try!(write!(out, \"{}\", Escape(snip.as_slice())));\n-            }\n-        }\n-        last = next.sp.hi;\n+\n+        let snip = |sp| sess.span_diagnostic.cm.span_to_snippet(sp).unwrap();\n+\n         if next.tok == t::EOF { break }\n \n         let klass = match next.tok {\n+            t::WS => {\n+                try!(write!(out, \"{}\", Escape(snip(next.sp).as_slice())));\n+                continue\n+            },\n+            t::COMMENT => {\n+                try!(write!(out, \"<span class='comment'>{}</span>\",\n+                            Escape(snip(next.sp).as_slice())));\n+                continue\n+            },\n+            t::SHEBANG(s) => {\n+                try!(write!(out, \"{}\", Escape(s.as_str())));\n+                continue\n+            },\n             // If this '&' token is directly adjacent to another token, assume\n             // that it's the address-of operator instead of the and-operator.\n             // This allows us to give all pointers their own class (`Box` and"}, {"sha": "c227d8a0fedc840893763a335661b6aad096de95", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f512779554a436d11dd9ffde4c198da6241dfd58/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f512779554a436d11dd9ffde4c198da6241dfd58/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=f512779554a436d11dd9ffde4c198da6241dfd58", "patch": "@@ -34,7 +34,7 @@ impl<'a> ParserAttr for Parser<'a> {\n     fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute> {\n         let mut attrs: Vec<ast::Attribute> = Vec::new();\n         loop {\n-            debug!(\"parse_outer_attributes: self.token={:?}\",\n+            debug!(\"parse_outer_attributes: self.token={}\",\n                    self.token);\n             match self.token {\n               token::POUND => {"}, {"sha": "3f3a8a723f10c40d13c9ee7ca4112870247fb3dd", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f512779554a436d11dd9ffde4c198da6241dfd58/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f512779554a436d11dd9ffde4c198da6241dfd58/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=f512779554a436d11dd9ffde4c198da6241dfd58", "patch": "@@ -13,7 +13,7 @@ use codemap::{BytePos, CharPos, CodeMap, Pos};\n use diagnostic;\n use parse::lexer::{is_whitespace, Reader};\n use parse::lexer::{StringReader, TokenAndSpan};\n-use parse::lexer::{is_line_non_doc_comment, is_block_non_doc_comment};\n+use parse::lexer::is_block_doc_comment;\n use parse::lexer;\n use parse::token;\n \n@@ -42,9 +42,9 @@ pub struct Comment {\n }\n \n pub fn is_doc_comment(s: &str) -> bool {\n-    (s.starts_with(\"///\") && !is_line_non_doc_comment(s)) ||\n+    (s.starts_with(\"///\") && super::is_doc_comment(s)) ||\n     s.starts_with(\"//!\") ||\n-    (s.starts_with(\"/**\") && !is_block_non_doc_comment(s)) ||\n+    (s.starts_with(\"/**\") && is_block_doc_comment(s)) ||\n     s.starts_with(\"/*!\")\n }\n \n@@ -260,7 +260,7 @@ fn read_block_comment(rdr: &mut StringReader,\n             rdr.bump();\n             rdr.bump();\n         }\n-        if !is_block_non_doc_comment(curr_line.as_slice()) {\n+        if is_block_doc_comment(curr_line.as_slice()) {\n             return\n         }\n         assert!(!curr_line.as_slice().contains_char('\\n'));"}, {"sha": "947f3d59b86fab32bd5699d859aa5a1b4e287884", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 81, "deletions": 53, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/f512779554a436d11dd9ffde4c198da6241dfd58/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f512779554a436d11dd9ffde4c198da6241dfd58/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=f512779554a436d11dd9ffde4c198da6241dfd58", "patch": "@@ -187,7 +187,7 @@ impl<'a> StringReader<'a> {\n     /// Advance peek_tok and peek_span to refer to the next token, and\n     /// possibly update the interner.\n     fn advance_token(&mut self) {\n-        match self.consume_whitespace_and_comments() {\n+        match self.scan_whitespace_or_comment() {\n             Some(comment) => {\n                 self.peek_span = comment.sp;\n                 self.peek_tok = comment.tok;\n@@ -339,8 +339,7 @@ impl<'a> StringReader<'a> {\n \n     /// PRECONDITION: self.curr is not whitespace\n     /// Eats any kind of comment.\n-    /// Returns a Some(sugared-doc-attr) if one exists, None otherwise\n-    fn consume_any_line_comment(&mut self) -> Option<TokenAndSpan> {\n+    fn scan_comment(&mut self) -> Option<TokenAndSpan> {\n         match self.curr {\n             Some(c) => {\n                 if c.is_whitespace() {\n@@ -375,28 +374,32 @@ impl<'a> StringReader<'a> {\n                             }\n                             self.bump();\n                         }\n-                        let ret = self.with_str_from(start_bpos, |string| {\n+                        return self.with_str_from(start_bpos, |string| {\n                             // but comments with only more \"/\"s are not\n-                            if !is_line_non_doc_comment(string) {\n-                                Some(TokenAndSpan{\n-                                    tok: token::DOC_COMMENT(str_to_ident(string)),\n-                                    sp: codemap::mk_sp(start_bpos, self.last_pos)\n-                                })\n+                            let tok = if is_doc_comment(string) {\n+                                token::DOC_COMMENT(str_to_ident(string))\n                             } else {\n-                                None\n-                            }\n-                        });\n+                                token::COMMENT\n+                            };\n \n-                        if ret.is_some() {\n-                            return ret;\n-                        }\n+                            return Some(TokenAndSpan{\n+                                tok: tok,\n+                                sp: codemap::mk_sp(start_bpos, self.last_pos)\n+                            });\n+                        });\n                     } else {\n+                        let start_bpos = self.last_pos - BytePos(2);\n                         while !self.curr_is('\\n') && !self.is_eof() { self.bump(); }\n+                        return Some(TokenAndSpan {\n+                            tok: token::COMMENT,\n+                            sp: codemap::mk_sp(start_bpos, self.last_pos)\n+                        });\n                     }\n-                    // Restart whitespace munch.\n-                    self.consume_whitespace_and_comments()\n                 }\n-                Some('*') => { self.bump(); self.bump(); self.consume_block_comment() }\n+                Some('*') => {\n+                    self.bump(); self.bump();\n+                    self.scan_block_comment()\n+                }\n                 _ => None\n             }\n         } else if self.curr_is('#') {\n@@ -412,9 +415,15 @@ impl<'a> StringReader<'a> {\n                 let cmap = CodeMap::new();\n                 cmap.files.borrow_mut().push(self.filemap.clone());\n                 let loc = cmap.lookup_char_pos_adj(self.last_pos);\n+                debug!(\"Skipping a shebang\");\n                 if loc.line == 1u && loc.col == CharPos(0u) {\n+                    // FIXME: Add shebang \"token\", return it\n+                    let start = self.last_pos;\n                     while !self.curr_is('\\n') && !self.is_eof() { self.bump(); }\n-                    return self.consume_whitespace_and_comments();\n+                    return Some(TokenAndSpan {\n+                        tok: token::SHEBANG(self.ident_from(start)),\n+                        sp: codemap::mk_sp(start, self.last_pos)\n+                    });\n                 }\n             }\n             None\n@@ -423,15 +432,33 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    /// EFFECT: eats whitespace and comments.\n-    /// Returns a Some(sugared-doc-attr) if one exists, None otherwise.\n-    fn consume_whitespace_and_comments(&mut self) -> Option<TokenAndSpan> {\n-        while is_whitespace(self.curr) { self.bump(); }\n-        return self.consume_any_line_comment();\n+    /// If there is whitespace, shebang, or a comment, scan it. Otherwise,\n+    /// return None.\n+    fn scan_whitespace_or_comment(&mut self) -> Option<TokenAndSpan> {\n+        match self.curr.unwrap_or('\\0') {\n+            // # to handle shebang at start of file -- this is the entry point\n+            // for skipping over all \"junk\"\n+            '/' | '#' => {\n+                let c = self.scan_comment();\n+                debug!(\"scanning a comment {}\", c);\n+                c\n+            },\n+            c if is_whitespace(Some(c)) => {\n+                let start_bpos = self.last_pos;\n+                while is_whitespace(self.curr) { self.bump(); }\n+                let c = Some(TokenAndSpan {\n+                    tok: token::WS,\n+                    sp: codemap::mk_sp(start_bpos, self.last_pos)\n+                });\n+                debug!(\"scanning whitespace: {}\", c);\n+                c\n+            },\n+            _ => None\n+        }\n     }\n \n     /// Might return a sugared-doc-attr\n-    fn consume_block_comment(&mut self) -> Option<TokenAndSpan> {\n+    fn scan_block_comment(&mut self) -> Option<TokenAndSpan> {\n         // block comments starting with \"/**\" or \"/*!\" are doc-comments\n         let is_doc_comment = self.curr_is('*') || self.curr_is('!');\n         let start_bpos = self.last_pos - BytePos(2);\n@@ -466,28 +493,23 @@ impl<'a> StringReader<'a> {\n             self.bump();\n         }\n \n-        let res = if is_doc_comment {\n-            self.with_str_from(start_bpos, |string| {\n-                // but comments with only \"*\"s between two \"/\"s are not\n-                if !is_block_non_doc_comment(string) {\n-                    let string = if has_cr {\n-                        self.translate_crlf(start_bpos, string,\n-                                            \"bare CR not allowed in block doc-comment\")\n-                    } else { string.into_maybe_owned() };\n-                    Some(TokenAndSpan{\n-                            tok: token::DOC_COMMENT(str_to_ident(string.as_slice())),\n-                            sp: codemap::mk_sp(start_bpos, self.last_pos)\n-                        })\n-                } else {\n-                    None\n-                }\n-            })\n-        } else {\n-            None\n-        };\n+        self.with_str_from(start_bpos, |string| {\n+            // but comments with only \"*\"s between two \"/\"s are not\n+            let tok = if is_block_doc_comment(string) {\n+                let string = if has_cr {\n+                    self.translate_crlf(start_bpos, string,\n+                                        \"bare CR not allowed in block doc-comment\")\n+                } else { string.into_maybe_owned() };\n+                token::DOC_COMMENT(str_to_ident(string.as_slice()))\n+            } else {\n+                token::COMMENT\n+            };\n \n-        // restart whitespace munch.\n-        if res.is_some() { res } else { self.consume_whitespace_and_comments() }\n+            Some(TokenAndSpan{\n+                tok: tok,\n+                sp: codemap::mk_sp(start_bpos, self.last_pos)\n+            })\n+        })\n     }\n \n     /// Scan through any digits (base `radix`) or underscores, and return how\n@@ -1242,12 +1264,18 @@ fn in_range(c: Option<char>, lo: char, hi: char) -> bool {\n \n fn is_dec_digit(c: Option<char>) -> bool { return in_range(c, '0', '9'); }\n \n-pub fn is_line_non_doc_comment(s: &str) -> bool {\n-    s.starts_with(\"////\")\n+pub fn is_doc_comment(s: &str) -> bool {\n+    let res = (s.starts_with(\"///\") && *s.as_bytes().get(3).unwrap_or(&b' ') != b'/')\n+              || s.starts_with(\"//!\");\n+    debug!(\"is `{}` a doc comment? {}\", s, res);\n+    res\n }\n \n-pub fn is_block_non_doc_comment(s: &str) -> bool {\n-    s.starts_with(\"/***\")\n+pub fn is_block_doc_comment(s: &str) -> bool {\n+    let res = (s.starts_with(\"/**\") && *s.as_bytes().get(3).unwrap_or(&b' ') != b'*')\n+              || s.starts_with(\"/*!\");\n+    debug!(\"is `{}` a doc comment? {}\", s, res);\n+    res\n }\n \n fn ident_start(c: Option<char>) -> bool {\n@@ -1383,9 +1411,9 @@ mod test {\n     }\n \n     #[test] fn line_doc_comments() {\n-        assert!(!is_line_non_doc_comment(\"///\"));\n-        assert!(!is_line_non_doc_comment(\"/// blah\"));\n-        assert!(is_line_non_doc_comment(\"////\"));\n+        assert!(is_doc_comment(\"///\"));\n+        assert!(is_doc_comment(\"/// blah\"));\n+        assert!(!is_doc_comment(\"////\"));\n     }\n \n     #[test] fn nested_block_comments() {"}, {"sha": "51f2c74d3aeff5d6e8dfe7d56984049e142061fd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f512779554a436d11dd9ffde4c198da6241dfd58/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f512779554a436d11dd9ffde4c198da6241dfd58/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f512779554a436d11dd9ffde4c198da6241dfd58", "patch": "@@ -325,10 +325,24 @@ fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n     is_plain_ident(t) || *t == token::UNDERSCORE\n }\n \n+/// Get a token the parser cares about\n+fn real_token(rdr: &mut Reader) -> TokenAndSpan {\n+    let mut t = rdr.next_token();\n+    loop {\n+        match t.tok {\n+            token::WS | token::COMMENT | token::SHEBANG(_) => {\n+                t = rdr.next_token();\n+            },\n+            _ => break\n+        }\n+    }\n+    t\n+}\n+\n impl<'a> Parser<'a> {\n     pub fn new(sess: &'a ParseSess, cfg: ast::CrateConfig,\n                mut rdr: Box<Reader>) -> Parser<'a> {\n-        let tok0 = rdr.next_token();\n+        let tok0 = real_token(rdr);\n         let span = tok0.sp;\n         let placeholder = TokenAndSpan {\n             tok: token::UNDERSCORE,\n@@ -864,7 +878,7 @@ impl<'a> Parser<'a> {\n             None\n         };\n         let next = if self.buffer_start == self.buffer_end {\n-            self.reader.next_token()\n+            real_token(self.reader)\n         } else {\n             // Avoid token copies with `replace`.\n             let buffer_start = self.buffer_start as uint;\n@@ -908,7 +922,7 @@ impl<'a> Parser<'a> {\n                       -> R {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n-            self.buffer[self.buffer_end as uint] = self.reader.next_token();\n+            self.buffer[self.buffer_end as uint] = real_token(self.reader);\n             self.buffer_end = (self.buffer_end + 1) & 3;\n         }\n         f(&self.buffer[((self.buffer_start + dist - 1) & 3) as uint].tok)"}, {"sha": "e65f9f208a317ce29c03d76de64940b13f06330c", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f512779554a436d11dd9ffde4c198da6241dfd58/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f512779554a436d11dd9ffde4c198da6241dfd58/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=f512779554a436d11dd9ffde4c198da6241dfd58", "patch": "@@ -97,8 +97,18 @@ pub enum Token {\n \n     /* For interpolation */\n     INTERPOLATED(Nonterminal),\n-\n     DOC_COMMENT(Ident),\n+\n+    // Junk. These carry no data because we don't really care about the data\n+    // they *would* carry, and don't really want to allocate a new ident for\n+    // them. Instead, users could extract that from the associated span.\n+\n+    /// Whitespace\n+    WS,\n+    /// Comment\n+    COMMENT,\n+    SHEBANG(Ident),\n+\n     EOF,\n }\n \n@@ -231,6 +241,10 @@ pub fn to_string(t: &Token) -> String {\n       /* Other */\n       DOC_COMMENT(s) => get_ident(s).get().to_string(),\n       EOF => \"<eof>\".to_string(),\n+      WS => \" \".to_string(),\n+      COMMENT => \"/* */\".to_string(),\n+      SHEBANG(s) => format!(\"/* shebang: {}*/\", s.as_str()),\n+\n       INTERPOLATED(ref nt) => {\n         match nt {\n             &NtExpr(ref e) => ::print::pprust::expr_to_string(&**e),"}]}