{"sha": "3abd4753b7c9fa9a3855d4b41b557f81b3e06aab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYmQ0NzUzYjdjOWZhOWEzODU1ZDRiNDFiNTU3ZjgxYjNlMDZhYWI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-07T17:36:24Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-16T10:06:50Z"}, "message": "Make QueryCache parameters associated types.", "tree": {"sha": "328850e8f1ff5838f5933dee42b469a11fa1dabb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/328850e8f1ff5838f5933dee42b469a11fa1dabb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab", "html_url": "https://github.com/rust-lang/rust/commit/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7309b3cd8be928a0ec9e3219d9562ddeb54ff994", "url": "https://api.github.com/repos/rust-lang/rust/commits/7309b3cd8be928a0ec9e3219d9562ddeb54ff994", "html_url": "https://github.com/rust-lang/rust/commit/7309b3cd8be928a0ec9e3219d9562ddeb54ff994"}], "stats": {"total": 195, "additions": 101, "deletions": 94}, "files": [{"sha": "71523ea39ca3e27d5434493029b25dbd06ae4bd9", "filename": "src/librustc/ty/query/caches.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs?ref=3abd4753b7c9fa9a3855d4b41b557f81b3e06aab", "patch": "@@ -6,12 +6,15 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sharded::Sharded;\n use std::default::Default;\n use std::hash::Hash;\n+use std::marker::PhantomData;\n \n pub(crate) trait CacheSelector<K, V> {\n-    type Cache: QueryCache<K, V>;\n+    type Cache: QueryCache<Key = K, Value = V>;\n }\n \n-pub(crate) trait QueryCache<K, V>: Default {\n+pub(crate) trait QueryCache: Default {\n+    type Key;\n+    type Value;\n     type Sharded: Default;\n \n     /// Checks if the query is already computed and in the cache.\n@@ -20,52 +23,62 @@ pub(crate) trait QueryCache<K, V>: Default {\n     /// to compute it.\n     fn lookup<'tcx, R, GetCache, OnHit, OnMiss>(\n         &self,\n-        state: &'tcx QueryStateImpl<'tcx, K, V, Self>,\n+        state: &'tcx QueryStateImpl<'tcx, Self>,\n         get_cache: GetCache,\n-        key: K,\n+        key: Self::Key,\n         // `on_hit` can be called while holding a lock to the query state shard.\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n-        GetCache:\n-            for<'a> Fn(&'a mut QueryStateShard<'tcx, K, Self::Sharded>) -> &'a mut Self::Sharded,\n-        OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(K, QueryLookup<'tcx, K, Self::Sharded>) -> R;\n+        GetCache: for<'a> Fn(\n+            &'a mut QueryStateShard<'tcx, Self::Key, Self::Sharded>,\n+        ) -> &'a mut Self::Sharded,\n+        OnHit: FnOnce(&Self::Value, DepNodeIndex) -> R,\n+        OnMiss: FnOnce(Self::Key, QueryLookup<'tcx, Self::Key, Self::Sharded>) -> R;\n \n     fn complete(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         lock_sharded_storage: &mut Self::Sharded,\n-        key: K,\n-        value: V,\n+        key: Self::Key,\n+        value: Self::Value,\n         index: DepNodeIndex,\n     );\n \n     fn iter<R, L>(\n         &self,\n         shards: &Sharded<L>,\n         get_shard: impl Fn(&mut L) -> &mut Self::Sharded,\n-        f: impl for<'a> FnOnce(Box<dyn Iterator<Item = (&'a K, &'a V, DepNodeIndex)> + 'a>) -> R,\n+        f: impl for<'a> FnOnce(\n+            Box<dyn Iterator<Item = (&'a Self::Key, &'a Self::Value, DepNodeIndex)> + 'a>,\n+        ) -> R,\n     ) -> R;\n }\n \n pub struct DefaultCacheSelector;\n \n impl<K: Eq + Hash, V: Clone> CacheSelector<K, V> for DefaultCacheSelector {\n-    type Cache = DefaultCache;\n+    type Cache = DefaultCache<K, V>;\n }\n \n-#[derive(Default)]\n-pub struct DefaultCache;\n+pub struct DefaultCache<K, V>(PhantomData<(K, V)>);\n+\n+impl<K, V> Default for DefaultCache<K, V> {\n+    fn default() -> Self {\n+        DefaultCache(PhantomData)\n+    }\n+}\n \n-impl<K: Eq + Hash, V: Clone> QueryCache<K, V> for DefaultCache {\n+impl<K: Eq + Hash, V: Clone> QueryCache for DefaultCache<K, V> {\n+    type Key = K;\n+    type Value = V;\n     type Sharded = FxHashMap<K, (V, DepNodeIndex)>;\n \n     #[inline(always)]\n     fn lookup<'tcx, R, GetCache, OnHit, OnMiss>(\n         &self,\n-        state: &'tcx QueryStateImpl<'tcx, K, V, Self>,\n+        state: &'tcx QueryStateImpl<'tcx, Self>,\n         get_cache: GetCache,\n         key: K,\n         on_hit: OnHit,"}, {"sha": "5b0653bd599e1d8dfefa2b98609d60dbf359e3ed", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=3abd4753b7c9fa9a3855d4b41b557f81b3e06aab", "patch": "@@ -30,7 +30,7 @@ pub(crate) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n     const EVAL_ALWAYS: bool;\n     const DEP_KIND: DepKind;\n \n-    type Cache: QueryCache<Self::Key, Self::Value>;\n+    type Cache: QueryCache<Key = Self::Key, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n     fn query_state<'a>(tcx: TyCtxt<'tcx>) -> &'a QueryState<'tcx, Self>;\n@@ -59,10 +59,7 @@ pub(crate) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n     }\n }\n \n-impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M\n-where\n-    <M as QueryAccessors<'tcx>>::Cache: QueryCache<DefId, <M as QueryConfig<'tcx>>::Value>,\n-{\n+impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M {\n     default fn describe(tcx: TyCtxt<'_>, def_id: DefId) -> Cow<'static, str> {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.def_path_str(def_id)).into()"}, {"sha": "c2740733977e8a7d8a39efe5084e2993a2e960d2", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 60, "deletions": 58, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=3abd4753b7c9fa9a3855d4b41b557f81b3e06aab", "patch": "@@ -4,7 +4,7 @@\n \n use crate::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use crate::ty::query::caches::QueryCache;\n-use crate::ty::query::config::{QueryAccessors, QueryConfig, QueryDescription};\n+use crate::ty::query::config::{QueryAccessors, QueryDescription};\n use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId};\n use crate::ty::query::Query;\n use crate::ty::tls;\n@@ -49,22 +49,20 @@ impl<'tcx, K, C: Default> Default for QueryStateShard<'tcx, K, C> {\n     }\n }\n \n-pub(crate) type QueryState<'tcx, Q> = QueryStateImpl<\n-    'tcx,\n-    <Q as QueryConfig<'tcx>>::Key,\n-    <Q as QueryConfig<'tcx>>::Value,\n-    <Q as QueryAccessors<'tcx>>::Cache,\n->;\n+pub(crate) type QueryState<'tcx, Q> = QueryStateImpl<'tcx, <Q as QueryAccessors<'tcx>>::Cache>;\n \n-pub(crate) struct QueryStateImpl<'tcx, K, V, C: QueryCache<K, V>> {\n+pub(crate) struct QueryStateImpl<'tcx, C: QueryCache> {\n     pub(super) cache: C,\n-    pub(super) shards: Sharded<QueryStateShard<'tcx, K, C::Sharded>>,\n+    pub(super) shards: Sharded<QueryStateShard<'tcx, C::Key, C::Sharded>>,\n     #[cfg(debug_assertions)]\n     pub(super) cache_hits: AtomicUsize,\n }\n \n-impl<'tcx, K, V, C: QueryCache<K, V>> QueryStateImpl<'tcx, K, V, C> {\n-    pub(super) fn get_lookup<K2: Hash>(&'tcx self, key: &K2) -> QueryLookup<'tcx, K, C::Sharded> {\n+impl<'tcx, C: QueryCache> QueryStateImpl<'tcx, C> {\n+    pub(super) fn get_lookup<K2: Hash>(\n+        &'tcx self,\n+        key: &K2,\n+    ) -> QueryLookup<'tcx, C::Key, C::Sharded> {\n         // We compute the key's hash once and then use it for both the\n         // shard lookup and the hashmap lookup. This relies on the fact\n         // that both of them use `FxHasher`.\n@@ -88,10 +86,12 @@ pub(super) enum QueryResult<'tcx> {\n     Poisoned,\n }\n \n-impl<'tcx, K, V, C: QueryCache<K, V>> QueryStateImpl<'tcx, K, V, C> {\n+impl<'tcx, C: QueryCache> QueryStateImpl<'tcx, C> {\n     pub fn iter_results<R>(\n         &self,\n-        f: impl for<'a> FnOnce(Box<dyn Iterator<Item = (&'a K, &'a V, DepNodeIndex)> + 'a>) -> R,\n+        f: impl for<'a> FnOnce(\n+            Box<dyn Iterator<Item = (&'a C::Key, &'a C::Value, DepNodeIndex)> + 'a>,\n+        ) -> R,\n     ) -> R {\n         self.cache.iter(&self.shards, |shard| &mut shard.cache, f)\n     }\n@@ -103,11 +103,11 @@ impl<'tcx, K, V, C: QueryCache<K, V>> QueryStateImpl<'tcx, K, V, C> {\n     pub(super) fn try_collect_active_jobs(\n         &self,\n         kind: DepKind,\n-        make_query: fn(K) -> Query<'tcx>,\n+        make_query: fn(C::Key) -> Query<'tcx>,\n         jobs: &mut FxHashMap<QueryJobId, QueryJobInfo<'tcx>>,\n     ) -> Option<()>\n     where\n-        K: Clone,\n+        C::Key: Clone,\n     {\n         // We use try_lock_shards here since we are called from the\n         // deadlock handler, and this shouldn't be locked.\n@@ -130,8 +130,8 @@ impl<'tcx, K, V, C: QueryCache<K, V>> QueryStateImpl<'tcx, K, V, C> {\n     }\n }\n \n-impl<'tcx, K, V, C: QueryCache<K, V>> Default for QueryStateImpl<'tcx, K, V, C> {\n-    fn default() -> QueryStateImpl<'tcx, K, V, C> {\n+impl<'tcx, C: QueryCache> Default for QueryStateImpl<'tcx, C> {\n+    fn default() -> QueryStateImpl<'tcx, C> {\n         QueryStateImpl {\n             cache: C::default(),\n             shards: Default::default(),\n@@ -150,27 +150,22 @@ pub(crate) struct QueryLookup<'tcx, K, C> {\n \n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n-pub(super) type JobOwner<'tcx, Q> = JobOwnerImpl<\n-    'tcx,\n-    <Q as QueryConfig<'tcx>>::Key,\n-    <Q as QueryConfig<'tcx>>::Value,\n-    <Q as QueryAccessors<'tcx>>::Cache,\n->;\n-\n-pub(super) struct JobOwnerImpl<'tcx, K, V, C: QueryCache<K, V>>\n+pub(super) struct JobOwner<'tcx, C>\n where\n-    K: Eq + Hash + Clone + Debug,\n-    V: Clone,\n+    C: QueryCache,\n+    C::Key: Eq + Hash + Clone + Debug,\n+    C::Value: Clone,\n {\n-    state: &'tcx QueryStateImpl<'tcx, K, V, C>,\n-    key: K,\n+    state: &'tcx QueryStateImpl<'tcx, C>,\n+    key: C::Key,\n     id: QueryJobId,\n }\n \n-impl<'tcx, K, V, C: QueryCache<K, V>> JobOwnerImpl<'tcx, K, V, C>\n+impl<'tcx, C: QueryCache> JobOwner<'tcx, C>\n where\n-    K: Eq + Hash + Clone + Debug,\n-    V: Clone,\n+    C: QueryCache,\n+    C::Key: Eq + Hash + Clone + Debug,\n+    C::Value: Clone,\n {\n     /// Either gets a `JobOwner` corresponding the query, allowing us to\n     /// start executing the query, or returns with the result of the query.\n@@ -184,13 +179,11 @@ where\n     pub(super) fn try_start<Q>(\n         tcx: TyCtxt<'tcx>,\n         span: Span,\n-        key: &K,\n-        mut lookup: QueryLookup<'tcx, K, C::Sharded>,\n-    ) -> TryGetJob<'tcx, Q>\n+        key: &C::Key,\n+        mut lookup: QueryLookup<'tcx, C::Key, C::Sharded>,\n+    ) -> TryGetJob<'tcx, C>\n     where\n-        K: Eq + Hash + Clone + Debug,\n-        V: Clone,\n-        Q: QueryDescription<'tcx, Key = K, Value = V, Cache = C> + 'tcx,\n+        Q: QueryDescription<'tcx, Key = C::Key, Value = C::Value, Cache = C>,\n     {\n         let lock = &mut *lookup.lock;\n \n@@ -230,7 +223,7 @@ where\n                 entry.insert(QueryResult::Started(job));\n \n                 let owner =\n-                    JobOwnerImpl { state: Q::query_state(tcx), id: global_id, key: (*key).clone() };\n+                    JobOwner { state: Q::query_state(tcx), id: global_id, key: (*key).clone() };\n                 return TryGetJob::NotYetStarted(owner);\n             }\n         };\n@@ -271,7 +264,12 @@ where\n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n     #[inline(always)]\n-    pub(super) fn complete(self, tcx: TyCtxt<'tcx>, result: &V, dep_node_index: DepNodeIndex) {\n+    pub(super) fn complete(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        result: &C::Value,\n+        dep_node_index: DepNodeIndex,\n+    ) {\n         // We can move out of `self` here because we `mem::forget` it below\n         let key = unsafe { ptr::read(&self.key) };\n         let state = self.state;\n@@ -304,10 +302,10 @@ where\n     (result, diagnostics.into_inner())\n }\n \n-impl<'tcx, K, V, C: QueryCache<K, V>> Drop for JobOwnerImpl<'tcx, K, V, C>\n+impl<'tcx, C: QueryCache> Drop for JobOwner<'tcx, C>\n where\n-    K: Eq + Hash + Clone + Debug,\n-    V: Clone,\n+    C::Key: Eq + Hash + Clone + Debug,\n+    C::Value: Clone,\n {\n     #[inline(never)]\n     #[cold]\n@@ -338,18 +336,22 @@ pub struct CycleError<'tcx> {\n }\n \n /// The result of `try_start`.\n-pub(super) enum TryGetJob<'tcx, D: QueryDescription<'tcx>> {\n+pub(super) enum TryGetJob<'tcx, C: QueryCache>\n+where\n+    C::Key: Eq + Hash + Clone + Debug,\n+    C::Value: Clone,\n+{\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n-    NotYetStarted(JobOwner<'tcx, D>),\n+    NotYetStarted(JobOwner<'tcx, C>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep-node index\n     /// if it succeeded or a cycle error if it failed.\n     #[cfg(parallel_compiler)]\n-    JobCompleted((D::Value, DepNodeIndex)),\n+    JobCompleted((C::Value, DepNodeIndex)),\n \n     /// Trying to execute the query resulted in a cycle.\n-    Cycle(D::Value),\n+    Cycle(C::Value),\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -478,22 +480,22 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n     #[inline(always)]\n-    fn try_get_cached<K, V, C, R, OnHit, OnMiss>(\n+    fn try_get_cached<C, R, OnHit, OnMiss>(\n         self,\n-        state: &'tcx QueryStateImpl<'tcx, K, V, C>,\n-        key: K,\n+        state: &'tcx QueryStateImpl<'tcx, C>,\n+        key: C::Key,\n         // `on_hit` can be called while holding a lock to the query cache\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n-        C: QueryCache<K, V>,\n-        OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(K, QueryLookup<'tcx, K, C::Sharded>) -> R,\n+        C: QueryCache,\n+        OnHit: FnOnce(&C::Value, DepNodeIndex) -> R,\n+        OnMiss: FnOnce(C::Key, QueryLookup<'tcx, C::Key, C::Sharded>) -> R,\n     {\n         state.cache.lookup(\n             state,\n-            QueryStateShard::<K, C::Sharded>::get_cache,\n+            QueryStateShard::<C::Key, C::Sharded>::get_cache,\n             key,\n             |value, index| {\n                 if unlikely!(self.prof.enabled()) {\n@@ -533,9 +535,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         span: Span,\n         key: Q::Key,\n-        lookup: QueryLookup<'tcx, Q::Key, <Q::Cache as QueryCache<Q::Key, Q::Value>>::Sharded>,\n+        lookup: QueryLookup<'tcx, Q::Key, <Q::Cache as QueryCache>::Sharded>,\n     ) -> Q::Value {\n-        let job = match JobOwnerImpl::try_start::<Q>(self, span, &key, lookup) {\n+        let job = match JobOwner::try_start::<Q>(self, span, &key, lookup) {\n             TryGetJob::NotYetStarted(job) => job,\n             TryGetJob::Cycle(result) => return result,\n             #[cfg(parallel_compiler)]\n@@ -696,7 +698,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn force_query_with_job<Q: QueryDescription<'tcx> + 'tcx>(\n         self,\n         key: Q::Key,\n-        job: JobOwner<'tcx, Q>,\n+        job: JobOwner<'tcx, Q::Cache>,\n         dep_node: DepNode,\n     ) -> (Q::Value, DepNodeIndex) {\n         // If the following assertion triggers, it can have two reasons:\n@@ -795,7 +797,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 // Cache hit, do nothing\n             },\n             |key, lookup| {\n-                let job = match JobOwnerImpl::try_start::<Q>(self, span, &key, lookup) {\n+                let job = match JobOwner::try_start::<Q>(self, span, &key, lookup) {\n                     TryGetJob::NotYetStarted(job) => job,\n                     TryGetJob::Cycle(_) => return,\n                     #[cfg(parallel_compiler)]"}, {"sha": "256bd86a3de383fb3b8b443cb8c68cda7f0f0ade", "filename": "src/librustc/ty/query/profiling_support.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs?ref=3abd4753b7c9fa9a3855d4b41b557f81b3e06aab", "patch": "@@ -157,14 +157,14 @@ where\n /// Allocate the self-profiling query strings for a single query cache. This\n /// method is called from `alloc_self_profile_query_strings` which knows all\n /// the queries via macro magic.\n-pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, K, V, C>(\n+pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n     tcx: TyCtxt<'tcx>,\n     query_name: &'static str,\n-    query_state: &QueryStateImpl<'tcx, K, V, C>,\n+    query_state: &QueryStateImpl<'tcx, C>,\n     string_cache: &mut QueryKeyStringCache,\n ) where\n-    K: Debug + Clone,\n-    C: QueryCache<K, V>,\n+    C: QueryCache,\n+    C::Key: Debug + Clone,\n {\n     tcx.prof.with_profiler(|profiler| {\n         let event_id_builder = profiler.event_id_builder();"}, {"sha": "20894a2a5d1e19460e9c41ee81437bb9d02dbdc5", "filename": "src/librustc/ty/query/stats.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abd4753b7c9fa9a3855d4b41b557f81b3e06aab/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs?ref=3abd4753b7c9fa9a3855d4b41b557f81b3e06aab", "patch": "@@ -1,5 +1,5 @@\n use crate::ty::query::caches::QueryCache;\n-use crate::ty::query::config::{QueryAccessors, QueryConfig};\n+use crate::ty::query::config::QueryAccessors;\n use crate::ty::query::plumbing::QueryStateImpl;\n use crate::ty::query::queries;\n use crate::ty::TyCtxt;\n@@ -38,20 +38,17 @@ struct QueryStats {\n     local_def_id_keys: Option<usize>,\n }\n \n-fn stats<'tcx, K, V, C: QueryCache<K, V>>(\n-    name: &'static str,\n-    map: &QueryStateImpl<'tcx, K, V, C>,\n-) -> QueryStats {\n+fn stats<'tcx, C: QueryCache>(name: &'static str, map: &QueryStateImpl<'tcx, C>) -> QueryStats {\n     let mut stats = QueryStats {\n         name,\n         #[cfg(debug_assertions)]\n         cache_hits: map.cache_hits.load(Ordering::Relaxed),\n         #[cfg(not(debug_assertions))]\n         cache_hits: 0,\n-        key_size: mem::size_of::<K>(),\n-        key_type: type_name::<K>(),\n-        value_size: mem::size_of::<V>(),\n-        value_type: type_name::<V>(),\n+        key_size: mem::size_of::<C::Key>(),\n+        key_type: type_name::<C::Key>(),\n+        value_size: mem::size_of::<C::Value>(),\n+        value_type: type_name::<C::Value>(),\n         entry_count: map.iter_results(|results| results.count()),\n         local_def_id_keys: None,\n     };\n@@ -127,8 +124,6 @@ macro_rules! print_stats {\n \n             $($(\n                 queries.push(stats::<\n-                    <queries::$name<'_> as QueryConfig<'_>>::Key,\n-                    <queries::$name<'_> as QueryConfig<'_>>::Value,\n                     <queries::$name<'_> as QueryAccessors<'_>>::Cache,\n                 >(\n                     stringify!($name),"}]}