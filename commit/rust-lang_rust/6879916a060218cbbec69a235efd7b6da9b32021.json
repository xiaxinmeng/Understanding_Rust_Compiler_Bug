{"sha": "6879916a060218cbbec69a235efd7b6da9b32021", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4Nzk5MTZhMDYwMjE4Y2JiZWM2OWEyMzVlZmQ3YjZkYTliMzIwMjE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-06T13:46:26Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-17T07:53:06Z"}, "message": "De-@ liveness.", "tree": {"sha": "ff2cf2afe890d0b52ab6b97ee931f3fde8ae50b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff2cf2afe890d0b52ab6b97ee931f3fde8ae50b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6879916a060218cbbec69a235efd7b6da9b32021", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6879916a060218cbbec69a235efd7b6da9b32021", "html_url": "https://github.com/rust-lang/rust/commit/6879916a060218cbbec69a235efd7b6da9b32021", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6879916a060218cbbec69a235efd7b6da9b32021/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ba5f1b8f42b25e213b67305cdbea798abec7a81", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ba5f1b8f42b25e213b67305cdbea798abec7a81", "html_url": "https://github.com/rust-lang/rust/commit/0ba5f1b8f42b25e213b67305cdbea798abec7a81"}], "stats": {"total": 722, "additions": 307, "deletions": 415}, "files": [{"sha": "7b08949fe024cc54ae3b97486b405e59dd311862", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 307, "deletions": 415, "changes": 722, "blob_url": "https://github.com/rust-lang/rust/blob/6879916a060218cbbec69a235efd7b6da9b32021/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6879916a060218cbbec69a235efd7b6da9b32021/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6879916a060218cbbec69a235efd7b6da9b32021", "patch": "@@ -111,9 +111,9 @@ use middle::moves;\n use util::nodemap::NodeMap;\n \n use std::cast::transmute;\n-use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::io;\n+use std::rc::Rc;\n use std::str;\n use std::uint;\n use std::vec_ng::Vec;\n@@ -126,9 +126,9 @@ use syntax::{visit, ast_util};\n use syntax::visit::{Visitor, FnKind};\n \n #[deriving(Eq)]\n-pub struct Variable(uint);\n+struct Variable(uint);\n #[deriving(Eq)]\n-pub struct LiveNode(uint);\n+struct LiveNode(uint);\n \n impl Variable {\n     fn get(&self) -> uint { let Variable(v) = *self; v }\n@@ -145,7 +145,7 @@ impl Clone for LiveNode {\n }\n \n #[deriving(Eq)]\n-pub enum LiveNodeKind {\n+enum LiveNodeKind {\n     FreeVarNode(Span),\n     ExprNode(Span),\n     VarDefNode(Span),\n@@ -162,25 +162,20 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: &ty::ctxt) -> ~str {\n     }\n }\n \n-struct LivenessVisitor;\n-\n-impl<'a> Visitor<@IrMaps<'a>> for LivenessVisitor {\n-    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, e: @IrMaps) {\n-        visit_fn(self, fk, fd, b, s, n, e);\n+impl<'a> Visitor<()> for IrMaps<'a> {\n+    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n+        visit_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_local(&mut self, l: &Local, e: @IrMaps) { visit_local(self, l, e); }\n-    fn visit_expr(&mut self, ex: &Expr, e: @IrMaps) { visit_expr(self, ex, e); }\n-    fn visit_arm(&mut self, a: &Arm, e: @IrMaps) { visit_arm(self, a, e); }\n+    fn visit_local(&mut self, l: &Local, _: ()) { visit_local(self, l); }\n+    fn visit_expr(&mut self, ex: &Expr, _: ()) { visit_expr(self, ex); }\n+    fn visit_arm(&mut self, a: &Arm, _: ()) { visit_arm(self, a); }\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: typeck::MethodMap,\n                    capture_map: moves::CaptureMap,\n                    krate: &Crate) {\n-    let mut visitor = LivenessVisitor;\n-\n-    let initial_maps = @IrMaps(tcx, method_map, capture_map);\n-    visit::walk_crate(&mut visitor, krate, initial_maps);\n+    visit::walk_crate(&mut IrMaps(tcx, method_map, capture_map), krate, ());\n     tcx.sess.abort_if_errors();\n }\n \n@@ -219,50 +214,50 @@ impl fmt::Show for Variable {\n // assignment.  And so forth.\n \n impl LiveNode {\n-    pub fn is_valid(&self) -> bool {\n+    fn is_valid(&self) -> bool {\n         self.get() != uint::MAX\n     }\n }\n \n fn invalid_node() -> LiveNode { LiveNode(uint::MAX) }\n \n-pub struct CaptureInfo {\n+struct CaptureInfo {\n     ln: LiveNode,\n     is_move: bool,\n     var_nid: NodeId\n }\n \n-pub enum LocalKind {\n+enum LocalKind {\n     FromMatch(BindingMode),\n     FromLetWithInitializer,\n     FromLetNoInitializer\n }\n \n-pub struct LocalInfo {\n+struct LocalInfo {\n     id: NodeId,\n     ident: Ident,\n     is_mutbl: bool,\n     kind: LocalKind,\n }\n \n-pub enum VarKind {\n+enum VarKind {\n     Arg(NodeId, Ident),\n     Local(LocalInfo),\n     ImplicitRet\n }\n \n-pub struct IrMaps<'a> {\n+struct IrMaps<'a> {\n     tcx: &'a ty::ctxt,\n     method_map: typeck::MethodMap,\n     capture_map: moves::CaptureMap,\n \n-    num_live_nodes: Cell<uint>,\n-    num_vars: Cell<uint>,\n-    live_node_map: RefCell<NodeMap<LiveNode>>,\n-    variable_map: RefCell<NodeMap<Variable>>,\n-    capture_info_map: RefCell<NodeMap<@Vec<CaptureInfo> >>,\n-    var_kinds: RefCell<Vec<VarKind> >,\n-    lnks: RefCell<Vec<LiveNodeKind> >,\n+    num_live_nodes: uint,\n+    num_vars: uint,\n+    live_node_map: NodeMap<LiveNode>,\n+    variable_map: NodeMap<Variable>,\n+    capture_info_map: NodeMap<Rc<Vec<CaptureInfo>>>,\n+    var_kinds: Vec<VarKind>,\n+    lnks: Vec<LiveNodeKind>,\n }\n \n fn IrMaps<'a>(tcx: &'a ty::ctxt,\n@@ -273,50 +268,43 @@ fn IrMaps<'a>(tcx: &'a ty::ctxt,\n         tcx: tcx,\n         method_map: method_map,\n         capture_map: capture_map,\n-        num_live_nodes: Cell::new(0),\n-        num_vars: Cell::new(0),\n-        live_node_map: RefCell::new(NodeMap::new()),\n-        variable_map: RefCell::new(NodeMap::new()),\n-        capture_info_map: RefCell::new(NodeMap::new()),\n-        var_kinds: RefCell::new(Vec::new()),\n-        lnks: RefCell::new(Vec::new()),\n+        num_live_nodes: 0,\n+        num_vars: 0,\n+        live_node_map: NodeMap::new(),\n+        variable_map: NodeMap::new(),\n+        capture_info_map: NodeMap::new(),\n+        var_kinds: Vec::new(),\n+        lnks: Vec::new(),\n     }\n }\n \n impl<'a> IrMaps<'a> {\n-    pub fn add_live_node(&self, lnk: LiveNodeKind) -> LiveNode {\n-        let num_live_nodes = self.num_live_nodes.get();\n-        let ln = LiveNode(num_live_nodes);\n-        let mut lnks = self.lnks.borrow_mut();\n-        lnks.get().push(lnk);\n-        self.num_live_nodes.set(num_live_nodes + 1);\n+    fn add_live_node(&mut self, lnk: LiveNodeKind) -> LiveNode {\n+        let ln = LiveNode(self.num_live_nodes);\n+        self.lnks.push(lnk);\n+        self.num_live_nodes += 1;\n \n         debug!(\"{} is of kind {}\", ln.to_str(),\n                live_node_kind_to_str(lnk, self.tcx));\n \n         ln\n     }\n \n-    pub fn add_live_node_for_node(&self, node_id: NodeId, lnk: LiveNodeKind) {\n+    fn add_live_node_for_node(&mut self, node_id: NodeId, lnk: LiveNodeKind) {\n         let ln = self.add_live_node(lnk);\n-        let mut live_node_map = self.live_node_map.borrow_mut();\n-        live_node_map.get().insert(node_id, ln);\n+        self.live_node_map.insert(node_id, ln);\n \n         debug!(\"{} is node {}\", ln.to_str(), node_id);\n     }\n \n-    pub fn add_variable(&self, vk: VarKind) -> Variable {\n-        let v = Variable(self.num_vars.get());\n-        {\n-            let mut var_kinds = self.var_kinds.borrow_mut();\n-            var_kinds.get().push(vk);\n-        }\n-        self.num_vars.set(self.num_vars.get() + 1);\n+    fn add_variable(&mut self, vk: VarKind) -> Variable {\n+        let v = Variable(self.num_vars);\n+        self.var_kinds.push(vk);\n+        self.num_vars += 1;\n \n         match vk {\n             Local(LocalInfo { id: node_id, .. }) | Arg(node_id, _) => {\n-                let mut variable_map = self.variable_map.borrow_mut();\n-                variable_map.get().insert(node_id, v);\n+                self.variable_map.insert(node_id, v);\n             },\n             ImplicitRet => {}\n         }\n@@ -326,9 +314,8 @@ impl<'a> IrMaps<'a> {\n         v\n     }\n \n-    pub fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n-        let variable_map = self.variable_map.borrow();\n-        match variable_map.get().find(&node_id) {\n+    fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n+        match self.variable_map.find(&node_id) {\n           Some(&var) => var,\n           None => {\n             self.tcx.sess.span_bug(\n@@ -337,34 +324,21 @@ impl<'a> IrMaps<'a> {\n         }\n     }\n \n-    pub fn variable_name(&self, var: Variable) -> ~str {\n-        let var_kinds = self.var_kinds.borrow();\n-        match var_kinds.get().get(var.get()) {\n+    fn variable_name(&self, var: Variable) -> ~str {\n+        match self.var_kinds.get(var.get()) {\n             &Local(LocalInfo { ident: nm, .. }) | &Arg(_, nm) => {\n                 token::get_ident(nm).get().to_str()\n             },\n             &ImplicitRet => ~\"<implicit-ret>\"\n         }\n     }\n \n-    pub fn set_captures(&self, node_id: NodeId, cs: Vec<CaptureInfo> ) {\n-        let mut capture_info_map = self.capture_info_map.borrow_mut();\n-        capture_info_map.get().insert(node_id, @cs);\n+    fn set_captures(&mut self, node_id: NodeId, cs: Vec<CaptureInfo>) {\n+        self.capture_info_map.insert(node_id, Rc::new(cs));\n     }\n \n-    pub fn captures(&self, expr: &Expr) -> @Vec<CaptureInfo> {\n-        let capture_info_map = self.capture_info_map.borrow();\n-        match capture_info_map.get().find(&expr.id) {\n-          Some(&caps) => caps,\n-          None => {\n-            self.tcx.sess.span_bug(expr.span, \"no registered caps\");\n-          }\n-        }\n-    }\n-\n-    pub fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n-        let lnks = self.lnks.borrow();\n-        *lnks.get().get(ln.get())\n+    fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n+        *self.lnks.get(ln.get())\n     }\n }\n \n@@ -383,25 +357,24 @@ impl<'a> Visitor<()> for Liveness<'a> {\n     }\n }\n \n-fn visit_fn(v: &mut LivenessVisitor,\n+fn visit_fn(ir: &mut IrMaps,\n             fk: &FnKind,\n             decl: &FnDecl,\n             body: &Block,\n             sp: Span,\n-            id: NodeId,\n-            this: @IrMaps) {\n+            id: NodeId) {\n     debug!(\"visit_fn: id={}\", id);\n     let _i = ::util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n-    let fn_maps = @IrMaps(this.tcx, this.method_map, this.capture_map);\n+    let mut fn_maps = IrMaps(ir.tcx, ir.method_map, ir.capture_map);\n \n     unsafe {\n-        debug!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(fn_maps));\n+        debug!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(&fn_maps));\n     }\n \n     for arg in decl.inputs.iter() {\n-        pat_util::pat_bindings(this.tcx.def_map,\n+        pat_util::pat_bindings(ir.tcx.def_map,\n                                arg.pat,\n                                |_bm, arg_id, _x, path| {\n             debug!(\"adding argument {}\", arg_id);\n@@ -412,7 +385,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n \n     // gather up the various local variables, significant expressions,\n     // and so forth:\n-    visit::walk_fn(v, fk, decl, body, sp, id, fn_maps);\n+    visit::walk_fn(&mut fn_maps, fk, decl, body, sp, id, ());\n \n     // Special nodes and variables:\n     // - exit_ln represents the end of the fn, either by return or fail\n@@ -425,7 +398,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n     };\n \n     // compute liveness\n-    let mut lsets = Liveness(fn_maps, specials);\n+    let mut lsets = Liveness(&mut fn_maps, specials);\n     let entry_ln = lsets.compute(decl, body);\n \n     // check for various error conditions\n@@ -434,12 +407,11 @@ fn visit_fn(v: &mut LivenessVisitor,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(v: &mut LivenessVisitor, local: &Local, this: @IrMaps) {\n-    let def_map = this.tcx.def_map;\n-    pat_util::pat_bindings(def_map, local.pat, |bm, p_id, sp, path| {\n+fn visit_local(ir: &mut IrMaps, local: &Local) {\n+    pat_util::pat_bindings(ir.tcx.def_map, local.pat, |bm, p_id, sp, path| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = ast_util::path_to_ident(path);\n-        this.add_live_node_for_node(p_id, VarDefNode(sp));\n+        ir.add_live_node_for_node(p_id, VarDefNode(sp));\n         let kind = match local.init {\n           Some(_) => FromLetWithInitializer,\n           None => FromLetNoInitializer\n@@ -448,67 +420,63 @@ fn visit_local(v: &mut LivenessVisitor, local: &Local, this: @IrMaps) {\n             BindByValue(MutMutable) => true,\n             _ => false\n         };\n-        this.add_variable(Local(LocalInfo {\n+        ir.add_variable(Local(LocalInfo {\n           id: p_id,\n           ident: name,\n           is_mutbl: mutbl,\n           kind: kind\n         }));\n     });\n-    visit::walk_local(v, local, this);\n+    visit::walk_local(ir, local, ());\n }\n \n-fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @IrMaps) {\n-    let def_map = this.tcx.def_map;\n+fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n     for pat in arm.pats.iter() {\n-        pat_util::pat_bindings(def_map, *pat, |bm, p_id, sp, path| {\n+        pat_util::pat_bindings(ir.tcx.def_map, *pat, |bm, p_id, sp, path| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n             let mutbl = match bm {\n                 BindByValue(MutMutable) => true,\n                 _ => false\n             };\n-            this.add_live_node_for_node(p_id, VarDefNode(sp));\n-            this.add_variable(Local(LocalInfo {\n+            ir.add_live_node_for_node(p_id, VarDefNode(sp));\n+            ir.add_variable(Local(LocalInfo {\n                 id: p_id,\n                 ident: name,\n                 is_mutbl: mutbl,\n                 kind: FromMatch(bm)\n             }));\n         })\n     }\n-    visit::walk_arm(v, arm, this);\n+    visit::walk_arm(ir, arm, ());\n }\n \n-fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n+fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) => {\n-        let def_map = this.tcx.def_map.borrow();\n-        let def = def_map.get().get_copy(&expr.id);\n+        let def = ir.tcx.def_map.borrow().get().get_copy(&expr.id);\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if moves::moved_variable_node_id_from_def(def).is_some() {\n-            this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+            ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n-        visit::walk_expr(v, expr, this);\n+        visit::walk_expr(ir, expr, ());\n       }\n       ExprFnBlock(..) | ExprProc(..) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n-        this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n \n         // Make a live_node for each captured variable, with the span\n         // being the location that the variable is used.  This results\n         // in better error messages than just pointing at the closure\n         // construction site.\n-        let capture_map = this.capture_map.borrow();\n-        let cvs = capture_map.get().get(&expr.id);\n         let mut call_caps = Vec::new();\n-        for cv in cvs.deref().iter() {\n+        for cv in ir.capture_map.borrow().get().get(&expr.id).deref().iter() {\n             match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n-                let cv_ln = this.add_live_node(FreeVarNode(cv.span));\n+                let cv_ln = ir.add_live_node(FreeVarNode(cv.span));\n                 let is_move = match cv.mode {\n                     // var must be dead afterwards\n                     moves::CapMove => true,\n@@ -523,20 +491,20 @@ fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n               None => {}\n             }\n         }\n-        this.set_captures(expr.id, call_caps);\n+        ir.set_captures(expr.id, call_caps);\n \n-        visit::walk_expr(v, expr, this);\n+        visit::walk_expr(ir, expr, ());\n       }\n \n       // live nodes required for interesting control flow:\n       ExprIf(..) | ExprMatch(..) | ExprWhile(..) | ExprLoop(..) => {\n-        this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::walk_expr(v, expr, this);\n+        ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        visit::walk_expr(ir, expr, ());\n       }\n       ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n       ExprBinary(op, _, _) if ast_util::lazy_binop(op) => {\n-        this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::walk_expr(v, expr, this);\n+        ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        visit::walk_expr(ir, expr, ());\n       }\n \n       // otherwise, live nodes are not required:\n@@ -548,7 +516,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n       ExprAssign(..) | ExprAssignOp(..) | ExprMac(..) |\n       ExprStruct(..) | ExprRepeat(..) | ExprParen(..) |\n       ExprInlineAsm(..) | ExprBox(..) => {\n-          visit::walk_expr(v, expr, this);\n+          visit::walk_expr(ir, expr, ());\n       }\n     }\n }\n@@ -560,7 +528,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n // the same basic propagation framework in all cases.\n \n #[deriving(Clone)]\n-pub struct Users {\n+struct Users {\n     reader: LiveNode,\n     writer: LiveNode,\n     used: bool\n@@ -574,7 +542,7 @@ fn invalid_users() -> Users {\n     }\n }\n \n-pub struct Specials {\n+struct Specials {\n     exit_ln: LiveNode,\n     fallthrough_ln: LiveNode,\n     no_ret_var: Variable\n@@ -584,76 +552,66 @@ static ACC_READ: uint = 1u;\n static ACC_WRITE: uint = 2u;\n static ACC_USE: uint = 4u;\n \n-pub type LiveNodeMap = @RefCell<NodeMap<LiveNode>>;\n-\n-pub struct Liveness<'a> {\n-    tcx: &'a ty::ctxt,\n-    ir: @IrMaps<'a>,\n+struct Liveness<'a> {\n+    ir: &'a mut IrMaps<'a>,\n     s: Specials,\n-    successors: @RefCell<Vec<LiveNode> >,\n-    users: @RefCell<Vec<Users> >,\n+    successors: Vec<LiveNode>,\n+    users: Vec<Users>,\n     // The list of node IDs for the nested loop scopes\n     // we're in.\n-    loop_scope: @RefCell<Vec<NodeId> >,\n+    loop_scope: Vec<NodeId>,\n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n     // it probably doesn't now)\n-    break_ln: LiveNodeMap,\n-    cont_ln: LiveNodeMap\n+    break_ln: NodeMap<LiveNode>,\n+    cont_ln: NodeMap<LiveNode>\n }\n \n-fn Liveness<'a>(ir: @IrMaps<'a>, specials: Specials) -> Liveness<'a> {\n+fn Liveness<'a>(ir: &'a mut IrMaps<'a>, specials: Specials) -> Liveness<'a> {\n     Liveness {\n         ir: ir,\n-        tcx: ir.tcx,\n         s: specials,\n-        successors: @RefCell::new(Vec::from_elem(ir.num_live_nodes.get(),\n-                                                 invalid_node())),\n-        users: @RefCell::new(Vec::from_elem(ir.num_live_nodes.get() *\n-                                            ir.num_vars.get(),\n-                                            invalid_users())),\n-        loop_scope: @RefCell::new(Vec::new()),\n-        break_ln: @RefCell::new(NodeMap::new()),\n-        cont_ln: @RefCell::new(NodeMap::new()),\n+        successors: Vec::from_elem(ir.num_live_nodes, invalid_node()),\n+        users: Vec::from_elem(ir.num_live_nodes * ir.num_vars, invalid_users()),\n+        loop_scope: Vec::new(),\n+        break_ln: NodeMap::new(),\n+        cont_ln: NodeMap::new(),\n     }\n }\n \n impl<'a> Liveness<'a> {\n-    pub fn live_node(&self, node_id: NodeId, span: Span) -> LiveNode {\n-        let ir: &IrMaps = self.ir;\n-        let live_node_map = ir.live_node_map.borrow();\n-        match live_node_map.get().find(&node_id) {\n+    fn live_node(&self, node_id: NodeId, span: Span) -> LiveNode {\n+        match self.ir.live_node_map.find(&node_id) {\n           Some(&ln) => ln,\n           None => {\n             // This must be a mismatch between the ir_map construction\n             // above and the propagation code below; the two sets of\n             // code have to agree about which AST nodes are worth\n             // creating liveness nodes for.\n-            self.tcx.sess.span_bug(\n+            self.ir.tcx.sess.span_bug(\n                 span, format!(\"no live node registered for node {}\",\n                            node_id));\n           }\n         }\n     }\n \n-    pub fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n+    fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n         self.ir.variable(node_id, span)\n     }\n \n-    pub fn pat_bindings(&self,\n-                        pat: @Pat,\n-                        f: |LiveNode, Variable, Span, NodeId|) {\n-        let def_map = self.tcx.def_map;\n-        pat_util::pat_bindings(def_map, pat, |_bm, p_id, sp, _n| {\n+    fn pat_bindings(&mut self,\n+                    pat: &Pat,\n+                    f: |&mut Liveness<'a>, LiveNode, Variable, Span, NodeId|) {\n+        pat_util::pat_bindings(self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n-            f(ln, var, sp, p_id);\n+            f(self, ln, var, sp, p_id);\n         })\n     }\n \n-    pub fn arm_pats_bindings(&self,\n-                             pats: &[@Pat],\n-                             f: |LiveNode, Variable, Span, NodeId|) {\n+    fn arm_pats_bindings(&mut self,\n+                         pats: &[@Pat],\n+                         f: |&mut Liveness<'a>, LiveNode, Variable, Span, NodeId|) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoratative\" set of ids\n@@ -662,86 +620,77 @@ impl<'a> Liveness<'a> {\n         }\n     }\n \n-    pub fn define_bindings_in_pat(&self, pat: @Pat, succ: LiveNode)\n-                                  -> LiveNode {\n+    fn define_bindings_in_pat(&mut self, pat: @Pat, succ: LiveNode)\n+                              -> LiveNode {\n         self.define_bindings_in_arm_pats([pat], succ)\n     }\n \n-    pub fn define_bindings_in_arm_pats(&self, pats: &[@Pat], succ: LiveNode)\n-                                       -> LiveNode {\n+    fn define_bindings_in_arm_pats(&mut self, pats: &[@Pat], succ: LiveNode)\n+                                   -> LiveNode {\n         let mut succ = succ;\n-        self.arm_pats_bindings(pats, |ln, var, _sp, _id| {\n-            self.init_from_succ(ln, succ);\n-            self.define(ln, var);\n+        self.arm_pats_bindings(pats, |this, ln, var, _sp, _id| {\n+            this.init_from_succ(ln, succ);\n+            this.define(ln, var);\n             succ = ln;\n         });\n         succ\n     }\n \n-    pub fn idx(&self, ln: LiveNode, var: Variable) -> uint {\n-        ln.get() * self.ir.num_vars.get() + var.get()\n+    fn idx(&self, ln: LiveNode, var: Variable) -> uint {\n+        ln.get() * self.ir.num_vars + var.get()\n     }\n \n-    pub fn live_on_entry(&self, ln: LiveNode, var: Variable)\n-                         -> Option<LiveNodeKind> {\n+    fn live_on_entry(&self, ln: LiveNode, var: Variable)\n+                      -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let users = self.users.borrow();\n-        let reader = users.get().get(self.idx(ln, var)).reader;\n+        let reader = self.users.get(self.idx(ln, var)).reader;\n         if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n     }\n \n     /*\n     Is this variable live on entry to any of its successor nodes?\n     */\n-    pub fn live_on_exit(&self, ln: LiveNode, var: Variable)\n-                        -> Option<LiveNodeKind> {\n-        let successor = {\n-            let successors = self.successors.borrow();\n-            *successors.get().get(ln.get())\n-        };\n+    fn live_on_exit(&self, ln: LiveNode, var: Variable)\n+                    -> Option<LiveNodeKind> {\n+        let successor = *self.successors.get(ln.get());\n         self.live_on_entry(successor, var)\n     }\n \n-    pub fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n+    fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n         assert!(ln.is_valid());\n-        let users = self.users.borrow();\n-        users.get().get(self.idx(ln, var)).used\n+        self.users.get(self.idx(ln, var)).used\n     }\n \n-    pub fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n-                             -> Option<LiveNodeKind> {\n+    fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n+                         -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let users = self.users.borrow();\n-        let writer = users.get().get(self.idx(ln, var)).writer;\n+        let writer = self.users.get(self.idx(ln, var)).writer;\n         if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n \n-    pub fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n-                            -> Option<LiveNodeKind> {\n-        let successor = {\n-            let successors = self.successors.borrow();\n-            *successors.get().get(ln.get())\n-        };\n+    fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n+                        -> Option<LiveNodeKind> {\n+        let successor = *self.successors.get(ln.get());\n         self.assigned_on_entry(successor, var)\n     }\n \n-    pub fn indices2(&self,\n-                    ln: LiveNode,\n-                    succ_ln: LiveNode,\n-                    op: |uint, uint|) {\n+    fn indices2(&mut self,\n+                ln: LiveNode,\n+                succ_ln: LiveNode,\n+                op: |&mut Liveness<'a>, uint, uint|) {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n-        for var_idx in range(0u, self.ir.num_vars.get()) {\n-            op(node_base_idx + var_idx, succ_base_idx + var_idx);\n+        for var_idx in range(0u, self.ir.num_vars) {\n+            op(self, node_base_idx + var_idx, succ_base_idx + var_idx);\n         }\n     }\n \n-    pub fn write_vars(&self,\n-                      wr: &mut io::Writer,\n-                      ln: LiveNode,\n-                      test: |uint| -> LiveNode) -> io::IoResult<()> {\n+    fn write_vars(&self,\n+                  wr: &mut io::Writer,\n+                  ln: LiveNode,\n+                  test: |uint| -> LiveNode) -> io::IoResult<()> {\n         let node_base_idx = self.idx(ln, Variable(0));\n-        for var_idx in range(0u, self.ir.num_vars.get()) {\n+        for var_idx in range(0u, self.ir.num_vars) {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n                 try!(write!(wr, \" {}\", Variable(var_idx).to_str()));\n@@ -750,28 +699,26 @@ impl<'a> Liveness<'a> {\n         Ok(())\n     }\n \n-    pub fn find_loop_scope(&self,\n-                           opt_label: Option<Ident>,\n-                           id: NodeId,\n-                           sp: Span)\n-                           -> NodeId {\n+    fn find_loop_scope(&self,\n+                       opt_label: Option<Ident>,\n+                       id: NodeId,\n+                       sp: Span)\n+                       -> NodeId {\n         match opt_label {\n             Some(_) => {\n                 // Refers to a labeled loop. Use the results of resolve\n                 // to find with one\n-                let def_map = self.tcx.def_map.borrow();\n-                match def_map.get().find(&id) {\n+                match self.ir.tcx.def_map.borrow().get().find(&id) {\n                     Some(&DefLabel(loop_id)) => loop_id,\n-                    _ => self.tcx.sess.span_bug(sp, \"label on break/loop \\\n-                                                     doesn't refer to a loop\")\n+                    _ => self.ir.tcx.sess.span_bug(sp, \"label on break/loop \\\n+                                                        doesn't refer to a loop\")\n                 }\n             }\n             None => {\n                 // Vanilla 'break' or 'loop', so use the enclosing\n                 // loop scope\n-                let loop_scope = self.loop_scope.borrow();\n-                if loop_scope.get().len() == 0 {\n-                    self.tcx.sess.span_bug(sp, \"break outside loop\");\n+                if self.loop_scope.len() == 0 {\n+                    self.ir.tcx.sess.span_bug(sp, \"break outside loop\");\n                 } else {\n                     // FIXME(#5275): this shouldn't have to be a method...\n                     self.last_loop_scope()\n@@ -780,54 +727,26 @@ impl<'a> Liveness<'a> {\n         }\n     }\n \n-    pub fn last_loop_scope(&self) -> NodeId {\n-        let loop_scope = self.loop_scope.borrow();\n-        *loop_scope.get().last().unwrap()\n+    fn last_loop_scope(&self) -> NodeId {\n+        *self.loop_scope.last().unwrap()\n     }\n \n     #[allow(unused_must_use)]\n-    pub fn ln_str(&self, ln: LiveNode) -> ~str {\n+    fn ln_str(&self, ln: LiveNode) -> ~str {\n         let mut wr = io::MemWriter::new();\n         {\n             let wr = &mut wr as &mut io::Writer;\n-            {\n-                let lnks = self.ir.lnks.try_borrow();\n-                write!(wr,\n-                       \"[ln({}) of kind {:?} reads\",\n-                       ln.get(),\n-                       lnks.and_then(|lnks| Some(*lnks.get().get(ln.get()))));\n-            }\n-            let users = self.users.try_borrow();\n-            match users {\n-                Some(users) => {\n-                    self.write_vars(wr, ln, |idx| users.get().get(idx).reader);\n-                    write!(wr, \"  writes\");\n-                    self.write_vars(wr, ln, |idx| users.get().get(idx).writer);\n-                }\n-                None => {\n-                    write!(wr, \"  (users borrowed)\");\n-                }\n-            }\n-            let successors = self.successors.try_borrow();\n-            match successors {\n-                Some(successors) => {\n-                    write!(wr,\n-                           \"  precedes {}]\",\n-                           successors.get().get(ln.get()).to_str());\n-                }\n-                None => {\n-                    write!(wr, \"  precedes (successors borrowed)]\");\n-                }\n-            }\n+            write!(wr, \"[ln({}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n+            self.write_vars(wr, ln, |idx| self.users.get(idx).reader);\n+            write!(wr, \"  writes\");\n+            self.write_vars(wr, ln, |idx| self.users.get(idx).writer);\n+            write!(wr, \"  precedes {}]\", self.successors.get(ln.get()).to_str());\n         }\n         str::from_utf8_owned(wr.unwrap()).unwrap()\n     }\n \n-    pub fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {\n-        {\n-            let mut successors = self.successors.borrow_mut();\n-            *successors.get().get_mut(ln.get()) = succ_ln;\n-        }\n+    fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n+        *self.successors.get_mut(ln.get()) = succ_ln;\n \n         // It is not necessary to initialize the\n         // values to empty because this is the value\n@@ -839,37 +758,32 @@ impl<'a> Liveness<'a> {\n         // }\n     }\n \n-    pub fn init_from_succ(&self, ln: LiveNode, succ_ln: LiveNode) {\n+    fn init_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n-        {\n-            let mut successors = self.successors.borrow_mut();\n-            *successors.get().get_mut(ln.get()) = succ_ln;\n-        }\n+        *self.successors.get_mut(ln.get()) = succ_ln;\n \n-        self.indices2(ln, succ_ln, |idx, succ_idx| {\n-            let mut users = self.users.borrow_mut();\n-            *users.get().get_mut(idx) = *users.get().get(succ_idx)\n+        self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n+            *this.users.get_mut(idx) = *this.users.get(succ_idx)\n         });\n         debug!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n     }\n \n-    pub fn merge_from_succ(&self,\n-                           ln: LiveNode,\n-                           succ_ln: LiveNode,\n-                           first_merge: bool)\n-                           -> bool {\n+    fn merge_from_succ(&mut self,\n+                       ln: LiveNode,\n+                       succ_ln: LiveNode,\n+                       first_merge: bool)\n+                       -> bool {\n         if ln == succ_ln { return false; }\n \n         let mut changed = false;\n-        self.indices2(ln, succ_ln, |idx, succ_idx| {\n-            let mut users = self.users.borrow_mut();\n-            changed |= copy_if_invalid(users.get().get(succ_idx).reader,\n-                                       &mut users.get().get_mut(idx).reader);\n-            changed |= copy_if_invalid(users.get().get(succ_idx).writer,\n-                                       &mut users.get().get_mut(idx).writer);\n-            if users.get().get(succ_idx).used && !users.get().get(idx).used {\n-                users.get().get_mut(idx).used = true;\n+        self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n+            changed |= copy_if_invalid(this.users.get(succ_idx).reader,\n+                                       &mut this.users.get_mut(idx).reader);\n+            changed |= copy_if_invalid(this.users.get(succ_idx).writer,\n+                                       &mut this.users.get_mut(idx).writer);\n+            if this.users.get(succ_idx).used && !this.users.get(idx).used {\n+                this.users.get_mut(idx).used = true;\n                 changed = true;\n             }\n         });\n@@ -879,34 +793,34 @@ impl<'a> Liveness<'a> {\n         return changed;\n \n         fn copy_if_invalid(src: LiveNode, dst: &mut LiveNode) -> bool {\n-            if src.is_valid() {\n-                if !dst.is_valid() {\n-                    *dst = src;\n-                    return true;\n-                }\n+            if src.is_valid() && !dst.is_valid() {\n+                *dst = src;\n+                true\n+            } else {\n+                false\n             }\n-            return false;\n         }\n     }\n \n     // Indicates that a local variable was *defined*; we know that no\n     // uses of the variable can precede the definition (resolve checks\n     // this) so we just clear out all the data.\n-    pub fn define(&self, writer: LiveNode, var: Variable) {\n+    fn define(&mut self, writer: LiveNode, var: Variable) {\n         let idx = self.idx(writer, var);\n-        let mut users = self.users.borrow_mut();\n-        users.get().get_mut(idx).reader = invalid_node();\n-        users.get().get_mut(idx).writer = invalid_node();\n+        self.users.get_mut(idx).reader = invalid_node();\n+        self.users.get_mut(idx).writer = invalid_node();\n \n         debug!(\"{} defines {} (idx={}): {}\", writer.to_str(), var.to_str(),\n                idx, self.ln_str(writer));\n     }\n \n     // Either read, write, or both depending on the acc bitset\n-    pub fn acc(&self, ln: LiveNode, var: Variable, acc: uint) {\n+    fn acc(&mut self, ln: LiveNode, var: Variable, acc: uint) {\n+        debug!(\"{} accesses[{:x}] {}: {}\",\n+               ln.to_str(), acc, var.to_str(), self.ln_str(ln));\n+\n         let idx = self.idx(ln, var);\n-        let mut users = self.users.borrow_mut();\n-        let user = users.get().get_mut(idx);\n+        let user = self.users.get_mut(idx);\n \n         if (acc & ACC_WRITE) != 0 {\n             user.reader = invalid_node();\n@@ -922,14 +836,11 @@ impl<'a> Liveness<'a> {\n         if (acc & ACC_USE) != 0 {\n             user.used = true;\n         }\n-\n-        debug!(\"{} accesses[{:x}] {}: {}\",\n-               ln.to_str(), acc, var.to_str(), self.ln_str(ln));\n     }\n \n     // _______________________________________________________________________\n \n-    pub fn compute(&self, decl: &FnDecl, body: &Block) -> LiveNode {\n+    fn compute(&mut self, decl: &FnDecl, body: &Block) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n@@ -938,12 +849,12 @@ impl<'a> Liveness<'a> {\n \n         let entry_ln: LiveNode =\n             self.with_loop_nodes(body.id, self.s.exit_ln, self.s.exit_ln,\n-              || { self.propagate_through_fn_block(decl, body) });\n+              |this| this.propagate_through_fn_block(decl, body));\n \n         // hack to skip the loop unless debug! is enabled:\n         debug!(\"^^ liveness computation results for body {} (entry={})\",\n                {\n-                   for ln_idx in range(0u, self.ir.num_live_nodes.get()) {\n+                   for ln_idx in range(0u, self.ir.num_live_nodes) {\n                        debug!(\"{}\", self.ln_str(LiveNode(ln_idx)));\n                    }\n                    body.id\n@@ -953,8 +864,8 @@ impl<'a> Liveness<'a> {\n         entry_ln\n     }\n \n-    pub fn propagate_through_fn_block(&self, _: &FnDecl, blk: &Block)\n-                                      -> LiveNode {\n+    fn propagate_through_fn_block(&mut self, _: &FnDecl, blk: &Block)\n+                                  -> LiveNode {\n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n         self.init_from_succ(self.s.fallthrough_ln, self.s.exit_ln);\n@@ -965,33 +876,33 @@ impl<'a> Liveness<'a> {\n         self.propagate_through_block(blk, self.s.fallthrough_ln)\n     }\n \n-    pub fn propagate_through_block(&self, blk: &Block, succ: LiveNode)\n-                                   -> LiveNode {\n+    fn propagate_through_block(&mut self, blk: &Block, succ: LiveNode)\n+                               -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.expr, succ);\n         blk.stmts.rev_iter().fold(succ, |succ, stmt| {\n             self.propagate_through_stmt(*stmt, succ)\n         })\n     }\n \n-    pub fn propagate_through_stmt(&self, stmt: &Stmt, succ: LiveNode)\n-                                  -> LiveNode {\n+    fn propagate_through_stmt(&mut self, stmt: &Stmt, succ: LiveNode)\n+                              -> LiveNode {\n         match stmt.node {\n-          StmtDecl(decl, _) => {\n-            return self.propagate_through_decl(decl, succ);\n-          }\n+            StmtDecl(decl, _) => {\n+                self.propagate_through_decl(decl, succ)\n+            }\n \n-          StmtExpr(expr, _) | StmtSemi(expr, _) => {\n-            return self.propagate_through_expr(expr, succ);\n-          }\n+            StmtExpr(expr, _) | StmtSemi(expr, _) => {\n+                self.propagate_through_expr(expr, succ)\n+            }\n \n-          StmtMac(..) => {\n-            self.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n-          }\n+            StmtMac(..) => {\n+                self.ir.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n+            }\n         }\n     }\n \n-    pub fn propagate_through_decl(&self, decl: &Decl, succ: LiveNode)\n-                                  -> LiveNode {\n+    fn propagate_through_decl(&mut self, decl: &Decl, succ: LiveNode)\n+                              -> LiveNode {\n         match decl.node {\n             DeclLocal(ref local) => {\n                 self.propagate_through_local(*local, succ)\n@@ -1000,8 +911,8 @@ impl<'a> Liveness<'a> {\n         }\n     }\n \n-    pub fn propagate_through_local(&self, local: &Local, succ: LiveNode)\n-                                   -> LiveNode {\n+    fn propagate_through_local(&mut self, local: &Local, succ: LiveNode)\n+                               -> LiveNode {\n         // Note: we mark the variable as defined regardless of whether\n         // there is an initializer.  Initially I had thought to only mark\n         // the live variable as defined if it was initialized, and then we\n@@ -1020,24 +931,24 @@ impl<'a> Liveness<'a> {\n         self.define_bindings_in_pat(local.pat, succ)\n     }\n \n-    pub fn propagate_through_exprs(&self, exprs: &[@Expr], succ: LiveNode)\n-                                   -> LiveNode {\n+    fn propagate_through_exprs(&mut self, exprs: &[@Expr], succ: LiveNode)\n+                               -> LiveNode {\n         exprs.rev_iter().fold(succ, |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n         })\n     }\n \n-    pub fn propagate_through_opt_expr(&self,\n-                                      opt_expr: Option<@Expr>,\n-                                      succ: LiveNode)\n-                                      -> LiveNode {\n+    fn propagate_through_opt_expr(&mut self,\n+                                  opt_expr: Option<@Expr>,\n+                                  succ: LiveNode)\n+                                  -> LiveNode {\n         opt_expr.iter().fold(succ, |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n         })\n     }\n \n-    pub fn propagate_through_expr(&self, expr: @Expr, succ: LiveNode)\n-                                  -> LiveNode {\n+    fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode)\n+                              -> LiveNode {\n         debug!(\"propagate_through_expr: {}\", expr_to_str(expr));\n \n         match expr.node {\n@@ -1058,16 +969,21 @@ impl<'a> Liveness<'a> {\n               The next-node for a break is the successor of the entire\n               loop. The next-node for a continue is the top of this loop.\n               */\n-              self.with_loop_nodes(blk.id, succ,\n-                  self.live_node(expr.id, expr.span), || {\n+              let node = self.live_node(expr.id, expr.span);\n+              self.with_loop_nodes(blk.id, succ, node, |this| {\n \n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n-                 let caps = self.ir.captures(expr);\n-                 caps.rev_iter().fold(succ, |succ, cap| {\n-                     self.init_from_succ(cap.ln, succ);\n-                     let var = self.variable(cap.var_nid, expr.span);\n-                     self.acc(cap.ln, var, ACC_READ | ACC_USE);\n+                 let caps = match this.ir.capture_info_map.find(&expr.id) {\n+                    Some(caps) => caps.clone(),\n+                    None => {\n+                        this.ir.tcx.sess.span_bug(expr.span, \"no registered caps\");\n+                     }\n+                 };\n+                 caps.deref().rev_iter().fold(succ, |succ, cap| {\n+                     this.init_from_succ(cap.ln, succ);\n+                     let var = this.variable(cap.var_nid, expr.span);\n+                     this.acc(cap.ln, var, ACC_READ | ACC_USE);\n                      cap.ln\n                  })\n               })\n@@ -1151,11 +1067,10 @@ impl<'a> Liveness<'a> {\n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n \n-              let break_ln = self.break_ln.borrow();\n-              match break_ln.get().find(&sc) {\n+              match self.break_ln.find(&sc) {\n                   Some(&b) => b,\n-                  None => self.tcx.sess.span_bug(expr.span,\n-                                                 \"break to unknown label\")\n+                  None => self.ir.tcx.sess.span_bug(expr.span,\n+                                                    \"break to unknown label\")\n               }\n           }\n \n@@ -1166,11 +1081,10 @@ impl<'a> Liveness<'a> {\n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n \n-              let cont_ln = self.cont_ln.borrow();\n-              match cont_ln.get().find(&sc) {\n+              match self.cont_ln.find(&sc) {\n                   Some(&b) => b,\n-                  None => self.tcx.sess.span_bug(expr.span,\n-                                                 \"loop to unknown label\")\n+                  None => self.ir.tcx.sess.span_bug(expr.span,\n+                                                    \"loop to unknown label\")\n               }\n           }\n \n@@ -1215,7 +1129,7 @@ impl<'a> Liveness<'a> {\n           ExprCall(f, ref args) => {\n             // calling a fn with bot return type means that the fn\n             // will fail, and hence the successors can be ignored\n-            let t_ret = ty::ty_fn_ret(ty::expr_ty(self.tcx, f));\n+            let t_ret = ty::ty_fn_ret(ty::expr_ty(self.ir.tcx, f));\n             let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n                        else {succ};\n             let succ = self.propagate_through_exprs(args.as_slice(), succ);\n@@ -1225,7 +1139,7 @@ impl<'a> Liveness<'a> {\n           ExprMethodCall(_, _, ref args) => {\n             // calling a method with bot return type means that the method\n             // will fail, and hence the successors can be ignored\n-            let t_ret = ty::node_id_to_type(self.tcx, expr.id);\n+            let t_ret = ty::node_id_to_type(self.ir.tcx, expr.id);\n             let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n                        else {succ};\n             self.propagate_through_exprs(args.as_slice(), succ)\n@@ -1280,15 +1194,15 @@ impl<'a> Liveness<'a> {\n           }\n \n           ExprMac(..) => {\n-            self.tcx.sess.span_bug(expr.span, \"unexpanded macro\");\n+            self.ir.tcx.sess.span_bug(expr.span, \"unexpanded macro\");\n           }\n         }\n     }\n \n-    pub fn propagate_through_lvalue_components(&self,\n-                                               expr: @Expr,\n-                                               succ: LiveNode)\n-                                               -> LiveNode {\n+    fn propagate_through_lvalue_components(&mut self,\n+                                           expr: &Expr,\n+                                           succ: LiveNode)\n+                                           -> LiveNode {\n         // # Lvalues\n         //\n         // In general, the full flow graph structure for an\n@@ -1346,8 +1260,8 @@ impl<'a> Liveness<'a> {\n     }\n \n     // see comment on propagate_through_lvalue()\n-    pub fn write_lvalue(&self, expr: &Expr, succ: LiveNode, acc: uint)\n-                        -> LiveNode {\n+    fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n+                    -> LiveNode {\n         match expr.node {\n           ExprPath(_) => self.access_path(expr, succ, acc),\n \n@@ -1359,10 +1273,9 @@ impl<'a> Liveness<'a> {\n         }\n     }\n \n-    pub fn access_path(&self, expr: &Expr, succ: LiveNode, acc: uint)\n-                       -> LiveNode {\n-        let def_map = self.tcx.def_map.borrow();\n-        let def = def_map.get().get_copy(&expr.id);\n+    fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n+                   -> LiveNode {\n+        let def = self.ir.tcx.def_map.borrow().get().get_copy(&expr.id);\n         match moves::moved_variable_node_id_from_def(def) {\n           Some(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n@@ -1377,12 +1290,12 @@ impl<'a> Liveness<'a> {\n         }\n     }\n \n-    pub fn propagate_through_loop(&self,\n-                                  expr: &Expr,\n-                                  cond: Option<@Expr>,\n-                                  body: &Block,\n-                                  succ: LiveNode)\n-                                  -> LiveNode {\n+    fn propagate_through_loop(&mut self,\n+                              expr: &Expr,\n+                              cond: Option<@Expr>,\n+                              body: &Block,\n+                              succ: LiveNode)\n+                              -> LiveNode {\n \n         /*\n \n@@ -1418,8 +1331,8 @@ impl<'a> Liveness<'a> {\n                expr.id, block_to_str(body));\n \n         let cond_ln = self.propagate_through_opt_expr(cond, ln);\n-        let body_ln = self.with_loop_nodes(expr.id, succ, ln, || {\n-            self.propagate_through_block(body, cond_ln)\n+        let body_ln = self.with_loop_nodes(expr.id, succ, ln, |this| {\n+            this.propagate_through_block(body, cond_ln)\n         });\n \n         // repeat until fixed point is reached:\n@@ -1428,37 +1341,24 @@ impl<'a> Liveness<'a> {\n             assert!(cond_ln == self.propagate_through_opt_expr(cond,\n                                                                     ln));\n             assert!(body_ln == self.with_loop_nodes(expr.id, succ, ln,\n-            || {\n-                self.propagate_through_block(body, cond_ln)\n-            }));\n+            |this| this.propagate_through_block(body, cond_ln)));\n         }\n \n         cond_ln\n     }\n \n-    pub fn with_loop_nodes<R>(\n-                           &self,\n-                           loop_node_id: NodeId,\n-                           break_ln: LiveNode,\n-                           cont_ln: LiveNode,\n-                           f: || -> R)\n-                           -> R {\n+    fn with_loop_nodes<R>(&mut self,\n+                          loop_node_id: NodeId,\n+                          break_ln: LiveNode,\n+                          cont_ln: LiveNode,\n+                          f: |&mut Liveness<'a>| -> R)\n+                          -> R {\n         debug!(\"with_loop_nodes: {} {}\", loop_node_id, break_ln.get());\n-        {\n-            let mut loop_scope = self.loop_scope.borrow_mut();\n-            loop_scope.get().push(loop_node_id);\n-        }\n-        {\n-            let mut this_break_ln = self.break_ln.borrow_mut();\n-            let mut this_cont_ln = self.cont_ln.borrow_mut();\n-            this_break_ln.get().insert(loop_node_id, break_ln);\n-            this_cont_ln.get().insert(loop_node_id, cont_ln);\n-        }\n-        let r = f();\n-        {\n-            let mut loop_scope = self.loop_scope.borrow_mut();\n-            loop_scope.get().pop();\n-        }\n+        self.loop_scope.push(loop_node_id);\n+        self.break_ln.insert(loop_node_id, break_ln);\n+        self.cont_ln.insert(loop_node_id, cont_ln);\n+        let r = f(self);\n+        self.loop_scope.pop();\n         r\n     }\n }\n@@ -1472,7 +1372,7 @@ fn check_local(this: &mut Liveness, local: &Local) {\n             this.warn_about_unused_or_dead_vars_in_pat(local.pat);\n         },\n         None => {\n-            this.pat_bindings(local.pat, |ln, var, sp, id| {\n+            this.pat_bindings(local.pat, |this, ln, var, sp, id| {\n                 this.warn_about_unused(sp, id, ln, var);\n             })\n         }\n@@ -1482,7 +1382,7 @@ fn check_local(this: &mut Liveness, local: &Local) {\n }\n \n fn check_arm(this: &mut Liveness, arm: &Arm) {\n-    this.arm_pats_bindings(arm.pats.as_slice(), |ln, var, sp, id| {\n+    this.arm_pats_bindings(arm.pats.as_slice(), |this, ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     });\n     visit::walk_arm(this, arm, ());\n@@ -1542,37 +1442,30 @@ fn check_fn(_v: &Liveness,\n     // do not check contents of nested fns\n }\n \n-pub enum ReadKind {\n-    PossiblyUninitializedVariable,\n-    PossiblyUninitializedField,\n-    MovedValue,\n-    PartiallyMovedValue\n-}\n-\n impl<'a> Liveness<'a> {\n-    pub fn check_ret(&self,\n-                     id: NodeId,\n-                     sp: Span,\n-                     _fk: &FnKind,\n-                     entry_ln: LiveNode,\n-                     body: &Block) {\n+    fn check_ret(&self,\n+                 id: NodeId,\n+                 sp: Span,\n+                 _fk: &FnKind,\n+                 entry_ln: LiveNode,\n+                 body: &Block) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n             // function without any kind of return expression:\n \n-            let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.tcx, id));\n+            let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.ir.tcx, id));\n             if ty::type_is_nil(t_ret) {\n                 // for nil return types, it is ok to not return a value expl.\n             } else if ty::type_is_bot(t_ret) {\n                 // for bot return types, not ok.  Function should fail.\n-                self.tcx.sess.span_err(\n+                self.ir.tcx.sess.span_err(\n                     sp, \"some control paths may return\");\n             } else {\n                 let ends_with_stmt = match body.expr {\n                     None if body.stmts.len() > 0 =>\n                         match body.stmts.last().unwrap().node {\n                             StmtSemi(e, _) => {\n-                                let t_stmt = ty::expr_ty(self.tcx, e);\n+                                let t_stmt = ty::expr_ty(self.ir.tcx, e);\n                                 ty::get(t_stmt).sty == ty::get(t_ret).sty\n                             },\n                             _ => false\n@@ -1586,20 +1479,19 @@ impl<'a> Liveness<'a> {\n                         hi: last_stmt.span.hi,\n                         expn_info: last_stmt.span.expn_info\n                     };\n-                    self.tcx.sess.span_note(\n+                    self.ir.tcx.sess.span_note(\n                         span_semicolon, \"consider removing this semicolon:\");\n                 }\n-                self.tcx.sess.span_err(\n+                self.ir.tcx.sess.span_err(\n                     sp, \"not all control paths return a value\");\n            }\n         }\n     }\n \n-    pub fn check_lvalue(&mut self, expr: @Expr) {\n+    fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n           ExprPath(_) => {\n-            let def_map = self.tcx.def_map.borrow();\n-            match def_map.get().get_copy(&expr.id) {\n+            match self.ir.tcx.def_map.borrow().get().get_copy(&expr.id) {\n               DefLocal(nid, _) => {\n                 // Assignment to an immutable variable or argument: only legal\n                 // if there is no later assignment. If this local is actually\n@@ -1630,14 +1522,14 @@ impl<'a> Liveness<'a> {\n        }\n     }\n \n-    pub fn should_warn(&self, var: Variable) -> Option<~str> {\n+    fn should_warn(&self, var: Variable) -> Option<~str> {\n         let name = self.ir.variable_name(var);\n         if name.len() == 0 || name[0] == ('_' as u8) { None } else { Some(name) }\n     }\n \n-    pub fn warn_about_unused_args(&self, decl: &FnDecl, entry_ln: LiveNode) {\n+    fn warn_about_unused_args(&self, decl: &FnDecl, entry_ln: LiveNode) {\n         for arg in decl.inputs.iter() {\n-            pat_util::pat_bindings(self.tcx.def_map,\n+            pat_util::pat_bindings(self.ir.tcx.def_map,\n                                    arg.pat,\n                                    |_bm, p_id, sp, path| {\n                 let var = self.variable(p_id, sp);\n@@ -1650,20 +1542,20 @@ impl<'a> Liveness<'a> {\n         }\n     }\n \n-    pub fn warn_about_unused_or_dead_vars_in_pat(&self, pat: @Pat) {\n-        self.pat_bindings(pat, |ln, var, sp, id| {\n-            if !self.warn_about_unused(sp, id, ln, var) {\n-                self.warn_about_dead_assign(sp, id, ln, var);\n+    fn warn_about_unused_or_dead_vars_in_pat(&mut self, pat: &Pat) {\n+        self.pat_bindings(pat, |this, ln, var, sp, id| {\n+            if !this.warn_about_unused(sp, id, ln, var) {\n+                this.warn_about_dead_assign(sp, id, ln, var);\n             }\n         })\n     }\n \n-    pub fn warn_about_unused(&self,\n-                             sp: Span,\n-                             id: NodeId,\n-                             ln: LiveNode,\n-                             var: Variable)\n-                             -> bool {\n+    fn warn_about_unused(&self,\n+                         sp: Span,\n+                         id: NodeId,\n+                         ln: LiveNode,\n+                         var: Variable)\n+                         -> bool {\n         if !self.used_on_entry(ln, var) {\n             let r = self.should_warn(var);\n             for name in r.iter() {\n@@ -1678,11 +1570,11 @@ impl<'a> Liveness<'a> {\n                 };\n \n                 if is_assigned {\n-                    self.tcx.sess.add_lint(UnusedVariable, id, sp,\n+                    self.ir.tcx.sess.add_lint(UnusedVariable, id, sp,\n                         format!(\"variable `{}` is assigned to, \\\n                                   but never used\", *name));\n                 } else {\n-                    self.tcx.sess.add_lint(UnusedVariable, id, sp,\n+                    self.ir.tcx.sess.add_lint(UnusedVariable, id, sp,\n                         format!(\"unused variable: `{}`\", *name));\n                 }\n             }\n@@ -1692,15 +1584,15 @@ impl<'a> Liveness<'a> {\n         }\n     }\n \n-    pub fn warn_about_dead_assign(&self,\n-                                  sp: Span,\n-                                  id: NodeId,\n-                                  ln: LiveNode,\n-                                  var: Variable) {\n+    fn warn_about_dead_assign(&self,\n+                              sp: Span,\n+                              id: NodeId,\n+                              ln: LiveNode,\n+                              var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n             let r = self.should_warn(var);\n             for name in r.iter() {\n-                self.tcx.sess.add_lint(DeadAssignment, id, sp,\n+                self.ir.tcx.sess.add_lint(DeadAssignment, id, sp,\n                     format!(\"value assigned to `{}` is never read\", *name));\n             }\n         }"}]}