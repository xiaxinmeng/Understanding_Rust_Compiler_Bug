{"sha": "2747923c272a355dbb6265586a884652e26b0ec7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NDc5MjNjMjcyYTM1NWRiYjYyNjU1ODZhODg0NjUyZTI2YjBlYzc=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-09-21T02:09:22Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-10-04T21:53:18Z"}, "message": "Rename Parser::last_span as prev_span.\n\nThis is a [breaking-change] for libsyntax.", "tree": {"sha": "a87686f4f87bde81c98cbef19ebb4b839a1018e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a87686f4f87bde81c98cbef19ebb4b839a1018e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2747923c272a355dbb6265586a884652e26b0ec7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2747923c272a355dbb6265586a884652e26b0ec7", "html_url": "https://github.com/rust-lang/rust/commit/2747923c272a355dbb6265586a884652e26b0ec7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2747923c272a355dbb6265586a884652e26b0ec7/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5dac7a2af3ee444817eb7bfbba3539be8c06cf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5dac7a2af3ee444817eb7bfbba3539be8c06cf1", "html_url": "https://github.com/rust-lang/rust/commit/a5dac7a2af3ee444817eb7bfbba3539be8c06cf1"}], "stats": {"total": 354, "additions": 175, "deletions": 179}, "files": [{"sha": "99fb23656e14045e5db0f50e237ae815a5d23f4c", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2747923c272a355dbb6265586a884652e26b0ec7/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2747923c272a355dbb6265586a884652e26b0ec7/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=2747923c272a355dbb6265586a884652e26b0ec7", "patch": "@@ -582,7 +582,7 @@ impl<'a> CrateReader<'a> {\n                     unreachable!();\n                 }\n             };\n-            let local_span = mk_sp(lo, p.last_span.hi);\n+            let local_span = mk_sp(lo, p.prev_span.hi);\n \n             // Mark the attrs as used\n             for attr in &def.attrs {"}, {"sha": "22c087aba80f11ea7abb6db8168f750d0c6fcb4f", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2747923c272a355dbb6265586a884652e26b0ec7/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2747923c272a355dbb6265586a884652e26b0ec7/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=2747923c272a355dbb6265586a884652e26b0ec7", "patch": "@@ -139,9 +139,9 @@ impl<'a> SpanUtils<'a> {\n         let mut prev = toks.real_token();\n         let mut result = None;\n         let mut bracket_count = 0;\n-        let mut last_span = None;\n+        let mut prev_span = None;\n         while prev.tok != token::Eof {\n-            last_span = None;\n+            prev_span = None;\n             let mut next = toks.real_token();\n \n             if (next.tok == token::OpenDelim(token::Paren) || next.tok == token::Lt) &&\n@@ -166,12 +166,12 @@ impl<'a> SpanUtils<'a> {\n             };\n \n             if prev.tok.is_ident() && bracket_count == 0 {\n-                last_span = Some(prev.sp);\n+                prev_span = Some(prev.sp);\n             }\n             prev = next;\n         }\n-        if result.is_none() && last_span.is_some() {\n-            return self.make_sub_span(span, last_span);\n+        if result.is_none() && prev_span.is_some() {\n+            return self.make_sub_span(span, prev_span);\n         }\n         return self.make_sub_span(span, result);\n     }"}, {"sha": "49012ad036a9a9211a43d6ac0855beee96eae1e5", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2747923c272a355dbb6265586a884652e26b0ec7/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2747923c272a355dbb6265586a884652e26b0ec7/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2747923c272a355dbb6265586a884652e26b0ec7", "patch": "@@ -804,7 +804,7 @@ impl CodeMap {\n     }\n \n     pub fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace> {\n-        let mut last_span = DUMMY_SP;\n+        let mut prev_span = DUMMY_SP;\n         let mut span = span;\n         let mut result = vec![];\n         loop {\n@@ -827,14 +827,14 @@ impl CodeMap {\n                 None => break,\n                 Some((call_site, macro_decl_name, def_site_span)) => {\n                     // Don't print recursive invocations\n-                    if !call_site.source_equal(&last_span) {\n+                    if !call_site.source_equal(&prev_span) {\n                         result.push(MacroBacktrace {\n                             call_site: call_site,\n                             macro_decl_name: macro_decl_name,\n                             def_site_span: def_site_span,\n                         });\n                     }\n-                    last_span = span;\n+                    prev_span = span;\n                     span = call_site;\n                 }\n             }"}, {"sha": "3cb34fa3c91c5a940e83e11f03bfcd72134abb37", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2747923c272a355dbb6265586a884652e26b0ec7/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2747923c272a355dbb6265586a884652e26b0ec7/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=2747923c272a355dbb6265586a884652e26b0ec7", "patch": "@@ -126,7 +126,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::OpenDelim(token::Bracket))?;\n                 let meta_item = self.parse_meta_item()?;\n                 self.expect(&token::CloseDelim(token::Bracket))?;\n-                let hi = self.last_span.hi;\n+                let hi = self.prev_span.hi;\n \n                 (mk_sp(lo, hi), meta_item, style)\n             }\n@@ -231,16 +231,16 @@ impl<'a> Parser<'a> {\n             token::Eq => {\n                 self.bump();\n                 let lit = self.parse_unsuffixed_lit()?;\n-                let hi = self.last_span.hi;\n+                let hi = self.prev_span.hi;\n                 Ok(P(spanned(lo, hi, ast::MetaItemKind::NameValue(name, lit))))\n             }\n             token::OpenDelim(token::Paren) => {\n                 let inner_items = self.parse_meta_seq()?;\n-                let hi = self.last_span.hi;\n+                let hi = self.prev_span.hi;\n                 Ok(P(spanned(lo, hi, ast::MetaItemKind::List(name, inner_items))))\n             }\n             _ => {\n-                let hi = self.last_span.hi;\n+                let hi = self.prev_span.hi;\n                 Ok(P(spanned(lo, hi, ast::MetaItemKind::Word(name))))\n             }\n         }\n@@ -253,14 +253,14 @@ impl<'a> Parser<'a> {\n \n         match self.parse_unsuffixed_lit() {\n             Ok(lit) => {\n-                return Ok(spanned(lo, self.last_span.hi, ast::NestedMetaItemKind::Literal(lit)))\n+                return Ok(spanned(lo, self.prev_span.hi, ast::NestedMetaItemKind::Literal(lit)))\n             }\n             Err(ref mut err) => self.diagnostic().cancel(err)\n         }\n \n         match self.parse_meta_item() {\n             Ok(mi) => {\n-                return Ok(spanned(lo, self.last_span.hi, ast::NestedMetaItemKind::MetaItem(mi)))\n+                return Ok(spanned(lo, self.prev_span.hi, ast::NestedMetaItemKind::MetaItem(mi)))\n             }\n             Err(ref mut err) => self.diagnostic().cancel(err)\n         }"}, {"sha": "1ecda9942966cd7f05bf57d4539f1f72ef0f9cf5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 154, "deletions": 158, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/2747923c272a355dbb6265586a884652e26b0ec7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2747923c272a355dbb6265586a884652e26b0ec7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2747923c272a355dbb6265586a884652e26b0ec7", "patch": "@@ -254,8 +254,8 @@ pub struct Parser<'a> {\n     pub token: token::Token,\n     /// the span of the current token:\n     pub span: Span,\n-    /// the span of the prior token:\n-    pub last_span: Span,\n+    /// the span of the previous token:\n+    pub prev_span: Span,\n     pub cfg: CrateConfig,\n     /// the previous token kind\n     last_token_kind: LastTokenKind,\n@@ -368,7 +368,7 @@ impl<'a> Parser<'a> {\n             cfg: cfg,\n             token: tok0.tok,\n             span: span,\n-            last_span: span,\n+            prev_span: span,\n             last_token_kind: LastTokenKind::Other,\n             buffer: [\n                 placeholder.clone(),\n@@ -414,8 +414,7 @@ impl<'a> Parser<'a> {\n \n     pub fn unexpected_last<T>(&self, t: &token::Token) -> PResult<'a, T> {\n         let token_str = Parser::token_to_string(t);\n-        let last_span = self.last_span;\n-        Err(self.span_fatal(last_span, &format!(\"unexpected token: `{}`\", token_str)))\n+        Err(self.span_fatal(self.prev_span, &format!(\"unexpected token: `{}`\", token_str)))\n     }\n \n     pub fn unexpected<T>(&mut self) -> PResult<'a, T> {\n@@ -506,7 +505,7 @@ impl<'a> Parser<'a> {\n                                  -> PResult<'a, (Span, P<Expr>)> {\n         expr.map(|e| {\n             if self.last_token_kind == LastTokenKind::Interpolated {\n-                (self.last_span, e)\n+                (self.prev_span, e)\n             } else {\n                 (e.span, e)\n             }\n@@ -526,7 +525,7 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 Err(if self.last_token_kind == LastTokenKind::DocComment {\n-                    self.span_fatal_help(self.last_span,\n+                    self.span_fatal_help(self.prev_span,\n                         \"found a documentation comment that doesn't document anything\",\n                         \"doc comments must come before what they document, maybe a comment was \\\n                         intended with `//`?\")\n@@ -928,7 +927,7 @@ impl<'a> Parser<'a> {\n             self.bug(\"attempted to bump the parser past EOF (may be stuck in a loop)\");\n         }\n \n-        self.last_span = self.span;\n+        self.prev_span = self.span;\n \n         // Record last token kind for possible error recovery.\n         self.last_token_kind = match self.token {\n@@ -974,7 +973,7 @@ impl<'a> Parser<'a> {\n                      next: token::Token,\n                      lo: BytePos,\n                      hi: BytePos) {\n-        self.last_span = mk_sp(self.span.lo, lo);\n+        self.prev_span = mk_sp(self.span.lo, lo);\n         // It would be incorrect to record the kind of the current token, but\n         // fortunately for tokens currently using `bump_with`, the\n         // last_token_kind will be of no use anyway.\n@@ -1114,8 +1113,7 @@ impl<'a> Parser<'a> {\n         let bounds = self.parse_ty_param_bounds(BoundParsingMode::Modified)?;\n \n         if !bounds.iter().any(|b| if let TraitTyParamBound(..) = *b { true } else { false }) {\n-            let last_span = self.last_span;\n-            self.span_err(last_span, \"at least one trait must be specified\");\n+            self.span_err(self.prev_span, \"at least one trait must be specified\");\n         }\n \n         Ok(ast::TyKind::ImplTrait(bounds))\n@@ -1213,7 +1211,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Semi)?\n             }\n \n-            let mac = spanned(lo, self.last_span.hi, Mac_ { path: pth, tts: tts });\n+            let mac = spanned(lo, self.prev_span.hi, Mac_ { path: pth, tts: tts });\n             (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac))\n         } else {\n             let (constness, unsafety, abi) = match self.parse_fn_front_matter() {\n@@ -1283,7 +1281,7 @@ impl<'a> Parser<'a> {\n             ident: name,\n             attrs: attrs,\n             node: node,\n-            span: mk_sp(lo, self.last_span.hi),\n+            span: mk_sp(lo, self.prev_span.hi),\n         })\n     }\n \n@@ -1330,13 +1328,13 @@ impl<'a> Parser<'a> {\n         // In type grammar, `+` is treated like a binary operator,\n         // and hence both L and R side are required.\n         if bounds.is_empty() {\n-            let last_span = self.last_span;\n-            self.span_err(last_span,\n+            let prev_span = self.prev_span;\n+            self.span_err(prev_span,\n                           \"at least one type parameter bound \\\n                           must be specified\");\n         }\n \n-        let sp = mk_sp(lo, self.last_span.hi);\n+        let sp = mk_sp(lo, self.prev_span.hi);\n         let sum = ast::TyKind::ObjectSum(lhs, bounds);\n         Ok(P(Ty {id: ast::DUMMY_NODE_ID, node: sum, span: sp}))\n     }\n@@ -1438,7 +1436,7 @@ impl<'a> Parser<'a> {\n             return Err(self.fatal(&msg));\n         };\n \n-        let sp = mk_sp(lo, self.last_span.hi);\n+        let sp = mk_sp(lo, self.prev_span.hi);\n         Ok(P(Ty {id: ast::DUMMY_NODE_ID, node: t, span: sp}))\n     }\n \n@@ -1456,7 +1454,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(keywords::Const) {\n             Mutability::Immutable\n         } else {\n-            let span = self.last_span;\n+            let span = self.prev_span;\n             self.span_err(span,\n                           \"expected mut or const in raw pointer type (use \\\n                            `*mut T` or `*const T` as appropriate)\");\n@@ -1499,7 +1497,7 @@ impl<'a> Parser<'a> {\n             pat\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n-            let sp = self.last_span;\n+            let sp = self.prev_span;\n             let spanned = Spanned { span: sp, node: keywords::Invalid.ident() };\n             P(Pat {\n                 id: ast::DUMMY_NODE_ID,\n@@ -1624,7 +1622,7 @@ impl<'a> Parser<'a> {\n             let lit = self.parse_lit_token()?;\n             lit\n         };\n-        Ok(codemap::Spanned { node: lit, span: mk_sp(lo, self.last_span.hi) })\n+        Ok(codemap::Spanned { node: lit, span: mk_sp(lo, self.prev_span.hi) })\n     }\n \n     /// matches '-' lit | lit\n@@ -1633,11 +1631,11 @@ impl<'a> Parser<'a> {\n         let minus_present = self.eat(&token::BinOp(token::Minus));\n         let lo = self.span.lo;\n         let literal = P(self.parse_lit()?);\n-        let hi = self.last_span.hi;\n+        let hi = self.prev_span.hi;\n         let expr = self.mk_expr(lo, hi, ExprKind::Lit(literal), ThinVec::new());\n \n         if minus_present {\n-            let minus_hi = self.last_span.hi;\n+            let minus_hi = self.prev_span.hi;\n             let unary = self.mk_unary(UnOp::Neg, expr);\n             Ok(self.mk_expr(minus_lo, minus_hi, unary, ThinVec::new()))\n         } else {\n@@ -1672,7 +1670,7 @@ impl<'a> Parser<'a> {\n     /// `<T as U>::F::a::<S>`\n     pub fn parse_qualified_path(&mut self, mode: PathStyle)\n                                 -> PResult<'a, (QSelf, ast::Path)> {\n-        let span = self.last_span;\n+        let span = self.prev_span;\n         let self_type = self.parse_ty_sum()?;\n         let mut path = if self.eat_keyword(keywords::As) {\n             self.parse_path(PathStyle::Type)?\n@@ -1705,7 +1703,7 @@ impl<'a> Parser<'a> {\n         };\n         path.segments.extend(segments);\n \n-        path.span.hi = self.last_span.hi;\n+        path.span.hi = self.prev_span.hi;\n \n         Ok((qself, path))\n     }\n@@ -1743,7 +1741,7 @@ impl<'a> Parser<'a> {\n         };\n \n         // Assemble the span.\n-        let span = mk_sp(lo, self.last_span.hi);\n+        let span = mk_sp(lo, self.prev_span.hi);\n \n         // Assemble the result.\n         Ok(ast::Path {\n@@ -1773,7 +1771,7 @@ impl<'a> Parser<'a> {\n                     bindings: P::from_vec(bindings),\n                 })\n             } else if self.eat(&token::OpenDelim(token::Paren)) {\n-                let lo = self.last_span.lo;\n+                let lo = self.prev_span.lo;\n \n                 let inputs = self.parse_seq_to_end(\n                     &token::CloseDelim(token::Paren),\n@@ -1786,7 +1784,7 @@ impl<'a> Parser<'a> {\n                     None\n                 };\n \n-                let hi = self.last_span.hi;\n+                let hi = self.prev_span.hi;\n \n                 ast::PathParameters::Parenthesized(ast::ParenthesizedParameterData {\n                     span: mk_sp(lo, hi),\n@@ -2017,7 +2015,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_field(&mut self) -> PResult<'a, Field> {\n         let lo = self.span.lo;\n         let i = self.parse_field_name()?;\n-        let hi = self.last_span.hi;\n+        let hi = self.prev_span.hi;\n         self.expect(&token::Colon)?;\n         let e = self.parse_expr()?;\n         Ok(ast::Field {\n@@ -2172,7 +2170,7 @@ impl<'a> Parser<'a> {\n                 }\n                 self.bump();\n \n-                hi = self.last_span.hi;\n+                hi = self.prev_span.hi;\n                 return if es.len() == 1 && !trailing_comma {\n                     Ok(self.mk_expr(lo, hi, ExprKind::Paren(es.into_iter().nth(0).unwrap()), attrs))\n                 } else {\n@@ -2221,7 +2219,7 @@ impl<'a> Parser<'a> {\n                         ex = ExprKind::Vec(vec!(first_expr));\n                     }\n                 }\n-                hi = self.last_span.hi;\n+                hi = self.prev_span.hi;\n             }\n             _ => {\n                 if self.eat_lt() {\n@@ -2231,18 +2229,18 @@ impl<'a> Parser<'a> {\n                     return Ok(self.mk_expr(lo, hi, ExprKind::Path(Some(qself), path), attrs));\n                 }\n                 if self.eat_keyword(keywords::Move) {\n-                    let lo = self.last_span.lo;\n+                    let lo = self.prev_span.lo;\n                     return self.parse_lambda_expr(lo, CaptureBy::Value, attrs);\n                 }\n                 if self.eat_keyword(keywords::If) {\n                     return self.parse_if_expr(attrs);\n                 }\n                 if self.eat_keyword(keywords::For) {\n-                    let lo = self.last_span.lo;\n+                    let lo = self.prev_span.lo;\n                     return self.parse_for_expr(None, lo, attrs);\n                 }\n                 if self.eat_keyword(keywords::While) {\n-                    let lo = self.last_span.lo;\n+                    let lo = self.prev_span.lo;\n                     return self.parse_while_expr(None, lo, attrs);\n                 }\n                 if self.token.is_lifetime() {\n@@ -2263,7 +2261,7 @@ impl<'a> Parser<'a> {\n                     return Err(self.fatal(\"expected `while`, `for`, or `loop` after a label\"))\n                 }\n                 if self.eat_keyword(keywords::Loop) {\n-                    let lo = self.last_span.lo;\n+                    let lo = self.prev_span.lo;\n                     return self.parse_loop_expr(None, lo, attrs);\n                 }\n                 if self.eat_keyword(keywords::Continue) {\n@@ -2277,7 +2275,7 @@ impl<'a> Parser<'a> {\n                     } else {\n                         ExprKind::Continue(None)\n                     };\n-                    let hi = self.last_span.hi;\n+                    let hi = self.prev_span.hi;\n                     return Ok(self.mk_expr(lo, hi, ex, attrs));\n                 }\n                 if self.eat_keyword(keywords::Match) {\n@@ -2307,7 +2305,7 @@ impl<'a> Parser<'a> {\n                     } else {\n                         ex = ExprKind::Break(None);\n                     }\n-                    hi = self.last_span.hi;\n+                    hi = self.prev_span.hi;\n                 } else if self.token.is_keyword(keywords::Let) {\n                     // Catch this syntax error here, instead of in `check_strict_keywords`, so\n                     // that we can explicitly mention that let is not to be used as an expression\n@@ -2324,7 +2322,7 @@ impl<'a> Parser<'a> {\n                         let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                                         SeqSep::none(),\n                                                         |p| p.parse_token_tree())?;\n-                        let hi = self.last_span.hi;\n+                        let hi = self.prev_span.hi;\n                         return Ok(self.mk_mac_expr(lo, hi, Mac_ { path: pth, tts: tts }, attrs));\n                     }\n                     if self.check(&token::OpenDelim(token::Brace)) {\n@@ -2489,8 +2487,8 @@ impl<'a> Parser<'a> {\n         };\n \n         if !bindings.is_empty() {\n-            let last_span = self.last_span;\n-            self.span_err(last_span, \"type bindings are only permitted on trait paths\");\n+            let prev_span = self.prev_span;\n+            self.span_err(prev_span, \"type bindings are only permitted on trait paths\");\n         }\n \n         Ok(match self.token {\n@@ -2502,7 +2500,7 @@ impl<'a> Parser<'a> {\n                     SeqSep::trailing_allowed(token::Comma),\n                     |p| Ok(p.parse_expr()?)\n                 )?;\n-                let hi = self.last_span.hi;\n+                let hi = self.prev_span.hi;\n \n                 es.insert(0, self_value);\n                 let id = spanned(ident_span.lo, ident_span.hi, ident);\n@@ -2512,8 +2510,8 @@ impl<'a> Parser<'a> {\n             // Field access.\n             _ => {\n                 if !tys.is_empty() {\n-                    let last_span = self.last_span;\n-                    self.span_err(last_span,\n+                    let prev_span = self.prev_span;\n+                    self.span_err(prev_span,\n                                   \"field expressions may not \\\n                                    have type parameters\");\n                 }\n@@ -2531,15 +2529,15 @@ impl<'a> Parser<'a> {\n         loop {\n             // expr?\n             while self.eat(&token::Question) {\n-                let hi = self.last_span.hi;\n+                let hi = self.prev_span.hi;\n                 e = self.mk_expr(lo, hi, ExprKind::Try(e), ThinVec::new());\n             }\n \n             // expr.f\n             if self.eat(&token::Dot) {\n                 match self.token {\n                   token::Ident(i) => {\n-                    let dot_pos = self.last_span.hi;\n+                    let dot_pos = self.prev_span.hi;\n                     hi = self.span.hi;\n                     self.bump();\n \n@@ -2551,7 +2549,7 @@ impl<'a> Parser<'a> {\n                     // A tuple index may not have a suffix\n                     self.expect_no_suffix(sp, \"tuple index\", suf);\n \n-                    let dot = self.last_span.hi;\n+                    let dot = self.prev_span.hi;\n                     hi = self.span.hi;\n                     self.bump();\n \n@@ -2563,16 +2561,16 @@ impl<'a> Parser<'a> {\n                             e = self.mk_expr(lo, hi, field, ThinVec::new());\n                         }\n                         None => {\n-                            let last_span = self.last_span;\n-                            self.span_err(last_span, \"invalid tuple or tuple struct index\");\n+                            let prev_span = self.prev_span;\n+                            self.span_err(prev_span, \"invalid tuple or tuple struct index\");\n                         }\n                     }\n                   }\n                   token::Literal(token::Float(n), _suf) => {\n                     self.bump();\n-                    let last_span = self.last_span;\n+                    let prev_span = self.prev_span;\n                     let fstr = n.as_str();\n-                    let mut err = self.diagnostic().struct_span_err(last_span,\n+                    let mut err = self.diagnostic().struct_span_err(prev_span,\n                         &format!(\"unexpected token: `{}`\", n.as_str()));\n                     if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n                         let float = match fstr.parse::<f64>().ok() {\n@@ -2591,7 +2589,7 @@ impl<'a> Parser<'a> {\n                     let actual = self.this_token_to_string();\n                     self.span_err(self.span, &format!(\"unexpected token: `{}`\", actual));\n \n-                    let dot_pos = self.last_span.hi;\n+                    let dot_pos = self.prev_span.hi;\n                     e = self.parse_dot_suffix(keywords::Invalid.ident(),\n                                               mk_sp(dot_pos, dot_pos),\n                                               e, lo)?;\n@@ -2609,7 +2607,7 @@ impl<'a> Parser<'a> {\n                     SeqSep::trailing_allowed(token::Comma),\n                     |p| Ok(p.parse_expr()?)\n                 )?;\n-                hi = self.last_span.hi;\n+                hi = self.prev_span.hi;\n \n                 let nd = self.mk_call(e, es);\n                 e = self.mk_expr(lo, hi, nd, ThinVec::new());\n@@ -2953,7 +2951,7 @@ impl<'a> Parser<'a> {\n         while let Some(op) = AssocOp::from_token(&self.token) {\n \n             let lhs_span = if self.last_token_kind == LastTokenKind::Interpolated {\n-                self.last_span\n+                self.prev_span\n             } else {\n                 lhs.span\n             };\n@@ -3146,7 +3144,7 @@ impl<'a> Parser<'a> {\n         if self.check_keyword(keywords::Let) {\n             return self.parse_if_let_expr(attrs);\n         }\n-        let lo = self.last_span.lo;\n+        let lo = self.prev_span.lo;\n         let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n         let mut els: Option<P<Expr>> = None;\n@@ -3162,7 +3160,7 @@ impl<'a> Parser<'a> {\n     /// Parse an 'if let' expression ('if' token already eaten)\n     pub fn parse_if_let_expr(&mut self, attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>> {\n-        let lo = self.last_span.lo;\n+        let lo = self.prev_span.lo;\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n@@ -3185,7 +3183,7 @@ impl<'a> Parser<'a> {\n                              -> PResult<'a, P<Expr>>\n     {\n         let decl = self.parse_fn_block_decl()?;\n-        let decl_hi = self.last_span.hi;\n+        let decl_hi = self.prev_span.hi;\n         let body = match decl.output {\n             FunctionRetTy::Default(_) => {\n                 // If no explicit return type is given, parse any\n@@ -3238,7 +3236,7 @@ impl<'a> Parser<'a> {\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n \n-        let hi = self.last_span.hi;\n+        let hi = self.prev_span.hi;\n \n         Ok(self.mk_expr(span_lo, hi,\n                         ExprKind::ForLoop(pat, expr, loop_block, opt_ident),\n@@ -3286,8 +3284,8 @@ impl<'a> Parser<'a> {\n \n     // `match` token already eaten\n     fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n-        let match_span = self.last_span;\n-        let lo = self.last_span.lo;\n+        let match_span = self.prev_span;\n+        let lo = self.prev_span.lo;\n         let discriminant = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n                                                None)?;\n         if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n@@ -3409,7 +3407,7 @@ impl<'a> Parser<'a> {\n                 }\n             } else if ddpos.is_some() && self.eat(&token::DotDot) {\n                 // Emit a friendly error, ignore `..` and continue parsing\n-                self.span_err(self.last_span, \"`..` can only be used once per \\\n+                self.span_err(self.prev_span, \"`..` can only be used once per \\\n                                                tuple or tuple struct pattern\");\n             } else {\n                 fields.push(self.parse_pat()?);\n@@ -3520,15 +3518,15 @@ impl<'a> Parser<'a> {\n                 let is_ref = self.eat_keyword(keywords::Ref);\n                 let is_mut = self.eat_keyword(keywords::Mut);\n                 let fieldname = self.parse_ident()?;\n-                hi = self.last_span.hi;\n+                hi = self.prev_span.hi;\n \n                 let bind_type = match (is_ref, is_mut) {\n                     (true, true) => BindingMode::ByRef(Mutability::Mutable),\n                     (true, false) => BindingMode::ByRef(Mutability::Immutable),\n                     (false, true) => BindingMode::ByValue(Mutability::Mutable),\n                     (false, false) => BindingMode::ByValue(Mutability::Immutable),\n                 };\n-                let fieldpath = codemap::Spanned{span:self.last_span, node:fieldname};\n+                let fieldpath = codemap::Spanned{span:self.prev_span, node:fieldname};\n                 let fieldpat = P(ast::Pat{\n                     id: ast::DUMMY_NODE_ID,\n                     node: PatKind::Ident(bind_type, fieldpath, None),\n@@ -3567,7 +3565,7 @@ impl<'a> Parser<'a> {\n                 // Parse an unqualified path\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n-            let hi = self.last_span.hi;\n+            let hi = self.prev_span.hi;\n             Ok(self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new()))\n         } else {\n             self.parse_pat_literal_maybe_minus()\n@@ -3651,12 +3649,12 @@ impl<'a> Parser<'a> {\n                         let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                                         SeqSep::none(),\n                                                         |p| p.parse_token_tree())?;\n-                        let mac = spanned(lo, self.last_span.hi, Mac_ { path: path, tts: tts });\n+                        let mac = spanned(lo, self.prev_span.hi, Mac_ { path: path, tts: tts });\n                         pat = PatKind::Mac(mac);\n                     }\n                     token::DotDotDot => {\n                         // Parse range\n-                        let hi = self.last_span.hi;\n+                        let hi = self.prev_span.hi;\n                         let begin =\n                               self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new());\n                         self.bump();\n@@ -3709,7 +3707,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let hi = self.last_span.hi;\n+        let hi = self.prev_span.hi;\n         Ok(P(ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n             node: pat,\n@@ -3724,8 +3722,8 @@ impl<'a> Parser<'a> {\n                        binding_mode: ast::BindingMode)\n                        -> PResult<'a, PatKind> {\n         let ident = self.parse_ident()?;\n-        let last_span = self.last_span;\n-        let name = codemap::Spanned{span: last_span, node: ident};\n+        let prev_span = self.prev_span;\n+        let name = codemap::Spanned{span: prev_span, node: ident};\n         let sub = if self.eat(&token::At) {\n             Some(self.parse_pat()?)\n         } else {\n@@ -3739,9 +3737,8 @@ impl<'a> Parser<'a> {\n         // binding mode then we do not end up here, because the lookahead\n         // will direct us over to parse_enum_variant()\n         if self.token == token::OpenDelim(token::Paren) {\n-            let last_span = self.last_span;\n             return Err(self.span_fatal(\n-                last_span,\n+                self.prev_span,\n                 \"expected identifier, found enum pattern\"))\n         }\n \n@@ -3763,7 +3760,7 @@ impl<'a> Parser<'a> {\n             pat: pat,\n             init: init,\n             id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, self.last_span.hi),\n+            span: mk_sp(lo, self.prev_span.hi),\n             attrs: attrs,\n         }))\n     }\n@@ -3778,7 +3775,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty_sum()?;\n         Ok(StructField {\n-            span: mk_sp(lo, self.last_span.hi),\n+            span: mk_sp(lo, self.prev_span.hi),\n             ident: Some(name),\n             vis: vis,\n             id: ast::DUMMY_NODE_ID,\n@@ -3796,7 +3793,7 @@ impl<'a> Parser<'a> {\n             _ => \"expected item after attributes\",\n         };\n \n-        self.span_err(self.last_span, message);\n+        self.span_err(self.prev_span, message);\n     }\n \n     /// Parse a statement. This stops just before trailing semicolons on everything but items.\n@@ -3886,7 +3883,7 @@ impl<'a> Parser<'a> {\n             Stmt {\n                 id: ast::DUMMY_NODE_ID,\n                 node: StmtKind::Local(self.parse_local(attrs.into())?),\n-                span: mk_sp(lo, self.last_span.hi),\n+                span: mk_sp(lo, self.prev_span.hi),\n             }\n         } else if self.token.is_path_start() && self.token != token::Lt && {\n             !self.check_keyword(keywords::Union) ||\n@@ -3898,7 +3895,7 @@ impl<'a> Parser<'a> {\n                 let expr = if self.check(&token::OpenDelim(token::Brace)) {\n                     self.parse_struct_expr(lo, pth, ThinVec::new())?\n                 } else {\n-                    let hi = self.last_span.hi;\n+                    let hi = self.prev_span.hi;\n                     self.mk_expr(lo, hi, ExprKind::Path(None, pth), ThinVec::new())\n                 };\n \n@@ -3910,7 +3907,7 @@ impl<'a> Parser<'a> {\n                 return Ok(Some(Stmt {\n                     id: ast::DUMMY_NODE_ID,\n                     node: StmtKind::Expr(expr),\n-                    span: mk_sp(lo, self.last_span.hi),\n+                    span: mk_sp(lo, self.prev_span.hi),\n                 }));\n             }\n \n@@ -3946,7 +3943,7 @@ impl<'a> Parser<'a> {\n                 SeqSep::none(),\n                 |p| p.parse_token_tree()\n             )?;\n-            let hi = self.last_span.hi;\n+            let hi = self.prev_span.hi;\n \n             let style = if delim == token::Brace {\n                 MacStmtStyle::Braces\n@@ -3991,8 +3988,7 @@ impl<'a> Parser<'a> {\n                 // Require a semicolon or braces.\n                 if style != MacStmtStyle::Braces {\n                     if !self.eat(&token::Semi) {\n-                        let last_span = self.last_span;\n-                        self.span_err(last_span,\n+                        self.span_err(self.prev_span,\n                                       \"macros that expand to items must \\\n                                        either be surrounded with braces or \\\n                                        followed by a semicolon\");\n@@ -4024,7 +4020,7 @@ impl<'a> Parser<'a> {\n                     let unused_attrs = |attrs: &[_], s: &mut Self| {\n                         if attrs.len() > 0 {\n                             if s.last_token_kind == LastTokenKind::DocComment {\n-                                s.span_err_help(s.last_span,\n+                                s.span_err_help(s.prev_span,\n                                     \"found a documentation comment that doesn't document anything\",\n                                     \"doc comments must come before what they document, maybe a \\\n                                     comment was intended with `//`?\");\n@@ -4087,7 +4083,7 @@ impl<'a> Parser<'a> {\n                     let mut stmt_span = stmt.span;\n                     // expand the span to include the semicolon, if it exists\n                     if self.eat(&token::Semi) {\n-                        stmt_span.hi = self.last_span.hi;\n+                        stmt_span.hi = self.prev_span.hi;\n                     }\n                     e.span_help(stmt_span, \"try placing this code inside a block\");\n                 }\n@@ -4133,7 +4129,7 @@ impl<'a> Parser<'a> {\n             stmts: stmts,\n             id: ast::DUMMY_NODE_ID,\n             rules: s,\n-            span: mk_sp(lo, self.last_span.hi),\n+            span: mk_sp(lo, self.prev_span.hi),\n         }))\n     }\n \n@@ -4172,7 +4168,7 @@ impl<'a> Parser<'a> {\n             stmt = stmt.add_trailing_semicolon();\n         }\n \n-        stmt.span.hi = self.last_span.hi;\n+        stmt.span.hi = self.prev_span.hi;\n         Ok(Some(stmt))\n     }\n \n@@ -4308,8 +4304,8 @@ impl<'a> Parser<'a> {\n                 if ty_param.default.is_some() {\n                     seen_default = true;\n                 } else if seen_default {\n-                    let last_span = p.last_span;\n-                    p.span_err(last_span,\n+                    let prev_span = p.prev_span;\n+                    p.span_err(prev_span,\n                                \"type parameters with a default must be trailing\");\n                 }\n                 Ok(ty_param)\n@@ -4327,7 +4323,7 @@ impl<'a> Parser<'a> {\n                     id: ast::DUMMY_NODE_ID,\n                     predicates: Vec::new(),\n                 },\n-                span: mk_sp(span_lo, self.last_span.hi),\n+                span: mk_sp(span_lo, self.prev_span.hi),\n             })\n         } else {\n             Ok(ast::Generics::default())\n@@ -4449,7 +4445,7 @@ impl<'a> Parser<'a> {\n                     let bounds =\n                         self.parse_lifetimes(token::BinOp(token::Plus))?;\n \n-                    let hi = self.last_span.hi;\n+                    let hi = self.prev_span.hi;\n                     let span = mk_sp(lo, hi);\n \n                     where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n@@ -4478,7 +4474,7 @@ impl<'a> Parser<'a> {\n \n                     if self.eat(&token::Colon) {\n                         let bounds = self.parse_ty_param_bounds(BoundParsingMode::Bare)?;\n-                        let hi = self.last_span.hi;\n+                        let hi = self.prev_span.hi;\n                         let span = mk_sp(lo, hi);\n \n                         if bounds.is_empty() {\n@@ -4498,7 +4494,7 @@ impl<'a> Parser<'a> {\n                         parsed_something = true;\n                     } else if self.eat(&token::Eq) {\n                         // let ty = try!(self.parse_ty());\n-                        let hi = self.last_span.hi;\n+                        let hi = self.prev_span.hi;\n                         let span = mk_sp(lo, hi);\n                         // where_clause.predicates.push(\n                         //     ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n@@ -4513,8 +4509,8 @@ impl<'a> Parser<'a> {\n                                      \"equality constraints are not yet supported \\\n                                      in where clauses (#20041)\");\n                     } else {\n-                        let last_span = self.last_span;\n-                        self.span_err(last_span,\n+                        let prev_span = self.prev_span;\n+                        self.span_err(prev_span,\n                               \"unexpected token in `where` clause\");\n                     }\n                 }\n@@ -4526,8 +4522,8 @@ impl<'a> Parser<'a> {\n         }\n \n         if !parsed_something {\n-            let last_span = self.last_span;\n-            self.span_err(last_span,\n+            let prev_span = self.prev_span;\n+            self.span_err(prev_span,\n                           \"a `where` clause must have at least one predicate \\\n                            in it\");\n         }\n@@ -4600,7 +4596,7 @@ impl<'a> Parser<'a> {\n     fn parse_self_arg(&mut self) -> PResult<'a, Option<Arg>> {\n         let expect_ident = |this: &mut Self| match this.token {\n             // Preserve hygienic context.\n-            token::Ident(ident) => { this.bump(); codemap::respan(this.last_span, ident) }\n+            token::Ident(ident) => { this.bump(); codemap::respan(this.prev_span, ident) }\n             _ => unreachable!()\n         };\n \n@@ -4689,7 +4685,7 @@ impl<'a> Parser<'a> {\n             _ => return Ok(None),\n         };\n \n-        let eself = codemap::respan(mk_sp(eself_lo, self.last_span.hi), eself);\n+        let eself = codemap::respan(mk_sp(eself_lo, self.prev_span.hi), eself);\n         Ok(Some(Arg::from_self(eself, eself_ident)))\n     }\n \n@@ -4807,7 +4803,7 @@ impl<'a> Parser<'a> {\n                                                 ast::Unsafety,\n                                                 abi::Abi)> {\n         let is_const_fn = self.eat_keyword(keywords::Const);\n-        let const_span = self.last_span;\n+        let const_span = self.prev_span;\n         let unsafety = self.parse_unsafety()?;\n         let (constness, unsafety, abi) = if is_const_fn {\n             (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n@@ -4817,7 +4813,7 @@ impl<'a> Parser<'a> {\n             } else {\n                 Abi::Rust\n             };\n-            (respan(self.last_span, Constness::NotConst), unsafety, abi)\n+            (respan(self.prev_span, Constness::NotConst), unsafety, abi)\n         };\n         self.expect_keyword(keywords::Fn)?;\n         Ok((constness, unsafety, abi))\n@@ -4854,7 +4850,7 @@ impl<'a> Parser<'a> {\n \n         Ok(ImplItem {\n             id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, self.last_span.hi),\n+            span: mk_sp(lo, self.prev_span.hi),\n             ident: name,\n             vis: vis,\n             defaultness: defaultness,\n@@ -4894,8 +4890,8 @@ impl<'a> Parser<'a> {\n         if self.token.is_path_start() {\n             // method macro.\n \n-            let last_span = self.last_span;\n-            self.complain_if_pub_macro(&vis, last_span);\n+            let prev_span = self.prev_span;\n+            self.complain_if_pub_macro(&vis, prev_span);\n \n             let lo = self.span.lo;\n             let pth = self.parse_path(PathStyle::Mod)?;\n@@ -4910,7 +4906,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Semi)?\n             }\n \n-            let mac = spanned(lo, self.last_span.hi, Mac_ { path: pth, tts: tts });\n+            let mac = spanned(lo, self.prev_span.hi, Mac_ { path: pth, tts: tts });\n             Ok((keywords::Invalid.ident(), vec![], ast::ImplItemKind::Macro(mac)))\n         } else {\n             let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n@@ -5051,7 +5047,7 @@ impl<'a> Parser<'a> {\n         Ok(ast::PolyTraitRef {\n             bound_lifetimes: lifetime_defs,\n             trait_ref: self.parse_trait_ref()?,\n-            span: mk_sp(lo, self.last_span.hi),\n+            span: mk_sp(lo, self.prev_span.hi),\n         })\n     }\n \n@@ -5217,7 +5213,7 @@ impl<'a> Parser<'a> {\n     // If `allow_path` is false, just parse the `pub` in `pub(path)` (but still parse `pub(crate)`)\n     fn parse_visibility(&mut self, allow_path: bool) -> PResult<'a, Visibility> {\n         let pub_crate = |this: &mut Self| {\n-            let span = this.last_span;\n+            let span = this.prev_span;\n             this.expect(&token::CloseDelim(token::Paren))?;\n             Ok(Visibility::Crate(span))\n         };\n@@ -5268,7 +5264,7 @@ impl<'a> Parser<'a> {\n         let hi = if self.span == syntax_pos::DUMMY_SP {\n             inner_lo\n         } else {\n-            self.last_span.hi\n+            self.prev_span.hi\n         };\n \n         Ok(ast::Mod {\n@@ -5537,9 +5533,9 @@ impl<'a> Parser<'a> {\n         };\n         self.expect(&token::Semi)?;\n \n-        let last_span = self.last_span;\n+        let prev_span = self.prev_span;\n         Ok(self.mk_item(lo,\n-                        last_span.hi,\n+                        prev_span.hi,\n                         ident,\n                         ItemKind::ExternCrate(maybe_path),\n                         visibility,\n@@ -5574,13 +5570,13 @@ impl<'a> Parser<'a> {\n         }\n         self.expect(&token::CloseDelim(token::Brace))?;\n \n-        let last_span = self.last_span;\n+        let prev_span = self.prev_span;\n         let m = ast::ForeignMod {\n             abi: abi,\n             items: foreign_items\n         };\n         Ok(self.mk_item(lo,\n-                     last_span.hi,\n+                     prev_span.hi,\n                      keywords::Invalid.ident(),\n                      ItemKind::ForeignMod(m),\n                      visibility,\n@@ -5633,7 +5629,7 @@ impl<'a> Parser<'a> {\n                 data: struct_def,\n                 disr_expr: disr_expr,\n             };\n-            variants.push(spanned(vlo, self.last_span.hi, vr));\n+            variants.push(spanned(vlo, self.prev_span.hi, vr));\n \n             if !self.eat(&token::Comma) { break; }\n         }\n@@ -5670,9 +5666,9 @@ impl<'a> Parser<'a> {\n                 match abi::lookup(&s.as_str()) {\n                     Some(abi) => Ok(Some(abi)),\n                     None => {\n-                        let last_span = self.last_span;\n+                        let prev_span = self.prev_span;\n                         self.span_err(\n-                            last_span,\n+                            prev_span,\n                             &format!(\"invalid ABI: expected one of [{}], \\\n                                      found `{}`\",\n                                     abi::all_names().join(\", \"),\n@@ -5714,9 +5710,9 @@ impl<'a> Parser<'a> {\n             let item_ = ItemKind::Use(self.parse_view_path()?);\n             self.expect(&token::Semi)?;\n \n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     keywords::Invalid.ident(),\n                                     item_,\n                                     visibility,\n@@ -5733,15 +5729,15 @@ impl<'a> Parser<'a> {\n \n             if self.eat_keyword(keywords::Fn) {\n                 // EXTERN FUNCTION ITEM\n-                let fn_span = self.last_span;\n+                let fn_span = self.prev_span;\n                 let abi = opt_abi.unwrap_or(Abi::C);\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(Unsafety::Normal,\n                                        respan(fn_span, Constness::NotConst),\n                                        abi)?;\n-                let last_span = self.last_span;\n+                let prev_span = self.prev_span;\n                 let item = self.mk_item(lo,\n-                                        last_span.hi,\n+                                        prev_span.hi,\n                                         ident,\n                                         item_,\n                                         visibility,\n@@ -5762,17 +5758,17 @@ impl<'a> Parser<'a> {\n                 Mutability::Immutable\n             };\n             let (ident, item_, extra_attrs) = self.parse_item_const(Some(m))?;\n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n         if self.eat_keyword(keywords::Const) {\n-            let const_span = self.last_span;\n+            let const_span = self.prev_span;\n             if self.check_keyword(keywords::Fn)\n                 || (self.check_keyword(keywords::Unsafe)\n                     && self.look_ahead(1, |t| t.is_keyword(keywords::Fn))) {\n@@ -5787,9 +5783,9 @@ impl<'a> Parser<'a> {\n                     self.parse_item_fn(unsafety,\n                                        respan(const_span, Constness::Const),\n                                        Abi::Rust)?;\n-                let last_span = self.last_span;\n+                let prev_span = self.prev_span;\n                 let item = self.mk_item(lo,\n-                                        last_span.hi,\n+                                        prev_span.hi,\n                                         ident,\n                                         item_,\n                                         visibility,\n@@ -5799,15 +5795,15 @@ impl<'a> Parser<'a> {\n \n             // CONST ITEM\n             if self.eat_keyword(keywords::Mut) {\n-                let last_span = self.last_span;\n-                self.diagnostic().struct_span_err(last_span, \"const globals cannot be mutable\")\n+                let prev_span = self.prev_span;\n+                self.diagnostic().struct_span_err(prev_span, \"const globals cannot be mutable\")\n                                  .help(\"did you mean to declare a static?\")\n                                  .emit();\n             }\n             let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5822,9 +5818,9 @@ impl<'a> Parser<'a> {\n             self.expect_keyword(keywords::Trait)?;\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_trait(ast::Unsafety::Unsafe)?;\n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5838,9 +5834,9 @@ impl<'a> Parser<'a> {\n             self.expect_keyword(keywords::Unsafe)?;\n             self.expect_keyword(keywords::Impl)?;\n             let (ident, item_, extra_attrs) = self.parse_item_impl(ast::Unsafety::Unsafe)?;\n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5850,14 +5846,14 @@ impl<'a> Parser<'a> {\n         if self.check_keyword(keywords::Fn) {\n             // FUNCTION ITEM\n             self.bump();\n-            let fn_span = self.last_span;\n+            let fn_span = self.prev_span;\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(Unsafety::Normal,\n                                    respan(fn_span, Constness::NotConst),\n                                    Abi::Rust)?;\n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5874,14 +5870,14 @@ impl<'a> Parser<'a> {\n                 Abi::Rust\n             };\n             self.expect_keyword(keywords::Fn)?;\n-            let fn_span = self.last_span;\n+            let fn_span = self.prev_span;\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(Unsafety::Unsafe,\n                                    respan(fn_span, Constness::NotConst),\n                                    abi)?;\n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5892,9 +5888,9 @@ impl<'a> Parser<'a> {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_mod(&attrs[..])?;\n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5904,9 +5900,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Type) {\n             // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type()?;\n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5916,9 +5912,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Enum) {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum()?;\n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5929,9 +5925,9 @@ impl<'a> Parser<'a> {\n             // TRAIT ITEM\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_trait(ast::Unsafety::Normal)?;\n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5941,9 +5937,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Impl) {\n             // IMPL ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_impl(ast::Unsafety::Normal)?;\n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5953,9 +5949,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Struct) {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct()?;\n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5967,9 +5963,9 @@ impl<'a> Parser<'a> {\n             // UNION ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_union()?;\n-            let last_span = self.last_span;\n+            let prev_span = self.prev_span;\n             let item = self.mk_item(lo,\n-                                    last_span.hi,\n+                                    prev_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -6015,8 +6011,8 @@ impl<'a> Parser<'a> {\n         if macros_allowed && self.token.is_path_start() {\n             // MACRO INVOCATION ITEM\n \n-            let last_span = self.last_span;\n-            self.complain_if_pub_macro(&visibility, last_span);\n+            let prev_span = self.prev_span;\n+            self.complain_if_pub_macro(&visibility, prev_span);\n \n             let mac_lo = self.span.lo;\n \n@@ -6039,15 +6035,15 @@ impl<'a> Parser<'a> {\n                                             |p| p.parse_token_tree())?;\n             if delim != token::Brace {\n                 if !self.eat(&token::Semi) {\n-                    let last_span = self.last_span;\n-                    self.span_err(last_span,\n+                    let prev_span = self.prev_span;\n+                    self.span_err(prev_span,\n                                   \"macros that expand to items must either \\\n                                    be surrounded with braces or followed by \\\n                                    a semicolon\");\n                 }\n             }\n \n-            let hi = self.last_span.hi;\n+            let hi = self.prev_span.hi;\n             let mac = spanned(mac_lo, hi, Mac_ { path: pth, tts: tts });\n             let item = self.mk_item(lo, hi, id, ItemKind::Mac(mac), visibility, attrs);\n             return Ok(Some(item));\n@@ -6057,8 +6053,8 @@ impl<'a> Parser<'a> {\n         match visibility {\n             Visibility::Inherited => {}\n             _ => {\n-                let last_span = self.last_span;\n-                return Err(self.span_fatal(last_span, \"unmatched visibility `pub`\"));\n+                let prev_span = self.prev_span;\n+                return Err(self.span_fatal(prev_span, \"unmatched visibility `pub`\"));\n             }\n         }\n \n@@ -6089,7 +6085,7 @@ impl<'a> Parser<'a> {\n                 rename: rename,\n                 id: ast::DUMMY_NODE_ID\n             };\n-            let hi = this.last_span.hi;\n+            let hi = this.prev_span.hi;\n             Ok(spanned(lo, hi, node))\n         })\n     }\n@@ -6134,7 +6130,7 @@ impl<'a> Parser<'a> {\n                 // `foo::bar` or `foo::bar as baz`\n                 let rename = self.parse_rename()?.\n                                   unwrap_or(prefix.segments.last().unwrap().identifier);\n-                Ok(P(spanned(lo, self.last_span.hi, ViewPathSimple(rename, prefix))))\n+                Ok(P(spanned(lo, self.prev_span.hi, ViewPathSimple(rename, prefix))))\n             }\n         }\n     }\n@@ -6182,7 +6178,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_str(&mut self) -> PResult<'a, (InternedString, StrStyle)> {\n         match self.parse_optional_str() {\n             Some((s, style, suf)) => {\n-                let sp = self.last_span;\n+                let sp = self.prev_span;\n                 self.expect_no_suffix(sp, \"string literal\", suf);\n                 Ok((s, style))\n             }"}, {"sha": "c16b7d29594115ab960eadfce94068a694ccede6", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2747923c272a355dbb6265586a884652e26b0ec7/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2747923c272a355dbb6265586a884652e26b0ec7/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=2747923c272a355dbb6265586a884652e26b0ec7", "patch": "@@ -122,7 +122,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n \n                     let (constraint, _str_style) = panictry!(p.parse_str());\n \n-                    let span = p.last_span;\n+                    let span = p.prev_span;\n \n                     panictry!(p.expect(&token::OpenDelim(token::Paren)));\n                     let out = panictry!(p.parse_expr());\n@@ -167,9 +167,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                     let (constraint, _str_style) = panictry!(p.parse_str());\n \n                     if constraint.starts_with(\"=\") {\n-                        cx.span_err(p.last_span, \"input operand constraint contains '='\");\n+                        cx.span_err(p.prev_span, \"input operand constraint contains '='\");\n                     } else if constraint.starts_with(\"+\") {\n-                        cx.span_err(p.last_span, \"input operand constraint contains '+'\");\n+                        cx.span_err(p.prev_span, \"input operand constraint contains '+'\");\n                     }\n \n                     panictry!(p.expect(&token::OpenDelim(token::Paren)));\n@@ -189,9 +189,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                     let (s, _str_style) = panictry!(p.parse_str());\n \n                     if OPTIONS.iter().any(|&opt| s == opt) {\n-                        cx.span_warn(p.last_span, \"expected a clobber, found an option\");\n+                        cx.span_warn(p.prev_span, \"expected a clobber, found an option\");\n                     } else if s.starts_with(\"{\") || s.ends_with(\"}\") {\n-                        cx.span_err(p.last_span, \"clobber should not be surrounded by braces\");\n+                        cx.span_err(p.prev_span, \"clobber should not be surrounded by braces\");\n                     }\n \n                     clobs.push(s);\n@@ -209,7 +209,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                 } else if option == \"intel\" {\n                     dialect = AsmDialect::Intel;\n                 } else {\n-                    cx.span_warn(p.last_span, \"unrecognized option\");\n+                    cx.span_warn(p.prev_span, \"unrecognized option\");\n                 }\n \n                 if p.token == token::Comma {"}]}