{"sha": "d7f1406378a31b9f5e9012d882ae237131e3c252", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZjE0MDYzNzhhMzFiOWY1ZTkwMTJkODgyYWUyMzcxMzFlM2MyNTI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-07T07:51:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-07T07:51:52Z"}, "message": "Rollup merge of #59789 - eddyb:typeck-reverts, r=nikomatsakis\n\nRevert two unapproved changes to rustc_typeck.\n\nThere was a breakdown in process (https://github.com/rust-lang/rust/pull/59004#issuecomment-477600735, https://github.com/rust-lang/rust/pull/58894#discussion_r272795560) and two changes were made to `rustc_typeck`'s \"collect\" queries, for rustdoc, that were neither needed *nor* correct.\nI'm reverting them here, and will fix up rustdoc *somehow*, if necessary.\n\ncc @rust-lang/compiler How do we ensure this doesn't happen again?\n\nr? @nikomatsakis or @oli-obk", "tree": {"sha": "ee828b23218e0ce6225ad5001e475d192c8e4d7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee828b23218e0ce6225ad5001e475d192c8e4d7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7f1406378a31b9f5e9012d882ae237131e3c252", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdw80ZCRBK7hj4Ov3rIwAAdHIIAFd2xs4cvaFImrHtX3ykxVAl\n09e6l7Kt6QORx14XBrCXCBpEuhAFDzI0O59sJwyPoGfSn2mG7BxpDsMjE555qJcB\nM+rkIO/fbspgR9YZcUV/gdrebAguk408lVPjZ0blylFjEDNMgP13EeggbqeX1a2F\nKFm7P3v0J7ETisb5SlrHaXeP2qVDz64hnw3POrJHwVljNq8YD1Fz54UTFtNWVw0Y\nRWUrKT6e/b84r6HzlhdyxOIX90n5LbPGXuB7H5eOd8YGQ+JkSCI2alqZ2rwYzD0V\nXewhDro41J4QTd48jRKXW/CXJdQcaP2SzlWlte1d87K7DUln8Fncnb2fKo2AupU=\n=98G2\n-----END PGP SIGNATURE-----\n", "payload": "tree ee828b23218e0ce6225ad5001e475d192c8e4d7c\nparent 7a76fe76f756895b8cda1e10398f2268656a2e0f\nparent d594fc2562106a75b55c66a7d0eda0d99b333756\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1573113112 +0100\ncommitter GitHub <noreply@github.com> 1573113112 +0100\n\nRollup merge of #59789 - eddyb:typeck-reverts, r=nikomatsakis\n\nRevert two unapproved changes to rustc_typeck.\n\nThere was a breakdown in process (https://github.com/rust-lang/rust/pull/59004#issuecomment-477600735, https://github.com/rust-lang/rust/pull/58894#discussion_r272795560) and two changes were made to `rustc_typeck`'s \"collect\" queries, for rustdoc, that were neither needed *nor* correct.\nI'm reverting them here, and will fix up rustdoc *somehow*, if necessary.\n\ncc @rust-lang/compiler How do we ensure this doesn't happen again?\n\nr? @nikomatsakis or @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7f1406378a31b9f5e9012d882ae237131e3c252", "html_url": "https://github.com/rust-lang/rust/commit/d7f1406378a31b9f5e9012d882ae237131e3c252", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7f1406378a31b9f5e9012d882ae237131e3c252/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a76fe76f756895b8cda1e10398f2268656a2e0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a76fe76f756895b8cda1e10398f2268656a2e0f", "html_url": "https://github.com/rust-lang/rust/commit/7a76fe76f756895b8cda1e10398f2268656a2e0f"}, {"sha": "d594fc2562106a75b55c66a7d0eda0d99b333756", "url": "https://api.github.com/repos/rust-lang/rust/commits/d594fc2562106a75b55c66a7d0eda0d99b333756", "html_url": "https://github.com/rust-lang/rust/commit/d594fc2562106a75b55c66a7d0eda0d99b333756"}], "stats": {"total": 180, "additions": 71, "deletions": 109}, "files": [{"sha": "b01b99ffcfb09da2458caf6c58c29a6733b7b1a2", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d7f1406378a31b9f5e9012d882ae237131e3c252", "patch": "@@ -95,8 +95,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     generics_of => {\n         tcx.arena.alloc(cdata.get_generics(def_id.index, tcx.sess))\n     }\n-    predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n-    predicates_defined_on => { cdata.get_predicates_defined_on(def_id.index, tcx) }\n+    explicit_predicates_of => { cdata.get_explicit_predicates(def_id.index, tcx) }\n+    inferred_outlives_of => { cdata.get_inferred_outlives(def_id.index, tcx) }\n     super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n     trait_def => {\n         tcx.arena.alloc(cdata.get_trait_def(def_id.index, tcx.sess))"}, {"sha": "771d01a4b6a1dbe67dec3a95092d4847f825b0bd", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d7f1406378a31b9f5e9012d882ae237131e3c252", "patch": "@@ -658,20 +658,22 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx.alloc_adt_def(did, adt_kind, variants, repr)\n     }\n \n-    crate fn get_predicates(\n+    crate fn get_explicit_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.root.per_def.predicates.get(self, item_id).unwrap().decode((self, tcx))\n+        self.root.per_def.explicit_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n-    crate fn get_predicates_defined_on(\n+    crate fn get_inferred_outlives(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n-    ) -> ty::GenericPredicates<'tcx> {\n-        self.root.per_def.predicates_defined_on.get(self, item_id).unwrap().decode((self, tcx))\n+    ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+        self.root.per_def.inferred_outlives.get(self, item_id).map(|predicates| {\n+            predicates.decode((self, tcx))\n+        }).unwrap_or_default()\n     }\n \n     crate fn get_super_predicates("}, {"sha": "618d342f6fe756d4495bac951b426047d96aa329", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d7f1406378a31b9f5e9012d882ae237131e3c252", "patch": "@@ -76,8 +76,8 @@ struct PerDefTables<'tcx> {\n     inherent_impls: PerDefTable<Lazy<[DefIndex]>>,\n     variances: PerDefTable<Lazy<[ty::Variance]>>,\n     generics: PerDefTable<Lazy<ty::Generics>>,\n-    predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n-    predicates_defined_on: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+    explicit_predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+    inferred_outlives: PerDefTable<Lazy<&'tcx [(ty::Predicate<'tcx>, Span)]>>,\n     super_predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     mir: PerDefTable<Lazy<mir::Body<'tcx>>>,\n@@ -524,8 +524,8 @@ impl<'tcx> EncodeContext<'tcx> {\n             inherent_impls: self.per_def.inherent_impls.encode(&mut self.opaque),\n             variances: self.per_def.variances.encode(&mut self.opaque),\n             generics: self.per_def.generics.encode(&mut self.opaque),\n-            predicates: self.per_def.predicates.encode(&mut self.opaque),\n-            predicates_defined_on: self.per_def.predicates_defined_on.encode(&mut self.opaque),\n+            explicit_predicates: self.per_def.explicit_predicates.encode(&mut self.opaque),\n+            inferred_outlives: self.per_def.inferred_outlives.encode(&mut self.opaque),\n             super_predicates: self.per_def.super_predicates.encode(&mut self.opaque),\n \n             mir: self.per_def.mir.encode(&mut self.opaque),\n@@ -675,7 +675,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -718,7 +719,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -776,7 +778,8 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n     }\n \n     fn encode_struct_ctor(&mut self, adt_def_id: DefId, def_id: DefId) {\n@@ -819,7 +822,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -829,15 +833,18 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.generics[def_id] <- self.tcx.generics_of(def_id));\n     }\n \n-    fn encode_predicates(&mut self, def_id: DefId) {\n-        debug!(\"EncodeContext::encode_predicates({:?})\", def_id);\n-        record!(self.per_def.predicates[def_id] <- self.tcx.predicates_of(def_id));\n+    fn encode_explicit_predicates(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_explicit_predicates({:?})\", def_id);\n+        record!(self.per_def.explicit_predicates[def_id] <-\n+            self.tcx.explicit_predicates_of(def_id));\n     }\n \n-    fn encode_predicates_defined_on(&mut self, def_id: DefId) {\n-        debug!(\"EncodeContext::encode_predicates_defined_on({:?})\", def_id);\n-        record!(self.per_def.predicates_defined_on[def_id] <-\n-            self.tcx.predicates_defined_on(def_id))\n+    fn encode_inferred_outlives(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_inferred_outlives({:?})\", def_id);\n+        let inferred_outlives = self.tcx.inferred_outlives_of(def_id);\n+        if !inferred_outlives.is_empty() {\n+            record!(self.per_def.inferred_outlives[def_id] <- inferred_outlives);\n+        }\n     }\n \n     fn encode_super_predicates(&mut self, def_id: DefId) {\n@@ -919,7 +926,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -986,7 +994,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         let mir = match ast_item.kind {\n             hir::ImplItemKind::Const(..) => true,\n             hir::ImplItemKind::Method(ref sig, _) => {\n@@ -1260,22 +1269,11 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Trait(..) |\n             hir::ItemKind::TraitAlias(..) => {\n                 self.encode_generics(def_id);\n-                self.encode_predicates(def_id);\n+                self.encode_explicit_predicates(def_id);\n+                self.encode_inferred_outlives(def_id);\n             }\n             _ => {}\n         }\n-        // The only time that `predicates_defined_on` is used (on\n-        // an external item) is for traits, during chalk lowering,\n-        // so only encode it in that case as an efficiency\n-        // hack. (No reason not to expand it in the future if\n-        // necessary.)\n-        match item.kind {\n-            hir::ItemKind::Trait(..) |\n-            hir::ItemKind::TraitAlias(..) => {\n-                self.encode_predicates_defined_on(def_id);\n-            }\n-            _ => {} // not *wrong* for other kinds of items, but not needed\n-        }\n         match item.kind {\n             hir::ItemKind::Trait(..) |\n             hir::ItemKind::TraitAlias(..) => {\n@@ -1377,7 +1375,8 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n         self.encode_item_type(def_id);\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -1588,7 +1587,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n     }\n }\n "}, {"sha": "f644b7264320b79076c4e6fe2c643fc2a1e5740c", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=d7f1406378a31b9f5e9012d882ae237131e3c252", "patch": "@@ -244,8 +244,13 @@ crate struct LazyPerDefTables<'tcx> {\n     pub inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n     pub variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n     pub generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n-    pub predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n-    pub predicates_defined_on: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    pub explicit_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    // FIXME(eddyb) this would ideally be `Lazy<[...]>` but `ty::Predicate`\n+    // doesn't handle shorthands in its own (de)serialization impls,\n+    // as it's an `enum` for which we want to derive (de)serialization,\n+    // so the `ty::codec` APIs handle the whole `&'tcx [...]` at once.\n+    // Also, as an optimization, a missing entry indicates an empty `&[]`.\n+    pub inferred_outlives: Lazy!(PerDefTable<Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>),\n     pub super_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n \n     pub mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),"}, {"sha": "ef84f1cb20f5133a36f86436993794b72b3455ff", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 57, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d7f1406378a31b9f5e9012d882ae237131e3c252", "patch": "@@ -1146,10 +1146,6 @@ fn report_assoc_ty_on_inherent_impl(tcx: TyCtxt<'_>, span: Span) {\n     );\n }\n \n-fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n-    checked_type_of(tcx, def_id, true).unwrap()\n-}\n-\n fn infer_placeholder_type(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n@@ -1193,26 +1189,14 @@ fn infer_placeholder_type(\n     ty\n }\n \n-/// Same as [`type_of`] but returns [`Option`] instead of failing.\n-///\n-/// If you want to fail anyway, you can set the `fail` parameter to true, but in this case,\n-/// you'd better just call [`type_of`] directly.\n-pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<'_>> {\n+fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     use rustc::hir::*;\n \n-    let hir_id = match tcx.hir().as_local_hir_id(def_id) {\n-        Some(hir_id) => hir_id,\n-        None => {\n-            if !fail {\n-                return None;\n-            }\n-            bug!(\"invalid node\");\n-        }\n-    };\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    Some(match tcx.hir().get(hir_id) {\n+    match tcx.hir().get(hir_id) {\n         Node::TraitItem(item) => match item.kind {\n             TraitItemKind::Method(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n@@ -1229,9 +1213,6 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             },\n             TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n             TraitItemKind::Type(_, None) => {\n-                if !fail {\n-                    return None;\n-                }\n                 span_bug!(item.span, \"associated type missing default\");\n             }\n         },\n@@ -1325,9 +1306,6 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                 | ItemKind::GlobalAsm(..)\n                 | ItemKind::ExternCrate(..)\n                 | ItemKind::Use(..) => {\n-                    if !fail {\n-                        return None;\n-                    }\n                     span_bug!(\n                         item.span,\n                         \"compute_type_of_item: unexpected item type: {:?}\",\n@@ -1365,7 +1343,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             ..\n         }) => {\n             if gen.is_some() {\n-                return Some(tcx.typeck_tables_of(def_id).node_type(hir_id));\n+                return tcx.typeck_tables_of(def_id).node_type(hir_id);\n             }\n \n             let substs = InternalSubsts::identity_for_item(tcx, def_id);\n@@ -1440,13 +1418,9 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                                     .map(|(index, _)| index)\n                                     .next()\n                             })\n-                            .or_else(|| {\n-                                if !fail {\n-                                    None\n-                                } else {\n-                                    bug!(\"no arg matching AnonConst in path\")\n-                                }\n-                            })?;\n+                            .unwrap_or_else(|| {\n+                                bug!(\"no arg matching AnonConst in path\");\n+                            });\n \n                         // We've encountered an `AnonConst` in some path, so we need to\n                         // figure out which generic parameter it corresponds to and return\n@@ -1456,8 +1430,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                                 tcx.generics_of(tcx.parent(def_id).unwrap())\n                             }\n                             Res::Def(_, def_id) => tcx.generics_of(def_id),\n-                            Res::Err => return Some(tcx.types.err),\n-                            _ if !fail => return None,\n+                            Res::Err => return tcx.types.err,\n                             res => {\n                                 tcx.sess.delay_span_bug(\n                                     DUMMY_SP,\n@@ -1466,7 +1439,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                                         res,\n                                     ),\n                                 );\n-                                return Some(tcx.types.err);\n+                                return tcx.types.err;\n                             }\n                         };\n \n@@ -1484,24 +1457,18 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                             // probably from an extra arg where one is not needed.\n                             .unwrap_or(tcx.types.err)\n                     } else {\n-                        if !fail {\n-                            return None;\n-                        }\n                         tcx.sess.delay_span_bug(\n                             DUMMY_SP,\n                             &format!(\n                                 \"unexpected const parent path {:?}\",\n                                 parent_node,\n                             ),\n                         );\n-                        return Some(tcx.types.err);\n+                        return tcx.types.err;\n                     }\n                 }\n \n                 x => {\n-                    if !fail {\n-                        return None;\n-                    }\n                     tcx.sess.delay_span_bug(\n                         DUMMY_SP,\n                         &format!(\n@@ -1551,21 +1518,13 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                 }\n                 ty\n             }\n-            x => {\n-                if !fail {\n-                    return None;\n-                }\n-                bug!(\"unexpected non-type Node::GenericParam: {:?}\", x)\n-            },\n+            x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n         },\n \n         x => {\n-            if !fail {\n-                return None;\n-            }\n             bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n         }\n-    })\n+    }\n }\n \n fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n@@ -2075,10 +2034,7 @@ fn explicit_predicates_of(\n         }\n     }\n \n-    let hir_id = match tcx.hir().as_local_hir_id(def_id) {\n-        Some(hir_id) => hir_id,\n-        None => return tcx.predicates_of(def_id),\n-    };\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let node = tcx.hir().get(hir_id);\n \n     let mut is_trait = None;"}, {"sha": "a5a4cfa2babc03e5a82167792a7fad07b22c310c", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=d7f1406378a31b9f5e9012d882ae237131e3c252", "patch": "@@ -109,8 +109,6 @@ use util::common::time;\n use std::iter;\n \n use astconv::{AstConv, Bounds};\n-pub use collect::checked_type_of;\n-\n pub struct TypeAndSubsts<'tcx> {\n     substs: SubstsRef<'tcx>,\n     ty: Ty<'tcx>,"}, {"sha": "0c670e5e7179a132328347c9420b2366fb1a1a21", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f1406378a31b9f5e9012d882ae237131e3c252/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d7f1406378a31b9f5e9012d882ae237131e3c252", "patch": "@@ -1492,12 +1492,13 @@ impl GenericParamDefKind {\n         }\n     }\n \n-    pub fn get_type(&self, cx: &DocContext<'_>) -> Option<Type> {\n-        match *self {\n-            GenericParamDefKind::Type { did, .. } => {\n-                rustc_typeck::checked_type_of(cx.tcx, did, false).map(|t| t.clean(cx))\n-            }\n-            GenericParamDefKind::Const { ref ty, .. } => Some(ty.clone()),\n+    // FIXME(eddyb) this either returns the default of a type parameter, or the\n+    // type of a `const` parameter. It seems that the intention is to *visit*\n+    // any embedded types, but `get_type` seems to be the wrong name for that.\n+    pub fn get_type(&self) -> Option<Type> {\n+        match self {\n+            GenericParamDefKind::Type { default, .. } => default.clone(),\n+            GenericParamDefKind::Const { ty, .. } => Some(ty.clone()),\n             GenericParamDefKind::Lifetime => None,\n         }\n     }\n@@ -1523,8 +1524,8 @@ impl GenericParamDef {\n         self.kind.is_type()\n     }\n \n-    pub fn get_type(&self, cx: &DocContext<'_>) -> Option<Type> {\n-        self.kind.get_type(cx)\n+    pub fn get_type(&self) -> Option<Type> {\n+        self.kind.get_type()\n     }\n \n     pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n@@ -1892,7 +1893,7 @@ fn get_real_types(\n                             if !x.is_type() {\n                                 continue\n                             }\n-                            if let Some(ty) = x.get_type(cx) {\n+                            if let Some(ty) = x.get_type() {\n                                 let adds = get_real_types(generics, &ty, cx, recurse + 1);\n                                 if !adds.is_empty() {\n                                     res.extend(adds);"}]}