{"sha": "a1f49730906ca27947cd99547f7295a1bcf83920", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExZjQ5NzMwOTA2Y2EyNzk0N2NkOTk1NDdmNzI5NWExYmNmODM5MjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-09T23:55:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-09T23:55:43Z"}, "message": "auto merge of #16662 : pczarn/rust/format-fmtstr-opt, r=brson\n\nBased on an observation that strings and arguments are always interleaved, thanks to #15832. Additionally optimize invocations where formatting parameters are unspecified for all arguments, e.g. `\"{} {:?} {:x}\"`, by emptying the `__STATIC_FMTARGS` array. Next, `Arguments::new` replaces an empty slice with `None` so that passing empty `__STATIC_FMTARGS` generates slightly less machine code when `Arguments::new` is inlined. Furthermore, formatting itself treats these cases separately without making redundant copies of formatting parameters.\r\n\r\nAll in all, this adds a single mov instruction per `write!` in most cases. That's why code size has increased.", "tree": {"sha": "4894feeb3041bedbce1a7febdf2916e142dcbede", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4894feeb3041bedbce1a7febdf2916e142dcbede"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1f49730906ca27947cd99547f7295a1bcf83920", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1f49730906ca27947cd99547f7295a1bcf83920", "html_url": "https://github.com/rust-lang/rust/commit/a1f49730906ca27947cd99547f7295a1bcf83920", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1f49730906ca27947cd99547f7295a1bcf83920/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "651106462c357b71a4ca2c02ba2bfedfc38b0035", "url": "https://api.github.com/repos/rust-lang/rust/commits/651106462c357b71a4ca2c02ba2bfedfc38b0035", "html_url": "https://github.com/rust-lang/rust/commit/651106462c357b71a4ca2c02ba2bfedfc38b0035"}, {"sha": "fcf88b8f87597f97112f048eaa296b3127e51d0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcf88b8f87597f97112f048eaa296b3127e51d0b", "html_url": "https://github.com/rust-lang/rust/commit/fcf88b8f87597f97112f048eaa296b3127e51d0b"}], "stats": {"total": 298, "additions": 232, "deletions": 66}, "files": [{"sha": "be75bfec32c86dd9fb172a5e42ce8dbbee0c39fd", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/a1f49730906ca27947cd99547f7295a1bcf83920/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1f49730906ca27947cd99547f7295a1bcf83920/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=a1f49730906ca27947cd99547f7295a1bcf83920", "patch": "@@ -113,6 +113,33 @@ impl<'a> Arguments<'a> {\n     /// Arguments structure. The compiler inserts an `unsafe` block to call this,\n     /// which is valid because the compiler performs all necessary validation to\n     /// ensure that the resulting call to format/write would be safe.\n+    #[cfg(not(stage0))]\n+    #[doc(hidden)] #[inline]\n+    pub unsafe fn new<'a>(pieces: &'static [&'static str],\n+                          args: &'a [Argument<'a>]) -> Arguments<'a> {\n+        Arguments {\n+            pieces: mem::transmute(pieces),\n+            fmt: None,\n+            args: args\n+        }\n+    }\n+\n+    /// This function is used to specify nonstandard formatting parameters.\n+    /// The `pieces` array must be at least as long as `fmt` to construct\n+    /// a valid Arguments structure.\n+    #[cfg(not(stage0))]\n+    #[doc(hidden)] #[inline]\n+    pub unsafe fn with_placeholders<'a>(pieces: &'static [&'static str],\n+                                        fmt: &'static [rt::Argument<'static>],\n+                                        args: &'a [Argument<'a>]) -> Arguments<'a> {\n+        Arguments {\n+            pieces: mem::transmute(pieces),\n+            fmt: Some(mem::transmute(fmt)),\n+            args: args\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     #[doc(hidden)] #[inline]\n     pub unsafe fn new<'a>(fmt: &'static [rt::Piece<'static>],\n                           args: &'a [Argument<'a>]) -> Arguments<'a> {\n@@ -129,6 +156,20 @@ impl<'a> Arguments<'a> {\n /// and pass it to a function or closure, passed as the first argument. The\n /// macro validates the format string at compile-time so usage of the `write`\n /// and `format` functions can be safely performed.\n+#[cfg(not(stage0))]\n+pub struct Arguments<'a> {\n+    // Format string pieces to print.\n+    pieces: &'a [&'a str],\n+\n+    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n+    fmt: Option<&'a [rt::Argument<'a>]>,\n+\n+    // Dynamic arguments for interpolation, to be interleaved with string\n+    // pieces. (Every argument is preceded by a string piece.)\n+    args: &'a [Argument<'a>],\n+}\n+\n+#[cfg(stage0)] #[doc(hidden)]\n pub struct Arguments<'a> {\n     fmt: &'a [rt::Piece<'a>],\n     args: &'a [Argument<'a>],\n@@ -255,6 +296,18 @@ uniform_fn_call_workaround! {\n     secret_upper_exp, UpperExp;\n }\n \n+#[cfg(not(stage0))]\n+static DEFAULT_ARGUMENT: rt::Argument<'static> = rt::Argument {\n+    position: rt::ArgumentNext,\n+    format: rt::FormatSpec {\n+        fill: ' ',\n+        align: rt::AlignUnknown,\n+        flags: 0,\n+        precision: rt::CountImplied,\n+        width: rt::CountImplied,\n+    }\n+};\n+\n /// The `write` function takes an output stream, a precompiled format string,\n /// and a list of arguments. The arguments will be formatted according to the\n /// specified format string into the output stream provided.\n@@ -263,6 +316,51 @@ uniform_fn_call_workaround! {\n ///\n ///   * output - the buffer to write output to\n ///   * args - the precompiled arguments generated by `format_args!`\n+#[cfg(not(stage0))]\n+pub fn write(output: &mut FormatWriter, args: &Arguments) -> Result {\n+    let mut formatter = Formatter {\n+        flags: 0,\n+        width: None,\n+        precision: None,\n+        buf: output,\n+        align: rt::AlignUnknown,\n+        fill: ' ',\n+        args: args.args,\n+        curarg: args.args.iter(),\n+    };\n+\n+    let mut pieces = args.pieces.iter();\n+\n+    match args.fmt {\n+        None => {\n+            // We can use default formatting parameters for all arguments.\n+            for _ in range(0, args.args.len()) {\n+                try!(formatter.buf.write(pieces.next().unwrap().as_bytes()));\n+                try!(formatter.run(&DEFAULT_ARGUMENT));\n+            }\n+        }\n+        Some(fmt) => {\n+            // Every spec has a corresponding argument that is preceded by\n+            // a string piece.\n+            for (arg, piece) in fmt.iter().zip(pieces.by_ref()) {\n+                try!(formatter.buf.write(piece.as_bytes()));\n+                try!(formatter.run(arg));\n+            }\n+        }\n+    }\n+\n+    // There can be only one trailing string piece left.\n+    match pieces.next() {\n+        Some(piece) => {\n+            try!(formatter.buf.write(piece.as_bytes()));\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+#[cfg(stage0)] #[doc(hidden)]\n pub fn write(output: &mut FormatWriter, args: &Arguments) -> Result {\n     let mut formatter = Formatter {\n         flags: 0,\n@@ -285,7 +383,26 @@ impl<'a> Formatter<'a> {\n     // First up is the collection of functions used to execute a format string\n     // at runtime. This consumes all of the compile-time statics generated by\n     // the format! syntax extension.\n+    #[cfg(not(stage0))]\n+    fn run(&mut self, arg: &rt::Argument) -> Result {\n+        // Fill in the format parameters into the formatter\n+        self.fill = arg.format.fill;\n+        self.align = arg.format.align;\n+        self.flags = arg.format.flags;\n+        self.width = self.getcount(&arg.format.width);\n+        self.precision = self.getcount(&arg.format.precision);\n+\n+        // Extract the correct argument\n+        let value = match arg.position {\n+            rt::ArgumentNext => { *self.curarg.next().unwrap() }\n+            rt::ArgumentIs(i) => self.args[i],\n+        };\n+\n+        // Then actually do some printing\n+        (value.formatter)(value.value, self)\n+    }\n \n+    #[cfg(stage0)] #[doc(hidden)]\n     fn run(&mut self, piece: &rt::Piece) -> Result {\n         match *piece {\n             rt::String(s) => self.buf.write(s.as_bytes()),"}, {"sha": "59fbde88d8be3ad9e1979e250334e0ba8c44b4c0", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1f49730906ca27947cd99547f7295a1bcf83920/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1f49730906ca27947cd99547f7295a1bcf83920/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=a1f49730906ca27947cd99547f7295a1bcf83920", "patch": "@@ -14,7 +14,7 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n-\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub enum Piece<'a> {\n     String(&'a str),"}, {"sha": "3f2208e6c2dadedaac61638a8912838f95f01caf", "filename": "src/libcoretest/fmt/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1f49730906ca27947cd99547f7295a1bcf83920/src%2Flibcoretest%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1f49730906ca27947cd99547f7295a1bcf83920/src%2Flibcoretest%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fmod.rs?ref=a1f49730906ca27947cd99547f7295a1bcf83920", "patch": "@@ -9,3 +9,10 @@\n // except according to those terms.\n \n mod num;\n+\n+#[test]\n+fn test_format_flags() {\n+    // No residual flags left by pointer formatting\n+    let p = \"\".as_ptr();\n+    assert_eq!(format!(\"{:p} {:x}\", p, 16u), format!(\"{:p} 10\", p));\n+}"}, {"sha": "0bb32c73ca264ce666fb956819cb376515be6efa", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 99, "deletions": 51, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/a1f49730906ca27947cd99547f7295a1bcf83920/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1f49730906ca27947cd99547f7295a1bcf83920/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=a1f49730906ca27947cd99547f7295a1bcf83920", "patch": "@@ -49,11 +49,16 @@ struct Context<'a, 'b:'a> {\n     name_types: HashMap<String, ArgumentType>,\n     name_ordering: Vec<String>,\n \n-    /// The latest consecutive literal strings\n-    literal: Option<String>,\n+    /// The latest consecutive literal strings, or empty if there weren't any.\n+    literal: String,\n \n-    /// Collection of the compiled `rt::Piece` structures\n+    /// Collection of the compiled `rt::Argument` structures\n     pieces: Vec<Gc<ast::Expr>>,\n+    /// Collection of string literals\n+    str_pieces: Vec<Gc<ast::Expr>>,\n+    /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n+    all_pieces_simple: bool,\n+\n     name_positions: HashMap<String, uint>,\n     method_statics: Vec<Gc<ast::Item>>,\n \n@@ -370,28 +375,21 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    /// Translate the accumulated string literals to a static `rt::Piece`\n-    fn trans_literal_string(&mut self) -> Option<Gc<ast::Expr>> {\n+    /// Translate the accumulated string literals to a literal expression\n+    fn trans_literal_string(&mut self) -> Gc<ast::Expr> {\n         let sp = self.fmtsp;\n-        self.literal.take().map(|s| {\n-            let s = token::intern_and_get_ident(s.as_slice());\n-            self.ecx.expr_call_global(sp,\n-                                      self.rtpath(\"String\"),\n-                                      vec!(\n-                self.ecx.expr_str(sp, s)\n-            ))\n-        })\n+        let s = token::intern_and_get_ident(self.literal.as_slice());\n+        self.literal.clear();\n+        self.ecx.expr_str(sp, s)\n     }\n \n-    /// Translate a `parse::Piece` to a static `rt::Piece`\n+    /// Translate a `parse::Piece` to a static `rt::Argument` or append\n+    /// to the `literal` string.\n     fn trans_piece(&mut self, piece: &parse::Piece) -> Option<Gc<ast::Expr>> {\n         let sp = self.fmtsp;\n         match *piece {\n             parse::String(s) => {\n-                match self.literal {\n-                    Some(ref mut sb) => sb.push_str(s),\n-                    ref mut empty => *empty = Some(String::from_str(s)),\n-                }\n+                self.literal.push_str(s);\n                 None\n             }\n             parse::Argument(ref arg) => {\n@@ -420,8 +418,25 @@ impl<'a, 'b> Context<'a, 'b> {\n                     }\n                 };\n \n-                // Translate the format\n+                let simple_arg = parse::Argument {\n+                    position: parse::ArgumentNext,\n+                    format: parse::FormatSpec {\n+                        fill: arg.format.fill,\n+                        align: parse::AlignUnknown,\n+                        flags: 0,\n+                        precision: parse::CountImplied,\n+                        width: parse::CountImplied,\n+                        ty: arg.format.ty\n+                    }\n+                };\n+\n                 let fill = match arg.format.fill { Some(c) => c, None => ' ' };\n+\n+                if *arg != simple_arg || fill != ' ' {\n+                    self.all_pieces_simple = false;\n+                }\n+\n+                // Translate the format\n                 let fill = self.ecx.expr_lit(sp, ast::LitChar(fill));\n                 let align = match arg.format.align {\n                     parse::AlignLeft => {\n@@ -450,14 +465,33 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width)));\n \n                 let path = self.ecx.path_global(sp, self.rtpath(\"Argument\"));\n-                let s = self.ecx.expr_struct(sp, path, vec!(\n+                Some(self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt)));\n-                Some(self.ecx.expr_call_global(sp, self.rtpath(\"Argument\"), vec!(s)))\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt))))\n             }\n         }\n     }\n \n+    fn item_static_array(&self,\n+                         name: ast::Ident,\n+                         piece_ty: Gc<ast::Ty>,\n+                         pieces: Vec<Gc<ast::Expr>>)\n+        -> ast::Stmt\n+    {\n+        let pieces_len = self.ecx.expr_uint(self.fmtsp, pieces.len());\n+        let fmt = self.ecx.expr_vec(self.fmtsp, pieces);\n+        let ty = ast::TyFixedLengthVec(\n+            piece_ty,\n+            pieces_len\n+        );\n+        let ty = self.ecx.ty(self.fmtsp, ty);\n+        let st = ast::ItemStatic(ty, ast::MutImmutable, fmt);\n+        let item = self.ecx.item(self.fmtsp, name,\n+                                 self.static_attrs(), st);\n+        let decl = respan(self.fmtsp, ast::DeclItem(item));\n+        respan(self.fmtsp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n+    }\n+\n     /// Actually builds the expression which the iformat! block will be expanded\n     /// to\n     fn to_expr(&self, invocation: Invocation) -> Gc<ast::Expr> {\n@@ -476,30 +510,31 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         // Next, build up the static array which will become our precompiled\n         // format \"string\"\n-        let fmt = self.ecx.expr_vec(self.fmtsp, self.pieces.clone());\n-        let piece_ty = self.ecx.ty_path(self.ecx.path_all(\n+        let static_str_name = self.ecx.ident_of(\"__STATIC_FMTSTR\");\n+        let static_lifetime = self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"'static\").name);\n+        let piece_ty = self.ecx.ty_rptr(\n                 self.fmtsp,\n-                true, vec!(\n-                    self.ecx.ident_of(\"std\"),\n-                    self.ecx.ident_of(\"fmt\"),\n-                    self.ecx.ident_of(\"rt\"),\n-                    self.ecx.ident_of(\"Piece\")),\n-                vec!(self.ecx.lifetime(self.fmtsp,\n-                                       self.ecx.ident_of(\"'static\").name)),\n-                Vec::new()\n-            ), None);\n-        let ty = ast::TyFixedLengthVec(\n-            piece_ty,\n-            self.ecx.expr_uint(self.fmtsp, self.pieces.len())\n-        );\n-        let ty = self.ecx.ty(self.fmtsp, ty);\n-        let st = ast::ItemStatic(ty, ast::MutImmutable, fmt);\n-        let static_name = self.ecx.ident_of(\"__STATIC_FMTSTR\");\n-        let item = self.ecx.item(self.fmtsp, static_name,\n-                                 self.static_attrs(), st);\n-        let decl = respan(self.fmtsp, ast::DeclItem(item));\n-        lets.push(box(GC) respan(self.fmtsp,\n-                                 ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID)));\n+                self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),\n+                Some(static_lifetime),\n+                ast::MutImmutable);\n+        lets.push(box(GC) self.item_static_array(static_str_name,\n+                                                 piece_ty,\n+                                                 self.str_pieces.clone()));\n+\n+        // Then, build up the static array which will store our precompiled\n+        // nonstandard placeholders, if there are any.\n+        let static_args_name = self.ecx.ident_of(\"__STATIC_FMTARGS\");\n+        if !self.all_pieces_simple {\n+            let piece_ty = self.ecx.ty_path(self.ecx.path_all(\n+                    self.fmtsp,\n+                    true, self.rtpath(\"Argument\"),\n+                    vec![static_lifetime],\n+                    vec![]\n+                ), None);\n+            lets.push(box(GC) self.item_static_array(static_args_name,\n+                                                     piece_ty,\n+                                                     self.pieces.clone()));\n+        }\n \n         // Right now there is a bug such that for the expression:\n         //      foo(bar(&1))\n@@ -545,13 +580,21 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n \n         // Now create the fmt::Arguments struct with all our locals we created.\n-        let fmt = self.ecx.expr_ident(self.fmtsp, static_name);\n+        let pieces = self.ecx.expr_ident(self.fmtsp, static_str_name);\n         let args_slice = self.ecx.expr_ident(self.fmtsp, slicename);\n+\n+        let (fn_name, fn_args) = if self.all_pieces_simple {\n+            (\"new\", vec![pieces, args_slice])\n+        } else {\n+            let fmt = self.ecx.expr_ident(self.fmtsp, static_args_name);\n+            (\"with_placeholders\", vec![pieces, fmt, args_slice])\n+        };\n+\n         let result = self.ecx.expr_call_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n                 self.ecx.ident_of(\"Arguments\"),\n-                self.ecx.ident_of(\"new\")), vec!(fmt, args_slice));\n+                self.ecx.ident_of(fn_name)), fn_args);\n \n         // We did all the work of making sure that the arguments\n         // structure is safe, so we can safely have an unsafe block.\n@@ -718,8 +761,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         name_ordering: name_ordering,\n         nest_level: 0,\n         next_arg: 0,\n-        literal: None,\n+        literal: String::new(),\n         pieces: Vec::new(),\n+        str_pieces: Vec::new(),\n+        all_pieces_simple: true,\n         method_statics: Vec::new(),\n         fmtsp: sp,\n     };\n@@ -739,8 +784,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                 cx.verify_piece(&piece);\n                 match cx.trans_piece(&piece) {\n                     Some(piece) => {\n-                        cx.trans_literal_string().map(|piece|\n-                                                      cx.pieces.push(piece));\n+                        let s = cx.trans_literal_string();\n+                        cx.str_pieces.push(s);\n                         cx.pieces.push(piece);\n                     }\n                     None => {}\n@@ -758,7 +803,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         }\n         None => {}\n     }\n-    cx.trans_literal_string().map(|piece| cx.pieces.push(piece));\n+    if !cx.literal.is_empty() {\n+        let s = cx.trans_literal_string();\n+        cx.str_pieces.push(s);\n+    }\n \n     // Make sure that all arguments were used and all arguments have types.\n     for (i, ty) in cx.arg_types.iter().enumerate() {"}, {"sha": "376a3a38fda1ed3d566a8dc2550ff1b6008f37e5", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a1f49730906ca27947cd99547f7295a1bcf83920/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/a1f49730906ca27947cd99547f7295a1bcf83920/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=a1f49730906ca27947cd99547f7295a1bcf83920", "patch": "@@ -39,26 +39,20 @@\n          () => {\n              #[inline]\n              #[allow(dead_code)]\n-             static __STATIC_FMTSTR:\n-                    [::std::fmt::rt::Piece<'static>, ..(1u as uint)] =\n-                 ([((::std::fmt::rt::String as\n-                        fn(&'static str) -> core::fmt::rt::Piece<'static>)((\"test\"\n-                                                                               as\n-                                                                               &'static str))\n-                       as core::fmt::rt::Piece<'static>)] as\n-                     [core::fmt::rt::Piece<'static>, .. 1]);\n+             static __STATIC_FMTSTR: [&'static str, ..(1u as uint)] =\n+                 ([(\"test\" as &'static str)] as [&'static str, .. 1]);\n              let __args_vec =\n                  (&([] as [core::fmt::Argument<'_>, .. 0]) as\n                      &[core::fmt::Argument<'_>, .. 0]);\n              let __args =\n                  (unsafe {\n                       ((::std::fmt::Arguments::new as\n-                           unsafe fn(&'static [core::fmt::rt::Piece<'static>], &'a [core::fmt::Argument<'a>]) -> core::fmt::Arguments<'a>)((__STATIC_FMTSTR\n-                                                                                                                                               as\n-                                                                                                                                               [core::fmt::rt::Piece<'static>, .. 1]),\n-                                                                                                                                           (__args_vec\n-                                                                                                                                               as\n-                                                                                                                                               &[core::fmt::Argument<'_>, .. 0]))\n+                           unsafe fn(&'static [&'static str], &'a [core::fmt::Argument<'a>]) -> core::fmt::Arguments<'a>)((__STATIC_FMTSTR\n+                                                                                                                              as\n+                                                                                                                              [&'static str, .. 1]),\n+                                                                                                                          (__args_vec\n+                                                                                                                              as\n+                                                                                                                              &[core::fmt::Argument<'_>, .. 0]))\n                           as core::fmt::Arguments<'_>)\n                   } as core::fmt::Arguments<'_>);\n "}]}