{"sha": "5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNGE5OWZhOGJmY2RkMjdlMGIwN2ZjZmZjNTY5NDE2YTMxODhhMzU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-16T18:33:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-16T18:33:10Z"}, "message": "Merge remote-tracking branch 'origin/master' into gen", "tree": {"sha": "e3b402fc030ed9998448823591e288be55cf2e94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3b402fc030ed9998448823591e288be55cf2e94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "html_url": "https://github.com/rust-lang/rust/commit/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0697e4b17afbcf2b8d912a42d28c841aba07e088", "url": "https://api.github.com/repos/rust-lang/rust/commits/0697e4b17afbcf2b8d912a42d28c841aba07e088", "html_url": "https://github.com/rust-lang/rust/commit/0697e4b17afbcf2b8d912a42d28c841aba07e088"}, {"sha": "00a6797f05607ed0d29d25378fb502a8a9b0a6bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/00a6797f05607ed0d29d25378fb502a8a9b0a6bf", "html_url": "https://github.com/rust-lang/rust/commit/00a6797f05607ed0d29d25378fb502a8a9b0a6bf"}], "stats": {"total": 4048, "additions": 2945, "deletions": 1103}, "files": [{"sha": "b5db5ce36133f33978aad38301c783b63ff8bbab", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -1452,6 +1452,7 @@ dependencies = [\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "5985dcb97c739b170ccceed2c727824dceb10691", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -918,6 +918,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"when debug-printing compiler state, do not include spans\"), // o/w tests have closure@path\n     identify_regions: bool = (false, parse_bool, [UNTRACKED],\n         \"make unnamed regions display as '# (where # is some non-ident unique id)\"),\n+    borrowck_mir: bool = (false, parse_bool, [UNTRACKED],\n+        \"implicitly treat functions as if they have `#[rustc_mir_borrowck]` attribute\"),\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass\"),\n     count_llvm_insns: bool = (false, parse_bool,"}, {"sha": "4058f3198afb4f52e8430c63fa07abf037324338", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 22, "deletions": 37, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -29,6 +29,7 @@ use rustc::ty::{self, TyCtxt};\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n+use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n \n use std::rc::Rc;\n \n@@ -465,10 +466,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             let mut err = match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0499,\n-                                                      \"cannot borrow `{}`{} as mutable \\\n-                                                      more than once at a time\",\n-                                                      nl, new_loan_msg);\n+                    let mut err = self.bccx.cannot_mutably_borrow_multiply(\n+                        new_loan.span, &nl, &new_loan_msg, Origin::Ast);\n \n                     if new_loan.span == old_loan.span {\n                         // Both borrows are happening in the same place\n@@ -496,10 +495,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n \n                 (ty::UniqueImmBorrow, ty::UniqueImmBorrow) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0524,\n-                                     \"two closures require unique access to `{}` \\\n-                                      at the same time\",\n-                                     nl);\n+                    let mut err = self.bccx.cannot_uniquely_borrow_by_two_closures(\n+                        new_loan.span, &nl, Origin::Ast);\n                     err.span_label(\n                             old_loan.span,\n                             \"first closure is constructed here\");\n@@ -513,10 +510,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0500,\n-                                                   \"closure requires unique access to `{}` \\\n-                                                   but {} is already borrowed{}\",\n-                                                   nl, ol_pronoun, old_loan_msg);\n+                    let mut err = self.bccx.cannot_uniquely_borrow_by_one_closure(\n+                        new_loan.span, &nl, &ol_pronoun, &old_loan_msg, Origin::Ast);\n                     err.span_label(\n                             new_loan.span,\n                             format!(\"closure construction occurs here{}\", new_loan_msg));\n@@ -530,10 +525,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0501,\n-                                                   \"cannot borrow `{}`{} as {} because \\\n-                                                   previous closure requires unique access\",\n-                                                   nl, new_loan_msg, new_loan.kind.to_user_str());\n+                    let new_loan_str = &new_loan.kind.to_user_str();\n+                    let mut err = self.bccx.cannot_reborrow_already_uniquely_borrowed(\n+                        new_loan.span, &nl, &new_loan_msg, new_loan_str, Origin::Ast);\n                     err.span_label(\n                             new_loan.span,\n                             format!(\"borrow occurs here{}\", new_loan_msg));\n@@ -547,15 +541,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n \n                 (..) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0502,\n-                                                   \"cannot borrow `{}`{} as {} because \\\n-                                                   {} is also borrowed as {}{}\",\n-                                                   nl,\n-                                                   new_loan_msg,\n-                                                   new_loan.kind.to_user_str(),\n-                                                   ol_pronoun,\n-                                                   old_loan.kind.to_user_str(),\n-                                                   old_loan_msg);\n+                    let mut err = self.bccx.cannot_reborrow_already_borrowed(\n+                        new_loan.span,\n+                        &nl, &new_loan_msg, &new_loan.kind.to_user_str(),\n+                        &ol_pronoun, &old_loan.kind.to_user_str(), &old_loan_msg, Origin::Ast);\n                     err.span_label(\n                             new_loan.span,\n                             format!(\"{} borrow occurs here{}\",\n@@ -645,9 +634,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         match self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow) {\n             UseOk => { }\n             UseWhileBorrowed(loan_path, loan_span) => {\n-                struct_span_err!(self.bccx, span, E0503,\n-                                 \"cannot use `{}` because it was mutably borrowed\",\n-                                 &self.bccx.loan_path_to_string(copy_path))\n+                let desc = self.bccx.loan_path_to_string(copy_path);\n+                self.bccx.cannot_use_when_mutably_borrowed(span, &desc, Origin::Ast)\n                     .span_label(loan_span,\n                                format!(\"borrow of `{}` occurs here\",\n                                        &self.bccx.loan_path_to_string(&loan_path))\n@@ -673,9 +661,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             UseWhileBorrowed(loan_path, loan_span) => {\n                 let mut err = match move_kind {\n                     move_data::Captured => {\n-                        let mut err = struct_span_err!(self.bccx, span, E0504,\n-                                         \"cannot move `{}` into closure because it is borrowed\",\n-                                         &self.bccx.loan_path_to_string(move_path));\n+                        let mut err = self.bccx.cannot_move_into_closure(\n+                            span, &self.bccx.loan_path_to_string(move_path), Origin::Ast);\n                         err.span_label(\n                             loan_span,\n                             format!(\"borrow of `{}` occurs here\",\n@@ -690,9 +677,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat => {\n-                        let mut err = struct_span_err!(self.bccx, span, E0505,\n-                                         \"cannot move out of `{}` because it is borrowed\",\n-                                         &self.bccx.loan_path_to_string(move_path));\n+                        let desc = self.bccx.loan_path_to_string(move_path);\n+                        let mut err = self.bccx.cannot_move_when_borrowed(span, &desc, Origin::Ast);\n                         err.span_label(\n                             loan_span,\n                             format!(\"borrow of `{}` occurs here\",\n@@ -874,9 +860,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                    span: Span,\n                                    loan_path: &LoanPath<'tcx>,\n                                    loan: &Loan) {\n-        struct_span_err!(self.bccx, span, E0506,\n-                         \"cannot assign to `{}` because it is borrowed\",\n-                         self.bccx.loan_path_to_string(loan_path))\n+        self.bccx.cannot_assign_to_borrowed(\n+            span, &self.bccx.loan_path_to_string(loan_path), Origin::Ast)\n             .span_label(loan.span,\n                        format!(\"borrow of `{}` occurs here\",\n                                self.bccx.loan_path_to_string(loan_path)))"}, {"sha": "80ca16d23f52209c3a0a58cc3dfa88a4a2b7cfcf", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -37,6 +37,8 @@ use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::util::nodemap::FxHashMap;\n+use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n+\n use std::fmt;\n use std::rc::Rc;\n use std::hash::{Hash, Hasher};\n@@ -219,6 +221,25 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     body: &'tcx hir::Body,\n }\n \n+impl<'b, 'tcx: 'b> BorrowckErrors for BorrowckCtxt<'b, 'tcx> {\n+    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+                                                         sp: S,\n+                                                         msg: &str,\n+                                                         code: &str)\n+                                                         -> DiagnosticBuilder<'a>\n+    {\n+        self.tcx.sess.struct_span_err_with_code(sp, msg, code)\n+    }\n+\n+    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n+                                               sp: S,\n+                                               msg: &str)\n+                                               -> DiagnosticBuilder<'a>\n+    {\n+        self.tcx.sess.struct_span_err(sp, msg)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Loans and loan paths\n \n@@ -548,14 +569,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             move_data::Declared => {\n                 // If this is an uninitialized variable, just emit a simple warning\n                 // and return.\n-                struct_span_err!(\n-                    self.tcx.sess, use_span, E0381,\n-                    \"{} of possibly uninitialized variable: `{}`\",\n-                    verb,\n-                    self.loan_path_to_string(lp))\n-                .span_label(use_span, format!(\"use of possibly uninitialized `{}`\",\n-                    self.loan_path_to_string(lp)))\n-                .emit();\n+                self.cannot_act_on_uninitialized_variable(use_span,\n+                                                          verb,\n+                                                          &self.loan_path_to_string(lp),\n+                                                          Origin::Ast)\n+                    .span_label(use_span, format!(\"use of possibly uninitialized `{}`\",\n+                                                  self.loan_path_to_string(lp)))\n+                    .emit();\n                 return;\n             }\n             _ => {\n@@ -682,10 +702,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                 lp: &LoanPath<'tcx>,\n                                                 assign:\n                                                 &move_data::Assignment) {\n-        let mut err = struct_span_err!(\n-            self.tcx.sess, span, E0384,\n-            \"re-assignment of immutable variable `{}`\",\n-            self.loan_path_to_string(lp));\n+        let mut err = self.cannot_reassign_immutable(span,\n+                                                     &self.loan_path_to_string(lp),\n+                                                     Origin::Ast);\n         err.span_label(span, \"re-assignment of immutable variable\");\n         if span != assign.span {\n             err.span_label(assign.span, format!(\"first assignment to `{}`\","}, {"sha": "50a9dccaa2bb8fa7aff8eb10ac8602f41f62048d", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 550, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -63,27 +63,6 @@ Now that the closure has its own copy of the data, there's no need to worry\n about safety.\n \"##,\n \n-E0381: r##\"\n-It is not allowed to use or capture an uninitialized variable. For example:\n-\n-```compile_fail,E0381\n-fn main() {\n-    let x: i32;\n-    let y = x; // error, use of possibly uninitialized variable\n-}\n-```\n-\n-To fix this, ensure that any declared variables are initialized before being\n-used. Example:\n-\n-```\n-fn main() {\n-    let x: i32 = 0;\n-    let y = x; // ok!\n-}\n-```\n-\"##,\n-\n E0382: r##\"\n This error occurs when an attempt is made to use a variable after its contents\n have been moved elsewhere. For example:\n@@ -182,28 +161,6 @@ x = Foo { a: 2 };\n ```\n \"##,\n \n-E0384: r##\"\n-This error occurs when an attempt is made to reassign an immutable variable.\n-For example:\n-\n-```compile_fail,E0384\n-fn main() {\n-    let x = 3;\n-    x = 5; // error, reassignment of immutable variable\n-}\n-```\n-\n-By default, variables in Rust are immutable. To fix this error, add the keyword\n-`mut` after the keyword `let` when declaring the variable. For example:\n-\n-```\n-fn main() {\n-    let mut x = 3;\n-    x = 5;\n-}\n-```\n-\"##,\n-\n /*E0386: r##\"\n This error occurs when an attempt is made to mutate the target of a mutable\n reference stored inside an immutable container.\n@@ -360,512 +317,6 @@ fn main() {\n ```\n \"##,\n \n-E0499: r##\"\n-A variable was borrowed as mutable more than once. Erroneous code example:\n-\n-```compile_fail,E0499\n-let mut i = 0;\n-let mut x = &mut i;\n-let mut a = &mut i;\n-// error: cannot borrow `i` as mutable more than once at a time\n-```\n-\n-Please note that in rust, you can either have many immutable references, or one\n-mutable reference. Take a look at\n-https://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n-for more information. Example:\n-\n-\n-```\n-let mut i = 0;\n-let mut x = &mut i; // ok!\n-\n-// or:\n-let mut i = 0;\n-let a = &i; // ok!\n-let b = &i; // still ok!\n-let c = &i; // still ok!\n-```\n-\"##,\n-\n-E0500: r##\"\n-A borrowed variable was used in another closure. Example of erroneous code:\n-\n-```compile_fail\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    let nights_watch = || {\n-        *jon_snow = 2;\n-    };\n-    let starks = || {\n-        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n-                       //        but it is already borrowed\n-    };\n-}\n-```\n-\n-In here, `jon_snow` is already borrowed by the `nights_watch` closure, so it\n-cannot be borrowed by the `starks` closure at the same time. To fix this issue,\n-you can put the closure in its own scope:\n-\n-```\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    {\n-        let nights_watch = || {\n-            *jon_snow = 2;\n-        };\n-    } // At this point, `jon_snow` is free.\n-    let starks = || {\n-        *jon_snow = 3;\n-    };\n-}\n-```\n-\n-Or, if the type implements the `Clone` trait, you can clone it between\n-closures:\n-\n-```\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    let mut jon_copy = jon_snow.clone();\n-    let nights_watch = || {\n-        jon_copy = 2;\n-    };\n-    let starks = || {\n-        *jon_snow = 3;\n-    };\n-}\n-```\n-\"##,\n-\n-E0501: r##\"\n-This error indicates that a mutable variable is being used while it is still\n-captured by a closure. Because the closure has borrowed the variable, it is not\n-available for use until the closure goes out of scope.\n-\n-Note that a capture will either move or borrow a variable, but in this\n-situation, the closure is borrowing the variable. Take a look at\n-http://rustbyexample.com/fn/closures/capture.html for more information about\n-capturing.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0501\n-fn inside_closure(x: &mut i32) {\n-    // Actions which require unique access\n-}\n-\n-fn outside_closure(x: &mut i32) {\n-    // Actions which require unique access\n-}\n-\n-fn foo(a: &mut i32) {\n-    let bar = || {\n-        inside_closure(a)\n-    };\n-    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n-                        //        closure requires unique access.\n-}\n-```\n-\n-To fix this error, you can place the closure in its own scope:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    {\n-        let bar = || {\n-            inside_closure(a)\n-        };\n-    } // borrow on `a` ends.\n-    outside_closure(a); // ok!\n-}\n-```\n-\n-Or you can pass the variable as a parameter to the closure:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    let bar = |s: &mut i32| {\n-        inside_closure(s)\n-    };\n-    outside_closure(a);\n-    bar(a);\n-}\n-```\n-\n-It may be possible to define the closure later:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    outside_closure(a);\n-    let bar = || {\n-        inside_closure(a)\n-    };\n-}\n-```\n-\"##,\n-\n-E0502: r##\"\n-This error indicates that you are trying to borrow a variable as mutable when it\n-has already been borrowed as immutable.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0502\n-fn bar(x: &mut i32) {}\n-fn foo(a: &mut i32) {\n-    let ref y = a; // a is borrowed as immutable.\n-    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n-            //        as immutable\n-}\n-```\n-\n-To fix this error, ensure that you don't have any other references to the\n-variable before trying to access it mutably:\n-\n-```\n-fn bar(x: &mut i32) {}\n-fn foo(a: &mut i32) {\n-    bar(a);\n-    let ref y = a; // ok!\n-}\n-```\n-\n-For more information on the rust ownership system, take a look at\n-https://doc.rust-lang.org/book/first-edition/references-and-borrowing.html.\n-\"##,\n-\n-E0503: r##\"\n-A value was used after it was mutably borrowed.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0503\n-fn main() {\n-    let mut value = 3;\n-    // Create a mutable borrow of `value`. This borrow\n-    // lives until the end of this function.\n-    let _borrow = &mut value;\n-    let _sum = value + 1; // error: cannot use `value` because\n-                          //        it was mutably borrowed\n-}\n-```\n-\n-In this example, `value` is mutably borrowed by `borrow` and cannot be\n-used to calculate `sum`. This is not possible because this would violate\n-Rust's mutability rules.\n-\n-You can fix this error by limiting the scope of the borrow:\n-\n-```\n-fn main() {\n-    let mut value = 3;\n-    // By creating a new block, you can limit the scope\n-    // of the reference.\n-    {\n-        let _borrow = &mut value; // Use `_borrow` inside this block.\n-    }\n-    // The block has ended and with it the borrow.\n-    // You can now use `value` again.\n-    let _sum = value + 1;\n-}\n-```\n-\n-Or by cloning `value` before borrowing it:\n-\n-```\n-fn main() {\n-    let mut value = 3;\n-    // We clone `value`, creating a copy.\n-    let value_cloned = value.clone();\n-    // The mutable borrow is a reference to `value` and\n-    // not to `value_cloned`...\n-    let _borrow = &mut value;\n-    // ... which means we can still use `value_cloned`,\n-    let _sum = value_cloned + 1;\n-    // even though the borrow only ends here.\n-}\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n-\"##,\n-\n-E0504: r##\"\n-This error occurs when an attempt is made to move a borrowed variable into a\n-closure.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0504\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-\n-    let x = move || {\n-        println!(\"child function: {}\", fancy_num.num);\n-        // error: cannot move `fancy_num` into closure because it is borrowed\n-    };\n-\n-    x();\n-    println!(\"main function: {}\", fancy_ref.num);\n-}\n-```\n-\n-Here, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\n-the closure `x`. There is no way to move a value into a closure while it is\n-borrowed, as that would invalidate the borrow.\n-\n-If the closure can't outlive the value being moved, try using a reference\n-rather than moving:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-\n-    let x = move || {\n-        // fancy_ref is usable here because it doesn't move `fancy_num`\n-        println!(\"child function: {}\", fancy_ref.num);\n-    };\n-\n-    x();\n-\n-    println!(\"main function: {}\", fancy_num.num);\n-}\n-```\n-\n-If the value has to be borrowed and then moved, try limiting the lifetime of\n-the borrow using a scoped block:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-\n-    {\n-        let fancy_ref = &fancy_num;\n-        println!(\"main function: {}\", fancy_ref.num);\n-        // `fancy_ref` goes out of scope here\n-    }\n-\n-    let x = move || {\n-        // `fancy_num` can be moved now (no more references exist)\n-        println!(\"child function: {}\", fancy_num.num);\n-    };\n-\n-    x();\n-}\n-```\n-\n-If the lifetime of a reference isn't enough, such as in the case of threading,\n-consider using an `Arc` to create a reference-counted value:\n-\n-```\n-use std::sync::Arc;\n-use std::thread;\n-\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n-    let fancy_ref2 = fancy_ref1.clone();\n-\n-    let x = thread::spawn(move || {\n-        // `fancy_ref1` can be moved and has a `'static` lifetime\n-        println!(\"child thread: {}\", fancy_ref1.num);\n-    });\n-\n-    x.join().expect(\"child thread should finish\");\n-    println!(\"main thread: {}\", fancy_ref2.num);\n-}\n-```\n-\"##,\n-\n-E0505: r##\"\n-A value was moved out while it was still borrowed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0505\n-struct Value {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-        eat(x);\n-    }\n-}\n-```\n-\n-Here, the function `eat` takes the ownership of `x`. However,\n-`x` cannot be moved because it was borrowed to `_ref_to_val`.\n-To fix that you can do few different things:\n-\n-* Try to avoid moving the variable.\n-* Release borrow before move.\n-* Implement the `Copy` trait on the type.\n-\n-Examples:\n-\n-```\n-struct Value {}\n-\n-fn eat(val: &Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-        eat(&x); // pass by reference, if it's possible\n-    }\n-}\n-```\n-\n-Or:\n-\n-```\n-struct Value {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-    }\n-    eat(x); // release borrow and then move it.\n-}\n-```\n-\n-Or:\n-\n-```\n-#[derive(Clone, Copy)] // implement Copy trait\n-struct Value {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-        eat(x); // it will be copied here.\n-    }\n-}\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n-\"##,\n-\n-E0506: r##\"\n-This error occurs when an attempt is made to assign to a borrowed value.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0506\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-    fancy_num = FancyNum { num: 6 };\n-    // error: cannot assign to `fancy_num` because it is borrowed\n-\n-    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n-}\n-```\n-\n-Because `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\n-be assigned to a new value as it would invalidate the reference.\n-\n-Alternatively, we can move out of `fancy_num` into a second `fancy_num`:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-    let moved_num = fancy_num;\n-    fancy_num = FancyNum { num: 6 };\n-\n-    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n-}\n-```\n-\n-If the value has to be borrowed, try limiting the lifetime of the borrow using\n-a scoped block:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-\n-    {\n-        let fancy_ref = &fancy_num;\n-        println!(\"Ref: {}\", fancy_ref.num);\n-    }\n-\n-    // Works because `fancy_ref` is no longer in scope\n-    fancy_num = FancyNum { num: 6 };\n-    println!(\"Num: {}\", fancy_num.num);\n-}\n-```\n-\n-Or by moving the reference into a function:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-\n-    print_fancy_ref(&fancy_num);\n-\n-    // Works because function borrow has ended\n-    fancy_num = FancyNum { num: 6 };\n-    println!(\"Num: {}\", fancy_num.num);\n-}\n-\n-fn print_fancy_ref(fancy_ref: &FancyNum){\n-    println!(\"Ref: {}\", fancy_ref.num);\n-}\n-```\n-\"##,\n-\n E0507: r##\"\n You tried to move out of a value which was borrowed. Erroneous code example:\n \n@@ -1291,7 +742,6 @@ b.resume();\n \n register_diagnostics! {\n //    E0385, // {} in an aliasable location\n-    E0524, // two closures require unique access to `..` at the same time\n     E0594, // cannot assign to {}\n     E0598, // lifetime of {} is too short to guarantee its contents can be...\n }"}, {"sha": "47fa21e3bf0b2bf6a1e47f4d6c78b94c1aca9246", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -171,6 +171,70 @@ impl<T: Idx> IdxSet<T> {\n             _pd: PhantomData,\n         }\n     }\n+\n+    /// Calls `f` on each index value held in this set, up to the\n+    /// bound `max_bits` on the size of universe of indexes.\n+    pub fn each_bit<F>(&self, max_bits: usize, f: F) where F: FnMut(T) {\n+        each_bit(self, max_bits, f)\n+    }\n+\n+    /// Removes all elements from this set.\n+    pub fn reset_to_empty(&mut self) {\n+        for word in self.words_mut() { *word = 0; }\n+    }\n+\n+    pub fn elems(&self, universe_size: usize) -> Elems<T> {\n+        Elems { i: 0, set: self, universe_size: universe_size }\n+    }\n+}\n+\n+pub struct Elems<'a, T: Idx> { i: usize, set: &'a IdxSet<T>, universe_size: usize }\n+\n+impl<'a, T: Idx> Iterator for Elems<'a, T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<T> {\n+        if self.i >= self.universe_size { return None; }\n+        let mut i = self.i;\n+        loop {\n+            if i >= self.universe_size {\n+                self.i = i; // (mark iteration as complete.)\n+                return None;\n+            }\n+            if self.set.contains(&T::new(i)) {\n+                self.i = i + 1; // (next element to start at.)\n+                return Some(T::new(i));\n+            }\n+            i = i + 1;\n+        }\n+    }\n+}\n+\n+fn each_bit<T: Idx, F>(words: &IdxSet<T>, max_bits: usize, mut f: F) where F: FnMut(T) {\n+    let usize_bits: usize = mem::size_of::<usize>() * 8;\n+\n+    for (word_index, &word) in words.words().iter().enumerate() {\n+        if word != 0 {\n+            let base_index = word_index * usize_bits;\n+            for offset in 0..usize_bits {\n+                let bit = 1 << offset;\n+                if (word & bit) != 0 {\n+                    // NB: we round up the total number of bits\n+                    // that we store in any given bit set so that\n+                    // it is an even multiple of usize::BITS. This\n+                    // means that there may be some stray bits at\n+                    // the end that do not correspond to any\n+                    // actual value; that's why we first check\n+                    // that we are in range of bits_per_block.\n+                    let bit_index = base_index + offset as usize;\n+                    if bit_index >= max_bits {\n+                        return;\n+                    } else {\n+                        f(Idx::new(bit_index));\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n pub struct Iter<'a, T: Idx> {"}, {"sha": "19d237b7761d355cf0be02dc0ee48d454a40fad1", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -970,14 +970,23 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     // We compute \"constant qualifications\" between MIR_CONST and MIR_VALIDATED.\n \n     // What we need to run borrowck etc.\n+\n     passes.push_pass(MIR_VALIDATED, mir::transform::qualify_consts::QualifyAndPromoteConstants);\n+\n+    // FIXME: ariel points SimplifyBranches should run after\n+    // mir-borrowck; otherwise code within `if false { ... }` would\n+    // not be checked.\n     passes.push_pass(MIR_VALIDATED,\n                      mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n     passes.push_pass(MIR_VALIDATED, mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n     passes.push_pass(MIR_VALIDATED, mir::transform::nll::NLL);\n \n     // borrowck runs between MIR_VALIDATED and MIR_OPTIMIZED.\n \n+    // FIXME: niko says this should be a query (see rustc::ty::maps)\n+    // instead of a pass.\n+    passes.push_pass(MIR_VALIDATED, mir::transform::borrow_check::BorrowckMir);\n+\n     // These next passes must be executed together\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::CriticalCallEdges);"}, {"sha": "49e626c540082869d2b45f330c3badb0227adb4a", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -15,6 +15,7 @@ rustc = { path = \"../librustc\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "bd41bce67da8ead21670beefeba21af6ba57b5a3", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 2, "deletions": 70, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -8,84 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::ast::{self, MetaItem};\n use syntax_pos::DUMMY_SP;\n \n-\n-use rustc::mir::{self, Mir, BasicBlock, Location};\n-use rustc::session::Session;\n+use rustc::mir::{self, Mir, Location};\n use rustc::ty::{self, TyCtxt};\n use util::elaborate_drops::DropFlagState;\n-use rustc_data_structures::indexed_set::{IdxSet};\n-\n-use std::fmt;\n \n-use super::{Dataflow, DataflowBuilder, DataflowAnalysis};\n-use super::{BitDenotation, DataflowOperator, DataflowResults};\n+use super::{MoveDataParamEnv};\n use super::indexes::MovePathIndex;\n use super::move_paths::{MoveData, LookupResult};\n \n-pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<MetaItem> {\n-    for attr in attrs {\n-        if attr.check_name(\"rustc_mir\") {\n-            let items = attr.meta_item_list();\n-            for item in items.iter().flat_map(|l| l.iter()) {\n-                match item.meta_item() {\n-                    Some(mi) if mi.check_name(name) => return Some(mi.clone()),\n-                    _ => continue\n-                }\n-            }\n-        }\n-    }\n-    return None;\n-}\n-\n-pub struct MoveDataParamEnv<'tcx> {\n-    pub(crate) move_data: MoveData<'tcx>,\n-    pub(crate) param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-pub(crate) fn do_dataflow<'a, 'tcx, BD, P>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                mir: &Mir<'tcx>,\n-                                node_id: ast::NodeId,\n-                                attributes: &[ast::Attribute],\n-                                dead_unwinds: &IdxSet<BasicBlock>,\n-                                bd: BD,\n-                                p: P)\n-                                -> DataflowResults<BD>\n-    where BD: BitDenotation<Idx=MovePathIndex> + DataflowOperator,\n-          P: Fn(&BD, BD::Idx) -> &fmt::Debug\n-{\n-    let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n-        if let Some(item) = has_rustc_mir_with(attrs, name) {\n-            if let Some(s) = item.value_str() {\n-                return Some(s.to_string())\n-            } else {\n-                sess.span_err(\n-                    item.span,\n-                    &format!(\"{} attribute requires a path\", item.name()));\n-                return None;\n-            }\n-        }\n-        return None;\n-    };\n-\n-    let print_preflow_to =\n-        name_found(tcx.sess, attributes, \"borrowck_graphviz_preflow\");\n-    let print_postflow_to =\n-        name_found(tcx.sess, attributes, \"borrowck_graphviz_postflow\");\n-\n-    let mut mbcx = DataflowBuilder {\n-        node_id,\n-        print_preflow_to,\n-        print_postflow_to,\n-        flow_state: DataflowAnalysis::new(tcx, mir, dead_unwinds, bd),\n-    };\n-\n-    mbcx.dataflow(p);\n-    mbcx.flow_state.results()\n-}\n-\n pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n                                         path: MovePathIndex,\n                                         mut cond: F)"}, {"sha": "7ff4fbcf199e0fc19381942050e7597c7af0e5fe", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -13,7 +13,6 @@\n use syntax::ast::NodeId;\n use rustc::mir::{BasicBlock, Mir};\n use rustc_data_structures::bitslice::bits_to_string;\n-use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n \n use dot;\n@@ -24,62 +23,13 @@ use std::fs::File;\n use std::io;\n use std::io::prelude::*;\n use std::marker::PhantomData;\n-use std::mem;\n use std::path::Path;\n \n use util;\n \n use super::{BitDenotation, DataflowState};\n use super::DataflowBuilder;\n \n-impl<O: BitDenotation> DataflowState<O> {\n-    fn each_bit<F>(&self, words: &IdxSet<O::Idx>, mut f: F)\n-        where F: FnMut(O::Idx) {\n-        //! Helper for iterating over the bits in a bitvector.\n-\n-        let bits_per_block = self.operator.bits_per_block();\n-        let usize_bits: usize = mem::size_of::<usize>() * 8;\n-\n-        for (word_index, &word) in words.words().iter().enumerate() {\n-            if word != 0 {\n-                let base_index = word_index * usize_bits;\n-                for offset in 0..usize_bits {\n-                    let bit = 1 << offset;\n-                    if (word & bit) != 0 {\n-                        // NB: we round up the total number of bits\n-                        // that we store in any given bit set so that\n-                        // it is an even multiple of usize::BITS. This\n-                        // means that there may be some stray bits at\n-                        // the end that do not correspond to any\n-                        // actual value; that's why we first check\n-                        // that we are in range of bits_per_block.\n-                        let bit_index = base_index + offset as usize;\n-                        if bit_index >= bits_per_block {\n-                            return;\n-                        } else {\n-                            f(O::Idx::new(bit_index));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn interpret_set<'c, P>(&self,\n-                                o: &'c O,\n-                                words: &IdxSet<O::Idx>,\n-                                render_idx: &P)\n-                                -> Vec<&'c Debug>\n-        where P: Fn(&O, O::Idx) -> &Debug\n-    {\n-        let mut v = Vec::new();\n-        self.each_bit(words, |i| {\n-            v.push(render_idx(o, i));\n-        });\n-        v\n-    }\n-}\n-\n pub trait MirWithFlowState<'tcx> {\n     type BD: BitDenotation;\n     fn node_id(&self) -> NodeId;"}, {"sha": "ab62342e607dd07e5a68eb78d196a76bdee87826", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -0,0 +1,180 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::mir::{self, Location, Mir};\n+use rustc::mir::visit::Visitor;\n+use rustc::ty::{Region, TyCtxt};\n+use rustc::ty::RegionKind::ReScope;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+\n+use rustc_data_structures::bitslice::{BitwiseOperator};\n+use rustc_data_structures::indexed_set::{IdxSet};\n+use rustc_data_structures::indexed_vec::{IndexVec};\n+\n+use dataflow::{BitDenotation, BlockSets, DataflowOperator};\n+pub use dataflow::indexes::BorrowIndex;\n+\n+use std::fmt;\n+\n+// `Borrows` maps each dataflow bit to an `Rvalue::Ref`, which can be\n+// uniquely identified in the MIR by the `Location` of the assigment\n+// statement in which it appears on the right hand side.\n+pub struct Borrows<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n+    location_map: FxHashMap<Location, BorrowIndex>,\n+    region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+}\n+\n+// temporarily allow some dead fields: `kind` and `region` will be\n+// needed by borrowck; `lvalue` will probably be a MovePathIndex when\n+// that is extended to include borrowed data paths.\n+#[allow(dead_code)]\n+#[derive(Debug)]\n+pub struct BorrowData<'tcx> {\n+    pub(crate) location: Location,\n+    pub(crate) kind: mir::BorrowKind,\n+    pub(crate) region: Region<'tcx>,\n+    pub(crate) lvalue: mir::Lvalue<'tcx>,\n+}\n+\n+impl<'tcx> fmt::Display for BorrowData<'tcx> {\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        let kind = match self.kind {\n+            mir::BorrowKind::Shared => \"\",\n+            mir::BorrowKind::Unique => \"uniq \",\n+            mir::BorrowKind::Mut => \"mut \",\n+        };\n+        let region = format!(\"{}\", self.region);\n+        let region = if region.len() > 0 { format!(\"{} \", region) } else { region };\n+        write!(w, \"&{}{}{:?}\", region, kind, self.lvalue)\n+    }\n+}\n+\n+impl<'a, 'tcx> Borrows<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+        let mut visitor = GatherBorrows { idx_vec: IndexVec::new(),\n+                                          location_map: FxHashMap(),\n+                                          region_map: FxHashMap(), };\n+        visitor.visit_mir(mir);\n+        return Borrows { tcx: tcx,\n+                         mir: mir,\n+                         borrows: visitor.idx_vec,\n+                         location_map: visitor.location_map,\n+                         region_map: visitor.region_map, };\n+\n+        struct GatherBorrows<'tcx> {\n+            idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n+            location_map: FxHashMap<Location, BorrowIndex>,\n+            region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+        }\n+        impl<'tcx> Visitor<'tcx> for GatherBorrows<'tcx> {\n+            fn visit_rvalue(&mut self,\n+                            rvalue: &mir::Rvalue<'tcx>,\n+                            location: mir::Location) {\n+                if let mir::Rvalue::Ref(region, kind, ref lvalue) = *rvalue {\n+                    let borrow = BorrowData {\n+                        location: location, kind: kind, region: region, lvalue: lvalue.clone(),\n+                    };\n+                    let idx = self.idx_vec.push(borrow);\n+                    self.location_map.insert(location, idx);\n+                    let borrows = self.region_map.entry(region).or_insert(FxHashSet());\n+                    borrows.insert(idx);\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> { &self.borrows }\n+\n+    pub fn location(&self, idx: BorrowIndex) -> &Location {\n+        &self.borrows[idx].location\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation for Borrows<'a, 'tcx> {\n+    type Idx = BorrowIndex;\n+    fn name() -> &'static str { \"borrows\" }\n+    fn bits_per_block(&self) -> usize {\n+        self.borrows.len()\n+    }\n+    fn start_block_effect(&self, _sets: &mut BlockSets<BorrowIndex>)  {\n+        // no borrows of code extents have been taken prior to\n+        // function execution, so this method has no effect on\n+        // `_sets`.\n+    }\n+    fn statement_effect(&self,\n+                        sets: &mut BlockSets<BorrowIndex>,\n+                        location: Location) {\n+        let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n+            panic!(\"could not find block at location {:?}\", location);\n+        });\n+        let stmt = block.statements.get(location.statement_index).unwrap_or_else(|| {\n+            panic!(\"could not find statement at location {:?}\");\n+        });\n+        match stmt.kind {\n+            mir::StatementKind::EndRegion(extent) => {\n+                let borrow_indexes = self.region_map.get(&ReScope(extent)).unwrap_or_else(|| {\n+                    panic!(\"could not find BorrowIndexs for code-extent {:?}\", extent);\n+                });\n+\n+                for idx in borrow_indexes { sets.kill(&idx); }\n+            }\n+\n+            mir::StatementKind::Assign(_, ref rhs) => {\n+                if let mir::Rvalue::Ref(region, _, _) = *rhs {\n+                    let index = self.location_map.get(&location).unwrap_or_else(|| {\n+                        panic!(\"could not find BorrowIndex for location {:?}\", location);\n+                    });\n+                    assert!(self.region_map.get(region).unwrap_or_else(|| {\n+                        panic!(\"could not find BorrowIndexs for region {:?}\", region);\n+                    }).contains(&index));\n+                    sets.gen(&index);\n+                }\n+            }\n+\n+            mir::StatementKind::InlineAsm { .. } |\n+            mir::StatementKind::SetDiscriminant { .. } |\n+            mir::StatementKind::StorageLive(..) |\n+            mir::StatementKind::StorageDead(..) |\n+            mir::StatementKind::Validate(..) |\n+            mir::StatementKind::Nop => {}\n+\n+        }\n+    }\n+    fn terminator_effect(&self,\n+                         _sets: &mut BlockSets<BorrowIndex>,\n+                         _location: Location) {\n+        // no terminators start nor end code extents.\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             _in_out: &mut IdxSet<BorrowIndex>,\n+                             _call_bb: mir::BasicBlock,\n+                             _dest_bb: mir::BasicBlock,\n+                             _dest_lval: &mir::Lvalue) {\n+        // there are no effects on the extents from method calls.\n+    }\n+}\n+\n+impl<'a, 'tcx> BitwiseOperator for Borrows<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // union effects of preds when computing borrows\n+    }\n+}\n+\n+impl<'a, 'tcx> DataflowOperator for Borrows<'a, 'tcx> {\n+    #[inline]\n+    fn bottom_value() -> bool {\n+        false // bottom = no Rvalue::Refs are active by default\n+    }\n+}"}, {"sha": "c7c66e1bb2b070cff15a2c6fc315027d8494183d", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -30,6 +30,9 @@ use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n use super::on_lookup_result_bits;\n \n+#[allow(dead_code)]\n+pub(super) mod borrows;\n+\n /// `MaybeInitializedLvals` tracks all l-values that might be\n /// initialized upon reaching a particular point in the control flow\n /// for a function.\n@@ -287,24 +290,22 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n \n     fn statement_effect(&self,\n                         sets: &mut BlockSets<MovePathIndex>,\n-                        bb: mir::BasicBlock,\n-                        idx: usize)\n+                        location: Location)\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.mir, self.mdpe,\n-            Location { block: bb, statement_index: idx },\n+            location,\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n \n     fn terminator_effect(&self,\n                          sets: &mut BlockSets<MovePathIndex>,\n-                         bb: mir::BasicBlock,\n-                         statements_len: usize)\n+                         location: Location)\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.mir, self.mdpe,\n-            Location { block: bb, statement_index: statements_len },\n+            location,\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n@@ -344,24 +345,22 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n \n     fn statement_effect(&self,\n                         sets: &mut BlockSets<MovePathIndex>,\n-                        bb: mir::BasicBlock,\n-                        idx: usize)\n+                        location: Location)\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.mir, self.mdpe,\n-            Location { block: bb, statement_index: idx },\n+            location,\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n \n     fn terminator_effect(&self,\n                          sets: &mut BlockSets<MovePathIndex>,\n-                         bb: mir::BasicBlock,\n-                         statements_len: usize)\n+                         location: Location)\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.mir, self.mdpe,\n-            Location { block: bb, statement_index: statements_len },\n+            location,\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n@@ -400,24 +399,22 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n \n     fn statement_effect(&self,\n                         sets: &mut BlockSets<MovePathIndex>,\n-                        bb: mir::BasicBlock,\n-                        idx: usize)\n+                        location: Location)\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.mir, self.mdpe,\n-            Location { block: bb, statement_index: idx },\n+            location,\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n \n     fn terminator_effect(&self,\n                          sets: &mut BlockSets<MovePathIndex>,\n-                         bb: mir::BasicBlock,\n-                         statements_len: usize)\n+                         location: Location)\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.mir, self.mdpe,\n-            Location { block: bb, statement_index: statements_len },\n+            location,\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n@@ -448,18 +445,16 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n     }\n     fn statement_effect(&self,\n                         sets: &mut BlockSets<MoveOutIndex>,\n-                        bb: mir::BasicBlock,\n-                        idx: usize) {\n+                        location: Location) {\n         let (tcx, mir, move_data) = (self.tcx, self.mir, self.move_data());\n-        let stmt = &mir[bb].statements[idx];\n+        let stmt = &mir[location.block].statements[location.statement_index];\n         let loc_map = &move_data.loc_map;\n         let path_map = &move_data.path_map;\n         let rev_lookup = &move_data.rev_lookup;\n \n-        let loc = Location { block: bb, statement_index: idx };\n         debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n-               stmt, loc, &loc_map[loc]);\n-        for move_index in &loc_map[loc] {\n+               stmt, location, &loc_map[location]);\n+        for move_index in &loc_map[location] {\n             // Every path deinitialized by a *particular move*\n             // has corresponding bit, \"gen'ed\" (i.e. set)\n             // here, in dataflow vector\n@@ -506,17 +501,15 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n \n     fn terminator_effect(&self,\n                          sets: &mut BlockSets<MoveOutIndex>,\n-                         bb: mir::BasicBlock,\n-                         statements_len: usize)\n+                         location: Location)\n     {\n         let (mir, move_data) = (self.mir, self.move_data());\n-        let term = mir[bb].terminator();\n+        let term = mir[location.block].terminator();\n         let loc_map = &move_data.loc_map;\n-        let loc = Location { block: bb, statement_index: statements_len };\n         debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n-               term, loc, &loc_map[loc]);\n+               term, location, &loc_map[location]);\n         let bits_per_block = self.bits_per_block();\n-        for move_index in &loc_map[loc] {\n+        for move_index in &loc_map[location] {\n             assert!(move_index.index() < bits_per_block);\n             zero_to_one(sets.gen_set.words_mut(), *move_index);\n         }"}, {"sha": "cdf991a0933f3b809fd354276278119c4a31434d", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 237, "deletions": 34, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -8,26 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::ast;\n+use syntax::ast::{self, MetaItem};\n \n use rustc_data_structures::indexed_set::{IdxSet, IdxSetBuf};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::bitslice::{bitwise, BitwiseOperator};\n \n-use rustc::ty::{TyCtxt};\n-use rustc::mir::{self, Mir};\n+use rustc::ty::{self, TyCtxt};\n+use rustc::mir::{self, Mir, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n+use rustc::session::Session;\n \n-use std::fmt::Debug;\n+use std::fmt::{self, Debug};\n use std::io;\n use std::mem;\n use std::path::PathBuf;\n use std::usize;\n \n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n-\n+pub use self::impls::borrows::{Borrows, BorrowData, BorrowIndex};\n pub(crate) use self::drop_flag_effects::*;\n \n+use self::move_paths::MoveData;\n+\n mod drop_flag_effects;\n mod graphviz;\n mod impls;\n@@ -44,29 +47,102 @@ pub(crate) struct DataflowBuilder<'a, 'tcx: 'a, BD> where BD: BitDenotation\n }\n \n pub trait Dataflow<BD: BitDenotation> {\n-    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> &Debug;\n+    /// Sets up and runs the dataflow problem, using `p` to render results if\n+    /// implementation so chooses.\n+    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> &Debug {\n+        let _ = p; // default implementation does not instrument process.\n+        self.build_sets();\n+        self.propagate();\n+    }\n+\n+    /// Sets up the entry, gen, and kill sets for this instance of a dataflow problem.\n+    fn build_sets(&mut self);\n+\n+    /// Finds a fixed-point solution to this instance of a dataflow problem.\n+    fn propagate(&mut self);\n }\n \n-impl<'a, 'tcx: 'a, BD> Dataflow<BD> for DataflowBuilder<'a, 'tcx, BD>\n-    where BD: BitDenotation + DataflowOperator\n+impl<'a, 'tcx: 'a, BD> Dataflow<BD> for DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation\n {\n     fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> &Debug {\n         self.flow_state.build_sets();\n         self.pre_dataflow_instrumentation(|c,i| p(c,i)).unwrap();\n         self.flow_state.propagate();\n         self.post_dataflow_instrumentation(|c,i| p(c,i)).unwrap();\n     }\n+\n+    fn build_sets(&mut self) { self.flow_state.build_sets(); }\n+    fn propagate(&mut self) { self.flow_state.propagate(); }\n+}\n+\n+pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<MetaItem> {\n+    for attr in attrs {\n+        if attr.check_name(\"rustc_mir\") {\n+            let items = attr.meta_item_list();\n+            for item in items.iter().flat_map(|l| l.iter()) {\n+                match item.meta_item() {\n+                    Some(mi) if mi.check_name(name) => return Some(mi.clone()),\n+                    _ => continue\n+                }\n+            }\n+        }\n+    }\n+    return None;\n+}\n+\n+pub struct MoveDataParamEnv<'tcx> {\n+    pub(crate) move_data: MoveData<'tcx>,\n+    pub(crate) param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+pub(crate) fn do_dataflow<'a, 'tcx, BD, P>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                mir: &Mir<'tcx>,\n+                                node_id: ast::NodeId,\n+                                attributes: &[ast::Attribute],\n+                                dead_unwinds: &IdxSet<BasicBlock>,\n+                                bd: BD,\n+                                p: P)\n+                                -> DataflowResults<BD>\n+    where BD: BitDenotation,\n+          P: Fn(&BD, BD::Idx) -> &fmt::Debug\n+{\n+    let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n+        if let Some(item) = has_rustc_mir_with(attrs, name) {\n+            if let Some(s) = item.value_str() {\n+                return Some(s.to_string())\n+            } else {\n+                sess.span_err(\n+                    item.span,\n+                    &format!(\"{} attribute requires a path\", item.name()));\n+                return None;\n+            }\n+        }\n+        return None;\n+    };\n+\n+    let print_preflow_to =\n+        name_found(tcx.sess, attributes, \"borrowck_graphviz_preflow\");\n+    let print_postflow_to =\n+        name_found(tcx.sess, attributes, \"borrowck_graphviz_postflow\");\n+\n+    let mut mbcx = DataflowBuilder {\n+        node_id,\n+        print_preflow_to,\n+        print_postflow_to,\n+        flow_state: DataflowAnalysis::new(tcx, mir, dead_unwinds, bd),\n+    };\n+\n+    mbcx.dataflow(p);\n+    mbcx.flow_state.results()\n }\n \n-struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O>\n-    where O: 'b + BitDenotation\n+struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O> where O: 'b + BitDenotation\n {\n     builder: &'b mut DataflowAnalysis<'a, 'tcx, O>,\n     changed: bool,\n }\n \n-impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n-    where BD: BitDenotation + DataflowOperator\n+impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n {\n     fn propagate(&mut self) {\n         let mut temp = IdxSetBuf::new_empty(self.flow_state.sets.bits_per_block);\n@@ -98,19 +174,19 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n \n             let sets = &mut self.flow_state.sets.for_block(bb.index());\n             for j_stmt in 0..statements.len() {\n-                self.flow_state.operator.statement_effect(sets, bb, j_stmt);\n+                let location = Location { block: bb, statement_index: j_stmt };\n+                self.flow_state.operator.statement_effect(sets, location);\n             }\n \n             if terminator.is_some() {\n-                let stmts_len = statements.len();\n-                self.flow_state.operator.terminator_effect(sets, bb, stmts_len);\n+                let location = Location { block: bb, statement_index: statements.len() };\n+                self.flow_state.operator.terminator_effect(sets, location);\n             }\n         }\n     }\n }\n \n-impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD>\n-    where BD: BitDenotation + DataflowOperator\n+impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD> where BD: BitDenotation\n {\n     fn reset(&mut self, bits: &mut IdxSet<BD::Idx>) {\n         let e = if BD::bottom_value() {!0} else {0};\n@@ -147,8 +223,7 @@ fn dataflow_path(context: &str, prepost: &str, path: &str) -> PathBuf {\n     path\n }\n \n-impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD>\n-    where BD: BitDenotation\n+impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation\n {\n     fn pre_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n         where P: Fn(&BD, BD::Idx) -> &Debug\n@@ -189,21 +264,108 @@ impl<E:Idx> Bits<E> {\n     }\n }\n \n-pub struct DataflowAnalysis<'a, 'tcx: 'a, O>\n-    where O: BitDenotation\n+/// DataflowResultsConsumer abstracts over walking the MIR with some\n+/// already constructed dataflow results.\n+///\n+/// It abstracts over the FlowState and also completely hides the\n+/// underlying flow analysis results, because it needs to handle cases\n+/// where we are combining the results of *multiple* flow analyses\n+/// (e.g. borrows + inits + uninits).\n+pub trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n+    type FlowState;\n+\n+    // Observation Hooks: override (at least one of) these to get analysis feedback.\n+    fn visit_block_entry(&mut self,\n+                         _bb: BasicBlock,\n+                         _flow_state: &Self::FlowState) {}\n+\n+    fn visit_statement_entry(&mut self,\n+                             _loc: Location,\n+                             _stmt: &Statement<'tcx>,\n+                             _flow_state: &Self::FlowState) {}\n+\n+    fn visit_terminator_entry(&mut self,\n+                              _loc: Location,\n+                              _term: &Terminator<'tcx>,\n+                              _flow_state: &Self::FlowState) {}\n+\n+    // Main entry point: this drives the processing of results.\n+\n+    fn analyze_results(&mut self, flow_uninit: &mut Self::FlowState) {\n+        let flow = flow_uninit;\n+        for bb in self.mir().basic_blocks().indices() {\n+            self.reset_to_entry_of(bb, flow);\n+            self.process_basic_block(bb, flow);\n+        }\n+    }\n+\n+    fn process_basic_block(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n+        let BasicBlockData { ref statements, ref terminator, is_cleanup: _ } =\n+            self.mir()[bb];\n+        let mut location = Location { block: bb, statement_index: 0 };\n+        for stmt in statements.iter() {\n+            self.reconstruct_statement_effect(location, flow_state);\n+            self.visit_statement_entry(location, stmt, flow_state);\n+            self.apply_local_effect(location, flow_state);\n+            location.statement_index += 1;\n+        }\n+\n+        if let Some(ref term) = *terminator {\n+            self.reconstruct_terminator_effect(location, flow_state);\n+            self.visit_terminator_entry(location, term, flow_state);\n+\n+            // We don't need to apply the effect of the terminator,\n+            // since we are only visiting dataflow state on control\n+            // flow entry to the various nodes. (But we still need to\n+            // reconstruct the effect, because the visit method might\n+            // inspect it.)\n+        }\n+    }\n+\n+    // Delegated Hooks: Provide access to the MIR and process the flow state.\n+\n+    fn mir(&self) -> &'a Mir<'tcx>;\n+\n+    // reset the state bitvector to represent the entry to block `bb`.\n+    fn reset_to_entry_of(&mut self,\n+                         bb: BasicBlock,\n+                         flow_state: &mut Self::FlowState);\n+\n+    // build gen + kill sets for statement at `loc`.\n+    fn reconstruct_statement_effect(&mut self,\n+                                    loc: Location,\n+                                    flow_state: &mut Self::FlowState);\n+\n+    // build gen + kill sets for terminator for `loc`.\n+    fn reconstruct_terminator_effect(&mut self,\n+                                     loc: Location,\n+                                     flow_state: &mut Self::FlowState);\n+\n+    // apply current gen + kill sets to `flow_state`.\n+    //\n+    // (`bb` and `stmt_idx` parameters can be ignored if desired by\n+    // client. For the terminator, the `stmt_idx` will be the number\n+    // of statements in the block.)\n+    fn apply_local_effect(&mut self,\n+                          loc: Location,\n+                          flow_state: &mut Self::FlowState);\n+}\n+\n+pub struct DataflowAnalysis<'a, 'tcx: 'a, O> where O: BitDenotation\n {\n     flow_state: DataflowState<O>,\n     dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n     mir: &'a Mir<'tcx>,\n }\n \n-impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O>\n-    where O: BitDenotation\n+impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O> where O: BitDenotation\n {\n     pub fn results(self) -> DataflowResults<O> {\n         DataflowResults(self.flow_state)\n     }\n \n+    pub fn flow_state(&self) -> &DataflowState<O> { &self.flow_state }\n+\n     pub fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n }\n \n@@ -213,10 +375,14 @@ impl<O: BitDenotation> DataflowResults<O> {\n     pub fn sets(&self) -> &AllSets<O::Idx> {\n         &self.0.sets\n     }\n+\n+    pub fn operator(&self) -> &O {\n+        &self.0.operator\n+    }\n }\n \n-// FIXME: This type shouldn't be public, but the graphviz::MirWithFlowState trait\n-// references it in a method signature. Look into using `pub(crate)` to address this.\n+/// State of a dataflow analysis; couples a collection of bit sets\n+/// with operator used to initialize and merge bits during analysis.\n pub struct DataflowState<O: BitDenotation>\n {\n     /// All the sets for the analysis. (Factored into its\n@@ -228,6 +394,28 @@ pub struct DataflowState<O: BitDenotation>\n     pub(crate) operator: O,\n }\n \n+impl<O: BitDenotation> DataflowState<O> {\n+    pub fn each_bit<F>(&self, words: &IdxSet<O::Idx>, f: F) where F: FnMut(O::Idx)\n+    {\n+        let bits_per_block = self.operator.bits_per_block();\n+        words.each_bit(bits_per_block, f)\n+    }\n+\n+    pub fn interpret_set<'c, P>(&self,\n+                                o: &'c O,\n+                                words: &IdxSet<O::Idx>,\n+                                render_idx: &P)\n+                                -> Vec<&'c Debug>\n+        where P: Fn(&O, O::Idx) -> &Debug\n+    {\n+        let mut v = Vec::new();\n+        self.each_bit(words, |i| {\n+            v.push(render_idx(o, i));\n+        });\n+        v\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct AllSets<E: Idx> {\n     /// Analysis bitwidth for each block.\n@@ -251,9 +439,28 @@ pub struct AllSets<E: Idx> {\n     on_entry_sets: Bits<E>,\n }\n \n+/// Triple of sets associated with a given block.\n+///\n+/// Generally, one sets up `on_entry`, `gen_set`, and `kill_set` for\n+/// each block individually, and then runs the dataflow analysis which\n+/// iteratively modifies the various `on_entry` sets (but leaves the\n+/// other two sets unchanged, since they represent the effect of the\n+/// block, which should be invariant over the course of the analysis).\n+///\n+/// It is best to ensure that the intersection of `gen_set` and\n+/// `kill_set` is empty; otherwise the results of the dataflow will\n+/// have a hidden dependency on what order the bits are generated and\n+/// killed during the iteration. (This is such a good idea that the\n+/// `fn gen` and `fn kill` methods that set their state enforce this\n+/// for you.)\n pub struct BlockSets<'a, E: Idx> {\n+    /// Dataflow state immediately before control flow enters the given block.\n     pub(crate) on_entry: &'a mut IdxSet<E>,\n+\n+    /// Bits that are set to 1 by the time we exit the given block.\n     pub(crate) gen_set: &'a mut IdxSet<E>,\n+\n+    /// Bits that are set to 0 by the time we exit the given block.\n     pub(crate) kill_set: &'a mut IdxSet<E>,\n }\n \n@@ -302,7 +509,7 @@ pub trait DataflowOperator: BitwiseOperator {\n     fn bottom_value() -> bool;\n }\n \n-pub trait BitDenotation {\n+pub trait BitDenotation: DataflowOperator {\n     /// Specifies what index type is used to access the bitvector.\n     type Idx: Idx;\n \n@@ -341,8 +548,7 @@ pub trait BitDenotation {\n     /// the MIR.\n     fn statement_effect(&self,\n                         sets: &mut BlockSets<Self::Idx>,\n-                        bb: mir::BasicBlock,\n-                        idx_stmt: usize);\n+                        location: Location);\n \n     /// Mutates the block-sets (the flow sets for the given\n     /// basic block) according to the effects of evaluating\n@@ -356,8 +562,7 @@ pub trait BitDenotation {\n     /// terminator took.\n     fn terminator_effect(&self,\n                          sets: &mut BlockSets<Self::Idx>,\n-                         bb: mir::BasicBlock,\n-                         idx_term: usize);\n+                         location: Location);\n \n     /// Mutates the block-sets according to the (flow-dependent)\n     /// effect of a successful return from a Call terminator.\n@@ -385,8 +590,7 @@ pub trait BitDenotation {\n                              dest_lval: &mir::Lvalue);\n }\n \n-impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n-    where D: BitDenotation + DataflowOperator\n+impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n {\n     pub fn new(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n@@ -427,8 +631,7 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n     }\n }\n \n-impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n-    where D: BitDenotation + DataflowOperator\n+impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n {\n     /// Propagates the bits of `in_out` into all the successors of `bb`,\n     /// using bitwise operator denoted by `self.operator`."}, {"sha": "86298c3b83e29ce63a07876f88d0c49f6f610bbf", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -0,0 +1,337 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::{self, TyCtxt};\n+use rustc::mir::*;\n+use rustc::mir::tcx::RvalueInitializationState;\n+use rustc::util::nodemap::FxHashMap;\n+use rustc_data_structures::indexed_vec::{IndexVec};\n+\n+use syntax::codemap::DUMMY_SP;\n+\n+use std::collections::hash_map::Entry;\n+use std::mem;\n+\n+use super::abs_domain::Lift;\n+\n+use super::{LocationMap, MoveData, MovePath, MovePathLookup, MovePathIndex, MoveOut, MoveOutIndex};\n+\n+pub(super) struct MoveDataBuilder<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    data: MoveData<'tcx>,\n+}\n+\n+pub enum MovePathError {\n+    IllegalMove,\n+    UnionMove { path: MovePathIndex },\n+}\n+\n+impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+    fn new(mir: &'a Mir<'tcx>,\n+           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+           param_env: ty::ParamEnv<'tcx>)\n+           -> Self {\n+        let mut move_paths = IndexVec::new();\n+        let mut path_map = IndexVec::new();\n+\n+        MoveDataBuilder {\n+            mir,\n+            tcx,\n+            param_env,\n+            data: MoveData {\n+                moves: IndexVec::new(),\n+                loc_map: LocationMap::new(mir),\n+                rev_lookup: MovePathLookup {\n+                    locals: mir.local_decls.indices().map(Lvalue::Local).map(|v| {\n+                        Self::new_move_path(&mut move_paths, &mut path_map, None, v)\n+                    }).collect(),\n+                    projections: FxHashMap(),\n+                },\n+                move_paths,\n+                path_map,\n+            }\n+        }\n+    }\n+\n+    fn new_move_path(move_paths: &mut IndexVec<MovePathIndex, MovePath<'tcx>>,\n+                     path_map: &mut IndexVec<MovePathIndex, Vec<MoveOutIndex>>,\n+                     parent: Option<MovePathIndex>,\n+                     lvalue: Lvalue<'tcx>)\n+                     -> MovePathIndex\n+    {\n+        let move_path = move_paths.push(MovePath {\n+            next_sibling: None,\n+            first_child: None,\n+            parent,\n+            lvalue,\n+        });\n+\n+        if let Some(parent) = parent {\n+            let next_sibling =\n+                mem::replace(&mut move_paths[parent].first_child, Some(move_path));\n+            move_paths[move_path].next_sibling = next_sibling;\n+        }\n+\n+        let path_map_ent = path_map.push(vec![]);\n+        assert_eq!(path_map_ent, move_path);\n+        move_path\n+    }\n+\n+    /// This creates a MovePath for a given lvalue, returning an `MovePathError`\n+    /// if that lvalue can't be moved from.\n+    ///\n+    /// NOTE: lvalues behind references *do not* get a move path, which is\n+    /// problematic for borrowck.\n+    ///\n+    /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n+    fn move_path_for(&mut self, lval: &Lvalue<'tcx>)\n+                     -> Result<MovePathIndex, MovePathError>\n+    {\n+        debug!(\"lookup({:?})\", lval);\n+        match *lval {\n+            Lvalue::Local(local) => Ok(self.data.rev_lookup.locals[local]),\n+            // error: can't move out of a static\n+            Lvalue::Static(..) => Err(MovePathError::IllegalMove),\n+            Lvalue::Projection(ref proj) => {\n+                self.move_path_for_projection(lval, proj)\n+            }\n+        }\n+    }\n+\n+    fn create_move_path(&mut self, lval: &Lvalue<'tcx>) {\n+        // This is an assignment, not a move, so this not being a valid\n+        // move path is OK.\n+        let _ = self.move_path_for(lval);\n+    }\n+\n+    fn move_path_for_projection(&mut self,\n+                                lval: &Lvalue<'tcx>,\n+                                proj: &LvalueProjection<'tcx>)\n+                                -> Result<MovePathIndex, MovePathError>\n+    {\n+        let base = try!(self.move_path_for(&proj.base));\n+        let lv_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        match lv_ty.sty {\n+            // error: can't move out of borrowed content\n+            ty::TyRef(..) | ty::TyRawPtr(..) => return Err(MovePathError::IllegalMove),\n+            // error: can't move out of struct with destructor\n+            ty::TyAdt(adt, _) if adt.has_dtor(self.tcx) && !adt.is_box() =>\n+                return Err(MovePathError::IllegalMove),\n+            // move out of union - always move the entire union\n+            ty::TyAdt(adt, _) if adt.is_union() =>\n+                return Err(MovePathError::UnionMove { path: base }),\n+            // error: can't move out of a slice\n+            ty::TySlice(..) =>\n+                return Err(MovePathError::IllegalMove),\n+            ty::TyArray(..) => match proj.elem {\n+                // error: can't move out of an array\n+                ProjectionElem::Index(..) => return Err(MovePathError::IllegalMove),\n+                _ => {\n+                    // FIXME: still badly broken\n+                }\n+            },\n+            _ => {}\n+        };\n+        match self.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n+            Entry::Occupied(ent) => Ok(*ent.get()),\n+            Entry::Vacant(ent) => {\n+                let path = Self::new_move_path(\n+                    &mut self.data.move_paths,\n+                    &mut self.data.path_map,\n+                    Some(base),\n+                    lval.clone()\n+                );\n+                ent.insert(path);\n+                Ok(path)\n+            }\n+        }\n+    }\n+\n+    fn finalize(self) -> MoveData<'tcx> {\n+        debug!(\"{}\", {\n+            debug!(\"moves for {:?}:\", self.mir.span);\n+            for (j, mo) in self.data.moves.iter_enumerated() {\n+                debug!(\"    {:?} = {:?}\", j, mo);\n+            }\n+            debug!(\"move paths for {:?}:\", self.mir.span);\n+            for (j, path) in self.data.move_paths.iter_enumerated() {\n+                debug!(\"    {:?} = {:?}\", j, path);\n+            }\n+            \"done dumping moves\"\n+        });\n+        self.data\n+    }\n+}\n+\n+pub(super) fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n+                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     param_env: ty::ParamEnv<'tcx>)\n+                                     -> MoveData<'tcx> {\n+    let mut builder = MoveDataBuilder::new(mir, tcx, param_env);\n+\n+    for (bb, block) in mir.basic_blocks().iter_enumerated() {\n+        for (i, stmt) in block.statements.iter().enumerate() {\n+            let source = Location { block: bb, statement_index: i };\n+            builder.gather_statement(source, stmt);\n+        }\n+\n+        let terminator_loc = Location {\n+            block: bb,\n+            statement_index: block.statements.len()\n+        };\n+        builder.gather_terminator(terminator_loc, block.terminator());\n+    }\n+\n+    builder.finalize()\n+}\n+\n+impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+    fn gather_statement(&mut self, loc: Location, stmt: &Statement<'tcx>) {\n+        debug!(\"gather_statement({:?}, {:?})\", loc, stmt);\n+        match stmt.kind {\n+            StatementKind::Assign(ref lval, ref rval) => {\n+                self.create_move_path(lval);\n+                if let RvalueInitializationState::Shallow = rval.initialization_state() {\n+                    // Box starts out uninitialized - need to create a separate\n+                    // move-path for the interior so it will be separate from\n+                    // the exterior.\n+                    self.create_move_path(&lval.clone().deref());\n+                }\n+                self.gather_rvalue(loc, rval);\n+            }\n+            StatementKind::StorageLive(_) |\n+            StatementKind::StorageDead(_) => {}\n+            StatementKind::SetDiscriminant{ .. } => {\n+                span_bug!(stmt.source_info.span,\n+                          \"SetDiscriminant should not exist during borrowck\");\n+            }\n+            StatementKind::InlineAsm { .. } |\n+            StatementKind::EndRegion(_) |\n+            StatementKind::Validate(..) |\n+            StatementKind::Nop => {}\n+        }\n+    }\n+\n+    fn gather_rvalue(&mut self, loc: Location, rvalue: &Rvalue<'tcx>) {\n+        match *rvalue {\n+            Rvalue::Use(ref operand) |\n+            Rvalue::Repeat(ref operand, _) |\n+            Rvalue::Cast(_, ref operand, _) |\n+            Rvalue::UnaryOp(_, ref operand) => {\n+                self.gather_operand(loc, operand)\n+            }\n+            Rvalue::BinaryOp(ref _binop, ref lhs, ref rhs) |\n+            Rvalue::CheckedBinaryOp(ref _binop, ref lhs, ref rhs) => {\n+                self.gather_operand(loc, lhs);\n+                self.gather_operand(loc, rhs);\n+            }\n+            Rvalue::Aggregate(ref _kind, ref operands) => {\n+                for operand in operands {\n+                    self.gather_operand(loc, operand);\n+                }\n+            }\n+            Rvalue::Ref(..) |\n+            Rvalue::Discriminant(..) |\n+            Rvalue::Len(..) |\n+            Rvalue::NullaryOp(NullOp::SizeOf, _) |\n+            Rvalue::NullaryOp(NullOp::Box, _) => {\n+                // This returns an rvalue with uninitialized contents. We can't\n+                // move out of it here because it is an rvalue - assignments always\n+                // completely initialize their lvalue.\n+                //\n+                // However, this does not matter - MIR building is careful to\n+                // only emit a shallow free for the partially-initialized\n+                // temporary.\n+                //\n+                // In any case, if we want to fix this, we have to register a\n+                // special move and change the `statement_effect` functions.\n+            }\n+        }\n+    }\n+\n+    fn gather_terminator(&mut self, loc: Location, term: &Terminator<'tcx>) {\n+        debug!(\"gather_terminator({:?}, {:?})\", loc, term);\n+        match term.kind {\n+            TerminatorKind::Goto { target: _ } |\n+            TerminatorKind::Resume |\n+            TerminatorKind::GeneratorDrop |\n+            TerminatorKind::Unreachable => { }\n+\n+            TerminatorKind::Return => {\n+                self.gather_move(loc, &Lvalue::Local(RETURN_POINTER));\n+            }\n+\n+            TerminatorKind::Assert { .. } |\n+            TerminatorKind::SwitchInt { .. } => {\n+                // branching terminators - these don't move anything\n+            }\n+\n+            TerminatorKind::Yield { ref value, .. } => {\n+                self.gather_operand(loc, value);\n+            }\n+\n+            TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n+                self.gather_move(loc, location);\n+            }\n+            TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n+                self.create_move_path(location);\n+                self.gather_operand(loc, value);\n+            }\n+            TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n+                self.gather_operand(loc, func);\n+                for arg in args {\n+                    self.gather_operand(loc, arg);\n+                }\n+                if let Some((ref destination, _bb)) = *destination {\n+                    self.create_move_path(destination);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn gather_operand(&mut self, loc: Location, operand: &Operand<'tcx>) {\n+        match *operand {\n+            Operand::Constant(..) => {} // not-a-move\n+            Operand::Consume(ref lval) => { // a move\n+                self.gather_move(loc, lval);\n+            }\n+        }\n+    }\n+\n+    fn gather_move(&mut self, loc: Location, lval: &Lvalue<'tcx>) {\n+        debug!(\"gather_move({:?}, {:?})\", loc, lval);\n+\n+        let lv_ty = lval.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        if !lv_ty.moves_by_default(self.tcx, self.param_env, DUMMY_SP) {\n+            debug!(\"gather_move({:?}, {:?}) - {:?} is Copy. skipping\", loc, lval, lv_ty);\n+            return\n+        }\n+\n+        let path = match self.move_path_for(lval) {\n+            Ok(path) | Err(MovePathError::UnionMove { path }) => path,\n+            Err(MovePathError::IllegalMove) => {\n+                // Moving out of a bad path. Eventually, this should be a MIR\n+                // borrowck error instead of a bug.\n+                span_bug!(self.mir.span,\n+                          \"Broken MIR: moving out of lvalue {:?}: {:?} at {:?}\",\n+                          lval, lv_ty, loc);\n+            }\n+        };\n+        let move_out = self.data.moves.push(MoveOut { path: path, source: loc });\n+\n+        debug!(\"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n+               loc, lval, move_out, path);\n+\n+        self.data.path_map[path].push(move_out);\n+        self.data.loc_map[loc].push(move_out);\n+    }\n+}"}, {"sha": "d2d80649846823c8390061c51ef0dd574f1c0d27", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 11, "deletions": 318, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -11,15 +11,10 @@\n \n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n-use rustc::mir::tcx::RvalueInitializationState;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n \n-use syntax::codemap::DUMMY_SP;\n-\n-use std::collections::hash_map::Entry;\n use std::fmt;\n-use std::mem;\n use std::ops::{Index, IndexMut};\n \n use self::abs_domain::{AbstractElem, Lift};\n@@ -63,6 +58,9 @@ pub(crate) mod indexes {\n \n     /// Index into MoveData.moves.\n     new_index!(MoveOutIndex, \"mo\");\n+\n+    /// Index into Borrows.locations\n+    new_index!(BorrowIndex, \"bw\");\n }\n \n pub use self::indexes::MovePathIndex;\n@@ -110,6 +108,12 @@ impl<'tcx> fmt::Debug for MovePath<'tcx> {\n     }\n }\n \n+impl<'tcx> fmt::Display for MovePath<'tcx> {\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        write!(w, \"{:?}\", self.lvalue)\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct MoveData<'tcx> {\n     pub move_paths: IndexVec<MovePathIndex, MovePath<'tcx>>,\n@@ -191,154 +195,7 @@ pub struct MovePathLookup<'tcx> {\n     projections: FxHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n }\n \n-pub(super) struct MoveDataBuilder<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    data: MoveData<'tcx>,\n-}\n-\n-pub enum MovePathError {\n-    IllegalMove,\n-    UnionMove { path: MovePathIndex },\n-}\n-\n-impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n-    fn new(mir: &'a Mir<'tcx>,\n-           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           param_env: ty::ParamEnv<'tcx>)\n-           -> Self {\n-        let mut move_paths = IndexVec::new();\n-        let mut path_map = IndexVec::new();\n-\n-        MoveDataBuilder {\n-            mir,\n-            tcx,\n-            param_env,\n-            data: MoveData {\n-                moves: IndexVec::new(),\n-                loc_map: LocationMap::new(mir),\n-                rev_lookup: MovePathLookup {\n-                    locals: mir.local_decls.indices().map(Lvalue::Local).map(|v| {\n-                        Self::new_move_path(&mut move_paths, &mut path_map, None, v)\n-                    }).collect(),\n-                    projections: FxHashMap(),\n-                },\n-                move_paths,\n-                path_map,\n-            }\n-        }\n-    }\n-\n-    fn new_move_path(move_paths: &mut IndexVec<MovePathIndex, MovePath<'tcx>>,\n-                     path_map: &mut IndexVec<MovePathIndex, Vec<MoveOutIndex>>,\n-                     parent: Option<MovePathIndex>,\n-                     lvalue: Lvalue<'tcx>)\n-                     -> MovePathIndex\n-    {\n-        let move_path = move_paths.push(MovePath {\n-            next_sibling: None,\n-            first_child: None,\n-            parent,\n-            lvalue,\n-        });\n-\n-        if let Some(parent) = parent {\n-            let next_sibling =\n-                mem::replace(&mut move_paths[parent].first_child, Some(move_path));\n-            move_paths[move_path].next_sibling = next_sibling;\n-        }\n-\n-        let path_map_ent = path_map.push(vec![]);\n-        assert_eq!(path_map_ent, move_path);\n-        move_path\n-    }\n-\n-    /// This creates a MovePath for a given lvalue, returning an `MovePathError`\n-    /// if that lvalue can't be moved from.\n-    ///\n-    /// NOTE: lvalues behind references *do not* get a move path, which is\n-    /// problematic for borrowck.\n-    ///\n-    /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n-    fn move_path_for(&mut self, lval: &Lvalue<'tcx>)\n-                     -> Result<MovePathIndex, MovePathError>\n-    {\n-        debug!(\"lookup({:?})\", lval);\n-        match *lval {\n-            Lvalue::Local(local) => Ok(self.data.rev_lookup.locals[local]),\n-            // error: can't move out of a static\n-            Lvalue::Static(..) => Err(MovePathError::IllegalMove),\n-            Lvalue::Projection(ref proj) => {\n-                self.move_path_for_projection(lval, proj)\n-            }\n-        }\n-    }\n-\n-    fn create_move_path(&mut self, lval: &Lvalue<'tcx>) {\n-        // This is an assignment, not a move, so this not being a valid\n-        // move path is OK.\n-        let _ = self.move_path_for(lval);\n-    }\n-\n-    fn move_path_for_projection(&mut self,\n-                                lval: &Lvalue<'tcx>,\n-                                proj: &LvalueProjection<'tcx>)\n-                                -> Result<MovePathIndex, MovePathError>\n-    {\n-        let base = try!(self.move_path_for(&proj.base));\n-        let lv_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-        match lv_ty.sty {\n-            // error: can't move out of borrowed content\n-            ty::TyRef(..) | ty::TyRawPtr(..) => return Err(MovePathError::IllegalMove),\n-            // error: can't move out of struct with destructor\n-            ty::TyAdt(adt, _) if adt.has_dtor(self.tcx) && !adt.is_box() =>\n-                return Err(MovePathError::IllegalMove),\n-            // move out of union - always move the entire union\n-            ty::TyAdt(adt, _) if adt.is_union() =>\n-                return Err(MovePathError::UnionMove { path: base }),\n-            // error: can't move out of a slice\n-            ty::TySlice(..) =>\n-                return Err(MovePathError::IllegalMove),\n-            ty::TyArray(..) => match proj.elem {\n-                // error: can't move out of an array\n-                ProjectionElem::Index(..) => return Err(MovePathError::IllegalMove),\n-                _ => {\n-                    // FIXME: still badly broken\n-                }\n-            },\n-            _ => {}\n-        };\n-        match self.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n-            Entry::Occupied(ent) => Ok(*ent.get()),\n-            Entry::Vacant(ent) => {\n-                let path = Self::new_move_path(\n-                    &mut self.data.move_paths,\n-                    &mut self.data.path_map,\n-                    Some(base),\n-                    lval.clone()\n-                );\n-                ent.insert(path);\n-                Ok(path)\n-            }\n-        }\n-    }\n-\n-    fn finalize(self) -> MoveData<'tcx> {\n-        debug!(\"{}\", {\n-            debug!(\"moves for {:?}:\", self.mir.span);\n-            for (j, mo) in self.data.moves.iter_enumerated() {\n-                debug!(\"    {:?} = {:?}\", j, mo);\n-            }\n-            debug!(\"move paths for {:?}:\", self.mir.span);\n-            for (j, path) in self.data.move_paths.iter_enumerated() {\n-                debug!(\"    {:?} = {:?}\", j, path);\n-            }\n-            \"done dumping moves\"\n-        });\n-        self.data\n-    }\n-}\n+mod builder;\n \n #[derive(Copy, Clone, Debug)]\n pub enum LookupResult {\n@@ -375,170 +232,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         param_env: ty::ParamEnv<'tcx>)\n                         -> Self {\n-        gather_moves(mir, tcx, param_env)\n-    }\n-}\n-\n-fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          param_env: ty::ParamEnv<'tcx>)\n-                          -> MoveData<'tcx> {\n-    let mut builder = MoveDataBuilder::new(mir, tcx, param_env);\n-\n-    for (bb, block) in mir.basic_blocks().iter_enumerated() {\n-        for (i, stmt) in block.statements.iter().enumerate() {\n-            let source = Location { block: bb, statement_index: i };\n-            builder.gather_statement(source, stmt);\n-        }\n-\n-        let terminator_loc = Location {\n-            block: bb,\n-            statement_index: block.statements.len()\n-        };\n-        builder.gather_terminator(terminator_loc, block.terminator());\n-    }\n-\n-    builder.finalize()\n-}\n-\n-impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n-    fn gather_statement(&mut self, loc: Location, stmt: &Statement<'tcx>) {\n-        debug!(\"gather_statement({:?}, {:?})\", loc, stmt);\n-        match stmt.kind {\n-            StatementKind::Assign(ref lval, ref rval) => {\n-                self.create_move_path(lval);\n-                if let RvalueInitializationState::Shallow = rval.initialization_state() {\n-                    // Box starts out uninitialized - need to create a separate\n-                    // move-path for the interior so it will be separate from\n-                    // the exterior.\n-                    self.create_move_path(&lval.clone().deref());\n-                }\n-                self.gather_rvalue(loc, rval);\n-            }\n-            StatementKind::StorageLive(_) |\n-            StatementKind::StorageDead(_) => {}\n-            StatementKind::SetDiscriminant{ .. } => {\n-                span_bug!(stmt.source_info.span,\n-                          \"SetDiscriminant should not exist during borrowck\");\n-            }\n-            StatementKind::InlineAsm { .. } |\n-            StatementKind::EndRegion(_) |\n-            StatementKind::Validate(..) |\n-            StatementKind::Nop => {}\n-        }\n-    }\n-\n-    fn gather_rvalue(&mut self, loc: Location, rvalue: &Rvalue<'tcx>) {\n-        match *rvalue {\n-            Rvalue::Use(ref operand) |\n-            Rvalue::Repeat(ref operand, _) |\n-            Rvalue::Cast(_, ref operand, _) |\n-            Rvalue::UnaryOp(_, ref operand) => {\n-                self.gather_operand(loc, operand)\n-            }\n-            Rvalue::BinaryOp(ref _binop, ref lhs, ref rhs) |\n-            Rvalue::CheckedBinaryOp(ref _binop, ref lhs, ref rhs) => {\n-                self.gather_operand(loc, lhs);\n-                self.gather_operand(loc, rhs);\n-            }\n-            Rvalue::Aggregate(ref _kind, ref operands) => {\n-                for operand in operands {\n-                    self.gather_operand(loc, operand);\n-                }\n-            }\n-            Rvalue::Ref(..) |\n-            Rvalue::Discriminant(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::NullaryOp(NullOp::SizeOf, _) |\n-            Rvalue::NullaryOp(NullOp::Box, _) => {\n-                // This returns an rvalue with uninitialized contents. We can't\n-                // move out of it here because it is an rvalue - assignments always\n-                // completely initialize their lvalue.\n-                //\n-                // However, this does not matter - MIR building is careful to\n-                // only emit a shallow free for the partially-initialized\n-                // temporary.\n-                //\n-                // In any case, if we want to fix this, we have to register a\n-                // special move and change the `statement_effect` functions.\n-            }\n-        }\n-    }\n-\n-    fn gather_terminator(&mut self, loc: Location, term: &Terminator<'tcx>) {\n-        debug!(\"gather_terminator({:?}, {:?})\", loc, term);\n-        match term.kind {\n-            TerminatorKind::Goto { target: _ } |\n-            TerminatorKind::Resume |\n-            TerminatorKind::GeneratorDrop |\n-            TerminatorKind::Unreachable => { }\n-\n-            TerminatorKind::Return => {\n-                self.gather_move(loc, &Lvalue::Local(RETURN_POINTER));\n-            }\n-\n-            TerminatorKind::Assert { .. } |\n-            TerminatorKind::SwitchInt { .. } => {\n-                // branching terminators - these don't move anything\n-            }\n-\n-            TerminatorKind::Yield { ref value,  .. } => {\n-                self.gather_operand(loc, value);\n-            }\n-\n-            TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n-                self.gather_move(loc, location);\n-            }\n-            TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n-                self.create_move_path(location);\n-                self.gather_operand(loc, value);\n-            }\n-            TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n-                self.gather_operand(loc, func);\n-                for arg in args {\n-                    self.gather_operand(loc, arg);\n-                }\n-                if let Some((ref destination, _bb)) = *destination {\n-                    self.create_move_path(destination);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn gather_operand(&mut self, loc: Location, operand: &Operand<'tcx>) {\n-        match *operand {\n-            Operand::Constant(..) => {} // not-a-move\n-            Operand::Consume(ref lval) => { // a move\n-                self.gather_move(loc, lval);\n-            }\n-        }\n-    }\n-\n-    fn gather_move(&mut self, loc: Location, lval: &Lvalue<'tcx>) {\n-        debug!(\"gather_move({:?}, {:?})\", loc, lval);\n-\n-        let lv_ty = lval.ty(self.mir, self.tcx).to_ty(self.tcx);\n-        if !lv_ty.moves_by_default(self.tcx, self.param_env, DUMMY_SP) {\n-            debug!(\"gather_move({:?}, {:?}) - {:?} is Copy. skipping\", loc, lval, lv_ty);\n-            return\n-        }\n-\n-        let path = match self.move_path_for(lval) {\n-            Ok(path) | Err(MovePathError::UnionMove { path }) => path,\n-            Err(MovePathError::IllegalMove) => {\n-                // Moving out of a bad path. Eventually, this should be a MIR\n-                // borrowck error instead of a bug.\n-                span_bug!(self.mir.span,\n-                          \"Broken MIR: moving out of lvalue {:?}: {:?} at {:?}\",\n-                          lval, lv_ty, loc);\n-            }\n-        };\n-        let move_out = self.data.moves.push(MoveOut { path: path, source: loc });\n-\n-        debug!(\"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n-               loc, lval, move_out, path);\n-\n-        self.data.path_map[path].push(move_out);\n-        self.data.loc_map[loc].push(move_out);\n+        builder::gather_moves(mir, tcx, param_env)\n     }\n }"}, {"sha": "83a8ce34c692884b7c3c10f4e1906693f405a5a6", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 551, "deletions": 0, "changes": 551, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -195,6 +195,50 @@ instead of using a `const fn`, or refactoring the code to a functional style to\n avoid mutation if possible.\n \"##,\n \n+E0381: r##\"\n+It is not allowed to use or capture an uninitialized variable. For example:\n+\n+```compile_fail,E0381\n+fn main() {\n+    let x: i32;\n+    let y = x; // error, use of possibly uninitialized variable\n+}\n+```\n+\n+To fix this, ensure that any declared variables are initialized before being\n+used. Example:\n+\n+```\n+fn main() {\n+    let x: i32 = 0;\n+    let y = x; // ok!\n+}\n+```\n+\"##,\n+\n+E0384: r##\"\n+This error occurs when an attempt is made to reassign an immutable variable.\n+For example:\n+\n+```compile_fail,E0384\n+fn main() {\n+    let x = 3;\n+    x = 5; // error, reassignment of immutable variable\n+}\n+```\n+\n+By default, variables in Rust are immutable. To fix this error, add the keyword\n+`mut` after the keyword `let` when declaring the variable. For example:\n+\n+```\n+fn main() {\n+    let mut x = 3;\n+    x = 5;\n+}\n+```\n+\"##,\n+\n+\n E0394: r##\"\n A static was referred to by value by another static.\n \n@@ -438,9 +482,516 @@ static A : &'static u32 = &S.a; // ok!\n ```\n \"##,\n \n+E0499: r##\"\n+A variable was borrowed as mutable more than once. Erroneous code example:\n+\n+```compile_fail,E0499\n+let mut i = 0;\n+let mut x = &mut i;\n+let mut a = &mut i;\n+// error: cannot borrow `i` as mutable more than once at a time\n+```\n+\n+Please note that in rust, you can either have many immutable references, or one\n+mutable reference. Take a look at\n+https://doc.rust-lang.org/stable/book/references-and-borrowing.html for more\n+information. Example:\n+\n+\n+```\n+let mut i = 0;\n+let mut x = &mut i; // ok!\n+\n+// or:\n+let mut i = 0;\n+let a = &i; // ok!\n+let b = &i; // still ok!\n+let c = &i; // still ok!\n+```\n+\"##,\n+\n+E0500: r##\"\n+A borrowed variable was used in another closure. Example of erroneous code:\n+\n+```compile_fail\n+fn you_know_nothing(jon_snow: &mut i32) {\n+    let nights_watch = || {\n+        *jon_snow = 2;\n+    };\n+    let starks = || {\n+        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n+                       //        but it is already borrowed\n+    };\n+}\n+```\n+\n+In here, `jon_snow` is already borrowed by the `nights_watch` closure, so it\n+cannot be borrowed by the `starks` closure at the same time. To fix this issue,\n+you can put the closure in its own scope:\n+\n+```\n+fn you_know_nothing(jon_snow: &mut i32) {\n+    {\n+        let nights_watch = || {\n+            *jon_snow = 2;\n+        };\n+    } // At this point, `jon_snow` is free.\n+    let starks = || {\n+        *jon_snow = 3;\n+    };\n+}\n+```\n+\n+Or, if the type implements the `Clone` trait, you can clone it between\n+closures:\n+\n+```\n+fn you_know_nothing(jon_snow: &mut i32) {\n+    let mut jon_copy = jon_snow.clone();\n+    let nights_watch = || {\n+        jon_copy = 2;\n+    };\n+    let starks = || {\n+        *jon_snow = 3;\n+    };\n+}\n+```\n+\"##,\n+\n+E0501: r##\"\n+This error indicates that a mutable variable is being used while it is still\n+captured by a closure. Because the closure has borrowed the variable, it is not\n+available for use until the closure goes out of scope.\n+\n+Note that a capture will either move or borrow a variable, but in this\n+situation, the closure is borrowing the variable. Take a look at\n+http://rustbyexample.com/fn/closures/capture.html for more information about\n+capturing.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0501\n+fn inside_closure(x: &mut i32) {\n+    // Actions which require unique access\n+}\n+\n+fn outside_closure(x: &mut i32) {\n+    // Actions which require unique access\n+}\n+\n+fn foo(a: &mut i32) {\n+    let bar = || {\n+        inside_closure(a)\n+    };\n+    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n+                        //        closure requires unique access.\n+}\n+```\n+\n+To fix this error, you can place the closure in its own scope:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    {\n+        let bar = || {\n+            inside_closure(a)\n+        };\n+    } // borrow on `a` ends.\n+    outside_closure(a); // ok!\n+}\n+```\n+\n+Or you can pass the variable as a parameter to the closure:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    let bar = |s: &mut i32| {\n+        inside_closure(s)\n+    };\n+    outside_closure(a);\n+    bar(a);\n+}\n+```\n+\n+It may be possible to define the closure later:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    outside_closure(a);\n+    let bar = || {\n+        inside_closure(a)\n+    };\n+}\n+```\n+\"##,\n+\n+E0502: r##\"\n+This error indicates that you are trying to borrow a variable as mutable when it\n+has already been borrowed as immutable.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0502\n+fn bar(x: &mut i32) {}\n+fn foo(a: &mut i32) {\n+    let ref y = a; // a is borrowed as immutable.\n+    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n+            //        as immutable\n+}\n+```\n+\n+To fix this error, ensure that you don't have any other references to the\n+variable before trying to access it mutably:\n+\n+```\n+fn bar(x: &mut i32) {}\n+fn foo(a: &mut i32) {\n+    bar(a);\n+    let ref y = a; // ok!\n+}\n+```\n+\n+For more information on the rust ownership system, take a look at\n+https://doc.rust-lang.org/stable/book/references-and-borrowing.html.\n+\"##,\n+\n+E0503: r##\"\n+A value was used after it was mutably borrowed.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0503\n+fn main() {\n+    let mut value = 3;\n+    // Create a mutable borrow of `value`. This borrow\n+    // lives until the end of this function.\n+    let _borrow = &mut value;\n+    let _sum = value + 1; // error: cannot use `value` because\n+                          //        it was mutably borrowed\n+}\n+```\n+\n+In this example, `value` is mutably borrowed by `borrow` and cannot be\n+used to calculate `sum`. This is not possible because this would violate\n+Rust's mutability rules.\n+\n+You can fix this error by limiting the scope of the borrow:\n+\n+```\n+fn main() {\n+    let mut value = 3;\n+    // By creating a new block, you can limit the scope\n+    // of the reference.\n+    {\n+        let _borrow = &mut value; // Use `_borrow` inside this block.\n+    }\n+    // The block has ended and with it the borrow.\n+    // You can now use `value` again.\n+    let _sum = value + 1;\n+}\n+```\n+\n+Or by cloning `value` before borrowing it:\n+\n+```\n+fn main() {\n+    let mut value = 3;\n+    // We clone `value`, creating a copy.\n+    let value_cloned = value.clone();\n+    // The mutable borrow is a reference to `value` and\n+    // not to `value_cloned`...\n+    let _borrow = &mut value;\n+    // ... which means we can still use `value_cloned`,\n+    let _sum = value_cloned + 1;\n+    // even though the borrow only ends here.\n+}\n+```\n+\n+You can find more information about borrowing in the rust-book:\n+http://doc.rust-lang.org/stable/book/references-and-borrowing.html\n+\"##,\n+\n+E0504: r##\"\n+This error occurs when an attempt is made to move a borrowed variable into a\n+closure.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0504\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+\n+    let x = move || {\n+        println!(\"child function: {}\", fancy_num.num);\n+        // error: cannot move `fancy_num` into closure because it is borrowed\n+    };\n+\n+    x();\n+    println!(\"main function: {}\", fancy_ref.num);\n+}\n+```\n+\n+Here, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\n+the closure `x`. There is no way to move a value into a closure while it is\n+borrowed, as that would invalidate the borrow.\n+\n+If the closure can't outlive the value being moved, try using a reference\n+rather than moving:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+\n+    let x = move || {\n+        // fancy_ref is usable here because it doesn't move `fancy_num`\n+        println!(\"child function: {}\", fancy_ref.num);\n+    };\n+\n+    x();\n+\n+    println!(\"main function: {}\", fancy_num.num);\n+}\n+```\n+\n+If the value has to be borrowed and then moved, try limiting the lifetime of\n+the borrow using a scoped block:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+\n+    {\n+        let fancy_ref = &fancy_num;\n+        println!(\"main function: {}\", fancy_ref.num);\n+        // `fancy_ref` goes out of scope here\n+    }\n+\n+    let x = move || {\n+        // `fancy_num` can be moved now (no more references exist)\n+        println!(\"child function: {}\", fancy_num.num);\n+    };\n+\n+    x();\n+}\n+```\n+\n+If the lifetime of a reference isn't enough, such as in the case of threading,\n+consider using an `Arc` to create a reference-counted value:\n+\n+```\n+use std::sync::Arc;\n+use std::thread;\n+\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n+    let fancy_ref2 = fancy_ref1.clone();\n+\n+    let x = thread::spawn(move || {\n+        // `fancy_ref1` can be moved and has a `'static` lifetime\n+        println!(\"child thread: {}\", fancy_ref1.num);\n+    });\n+\n+    x.join().expect(\"child thread should finish\");\n+    println!(\"main thread: {}\", fancy_ref2.num);\n+}\n+```\n+\"##,\n+\n+E0505: r##\"\n+A value was moved out while it was still borrowed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0505\n+struct Value {}\n+\n+fn eat(val: Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+    {\n+        let _ref_to_val: &Value = &x;\n+        eat(x);\n+    }\n+}\n+```\n+\n+Here, the function `eat` takes the ownership of `x`. However,\n+`x` cannot be moved because it was borrowed to `_ref_to_val`.\n+To fix that you can do few different things:\n+\n+* Try to avoid moving the variable.\n+* Release borrow before move.\n+* Implement the `Copy` trait on the type.\n+\n+Examples:\n+\n+```\n+struct Value {}\n+\n+fn eat(val: &Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+    {\n+        let _ref_to_val: &Value = &x;\n+        eat(&x); // pass by reference, if it's possible\n+    }\n+}\n+```\n+\n+Or:\n+\n+```\n+struct Value {}\n+\n+fn eat(val: Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+    {\n+        let _ref_to_val: &Value = &x;\n+    }\n+    eat(x); // release borrow and then move it.\n+}\n+```\n+\n+Or:\n+\n+```\n+#[derive(Clone, Copy)] // implement Copy trait\n+struct Value {}\n+\n+fn eat(val: Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+    {\n+        let _ref_to_val: &Value = &x;\n+        eat(x); // it will be copied here.\n+    }\n+}\n+```\n+\n+You can find more information about borrowing in the rust-book:\n+http://doc.rust-lang.org/stable/book/references-and-borrowing.html\n+\"##,\n+\n+E0506: r##\"\n+This error occurs when an attempt is made to assign to a borrowed value.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0506\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+    fancy_num = FancyNum { num: 6 };\n+    // error: cannot assign to `fancy_num` because it is borrowed\n+\n+    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n+}\n+```\n+\n+Because `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\n+be assigned to a new value as it would invalidate the reference.\n+\n+Alternatively, we can move out of `fancy_num` into a second `fancy_num`:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+    let moved_num = fancy_num;\n+    fancy_num = FancyNum { num: 6 };\n+\n+    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n+}\n+```\n+\n+If the value has to be borrowed, try limiting the lifetime of the borrow using\n+a scoped block:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+\n+    {\n+        let fancy_ref = &fancy_num;\n+        println!(\"Ref: {}\", fancy_ref.num);\n+    }\n+\n+    // Works because `fancy_ref` is no longer in scope\n+    fancy_num = FancyNum { num: 6 };\n+    println!(\"Num: {}\", fancy_num.num);\n+}\n+```\n+\n+Or by moving the reference into a function:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+\n+    print_fancy_ref(&fancy_num);\n+\n+    // Works because function borrow has ended\n+    fancy_num = FancyNum { num: 6 };\n+    println!(\"Num: {}\", fancy_num.num);\n+}\n+\n+fn print_fancy_ref(fancy_ref: &FancyNum){\n+    println!(\"Ref: {}\", fancy_ref.num);\n+}\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {\n+    E0524, // two closures require unique access to `..` at the same time\n     E0526, // shuffle indices are not constant\n     E0625, // thread-local statics cannot be accessed at compile-time\n }"}, {"sha": "143ad784171a098b5e3fcf738d53b0f6f441bd7a", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -32,6 +32,7 @@ extern crate graphviz as dot;\n #[macro_use]\n extern crate rustc;\n extern crate rustc_data_structures;\n+extern crate rustc_errors;\n #[macro_use]\n #[no_link]\n extern crate rustc_bitflags;"}, {"sha": "b56d5d31f55fa4d3a8a24853d51300563dc8c8d4", "filename": "src/librustc_mir/transform/borrow_check.rs", "status": "added", "additions": 1277, "deletions": 0, "changes": 1277, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -0,0 +1,1277 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass borrow-checks the MIR to (further) ensure it is not broken.\n+\n+use rustc::infer::{InferCtxt};\n+use rustc::ty::{self, TyCtxt, ParamEnv};\n+use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue};\n+use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n+use rustc::mir::{Statement, StatementKind, Terminator, TerminatorKind};\n+use rustc::mir::transform::{MirPass, MirSource};\n+\n+use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n+use rustc_data_structures::indexed_vec::{Idx};\n+\n+use syntax::ast::{self};\n+use syntax_pos::{DUMMY_SP, Span};\n+\n+use dataflow::{do_dataflow};\n+use dataflow::{MoveDataParamEnv};\n+use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n+use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{MovingOutStatements};\n+use dataflow::{Borrows, BorrowData, BorrowIndex};\n+use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n+use util::borrowck_errors::{BorrowckErrors, Origin};\n+\n+use self::MutateMode::{JustWrite, WriteAndRead};\n+use self::ConsumeKind::{Consume};\n+\n+pub struct BorrowckMir;\n+\n+impl MirPass for BorrowckMir {\n+    fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n+\n+        // let err_count = tcx.sess.err_count();\n+        // if err_count > 0 {\n+        //     // compiling a broken program can obviously result in a\n+        //     // broken MIR, so try not to report duplicate errors.\n+        //     debug!(\"skipping BorrowckMir: {} due to {} previous errors\",\n+        //            tcx.node_path_str(src.item_id()), err_count);\n+        //     return;\n+        // }\n+\n+        debug!(\"run_pass BorrowckMir: {}\", tcx.node_path_str(src.item_id()));\n+\n+        let def_id = tcx.hir.local_def_id(src.item_id());\n+        if tcx.has_attr(def_id, \"rustc_mir_borrowck\") || tcx.sess.opts.debugging_opts.borrowck_mir {\n+            borrowck_mir(tcx, src, mir);\n+        }\n+    }\n+}\n+\n+fn borrowck_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &Mir<'tcx>)\n+{\n+    let id = src.item_id();\n+    let def_id = tcx.hir.local_def_id(id);\n+    debug!(\"borrowck_mir({}) UNIMPLEMENTED\", tcx.item_path_str(def_id));\n+\n+    let attributes = tcx.get_attrs(def_id);\n+    let param_env = tcx.param_env(def_id);\n+    tcx.infer_ctxt().enter(|_infcx| {\n+\n+        let move_data = MoveData::gather_moves(mir, tcx, param_env);\n+        let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n+        let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+        let flow_borrows = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                       Borrows::new(tcx, mir),\n+                                       |bd, i| bd.location(i));\n+        let flow_inits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                     MaybeInitializedLvals::new(tcx, mir, &mdpe),\n+                                     |bd, i| &bd.move_data().move_paths[i]);\n+        let flow_uninits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                       MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n+                                       |bd, i| &bd.move_data().move_paths[i]);\n+        let flow_move_outs = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                         MovingOutStatements::new(tcx, mir, &mdpe),\n+                                         |bd, i| &bd.move_data().moves[i]);\n+\n+        let mut mbcx = MirBorrowckCtxt {\n+            tcx: tcx,\n+            mir: mir,\n+            node_id: id,\n+            move_data: &mdpe.move_data,\n+            param_env: param_env,\n+            fake_infer_ctxt: &_infcx,\n+        };\n+\n+        let mut state = InProgress::new(flow_borrows,\n+                                        flow_inits,\n+                                        flow_uninits,\n+                                        flow_move_outs);\n+\n+        mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n+    });\n+\n+    debug!(\"borrowck_mir done\");\n+}\n+\n+#[allow(dead_code)]\n+pub struct MirBorrowckCtxt<'c, 'b, 'a: 'b+'c, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    mir: &'b Mir<'gcx>,\n+    node_id: ast::NodeId,\n+    move_data: &'b MoveData<'gcx>,\n+    param_env: ParamEnv<'tcx>,\n+    fake_infer_ctxt: &'c InferCtxt<'c, 'gcx, 'tcx>,\n+}\n+\n+// (forced to be `pub` due to its use as an associated type below.)\n+pub struct InProgress<'b, 'tcx: 'b> {\n+    borrows: FlowInProgress<Borrows<'b, 'tcx>>,\n+    inits: FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>,\n+    uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>,\n+    move_outs: FlowInProgress<MovingOutStatements<'b, 'tcx>>,\n+}\n+\n+struct FlowInProgress<BD> where BD: BitDenotation {\n+    base_results: DataflowResults<BD>,\n+    curr_state: IdxSetBuf<BD::Idx>,\n+    stmt_gen: IdxSetBuf<BD::Idx>,\n+    stmt_kill: IdxSetBuf<BD::Idx>,\n+}\n+\n+// Check that:\n+// 1. assignments are always made to mutable locations (FIXME: does that still really go here?)\n+// 2. loans made in overlapping scopes do not conflict\n+// 3. assignments do not affect things loaned out as immutable\n+// 4. moves do not affect things loaned out in any way\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n+    for MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n+{\n+    type FlowState = InProgress<'b, 'gcx>;\n+\n+    fn mir(&self) -> &'b Mir<'gcx> { self.mir }\n+\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.reset_to_entry_of(bb),\n+                             |i| i.reset_to_entry_of(bb),\n+                             |u| u.reset_to_entry_of(bb));\n+    }\n+\n+    fn reconstruct_statement_effect(&mut self,\n+                                    location: Location,\n+                                    flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.reconstruct_statement_effect(location),\n+                             |i| i.reconstruct_statement_effect(location),\n+                             |u| u.reconstruct_statement_effect(location));\n+    }\n+\n+    fn apply_local_effect(&mut self,\n+                          _location: Location,\n+                          flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.apply_local_effect(),\n+                             |i| i.apply_local_effect(),\n+                             |u| u.apply_local_effect());\n+    }\n+\n+    fn reconstruct_terminator_effect(&mut self,\n+                                     location: Location,\n+                                     flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.reconstruct_terminator_effect(location),\n+                             |i| i.reconstruct_terminator_effect(location),\n+                             |u| u.reconstruct_terminator_effect(location));\n+    }\n+\n+    fn visit_block_entry(&mut self,\n+                         bb: BasicBlock,\n+                         flow_state: &Self::FlowState) {\n+        let summary = flow_state.summary();\n+        debug!(\"MirBorrowckCtxt::process_block({:?}): {}\", bb, summary);\n+    }\n+\n+    fn visit_statement_entry(&mut self,\n+                             location: Location,\n+                             stmt: &Statement<'gcx>,\n+                             flow_state: &Self::FlowState) {\n+        let summary = flow_state.summary();\n+        debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}): {}\", location, stmt, summary);\n+        let span = stmt.source_info.span;\n+        match stmt.kind {\n+            StatementKind::Assign(ref lhs, ref rhs) => {\n+                self.mutate_lvalue(ContextKind::AssignLhs.new(location),\n+                                   (lhs, span), JustWrite, flow_state);\n+                self.consume_rvalue(ContextKind::AssignRhs.new(location),\n+                                    (rhs, span), location, flow_state);\n+            }\n+            StatementKind::SetDiscriminant { ref lvalue, variant_index: _ } => {\n+                self.mutate_lvalue(ContextKind::SetDiscrim.new(location),\n+                                   (lvalue, span), JustWrite, flow_state);\n+            }\n+            StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                for (o, output) in asm.outputs.iter().zip(outputs) {\n+                    if o.is_indirect {\n+                        self.consume_lvalue(ContextKind::InlineAsm.new(location),\n+                                            Consume,\n+                                            (output, span),\n+                                            flow_state);\n+                    } else {\n+                        self.mutate_lvalue(ContextKind::InlineAsm.new(location),\n+                                           (output, span),\n+                                           if o.is_rw { WriteAndRead } else { JustWrite },\n+                                           flow_state);\n+                    }\n+                }\n+                for input in inputs {\n+                    self.consume_operand(ContextKind::InlineAsm.new(location),\n+                                         Consume,\n+                                         (input, span), flow_state);\n+                }\n+            }\n+            StatementKind::EndRegion(ref _rgn) => {\n+                // ignored when consuming results (update to\n+                // flow_state already handled).\n+            }\n+            StatementKind::Nop |\n+            StatementKind::Validate(..) |\n+            StatementKind::StorageLive(..) => {\n+                // ignored by borrowck\n+            }\n+\n+            StatementKind::StorageDead(ref lvalue) => {\n+                // causes non-drop values to be dropped.\n+                self.consume_lvalue(ContextKind::StorageDead.new(location),\n+                                    ConsumeKind::Consume,\n+                                    (lvalue, span),\n+                                    flow_state)\n+            }\n+        }\n+    }\n+\n+    fn visit_terminator_entry(&mut self,\n+                              location: Location,\n+                              term: &Terminator<'gcx>,\n+                              flow_state: &Self::FlowState) {\n+        let loc = location;\n+        let summary = flow_state.summary();\n+        debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?}): {}\", location, term, summary);\n+        let span = term.source_info.span;\n+        match term.kind {\n+            TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n+                self.consume_operand(ContextKind::SwitchInt.new(loc),\n+                                     Consume,\n+                                     (discr, span), flow_state);\n+            }\n+            TerminatorKind::Drop { location: ref drop_lvalue, target: _, unwind: _ } => {\n+                self.consume_lvalue(ContextKind::Drop.new(loc),\n+                                    ConsumeKind::Drop,\n+                                    (drop_lvalue, span), flow_state);\n+            }\n+            TerminatorKind::DropAndReplace { location: ref drop_lvalue,\n+                                             value: ref new_value,\n+                                             target: _,\n+                                             unwind: _ } => {\n+                self.mutate_lvalue(ContextKind::DropAndReplace.new(loc),\n+                                   (drop_lvalue, span), JustWrite, flow_state);\n+                self.consume_operand(ContextKind::DropAndReplace.new(loc),\n+                                     ConsumeKind::Drop,\n+                                     (new_value, span), flow_state);\n+            }\n+            TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n+                self.consume_operand(ContextKind::CallOperator.new(loc),\n+                                     Consume,\n+                                     (func, span), flow_state);\n+                for arg in args {\n+                    self.consume_operand(ContextKind::CallOperand.new(loc),\n+                                         Consume,\n+                                         (arg, span), flow_state);\n+                }\n+                if let Some((ref dest, _/*bb*/)) = *destination {\n+                    self.mutate_lvalue(ContextKind::CallDest.new(loc),\n+                                       (dest, span), JustWrite, flow_state);\n+                }\n+            }\n+            TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n+                self.consume_operand(ContextKind::Assert.new(loc),\n+                                     Consume,\n+                                     (cond, span), flow_state);\n+                match *msg {\n+                    AssertMessage::BoundsCheck { ref len, ref index } => {\n+                        self.consume_operand(ContextKind::Assert.new(loc),\n+                                             Consume,\n+                                             (len, span), flow_state);\n+                        self.consume_operand(ContextKind::Assert.new(loc),\n+                                             Consume,\n+                                             (index, span), flow_state);\n+                    }\n+                    AssertMessage::Math(_/*const_math_err*/) => {}\n+                }\n+            }\n+\n+            TerminatorKind::Goto { target: _ } |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Return |\n+            TerminatorKind::Unreachable => {\n+                // no data used, thus irrelevant to borrowck\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum MutateMode { JustWrite, WriteAndRead }\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ConsumeKind { Drop, Consume }\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum Control { Continue, Break }\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn mutate_lvalue(&mut self,\n+                     context: Context,\n+                     lvalue_span: (&Lvalue<'gcx>, Span),\n+                     mode: MutateMode,\n+                     flow_state: &InProgress<'b, 'gcx>) {\n+        // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n+        match mode {\n+            MutateMode::WriteAndRead => {\n+                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+            }\n+            MutateMode::JustWrite => {\n+                self.check_if_assigned_path_is_moved(context, lvalue_span, flow_state);\n+            }\n+        }\n+\n+        // check we don't invalidate any outstanding loans\n+        self.each_borrow_involving_path(context,\n+                                        lvalue_span.0, flow_state, |this, _index, _data| {\n+                                            this.report_illegal_mutation_of_borrowed(context,\n+                                                                                     lvalue_span);\n+                                            Control::Break\n+                                        });\n+\n+        // check for reassignments to immutable local variables\n+        self.check_if_reassignment_to_immutable_state(context, lvalue_span, flow_state);\n+    }\n+\n+    fn consume_rvalue(&mut self,\n+                      context: Context,\n+                      (rvalue, span): (&Rvalue<'gcx>, Span),\n+                      location: Location,\n+                      flow_state: &InProgress<'b, 'gcx>) {\n+        match *rvalue {\n+            Rvalue::Ref(_/*rgn*/, bk, ref lvalue) => {\n+                self.borrow(context, location, bk, (lvalue, span), flow_state)\n+            }\n+\n+            Rvalue::Use(ref operand) |\n+            Rvalue::Repeat(ref operand, _) |\n+            Rvalue::UnaryOp(_/*un_op*/, ref operand) |\n+            Rvalue::Cast(_/*cast_kind*/, ref operand, _/*ty*/) => {\n+                self.consume_operand(context, Consume, (operand, span), flow_state)\n+            }\n+\n+            Rvalue::Len(ref lvalue) |\n+            Rvalue::Discriminant(ref lvalue) => {\n+                // len(_)/discriminant(_) merely read, not consume.\n+                self.check_if_path_is_moved(context, (lvalue, span), flow_state);\n+            }\n+\n+            Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n+            Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n+                self.consume_operand(context, Consume, (operand1, span), flow_state);\n+                self.consume_operand(context, Consume, (operand2, span), flow_state);\n+            }\n+\n+            Rvalue::NullaryOp(_op, _ty) => {\n+                // nullary ops take no dynamic input; no borrowck effect.\n+                //\n+                // FIXME: is above actually true? Do we want to track\n+                // the fact that uninitialized data can be created via\n+                // `NullOp::Box`?\n+            }\n+\n+            Rvalue::Aggregate(ref _aggregate_kind, ref operands) => {\n+                for operand in operands {\n+                    self.consume_operand(context, Consume, (operand, span), flow_state);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn consume_operand(&mut self,\n+                       context: Context,\n+                       consume_via_drop: ConsumeKind,\n+                       (operand, span): (&Operand<'gcx>, Span),\n+                       flow_state: &InProgress<'b, 'gcx>) {\n+        match *operand {\n+            Operand::Consume(ref lvalue) =>\n+                self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state),\n+            Operand::Constant(_) => {}\n+        }\n+    }\n+\n+    fn consume_lvalue(&mut self,\n+                      context: Context,\n+                      consume_via_drop: ConsumeKind,\n+                      lvalue_span: (&Lvalue<'gcx>, Span),\n+                      flow_state: &InProgress<'b, 'gcx>) {\n+        let lvalue = lvalue_span.0;\n+        let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        let moves_by_default =\n+            self.fake_infer_ctxt.type_moves_by_default(self.param_env, ty, DUMMY_SP);\n+        if moves_by_default {\n+            // move of lvalue: check if this is move of already borrowed path\n+            self.each_borrow_involving_path(\n+                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n+                    if !borrow.compatible_with(BorrowKind::Mut) {\n+                        this.report_move_out_while_borrowed(context, lvalue_span);\n+                        Control::Break\n+                    } else {\n+                        Control::Continue\n+                    }\n+                });\n+        } else {\n+            // copy of lvalue: check if this is \"copy of frozen path\" (FIXME: see check_loans.rs)\n+            self.each_borrow_involving_path(\n+                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n+                    if !borrow.compatible_with(BorrowKind::Shared) {\n+                        this.report_use_while_mutably_borrowed(context, lvalue_span);\n+                        Control::Break\n+                    } else {\n+                        Control::Continue\n+                    }\n+                });\n+        }\n+\n+        // Finally, check if path was already moved.\n+        match consume_via_drop {\n+            ConsumeKind::Drop => {\n+                // If path is merely being dropped, then we'll already\n+                // check the drop flag to see if it is moved (thus we\n+                // skip this check in that case).\n+            }\n+            ConsumeKind::Consume => {\n+                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+            }\n+        }\n+    }\n+\n+    fn borrow(&mut self,\n+              context: Context,\n+              location: Location,\n+              bk: BorrowKind,\n+              lvalue_span: (&Lvalue<'gcx>, Span),\n+              flow_state: &InProgress<'b, 'gcx>) {\n+        debug!(\"borrow location: {:?} lvalue: {:?} span: {:?}\",\n+               location, lvalue_span.0, lvalue_span.1);\n+        self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+        self.check_for_conflicting_loans(context, location, bk, lvalue_span, flow_state);\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn check_if_reassignment_to_immutable_state(&mut self,\n+                                                context: Context,\n+                                                (lvalue, span): (&Lvalue<'gcx>, Span),\n+                                                flow_state: &InProgress<'b, 'gcx>) {\n+        let move_data = flow_state.inits.base_results.operator().move_data();\n+\n+        // determine if this path has a non-mut owner (and thus needs checking).\n+        let mut l = lvalue;\n+        loop {\n+            match *l {\n+                Lvalue::Projection(ref proj) => {\n+                    l = &proj.base;\n+                    continue;\n+                }\n+                Lvalue::Local(local) => {\n+                    match self.mir.local_decls[local].mutability {\n+                        Mutability::Not => break, // needs check\n+                        Mutability::Mut => return,\n+                    }\n+                }\n+                Lvalue::Static(_) => {\n+                    // mutation of non-mut static is always illegal,\n+                    // independent of dataflow.\n+                    self.report_assignment_to_static(context, (lvalue, span));\n+                    return;\n+                }\n+            }\n+        }\n+\n+        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n+            if flow_state.inits.curr_state.contains(&mpi) {\n+                // may already be assigned before reaching this statement;\n+                // report error.\n+                self.report_illegal_reassignment(context, (lvalue, span));\n+            }\n+        }\n+    }\n+\n+    fn check_if_path_is_moved(&mut self,\n+                              context: Context,\n+                              lvalue_span: (&Lvalue<'gcx>, Span),\n+                              flow_state: &InProgress<'b, 'gcx>) {\n+        // FIXME: analogous code in check_loans first maps `lvalue` to\n+        // its base_path ... but is that what we want here?\n+        let lvalue = self.base_path(lvalue_span.0);\n+\n+        let maybe_uninits = &flow_state.uninits;\n+        let move_data = maybe_uninits.base_results.operator().move_data();\n+        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n+            if maybe_uninits.curr_state.contains(&mpi) {\n+                // find and report move(s) that could cause this to be uninitialized\n+\n+                // FIXME: for each move in flow_state.move_outs ...\n+                &flow_state.move_outs;\n+\n+                self.report_use_of_moved(context, lvalue_span);\n+            } else {\n+                // sanity check: initialized on *some* path, right?\n+                assert!(flow_state.inits.curr_state.contains(&mpi));\n+            }\n+        }\n+    }\n+\n+    fn move_path_for_lvalue(&mut self,\n+                            _context: Context,\n+                            move_data: &MoveData<'gcx>,\n+                            lvalue: &Lvalue<'gcx>)\n+                            -> Option<MovePathIndex>\n+    {\n+        // If returns None, then there is no move path corresponding\n+        // to a direct owner of `lvalue` (which means there is nothing\n+        // that borrowck tracks for its analysis).\n+\n+        match move_data.rev_lookup.find(lvalue) {\n+            LookupResult::Parent(_) => None,\n+            LookupResult::Exact(mpi) => Some(mpi),\n+        }\n+    }\n+\n+    fn check_if_assigned_path_is_moved(&mut self,\n+                                       context: Context,\n+                                       (lvalue, span): (&Lvalue<'gcx>, Span),\n+                                       flow_state: &InProgress<'b, 'gcx>) {\n+        // recur down lvalue; dispatch to check_if_path_is_moved when necessary\n+        let mut lvalue = lvalue;\n+        loop {\n+            match *lvalue {\n+                Lvalue::Local(_) | Lvalue::Static(_) => {\n+                    // assigning to `x` does not require `x` be initialized.\n+                    break;\n+                }\n+                Lvalue::Projection(ref proj) => {\n+                    let Projection { ref base, ref elem } = **proj;\n+                    match *elem {\n+                        ProjectionElem::Deref |\n+                        // assigning to *P requires `P` initialized.\n+                        ProjectionElem::Index(_/*operand*/) |\n+                        ProjectionElem::ConstantIndex { .. } |\n+                        // assigning to P[i] requires `P` initialized.\n+                        ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>\n+                        // assigning to (P->variant) is okay if assigning to `P` is okay\n+                        //\n+                        // FIXME: is this true even if P is a adt with a dtor?\n+                        { }\n+\n+                        ProjectionElem::Subslice { .. } => {\n+                            panic!(\"we dont allow assignments to subslices, context: {:?}\",\n+                                   context);\n+                        }\n+\n+                        ProjectionElem::Field(..) => {\n+                            // if type of `P` has a dtor, then\n+                            // assigning to `P.f` requires `P` itself\n+                            // be already initialized\n+                            let tcx = self.tcx;\n+                            match base.ty(self.mir, tcx).to_ty(tcx).sty {\n+                                ty::TyAdt(def, _) if def.has_dtor(tcx) => {\n+\n+                                    // FIXME: analogous code in\n+                                    // check_loans.rs first maps\n+                                    // `base` to its base_path.\n+\n+                                    self.check_if_path_is_moved(context,\n+                                                                (base, span), flow_state);\n+\n+                                    // (base initialized; no need to\n+                                    // recur further)\n+                                    break;\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                    }\n+\n+                    lvalue = base;\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_conflicting_loans(&mut self,\n+                                   context: Context,\n+                                   _location: Location,\n+                                   _bk: BorrowKind,\n+                                   lvalue_span: (&Lvalue<'gcx>, Span),\n+                                   flow_state: &InProgress<'b, 'gcx>) {\n+        // NOTE FIXME: The analogous code in old borrowck\n+        // check_loans.rs is careful to iterate over every *issued*\n+        // loan, as opposed to just the in scope ones.\n+        //\n+        // (Or if you prefer, all the *other* iterations over loans\n+        // only consider loans that are in scope of some given\n+        // CodeExtent)\n+        //\n+        // The (currently skeletal) code here does not encode such a\n+        // distinction, which means it is almost certainly over\n+        // looking something.\n+        //\n+        // (It is probably going to reject code that should be\n+        // accepted, I suspect, by treated issued-but-out-of-scope\n+        // loans as issued-and-in-scope, and thus causing them to\n+        // interfere with other loans.)\n+        //\n+        // However, I just want to get something running, especially\n+        // since I am trying to move into new territory with NLL, so\n+        // lets get this going first, and then address the issued vs\n+        // in-scope distinction later.\n+\n+        let state = &flow_state.borrows;\n+        let data = &state.base_results.operator().borrows();\n+\n+        debug!(\"check_for_conflicting_loans location: {:?}\", _location);\n+\n+        // does any loan generated here conflict with a previously issued loan?\n+        let mut loans_generated = 0;\n+        for (g, gen) in state.elems_generated().map(|g| (g, &data[g])) {\n+            loans_generated += 1;\n+            for (i, issued) in state.elems_incoming().map(|i| (i, &data[i])) {\n+                debug!(\"check_for_conflicting_loans gen: {:?} issued: {:?} conflicts: {}\",\n+                       (g, gen, self.base_path(&gen.lvalue),\n+                        self.restrictions(&gen.lvalue).collect::<Vec<_>>()),\n+                       (i, issued, self.base_path(&issued.lvalue),\n+                        self.restrictions(&issued.lvalue).collect::<Vec<_>>()),\n+                       self.conflicts_with(gen, issued));\n+                if self.conflicts_with(gen, issued) {\n+                    self.report_conflicting_borrow(context, lvalue_span, gen, issued);\n+                }\n+            }\n+        }\n+\n+        // MIR statically ensures each statement gens *at most one*\n+        // loan; mutual conflict (within a statement) can't arise.\n+        //\n+        // As safe-guard, assert that above property actually holds.\n+        assert!(loans_generated <= 1);\n+    } }\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn each_borrow_involving_path<F>(&mut self,\n+                                     _context: Context,\n+                                     lvalue: &Lvalue<'gcx>,\n+                                     flow_state: &InProgress<'b, 'gcx>,\n+                                     mut op: F)\n+        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>) -> Control\n+    {\n+        // FIXME: analogous code in check_loans first maps `lvalue` to\n+        // its base_path.\n+\n+        let domain = flow_state.borrows.base_results.operator();\n+        let data = domain.borrows();\n+\n+        // check for loan restricting path P being used. Accounts for\n+        // borrows of P, P.a.b, etc.\n+        for i in flow_state.borrows.elems_incoming() {\n+            // FIXME: check_loans.rs filtered this to \"in scope\"\n+            // loans; i.e. it took a scope S and checked that each\n+            // restriction's kill_scope was a superscope of S.\n+            let borrowed = &data[i];\n+            for restricted in self.restrictions(&borrowed.lvalue) {\n+                if restricted == lvalue {\n+                    let ctrl = op(self, i, borrowed);\n+                    if ctrl == Control::Break { return; }\n+                }\n+            }\n+        }\n+\n+        // check for loans (not restrictions) on any base path.\n+        // e.g. Rejects `{ let x = &mut a.b; let y = a.b.c; }`,\n+        // since that moves out of borrowed path `a.b`.\n+        //\n+        // Limiting to loans (not restrictions) keeps this one\n+        // working: `{ let x = &mut a.b; let y = a.c; }`\n+        let mut cursor = lvalue;\n+        loop {\n+            // FIXME: check_loans.rs invoked `op` *before* cursor\n+            // shift here.  Might just work (and even avoid redundant\n+            // errors?) given code above?  But for now, I want to try\n+            // doing what I think is more \"natural\" check.\n+            for i in flow_state.borrows.elems_incoming() {\n+                let borrowed = &data[i];\n+                if borrowed.lvalue == *cursor {\n+                    let ctrl = op(self, i, borrowed);\n+                    if ctrl == Control::Break { return; }\n+                }\n+            }\n+\n+            match *cursor {\n+                Lvalue::Local(_) | Lvalue::Static(_) => break,\n+                Lvalue::Projection(ref proj) => cursor = &proj.base,\n+            }\n+        }\n+    }\n+}\n+\n+mod restrictions {\n+    use super::MirBorrowckCtxt;\n+\n+    use rustc::hir;\n+    use rustc::ty::{self, TyCtxt};\n+    use rustc::mir::{Lvalue, Mir, Operand, ProjectionElem};\n+\n+    pub(super) struct Restrictions<'c, 'tcx: 'c> {\n+        mir: &'c Mir<'tcx>,\n+        tcx: TyCtxt<'c, 'tcx, 'tcx>,\n+        lvalue_stack: Vec<&'c Lvalue<'tcx>>,\n+    }\n+\n+    impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+        pub(super) fn restrictions<'d>(&self,\n+                                       lvalue: &'d Lvalue<'gcx>)\n+                                       -> Restrictions<'d, 'gcx> where 'b: 'd\n+        {\n+            let lvalue_stack = if self.has_restrictions(lvalue) { vec![lvalue] } else { vec![] };\n+            Restrictions { lvalue_stack: lvalue_stack, mir: self.mir, tcx: self.tcx }\n+        }\n+\n+        fn has_restrictions(&self, lvalue: &Lvalue<'gcx>) -> bool {\n+            let mut cursor = lvalue;\n+            loop {\n+                let proj = match *cursor {\n+                    Lvalue::Local(_) => return true,\n+                    Lvalue::Static(_) => return false,\n+                    Lvalue::Projection(ref proj) => proj,\n+                };\n+                match proj.elem {\n+                    ProjectionElem::Index(..) |\n+                    ProjectionElem::ConstantIndex { .. } |\n+                    ProjectionElem::Downcast(..) |\n+                    ProjectionElem::Subslice { .. } |\n+                    ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n+                        cursor = &proj.base;\n+                        continue;\n+                    }\n+                    ProjectionElem::Deref => {\n+                        let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        match ty.sty {\n+                            ty::TyRawPtr(_) => {\n+                                return false;\n+                            }\n+                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                                // FIXME: do I need to check validity of\n+                                // region here though? (I think the original\n+                                // check_loans code did, like readme says)\n+                                return false;\n+                            }\n+                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                                cursor = &proj.base;\n+                                continue;\n+                            }\n+                            ty::TyAdt(..) if ty.is_box() => {\n+                                cursor = &proj.base;\n+                                continue;\n+                            }\n+                            _ => {\n+                                panic!(\"unknown type fed to Projection Deref.\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    impl<'c, 'tcx> Iterator for Restrictions<'c, 'tcx> {\n+        type Item = &'c Lvalue<'tcx>;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            'pop: loop {\n+                let lvalue = match self.lvalue_stack.pop() {\n+                    None => return None,\n+                    Some(lvalue) => lvalue,\n+                };\n+\n+                // `lvalue` may not be a restriction itself, but may\n+                // hold one further down (e.g. we never return\n+                // downcasts here, but may return a base of a\n+                // downcast).\n+                //\n+                // Also, we need to enqueue any additional\n+                // subrestrictions that it implies, since we can only\n+                // return from from this call alone.\n+\n+                let mut cursor = lvalue;\n+                'cursor: loop {\n+                    let proj = match *cursor {\n+                        Lvalue::Local(_) => return Some(cursor), // search yielded this leaf\n+                        Lvalue::Static(_) => continue 'pop, // fruitless leaf; try next on stack\n+                        Lvalue::Projection(ref proj) => proj,\n+                    };\n+\n+                    match proj.elem {\n+                        ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n+                            // FIXME: add union handling\n+                            self.lvalue_stack.push(&proj.base);\n+                            return Some(cursor);\n+                        }\n+                        ProjectionElem::Downcast(..) |\n+                        ProjectionElem::Subslice { .. } |\n+                        ProjectionElem::ConstantIndex { .. } |\n+                        ProjectionElem::Index(Operand::Constant(..)) => {\n+                            cursor = &proj.base;\n+                            continue 'cursor;\n+                        }\n+                        ProjectionElem::Index(Operand::Consume(ref index)) => {\n+                            self.lvalue_stack.push(index); // FIXME: did old borrowck do this?\n+                            cursor = &proj.base;\n+                            continue 'cursor;\n+                        }\n+                        ProjectionElem::Deref => {\n+                            // (handled below)\n+                        }\n+                    }\n+\n+                    assert_eq!(proj.elem, ProjectionElem::Deref);\n+\n+                    let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    match ty.sty {\n+                        ty::TyRawPtr(_) => {\n+                            // borrowck ignores raw ptrs; treat analogous to imm borrow\n+                            continue 'pop;\n+                        }\n+                        // R-Deref-Imm-Borrowed\n+                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                            // immutably-borrowed referents do not\n+                            // have recursively-implied restrictions\n+                            // (because preventing actions on `*LV`\n+                            // does nothing about aliases like `*LV1`)\n+\n+                            // FIXME: do I need to check validity of\n+                            // `_r` here though? (I think the original\n+                            // check_loans code did, like the readme\n+                            // says)\n+\n+                            // (And do I *really* not have to\n+                            // recursively process the `base` as a\n+                            // further search here? Leaving this `if\n+                            // false` here as a hint to look at this\n+                            // again later.\n+                            //\n+                            // Ah, it might be because the\n+                            // restrictions are distinct from the path\n+                            // substructure. Note that there is a\n+                            // separate loop over the path\n+                            // substructure in fn\n+                            // each_borrow_involving_path, for better\n+                            // or for worse.\n+\n+                            if false {\n+                                cursor = &proj.base;\n+                                continue 'cursor;\n+                            } else {\n+                                continue 'pop;\n+                            }\n+                        }\n+\n+                        // R-Deref-Mut-Borrowed\n+                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                            // mutably-borrowed referents are\n+                            // themselves restricted.\n+\n+                            // FIXME: do I need to check validity of\n+                            // `_r` here though? (I think the original\n+                            // check_loans code did, like the readme\n+                            // says)\n+\n+                            // schedule base for future iteration.\n+                            self.lvalue_stack.push(&proj.base);\n+                            return Some(cursor); // search yielded interior node\n+                        }\n+\n+                        // R-Deref-Send-Pointer\n+                        ty::TyAdt(..) if ty.is_box() => {\n+                            // borrowing interior of a box implies that\n+                            // its base can no longer be mutated (o/w box\n+                            // storage would be freed)\n+                            self.lvalue_stack.push(&proj.base);\n+                            return Some(cursor); // search yielded interior node\n+                        }\n+\n+                        _ => panic!(\"unknown type fed to Projection Deref.\"),\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn report_use_of_moved(&mut self,\n+                           _context: Context,\n+                           (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_act_on_uninitialized_variable(\n+            span, \"use\", &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span_label for use of uninitialized variable\n+        err.emit();\n+    }\n+\n+    fn report_move_out_while_borrowed(&mut self,\n+                                      _context: Context,\n+                                      (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_move_when_borrowed(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME 1: add span_label for \"borrow of `()` occurs here\"\n+        // FIXME 2: add span_label for \"move out of `{}` occurs here\"\n+        err.emit();\n+    }\n+\n+    fn report_use_while_mutably_borrowed(&mut self,\n+                                         _context: Context,\n+                                         (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME 1: add span_label for \"borrow of `()` occurs here\"\n+        // FIXME 2: add span_label for \"use of `{}` occurs here\"\n+        err.emit();\n+    }\n+\n+    fn report_conflicting_borrow(&mut self,\n+                                 _context: Context,\n+                                 (lvalue, span): (&Lvalue, Span),\n+                                 loan1: &BorrowData,\n+                                 loan2: &BorrowData) {\n+        // FIXME: obviously falsifiable. Generalize for non-eq lvalues later.\n+        assert_eq!(loan1.lvalue, loan2.lvalue);\n+\n+        // FIXME: supply non-\"\" `opt_via` when appropriate\n+        let mut err = match (loan1.kind, \"immutable\", \"mutable\",\n+                             loan2.kind, \"immutable\", \"mutable\") {\n+            (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n+            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) |\n+            (BorrowKind::Mut, _, lft, BorrowKind::Mut, _, rgt) =>\n+                self.tcx.cannot_reborrow_already_borrowed(\n+                    span, &self.describe_lvalue(lvalue),\n+                    \"\", lft, \"it\", rgt, \"\", Origin::Mir),\n+\n+            _ =>  self.tcx.cannot_mutably_borrow_multiply(\n+                span, &self.describe_lvalue(lvalue), \"\", Origin::Mir),\n+            // FIXME: add span labels for first and second mutable borrows, as well as\n+            // end point for first.\n+        };\n+        err.emit();\n+    }\n+\n+    fn report_illegal_mutation_of_borrowed(&mut self, _: Context, (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_assign_to_borrowed(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span labels for borrow and assignment points\n+        err.emit();\n+    }\n+\n+    fn report_illegal_reassignment(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_reassign_immutable(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span labels for borrow and assignment points\n+        err.emit();\n+    }\n+\n+    fn report_assignment_to_static(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_assign_static(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span labels for borrow and assignment points\n+        err.emit();\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    // End-user visible description of `lvalue`\n+    fn describe_lvalue(&self, lvalue: &Lvalue) -> String {\n+        let mut buf = String::new();\n+        self.append_lvalue_to_string(lvalue, &mut buf);\n+        buf\n+    }\n+\n+    // Appends end-user visible description of `lvalue` to `buf`.\n+    fn append_lvalue_to_string(&self, lvalue: &Lvalue, buf: &mut String) {\n+        match *lvalue {\n+            Lvalue::Local(local) => {\n+                let local = &self.mir.local_decls[local];\n+                match local.name {\n+                    Some(name) => buf.push_str(&format!(\"{}\", name)),\n+                    None => buf.push_str(\"_\"),\n+                }\n+            }\n+            Lvalue::Static(ref static_) => {\n+                buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n+            }\n+            Lvalue::Projection(ref proj) => {\n+                let (prefix, suffix, index_operand) = match proj.elem {\n+                    ProjectionElem::Deref =>\n+                        (\"(*\", format!(\")\"), None),\n+                    ProjectionElem::Downcast(..) =>\n+                        (\"\",   format!(\"\"), None), // (dont emit downcast info)\n+                    ProjectionElem::Field(field, _ty) =>\n+                        (\"\",   format!(\".{}\", field.index()), None),\n+                    ProjectionElem::Index(ref index) =>\n+                        (\"\",   format!(\"\"), Some(index)),\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n+                        (\"\",   format!(\"[{} of {}]\", offset, min_length), None),\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>\n+                        (\"\",   format!(\"[-{} of {}]\", offset, min_length), None),\n+                    ProjectionElem::Subslice { from, to: 0 } =>\n+                        (\"\",   format!(\"[{}:]\", from), None),\n+                    ProjectionElem::Subslice { from: 0, to } =>\n+                        (\"\",   format!(\"[:-{}]\", to), None),\n+                    ProjectionElem::Subslice { from, to } =>\n+                        (\"\",   format!(\"[{}:-{}]\", from, to), None),\n+                };\n+                buf.push_str(prefix);\n+                self.append_lvalue_to_string(&proj.base, buf);\n+                if let Some(index) = index_operand {\n+                    buf.push_str(\"[\");\n+                    self.append_operand_to_string(index, buf);\n+                    buf.push_str(\"]\");\n+                } else {\n+                    buf.push_str(&suffix);\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    fn append_operand_to_string(&self, operand: &Operand, buf: &mut String) {\n+        match *operand {\n+            Operand::Consume(ref lvalue) => {\n+                self.append_lvalue_to_string(lvalue, buf);\n+            }\n+            Operand::Constant(ref constant) => {\n+                buf.push_str(&format!(\"{:?}\", constant));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    // FIXME: needs to be able to express errors analogous to check_loans.rs\n+    fn conflicts_with(&self, loan1: &BorrowData<'gcx>, loan2: &BorrowData<'gcx>) -> bool {\n+        if loan1.compatible_with(loan2.kind) { return false; }\n+\n+        let loan2_base_path = self.base_path(&loan2.lvalue);\n+        for restricted in self.restrictions(&loan1.lvalue) {\n+            if restricted != loan2_base_path { continue; }\n+            return true;\n+        }\n+\n+        let loan1_base_path = self.base_path(&loan1.lvalue);\n+        for restricted in self.restrictions(&loan2.lvalue) {\n+            if restricted != loan1_base_path { continue; }\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    // FIXME (#16118): function intended to allow the borrow checker\n+    // to be less precise in its handling of Box while still allowing\n+    // moves out of a Box. They should be removed when/if we stop\n+    // treating Box specially (e.g. when/if DerefMove is added...)\n+\n+    fn base_path<'d>(&self, lvalue: &'d Lvalue<'gcx>) -> &'d Lvalue<'gcx> {\n+        //! Returns the base of the leftmost (deepest) dereference of an\n+        //! Box in `lvalue`. If there is no dereference of an Box\n+        //! in `lvalue`, then it just returns `lvalue` itself.\n+\n+        let mut cursor = lvalue;\n+        let mut deepest = lvalue;\n+        loop {\n+            let proj = match *cursor {\n+                Lvalue::Local(..) | Lvalue::Static(..) => return deepest,\n+                Lvalue::Projection(ref proj) => proj,\n+            };\n+            if proj.elem == ProjectionElem::Deref &&\n+                lvalue.ty(self.mir, self.tcx).to_ty(self.tcx).is_box()\n+            {\n+                deepest = &proj.base;\n+            }\n+            cursor = &proj.base;\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Context {\n+    kind: ContextKind,\n+    loc: Location,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ContextKind {\n+    AssignLhs,\n+    AssignRhs,\n+    SetDiscrim,\n+    InlineAsm,\n+    SwitchInt,\n+    Drop,\n+    DropAndReplace,\n+    CallOperator,\n+    CallOperand,\n+    CallDest,\n+    Assert,\n+    StorageDead,\n+}\n+\n+impl ContextKind {\n+    fn new(self, loc: Location) -> Context { Context { kind: self, loc: loc } }\n+}\n+\n+impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n+    pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'tcx>>,\n+                      inits: DataflowResults<MaybeInitializedLvals<'b, 'tcx>>,\n+                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>,\n+                      move_outs: DataflowResults<MovingOutStatements<'b, 'tcx>>) -> Self {\n+        InProgress {\n+            borrows: FlowInProgress::new(borrows),\n+            inits: FlowInProgress::new(inits),\n+            uninits: FlowInProgress::new(uninits),\n+            move_outs: FlowInProgress::new(move_outs),\n+        }\n+    }\n+\n+    fn each_flow<XB, XI, XU>(&mut self,\n+                             mut xform_borrows: XB,\n+                             mut xform_inits: XI,\n+                             mut xform_uninits: XU) where\n+        XB: FnMut(&mut FlowInProgress<Borrows<'b, 'tcx>>),\n+        XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>),\n+        XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>),\n+    {\n+        xform_borrows(&mut self.borrows);\n+        xform_inits(&mut self.inits);\n+        xform_uninits(&mut self.uninits);\n+    }\n+\n+    fn summary(&self) -> String {\n+        let mut s = String::new();\n+\n+        s.push_str(\"borrows in effect: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_state_bit(|borrow| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"borrows generated: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_gen_bit(|borrow| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"inits: [\");\n+        let mut saw_one = false;\n+        self.inits.each_state_bit(|mpi_init| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let move_path =\n+                &self.inits.base_results.operator().move_data().move_paths[mpi_init];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"uninits: [\");\n+        let mut saw_one = false;\n+        self.uninits.each_state_bit(|mpi_uninit| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let move_path =\n+                &self.uninits.base_results.operator().move_data().move_paths[mpi_uninit];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"]\");\n+\n+        return s;\n+    }\n+}\n+\n+impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n+    fn each_state_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n+        self.curr_state.each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    fn each_gen_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n+        self.stmt_gen.each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    fn new(results: DataflowResults<BD>) -> Self {\n+        let bits_per_block = results.sets().bits_per_block();\n+        let curr_state = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_gen = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_kill = IdxSetBuf::new_empty(bits_per_block);\n+        FlowInProgress {\n+            base_results: results,\n+            curr_state: curr_state,\n+            stmt_gen: stmt_gen,\n+            stmt_kill: stmt_kill,\n+        }\n+    }\n+\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n+        (*self.curr_state).clone_from(self.base_results.sets().on_entry_set_for(bb.index()));\n+    }\n+\n+    fn reconstruct_statement_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored, gen_set: &mut self.stmt_gen, kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results.operator().statement_effect(&mut sets, loc);\n+    }\n+\n+    fn reconstruct_terminator_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored, gen_set: &mut self.stmt_gen, kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results.operator().terminator_effect(&mut sets, loc);\n+    }\n+\n+    fn apply_local_effect(&mut self) {\n+        self.curr_state.union(&self.stmt_gen);\n+        self.curr_state.subtract(&self.stmt_kill);\n+    }\n+\n+    fn elems_generated(&self) -> indexed_set::Elems<BD::Idx> {\n+        let univ = self.base_results.sets().bits_per_block();\n+        self.stmt_gen.elems(univ)\n+    }\n+\n+    fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n+        let univ = self.base_results.sets().bits_per_block();\n+        self.curr_state.elems(univ)\n+    }\n+}\n+\n+impl<'tcx> BorrowData<'tcx> {\n+    fn compatible_with(&self, bk: BorrowKind) -> bool {\n+        match (self.kind, bk) {\n+            (BorrowKind::Shared, BorrowKind::Shared) => true,\n+\n+            (BorrowKind::Mut, _) |\n+            (BorrowKind::Unique, _) |\n+            (_, BorrowKind::Mut) |\n+            (_, BorrowKind::Unique) => false,\n+        }\n+    }\n+}"}, {"sha": "d8564f858e5683481f49ef46d8bde68018134f79", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -31,6 +31,7 @@ pub mod simplify;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;\n+pub mod borrow_check;\n pub mod rustc_peek;\n pub mod elaborate_drops;\n pub mod add_call_guards;"}, {"sha": "ceff52409b2f0f53c35140d6399cf823b2bd764e", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -13,7 +13,7 @@ use syntax::ast;\n use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt};\n-use rustc::mir::{self, Mir};\n+use rustc::mir::{self, Mir, Location};\n use rustc::mir::transform::{MirPass, MirSource};\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -202,7 +202,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // reset GEN and KILL sets before emulating their effect.\n         for e in sets.gen_set.words_mut() { *e = 0; }\n         for e in sets.kill_set.words_mut() { *e = 0; }\n-        results.0.operator.statement_effect(&mut sets, bb, j);\n+        results.0.operator.statement_effect(&mut sets, Location { block: bb, statement_index: j });\n         sets.on_entry.union(sets.gen_set);\n         sets.on_entry.subtract(sets.kill_set);\n     }"}, {"sha": "9de3072658660acea829ffc4547864b3e750e821", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -0,0 +1,192 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::{self, TyCtxt};\n+use rustc_errors::DiagnosticBuilder;\n+use syntax_pos::{MultiSpan, Span};\n+\n+use std::fmt;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Origin { Ast, Mir }\n+\n+impl fmt::Display for Origin {\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Origin::Mir => write!(w, \" (Mir)\"),\n+            Origin::Ast => ty::tls::with_opt(|opt_tcx| {\n+                // If user passed `-Z borrowck-mir`, then include an\n+                // AST origin as part of the error report\n+                if let Some(tcx) = opt_tcx {\n+                    if tcx.sess.opts.debugging_opts.borrowck_mir {\n+                        return write!(w, \" (Ast)\");\n+                    }\n+                }\n+                // otherwise, do not include the origin (i.e., print\n+                // nothing at all)\n+                Ok(())\n+            }),\n+        }\n+    }\n+}\n+\n+pub trait BorrowckErrors {\n+    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+                                                         sp: S,\n+                                                         msg: &str,\n+                                                         code: &str)\n+                                                         -> DiagnosticBuilder<'a>;\n+\n+    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n+                                               sp: S,\n+                                               msg: &str)\n+                                               -> DiagnosticBuilder<'a>;\n+\n+    fn cannot_move_when_borrowed(&self, span: Span, desc: &str, o: Origin)\n+                                 -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0505,\n+                         \"cannot move out of `{}` because it is borrowed{OGN}\",\n+                         desc, OGN=o)\n+    }\n+\n+    fn cannot_use_when_mutably_borrowed(&self, span: Span, desc: &str, o: Origin)\n+                                        -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0503,\n+                         \"cannot use `{}` because it was mutably borrowed{OGN}\",\n+                         desc, OGN=o)\n+    }\n+\n+    fn cannot_act_on_uninitialized_variable(&self,\n+                                            span: Span,\n+                                            verb: &str,\n+                                            desc: &str,\n+                                            o: Origin)\n+                                            -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0381,\n+                         \"{} of possibly uninitialized variable: `{}`{OGN}\",\n+                         verb, desc, OGN=o)\n+    }\n+\n+    fn cannot_mutably_borrow_multiply(&self,\n+                                      span: Span,\n+                                      desc: &str,\n+                                      opt_via: &str,\n+                                      o: Origin)\n+                                      -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0499,\n+                         \"cannot borrow `{}`{} as mutable more than once at a time{OGN}\",\n+                         desc, opt_via, OGN=o)\n+    }\n+\n+    fn cannot_uniquely_borrow_by_two_closures(&self, span: Span, desc: &str, o: Origin)\n+                                              -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0524,\n+                         \"two closures require unique access to `{}` at the same time{OGN}\",\n+                         desc, OGN=o)\n+    }\n+\n+    fn cannot_uniquely_borrow_by_one_closure(&self,\n+                                             span: Span,\n+                                             desc_new: &str,\n+                                             noun_old: &str,\n+                                             msg_old: &str,\n+                                             o: Origin)\n+                                             -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0500,\n+                         \"closure requires unique access to `{}` but {} is already borrowed{}{OGN}\",\n+                         desc_new, noun_old, msg_old, OGN=o)\n+    }\n+\n+    fn cannot_reborrow_already_uniquely_borrowed(&self,\n+                                                 span: Span,\n+                                                 desc_new: &str,\n+                                                 msg_new: &str,\n+                                                 kind_new: &str,\n+                                                 o: Origin)\n+                                                 -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0501,\n+                         \"cannot borrow `{}`{} as {} because previous closure \\\n+                          requires unique access{OGN}\",\n+                         desc_new, msg_new, kind_new, OGN=o)\n+    }\n+\n+    fn cannot_reborrow_already_borrowed(&self,\n+                                        span: Span,\n+                                        desc_new: &str,\n+                                        msg_new: &str,\n+                                        kind_new: &str,\n+                                        noun_old: &str,\n+                                        kind_old: &str,\n+                                        msg_old: &str,\n+                                        o: Origin)\n+                                        -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0502,\n+                         \"cannot borrow `{}`{} as {} because {} is also borrowed as {}{}{OGN}\",\n+                         desc_new, msg_new, kind_new, noun_old, kind_old, msg_old, OGN=o)\n+    }\n+\n+    fn cannot_assign_to_borrowed(&self, span: Span, desc: &str, o: Origin)\n+                                 -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0506,\n+                         \"cannot assign to `{}` because it is borrowed{OGN}\",\n+                         desc, OGN=o)\n+    }\n+\n+    fn cannot_move_into_closure(&self, span: Span, desc: &str, o: Origin)\n+                                -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0504,\n+                         \"cannot move `{}` into closure because it is borrowed{OGN}\",\n+                         desc, OGN=o)\n+    }\n+\n+    fn cannot_reassign_immutable(&self, span: Span, desc: &str, o: Origin)\n+                                 -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0384,\n+                         \"re-assignment of immutable variable `{}`{OGN}\",\n+                         desc, OGN=o)\n+    }\n+\n+    fn cannot_assign_static(&self, span: Span, desc: &str, o: Origin)\n+                            -> DiagnosticBuilder\n+    {\n+        self.struct_span_err(span, &format!(\"cannot assign to immutable static item {}{OGN}\",\n+                                            desc, OGN=o))\n+    }\n+}\n+\n+impl<'b, 'tcx, 'gcx> BorrowckErrors for TyCtxt<'b, 'tcx, 'gcx> {\n+    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+                                                         sp: S,\n+                                                         msg: &str,\n+                                                         code: &str)\n+                                                         -> DiagnosticBuilder<'a>\n+    {\n+        self.sess.struct_span_err_with_code(sp, msg, code)\n+    }\n+\n+    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n+                                               sp: S,\n+                                               msg: &str)\n+                                               -> DiagnosticBuilder<'a>\n+    {\n+        self.sess.struct_span_err(sp, msg)\n+    }\n+}"}, {"sha": "4b6da96824dcd9ac126247f25713b4e7fbb36205", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4a99fa8bfcdd27e0b07fcffc569416a3188a35/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=5f4a99fa8bfcdd27e0b07fcffc569416a3188a35", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub mod borrowck_errors;\n pub mod elaborate_drops;\n pub mod def_use;\n pub mod patch;"}]}