{"sha": "64f867ae3e22187b0cf7d08880f61145bd04827d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0Zjg2N2FlM2UyMjE4N2IwY2Y3ZDA4ODgwZjYxMTQ1YmQwNDgyN2Q=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-08-04T20:41:01Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-08-17T17:14:05Z"}, "message": "Serialize additional data for procedural macros\n\nSplit off from #62855\n\nThis PR deerializes the declaration `Span` and attributes for all\nprocedural macros from their underlying function definitions.\nThis allows Rustdoc to properly render doc comments\nand source links when inlining procedural macros across crates", "tree": {"sha": "085b7782f919cbc6490cd80a428e313e50a524b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/085b7782f919cbc6490cd80a428e313e50a524b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64f867ae3e22187b0cf7d08880f61145bd04827d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl1YNeEACgkQtAh+UQ6Y\nsWTUMw/+M9TbV+aFDCDGNQACQXHhxHo6ZI4qfPhVImxl1kZ7kFqmuxo0zHGNqM3w\nSTqu3HwEQ6/0zrRiOgWhH8wDnbJUVI5LAaYvnOtLwnHJ8hTnHQkXOmgLrRcz+18t\nGKz+uRbz5p5tCVr08Ncchb/9aT1PKkPuOQTqyZrSO31HtBmu5uwBT6g13p+KChPV\nPE7QaybKL31un5fmvE9FM6nCNA5SVt66QTu0TX1Oglq3fH+5i01jlQ7ouREXZ74b\nGKZ21tWL9NxpaqWs+U1DHt7iwU1QbsiU6YAfMfSPwIau8UWRUQB4OZ7kHsNm7uC7\n+Z2dgnebEN4TcBiKnwnzjeyjG+NihNyh2Ht7wykRLV28S39IxJBAgcIgZ7IF6DDV\nFEDIbFEL+YShzWE4YWbW1Xzcf01gaUAWvXDPXyOwS+C+RKS+XVV9iU0V/YX3c3PB\nL/nFgrE+FOIkt7RcTqTAjC78xBh2PjCKyr3SkP6vKJqwnDgeLtoDIUBOovtFAL5E\nwTt+9FO8YUGgOkKEGp7FwEBi+CKIcWWvTucis3wqHAKh6h3N/J6OcWvEFlb1FJfV\nQn8WeNJFzHrMiyypw1KaXdU5bmTUjOHrYsQX22EVVPAo6RE/LcoIQ9V21I9Nci5I\nQaKK5Z6V6RBxfEmRQtS5Szw9ogB5ImeyD7ljAOq/0bT+aMQ8GNo=\n=dnCz\n-----END PGP SIGNATURE-----", "payload": "tree 085b7782f919cbc6490cd80a428e313e50a524b9\nparent ac60ca0643feb3452688a9ca97c839c155742915\nauthor Aaron Hill <aa1ronham@gmail.com> 1564951261 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1566062045 -0400\n\nSerialize additional data for procedural macros\n\nSplit off from #62855\n\nThis PR deerializes the declaration `Span` and attributes for all\nprocedural macros from their underlying function definitions.\nThis allows Rustdoc to properly render doc comments\nand source links when inlining procedural macros across crates\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64f867ae3e22187b0cf7d08880f61145bd04827d", "html_url": "https://github.com/rust-lang/rust/commit/64f867ae3e22187b0cf7d08880f61145bd04827d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64f867ae3e22187b0cf7d08880f61145bd04827d/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac60ca0643feb3452688a9ca97c839c155742915", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac60ca0643feb3452688a9ca97c839c155742915", "html_url": "https://github.com/rust-lang/rust/commit/ac60ca0643feb3452688a9ca97c839c155742915"}], "stats": {"total": 450, "additions": 240, "deletions": 210}, "files": [{"sha": "5c543165bc2b19da1a271b65aa7331da77300b00", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -468,6 +468,14 @@ pub enum ProcMacro {\n }\n \n impl ProcMacro {\n+    pub fn name(&self) -> &'static str {\n+        match self {\n+            ProcMacro::CustomDerive { trait_name, .. } => trait_name,\n+            ProcMacro::Attr { name, .. } => name,\n+            ProcMacro::Bang { name, ..} => name\n+        }\n+    }\n+\n     pub const fn custom_derive(\n         trait_name: &'static str,\n         attributes: &'static [&'static str],"}, {"sha": "c91ad7858d0bb742e6870fded4f8f11dd2a2f850", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -1,5 +1,4 @@\n use crate::ty::{self, TyCtxt};\n-use crate::hir::map::definitions::FIRST_FREE_DEF_INDEX;\n use rustc_data_structures::indexed_vec::Idx;\n use std::fmt;\n use std::u32;\n@@ -102,31 +101,6 @@ newtype_index! {\n     }\n }\n \n-impl DefIndex {\n-    // Proc macros from a proc-macro crate have a kind of virtual DefIndex. This\n-    // function maps the index of the macro within the crate (which is also the\n-    // index of the macro in the CrateMetadata::proc_macros array) to the\n-    // corresponding DefIndex.\n-    pub fn from_proc_macro_index(proc_macro_index: usize) -> DefIndex {\n-        // DefIndex for proc macros start from FIRST_FREE_DEF_INDEX,\n-        // because the first FIRST_FREE_DEF_INDEX indexes are reserved\n-        // for internal use.\n-        let def_index = DefIndex::from(\n-            proc_macro_index.checked_add(FIRST_FREE_DEF_INDEX)\n-                .expect(\"integer overflow adding `proc_macro_index`\"));\n-        assert!(def_index != CRATE_DEF_INDEX);\n-        def_index\n-    }\n-\n-    // This function is the reverse of from_proc_macro_index() above.\n-    pub fn to_proc_macro_index(self: DefIndex) -> usize {\n-        self.index().checked_sub(FIRST_FREE_DEF_INDEX)\n-            .unwrap_or_else(|| {\n-                bug!(\"using local index {:?} as proc-macro index\", self)\n-            })\n-    }\n-}\n-\n impl rustc_serialize::UseSpecializedEncodable for DefIndex {}\n impl rustc_serialize::UseSpecializedDecodable for DefIndex {}\n "}, {"sha": "6dc3c7038f5696c625ae4601e4eb9a634d0ba40e", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -411,10 +411,6 @@ impl Definitions {\n     }\n \n     /// Adds a root definition (no parent) and a few other reserved definitions.\n-    ///\n-    /// After the initial definitions are created the first `FIRST_FREE_DEF_INDEX` indexes\n-    /// are taken, so the \"user\" indexes will be allocated starting with `FIRST_FREE_DEF_INDEX`\n-    /// in ascending order.\n     pub fn create_root_def(&mut self,\n                            crate_name: &str,\n                            crate_disambiguator: CrateDisambiguator)\n@@ -589,19 +585,6 @@ impl DefPathData {\n     }\n }\n \n-/// Evaluates to the number of tokens passed to it.\n-///\n-/// Logarithmic counting: every one or two recursive expansions, the number of\n-/// tokens to count is divided by two, instead of being reduced by one.\n-/// Therefore, the recursion depth is the binary logarithm of the number of\n-/// tokens to count, and the expanded tree is likewise very small.\n-macro_rules! count {\n-    ()                     => (0usize);\n-    ($one:tt)              => (1usize);\n-    ($($pairs:tt $_p:tt)*) => (count!($($pairs)*) << 1usize);\n-    ($odd:tt $($rest:tt)*) => (count!($($rest)*) | 1usize);\n-}\n-\n // We define the GlobalMetaDataKind enum with this macro because we want to\n // make sure that we exhaustively iterate over all variants when registering\n // the corresponding DefIndices in the DefTable.\n@@ -614,8 +597,6 @@ macro_rules! define_global_metadata_kind {\n             $($variant),*\n         }\n \n-        pub const FIRST_FREE_DEF_INDEX: usize = 1 + count!($($variant)*);\n-\n         impl GlobalMetaDataKind {\n             fn allocate_def_indices(definitions: &mut Definitions) {\n                 $({"}, {"sha": "af41b6a4c857f092101cac0c8286eaeda6e7e136", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 25, "deletions": 64, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -2,8 +2,7 @@\n \n use crate::cstore::{self, CStore, CrateSource, MetadataBlob};\n use crate::locator::{self, CratePaths};\n-use crate::decoder::proc_macro_def_path_table;\n-use crate::schema::CrateRoot;\n+use crate::schema::{CrateRoot};\n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n \n use rustc::hir::def_id::CrateNum;\n@@ -26,11 +25,11 @@ use std::{cmp, fs};\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::allocator::{global_allocator_spans, AllocatorKind};\n-use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::symbol::{Symbol, sym};\n use syntax::{span_err, span_fatal};\n use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n+use proc_macro::bridge::client::ProcMacro;\n \n pub struct Library {\n     pub dylib: Option<(PathBuf, PathKind)>,\n@@ -230,24 +229,13 @@ impl<'a> CrateLoader<'a> {\n \n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n \n-        let proc_macros = crate_root.proc_macro_decls_static.map(|_| {\n+        let raw_proc_macros =  crate_root.proc_macro_data.map(|_| {\n             if self.sess.opts.debugging_opts.dual_proc_macros {\n-                let host_lib = host_lib.unwrap();\n-                self.load_derive_macros(\n-                    &host_lib.metadata.get_root(),\n-                    host_lib.dylib.map(|p| p.0),\n-                    span\n-                )\n+                let host_lib = host_lib.as_ref().unwrap();\n+                self.dlsym_proc_macros(host_lib.dylib.as_ref().map(|p| p.0.clone()),\n+                                       &host_lib.metadata.get_root(), span)\n             } else {\n-                self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n-            }\n-        });\n-\n-        let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n-            if let Some(proc_macros) = &proc_macros {\n-                proc_macro_def_path_table(&crate_root, proc_macros)\n-            } else {\n-                crate_root.def_path_table.decode((&metadata, self.sess))\n+                self.dlsym_proc_macros(dylib.clone().map(|p| p.0), &crate_root, span)\n             }\n         });\n \n@@ -260,13 +248,16 @@ impl<'a> CrateLoader<'a> {\n             .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n             .collect();\n \n+        let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n+            crate_root.def_path_table.decode((&metadata, self.sess))\n+        });\n+\n         let cmeta = cstore::CrateMetadata {\n             name: crate_root.name,\n             imported_name: ident,\n             extern_crate: Lock::new(None),\n             def_path_table: Lrc::new(def_path_table),\n             trait_impls,\n-            proc_macros,\n             root: crate_root,\n             blob: metadata,\n             cnum_map,\n@@ -280,7 +271,10 @@ impl<'a> CrateLoader<'a> {\n                 rlib,\n                 rmeta,\n             },\n-            private_dep\n+            private_dep,\n+            span,\n+            host_lib,\n+            raw_proc_macros\n         };\n \n         let cmeta = Lrc::new(cmeta);\n@@ -389,7 +383,7 @@ impl<'a> CrateLoader<'a> {\n         match result {\n             (LoadResult::Previous(cnum), None) => {\n                 let data = self.cstore.get_crate_data(cnum);\n-                if data.root.proc_macro_decls_static.is_some() {\n+                if data.root.proc_macro_data.is_some() {\n                     dep_kind = DepKind::UnexportedMacrosOnly;\n                 }\n                 data.dep_kind.with_lock(|data_dep_kind| {\n@@ -482,7 +476,7 @@ impl<'a> CrateLoader<'a> {\n                           dep_kind: DepKind)\n                           -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n-        if crate_root.proc_macro_decls_static.is_some() {\n+        if crate_root.proc_macro_data.is_some() {\n             return cstore::CrateNumMap::new();\n         }\n \n@@ -574,19 +568,13 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    /// Loads custom derive macros.\n-    ///\n-    /// Note that this is intentionally similar to how we load plugins today,\n-    /// but also intentionally separate. Plugins are likely always going to be\n-    /// implemented as dynamic libraries, but we have a possible future where\n-    /// custom derive (and other macro-1.1 style features) are implemented via\n-    /// executables and custom IPC.\n-    fn load_derive_macros(&mut self, root: &CrateRoot<'_>, dylib: Option<PathBuf>, span: Span)\n-                          -> Vec<(ast::Name, Lrc<SyntaxExtension>)> {\n-        use std::{env, mem};\n+    fn dlsym_proc_macros(&self,\n+                         dylib: Option<PathBuf>,\n+                         root: &CrateRoot<'_>,\n+                         span: Span\n+    ) -> &'static [ProcMacro] {\n+        use std::env;\n         use crate::dynamic_lib::DynamicLibrary;\n-        use proc_macro::bridge::client::ProcMacro;\n-        use syntax::ext::proc_macro::{BangProcMacro, AttrProcMacro, ProcMacroDerive};\n \n         let path = match dylib {\n             Some(dylib) => dylib,\n@@ -608,38 +596,11 @@ impl<'a> CrateLoader<'a> {\n             *(sym as *const &[ProcMacro])\n         };\n \n-        let extensions = decls.iter().map(|&decl| {\n-            let (name, kind, helper_attrs) = match decl {\n-                ProcMacro::CustomDerive { trait_name, attributes, client } => {\n-                    let helper_attrs =\n-                        attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n-                    (\n-                        trait_name,\n-                        SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n-                            client, attrs: helper_attrs.clone()\n-                        })),\n-                        helper_attrs,\n-                    )\n-                }\n-                ProcMacro::Attr { name, client } => (\n-                    name, SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client })), Vec::new()\n-                ),\n-                ProcMacro::Bang { name, client } => (\n-                    name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n-                )\n-            };\n-\n-            (Symbol::intern(name), Lrc::new(SyntaxExtension {\n-                helper_attrs,\n-                ..SyntaxExtension::default(kind, root.edition)\n-            }))\n-        }).collect();\n-\n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long.\n-        mem::forget(lib);\n+        std::mem::forget(lib);\n \n-        extensions\n+        decls\n     }\n \n     /// Look for a plugin registrar. Returns library path, crate"}, {"sha": "792922a18372225ad2d0060eef53c606f19b8050", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -28,6 +28,9 @@ pub use crate::cstore_impl::{provide, provide_extern};\n pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n pub use rustc_data_structures::sync::MetadataRef;\n+use crate::creader::Library;\n+use syntax_pos::Span;\n+use proc_macro::bridge::client::ProcMacro;\n \n pub struct MetadataBlob(pub MetadataRef);\n \n@@ -82,11 +85,19 @@ pub struct CrateMetadata {\n     pub dep_kind: Lock<DepKind>,\n     pub source: CrateSource,\n \n-    pub proc_macros: Option<Vec<(ast::Name, Lrc<SyntaxExtension>)>>,\n-\n     /// Whether or not this crate should be consider a private dependency\n     /// for purposes of the 'exported_private_dependencies' lint\n-    pub private_dep: bool\n+    pub private_dep: bool,\n+\n+    pub host_lib: Option<Library>,\n+    pub span: Span,\n+\n+    pub raw_proc_macros: Option<&'static [ProcMacro]>,\n+}\n+\n+pub struct FullProcMacro {\n+    pub name: ast::Name,\n+    pub ext: Lrc<SyntaxExtension>\n }\n \n pub struct CStore {"}, {"sha": "a66da32fa4d7560ef79d4931cb35438ae8c077dd", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -426,8 +426,8 @@ impl cstore::CStore {\n \n     pub fn load_macro_untracked(&self, id: DefId, sess: &Session) -> LoadedMacro {\n         let data = self.get_crate_data(id.krate);\n-        if let Some(ref proc_macros) = data.proc_macros {\n-            return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n+        if data.is_proc_macro_crate() {\n+            return LoadedMacro::ProcMacro(data.get_proc_macro(id.index, sess).ext);\n         } else if data.name == sym::proc_macro && data.item_name(id.index) == sym::quote {\n             let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n             let kind = SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client }));\n@@ -439,7 +439,8 @@ impl cstore::CStore {\n         }\n \n         let def = data.get_macro(id.index);\n-        let macro_full_name = data.def_path(id.index).to_string_friendly(|_| data.imported_name);\n+        let macro_full_name = data.def_path(id.index)\n+            .to_string_friendly(|_| data.imported_name);\n         let source_name = FileName::Macros(macro_full_name);\n \n         let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);"}, {"sha": "26f3a22ab1eaf73b6b4e102e59b8d84d336111bf", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 113, "deletions": 71, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -1,16 +1,15 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n+use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule, FullProcMacro};\n use crate::schema::*;\n \n use rustc_data_structures::sync::{Lrc, ReadGuard};\n-use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash, Definitions};\n+use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n use rustc::middle::cstore::LinkagePreference;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Res, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::hir::map::definitions::DefPathTable;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n@@ -30,10 +29,11 @@ use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::source_map;\n use syntax::symbol::{Symbol, sym};\n-use syntax::ext::base::{MacroKind, SyntaxExtension};\n-use syntax::ext::hygiene::ExpnId;\n-use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n+use syntax::ext::base::{MacroKind, SyntaxExtensionKind, SyntaxExtension};\n+use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, symbol::{InternedString}};\n use log::debug;\n+use proc_macro::bridge::client::ProcMacro;\n+use syntax::ext::proc_macro::{AttrProcMacro, ProcMacroDerive, BangProcMacro};\n \n pub struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n@@ -138,7 +138,7 @@ impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> LazySeq<T> {\n     pub fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         meta: M,\n-    ) -> impl Iterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n+    ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n         let mut dcx = meta.decoder(self.position);\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         (0..self.len).map(move |_| T::decode(&mut dcx).unwrap())\n@@ -434,46 +434,16 @@ impl<'tcx> EntryKind<'tcx> {\n     }\n }\n \n-/// Creates the \"fake\" DefPathTable for a given proc macro crate.\n-///\n-/// The DefPathTable is as follows:\n-///\n-/// CRATE_ROOT (DefIndex 0:0)\n-///  |- GlobalMetaDataKind data (DefIndex 1:0 .. DefIndex 1:N)\n-///  |- proc macro #0 (DefIndex 1:N)\n-///  |- proc macro #1 (DefIndex 1:N+1)\n-///  \\- ...\n-crate fn proc_macro_def_path_table(crate_root: &CrateRoot<'_>,\n-                                   proc_macros: &[(ast::Name, Lrc<SyntaxExtension>)])\n-                                   -> DefPathTable\n-{\n-    let mut definitions = Definitions::default();\n-\n-    let name = crate_root.name.as_str();\n-    let disambiguator = crate_root.disambiguator;\n-    debug!(\"creating proc macro def path table for {:?}/{:?}\", name, disambiguator);\n-    let crate_root = definitions.create_root_def(&name, disambiguator);\n-    for (index, (name, _)) in proc_macros.iter().enumerate() {\n-        let def_index = definitions.create_def_with_parent(\n-            crate_root,\n-            ast::DUMMY_NODE_ID,\n-            DefPathData::MacroNs(name.as_interned_str()),\n-            ExpnId::root(),\n-            DUMMY_SP);\n-        debug!(\"definition for {:?} is {:?}\", name, def_index);\n-        assert_eq!(def_index, DefIndex::from_proc_macro_index(index));\n-    }\n-\n-    definitions.def_path_table().clone()\n-}\n-\n impl<'a, 'tcx> CrateMetadata {\n+    pub fn is_proc_macro_crate(&self) -> bool {\n+        self.root.proc_macro_decls_static.is_some()\n+    }\n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n-        self.proc_macros.is_some() && id != CRATE_DEF_INDEX\n+        self.is_proc_macro_crate() &&\n+            self.root.proc_macro_data.unwrap().decode(self).find(|x| *x == id).is_some()\n     }\n \n     fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n-        assert!(!self.is_proc_macro(item_id));\n         self.root.entries_index.lookup(self.blob.raw_bytes(), item_id)\n     }\n \n@@ -496,29 +466,89 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n+    fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n+        // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n+        // with items in 'raw_proc_macros'\n+        let pos = self.root.proc_macro_data.unwrap().decode(self).position(|i| i == id).unwrap();\n+        &self.raw_proc_macros.unwrap()[pos]\n+    }\n+\n     pub fn item_name(&self, item_index: DefIndex) -> Symbol {\n-        self.def_key(item_index)\n-            .disambiguated_data\n-            .data\n-            .get_opt_name()\n-            .expect(\"no name in item_name\")\n-            .as_symbol()\n+        if !self.is_proc_macro(item_index) {\n+            self.def_key(item_index)\n+                .disambiguated_data\n+                .data\n+                .get_opt_name()\n+                .expect(\"no name in item_name\")\n+                .as_symbol()\n+        } else {\n+            Symbol::intern(self.raw_proc_macro(item_index).name())\n+        }\n     }\n \n     pub fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n             self.entry(index).kind.def_kind()\n         } else {\n             Some(DefKind::Macro(\n-                self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.macro_kind()\n+                macro_kind(self.raw_proc_macro(index))\n             ))\n         }\n     }\n \n     pub fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n-        match self.is_proc_macro(index) {\n-            true => DUMMY_SP,\n-            false => self.entry(index).span.decode((self, sess)),\n+        self.entry(index).span.decode((self, sess))\n+    }\n+\n+\n+    pub fn get_proc_macro(&self, id: DefIndex, sess: &Session) -> FullProcMacro {\n+        if sess.opts.debugging_opts.dual_proc_macros {\n+            let host_lib = self.host_lib.as_ref().unwrap();\n+            self.load_proc_macro(\n+                &host_lib.metadata.get_root(),\n+                id,\n+                sess\n+            )\n+        } else {\n+            self.load_proc_macro(&self.root, id, sess)\n+        }\n+    }\n+\n+    fn load_proc_macro(&self, root: &CrateRoot<'_>,\n+                        id: DefIndex,\n+                        sess: &Session)\n+                        -> FullProcMacro {\n+\n+        let raw_macro = self.raw_proc_macro(id);\n+        let (name, kind, helper_attrs) = match *raw_macro {\n+            ProcMacro::CustomDerive { trait_name, attributes, client } => {\n+                let helper_attrs =\n+                    attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n+                (\n+                    trait_name,\n+                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n+                        client, attrs: helper_attrs.clone()\n+                    })),\n+                    helper_attrs,\n+                )\n+            }\n+            ProcMacro::Attr { name, client } => (\n+                name, SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client })), Vec::new()\n+            ),\n+            ProcMacro::Bang { name, client } => (\n+                name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n+            )\n+        };\n+\n+        let span = self.get_span(id, sess);\n+\n+        FullProcMacro {\n+            name: Symbol::intern(name),\n+            ext: Lrc::new(SyntaxExtension {\n+                span,\n+                helper_attrs,\n+                ..SyntaxExtension::default(kind, root.edition)\n+            })\n         }\n     }\n \n@@ -715,7 +745,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     /// Iterates over the language items in the given crate.\n     pub fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n         } else {\n@@ -730,18 +760,18 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n         where F: FnMut(def::Export<hir::HirId>)\n     {\n-        if let Some(ref proc_macros) = self.proc_macros {\n+        if let Some(proc_macros_ids) = self.root.proc_macro_data.map(|d| d.decode(self)) {\n             /* If we are loading as a proc macro, we want to return the view of this crate\n-             * as a proc macro crate, not as a Rust crate. See `proc_macro_def_path_table`\n-             * for the DefPathTable we are corresponding to.\n+             * as a proc macro crate.\n              */\n             if id == CRATE_DEF_INDEX {\n-                for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n+                for def_index in proc_macros_ids {\n+                    let raw_macro = self.raw_proc_macro(def_index);\n                     let res = Res::Def(\n-                        DefKind::Macro(ext.macro_kind()),\n-                        self.local_def_id(DefIndex::from_proc_macro_index(id)),\n+                        DefKind::Macro(macro_kind(raw_macro)),\n+                        self.local_def_id(def_index),\n                     );\n-                    let ident = Ident::with_dummy_span(name);\n+                    let ident = Ident::from_str(raw_macro.name());\n                     callback(def::Export {\n                         ident: ident,\n                         res: res,\n@@ -952,11 +982,8 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n-        if self.is_proc_macro(node_id) {\n-            return Lrc::new([]);\n-        }\n \n+    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n         // The attributes for a tuple struct/variant are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -1014,7 +1041,7 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n     ) -> &'tcx [DefId] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // proc-macro crates export no trait impls.\n             return &[]\n         }\n@@ -1058,7 +1085,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n \n     pub fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n         } else {\n@@ -1067,7 +1094,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n         } else {\n@@ -1090,7 +1117,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n         } else {\n@@ -1114,7 +1141,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // If this crate is a custom derive crate, then we're not even going to\n             // link those in so we skip those crates.\n             vec![]\n@@ -1183,13 +1210,18 @@ impl<'a, 'tcx> CrateMetadata {\n \n     #[inline]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.def_path_table.def_key(index)\n+        let mut key = self.def_path_table.def_key(index);\n+        if self.is_proc_macro(index) {\n+            let name = self.raw_proc_macro(index).name();\n+            key.disambiguated_data.data = DefPathData::MacroNs(InternedString::intern(name));\n+        }\n+        key\n     }\n \n     // Returns the path leading to the thing with this `id`.\n     pub fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n-        DefPath::make(self.cnum, id, |parent| self.def_path_table.def_key(parent))\n+        DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n     #[inline]\n@@ -1302,3 +1334,13 @@ impl<'a, 'tcx> CrateMetadata {\n         self.source_map_import_info.borrow()\n     }\n }\n+\n+// Cannot be implemented on 'ProcMacro', as libproc_macro\n+// does not depend on libsyntax\n+fn macro_kind(raw: &ProcMacro) -> MacroKind {\n+    match raw {\n+        ProcMacro::CustomDerive { .. } => MacroKind::Derive,\n+        ProcMacro::Attr { .. } => MacroKind::Attr,\n+        ProcMacro::Bang { .. } => MacroKind::Bang\n+    }\n+}"}, {"sha": "094f1a6ac330c3ce83202df8a6a4f42844aef87d", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -30,6 +30,7 @@ use rustc_data_structures::sync::Lrc;\n use std::u32;\n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::source_map::Spanned;\n use syntax::symbol::{kw, sym};\n use syntax_pos::{self, FileName, SourceFile, Span};\n@@ -376,6 +377,8 @@ impl<'tcx> EncodeContext<'tcx> {\n     }\n \n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n+        let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n+\n         let mut i = self.position();\n \n         let crate_deps = self.encode_crate_deps();\n@@ -456,16 +459,23 @@ impl<'tcx> EncodeContext<'tcx> {\n             self.lazy_seq(interpret_alloc_index)\n         };\n \n+\n         i = self.position();\n         let entries_index = self.entries_index.write_index(&mut self.opaque);\n         let entries_index_bytes = self.position() - i;\n \n+        // Encode the proc macro data\n+        i = self.position();\n+        let proc_macro_data = self.encode_proc_macros();\n+        let proc_macro_data_bytes = self.position() - i;\n+\n+\n         let attrs = tcx.hir().krate_attrs();\n-        let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n         let has_default_lib_allocator = attr::contains_name(&attrs, sym::default_lib_allocator);\n         let has_global_allocator = *tcx.sess.has_global_allocator.get();\n         let has_panic_handler = *tcx.sess.has_panic_handler.try_get().unwrap_or(&false);\n \n+\n         let root = self.lazy(&CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n             extra_filename: tcx.sess.opts.cg.extra_filename.clone(),\n@@ -484,6 +494,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             } else {\n                 None\n             },\n+            proc_macro_data,\n             proc_macro_stability: if is_proc_macro {\n                 tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).map(|stab| stab.clone())\n             } else {\n@@ -532,6 +543,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             println!(\"            impl bytes: {}\", impl_bytes);\n             println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n             println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n+            println!(\" proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n             println!(\"   entries index bytes: {}\", entries_index_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);\n@@ -1463,6 +1475,22 @@ impl EncodeContext<'tcx> {\n         self.lazy_seq(foreign_modules.iter().cloned())\n     }\n \n+    fn encode_proc_macros(&mut self) -> Option<LazySeq<DefIndex>> {\n+        let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n+        if is_proc_macro {\n+            let proc_macros: Vec<_> = self.tcx.hir().krate().items.values().filter_map(|item| {\n+                if item.attrs.iter().any(|attr| is_proc_macro_attr(attr)) {\n+                    Some(item.hir_id.owner)\n+                } else {\n+                    None\n+                }\n+            }).collect();\n+            Some(self.lazy_seq(proc_macros))\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n         let crates = self.tcx.crates();\n "}, {"sha": "ceba7cf0fe031c94324f06469b8d6edb33739f0c", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -716,7 +716,9 @@ impl<'a> Context<'a> {\n \n         let root = metadata.get_root();\n         if let Some(is_proc_macro) = self.is_proc_macro {\n-            if root.proc_macro_decls_static.is_some() != is_proc_macro {\n+            if root.proc_macro_data.is_some() != is_proc_macro {\n+                info!(\"Rejecting via proc macro: expected {} got {}\",\n+                      is_proc_macro, root.proc_macro_data.is_some());\n                 return None;\n             }\n         }"}, {"sha": "13c599cf997b65a5f400d0f7104e43ea42db7e3b", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -182,6 +182,10 @@ pub struct CrateRoot<'tcx> {\n \n     pub entries_index: LazySeq<index::Index<'tcx>>,\n \n+    /// The DefIndex's of any proc macros delcared by\n+    /// this crate\n+    pub proc_macro_data: Option<LazySeq<DefIndex>>,\n+\n     pub compiler_builtins: bool,\n     pub needs_allocator: bool,\n     pub needs_panic_runtime: bool,"}, {"sha": "250773a1853ec32a18745ead74d89516ba14e4f8", "filename": "src/test/ui/macros/same-sequence-span.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -18,15 +18,21 @@ error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fra\n   --> $DIR/same-sequence-span.rs:20:1\n    |\n LL | proc_macro_sequence::make_foo!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed after `expr` fragments\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | not allowed after `expr` fragments\n+   | in this macro invocation\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n \n error: `$x:expr` may be followed by `=`, which is not allowed for `expr` fragments\n   --> $DIR/same-sequence-span.rs:20:1\n    |\n LL | proc_macro_sequence::make_foo!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed after `expr` fragments\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | not allowed after `expr` fragments\n+   | in this macro invocation\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n "}, {"sha": "829d8bf4c81dae86f65e7061d5919ca1252c552c", "filename": "src/test/ui/proc-macro/generate-mod.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -2,13 +2,19 @@ error[E0412]: cannot find type `FromOutside` in this scope\n   --> $DIR/generate-mod.rs:9:1\n    |\n LL | generate_mod::check!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | not found in this scope\n+   | in this macro invocation\n \n error[E0412]: cannot find type `Outer` in this scope\n   --> $DIR/generate-mod.rs:9:1\n    |\n LL | generate_mod::check!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | not found in this scope\n+   | in this macro invocation\n \n error[E0412]: cannot find type `FromOutside` in this scope\n   --> $DIR/generate-mod.rs:12:1"}, {"sha": "65e40172ef539b24a03e36abaffff8ce6b25d736", "filename": "src/test/ui/proc-macro/invalid-punct-ident-4.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -2,7 +2,10 @@ error: unexpected close delimiter: `)`\n   --> $DIR/invalid-punct-ident-4.rs:6:1\n    |\n LL | lexer_failure!();\n-   | ^^^^^^^^^^^^^^^^^ unexpected close delimiter\n+   | ^^^^^^^^^^^^^^^^^\n+   | |\n+   | unexpected close delimiter\n+   | in this macro invocation\n \n error: proc macro panicked\n   --> $DIR/invalid-punct-ident-4.rs:6:1"}, {"sha": "f28b8c9fb73e9650b650668779a9581dfd9b685b", "filename": "src/test/ui/proc-macro/lints_in_proc_macros.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fproc-macro%2Flints_in_proc_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fproc-macro%2Flints_in_proc_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Flints_in_proc_macros.stderr?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -2,7 +2,10 @@ error[E0425]: cannot find value `foobar2` in this scope\n   --> $DIR/lints_in_proc_macros.rs:12:5\n    |\n LL |     bang_proc_macro2!();\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `foobar`\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     help: a local variable with a similar name exists: `foobar`\n+   |     in this macro invocation\n \n error: aborting due to previous error\n "}, {"sha": "a0c1f9cd5c05f9dcd2d387e0cddf347f5d1c1990", "filename": "src/test/ui/proc-macro/multispan.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -2,7 +2,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:14:5\n    |\n LL |     hello!(hi);\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:14:12\n@@ -14,7 +14,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:17:5\n    |\n LL |     hello!(hi hi);\n-   |     ^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:17:12\n@@ -26,7 +26,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:20:5\n    |\n LL |     hello!(hi hi hi);\n-   |     ^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:20:12\n@@ -38,7 +38,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:23:5\n    |\n LL |     hello!(hi hey hi yo hi beep beep hi hi);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:23:12\n@@ -50,7 +50,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:24:5\n    |\n LL |     hello!(hi there, hi how are you? hi... hi.);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:24:12\n@@ -62,7 +62,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:25:5\n    |\n LL |     hello!(whoah. hi di hi di ho);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:25:19\n@@ -74,7 +74,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:26:5\n    |\n LL |     hello!(hi good hi and good bye);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:26:12"}, {"sha": "06715c197bc5975c2a7894c88398281a79c0480c", "filename": "src/test/ui/proc-macro/subspan.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fproc-macro%2Fsubspan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fproc-macro%2Fsubspan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fsubspan.stderr?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -2,7 +2,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:11:1\n    |\n LL | subspan!(\"hi\");\n-   | ^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:11:11\n@@ -14,7 +14,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:14:1\n    |\n LL | subspan!(\"hihi\");\n-   | ^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:14:11\n@@ -26,7 +26,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:17:1\n    |\n LL | subspan!(\"hihihi\");\n-   | ^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:17:11\n@@ -38,7 +38,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:20:1\n    |\n LL | subspan!(\"why I hide? hi!\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:20:17\n@@ -50,7 +50,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:21:1\n    |\n LL | subspan!(\"hey, hi, hidy, hidy, hi hi\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:21:16\n@@ -62,7 +62,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:22:1\n    |\n LL | subspan!(\"this is a hi, and this is another hi\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:22:12\n@@ -74,7 +74,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:23:1\n    |\n LL | subspan!(\"how are you this evening\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:23:24\n@@ -86,7 +86,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:24:1\n    |\n LL | subspan!(\"this is highly eradic\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:24:12"}, {"sha": "0a6cbe13098a8c20f849b09962dcc5c4b5b8b05b", "filename": "src/test/ui/proc-macro/three-equals.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f867ae3e22187b0cf7d08880f61145bd04827d/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr?ref=64f867ae3e22187b0cf7d08880f61145bd04827d", "patch": "@@ -2,7 +2,7 @@ error: found 2 equal signs, need exactly 3\n   --> $DIR/three-equals.rs:15:5\n    |\n LL |     three_equals!(==);\n-   |     ^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n    = help: input must be: `===`\n "}]}