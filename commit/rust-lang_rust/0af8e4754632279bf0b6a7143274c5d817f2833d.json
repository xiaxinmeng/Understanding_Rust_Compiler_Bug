{"sha": "0af8e4754632279bf0b6a7143274c5d817f2833d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZjhlNDc1NDYzMjI3OWJmMGI2YTcxNDMyNzRjNWQ4MTdmMjgzM2Q=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-09-22T17:46:23Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-09-22T17:46:23Z"}, "message": "Fix rebase", "tree": {"sha": "eda91cfd97b575b51cd689b0b5976f1bdacf5432", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eda91cfd97b575b51cd689b0b5976f1bdacf5432"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0af8e4754632279bf0b6a7143274c5d817f2833d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0af8e4754632279bf0b6a7143274c5d817f2833d", "html_url": "https://github.com/rust-lang/rust/commit/0af8e4754632279bf0b6a7143274c5d817f2833d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0af8e4754632279bf0b6a7143274c5d817f2833d/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45b445e5a3a1f084becad71cd1ffbbff399a6462", "url": "https://api.github.com/repos/rust-lang/rust/commits/45b445e5a3a1f084becad71cd1ffbbff399a6462", "html_url": "https://github.com/rust-lang/rust/commit/45b445e5a3a1f084becad71cd1ffbbff399a6462"}], "stats": {"total": 62, "additions": 31, "deletions": 31}, "files": [{"sha": "f2a756ed3902147facb45a3f766c4a7f03ba8189", "filename": "src/librustc_front/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0af8e4754632279bf0b6a7143274c5d817f2833d/src%2Flibrustc_front%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af8e4754632279bf0b6a7143274c5d817f2833d/src%2Flibrustc_front%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fvisit.rs?ref=0af8e4754632279bf0b6a7143274c5d817f2833d", "patch": "@@ -407,7 +407,7 @@ pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V, prefix: &'v Path\n     }\n \n     if let PathListIdent { name, .. } = item.node {\n-        visitor.visit_ident(item.span, name);\n+        visitor.visit_name(item.span, name);\n     }\n }\n "}, {"sha": "51b2d58a58139acace2a59da8da6ac4629ab60c7", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0af8e4754632279bf0b6a7143274c5d817f2833d/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af8e4754632279bf0b6a7143274c5d817f2833d/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=0af8e4754632279bf0b6a7143274c5d817f2833d", "patch": "@@ -53,17 +53,17 @@ declare_lint! {\n pub struct NonCamelCaseTypes;\n \n impl NonCamelCaseTypes {\n-    fn check_case(&self, cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n-        fn is_camel_case(ident: ast::Ident) -> bool {\n-            let ident = ident.name.as_str();\n-            if ident.is_empty() {\n+    fn check_case(&self, cx: &LateContext, sort: &str, name: ast::Name, span: Span) {\n+        fn is_camel_case(name: ast::Name) -> bool {\n+            let name = name.as_str();\n+            if name.is_empty() {\n                 return true;\n             }\n-            let ident = ident.trim_matches('_');\n+            let name = name.trim_matches('_');\n \n             // start with a non-lowercase letter rather than non-uppercase\n             // ones (some scripts don't have a concept of upper/lowercase)\n-            !ident.is_empty() && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n+            !name.is_empty() && !name.char_at(0).is_lowercase() && !name.contains('_')\n         }\n \n         fn to_camel_case(s: &str) -> String {\n@@ -76,9 +76,9 @@ impl NonCamelCaseTypes {\n             )).collect::<Vec<_>>().concat()\n         }\n \n-        let s = ident.name.as_str();\n+        let s = name.as_str();\n \n-        if !is_camel_case(ident) {\n+        if !is_camel_case(name) {\n             let c = to_camel_case(&s);\n             let m = if c.is_empty() {\n                 format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, s)\n@@ -110,16 +110,16 @@ impl LateLintPass for NonCamelCaseTypes {\n \n         match it.node {\n             hir::ItemTy(..) | hir::ItemStruct(..) => {\n-                self.check_case(cx, \"type\", it.ident, it.span)\n+                self.check_case(cx, \"type\", it.name, it.span)\n             }\n             hir::ItemTrait(..) => {\n-                self.check_case(cx, \"trait\", it.ident, it.span)\n+                self.check_case(cx, \"trait\", it.name, it.span)\n             }\n             hir::ItemEnum(ref enum_definition, _) => {\n                 if has_extern_repr {\n                     return;\n                 }\n-                self.check_case(cx, \"type\", it.ident, it.span);\n+                self.check_case(cx, \"type\", it.name, it.span);\n                 for variant in &enum_definition.variants {\n                     self.check_case(cx, \"variant\", variant.node.name, variant.span);\n                 }\n@@ -130,7 +130,7 @@ impl LateLintPass for NonCamelCaseTypes {\n \n     fn check_generics(&mut self, cx: &LateContext, it: &hir::Generics) {\n         for gen in it.ty_params.iter() {\n-            self.check_case(cx, \"type parameter\", gen.ident, gen.span);\n+            self.check_case(cx, \"type parameter\", gen.name, gen.span);\n         }\n     }\n }\n@@ -237,31 +237,31 @@ impl LateLintPass for NonSnakeCase {\n                 fk: FnKind, _: &hir::FnDecl,\n                 _: &hir::Block, span: Span, id: ast::NodeId) {\n         match fk {\n-            FnKind::Method(ident, _, _) => match method_context(cx, id, span) {\n+            FnKind::Method(name, _, _) => match method_context(cx, id, span) {\n                 MethodLateContext::PlainImpl => {\n-                    self.check_snake_case(cx, \"method\", &ident.name.as_str(), Some(span))\n+                    self.check_snake_case(cx, \"method\", &name.as_str(), Some(span))\n                 },\n                 MethodLateContext::TraitDefaultImpl => {\n-                    self.check_snake_case(cx, \"trait method\", &ident.name.as_str(), Some(span))\n+                    self.check_snake_case(cx, \"trait method\", &name.as_str(), Some(span))\n                 },\n                 _ => (),\n             },\n-            FnKind::ItemFn(ident, _, _, _, _, _) => {\n-                self.check_snake_case(cx, \"function\", &ident.name.as_str(), Some(span))\n+            FnKind::ItemFn(name, _, _, _, _, _) => {\n+                self.check_snake_case(cx, \"function\", &name.as_str(), Some(span))\n             },\n             _ => (),\n         }\n     }\n \n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if let hir::ItemMod(_) = it.node {\n-            self.check_snake_case(cx, \"module\", &it.ident.name.as_str(), Some(it.span));\n+            self.check_snake_case(cx, \"module\", &it.name.as_str(), Some(it.span));\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if let hir::MethodTraitItem(_, None) = trait_item.node {\n-            self.check_snake_case(cx, \"trait method\", &trait_item.ident.name.as_str(),\n+            self.check_snake_case(cx, \"trait method\", &trait_item.name.as_str(),\n                                   Some(trait_item.span));\n         }\n     }\n@@ -281,10 +281,10 @@ impl LateLintPass for NonSnakeCase {\n     }\n \n     fn check_struct_def(&mut self, cx: &LateContext, s: &hir::StructDef,\n-                        _: ast::Ident, _: &hir::Generics, _: ast::NodeId) {\n+                        _: ast::Name, _: &hir::Generics, _: ast::NodeId) {\n         for sf in &s.fields {\n-            if let hir::StructField_ { kind: hir::NamedField(ident, _), .. } = sf.node {\n-                self.check_snake_case(cx, \"structure field\", &ident.name.as_str(),\n+            if let hir::StructField_ { kind: hir::NamedField(name, _), .. } = sf.node {\n+                self.check_snake_case(cx, \"structure field\", &name.as_str(),\n                                       Some(sf.span));\n             }\n         }\n@@ -301,8 +301,8 @@ declare_lint! {\n pub struct NonUpperCaseGlobals;\n \n impl NonUpperCaseGlobals {\n-    fn check_upper_case(cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n-        let s = ident.name.as_str();\n+    fn check_upper_case(cx: &LateContext, sort: &str, name: ast::Name, span: Span) {\n+        let s = name.as_str();\n \n         if s.chars().any(|c| c.is_lowercase()) {\n             let uc = NonSnakeCase::to_snake_case(&s).to_uppercase();\n@@ -330,10 +330,10 @@ impl LateLintPass for NonUpperCaseGlobals {\n         match it.node {\n             // only check static constants\n             hir::ItemStatic(_, hir::MutImmutable, _) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"static constant\", it.ident, it.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"static constant\", it.name, it.span);\n             }\n             hir::ItemConst(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.ident, it.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.name, it.span);\n             }\n             _ => {}\n         }\n@@ -343,7 +343,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n         match ti.node {\n             hir::ConstTraitItem(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n-                                                      ti.ident, ti.span);\n+                                                      ti.name, ti.span);\n             }\n             _ => {}\n         }\n@@ -353,7 +353,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n         match ii.node {\n             hir::ConstImplItem(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n-                                                      ii.ident, ii.span);\n+                                                      ii.name, ii.span);\n             }\n             _ => {}\n         }\n@@ -364,7 +364,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n             (&hir::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n-                                                      path1.node, p.span);\n+                                                      path1.node.name, p.span);\n             }\n             _ => {}\n         }"}, {"sha": "de2a7c696cc63c2dff91ec2afa575b6f83321afb", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0af8e4754632279bf0b6a7143274c5d817f2833d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af8e4754632279bf0b6a7143274c5d817f2833d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=0af8e4754632279bf0b6a7143274c5d817f2833d", "patch": "@@ -988,7 +988,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n     fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n         let name = if let hir::PathListIdent { name, .. } = item.node {\n-            name.name\n+            name\n         } else if !prefix.segments.is_empty() {\n             prefix.segments.last().unwrap().identifier.name\n         } else {"}]}