{"sha": "9e0203bd69ffd236b9e129235b94807909823eac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMDIwM2JkNjlmZmQyMzZiOWUxMjkyMzViOTQ4MDc5MDk4MjNlYWM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-08-30T16:35:49Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-08-30T16:39:08Z"}, "message": "internal: make scheduling control flow more obvious\n\nThere should be only one place where we need to check if we want to\nstart background activities.", "tree": {"sha": "9a572e8ae3d9f0424f46bf8d61eda3aeed615909", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a572e8ae3d9f0424f46bf8d61eda3aeed615909"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e0203bd69ffd236b9e129235b94807909823eac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e0203bd69ffd236b9e129235b94807909823eac", "html_url": "https://github.com/rust-lang/rust/commit/9e0203bd69ffd236b9e129235b94807909823eac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e0203bd69ffd236b9e129235b94807909823eac/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a59f344c4ff4f2bd3923a4499eb5868451698009", "url": "https://api.github.com/repos/rust-lang/rust/commits/a59f344c4ff4f2bd3923a4499eb5868451698009", "html_url": "https://github.com/rust-lang/rust/commit/a59f344c4ff4f2bd3923a4499eb5868451698009"}], "stats": {"total": 106, "additions": 52, "deletions": 54}, "files": [{"sha": "9f11254698aa494d0d099633dc98519238a16d41", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9e0203bd69ffd236b9e129235b94807909823eac/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e0203bd69ffd236b9e129235b94807909823eac/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=9e0203bd69ffd236b9e129235b94807909823eac", "patch": "@@ -152,8 +152,10 @@ impl GlobalState {\n             );\n         }\n \n-        self.fetch_workspaces_request();\n-        self.fetch_workspaces_if_needed();\n+        self.fetch_workspaces_queue.request_op();\n+        if self.fetch_workspaces_queue.should_start_op() {\n+            self.fetch_workspaces();\n+        }\n \n         while let Some(event) = self.next_event(&inbox) {\n             if let Event::Lsp(lsp_server::Message::Notification(not)) = &event {\n@@ -234,14 +236,14 @@ impl GlobalState {\n                                     (Progress::Report, Some(msg))\n                                 }\n                                 ProjectWorkspaceProgress::End(workspaces) => {\n-                                    self.fetch_workspaces_completed(workspaces);\n+                                    self.fetch_workspaces_queue.op_completed(workspaces);\n \n                                     let old = Arc::clone(&self.workspaces);\n                                     self.switch_workspaces();\n                                     let workspaces_updated = !Arc::ptr_eq(&old, &self.workspaces);\n \n                                     if self.config.run_build_scripts() && workspaces_updated {\n-                                        self.fetch_build_data_request()\n+                                        self.fetch_build_data_queue.request_op()\n                                     }\n \n                                     (Progress::End, None)\n@@ -257,7 +259,7 @@ impl GlobalState {\n                                     (Some(Progress::Report), Some(msg))\n                                 }\n                                 BuildDataProgress::End(build_data_result) => {\n-                                    self.fetch_build_data_completed(build_data_result);\n+                                    self.fetch_build_data_queue.op_completed(build_data_result);\n \n                                     self.switch_workspaces();\n \n@@ -425,7 +427,6 @@ impl GlobalState {\n             }\n \n             if !was_quiescent || state_changed {\n-                // Ensure that only one cache priming task can run at a time\n                 self.prime_caches_queue.request_op();\n \n                 // Refresh semantic tokens if the client supports it.\n@@ -473,10 +474,13 @@ impl GlobalState {\n         }\n \n         if self.config.cargo_autoreload() {\n-            self.fetch_workspaces_if_needed();\n+            if self.fetch_workspaces_queue.should_start_op() {\n+                self.fetch_workspaces();\n+            }\n+        }\n+        if self.fetch_build_data_queue.should_start_op() {\n+            self.fetch_build_data();\n         }\n-        self.fetch_build_data_if_needed();\n-\n         if self.prime_caches_queue.should_start_op() {\n             self.task_pool.handle.spawn_with_sender({\n                 let analysis = self.snapshot().analysis;\n@@ -495,7 +499,18 @@ impl GlobalState {\n             });\n         }\n \n-        self.report_new_status_if_needed();\n+        let status = self.current_status();\n+        if self.last_reported_status.as_ref() != Some(&status) {\n+            self.last_reported_status = Some(status.clone());\n+\n+            if let (lsp_ext::Health::Error, Some(message)) = (status.health, &status.message) {\n+                self.show_message(lsp_types::MessageType::Error, message.clone());\n+            }\n+\n+            if self.config.server_status_notification() {\n+                self.send_notification::<lsp_ext::ServerStatusNotification>(status);\n+            }\n+        }\n \n         let loop_duration = loop_start.elapsed();\n         if loop_duration > Duration::from_millis(100) {\n@@ -534,8 +549,7 @@ impl GlobalState {\n \n         RequestDispatcher { req: Some(req), global_state: self }\n             .on_sync_mut::<lsp_ext::ReloadWorkspace>(|s, ()| {\n-                s.fetch_workspaces_request();\n-                s.fetch_workspaces_if_needed();\n+                s.fetch_workspaces_queue.request_op();\n                 Ok(())\n             })?\n             .on_sync_mut::<lsp_types::request::Shutdown>(|s, ()| {"}, {"sha": "ad4d81ada7a75291395e1f9440bd246e58bbfeff", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 7, "deletions": 42, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9e0203bd69ffd236b9e129235b94807909823eac/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e0203bd69ffd236b9e129235b94807909823eac/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=9e0203bd69ffd236b9e129235b94807909823eac", "patch": "@@ -47,7 +47,7 @@ impl GlobalState {\n             self.analysis_host.update_lru_capacity(self.config.lru_capacity());\n         }\n         if self.config.linked_projects() != old_config.linked_projects() {\n-            self.fetch_workspaces_request()\n+            self.fetch_workspaces_queue.request_op()\n         } else if self.config.flycheck() != old_config.flycheck() {\n             self.reload_flycheck();\n         }\n@@ -71,7 +71,7 @@ impl GlobalState {\n                 \", \"\n             )\n         );\n-        self.fetch_workspaces_request();\n+        self.fetch_workspaces_queue.request_op();\n \n         fn is_interesting(path: &AbsPath, change_kind: ChangeKind) -> bool {\n             const IMPLICIT_TARGET_FILES: &[&str] = &[\"build.rs\", \"src/main.rs\", \"src/lib.rs\"];\n@@ -109,7 +109,8 @@ impl GlobalState {\n             false\n         }\n     }\n-    pub(crate) fn report_new_status_if_needed(&mut self) {\n+\n+    pub(crate) fn current_status(&self) -> lsp_ext::ServerStatusParams {\n         let mut status = lsp_ext::ServerStatusParams {\n             health: lsp_ext::Health::Ok,\n             quiescent: self.is_quiescent(),\n@@ -132,27 +133,10 @@ impl GlobalState {\n             status.health = lsp_ext::Health::Error;\n             status.message = Some(error)\n         }\n-\n-        if self.last_reported_status.as_ref() != Some(&status) {\n-            self.last_reported_status = Some(status.clone());\n-\n-            if let (lsp_ext::Health::Error, Some(message)) = (status.health, &status.message) {\n-                self.show_message(lsp_types::MessageType::Error, message.clone());\n-            }\n-\n-            if self.config.server_status_notification() {\n-                self.send_notification::<lsp_ext::ServerStatusNotification>(status);\n-            }\n-        }\n+        status\n     }\n \n-    pub(crate) fn fetch_workspaces_request(&mut self) {\n-        self.fetch_workspaces_queue.request_op()\n-    }\n-    pub(crate) fn fetch_workspaces_if_needed(&mut self) {\n-        if !self.fetch_workspaces_queue.should_start_op() {\n-            return;\n-        }\n+    pub(crate) fn fetch_workspaces(&mut self) {\n         tracing::info!(\"will fetch workspaces\");\n \n         self.task_pool.handle.spawn_with_sender({\n@@ -203,21 +187,8 @@ impl GlobalState {\n             }\n         });\n     }\n-    pub(crate) fn fetch_workspaces_completed(\n-        &mut self,\n-        workspaces: Vec<anyhow::Result<ProjectWorkspace>>,\n-    ) {\n-        self.fetch_workspaces_queue.op_completed(workspaces)\n-    }\n-\n-    pub(crate) fn fetch_build_data_request(&mut self) {\n-        self.fetch_build_data_queue.request_op();\n-    }\n-    pub(crate) fn fetch_build_data_if_needed(&mut self) {\n-        if !self.fetch_build_data_queue.should_start_op() {\n-            return;\n-        }\n \n+    pub(crate) fn fetch_build_data(&mut self) {\n         let workspaces = Arc::clone(&self.workspaces);\n         let config = self.config.cargo();\n         self.task_pool.handle.spawn_with_sender(move |sender| {\n@@ -236,12 +207,6 @@ impl GlobalState {\n             sender.send(Task::FetchBuildData(BuildDataProgress::End((workspaces, res)))).unwrap();\n         });\n     }\n-    pub(crate) fn fetch_build_data_completed(\n-        &mut self,\n-        build_data: (Arc<Vec<ProjectWorkspace>>, Vec<anyhow::Result<WorkspaceBuildScripts>>),\n-    ) {\n-        self.fetch_build_data_queue.op_completed(build_data)\n-    }\n \n     pub(crate) fn switch_workspaces(&mut self) {\n         let _p = profile::span(\"GlobalState::switch_workspaces\");"}, {"sha": "6131cdcbdce20cfdf91769697c92628bf8f67e0f", "filename": "docs/dev/style.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9e0203bd69ffd236b9e129235b94807909823eac/docs%2Fdev%2Fstyle.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e0203bd69ffd236b9e129235b94807909823eac/docs%2Fdev%2Fstyle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fstyle.md?ref=9e0203bd69ffd236b9e129235b94807909823eac", "patch": "@@ -257,6 +257,25 @@ if idx >= len {\n \n **Rationale:** it's useful to see the invariant relied upon by the rest of the function clearly spelled out.\n \n+## Control Flow\n+\n+As a special case of the previous rule, do not hide control flow inside functions, push it to the caller:\n+\n+```rust\n+// GOOD\n+if cond {\n+    f()\n+}\n+\n+// BAD\n+fn f() {\n+    if !cond {\n+        return;\n+    }\n+    ...\n+}\n+```\n+\n ## Assertions\n \n Assert liberally."}]}