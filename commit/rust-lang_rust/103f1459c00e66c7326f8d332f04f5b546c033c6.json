{"sha": "103f1459c00e66c7326f8d332f04f5b546c033c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwM2YxNDU5YzAwZTY2YzczMjZmOGQzMzJmMDRmNWI1NDZjMDMzYzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-30T20:02:56Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-30T20:02:56Z"}, "message": "rollup merge of #21702: nikomatsakis/issue-21636\n\nCheck and extract bindings from trait definitions.\n\nFixes #21636.\n\nr? @nick29581", "tree": {"sha": "50e6e7ac54b9bf52d638a6b276ffa234722ea5a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50e6e7ac54b9bf52d638a6b276ffa234722ea5a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/103f1459c00e66c7326f8d332f04f5b546c033c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/103f1459c00e66c7326f8d332f04f5b546c033c6", "html_url": "https://github.com/rust-lang/rust/commit/103f1459c00e66c7326f8d332f04f5b546c033c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/103f1459c00e66c7326f8d332f04f5b546c033c6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16120e9a1ff14e242f260357711dcc57263e757a", "url": "https://api.github.com/repos/rust-lang/rust/commits/16120e9a1ff14e242f260357711dcc57263e757a", "html_url": "https://github.com/rust-lang/rust/commit/16120e9a1ff14e242f260357711dcc57263e757a"}, {"sha": "093926e841df9a715f35d194846ad24134bafd2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/093926e841df9a715f35d194846ad24134bafd2c", "html_url": "https://github.com/rust-lang/rust/commit/093926e841df9a715f35d194846ad24134bafd2c"}], "stats": {"total": 84, "additions": 84, "deletions": 0}, "files": [{"sha": "ce66f4d5b355c76478981ff9ec88dc7d14dcb5a5", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/103f1459c00e66c7326f8d332f04f5b546c033c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103f1459c00e66c7326f8d332f04f5b546c033c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=103f1459c00e66c7326f8d332f04f5b546c033c6", "patch": "@@ -430,6 +430,11 @@ fn project_type<'cx,'tcx>(\n                                        &obligation_trait_ref,\n                                        &mut candidates);\n \n+    assemble_candidates_from_trait_def(selcx,\n+                                       obligation,\n+                                       &obligation_trait_ref,\n+                                       &mut candidates);\n+\n     if let Err(e) = assemble_candidates_from_impls(selcx,\n                                                    obligation,\n                                                    &obligation_trait_ref,\n@@ -474,6 +479,41 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n                                         candidate_set, env_predicates);\n }\n \n+/// In the case of a nested projection like <<A as Foo>::FooT as Bar>::BarT, we may find\n+/// that the definition of `Foo` has some clues:\n+///\n+/// ```rust\n+/// trait Foo {\n+///     type FooT : Bar<BarT=i32>\n+/// }\n+/// ```\n+///\n+/// Here, for example, we could conclude that the result is `i32`.\n+fn assemble_candidates_from_trait_def<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n+{\n+    // Check whether the self-type is itself a projection.\n+    let trait_ref = match obligation_trait_ref.self_ty().sty {\n+        ty::ty_projection(ref data) => data.trait_ref.clone(),\n+        ty::ty_infer(ty::TyVar(_)) => {\n+            // If the self-type is an inference variable, then it MAY wind up\n+            // being a projected type, so induce an ambiguity.\n+            candidate_set.ambiguous = true;\n+            return;\n+        }\n+        _ => { return; }\n+    };\n+\n+    // If so, extract what we know from the trait and try to come up with a good answer.\n+    let trait_def = ty::lookup_trait_def(selcx.tcx(), trait_ref.def_id);\n+    let bounds = trait_def.generics.to_bounds(selcx.tcx(), trait_ref.substs);\n+    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n+                                        candidate_set, bounds.predicates.into_vec());\n+}\n+\n fn assemble_candidates_from_predicates<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,"}, {"sha": "b47b0109bdf39220700753aed82820fb24a025e0", "filename": "src/test/run-pass/associated-types-binding-in-trait.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/103f1459c00e66c7326f8d332f04f5b546c033c6/src%2Ftest%2Frun-pass%2Fassociated-types-binding-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103f1459c00e66c7326f8d332f04f5b546c033c6/src%2Ftest%2Frun-pass%2Fassociated-types-binding-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-binding-in-trait.rs?ref=103f1459c00e66c7326f8d332f04f5b546c033c6", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case where the associated type binding (to `bool`, in this\n+// case) is derived from the trait definition. Issue #21636.\n+\n+use std::vec;\n+\n+pub trait BitIter {\n+    type Iter: Iterator<Item=bool>;\n+    fn bit_iter(self) -> <Self as BitIter>::Iter;\n+}\n+\n+impl BitIter for Vec<bool> {\n+    type Iter = vec::IntoIter<bool>;\n+    fn bit_iter(self) -> <Self as BitIter>::Iter {\n+        self.into_iter()\n+    }\n+}\n+\n+fn count<T>(arg: T) -> usize\n+    where T: BitIter\n+{\n+    let mut sum = 0;\n+    for i in arg.bit_iter() {\n+        if i {\n+            sum += 1;\n+        }\n+    }\n+    sum\n+}\n+\n+fn main() {\n+    let v = vec![true, false, true];\n+    let c = count(v);\n+    assert_eq!(c, 2);\n+}"}]}