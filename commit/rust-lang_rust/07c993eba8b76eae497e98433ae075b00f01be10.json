{"sha": "07c993eba8b76eae497e98433ae075b00f01be10", "node_id": "C_kwDOAAsO6NoAKDA3Yzk5M2ViYThiNzZlYWU0OTdlOTg0MzNhZTA3NWIwMGYwMWJlMTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-23T09:20:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-23T09:20:10Z"}, "message": "Auto merge of #108369 - compiler-errors:ty-error-more, r=BoxyUwU\n\nUse `tcx.ty_error_with_guaranteed` in more places, rename variants\n\n1. Use `ty_error_with_guaranteed` more so we don't delay so many span bugs\n2. Rename `ty_error_with_guaranteed` to `ty_error`, `ty_error` to `ty_error_misc`. This is to incentivize using the former over the latter in cases where we already are witness to a `ErrorGuaranteed` token.\n\nSecond commit is just name replacement, so the first commit can be reviewed on its own with more scrutiny.", "tree": {"sha": "69748b387cb62fabe30006ca5e386aae4db38afb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69748b387cb62fabe30006ca5e386aae4db38afb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07c993eba8b76eae497e98433ae075b00f01be10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07c993eba8b76eae497e98433ae075b00f01be10", "html_url": "https://github.com/rust-lang/rust/commit/07c993eba8b76eae497e98433ae075b00f01be10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07c993eba8b76eae497e98433ae075b00f01be10/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb909d81464900597b91f3bbf2a6bef10006c9ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb909d81464900597b91f3bbf2a6bef10006c9ff", "html_url": "https://github.com/rust-lang/rust/commit/eb909d81464900597b91f3bbf2a6bef10006c9ff"}, {"sha": "298ae8c721102c36243335653e57a7f94e08f94a", "url": "https://api.github.com/repos/rust-lang/rust/commits/298ae8c721102c36243335653e57a7f94e08f94a", "html_url": "https://github.com/rust-lang/rust/commit/298ae8c721102c36243335653e57a7f94e08f94a"}], "stats": {"total": 687, "additions": 374, "deletions": 313}, "files": [{"sha": "c550e37c63eefd06d4532a9c1d1cf34ffb557534", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -1,5 +1,6 @@\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::vec_map::VecMap;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n use rustc_infer::infer::TyCtxtInferExt as _;\n@@ -149,13 +150,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // once we convert the generic parameters to those of the opaque type.\n             if let Some(prev) = result.get_mut(&opaque_type_key.def_id) {\n                 if prev.ty != ty {\n-                    if !ty.references_error() {\n+                    let guar = ty.error_reported().err().unwrap_or_else(|| {\n                         prev.report_mismatch(\n                             &OpaqueHiddenType { ty, span: concrete_type.span },\n                             infcx.tcx,\n-                        );\n-                    }\n-                    prev.ty = infcx.tcx.ty_error();\n+                        )\n+                    });\n+                    prev.ty = infcx.tcx.ty_error(guar);\n                 }\n                 // Pick a better span if there is one.\n                 // FIXME(oli-obk): collect multiple spans for better diagnostics down the road.\n@@ -247,20 +248,20 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         origin: OpaqueTyOrigin,\n     ) -> Ty<'tcx> {\n         if let Some(e) = self.tainted_by_errors() {\n-            return self.tcx.ty_error_with_guaranteed(e);\n+            return self.tcx.ty_error(e);\n         }\n \n         let definition_ty = instantiated_ty\n             .remap_generic_params_to_declaration_params(opaque_type_key, self.tcx, false)\n             .ty;\n \n-        if !check_opaque_type_parameter_valid(\n+        if let Err(guar) = check_opaque_type_parameter_valid(\n             self.tcx,\n             opaque_type_key,\n             origin,\n             instantiated_ty.span,\n         ) {\n-            return self.tcx.ty_error();\n+            return self.tcx.ty_error(guar);\n         }\n \n         // Only check this for TAIT. RPIT already supports `tests/ui/impl-trait/nested-return-type2.rs`\n@@ -325,7 +326,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             definition_ty\n         } else {\n             let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n-            self.tcx.ty_error_with_guaranteed(reported)\n+            self.tcx.ty_error(reported)\n         }\n     }\n }\n@@ -335,7 +336,7 @@ fn check_opaque_type_parameter_valid(\n     opaque_type_key: OpaqueTypeKey<'_>,\n     origin: OpaqueTyOrigin,\n     span: Span,\n-) -> bool {\n+) -> Result<(), ErrorGuaranteed> {\n     match origin {\n         // No need to check return position impl trait (RPIT)\n         // because for type and const parameters they are correct\n@@ -358,7 +359,7 @@ fn check_opaque_type_parameter_valid(\n         // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n         //\n         // which would error here on all of the `'static` args.\n-        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n+        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return Ok(()),\n         // Check these\n         OpaqueTyOrigin::TyAlias => {}\n     }\n@@ -379,13 +380,13 @@ fn check_opaque_type_parameter_valid(\n             // Prevent `fn foo() -> Foo<u32>` from being defining.\n             let opaque_param = opaque_generics.param_at(i, tcx);\n             let kind = opaque_param.kind.descr();\n-            tcx.sess.emit_err(NonGenericOpaqueTypeParam {\n+\n+            return Err(tcx.sess.emit_err(NonGenericOpaqueTypeParam {\n                 ty: arg,\n                 kind,\n                 span,\n                 param_span: tcx.def_span(opaque_param.def_id),\n-            });\n-            return false;\n+            }));\n         }\n     }\n \n@@ -396,12 +397,13 @@ fn check_opaque_type_parameter_valid(\n                 .into_iter()\n                 .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n                 .collect();\n-            tcx.sess\n+            return Err(tcx\n+                .sess\n                 .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n                 .span_note(spans, &format!(\"{} used multiple times\", descr))\n-                .emit();\n-            return false;\n+                .emit());\n         }\n     }\n-    true\n+\n+    Ok(())\n }"}, {"sha": "e2f897a89e82e1cc44259842de0e4e228dad2583", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -270,12 +270,13 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                 .and(type_op::normalize::Normalize::new(ty))\n                 .fully_perform(self.infcx)\n                 .unwrap_or_else(|_| {\n-                    self.infcx\n+                    let guar = self\n+                        .infcx\n                         .tcx\n                         .sess\n                         .delay_span_bug(span, &format!(\"failed to normalize {:?}\", ty));\n                     TypeOpOutput {\n-                        output: self.infcx.tcx.ty_error(),\n+                        output: self.infcx.tcx.ty_error(guar),\n                         constraints: None,\n                         error_info: None,\n                     }"}, {"sha": "c4e7e1f8ffa304b0b2b64c3ded9f8aa74ad4a933", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -239,7 +239,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n                     decl.hidden_type.span,\n                     &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n                 );\n-                hidden_type.ty = infcx.tcx.ty_error_with_guaranteed(reported);\n+                hidden_type.ty = infcx.tcx.ty_error(reported);\n             }\n \n             (opaque_type_key, (hidden_type, decl.origin))\n@@ -529,9 +529,9 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         for elem in place.projection.iter() {\n             if place_ty.variant_index.is_none() {\n-                if place_ty.ty.references_error() {\n+                if let Err(guar) = place_ty.ty.error_reported() {\n                     assert!(self.errors_reported);\n-                    return PlaceTy::from_ty(self.tcx().ty_error());\n+                    return PlaceTy::from_ty(self.tcx().ty_error(guar));\n                 }\n             }\n             place_ty = self.sanitize_projection(place_ty, elem, place, location, context);\n@@ -763,7 +763,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n     fn error(&mut self) -> Ty<'tcx> {\n         self.errors_reported = true;\n-        self.tcx().ty_error()\n+        self.tcx().ty_error_misc()\n     }\n \n     fn get_ambient_variance(&self, context: PlaceContext) -> ty::Variance {"}, {"sha": "92dc02c8d3f150a397944d2ca522b1bade68172a", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -429,7 +429,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                     if let (hir::TyKind::Infer, false) = (&ty.kind, self.astconv.allow_ty_infer()) {\n                         self.inferred_params.push(ty.span);\n-                        tcx.ty_error().into()\n+                        tcx.ty_error_misc().into()\n                     } else {\n                         self.astconv.ast_ty_to_ty(ty).into()\n                     }\n@@ -502,14 +502,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 _ => false,\n                             }) {\n                                 // Avoid ICE #86756 when type error recovery goes awry.\n-                                return tcx.ty_error().into();\n+                                return tcx.ty_error_misc().into();\n                             }\n                             tcx.at(self.span).type_of(param.def_id).subst(tcx, substs).into()\n                         } else if infer_args {\n                             self.astconv.ty_infer(Some(param), self.span).into()\n                         } else {\n                             // We've already errored above about the mismatch.\n-                            tcx.ty_error().into()\n+                            tcx.ty_error_misc().into()\n                         }\n                     }\n                     GenericParamDefKind::Const { has_default } => {\n@@ -518,8 +518,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             .type_of(param.def_id)\n                             .no_bound_vars()\n                             .expect(\"const parameter types cannot be generic\");\n-                        if ty.references_error() {\n-                            return tcx.const_error(ty).into();\n+                        if let Err(guar) = ty.error_reported() {\n+                            return tcx.const_error_with_guaranteed(ty, guar).into();\n                         }\n                         if !infer_args && has_default {\n                             tcx.const_param_default(param.def_id).subst(tcx, substs.unwrap()).into()\n@@ -1239,9 +1239,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         }\n                         let reported = err.emit();\n                         term = match def_kind {\n-                            hir::def::DefKind::AssocTy => {\n-                                tcx.ty_error_with_guaranteed(reported).into()\n-                            }\n+                            hir::def::DefKind::AssocTy => tcx.ty_error(reported).into(),\n                             hir::def::DefKind::AssocConst => tcx\n                                 .const_error_with_guaranteed(\n                                     tcx.type_of(assoc_item_def_id)\n@@ -1397,7 +1395,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .map(|trait_ref| tcx.def_span(trait_ref));\n             let reported =\n                 tcx.sess.emit_err(TraitObjectDeclaredWithNoTraits { span, trait_alias_span });\n-            return tcx.ty_error_with_guaranteed(reported);\n+            return tcx.ty_error(reported);\n         }\n \n         // Check that there are no gross object safety violations;\n@@ -1414,7 +1412,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     &object_safety_violations,\n                 )\n                 .emit();\n-                return tcx.ty_error_with_guaranteed(reported);\n+                return tcx.ty_error(reported);\n             }\n         }\n \n@@ -1523,10 +1521,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         if arg == dummy_self.into() {\n                             let param = &generics.params[index];\n                             missing_type_params.push(param.name);\n-                            return tcx.ty_error().into();\n+                            return tcx.ty_error_misc().into();\n                         } else if arg.walk().any(|arg| arg == dummy_self.into()) {\n                             references_self = true;\n-                            return tcx.ty_error().into();\n+                            return tcx.ty_error_misc().into();\n                         }\n                         arg\n                     })\n@@ -1579,15 +1577,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     false\n                 });\n                 if references_self {\n-                    tcx.sess\n+                    let guar = tcx\n+                        .sess\n                         .delay_span_bug(span, \"trait object projection bounds reference `Self`\");\n                     let substs: Vec<_> = b\n                         .projection_ty\n                         .substs\n                         .iter()\n                         .map(|arg| {\n                             if arg.walk().any(|arg| arg == dummy_self.into()) {\n-                                return tcx.ty_error().into();\n+                                return tcx.ty_error(guar).into();\n                             }\n                             arg\n                         })\n@@ -2473,7 +2472,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 &[path_str],\n                 item_segment.ident.name,\n             );\n-            return tcx.ty_error_with_guaranteed(reported)\n+            return tcx.ty_error(reported)\n         };\n \n         debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n@@ -2820,7 +2819,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n                         tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id))\n                     }\n-                    Some(rbv::ResolvedArg::Error(guar)) => tcx.ty_error_with_guaranteed(guar),\n+                    Some(rbv::ResolvedArg::Error(guar)) => tcx.ty_error(guar),\n                     arg => bug!(\"unexpected bound var resolution for {hir_id:?}: {arg:?}\"),\n                 }\n             }\n@@ -2932,7 +2931,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     {\n                         err.span_note(impl_.self_ty.span, \"not a concrete type\");\n                     }\n-                    tcx.ty_error_with_guaranteed(err.emit())\n+                    tcx.ty_error(err.emit())\n                 } else {\n                     ty\n                 }\n@@ -2985,7 +2984,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .sess\n                     .delay_span_bug(path.span, \"path with `Res::Err` but no error emitted\");\n                 self.set_tainted_by_errors(e);\n-                self.tcx().ty_error_with_guaranteed(e)\n+                self.tcx().ty_error(e)\n             }\n             _ => span_bug!(span, \"unexpected resolution: {:?}\", path.res),\n         }\n@@ -3064,7 +3063,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let ty = self.ast_ty_to_ty_inner(qself, false, true);\n                 self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, qself, segment, false)\n                     .map(|(ty, _, _)| ty)\n-                    .unwrap_or_else(|_| tcx.ty_error())\n+                    .unwrap_or_else(|guar| tcx.ty_error(guar))\n             }\n             &hir::TyKind::Path(hir::QPath::LangItem(lang_item, span, _)) => {\n                 let def_id = tcx.require_lang_item(lang_item, Some(span));\n@@ -3112,7 +3111,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(None, ast_ty.span)\n             }\n-            hir::TyKind::Err => tcx.ty_error(),\n+            hir::TyKind::Err => tcx.ty_error_misc(),\n         };\n \n         self.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);"}, {"sha": "bdc9ff5cada9af2723f7ab1114d8a0cb3161c445", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -790,7 +790,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n                     return_span,\n                     format!(\"could not fully resolve: {ty} => {err:?}\"),\n                 );\n-                collected_tys.insert(def_id, tcx.ty_error_with_guaranteed(reported));\n+                collected_tys.insert(def_id, tcx.ty_error(reported));\n             }\n         }\n     }"}, {"sha": "a2900037797c685e62d4d30970daa4c4181f0196", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -499,7 +499,7 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                 }\n                 _ => {}\n             }\n-            self.tcx().ty_error_with_guaranteed(err.emit())\n+            self.tcx().ty_error(err.emit())\n         }\n     }\n "}, {"sha": "50073d94ea5c975a3fe84372c950f73cd369bf0c", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -319,8 +319,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                 ItemKind::Impl(hir::Impl { self_ty, .. }) => {\n                     match self_ty.find_self_aliases() {\n                         spans if spans.len() > 0 => {\n-                            tcx.sess.emit_err(crate::errors::SelfInImplSelf { span: spans.into(), note: (), });\n-                            tcx.ty_error()\n+                            let guar = tcx.sess.emit_err(crate::errors::SelfInImplSelf { span: spans.into(), note: () });\n+                            tcx.ty_error(guar)\n                         },\n                         _ => icx.to_ty(*self_ty),\n                     }\n@@ -599,8 +599,9 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n             // // constant does not contain interior mutability.\n             // ```\n             let tables = self.tcx.typeck(item_def_id);\n-            if let Some(_) = tables.tainted_by_errors {\n-                self.found = Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error() });\n+            if let Some(guar) = tables.tainted_by_errors {\n+                self.found =\n+                    Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error(guar) });\n                 return;\n             }\n             let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n@@ -618,8 +619,8 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n                 debug!(?concrete_type, \"found constraint\");\n                 if let Some(prev) = &mut self.found {\n                     if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n-                        prev.report_mismatch(&concrete_type, self.tcx);\n-                        prev.ty = self.tcx.ty_error();\n+                        let guar = prev.report_mismatch(&concrete_type, self.tcx);\n+                        prev.ty = self.tcx.ty_error(guar);\n                     }\n                 } else {\n                     self.found = Some(concrete_type);\n@@ -706,7 +707,7 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n                 _ => \"item\",\n             },\n         });\n-        return tcx.ty_error_with_guaranteed(reported);\n+        return tcx.ty_error(reported);\n     };\n \n     // Only check against typeck if we didn't already error\n@@ -814,11 +815,11 @@ fn find_opaque_ty_constraints_for_rpit(\n \n     concrete.map(|concrete| concrete.ty).unwrap_or_else(|| {\n         let table = tcx.typeck(owner_def_id);\n-        if let Some(_) = table.tainted_by_errors {\n+        if let Some(guar) = table.tainted_by_errors {\n             // Some error in the\n             // owner fn prevented us from populating\n             // the `concrete_opaque_types` table.\n-            tcx.ty_error()\n+            tcx.ty_error(guar)\n         } else {\n             table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n                 // We failed to resolve the opaque type or it"}, {"sha": "fe2f6319c1ad359ba0265ab73bc8a4bfa1440ea2", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -438,7 +438,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let err = self.report_invalid_callee(call_expr, callee_expr, callee_ty, arg_exprs);\n \n-                return self.tcx.ty_error_with_guaranteed(err);\n+                return self.tcx.ty_error(err);\n             }\n         };\n "}, {"sha": "6c7004283233ac5e43c8432662f99fb7eac8b81f", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -3,6 +3,7 @@\n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use hir::def::DefKind;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir_analysis::astconv::AstConv;\n@@ -488,17 +489,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n         let expected_span =\n             expected_sig.cause_span.unwrap_or_else(|| self.tcx.def_span(expr_def_id));\n-        self.report_arg_count_mismatch(\n-            expected_span,\n-            closure_span,\n-            expected_args,\n-            found_args,\n-            true,\n-            closure_arg_span,\n-        )\n-        .emit();\n-\n-        let error_sig = self.error_sig_of_closure(decl);\n+        let guar = self\n+            .report_arg_count_mismatch(\n+                expected_span,\n+                closure_span,\n+                expected_args,\n+                found_args,\n+                true,\n+                closure_arg_span,\n+            )\n+            .emit();\n+\n+        let error_sig = self.error_sig_of_closure(decl, guar);\n \n         self.closure_sigs(expr_def_id, body, error_sig)\n     }\n@@ -792,13 +794,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Converts the types that the user supplied, in case that doing\n     /// so should yield an error, but returns back a signature where\n     /// all parameters are of type `TyErr`.\n-    fn error_sig_of_closure(&self, decl: &hir::FnDecl<'_>) -> ty::PolyFnSig<'tcx> {\n+    fn error_sig_of_closure(\n+        &self,\n+        decl: &hir::FnDecl<'_>,\n+        guar: ErrorGuaranteed,\n+    ) -> ty::PolyFnSig<'tcx> {\n         let astconv: &dyn AstConv<'_> = self;\n+        let err_ty = self.tcx.ty_error(guar);\n \n         let supplied_arguments = decl.inputs.iter().map(|a| {\n             // Convert the types that the user supplied (if any), but ignore them.\n             astconv.ast_ty_to_ty(a);\n-            self.tcx.ty_error()\n+            err_ty\n         });\n \n         if let hir::FnRetTy::Return(ref output) = decl.output {\n@@ -807,7 +814,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let result = ty::Binder::dummy(self.tcx.mk_fn_sig(\n             supplied_arguments,\n-            self.tcx.ty_error(),\n+            err_ty,\n             decl.c_variadic,\n             hir::Unsafety::Normal,\n             Abi::RustCall,"}, {"sha": "00b86890b33f4ec54e2449444b69ccb58e8caaf6", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -170,14 +170,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n \n         // Just ignore error types.\n-        if a.references_error() || b.references_error() {\n+        if let Err(guar) = (a, b).error_reported() {\n             // Best-effort try to unify these types -- we're already on the error path,\n             // so this will have the side-effect of making sure we have no ambiguities\n             // due to `[type error]` and `_` not coercing together.\n             let _ = self.commit_if_ok(|_| {\n                 self.at(&self.cause, self.param_env).define_opaque_types(true).eq(a, b)\n             });\n-            return success(vec![], self.fcx.tcx.ty_error(), vec![]);\n+            return success(vec![], self.fcx.tcx.ty_error(guar), vec![]);\n         }\n \n         // Coercing from `!` to any type is allowed:\n@@ -997,7 +997,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (adjustments, _) = self.register_infer_ok_obligations(ok);\n         self.apply_adjustments(expr, adjustments);\n-        Ok(if expr_ty.references_error() { self.tcx.ty_error() } else { target })\n+        Ok(if let Err(guar) = expr_ty.error_reported() { self.tcx.ty_error(guar) } else { target })\n     }\n \n     /// Same as `try_coerce()`, but without side-effects.\n@@ -1434,8 +1434,8 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n         // If we see any error types, just propagate that error\n         // upwards.\n-        if expression_ty.references_error() || self.merged_ty().references_error() {\n-            self.final_ty = Some(fcx.tcx.ty_error());\n+        if let Err(guar) = (expression_ty, self.merged_ty()).error_reported() {\n+            self.final_ty = Some(fcx.tcx.ty_error(guar));\n             return;\n         }\n \n@@ -1620,7 +1620,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n                 let reported = err.emit_unless(unsized_return);\n \n-                self.final_ty = Some(fcx.tcx.ty_error_with_guaranteed(reported));\n+                self.final_ty = Some(fcx.tcx.ty_error(reported));\n             }\n         }\n     }"}, {"sha": "6d54f6948c8ca61f707fa17bba5fc12980e45c9e", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 65, "deletions": 50, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return if let [Adjustment { kind: Adjust::NeverToAny, target }] = &adjustments[..] {\n                     target.to_owned()\n                 } else {\n-                    self.tcx().ty_error_with_guaranteed(reported)\n+                    self.tcx().ty_error(reported)\n                 };\n             }\n \n@@ -313,7 +313,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     tcx.types.never\n                 } else {\n                     // There was an error; make type-check fail.\n-                    tcx.ty_error()\n+                    tcx.ty_error_misc()\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => self.check_expr_return(expr_opt.as_deref(), expr),\n@@ -354,7 +354,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Field(base, field) => self.check_field(expr, &base, field, expected),\n             ExprKind::Index(base, idx) => self.check_expr_index(base, idx, expr),\n             ExprKind::Yield(value, ref src) => self.check_expr_yield(value, expr, src),\n-            hir::ExprKind::Err => tcx.ty_error(),\n+            hir::ExprKind::Err => tcx.ty_error_misc(),\n         }\n     }\n \n@@ -402,7 +402,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         {\n                             err.subdiagnostic(ExprParenthesesNeeded::surrounding(*sp));\n                         }\n-                        oprnd_t = tcx.ty_error_with_guaranteed(err.emit());\n+                        oprnd_t = tcx.ty_error(err.emit());\n                     }\n                 }\n                 hir::UnOp::Not => {\n@@ -452,7 +452,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let tm = ty::TypeAndMut { ty, mutbl };\n         match kind {\n-            _ if tm.ty.references_error() => self.tcx.ty_error(),\n+            _ if tm.ty.references_error() => self.tcx.ty_error_misc(),\n             hir::BorrowKind::Raw => {\n                 self.check_named_place_expr(oprnd);\n                 self.tcx.mk_ptr(tm)\n@@ -531,11 +531,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let e =\n                     self.tcx.sess.delay_span_bug(qpath.span(), \"`Res::Err` but no error emitted\");\n                 self.set_tainted_by_errors(e);\n-                tcx.ty_error_with_guaranteed(e)\n+                tcx.ty_error(e)\n             }\n             Res::Def(DefKind::Variant, _) => {\n                 let e = report_unexpected_variant_res(tcx, res, qpath, expr.span, \"E0533\", \"value\");\n-                tcx.ty_error_with_guaranteed(e)\n+                tcx.ty_error(e)\n             }\n             _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, expr.hir_id).0,\n         };\n@@ -634,7 +634,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // If the loop context is not a `loop { }`, then break with\n                 // a value is illegal, and `opt_coerce_to` will be `None`.\n                 // Just set expectation to error in that case.\n-                let coerce_to = opt_coerce_to.unwrap_or_else(|| tcx.ty_error());\n+                let coerce_to = opt_coerce_to.unwrap_or_else(|| tcx.ty_error_misc());\n \n                 // Recurse without `enclosing_breakables` borrowed.\n                 e_ty = self.check_expr_with_hint(e, coerce_to);\n@@ -1033,7 +1033,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         let result_ty = coerce.complete(self);\n-        if cond_ty.references_error() { self.tcx.ty_error() } else { result_ty }\n+        if let Err(guar) = cond_ty.error_reported() { self.tcx.ty_error(guar) } else { result_ty }\n     }\n \n     /// Type check assignment expression `expr` of form `lhs = rhs`.\n@@ -1109,7 +1109,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // If the assignment expression itself is ill-formed, don't\n             // bother emitting another error\n             let reported = err.emit_unless(lhs_ty.references_error() || rhs_ty.references_error());\n-            return self.tcx.ty_error_with_guaranteed(reported);\n+            return self.tcx.ty_error(reported);\n         }\n \n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n@@ -1155,8 +1155,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n \n-        if lhs_ty.references_error() || rhs_ty.references_error() {\n-            self.tcx.ty_error()\n+        if let Err(guar) = (lhs_ty, rhs_ty).error_reported() {\n+            self.tcx.ty_error(guar)\n         } else {\n             self.tcx.mk_unit()\n         }\n@@ -1274,8 +1274,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let t_expr = self.resolve_vars_if_possible(t_expr);\n \n         // Eagerly check for some obvious errors.\n-        if t_expr.references_error() || t_cast.references_error() {\n-            self.tcx.ty_error()\n+        if let Err(guar) = (t_expr, t_cast).error_reported() {\n+            self.tcx.ty_error(guar)\n         } else {\n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n@@ -1296,7 +1296,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     deferred_cast_checks.push(cast_check);\n                     t_cast\n                 }\n-                Err(_) => self.tcx.ty_error(),\n+                Err(guar) => self.tcx.ty_error(guar),\n             }\n         }\n     }\n@@ -1423,8 +1423,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n-        if element_ty.references_error() {\n-            return tcx.ty_error();\n+        if let Err(guar) = element_ty.error_reported() {\n+            return tcx.ty_error(guar);\n         }\n \n         self.check_repeat_element_needs_copy_bound(element, count, element_ty);\n@@ -1493,8 +1493,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => self.check_expr_with_expectation(&e, NoExpectation),\n         });\n         let tuple = self.tcx.mk_tup(elt_ts_iter);\n-        if tuple.references_error() {\n-            self.tcx.ty_error()\n+        if let Err(guar) = tuple.error_reported() {\n+            self.tcx.ty_error(guar)\n         } else {\n             self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n             tuple\n@@ -1510,9 +1510,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base_expr: &'tcx Option<&'tcx hir::Expr<'tcx>>,\n     ) -> Ty<'tcx> {\n         // Find the relevant variant\n-        let Some((variant, adt_ty)) = self.check_struct_path(qpath, expr.hir_id) else {\n-            self.check_struct_fields_on_error(fields, base_expr);\n-            return self.tcx.ty_error();\n+        let (variant, adt_ty) = match self.check_struct_path(qpath, expr.hir_id) {\n+            Ok(data) => data,\n+            Err(guar) => {\n+                self.check_struct_fields_on_error(fields, base_expr);\n+                return self.tcx.ty_error(guar);\n+            }\n         };\n \n         // Prohibit struct expressions when non-exhaustive flag is set.\n@@ -1594,12 +1597,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.field_ty(field.span, v_field, substs)\n             } else {\n                 error_happened = true;\n-                if let Some(prev_span) = seen_fields.get(&ident) {\n+                let guar = if let Some(prev_span) = seen_fields.get(&ident) {\n                     tcx.sess.emit_err(FieldMultiplySpecifiedInInitializer {\n                         span: field.ident.span,\n                         prev_span: *prev_span,\n                         ident,\n-                    });\n+                    })\n                 } else {\n                     self.report_unknown_field(\n                         adt_ty,\n@@ -1608,10 +1611,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ast_fields,\n                         adt.variant_descr(),\n                         expr_span,\n-                    );\n-                }\n+                    )\n+                };\n \n-                tcx.ty_error()\n+                tcx.ty_error(guar)\n             };\n \n             // Make sure to give a type to the field even if there's\n@@ -1994,14 +1997,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         skip_fields: &[hir::ExprField<'_>],\n         kind_name: &str,\n         expr_span: Span,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         if variant.is_recovered() {\n-            self.set_tainted_by_errors(\n-                self.tcx\n-                    .sess\n-                    .delay_span_bug(expr_span, \"parser recovered but no error was emitted\"),\n-            );\n-            return;\n+            let guar = self\n+                .tcx\n+                .sess\n+                .delay_span_bug(expr_span, \"parser recovered but no error was emitted\");\n+            self.set_tainted_by_errors(guar);\n+            return guar;\n         }\n         let mut err = self.err_ctxt().type_error_struct_with_diag(\n             field.ident.span,\n@@ -2115,7 +2118,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n             }\n         }\n-        err.emit();\n+        err.emit()\n     }\n \n     // Return a hint about the closest match in field names\n@@ -2256,21 +2259,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // (#90483) apply adjustments to avoid ExprUseVisitor from\n             // creating erroneous projection.\n             self.apply_adjustments(base, adjustments);\n-            self.ban_private_field_access(expr, base_ty, field, did, expected.only_has_type(self));\n-            return self.tcx().ty_error();\n+            let guar = self.ban_private_field_access(\n+                expr,\n+                base_ty,\n+                field,\n+                did,\n+                expected.only_has_type(self),\n+            );\n+            return self.tcx().ty_error(guar);\n         }\n \n-        if field.name == kw::Empty {\n+        let guar = if field.name == kw::Empty {\n+            self.tcx.sess.delay_span_bug(field.span, \"field name with no name\")\n         } else if self.method_exists(\n             field,\n             base_ty,\n             expr.hir_id,\n             true,\n             expected.only_has_type(self),\n         ) {\n-            self.ban_take_value_of_method(expr, base_ty, field);\n+            self.ban_take_value_of_method(expr, base_ty, field)\n         } else if !base_ty.is_primitive_ty() {\n-            self.ban_nonexisting_field(field, base, expr, base_ty);\n+            self.ban_nonexisting_field(field, base, expr, base_ty)\n         } else {\n             let field_name = field.to_string();\n             let mut err = type_error_struct!(\n@@ -2339,10 +2349,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 }\n             }\n-            err.emit();\n-        }\n+            err.emit()\n+        };\n \n-        self.tcx().ty_error()\n+        self.tcx().ty_error(guar)\n     }\n \n     fn suggest_await_on_field_access(\n@@ -2388,7 +2398,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base: &'tcx hir::Expr<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n         base_ty: Ty<'tcx>,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         debug!(\n             \"ban_nonexisting_field: field={:?}, base={:?}, expr={:?}, base_ty={:?}\",\n             ident, base, expr, base_ty\n@@ -2436,7 +2446,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             HelpUseLatestEdition::new().add_to_diagnostic(&mut err);\n         }\n \n-        err.emit();\n+        err.emit()\n     }\n \n     fn ban_private_field_access(\n@@ -2446,7 +2456,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: Ident,\n         base_did: DefId,\n         return_ty: Option<Ty<'tcx>>,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         let struct_path = self.tcx().def_path_str(base_did);\n         let kind_name = self.tcx().def_descr(base_did);\n         let mut err = struct_span_err!(\n@@ -2469,10 +2479,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 None,\n             );\n         }\n-        err.emit();\n+        err.emit()\n     }\n \n-    fn ban_take_value_of_method(&self, expr: &hir::Expr<'tcx>, expr_t: Ty<'tcx>, field: Ident) {\n+    fn ban_take_value_of_method(\n+        &self,\n+        expr: &hir::Expr<'tcx>,\n+        expr_t: Ty<'tcx>,\n+        field: Ident,\n+    ) -> ErrorGuaranteed {\n         let mut err = type_error_struct!(\n             self.tcx().sess,\n             field.span,\n@@ -2544,7 +2559,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.help(\"methods are immutable and cannot be assigned to\");\n         }\n \n-        err.emit();\n+        err.emit()\n     }\n \n     fn point_at_param_definition(&self, err: &mut Diagnostic, param: ty::ParamTy) {\n@@ -2829,7 +2844,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     let reported = err.emit();\n-                    self.tcx.ty_error_with_guaranteed(reported)\n+                    self.tcx.ty_error(reported)\n                 }\n             }\n         }"}, {"sha": "b7ae621c6859f390524b2480ad03e3155bad0502", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -104,7 +104,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // type, `?T` is not considered unsolved, but `?I` is. The\n         // same is true for float variables.)\n         let fallback = match ty.kind() {\n-            _ if let Some(e) = self.tainted_by_errors() => self.tcx.ty_error_with_guaranteed(e),\n+            _ if let Some(e) = self.tainted_by_errors() => self.tcx.ty_error(e),\n             ty::Infer(ty::IntVar(_)) => self.tcx.types.i32,\n             ty::Infer(ty::FloatVar(_)) => self.tcx.types.f64,\n             _ => match diverging_fallback.get(&ty) {"}, {"sha": "60e55c7b0cf57cc25dd1cb467b03bd1c5e2aebd1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -451,7 +451,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n         match self.typeck_results.borrow().node_types().get(id) {\n             Some(&t) => t,\n-            None if let Some(e) = self.tainted_by_errors() => self.tcx.ty_error_with_guaranteed(e),\n+            None if let Some(e) = self.tainted_by_errors() => self.tcx.ty_error(e),\n             None => {\n                 bug!(\n                     \"no type for node {} in fcx {}\",\n@@ -465,7 +465,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn node_ty_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n         match self.typeck_results.borrow().node_types().get(id) {\n             Some(&t) => Some(t),\n-            None if let Some(e) = self.tainted_by_errors() => Some(self.tcx.ty_error_with_guaranteed(e)),\n+            None if let Some(e) = self.tainted_by_errors() => Some(self.tcx.ty_error(e)),\n             None => None,\n         }\n     }\n@@ -701,7 +701,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub(in super::super) fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {\n-        vec![self.tcx.ty_error(); len]\n+        let ty_error = self.tcx.ty_error_misc();\n+        vec![ty_error; len]\n     }\n \n     /// Unifies the output type with the expected type early, for more coercions\n@@ -1161,7 +1162,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     let reported = err.emit();\n-                    return (tcx.ty_error_with_guaranteed(reported), res);\n+                    return (tcx.ty_error(reported), res);\n                 }\n             }\n         } else {\n@@ -1417,7 +1418,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282, true)\n                     .emit()\n             });\n-            let err = self.tcx.ty_error_with_guaranteed(e);\n+            let err = self.tcx.ty_error(e);\n             self.demand_suptype(sp, err, ty);\n             err\n         }"}, {"sha": "99339153de2d633461088e3c673eea8667c99d2f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -10,7 +10,9 @@ use crate::{\n };\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::{pluralize, Applicability, Diagnostic, DiagnosticId, MultiSpan};\n+use rustc_errors::{\n+    pluralize, Applicability, Diagnostic, DiagnosticId, ErrorGuaranteed, MultiSpan,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -72,7 +74,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let ty = self.typeck_results.borrow().expr_ty_adjusted(expr);\n                 let ty = self.resolve_vars_if_possible(ty);\n                 if ty.has_non_region_infer() {\n-                    self.tcx.ty_error()\n+                    self.tcx.ty_error_misc()\n                 } else {\n                     self.tcx.erase_regions(ty)\n                 }\n@@ -113,7 +115,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 tuple_arguments,\n                 method.ok().map(|method| method.def_id),\n             );\n-            return self.tcx.ty_error();\n+            return self.tcx.ty_error_misc();\n         }\n \n         let method = method.unwrap();\n@@ -533,7 +535,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .typeck_results\n                     .borrow()\n                     .expr_ty_adjusted_opt(*expr)\n-                    .unwrap_or_else(|| tcx.ty_error());\n+                    .unwrap_or_else(|| tcx.ty_error_misc());\n                 (self.resolve_vars_if_possible(ty), normalize_span(expr.span))\n             })\n             .collect();\n@@ -1286,23 +1288,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 opt_ty.unwrap_or_else(|| self.next_float_var())\n             }\n             ast::LitKind::Bool(_) => tcx.types.bool,\n-            ast::LitKind::Err => tcx.ty_error(),\n+            ast::LitKind::Err => tcx.ty_error_misc(),\n         }\n     }\n \n     pub fn check_struct_path(\n         &self,\n         qpath: &QPath<'_>,\n         hir_id: hir::HirId,\n-    ) -> Option<(&'tcx ty::VariantDef, Ty<'tcx>)> {\n+    ) -> Result<(&'tcx ty::VariantDef, Ty<'tcx>), ErrorGuaranteed> {\n         let path_span = qpath.span();\n         let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, hir_id);\n         let variant = match def {\n             Res::Err => {\n-                self.set_tainted_by_errors(\n-                    self.tcx.sess.delay_span_bug(path_span, \"`Res::Err` but no error emitted\"),\n-                );\n-                return None;\n+                let guar =\n+                    self.tcx.sess.delay_span_bug(path_span, \"`Res::Err` but no error emitted\");\n+                self.set_tainted_by_errors(guar);\n+                return Err(guar);\n             }\n             Res::Def(DefKind::Variant, _) => match ty.normalized.ty_adt_def() {\n                 Some(adt) => {\n@@ -1330,28 +1332,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Check bounds on type arguments used in the path.\n             self.add_required_obligations_for_hir(path_span, did, substs, hir_id);\n \n-            Some((variant, ty.normalized))\n+            Ok((variant, ty.normalized))\n         } else {\n-            match ty.normalized.kind() {\n-                ty::Error(_) => {\n+            Err(match *ty.normalized.kind() {\n+                ty::Error(guar) => {\n                     // E0071 might be caused by a spelling error, which will have\n                     // already caused an error message and probably a suggestion\n                     // elsewhere. Refrain from emitting more unhelpful errors here\n                     // (issue #88844).\n+                    guar\n                 }\n-                _ => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        path_span,\n-                        E0071,\n-                        \"expected struct, variant or union type, found {}\",\n-                        ty.normalized.sort_string(self.tcx)\n-                    )\n-                    .span_label(path_span, \"not a struct\")\n-                    .emit();\n-                }\n-            }\n-            None\n+                _ => struct_span_err!(\n+                    self.tcx.sess,\n+                    path_span,\n+                    E0071,\n+                    \"expected struct, variant or union type, found {}\",\n+                    ty.normalized.sort_string(self.tcx)\n+                )\n+                .span_label(path_span, \"not a struct\")\n+                .emit(),\n+            })\n         }\n     }\n \n@@ -1715,9 +1715,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat: &'tcx hir::Pat<'tcx>,\n         ty: Ty<'tcx>,\n     ) {\n-        if ty.references_error() {\n+        if let Err(guar) = ty.error_reported() {\n             // Override the types everywhere with `err()` to avoid knock on errors.\n-            let err = self.tcx.ty_error();\n+            let err = self.tcx.ty_error(guar);\n             self.write_ty(hir_id, err);\n             self.write_ty(pat.hir_id, err);\n             let local_ty = LocalTy { decl_ty: err, revealed_ty: err };\n@@ -1746,7 +1746,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let result = self\n                     .astconv()\n                     .associated_path_to_ty(hir_id, path_span, ty.raw, qself, segment, true);\n-                let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n+                let ty =\n+                    result.map(|(ty, _, _)| ty).unwrap_or_else(|guar| self.tcx().ty_error(guar));\n                 let ty = self.handle_raw_ty(path_span, ty);\n                 let result = result.map(|(_, kind, def_id)| (kind, def_id));\n "}, {"sha": "a4b325a9b798435b7ca54e6201b108da7a5263c0", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -297,7 +297,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 method.sig.output()\n             }\n             // error types are considered \"builtin\"\n-            Err(_) if lhs_ty.references_error() || rhs_ty.references_error() => self.tcx.ty_error(),\n+            Err(_) if lhs_ty.references_error() || rhs_ty.references_error() => {\n+                self.tcx.ty_error_misc()\n+            }\n             Err(errors) => {\n                 let (_, trait_def_id) =\n                     lang_item_for_op(self.tcx, Op::Binary(op, is_assign), op.span);\n@@ -518,7 +520,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n                 let reported = err.emit();\n-                self.tcx.ty_error_with_guaranteed(reported)\n+                self.tcx.ty_error(reported)\n             }\n         };\n \n@@ -631,7 +633,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             Err(errors) => {\n                 let actual = self.resolve_vars_if_possible(operand_ty);\n-                if !actual.references_error() {\n+                let guar = actual.error_reported().err().unwrap_or_else(|| {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,\n                         ex.span,\n@@ -701,9 +703,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    err.emit();\n-                }\n-                self.tcx.ty_error()\n+                    err.emit()\n+                });\n+                self.tcx.ty_error(guar)\n             }\n         }\n     }"}, {"sha": "9d95866fca4ab2d1c750be9e03eb86d11173d992", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 141, "deletions": 107, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -475,8 +475,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let (Some((true, ..)), _) | (_, Some((true, ..))) = (lhs, rhs) {\n             // There exists a side that didn't meet our criteria that the end-point\n             // be of a numeric or char type, as checked in `calc_side` above.\n-            self.emit_err_pat_range(span, lhs, rhs);\n-            return self.tcx.ty_error();\n+            let guar = self.emit_err_pat_range(span, lhs, rhs);\n+            return self.tcx.ty_error(guar);\n         }\n \n         // Unify each side with `expected`.\n@@ -496,7 +496,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         demand_eqtype(&mut rhs, lhs);\n \n         if let (Some((true, ..)), _) | (_, Some((true, ..))) = (lhs, rhs) {\n-            return self.tcx.ty_error();\n+            return self.tcx.ty_error_misc();\n         }\n \n         // Find the unified type and check if it's of numeric or char type again.\n@@ -511,8 +511,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let Some((ref mut fail, _, _)) = rhs {\n                 *fail = true;\n             }\n-            self.emit_err_pat_range(span, lhs, rhs);\n-            return self.tcx.ty_error();\n+            let guar = self.emit_err_pat_range(span, lhs, rhs);\n+            return self.tcx.ty_error(guar);\n         }\n         ty\n     }\n@@ -528,7 +528,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         lhs: Option<(bool, Ty<'tcx>, Span)>,\n         rhs: Option<(bool, Ty<'tcx>, Span)>,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         let span = match (lhs, rhs) {\n             (Some((true, ..)), Some((true, ..))) => span,\n             (Some((true, _, sp)), _) => sp,\n@@ -573,7 +573,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     type between two end-points, you can use a guard.\",\n             );\n         }\n-        err.emit();\n+        err.emit()\n     }\n \n     fn check_pat_ident(\n@@ -807,29 +807,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn check_dereferenceable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat<'_>) -> bool {\n+    pub fn check_dereferenceable(\n+        &self,\n+        span: Span,\n+        expected: Ty<'tcx>,\n+        inner: &Pat<'_>,\n+    ) -> Result<(), ErrorGuaranteed> {\n         if let PatKind::Binding(..) = inner.kind\n             && let Some(mt) = self.shallow_resolve(expected).builtin_deref(true)\n             && let ty::Dynamic(..) = mt.ty.kind()\n         {\n-                    // This is \"x = SomeTrait\" being reduced from\n-                    // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n-                    let type_str = self.ty_to_string(expected);\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0033,\n-                        \"type `{}` cannot be dereferenced\",\n-                        type_str\n-                    );\n-                    err.span_label(span, format!(\"type `{type_str}` cannot be dereferenced\"));\n-                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(CANNOT_IMPLICITLY_DEREF_POINTER_TRAIT_OBJ);\n-                    }\n-                    err.emit();\n-                    return false;\n-                }\n-        true\n+            // This is \"x = SomeTrait\" being reduced from\n+            // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n+            let type_str = self.ty_to_string(expected);\n+            let mut err = struct_span_err!(\n+                self.tcx.sess,\n+                span,\n+                E0033,\n+                \"type `{}` cannot be dereferenced\",\n+                type_str\n+            );\n+            err.span_label(span, format!(\"type `{type_str}` cannot be dereferenced\"));\n+            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                err.note(CANNOT_IMPLICITLY_DEREF_POINTER_TRAIT_OBJ);\n+            }\n+            return Err(err.emit());\n+        }\n+        Ok(())\n     }\n \n     fn check_pat_struct(\n@@ -843,13 +847,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         // Resolve the path and check the definition for errors.\n-        let Some((variant, pat_ty)) = self.check_struct_path(qpath, pat.hir_id) else {\n-            let err = self.tcx.ty_error();\n-            for field in fields {\n-                let ti = ti;\n-                self.check_pat(field.pat, err, def_bm, ti);\n+        let (variant, pat_ty) = match self.check_struct_path(qpath, pat.hir_id) {\n+            Ok(data) => data,\n+            Err(guar) => {\n+                let err = self.tcx.ty_error(guar);\n+                for field in fields {\n+                    let ti = ti;\n+                    self.check_pat(field.pat, err, def_bm, ti);\n+                }\n+                return err;\n             }\n-            return err;\n         };\n \n         // Type-check the path.\n@@ -859,7 +866,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if self.check_struct_pat_fields(pat_ty, &pat, variant, fields, has_rest_pat, def_bm, ti) {\n             pat_ty\n         } else {\n-            self.tcx.ty_error()\n+            self.tcx.ty_error_misc()\n         }\n     }\n \n@@ -879,12 +886,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Res::Err => {\n                 let e = tcx.sess.delay_span_bug(qpath.span(), \"`Res::Err` but no error emitted\");\n                 self.set_tainted_by_errors(e);\n-                return tcx.ty_error_with_guaranteed(e);\n+                return tcx.ty_error(e);\n             }\n             Res::Def(DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::Variant, _) => {\n                 let expected = \"unit struct, unit variant or constant\";\n                 let e = report_unexpected_variant_res(tcx, res, qpath, pat.span, \"E0533\", expected);\n-                return tcx.ty_error_with_guaranteed(e);\n+                return tcx.ty_error(e);\n             }\n             Res::SelfCtor(..)\n             | Res::Def(\n@@ -1027,7 +1034,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         let on_error = |e| {\n             for pat in subpats {\n-                self.check_pat(pat, tcx.ty_error_with_guaranteed(e), def_bm, ti);\n+                self.check_pat(pat, tcx.ty_error(e), def_bm, ti);\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -1044,27 +1051,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let e = tcx.sess.delay_span_bug(pat.span, \"`Res::Err` but no error emitted\");\n             self.set_tainted_by_errors(e);\n             on_error(e);\n-            return tcx.ty_error_with_guaranteed(e);\n+            return tcx.ty_error(e);\n         }\n \n         // Type-check the path.\n         let (pat_ty, res) =\n             self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id);\n         if !pat_ty.is_fn() {\n             let e = report_unexpected_res(res);\n-            return tcx.ty_error_with_guaranteed(e);\n+            return tcx.ty_error(e);\n         }\n \n         let variant = match res {\n             Res::Err => {\n                 let e = tcx.sess.delay_span_bug(pat.span, \"`Res::Err` but no error emitted\");\n                 self.set_tainted_by_errors(e);\n                 on_error(e);\n-                return tcx.ty_error_with_guaranteed(e);\n+                return tcx.ty_error(e);\n             }\n             Res::Def(DefKind::AssocConst | DefKind::AssocFn, _) => {\n                 let e = report_unexpected_res(res);\n-                return tcx.ty_error_with_guaranteed(e);\n+                return tcx.ty_error(e);\n             }\n             Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => tcx.expect_variant_res(res),\n             _ => bug!(\"unexpected pattern resolution: {:?}\", res),\n@@ -1105,7 +1112,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Pattern has wrong number of fields.\n             let e = self.e0023(pat.span, res, qpath, subpats, &variant.fields, expected, had_err);\n             on_error(e);\n-            return tcx.ty_error_with_guaranteed(e);\n+            return tcx.ty_error(e);\n         }\n         pat_ty\n     }\n@@ -1301,9 +1308,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let reported = err.emit();\n             // Walk subpatterns with an expected type of `err` in this case to silence\n             // further errors being emitted when using the bindings. #50333\n-            let element_tys_iter = (0..max_len).map(|_| tcx.ty_error_with_guaranteed(reported));\n+            let element_tys_iter = (0..max_len).map(|_| tcx.ty_error(reported));\n             for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, tcx.ty_error_with_guaranteed(reported), def_bm, ti);\n+                self.check_pat(elem, tcx.ty_error(reported), def_bm, ti);\n             }\n             tcx.mk_tup(element_tys_iter)\n         } else {\n@@ -1349,9 +1356,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let ident = tcx.adjust_ident(field.ident, variant.def_id);\n             let field_ty = match used_fields.entry(ident) {\n                 Occupied(occupied) => {\n-                    self.error_field_already_bound(span, field.ident, *occupied.get());\n                     no_field_errors = false;\n-                    tcx.ty_error()\n+                    let guar = self.error_field_already_bound(span, field.ident, *occupied.get());\n+                    tcx.ty_error(guar)\n                 }\n                 Vacant(vacant) => {\n                     vacant.insert(span);\n@@ -1365,7 +1372,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .unwrap_or_else(|| {\n                             inexistent_fields.push(field);\n                             no_field_errors = false;\n-                            tcx.ty_error()\n+                            tcx.ty_error_misc()\n                         })\n                 }\n             };\n@@ -1536,7 +1543,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn error_field_already_bound(&self, span: Span, ident: Ident, other_field: Span) {\n+    fn error_field_already_bound(\n+        &self,\n+        span: Span,\n+        ident: Ident,\n+        other_field: Span,\n+    ) -> ErrorGuaranteed {\n         struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -1546,7 +1558,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n         .span_label(span, format!(\"multiple uses of `{ident}` in pattern\"))\n         .span_label(other_field, format!(\"first use of `{ident}`\"))\n-        .emit();\n+        .emit()\n     }\n \n     fn error_inexistent_fields(\n@@ -1919,19 +1931,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n-        let (box_ty, inner_ty) = if self.check_dereferenceable(span, expected, inner) {\n-            // Here, `demand::subtype` is good enough, but I don't\n-            // think any errors can be introduced by using `demand::eqtype`.\n-            let inner_ty = self.next_ty_var(TypeVariableOrigin {\n-                kind: TypeVariableOriginKind::TypeInference,\n-                span: inner.span,\n-            });\n-            let box_ty = tcx.mk_box(inner_ty);\n-            self.demand_eqtype_pat(span, expected, box_ty, ti);\n-            (box_ty, inner_ty)\n-        } else {\n-            let err = tcx.ty_error();\n-            (err, err)\n+        let (box_ty, inner_ty) = match self.check_dereferenceable(span, expected, inner) {\n+            Ok(()) => {\n+                // Here, `demand::subtype` is good enough, but I don't\n+                // think any errors can be introduced by using `demand::eqtype`.\n+                let inner_ty = self.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeInference,\n+                    span: inner.span,\n+                });\n+                let box_ty = tcx.mk_box(inner_ty);\n+                self.demand_eqtype_pat(span, expected, box_ty, ti);\n+                (box_ty, inner_ty)\n+            }\n+            Err(guar) => {\n+                let err = tcx.ty_error(guar);\n+                (err, err)\n+            }\n         };\n         self.check_pat(inner, inner_ty, def_bm, ti);\n         box_ty\n@@ -1949,37 +1964,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected = self.shallow_resolve(expected);\n-        let (ref_ty, inner_ty) = if self.check_dereferenceable(pat.span, expected, inner) {\n-            // `demand::subtype` would be good enough, but using `eqtype` turns\n-            // out to be equally general. See (note_1) for details.\n-\n-            // Take region, inner-type from expected type if we can,\n-            // to avoid creating needless variables. This also helps with\n-            // the bad interactions of the given hack detailed in (note_1).\n-            debug!(\"check_pat_ref: expected={:?}\", expected);\n-            match *expected.kind() {\n-                ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => (expected, r_ty),\n-                _ => {\n-                    let inner_ty = self.next_ty_var(TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeInference,\n-                        span: inner.span,\n-                    });\n-                    let ref_ty = self.new_ref_ty(pat.span, mutbl, inner_ty);\n-                    debug!(\"check_pat_ref: demanding {:?} = {:?}\", expected, ref_ty);\n-                    let err = self.demand_eqtype_pat_diag(pat.span, expected, ref_ty, ti);\n-\n-                    // Look for a case like `fn foo(&foo: u32)` and suggest\n-                    // `fn foo(foo: &u32)`\n-                    if let Some(mut err) = err {\n-                        self.borrow_pat_suggestion(&mut err, pat);\n-                        err.emit();\n+        let (ref_ty, inner_ty) = match self.check_dereferenceable(pat.span, expected, inner) {\n+            Ok(()) => {\n+                // `demand::subtype` would be good enough, but using `eqtype` turns\n+                // out to be equally general. See (note_1) for details.\n+\n+                // Take region, inner-type from expected type if we can,\n+                // to avoid creating needless variables. This also helps with\n+                // the bad interactions of the given hack detailed in (note_1).\n+                debug!(\"check_pat_ref: expected={:?}\", expected);\n+                match *expected.kind() {\n+                    ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => (expected, r_ty),\n+                    _ => {\n+                        let inner_ty = self.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeInference,\n+                            span: inner.span,\n+                        });\n+                        let ref_ty = self.new_ref_ty(pat.span, mutbl, inner_ty);\n+                        debug!(\"check_pat_ref: demanding {:?} = {:?}\", expected, ref_ty);\n+                        let err = self.demand_eqtype_pat_diag(pat.span, expected, ref_ty, ti);\n+\n+                        // Look for a case like `fn foo(&foo: u32)` and suggest\n+                        // `fn foo(foo: &u32)`\n+                        if let Some(mut err) = err {\n+                            self.borrow_pat_suggestion(&mut err, pat);\n+                            err.emit();\n+                        }\n+                        (ref_ty, inner_ty)\n                     }\n-                    (ref_ty, inner_ty)\n                 }\n             }\n-        } else {\n-            let err = tcx.ty_error();\n-            (err, err)\n+            Err(guar) => {\n+                let err = tcx.ty_error(guar);\n+                (err, err)\n+            }\n         };\n         self.check_pat(inner, inner_ty, def_bm, ti);\n         ref_ty\n@@ -2027,10 +2045,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Slice(element_ty) => (element_ty, Some(expected), expected),\n             // The expected type must be an array or slice, but was neither, so error.\n             _ => {\n-                if !expected.references_error() {\n-                    self.error_expected_array_or_slice(span, expected, ti);\n-                }\n-                let err = self.tcx.ty_error();\n+                let guar = expected\n+                    .error_reported()\n+                    .err()\n+                    .unwrap_or_else(|| self.error_expected_array_or_slice(span, expected, ti));\n+                let err = self.tcx.ty_error(guar);\n                 (err, Some(err), err)\n             }\n         };\n@@ -2063,7 +2082,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         len: ty::Const<'tcx>,\n         min_len: u64,\n     ) -> (Option<Ty<'tcx>>, Ty<'tcx>) {\n-        if let Some(len) = len.try_eval_target_usize(self.tcx, self.param_env) {\n+        let guar = if let Some(len) = len.try_eval_target_usize(self.tcx, self.param_env) {\n             // Now we know the length...\n             if slice.is_none() {\n                 // ...and since there is no variable-length pattern,\n@@ -2073,15 +2092,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     return (None, arr_ty);\n                 }\n \n-                self.error_scrutinee_inconsistent_length(span, min_len, len);\n+                self.error_scrutinee_inconsistent_length(span, min_len, len)\n             } else if let Some(pat_len) = len.checked_sub(min_len) {\n                 // The variable-length pattern was there,\n                 // so it has an array type with the remaining elements left as its size...\n                 return (Some(self.tcx.mk_array(element_ty, pat_len)), arr_ty);\n             } else {\n                 // ...however, in this case, there were no remaining elements.\n                 // That is, the slice pattern requires more than the array type offers.\n-                self.error_scrutinee_with_rest_inconsistent_length(span, min_len, len);\n+                self.error_scrutinee_with_rest_inconsistent_length(span, min_len, len)\n             }\n         } else if slice.is_none() {\n             // We have a pattern with a fixed length,\n@@ -2093,14 +2112,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We have a variable-length pattern and don't know the array length.\n             // This happens if we have e.g.,\n             // `let [a, b, ..] = arr` where `arr: [T; N]` where `const N: usize`.\n-            self.error_scrutinee_unfixed_length(span);\n-        }\n+            self.error_scrutinee_unfixed_length(span)\n+        };\n \n         // If we get here, we must have emitted an error.\n-        (Some(self.tcx.ty_error()), arr_ty)\n+        (Some(self.tcx.ty_error(guar)), arr_ty)\n     }\n \n-    fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {\n+    fn error_scrutinee_inconsistent_length(\n+        &self,\n+        span: Span,\n+        min_len: u64,\n+        size: u64,\n+    ) -> ErrorGuaranteed {\n         struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -2111,10 +2135,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             size,\n         )\n         .span_label(span, format!(\"expected {} element{}\", size, pluralize!(size)))\n-        .emit();\n+        .emit()\n     }\n \n-    fn error_scrutinee_with_rest_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {\n+    fn error_scrutinee_with_rest_inconsistent_length(\n+        &self,\n+        span: Span,\n+        min_len: u64,\n+        size: u64,\n+    ) -> ErrorGuaranteed {\n         struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -2128,20 +2157,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             span,\n             format!(\"pattern cannot match array of {} element{}\", size, pluralize!(size),),\n         )\n-        .emit();\n+        .emit()\n     }\n \n-    fn error_scrutinee_unfixed_length(&self, span: Span) {\n+    fn error_scrutinee_unfixed_length(&self, span: Span) -> ErrorGuaranteed {\n         struct_span_err!(\n             self.tcx.sess,\n             span,\n             E0730,\n             \"cannot pattern-match on an array without a fixed length\",\n         )\n-        .emit();\n+        .emit()\n     }\n \n-    fn error_expected_array_or_slice(&self, span: Span, expected_ty: Ty<'tcx>, ti: TopInfo<'tcx>) {\n+    fn error_expected_array_or_slice(\n+        &self,\n+        span: Span,\n+        expected_ty: Ty<'tcx>,\n+        ti: TopInfo<'tcx>,\n+    ) -> ErrorGuaranteed {\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -2185,7 +2219,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n         err.span_label(span, format!(\"pattern cannot match with input type `{expected_ty}`\"));\n-        err.emit();\n+        err.emit()\n     }\n \n     fn is_slice_or_array_or_vector(&self, ty: Ty<'tcx>) -> (bool, Ty<'tcx>) {"}, {"sha": "8fcec3363c0be13379ba0797e4e43d67bd3e30dd", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -91,10 +91,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             );\n         }\n         let reported = err.emit();\n-        Some((\n-            self.tcx.ty_error_with_guaranteed(reported),\n-            self.tcx.ty_error_with_guaranteed(reported),\n-        ))\n+        Some((self.tcx.ty_error(reported), self.tcx.ty_error(reported)))\n     }\n \n     /// To type-check `base_expr[index_expr]`, we progressively autoderef"}, {"sha": "00348f3afdc442a294cf0c7e508ed9cd282de0c4", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -797,7 +797,7 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Resolver<'cx, 'tcx> {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n                 let e = self.report_error(t);\n                 self.replaced_with_error = Some(e);\n-                self.interner().ty_error_with_guaranteed(e)\n+                self.interner().ty_error(e)\n             }\n         }\n     }"}, {"sha": "3e8c2052de89d7135790f2b4b936222d035137a1", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -126,7 +126,7 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n \n             (&ty::Error(e), _) | (_, &ty::Error(e)) => {\n                 infcx.set_tainted_by_errors(e);\n-                Ok(self.tcx().ty_error_with_guaranteed(e))\n+                Ok(self.tcx().ty_error(e))\n             }\n \n             ("}, {"sha": "df9aa765dc1533744972fc26f155ad45a64354e9", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -89,9 +89,7 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n                 Err(TypeError::Sorts(relate::expected_found(self, a, b)))\n             }\n \n-            (&ty::Error(guar), _) | (_, &ty::Error(guar)) => {\n-                Ok(self.tcx().ty_error_with_guaranteed(guar))\n-            }\n+            (&ty::Error(guar), _) | (_, &ty::Error(guar)) => Ok(self.tcx().ty_error(guar)),\n \n             _ => relate::super_relate_tys(self, a, b),\n         }"}, {"sha": "796daa7646f9c8922992579cfa84d102dc1ade6a", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -718,13 +718,13 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Constructs a `TyKind::Error` type with current `ErrorGuaranteed`\n     #[track_caller]\n-    pub fn ty_error_with_guaranteed(self, reported: ErrorGuaranteed) -> Ty<'tcx> {\n+    pub fn ty_error(self, reported: ErrorGuaranteed) -> Ty<'tcx> {\n         self.mk_ty(Error(reported))\n     }\n \n     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` to ensure it gets used.\n     #[track_caller]\n-    pub fn ty_error(self) -> Ty<'tcx> {\n+    pub fn ty_error_misc(self) -> Ty<'tcx> {\n         self.ty_error_with_message(DUMMY_SP, \"TyKind::Error constructed but no error reported\")\n     }\n \n@@ -2458,7 +2458,7 @@ impl<'tcx> TyCtxt<'tcx> {\n impl<'tcx> TyCtxtAt<'tcx> {\n     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` to ensure it gets used.\n     #[track_caller]\n-    pub fn ty_error(self) -> Ty<'tcx> {\n+    pub fn ty_error_misc(self) -> Ty<'tcx> {\n         self.tcx.ty_error_with_message(self.span, \"TyKind::Error constructed but no error reported\")\n     }\n "}, {"sha": "baef4ffeda73266cbca003b4462fe5c0dc71b779", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -101,7 +101,7 @@ impl GenericParamDef {\n     ) -> ty::GenericArg<'tcx> {\n         match &self.kind {\n             ty::GenericParamDefKind::Lifetime => tcx.mk_re_error_misc().into(),\n-            ty::GenericParamDefKind::Type { .. } => tcx.ty_error().into(),\n+            ty::GenericParamDefKind::Type { .. } => tcx.ty_error_misc().into(),\n             ty::GenericParamDefKind::Const { .. } => {\n                 tcx.const_error(tcx.type_of(self.def_id).subst(tcx, preceding_substs)).into()\n             }"}, {"sha": "c8b1c7f76f40d1f168190e99a8a4f3a568fd3878", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -35,6 +35,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, DocLinkResMap, LifetimeRes, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LocalDefIdMap};\n@@ -1358,7 +1359,7 @@ pub struct OpaqueHiddenType<'tcx> {\n }\n \n impl<'tcx> OpaqueHiddenType<'tcx> {\n-    pub fn report_mismatch(&self, other: &Self, tcx: TyCtxt<'tcx>) {\n+    pub fn report_mismatch(&self, other: &Self, tcx: TyCtxt<'tcx>) -> ErrorGuaranteed {\n         // Found different concrete types for the opaque type.\n         let sub_diag = if self.span == other.span {\n             TypeMismatchReason::ConflictType { span: self.span }\n@@ -1370,7 +1371,7 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n             other_ty: other.ty,\n             other_span: other.span,\n             sub: sub_diag,\n-        });\n+        })\n     }\n \n     #[instrument(level = \"debug\", skip(tcx), ret)]"}, {"sha": "6463b38c7e19c1767705cbdd886a288b15a21f4c", "filename": "compiler/rustc_middle/src/ty/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -186,7 +186,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ReverseMapper<'tcx> {\n                                 .emit();\n                         }\n \n-                        self.interner().ty_error()\n+                        self.interner().ty_error_misc()\n                     }\n                 }\n             }"}, {"sha": "735b87d08e3272fe9f46aa7a200d69e2dec6e7ff", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -412,7 +412,7 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n             bug!(\"bound types encountered in super_relate_tys\")\n         }\n \n-        (&ty::Error(guar), _) | (_, &ty::Error(guar)) => Ok(tcx.ty_error_with_guaranteed(guar)),\n+        (&ty::Error(guar), _) | (_, &ty::Error(guar)) => Ok(tcx.ty_error(guar)),\n \n         (&ty::Never, _)\n         | (&ty::Char, _)"}, {"sha": "c4f526dbdc89d254dc847feb68316e82475b7877", "filename": "compiler/rustc_middle/src/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -16,7 +16,7 @@ impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for Ty<'_> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo<DepKind>]) -> Self {\n         // SAFETY: This is never called when `Self` is not `Ty<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow.\n-        unsafe { std::mem::transmute::<Ty<'tcx>, Ty<'_>>(tcx.ty_error()) }\n+        unsafe { std::mem::transmute::<Ty<'tcx>, Ty<'_>>(tcx.ty_error_misc()) }\n     }\n }\n \n@@ -34,7 +34,7 @@ impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for ty::SymbolName<'_> {\n \n impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for ty::Binder<'_, ty::FnSig<'_>> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>, stack: &[QueryInfo<DepKind>]) -> Self {\n-        let err = tcx.ty_error();\n+        let err = tcx.ty_error_misc();\n \n         let arity = if let Some(frame) = stack.get(0)\n             && frame.query.dep_kind == DepKind::fn_sig"}, {"sha": "27536fcddd759998869ea55ef62d83417e57ef32", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -639,7 +639,7 @@ fn construct_error(\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def);\n     let generator_kind = tcx.generator_kind(def);\n \n-    let ty = tcx.ty_error();\n+    let ty = tcx.ty_error(err);\n     let num_params = match body_owner_kind {\n         hir::BodyOwnerKind::Fn => tcx.fn_sig(def).skip_binder().inputs().skip_binder().len(),\n         hir::BodyOwnerKind::Closure => {"}, {"sha": "d4fdd5457375164fece0eb3e28fdf2db82c1e24a", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -316,7 +316,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 | ty::Never\n                 | ty::Foreign(..) => tcx.types.unit,\n \n-                ty::Error(e) => tcx.ty_error_with_guaranteed(*e),\n+                ty::Error(e) => tcx.ty_error(*e),\n \n                 ty::Str | ty::Slice(_) => tcx.types.usize,\n "}, {"sha": "1272d942b142a131a8559522db64940502a0a167", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -3534,7 +3534,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         {\n             if let hir::Expr { kind: hir::ExprKind::Block(..), .. } = expr {\n                 let expr = expr.peel_blocks();\n-                let ty = typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error());\n+                let ty = typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error_misc());\n                 let span = expr.span;\n                 if Some(span) != err.span.primary_span() {\n                     err.span_label(\n@@ -3637,7 +3637,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         let mut assocs = vec![];\n         let mut expr = expr;\n         let mut prev_ty = self.resolve_vars_if_possible(\n-            typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n+            typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error_misc()),\n         );\n         while let hir::ExprKind::MethodCall(_path_segment, rcvr_expr, _args, span) = expr.kind {\n             // Point at every method call in the chain with the resulting type.\n@@ -3648,7 +3648,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 self.probe_assoc_types_at_expr(&type_diffs, span, prev_ty, expr.hir_id, param_env);\n             assocs.push(assocs_in_this_method);\n             prev_ty = self.resolve_vars_if_possible(\n-                typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n+                typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error_misc()),\n             );\n \n             if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n@@ -3666,7 +3666,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 if let hir::Node::Param(param) = parent {\n                     // ...and it is a an fn argument.\n                     let prev_ty = self.resolve_vars_if_possible(\n-                        typeck_results.node_type_opt(param.hir_id).unwrap_or(tcx.ty_error()),\n+                        typeck_results.node_type_opt(param.hir_id).unwrap_or(tcx.ty_error_misc()),\n                     );\n                     let assocs_in_this_method = self.probe_assoc_types_at_expr(&type_diffs, param.ty_span, prev_ty, param.hir_id, param_env);\n                     if assocs_in_this_method.iter().any(|a| a.is_some()) {"}, {"sha": "14bba00b57e052acf4f0f37fa297cf991ea1a1f7", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -1213,8 +1213,8 @@ struct Progress<'tcx> {\n }\n \n impl<'tcx> Progress<'tcx> {\n-    fn error(tcx: TyCtxt<'tcx>) -> Self {\n-        Progress { term: tcx.ty_error().into(), obligations: vec![] }\n+    fn error(tcx: TyCtxt<'tcx>, guar: ErrorGuaranteed) -> Self {\n+        Progress { term: tcx.ty_error(guar).into(), obligations: vec![] }\n     }\n \n     fn with_addl_obligations(mut self, mut obligations: Vec<PredicateObligation<'tcx>>) -> Self {\n@@ -1240,8 +1240,8 @@ fn project<'cx, 'tcx>(\n         )));\n     }\n \n-    if obligation.predicate.references_error() {\n-        return Ok(Projected::Progress(Progress::error(selcx.tcx())));\n+    if let Err(guar) = obligation.predicate.error_reported() {\n+        return Ok(Projected::Progress(Progress::error(selcx.tcx(), guar)));\n     }\n \n     let mut candidates = ProjectionCandidateSet::None;\n@@ -2097,8 +2097,9 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n \n     let param_env = obligation.param_env;\n-    let Ok(assoc_ty) = specialization_graph::assoc_def(tcx, impl_def_id, assoc_item_id) else {\n-        return Progress { term: tcx.ty_error().into(), obligations: nested };\n+    let assoc_ty = match specialization_graph::assoc_def(tcx, impl_def_id, assoc_item_id) {\n+        Ok(assoc_ty) => assoc_ty,\n+        Err(guar) => return Progress::error(tcx, guar),\n     };\n \n     if !assoc_ty.item.defaultness(tcx).has_value() {\n@@ -2110,7 +2111,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n             \"confirm_impl_candidate: no associated type {:?} for {:?}\",\n             assoc_ty.item.name, obligation.predicate\n         );\n-        return Progress { term: tcx.ty_error().into(), obligations: nested };\n+        return Progress { term: tcx.ty_error_misc().into(), obligations: nested };\n     }\n     // If we're trying to normalize `<Vec<u32> as X>::A<S>` using\n     //`impl<T> X for Vec<T> { type A<Y> = Box<Y>; }`, then:\n@@ -2194,11 +2195,12 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n     let mut obligations = data.nested;\n \n     let trait_fn_def_id = tcx.impl_trait_in_trait_parent(obligation.predicate.def_id);\n-    let Ok(leaf_def) = specialization_graph::assoc_def(tcx, data.impl_def_id, trait_fn_def_id) else {\n-        return Progress { term: tcx.ty_error().into(), obligations };\n+    let leaf_def = match specialization_graph::assoc_def(tcx, data.impl_def_id, trait_fn_def_id) {\n+        Ok(assoc_ty) => assoc_ty,\n+        Err(guar) => return Progress::error(tcx, guar),\n     };\n     if !leaf_def.item.defaultness(tcx).has_value() {\n-        return Progress { term: tcx.ty_error().into(), obligations };\n+        return Progress { term: tcx.ty_error_misc().into(), obligations };\n     }\n \n     // Use the default `impl Trait` for the trait, e.g., for a default trait body\n@@ -2269,7 +2271,7 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n         obligation.recursion_depth + 1,\n         tcx.bound_return_position_impl_trait_in_trait_tys(impl_fn_def_id)\n             .map_bound(|tys| {\n-                tys.map_or_else(|_| tcx.ty_error(), |tys| tys[&obligation.predicate.def_id])\n+                tys.map_or_else(|guar| tcx.ty_error(guar), |tys| tys[&obligation.predicate.def_id])\n             })\n             .subst(tcx, impl_fn_substs),\n         &mut obligations,"}, {"sha": "e2fb954e31f360e4871c48241c09f03efddff1ba", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -2443,15 +2443,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // the placeholder trait ref may fail due the Generalizer relation\n                 // raising a CyclicalTy error due to a sub_root_var relation\n                 // for a variable being generalized...\n-                self.infcx.tcx.sess.delay_span_bug(\n+                let guar = self.infcx.tcx.sess.delay_span_bug(\n                     obligation.cause.span,\n                     &format!(\n                         \"Impl {:?} was matchable against {:?} but now is not\",\n                         impl_def_id, obligation\n                     ),\n                 );\n                 let value = self.infcx.fresh_substs_for_item(obligation.cause.span, impl_def_id);\n-                let err = self.tcx().ty_error();\n+                let err = self.tcx().ty_error(guar);\n                 let value = value.fold_with(&mut BottomUpFolder {\n                     tcx: self.tcx(),\n                     ty_op: |_| err,"}, {"sha": "50cd1d1c0e8e107529502c6151dbd24dccdd7dee", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -455,7 +455,7 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n                 interner.tcx.mk_alias_ty(assoc_ty.0, substitution.lower_into(interner)),\n             ),\n             TyKind::Foreign(def_id) => ty::Foreign(def_id.0),\n-            TyKind::Error => return interner.tcx.ty_error(),\n+            TyKind::Error => return interner.tcx.ty_error_misc(),\n             TyKind::Alias(alias_ty) => match alias_ty {\n                 chalk_ir::AliasTy::Projection(projection) => ty::Alias(\n                     ty::Projection,"}, {"sha": "853c50f52462f663a920ae4372434fd5f03ed7d7", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c993eba8b76eae497e98433ae075b00f01be10/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=07c993eba8b76eae497e98433ae075b00f01be10", "patch": "@@ -98,7 +98,7 @@ fn impl_defaultness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Defaultness {\n fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> &[Ty<'_>] {\n     if let Some(def_id) = def_id.as_local() {\n         if matches!(tcx.representability(def_id), ty::Representability::Infinite) {\n-            return tcx.intern_type_list(&[tcx.ty_error()]);\n+            return tcx.intern_type_list(&[tcx.ty_error_misc()]);\n         }\n     }\n     let def = tcx.adt_def(def_id);"}]}