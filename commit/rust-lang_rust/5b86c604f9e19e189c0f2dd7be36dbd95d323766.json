{"sha": "5b86c604f9e19e189c0f2dd7be36dbd95d323766", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViODZjNjA0ZjllMTllMTg5YzBmMmRkN2JlMzZkYmQ5NWQzMjM3NjY=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-07-07T13:00:59Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-07-07T14:23:07Z"}, "message": "Move `BorrowedContentSource` from move_errors to error_reporting", "tree": {"sha": "0435230811a866441469157163f9afbfc23bd0ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0435230811a866441469157163f9afbfc23bd0ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b86c604f9e19e189c0f2dd7be36dbd95d323766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b86c604f9e19e189c0f2dd7be36dbd95d323766", "html_url": "https://github.com/rust-lang/rust/commit/5b86c604f9e19e189c0f2dd7be36dbd95d323766", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b86c604f9e19e189c0f2dd7be36dbd95d323766/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbeed58adee2ef046b46b252980f86672f9bfc4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbeed58adee2ef046b46b252980f86672f9bfc4c", "html_url": "https://github.com/rust-lang/rust/commit/dbeed58adee2ef046b46b252980f86672f9bfc4c"}], "stats": {"total": 262, "additions": 133, "deletions": 129}, "files": [{"sha": "7f48a4ea20e3d315e014e5c1f0e640f2c4a5e8e7", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 131, "deletions": 2, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/5b86c604f9e19e189c0f2dd7be36dbd95d323766/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b86c604f9e19e189c0f2dd7be36dbd95d323766/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=5b86c604f9e19e189c0f2dd7be36dbd95d323766", "patch": "@@ -4,9 +4,9 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     AggregateKind, Constant, Field, Local, LocalKind, Location, Operand,\n     Place, PlaceBase, ProjectionElem, Rvalue, Statement, StatementKind, Static,\n-    StaticKind, TerminatorKind,\n+    StaticKind, Terminator, TerminatorKind,\n };\n-use rustc::ty::{self, DefIdTree, Ty};\n+use rustc::ty::{self, DefIdTree, Ty, TyCtxt};\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::print::Print;\n use rustc_errors::DiagnosticBuilder;\n@@ -15,6 +15,7 @@ use syntax::symbol::sym;\n \n use super::borrow_set::BorrowData;\n use super::{MirBorrowckCtxt};\n+use crate::dataflow::move_paths::{InitLocation, LookupResult};\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n \n@@ -401,6 +402,70 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             err.note(&message);\n         }\n     }\n+\n+    pub(super) fn borrowed_content_source(\n+        &self,\n+        deref_base: &Place<'tcx>,\n+    ) -> BorrowedContentSource<'tcx> {\n+        let tcx = self.infcx.tcx;\n+\n+        // Look up the provided place and work out the move path index for it,\n+        // we'll use this to check whether it was originally from an overloaded\n+        // operator.\n+        match self.move_data.rev_lookup.find(deref_base) {\n+            LookupResult::Exact(mpi) | LookupResult::Parent(Some(mpi)) => {\n+                debug!(\"borrowed_content_source: mpi={:?}\", mpi);\n+\n+                for i in &self.move_data.init_path_map[mpi] {\n+                    let init = &self.move_data.inits[*i];\n+                    debug!(\"borrowed_content_source: init={:?}\", init);\n+                    // We're only interested in statements that initialized a value, not the\n+                    // initializations from arguments.\n+                    let loc = match init.location {\n+                        InitLocation::Statement(stmt) => stmt,\n+                        _ => continue,\n+                    };\n+\n+                    let bbd = &self.body[loc.block];\n+                    let is_terminator = bbd.statements.len() == loc.statement_index;\n+                    debug!(\n+                        \"borrowed_content_source: loc={:?} is_terminator={:?}\",\n+                        loc,\n+                        is_terminator,\n+                    );\n+                    if !is_terminator {\n+                        continue;\n+                    } else if let Some(Terminator {\n+                        kind: TerminatorKind::Call {\n+                            ref func,\n+                            from_hir_call: false,\n+                            ..\n+                        },\n+                        ..\n+                    }) = bbd.terminator {\n+                        if let Some(source)\n+                            = BorrowedContentSource::from_call(func.ty(self.body, tcx), tcx)\n+                        {\n+                            return source;\n+                        }\n+                    }\n+                }\n+            }\n+            // Base is a `static` so won't be from an overloaded operator\n+            _ => (),\n+        };\n+\n+        // If we didn't find an overloaded deref or index, then assume it's a\n+        // built in deref and check the type of the base.\n+        let base_ty = deref_base.ty(self.body, tcx).ty;\n+        if base_ty.is_unsafe_ptr() {\n+            BorrowedContentSource::DerefRawPointer\n+        } else if base_ty.is_mutable_pointer() {\n+            BorrowedContentSource::DerefMutableRef\n+        } else {\n+            BorrowedContentSource::DerefSharedRef\n+        }\n+    }\n }\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n@@ -547,6 +612,70 @@ impl UseSpans {\n     }\n }\n \n+pub(super) enum BorrowedContentSource<'tcx> {\n+    DerefRawPointer,\n+    DerefMutableRef,\n+    DerefSharedRef,\n+    OverloadedDeref(Ty<'tcx>),\n+    OverloadedIndex(Ty<'tcx>),\n+}\n+\n+impl BorrowedContentSource<'tcx> {\n+    pub(super) fn describe_for_unnamed_place(&self) -> String {\n+        match *self {\n+            BorrowedContentSource::DerefRawPointer => format!(\"a raw pointer\"),\n+            BorrowedContentSource::DerefSharedRef => format!(\"a shared reference\"),\n+            BorrowedContentSource::DerefMutableRef => {\n+                format!(\"a mutable reference\")\n+            }\n+            BorrowedContentSource::OverloadedDeref(ty) => {\n+                if ty.is_rc() {\n+                   format!(\"an `Rc`\")\n+                } else if ty.is_arc() {\n+                    format!(\"an `Arc`\")\n+                } else {\n+                    format!(\"dereference of `{}`\", ty)\n+                }\n+            }\n+            BorrowedContentSource::OverloadedIndex(ty) => format!(\"index of `{}`\", ty),\n+        }\n+    }\n+\n+    pub(super) fn describe_for_named_place(&self) -> Option<&'static str> {\n+        match *self {\n+            BorrowedContentSource::DerefRawPointer => Some(\"raw pointer\"),\n+            BorrowedContentSource::DerefSharedRef => Some(\"shared reference\"),\n+            BorrowedContentSource::DerefMutableRef => Some(\"mutable reference\"),\n+            // Overloaded deref and index operators should be evaluated into a\n+            // temporary. So we don't need a description here.\n+            BorrowedContentSource::OverloadedDeref(_)\n+            | BorrowedContentSource::OverloadedIndex(_) => None\n+        }\n+    }\n+\n+    fn from_call(func: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> Option<Self> {\n+        match func.sty {\n+            ty::FnDef(def_id, substs) => {\n+                let trait_id = tcx.trait_of_item(def_id)?;\n+\n+                let lang_items = tcx.lang_items();\n+                if Some(trait_id) == lang_items.deref_trait()\n+                    || Some(trait_id) == lang_items.deref_mut_trait()\n+                {\n+                    Some(BorrowedContentSource::OverloadedDeref(substs.type_at(0)))\n+                } else if Some(trait_id) == lang_items.index_trait()\n+                    || Some(trait_id) == lang_items.index_mut_trait()\n+                {\n+                    Some(BorrowedContentSource::OverloadedIndex(substs.type_at(0)))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Finds the spans associated to a move or copy of move_place at location.\n     pub(super) fn move_spans("}, {"sha": "3130b7cec5b4a946628aa9b7ee645ce071fc4b15", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 2, "deletions": 127, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/5b86c604f9e19e189c0f2dd7be36dbd95d323766/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b86c604f9e19e189c0f2dd7be36dbd95d323766/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=5b86c604f9e19e189c0f2dd7be36dbd95d323766", "patch": "@@ -1,15 +1,15 @@\n use core::unicode::property::Pattern_White_Space;\n \n use rustc::mir::*;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty;\n use rustc_errors::{DiagnosticBuilder,Applicability};\n use syntax_pos::Span;\n \n use crate::borrow_check::MirBorrowckCtxt;\n use crate::borrow_check::prefixes::PrefixSet;\n use crate::borrow_check::error_reporting::UseSpans;\n use crate::dataflow::move_paths::{\n-    IllegalMoveOrigin, IllegalMoveOriginKind, InitLocation,\n+    IllegalMoveOrigin, IllegalMoveOriginKind,\n     LookupResult, MoveError, MovePathIndex,\n };\n use crate::util::borrowck_errors::{BorrowckErrors, Origin};\n@@ -55,70 +55,6 @@ enum GroupedMoveError<'tcx> {\n     },\n }\n \n-enum BorrowedContentSource<'tcx> {\n-    DerefRawPointer,\n-    DerefMutableRef,\n-    DerefSharedRef,\n-    OverloadedDeref(Ty<'tcx>),\n-    OverloadedIndex(Ty<'tcx>),\n-}\n-\n-impl BorrowedContentSource<'tcx> {\n-    fn describe_for_unnamed_place(&self) -> String {\n-        match *self {\n-            BorrowedContentSource::DerefRawPointer => format!(\"a raw pointer\"),\n-            BorrowedContentSource::DerefSharedRef => format!(\"a shared reference\"),\n-            BorrowedContentSource::DerefMutableRef => {\n-                format!(\"a mutable reference\")\n-            }\n-            BorrowedContentSource::OverloadedDeref(ty) => {\n-                if ty.is_rc() {\n-                   format!(\"an `Rc`\")\n-                } else if ty.is_arc() {\n-                    format!(\"an `Arc`\")\n-                } else {\n-                    format!(\"dereference of `{}`\", ty)\n-                }\n-            }\n-            BorrowedContentSource::OverloadedIndex(ty) => format!(\"index of `{}`\", ty),\n-        }\n-    }\n-\n-    fn describe_for_named_place(&self) -> Option<&'static str> {\n-        match *self {\n-            BorrowedContentSource::DerefRawPointer => Some(\"raw pointer\"),\n-            BorrowedContentSource::DerefSharedRef => Some(\"shared reference\"),\n-            BorrowedContentSource::DerefMutableRef => Some(\"mutable reference\"),\n-            // Overloaded deref and index operators should be evaluated into a\n-            // temporary. So we don't need a description here.\n-            BorrowedContentSource::OverloadedDeref(_)\n-            | BorrowedContentSource::OverloadedIndex(_) => None\n-        }\n-    }\n-\n-    fn from_call(func: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> Option<Self> {\n-        match func.sty {\n-            ty::FnDef(def_id, substs) => {\n-                let trait_id = tcx.trait_of_item(def_id)?;\n-\n-                let lang_items = tcx.lang_items();\n-                if Some(trait_id) == lang_items.deref_trait()\n-                    || Some(trait_id) == lang_items.deref_mut_trait()\n-                {\n-                    Some(BorrowedContentSource::OverloadedDeref(substs.type_at(0)))\n-                } else if Some(trait_id) == lang_items.index_trait()\n-                    || Some(trait_id) == lang_items.index_mut_trait()\n-                {\n-                    Some(BorrowedContentSource::OverloadedIndex(substs.type_at(0)))\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None,\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     pub(crate) fn report_move_errors(&mut self, move_errors: Vec<(Place<'tcx>, MoveError<'tcx>)>) {\n         let grouped_errors = self.group_move_errors(move_errors);\n@@ -646,65 +582,4 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             );\n         }\n     }\n-\n-    fn borrowed_content_source(&self, deref_base: &Place<'tcx>) -> BorrowedContentSource<'tcx> {\n-        let tcx = self.infcx.tcx;\n-\n-        // Look up the provided place and work out the move path index for it,\n-        // we'll use this to check whether it was originally from an overloaded\n-        // operator.\n-        match self.move_data.rev_lookup.find(deref_base) {\n-            LookupResult::Exact(mpi) | LookupResult::Parent(Some(mpi)) => {\n-                debug!(\"borrowed_content_source: mpi={:?}\", mpi);\n-\n-                for i in &self.move_data.init_path_map[mpi] {\n-                    let init = &self.move_data.inits[*i];\n-                    debug!(\"borrowed_content_source: init={:?}\", init);\n-                    // We're only interested in statements that initialized a value, not the\n-                    // initializations from arguments.\n-                    let loc = match init.location {\n-                        InitLocation::Statement(stmt) => stmt,\n-                        _ => continue,\n-                    };\n-\n-                    let bbd = &self.body[loc.block];\n-                    let is_terminator = bbd.statements.len() == loc.statement_index;\n-                    debug!(\n-                        \"borrowed_content_source: loc={:?} is_terminator={:?}\",\n-                        loc,\n-                        is_terminator,\n-                    );\n-                    if !is_terminator {\n-                        continue;\n-                    } else if let Some(Terminator {\n-                        kind: TerminatorKind::Call {\n-                            ref func,\n-                            from_hir_call: false,\n-                            ..\n-                        },\n-                        ..\n-                    }) = bbd.terminator {\n-                        if let Some(source)\n-                            = BorrowedContentSource::from_call(func.ty(self.body, tcx), tcx)\n-                        {\n-                            return source;\n-                        }\n-                    }\n-                }\n-            }\n-            // Base is a `static` so won't be from an overloaded operator\n-            _ => (),\n-        };\n-\n-        // If we didn't find an overloaded deref or index, then assume it's a\n-        // built in deref and check the type of the base.\n-        let base_ty = deref_base.ty(self.body, tcx).ty;\n-        if base_ty.is_unsafe_ptr() {\n-            BorrowedContentSource::DerefRawPointer\n-        } else if base_ty.is_mutable_pointer() {\n-            BorrowedContentSource::DerefMutableRef\n-        } else {\n-            BorrowedContentSource::DerefSharedRef\n-        }\n-    }\n }"}]}