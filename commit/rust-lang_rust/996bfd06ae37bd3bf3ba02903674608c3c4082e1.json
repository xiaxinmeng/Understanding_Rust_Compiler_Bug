{"sha": "996bfd06ae37bd3bf3ba02903674608c3c4082e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NmJmZDA2YWUzN2JkM2JmM2JhMDI5MDM2NzQ2MDhjM2M0MDgyZTE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-16T11:14:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-16T11:14:45Z"}, "message": "Merge pull request #802 from bjorn3/debuginfo_locals\n\nDebuginfo locals", "tree": {"sha": "ac10fdf7efefe05fd47ca8c76d35a71e981d3876", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac10fdf7efefe05fd47ca8c76d35a71e981d3876"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/996bfd06ae37bd3bf3ba02903674608c3c4082e1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd92clCRBK7hj4Ov3rIwAAdHIIACnodxB1B48cvPPrLQ+sgY6V\n4xt9e9w7oWL0FhsHaCe0I1Zn3NcYHaDSiM239YdQgtLHEco6UWLkVHv1Va/PtUOL\nF9+ONWYEIyvqv0uJT4j9yWC+RF5XSgokyUrDFonn4zB2bCCbGQZntHQot9K5pZBm\nMZ0fO14ZEAC/i/1HR3dSiRVzLZmQopI5UWrL+IwpnjN/Rlt8v55ubEq/DoCaLOCf\nvOcqT4McoYyzvQFiYm9kfC/5GbbnGWQ2bnfNyf0KdmwDzUubSmrCjCiXzlGh9lwe\nx7D5hisbNOJ+JFQda+LTIDvalVpdLpJWpqi5QSs92uWjXC0B3LzpqhOXfYwe0LY=\n=peF7\n-----END PGP SIGNATURE-----\n", "payload": "tree ac10fdf7efefe05fd47ca8c76d35a71e981d3876\nparent 306bf8ec1c13f22523e6aea74718357674bc30aa\nparent beda104a2b828616ce5691577bf0d8750c641ce0\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1576494885 +0100\ncommitter GitHub <noreply@github.com> 1576494885 +0100\n\nMerge pull request #802 from bjorn3/debuginfo_locals\n\nDebuginfo locals"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/996bfd06ae37bd3bf3ba02903674608c3c4082e1", "html_url": "https://github.com/rust-lang/rust/commit/996bfd06ae37bd3bf3ba02903674608c3c4082e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/996bfd06ae37bd3bf3ba02903674608c3c4082e1/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "306bf8ec1c13f22523e6aea74718357674bc30aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/306bf8ec1c13f22523e6aea74718357674bc30aa", "html_url": "https://github.com/rust-lang/rust/commit/306bf8ec1c13f22523e6aea74718357674bc30aa"}, {"sha": "beda104a2b828616ce5691577bf0d8750c641ce0", "url": "https://api.github.com/repos/rust-lang/rust/commits/beda104a2b828616ce5691577bf0d8750c641ce0", "html_url": "https://github.com/rust-lang/rust/commit/beda104a2b828616ce5691577bf0d8750c641ce0"}], "stats": {"total": 1175, "additions": 756, "deletions": 419}, "files": [{"sha": "243852f1d2bef310817ec29e9fd3aec588ec8e22", "filename": "src/base.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=996bfd06ae37bd3bf3ba02903674608c3c4082e1", "patch": "@@ -17,10 +17,11 @@ pub fn trans_fn<'clif, 'tcx, B: Backend + 'static>(\n     let mut debug_context = cx\n         .debug_context\n         .as_mut()\n-        .map(|debug_context| FunctionDebugContext::new(tcx, debug_context, mir, func_id, &name, &sig));\n+        .map(|debug_context| FunctionDebugContext::new(debug_context, instance, func_id, &name));\n \n     // Make FunctionBuilder\n     let mut func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n+    func.collect_debug_info();\n     let mut func_ctx = FunctionBuilderContext::new();\n     let mut bcx = FunctionBuilder::new(&mut func, &mut func_ctx);\n \n@@ -60,6 +61,7 @@ pub fn trans_fn<'clif, 'tcx, B: Backend + 'static>(\n     let instance = fx.instance;\n     let clif_comments = fx.clif_comments;\n     let source_info_set = fx.source_info_set;\n+    let local_map = fx.local_map;\n \n     #[cfg(debug_assertions)]\n     crate::pretty_clif::write_clif_file(cx.tcx, \"unopt\", instance, &func, &clif_comments, None);\n@@ -72,26 +74,28 @@ pub fn trans_fn<'clif, 'tcx, B: Backend + 'static>(\n     context.func = func;\n     cx.module.define_function(func_id, context).unwrap();\n \n-    let value_ranges = context\n-        .build_value_labels_ranges(cx.module.isa())\n-        .expect(\"value location ranges\");\n-\n     // Write optimized function to file for debugging\n     #[cfg(debug_assertions)]\n-    crate::pretty_clif::write_clif_file(\n-        cx.tcx,\n-        \"opt\",\n-        instance,\n-        &context.func,\n-        &clif_comments,\n-        Some(&value_ranges),\n-    );\n+    {\n+        let value_ranges = context\n+            .build_value_labels_ranges(cx.module.isa())\n+            .expect(\"value location ranges\");\n+\n+        crate::pretty_clif::write_clif_file(\n+            cx.tcx,\n+            \"opt\",\n+            instance,\n+            &context.func,\n+            &clif_comments,\n+            Some(&value_ranges),\n+        );\n+    }\n \n     // Define debuginfo for function\n     let isa = cx.module.isa();\n     debug_context\n         .as_mut()\n-        .map(|x| x.define(tcx, context, isa, &source_info_set));\n+        .map(|x| x.define(context, isa, &source_info_set, local_map));\n \n     // Clear context to make it usable for the next function\n     context.clear();"}, {"sha": "e6d133c64510cb4bd7245ad3b0fb1953daa01995", "filename": "src/debuginfo.rs", "status": "removed", "additions": 0, "deletions": 399, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/306bf8ec1c13f22523e6aea74718357674bc30aa/src%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/306bf8ec1c13f22523e6aea74718357674bc30aa/src%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo.rs?ref=306bf8ec1c13f22523e6aea74718357674bc30aa", "patch": "@@ -1,399 +0,0 @@\n-use crate::prelude::*;\n-\n-use crate::backend::WriteDebugInfo;\n-\n-use std::marker::PhantomData;\n-\n-use syntax::source_map::FileName;\n-\n-use gimli::write::{\n-    Address, AttributeValue, DwarfUnit, EndianVec, FileId, LineProgram, LineString,\n-    LineStringTable, Range, RangeList, Result, Sections, UnitEntryId, Writer,\n-};\n-use gimli::{Encoding, Format, LineEncoding, RunTimeEndian, SectionId};\n-\n-fn target_endian(tcx: TyCtxt) -> RunTimeEndian {\n-    use rustc::ty::layout::Endian;\n-\n-    match tcx.data_layout.endian {\n-        Endian::Big => RunTimeEndian::Big,\n-        Endian::Little => RunTimeEndian::Little,\n-    }\n-}\n-\n-fn line_program_add_file(\n-    line_program: &mut LineProgram,\n-    line_strings: &mut LineStringTable,\n-    file: &FileName,\n-) -> FileId {\n-    match file {\n-        FileName::Real(path) => {\n-            let dir_name = path.parent().unwrap().to_str().unwrap().as_bytes();\n-            let dir_id = if !dir_name.is_empty() {\n-                let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n-                line_program.add_directory(dir_name)\n-            } else {\n-                line_program.default_directory()\n-            };\n-            let file_name = LineString::new(\n-                path.file_name().unwrap().to_str().unwrap().as_bytes(),\n-                line_program.encoding(),\n-                line_strings,\n-            );\n-            line_program.add_file(file_name, dir_id, None)\n-        }\n-        // FIXME give more appropriate file names\n-        _ => {\n-            let dir_id = line_program.default_directory();\n-            let dummy_file_name = LineString::new(\n-                file.to_string().into_bytes(),\n-                line_program.encoding(),\n-                line_strings,\n-            );\n-            line_program.add_file(dummy_file_name, dir_id, None)\n-        }\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct DebugReloc {\n-    pub offset: u32,\n-    pub size: u8,\n-    pub name: DebugRelocName,\n-    pub addend: i64,\n-}\n-\n-#[derive(Clone)]\n-pub enum DebugRelocName {\n-    Section(SectionId),\n-    Symbol(usize),\n-}\n-\n-pub struct DebugContext<'tcx> {\n-    endian: RunTimeEndian,\n-    symbols: indexmap::IndexMap<FuncId, String>,\n-\n-    dwarf: DwarfUnit,\n-    unit_range_list: RangeList,\n-\n-    _dummy: PhantomData<&'tcx ()>,\n-}\n-\n-impl<'tcx> DebugContext<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, address_size: u8) -> Self {\n-        let encoding = Encoding {\n-            format: Format::Dwarf32,\n-            // TODO: this should be configurable\n-            // macOS doesn't seem to support DWARF > 3\n-            version: 3,\n-            address_size,\n-        };\n-\n-        let mut dwarf = DwarfUnit::new(encoding);\n-\n-        // FIXME: how to get version when building out of tree?\n-        // Normally this would use option_env!(\"CFG_VERSION\").\n-        let producer = format!(\"cranelift fn (rustc version {})\", \"unknown version\");\n-        let comp_dir = tcx.sess.working_dir.0.to_string_lossy().into_owned();\n-        let name = match tcx.sess.local_crate_source_file {\n-            Some(ref path) => path.to_string_lossy().into_owned(),\n-            None => tcx.crate_name(LOCAL_CRATE).to_string(),\n-        };\n-\n-        let line_program = LineProgram::new(\n-            encoding,\n-            LineEncoding::default(),\n-            LineString::new(comp_dir.as_bytes(), encoding, &mut dwarf.line_strings),\n-            LineString::new(name.as_bytes(), encoding, &mut dwarf.line_strings),\n-            None,\n-        );\n-        dwarf.unit.line_program = line_program;\n-\n-        {\n-            let name = dwarf.strings.add(&*name);\n-            let comp_dir = dwarf.strings.add(&*comp_dir);\n-\n-            let root = dwarf.unit.root();\n-            let root = dwarf.unit.get_mut(root);\n-            root.set(\n-                gimli::DW_AT_producer,\n-                AttributeValue::StringRef(dwarf.strings.add(producer)),\n-            );\n-            root.set(\n-                gimli::DW_AT_language,\n-                AttributeValue::Language(gimli::DW_LANG_Rust),\n-            );\n-            root.set(gimli::DW_AT_name, AttributeValue::StringRef(name));\n-            root.set(gimli::DW_AT_comp_dir, AttributeValue::StringRef(comp_dir));\n-            root.set(\n-                gimli::DW_AT_low_pc,\n-                AttributeValue::Address(Address::Constant(0)),\n-            );\n-        }\n-\n-        DebugContext {\n-            endian: target_endian(tcx),\n-            symbols: indexmap::IndexMap::new(),\n-\n-            dwarf,\n-            unit_range_list: RangeList(Vec::new()),\n-\n-            _dummy: PhantomData,\n-        }\n-    }\n-\n-    fn emit_location(&mut self, tcx: TyCtxt<'tcx>, entry_id: UnitEntryId, span: Span) {\n-        let loc = tcx.sess.source_map().lookup_char_pos(span.lo());\n-\n-        let file_id = line_program_add_file(\n-            &mut self.dwarf.unit.line_program,\n-            &mut self.dwarf.line_strings,\n-            &loc.file.name,\n-        );\n-\n-        let entry = self.dwarf.unit.get_mut(entry_id);\n-\n-        entry.set(\n-            gimli::DW_AT_decl_file,\n-            AttributeValue::FileIndex(Some(file_id)),\n-        );\n-        entry.set(\n-            gimli::DW_AT_decl_line,\n-            AttributeValue::Udata(loc.line as u64),\n-        );\n-        // FIXME: probably omit this\n-        entry.set(\n-            gimli::DW_AT_decl_column,\n-            AttributeValue::Udata(loc.col.to_usize() as u64),\n-        );\n-    }\n-\n-    pub fn emit<P: WriteDebugInfo>(&mut self, product: &mut P) {\n-        let unit_range_list_id = self.dwarf.unit.ranges.add(self.unit_range_list.clone());\n-        let root = self.dwarf.unit.root();\n-        let root = self.dwarf.unit.get_mut(root);\n-        root.set(\n-            gimli::DW_AT_ranges,\n-            AttributeValue::RangeListRef(unit_range_list_id),\n-        );\n-\n-        let mut sections = Sections::new(WriterRelocate::new(self));\n-        self.dwarf.write(&mut sections).unwrap();\n-\n-        let mut section_map = HashMap::new();\n-        let _: Result<()> = sections.for_each_mut(|id, section| {\n-            if !section.writer.slice().is_empty() {\n-                let section_id = product.add_debug_section(id, section.writer.take());\n-                section_map.insert(id, section_id);\n-            }\n-            Ok(())\n-        });\n-\n-        let _: Result<()> = sections.for_each(|id, section| {\n-            if let Some(section_id) = section_map.get(&id) {\n-                for reloc in &section.relocs {\n-                    product.add_debug_reloc(&section_map, &self.symbols, section_id, reloc);\n-                }\n-            }\n-            Ok(())\n-        });\n-    }\n-}\n-\n-pub struct FunctionDebugContext<'a, 'tcx> {\n-    debug_context: &'a mut DebugContext<'tcx>,\n-    entry_id: UnitEntryId,\n-    symbol: usize,\n-    mir_span: Span,\n-}\n-\n-impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        debug_context: &'a mut DebugContext<'tcx>,\n-        mir: &Body,\n-        func_id: FuncId,\n-        name: &str,\n-        _sig: &Signature,\n-    ) -> Self {\n-        let (symbol, _) = debug_context.symbols.insert_full(func_id, name.to_string());\n-\n-        // FIXME: add to appropriate scope intead of root\n-        let scope = debug_context.dwarf.unit.root();\n-\n-        let entry_id = debug_context\n-            .dwarf\n-            .unit\n-            .add(scope, gimli::DW_TAG_subprogram);\n-        let entry = debug_context.dwarf.unit.get_mut(entry_id);\n-        let name_id = debug_context.dwarf.strings.add(name);\n-        entry.set(\n-            gimli::DW_AT_linkage_name,\n-            AttributeValue::StringRef(name_id),\n-        );\n-\n-        entry.set(\n-            gimli::DW_AT_low_pc,\n-            AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n-        );\n-\n-        debug_context.emit_location(tcx, entry_id, mir.span);\n-\n-        FunctionDebugContext {\n-            debug_context,\n-            entry_id,\n-            symbol,\n-            mir_span: mir.span,\n-        }\n-    }\n-\n-    pub fn define(\n-        &mut self,\n-        tcx: TyCtxt,\n-        context: &Context,\n-        isa: &dyn cranelift::codegen::isa::TargetIsa,\n-        source_info_set: &indexmap::IndexSet<(Span, mir::SourceScope)>,\n-    ) {\n-        let line_program = &mut self.debug_context.dwarf.unit.line_program;\n-\n-        line_program.begin_sequence(Some(Address::Symbol {\n-            symbol: self.symbol,\n-            addend: 0,\n-        }));\n-\n-        let encinfo = isa.encoding_info();\n-        let func = &context.func;\n-        let mut ebbs = func.layout.ebbs().collect::<Vec<_>>();\n-        ebbs.sort_by_key(|ebb| func.offsets[*ebb]); // Ensure inst offsets always increase\n-\n-        let line_strings = &mut self.debug_context.dwarf.line_strings;\n-        let mut create_row_for_span = |line_program: &mut LineProgram, span: Span| {\n-            let loc = tcx.sess.source_map().lookup_char_pos(span.lo());\n-            let file_id = line_program_add_file(line_program, line_strings, &loc.file.name);\n-\n-            /*println!(\n-                \"srcloc {:>04X} {}:{}:{}\",\n-                line_program.row().address_offset,\n-                file.display(),\n-                loc.line,\n-                loc.col.to_u32()\n-            );*/\n-\n-            line_program.row().file = file_id;\n-            line_program.row().line = loc.line as u64;\n-            line_program.row().column = loc.col.to_u32() as u64 + 1;\n-            line_program.generate_row();\n-        };\n-\n-        let mut end = 0;\n-        for ebb in ebbs {\n-            for (offset, inst, size) in func.inst_offsets(ebb, &encinfo) {\n-                let srcloc = func.srclocs[inst];\n-                line_program.row().address_offset = offset as u64;\n-                if !srcloc.is_default() {\n-                    let source_info = *source_info_set.get_index(srcloc.bits() as usize).unwrap();\n-                    create_row_for_span(line_program, source_info.0);\n-                } else {\n-                    create_row_for_span(line_program, self.mir_span);\n-                }\n-                end = offset + size;\n-            }\n-        }\n-\n-        line_program.end_sequence(end as u64);\n-\n-        let entry = self.debug_context.dwarf.unit.get_mut(self.entry_id);\n-        entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(end as u64));\n-\n-        self.debug_context\n-            .unit_range_list\n-            .0\n-            .push(Range::StartLength {\n-                begin: Address::Symbol {\n-                    symbol: self.symbol,\n-                    addend: 0,\n-                },\n-                length: end as u64,\n-            });\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct WriterRelocate {\n-    relocs: Vec<DebugReloc>,\n-    writer: EndianVec<RunTimeEndian>,\n-}\n-\n-impl WriterRelocate {\n-    fn new(ctx: &DebugContext) -> Self {\n-        WriterRelocate {\n-            relocs: Vec::new(),\n-            writer: EndianVec::new(ctx.endian),\n-        }\n-    }\n-}\n-\n-impl Writer for WriterRelocate {\n-    type Endian = RunTimeEndian;\n-\n-    fn endian(&self) -> Self::Endian {\n-        self.writer.endian()\n-    }\n-\n-    fn len(&self) -> usize {\n-        self.writer.len()\n-    }\n-\n-    fn write(&mut self, bytes: &[u8]) -> Result<()> {\n-        self.writer.write(bytes)\n-    }\n-\n-    fn write_at(&mut self, offset: usize, bytes: &[u8]) -> Result<()> {\n-        self.writer.write_at(offset, bytes)\n-    }\n-\n-    fn write_address(&mut self, address: Address, size: u8) -> Result<()> {\n-        match address {\n-            Address::Constant(val) => self.write_udata(val, size),\n-            Address::Symbol { symbol, addend } => {\n-                let offset = self.len() as u64;\n-                self.relocs.push(DebugReloc {\n-                    offset: offset as u32,\n-                    size,\n-                    name: DebugRelocName::Symbol(symbol),\n-                    addend: addend as i64,\n-                });\n-                self.write_udata(0, size)\n-            }\n-        }\n-    }\n-\n-    // TODO: implement write_eh_pointer\n-\n-    fn write_offset(&mut self, val: usize, section: SectionId, size: u8) -> Result<()> {\n-        let offset = self.len() as u32;\n-        self.relocs.push(DebugReloc {\n-            offset,\n-            size,\n-            name: DebugRelocName::Section(section),\n-            addend: val as i64,\n-        });\n-        self.write_udata(0, size)\n-    }\n-\n-    fn write_offset_at(\n-        &mut self,\n-        offset: usize,\n-        val: usize,\n-        section: SectionId,\n-        size: u8,\n-    ) -> Result<()> {\n-        self.relocs.push(DebugReloc {\n-            offset: offset as u32,\n-            size,\n-            name: DebugRelocName::Section(section),\n-            addend: val as i64,\n-        });\n-        self.write_udata_at(offset, 0, size)\n-    }\n-}"}, {"sha": "2b6dc9f669f30a124d4349ae4fb57e7f6339129e", "filename": "src/debuginfo/emit.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Femit.rs?ref=996bfd06ae37bd3bf3ba02903674608c3c4082e1", "patch": "@@ -0,0 +1,135 @@\n+use std::collections::HashMap;\n+\n+use gimli::write::{Address, AttributeValue, EndianVec, Result, Sections, Writer};\n+use gimli::{RunTimeEndian, SectionId};\n+\n+use crate::backend::WriteDebugInfo;\n+\n+use super::DebugContext;\n+\n+impl DebugContext<'_> {\n+    pub fn emit<P: WriteDebugInfo>(&mut self, product: &mut P) {\n+        let unit_range_list_id = self.dwarf.unit.ranges.add(self.unit_range_list.clone());\n+        let root = self.dwarf.unit.root();\n+        let root = self.dwarf.unit.get_mut(root);\n+        root.set(\n+            gimli::DW_AT_ranges,\n+            AttributeValue::RangeListRef(unit_range_list_id),\n+        );\n+\n+        let mut sections = Sections::new(WriterRelocate::new(self));\n+        self.dwarf.write(&mut sections).unwrap();\n+\n+        let mut section_map = HashMap::new();\n+        let _: Result<()> = sections.for_each_mut(|id, section| {\n+            if !section.writer.slice().is_empty() {\n+                let section_id = product.add_debug_section(id, section.writer.take());\n+                section_map.insert(id, section_id);\n+            }\n+            Ok(())\n+        });\n+\n+        let _: Result<()> = sections.for_each(|id, section| {\n+            if let Some(section_id) = section_map.get(&id) {\n+                for reloc in &section.relocs {\n+                    product.add_debug_reloc(&section_map, &self.symbols, section_id, reloc);\n+                }\n+            }\n+            Ok(())\n+        });\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub struct DebugReloc {\n+    pub offset: u32,\n+    pub size: u8,\n+    pub name: DebugRelocName,\n+    pub addend: i64,\n+}\n+\n+#[derive(Clone)]\n+pub enum DebugRelocName {\n+    Section(SectionId),\n+    Symbol(usize),\n+}\n+\n+#[derive(Clone)]\n+struct WriterRelocate {\n+    relocs: Vec<DebugReloc>,\n+    writer: EndianVec<RunTimeEndian>,\n+}\n+\n+impl WriterRelocate {\n+    fn new(ctx: &DebugContext) -> Self {\n+        WriterRelocate {\n+            relocs: Vec::new(),\n+            writer: EndianVec::new(ctx.endian),\n+        }\n+    }\n+}\n+\n+impl Writer for WriterRelocate {\n+    type Endian = RunTimeEndian;\n+\n+    fn endian(&self) -> Self::Endian {\n+        self.writer.endian()\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.writer.len()\n+    }\n+\n+    fn write(&mut self, bytes: &[u8]) -> Result<()> {\n+        self.writer.write(bytes)\n+    }\n+\n+    fn write_at(&mut self, offset: usize, bytes: &[u8]) -> Result<()> {\n+        self.writer.write_at(offset, bytes)\n+    }\n+\n+    fn write_address(&mut self, address: Address, size: u8) -> Result<()> {\n+        match address {\n+            Address::Constant(val) => self.write_udata(val, size),\n+            Address::Symbol { symbol, addend } => {\n+                let offset = self.len() as u64;\n+                self.relocs.push(DebugReloc {\n+                    offset: offset as u32,\n+                    size,\n+                    name: DebugRelocName::Symbol(symbol),\n+                    addend: addend as i64,\n+                });\n+                self.write_udata(0, size)\n+            }\n+        }\n+    }\n+\n+    // TODO: implement write_eh_pointer\n+\n+    fn write_offset(&mut self, val: usize, section: SectionId, size: u8) -> Result<()> {\n+        let offset = self.len() as u32;\n+        self.relocs.push(DebugReloc {\n+            offset,\n+            size,\n+            name: DebugRelocName::Section(section),\n+            addend: val as i64,\n+        });\n+        self.write_udata(0, size)\n+    }\n+\n+    fn write_offset_at(\n+        &mut self,\n+        offset: usize,\n+        val: usize,\n+        section: SectionId,\n+        size: u8,\n+    ) -> Result<()> {\n+        self.relocs.push(DebugReloc {\n+            offset: offset as u32,\n+            size,\n+            name: DebugRelocName::Section(section),\n+            addend: val as i64,\n+        });\n+        self.write_udata_at(offset, 0, size)\n+    }\n+}"}, {"sha": "e64344bfe6f23399442d85493da45762b3cfecf9", "filename": "src/debuginfo/line_info.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fline_info.rs?ref=996bfd06ae37bd3bf3ba02903674608c3c4082e1", "patch": "@@ -0,0 +1,145 @@\n+use crate::prelude::*;\n+\n+use syntax::source_map::FileName;\n+\n+use cranelift::codegen::binemit::CodeOffset;\n+\n+use gimli::write::{\n+    Address, AttributeValue, FileId, LineProgram, LineString, LineStringTable, UnitEntryId,\n+};\n+\n+fn line_program_add_file(\n+    line_program: &mut LineProgram,\n+    line_strings: &mut LineStringTable,\n+    file: &FileName,\n+) -> FileId {\n+    match file {\n+        FileName::Real(path) => {\n+            let dir_name = path.parent().unwrap().to_str().unwrap().as_bytes();\n+            let dir_id = if !dir_name.is_empty() {\n+                let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n+                line_program.add_directory(dir_name)\n+            } else {\n+                line_program.default_directory()\n+            };\n+            let file_name = LineString::new(\n+                path.file_name().unwrap().to_str().unwrap().as_bytes(),\n+                line_program.encoding(),\n+                line_strings,\n+            );\n+            line_program.add_file(file_name, dir_id, None)\n+        }\n+        // FIXME give more appropriate file names\n+        _ => {\n+            let dir_id = line_program.default_directory();\n+            let dummy_file_name = LineString::new(\n+                file.to_string().into_bytes(),\n+                line_program.encoding(),\n+                line_strings,\n+            );\n+            line_program.add_file(dummy_file_name, dir_id, None)\n+        }\n+    }\n+}\n+\n+impl<'tcx> DebugContext<'tcx> {\n+    pub(super) fn emit_location(&mut self, entry_id: UnitEntryId, span: Span) {\n+        let loc = self.tcx.sess.source_map().lookup_char_pos(span.lo());\n+\n+        let file_id = line_program_add_file(\n+            &mut self.dwarf.unit.line_program,\n+            &mut self.dwarf.line_strings,\n+            &loc.file.name,\n+        );\n+\n+        let entry = self.dwarf.unit.get_mut(entry_id);\n+\n+        entry.set(\n+            gimli::DW_AT_decl_file,\n+            AttributeValue::FileIndex(Some(file_id)),\n+        );\n+        entry.set(\n+            gimli::DW_AT_decl_line,\n+            AttributeValue::Udata(loc.line as u64),\n+        );\n+        // FIXME: probably omit this\n+        entry.set(\n+            gimli::DW_AT_decl_column,\n+            AttributeValue::Udata(loc.col.to_usize() as u64),\n+        );\n+    }\n+}\n+\n+impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n+    pub(crate) fn create_debug_lines(\n+        &mut self,\n+        context: &Context,\n+        isa: &dyn cranelift::codegen::isa::TargetIsa,\n+        source_info_set: &indexmap::IndexSet<(Span, mir::SourceScope)>,\n+    ) -> CodeOffset {\n+        let tcx = self.debug_context.tcx;\n+\n+        let line_program = &mut self.debug_context.dwarf.unit.line_program;\n+\n+        line_program.begin_sequence(Some(Address::Symbol {\n+            symbol: self.symbol,\n+            addend: 0,\n+        }));\n+\n+        let encinfo = isa.encoding_info();\n+        let func = &context.func;\n+        let mut ebbs = func.layout.ebbs().collect::<Vec<_>>();\n+        ebbs.sort_by_key(|ebb| func.offsets[*ebb]); // Ensure inst offsets always increase\n+\n+        let line_strings = &mut self.debug_context.dwarf.line_strings;\n+        let mut create_row_for_span = |line_program: &mut LineProgram, span: Span| {\n+            let loc = tcx.sess.source_map().lookup_char_pos(span.lo());\n+            let file_id = line_program_add_file(line_program, line_strings, &loc.file.name);\n+\n+            /*println!(\n+                \"srcloc {:>04X} {}:{}:{}\",\n+                line_program.row().address_offset,\n+                file.display(),\n+                loc.line,\n+                loc.col.to_u32()\n+            );*/\n+\n+            line_program.row().file = file_id;\n+            line_program.row().line = loc.line as u64;\n+            line_program.row().column = loc.col.to_u32() as u64 + 1;\n+            line_program.generate_row();\n+        };\n+\n+        let mut end = 0;\n+        for ebb in ebbs {\n+            for (offset, inst, size) in func.inst_offsets(ebb, &encinfo) {\n+                let srcloc = func.srclocs[inst];\n+                line_program.row().address_offset = offset as u64;\n+                if !srcloc.is_default() {\n+                    let source_info = *source_info_set.get_index(srcloc.bits() as usize).unwrap();\n+                    create_row_for_span(line_program, source_info.0);\n+                } else {\n+                    create_row_for_span(line_program, self.mir.span);\n+                }\n+                end = offset + size;\n+            }\n+        }\n+\n+        line_program.end_sequence(end as u64);\n+\n+        let entry = self.debug_context.dwarf.unit.get_mut(self.entry_id);\n+        entry.set(\n+            gimli::DW_AT_low_pc,\n+            AttributeValue::Address(Address::Symbol {\n+                symbol: self.symbol,\n+                addend: 0,\n+            }),\n+        );\n+        entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(end as u64));\n+\n+        self.debug_context\n+            .emit_location(self.entry_id, self.mir.span);\n+\n+        end\n+    }\n+}"}, {"sha": "bb3f26f9fee9d58009cbdec8bb732c1f86ffae83", "filename": "src/debuginfo/mod.rs", "status": "added", "additions": 434, "deletions": 0, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=996bfd06ae37bd3bf3ba02903674608c3c4082e1", "patch": "@@ -0,0 +1,434 @@\n+mod emit;\n+mod line_info;\n+\n+use crate::prelude::*;\n+\n+use cranelift::codegen::ir::{StackSlots, ValueLabel, ValueLoc};\n+use cranelift::codegen::isa::RegUnit;\n+use cranelift::codegen::ValueLocRange;\n+\n+use gimli::write::{\n+    self, Address, AttributeValue, DwarfUnit, Expression, LineProgram, LineString, Location,\n+    LocationList, Range, RangeList, UnitEntryId, Writer,\n+};\n+use gimli::{Encoding, Format, LineEncoding, Register, RunTimeEndian, X86_64};\n+\n+pub use emit::{DebugReloc, DebugRelocName};\n+\n+fn target_endian(tcx: TyCtxt) -> RunTimeEndian {\n+    use rustc::ty::layout::Endian;\n+\n+    match tcx.data_layout.endian {\n+        Endian::Big => RunTimeEndian::Big,\n+        Endian::Little => RunTimeEndian::Little,\n+    }\n+}\n+\n+pub struct DebugContext<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    endian: RunTimeEndian,\n+    symbols: indexmap::IndexMap<FuncId, String>,\n+\n+    dwarf: DwarfUnit,\n+    unit_range_list: RangeList,\n+\n+    types: HashMap<Ty<'tcx>, UnitEntryId>,\n+}\n+\n+impl<'tcx> DebugContext<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, address_size: u8) -> Self {\n+        let encoding = Encoding {\n+            format: Format::Dwarf32,\n+            // TODO: this should be configurable\n+            // macOS doesn't seem to support DWARF > 3\n+            version: 3,\n+            address_size,\n+        };\n+\n+        let mut dwarf = DwarfUnit::new(encoding);\n+\n+        // FIXME: how to get version when building out of tree?\n+        // Normally this would use option_env!(\"CFG_VERSION\").\n+        let producer = format!(\"cranelift fn (rustc version {})\", \"unknown version\");\n+        let comp_dir = tcx.sess.working_dir.0.to_string_lossy().into_owned();\n+        let name = match tcx.sess.local_crate_source_file {\n+            Some(ref path) => path.to_string_lossy().into_owned(),\n+            None => tcx.crate_name(LOCAL_CRATE).to_string(),\n+        };\n+\n+        let line_program = LineProgram::new(\n+            encoding,\n+            LineEncoding::default(),\n+            LineString::new(comp_dir.as_bytes(), encoding, &mut dwarf.line_strings),\n+            LineString::new(name.as_bytes(), encoding, &mut dwarf.line_strings),\n+            None,\n+        );\n+        dwarf.unit.line_program = line_program;\n+\n+        {\n+            let name = dwarf.strings.add(&*name);\n+            let comp_dir = dwarf.strings.add(&*comp_dir);\n+\n+            let root = dwarf.unit.root();\n+            let root = dwarf.unit.get_mut(root);\n+            root.set(\n+                gimli::DW_AT_producer,\n+                AttributeValue::StringRef(dwarf.strings.add(producer)),\n+            );\n+            root.set(\n+                gimli::DW_AT_language,\n+                AttributeValue::Language(gimli::DW_LANG_Rust),\n+            );\n+            root.set(gimli::DW_AT_name, AttributeValue::StringRef(name));\n+            root.set(gimli::DW_AT_comp_dir, AttributeValue::StringRef(comp_dir));\n+            root.set(\n+                gimli::DW_AT_low_pc,\n+                AttributeValue::Address(Address::Constant(0)),\n+            );\n+        }\n+\n+        DebugContext {\n+            tcx,\n+\n+            endian: target_endian(tcx),\n+            symbols: indexmap::IndexMap::new(),\n+\n+            dwarf,\n+            unit_range_list: RangeList(Vec::new()),\n+\n+            types: HashMap::new(),\n+        }\n+    }\n+\n+    fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n+        if let Some(type_id) = self.types.get(ty) {\n+            return *type_id;\n+        }\n+\n+        let new_entry = |dwarf: &mut DwarfUnit, tag| dwarf.unit.add(dwarf.unit.root(), tag);\n+\n+        let primitive = |dwarf: &mut DwarfUnit, ate| {\n+            let type_id = new_entry(dwarf, gimli::DW_TAG_base_type);\n+            let type_entry = dwarf.unit.get_mut(type_id);\n+            type_entry.set(gimli::DW_AT_encoding, AttributeValue::Encoding(ate));\n+            type_id\n+        };\n+\n+        let name = format!(\"{}\", ty);\n+        let layout = self.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n+\n+        let type_id = match ty.kind {\n+            ty::Bool => primitive(&mut self.dwarf, gimli::DW_ATE_boolean),\n+            ty::Char => primitive(&mut self.dwarf, gimli::DW_ATE_UTF),\n+            ty::Uint(_) => primitive(&mut self.dwarf, gimli::DW_ATE_unsigned),\n+            ty::Int(_) => primitive(&mut self.dwarf, gimli::DW_ATE_signed),\n+            ty::Float(_) => primitive(&mut self.dwarf, gimli::DW_ATE_float),\n+            ty::Ref(_, pointee_ty, mutbl)\n+            | ty::RawPtr(ty::TypeAndMut {\n+                ty: pointee_ty,\n+                mutbl,\n+            }) => {\n+                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_pointer_type);\n+\n+                // Ensure that type is inserted before recursing to avoid duplicates\n+                self.types.insert(ty, type_id);\n+\n+                let pointee = self.dwarf_ty(pointee_ty);\n+\n+                let type_entry = self.dwarf.unit.get_mut(type_id);\n+\n+                //type_entry.set(gimli::DW_AT_mutable, AttributeValue::Flag(mutbl == rustc::hir::Mutability::MutMutable));\n+                type_entry.set(gimli::DW_AT_type, AttributeValue::ThisUnitEntryRef(pointee));\n+\n+                type_id\n+            }\n+            ty::Adt(adt_def, _substs) if adt_def.is_struct() && !layout.is_unsized() => {\n+                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type);\n+\n+                // Ensure that type is inserted before recursing to avoid duplicates\n+                self.types.insert(ty, type_id);\n+\n+                let variant = adt_def.non_enum_variant();\n+\n+                for (field_idx, field_def) in variant.fields.iter().enumerate() {\n+                    let field_offset = layout.fields.offset(field_idx);\n+                    let field_layout = layout.field(&layout::LayoutCx {\n+                        tcx: self.tcx,\n+                        param_env: ParamEnv::reveal_all(),\n+                    }, field_idx).unwrap();\n+\n+                    let field_type = self.dwarf_ty(field_layout.ty);\n+\n+                    let field_id = self.dwarf.unit.add(type_id, gimli::DW_TAG_member);\n+                    let field_entry = self.dwarf.unit.get_mut(field_id);\n+\n+                    field_entry.set(gimli::DW_AT_name, AttributeValue::String(field_def.ident.as_str().to_string().into_bytes()));\n+                    field_entry.set(gimli::DW_AT_data_member_location, AttributeValue::Udata(field_offset.bytes()));\n+                    field_entry.set(gimli::DW_AT_type, AttributeValue::ThisUnitEntryRef(field_type));\n+                }\n+\n+                type_id\n+            }\n+            _ => new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type),\n+        };\n+\n+        let type_entry = self.dwarf.unit.get_mut(type_id);\n+\n+        type_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n+        type_entry.set(\n+            gimli::DW_AT_byte_size,\n+            AttributeValue::Udata(layout.size.bytes()),\n+        );\n+\n+        self.types.insert(ty, type_id);\n+\n+        type_id\n+    }\n+}\n+\n+pub struct FunctionDebugContext<'a, 'tcx> {\n+    debug_context: &'a mut DebugContext<'tcx>,\n+    entry_id: UnitEntryId,\n+    symbol: usize,\n+    instance: Instance<'tcx>,\n+    mir: &'tcx mir::Body<'tcx>,\n+}\n+\n+impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n+    pub fn new(\n+        debug_context: &'a mut DebugContext<'tcx>,\n+        instance: Instance<'tcx>,\n+        func_id: FuncId,\n+        name: &str,\n+    ) -> Self {\n+        let mir = *debug_context.tcx.instance_mir(instance.def);\n+\n+        let (symbol, _) = debug_context.symbols.insert_full(func_id, name.to_string());\n+\n+        // FIXME: add to appropriate scope intead of root\n+        let scope = debug_context.dwarf.unit.root();\n+\n+        let entry_id = debug_context\n+            .dwarf\n+            .unit\n+            .add(scope, gimli::DW_TAG_subprogram);\n+        let entry = debug_context.dwarf.unit.get_mut(entry_id);\n+        let name_id = debug_context.dwarf.strings.add(name);\n+        entry.set(\n+            gimli::DW_AT_linkage_name,\n+            AttributeValue::StringRef(name_id),\n+        );\n+\n+        FunctionDebugContext {\n+            debug_context,\n+            entry_id,\n+            symbol,\n+            instance,\n+            mir,\n+        }\n+    }\n+\n+    fn define_local(&mut self, name: String, ty: Ty<'tcx>) -> UnitEntryId {\n+        let ty = self.debug_context.tcx.subst_and_normalize_erasing_regions(\n+            self.instance.substs,\n+            ty::ParamEnv::reveal_all(),\n+            &ty,\n+        );\n+        let dw_ty = self.debug_context.dwarf_ty(ty);\n+\n+        let var_id = self\n+            .debug_context\n+            .dwarf\n+            .unit\n+            .add(self.entry_id, gimli::DW_TAG_variable);\n+        let var_entry = self.debug_context.dwarf.unit.get_mut(var_id);\n+\n+        var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n+        var_entry.set(gimli::DW_AT_type, AttributeValue::ThisUnitEntryRef(dw_ty));\n+\n+        var_id\n+    }\n+\n+    pub fn define(\n+        &mut self,\n+        context: &Context,\n+        isa: &dyn cranelift::codegen::isa::TargetIsa,\n+        source_info_set: &indexmap::IndexSet<(Span, mir::SourceScope)>,\n+        local_map: HashMap<mir::Local, CPlace<'tcx>>,\n+    ) {\n+        let end = self.create_debug_lines(context, isa, source_info_set);\n+\n+        self.debug_context\n+            .unit_range_list\n+            .0\n+            .push(Range::StartLength {\n+                begin: Address::Symbol {\n+                    symbol: self.symbol,\n+                    addend: 0,\n+                },\n+                length: end as u64,\n+            });\n+\n+        // FIXME make it more reliable and implement scopes before re-enabling this.\n+        if false {\n+            let value_labels_ranges = context.build_value_labels_ranges(isa).unwrap();\n+\n+            for (local, _local_decl) in self.mir.local_decls.iter_enumerated() {\n+                let var_id = self.define_local(format!(\"{:?}\", local), &self.mir.local_decls[local].ty);\n+\n+                let location = place_location(\n+                    self,\n+                    context,\n+                    &local_map,\n+                    &value_labels_ranges,\n+                    Place {\n+                        base: PlaceBase::Local(local),\n+                        projection: ty::List::empty(),\n+                    },\n+                );\n+\n+                let var_entry = self.debug_context.dwarf.unit.get_mut(var_id);\n+                var_entry.set(gimli::DW_AT_location, location);\n+            }\n+        }\n+\n+        // FIXME create locals for all entries in mir.var_debug_info\n+    }\n+}\n+\n+fn place_location<'a, 'tcx>(\n+    func_debug_ctx: &mut FunctionDebugContext<'a, 'tcx>,\n+    context: &Context,\n+    local_map: &HashMap<mir::Local, CPlace<'tcx>>,\n+    value_labels_ranges: &HashMap<ValueLabel, Vec<ValueLocRange>>,\n+    place: Place<'tcx>,\n+) -> AttributeValue {\n+    assert!(place.projection.is_empty()); // FIXME implement them\n+    let cplace = match place.base {\n+        PlaceBase::Local(local) => local_map[&local],\n+        PlaceBase::Static(_) => bug!(\"Unenforced invariant that the place is based on a Local violated: {:?}\", place),\n+    };\n+\n+    match cplace.inner() {\n+        CPlaceInner::Var(local) => {\n+            let value_label = cranelift::codegen::ir::ValueLabel::from_u32(local.as_u32());\n+            if let Some(value_loc_ranges) = value_labels_ranges.get(&value_label) {\n+                let loc_list = LocationList(\n+                    value_loc_ranges\n+                        .iter()\n+                        .map(|value_loc_range| Location::StartEnd {\n+                            begin: Address::Symbol {\n+                                symbol: func_debug_ctx.symbol,\n+                                addend: i64::from(value_loc_range.start),\n+                            },\n+                            end: Address::Symbol {\n+                                symbol: func_debug_ctx.symbol,\n+                                addend: i64::from(value_loc_range.end),\n+                            },\n+                            data: Expression(\n+                                translate_loc(value_loc_range.loc, &context.func.stack_slots).unwrap(),\n+                            ),\n+                        })\n+                        .collect(),\n+                );\n+                let loc_list_id = func_debug_ctx.debug_context.dwarf.unit.locations.add(loc_list);\n+\n+                AttributeValue::LocationListRef(loc_list_id)\n+            } else {\n+                // FIXME set value labels for unused locals\n+\n+                AttributeValue::Exprloc(Expression(vec![]))\n+            }\n+        }\n+        CPlaceInner::Addr(_, _) => {\n+            // FIXME implement this (used by arguments and returns)\n+\n+            AttributeValue::Exprloc(Expression(vec![]))\n+        }\n+        CPlaceInner::Stack(stack_slot) => {\n+            AttributeValue::Exprloc(Expression(translate_loc(ValueLoc::Stack(*stack_slot), &context.func.stack_slots).unwrap()))\n+        }\n+        CPlaceInner::NoPlace => AttributeValue::Exprloc(Expression(vec![])),\n+    }\n+}\n+\n+\n+\n+\n+\n+// Adapted from https://github.com/CraneStation/wasmtime/blob/5a1845b4caf7a5dba8eda1fef05213a532ed4259/crates/debug/src/transform/expression.rs#L59-L137\n+\n+fn map_reg(reg: RegUnit) -> Register {\n+    static mut REG_X86_MAP: Option<HashMap<RegUnit, Register>> = None;\n+    // FIXME lazy initialization?\n+    unsafe {\n+        if REG_X86_MAP.is_none() {\n+            REG_X86_MAP = Some(HashMap::new());\n+        }\n+        if let Some(val) = REG_X86_MAP.as_mut().unwrap().get(&reg) {\n+            return *val;\n+        }\n+        let result = match reg {\n+            0 => X86_64::RAX,\n+            1 => X86_64::RCX,\n+            2 => X86_64::RDX,\n+            3 => X86_64::RBX,\n+            4 => X86_64::RSP,\n+            5 => X86_64::RBP,\n+            6 => X86_64::RSI,\n+            7 => X86_64::RDI,\n+            8 => X86_64::R8,\n+            9 => X86_64::R9,\n+            10 => X86_64::R10,\n+            11 => X86_64::R11,\n+            12 => X86_64::R12,\n+            13 => X86_64::R13,\n+            14 => X86_64::R14,\n+            15 => X86_64::R15,\n+            16 => X86_64::XMM0,\n+            17 => X86_64::XMM1,\n+            18 => X86_64::XMM2,\n+            19 => X86_64::XMM3,\n+            20 => X86_64::XMM4,\n+            21 => X86_64::XMM5,\n+            22 => X86_64::XMM6,\n+            23 => X86_64::XMM7,\n+            24 => X86_64::XMM8,\n+            25 => X86_64::XMM9,\n+            26 => X86_64::XMM10,\n+            27 => X86_64::XMM11,\n+            28 => X86_64::XMM12,\n+            29 => X86_64::XMM13,\n+            30 => X86_64::XMM14,\n+            31 => X86_64::XMM15,\n+            _ => panic!(\"unknown x86_64 register {}\", reg),\n+        };\n+        REG_X86_MAP.as_mut().unwrap().insert(reg, result);\n+        result\n+    }\n+}\n+\n+fn translate_loc(loc: ValueLoc, stack_slots: &StackSlots) -> Option<Vec<u8>> {\n+    match loc {\n+        ValueLoc::Reg(reg) => {\n+            let machine_reg = map_reg(reg).0 as u8;\n+            assert!(machine_reg <= 32); // FIXME\n+            Some(vec![gimli::constants::DW_OP_reg0.0 + machine_reg])\n+        }\n+        ValueLoc::Stack(ss) => {\n+            if let Some(ss_offset) = stack_slots[ss].offset {\n+                let endian = gimli::RunTimeEndian::Little;\n+                let mut writer = write::EndianVec::new(endian);\n+                writer\n+                    .write_u8(gimli::constants::DW_OP_breg0.0 + X86_64::RBP.0 as u8)\n+                    .expect(\"bp wr\");\n+                writer.write_sleb128(ss_offset as i64 + 16).expect(\"ss wr\");\n+                let buf = writer.into_vec();\n+                return Some(buf);\n+            }\n+            None\n+        }\n+        _ => None,\n+    }\n+}"}, {"sha": "840b4bf0db29e4b44a45826fd749b592a7e5879b", "filename": "src/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=996bfd06ae37bd3bf3ba02903674608c3c4082e1", "patch": "@@ -625,6 +625,7 @@ pub fn codegen_intrinsic_call<'tcx>(\n                         }\n                         _ => panic!(\"clif_type returned {}\", clif_ty),\n                     };\n+                    fx.bcx.set_val_label(val, cranelift::codegen::ir::ValueLabel::from_u32(var.as_u32()));\n                     fx.bcx.def_var(mir_var(var), val);\n                 }\n                 _ => {\n@@ -656,6 +657,7 @@ pub fn codegen_intrinsic_call<'tcx>(\n                         }\n                         _ => panic!(\"clif_type returned {}\", clif_ty),\n                     };\n+                    fx.bcx.set_val_label(val, cranelift::codegen::ir::ValueLabel::from_u32(var.as_u32()));\n                     fx.bcx.def_var(mir_var(var), val);\n                 }\n                 CPlaceInner::Addr(_, _) | CPlaceInner::Stack(_) => {"}, {"sha": "64359f3899f5385361e12e6f2f4f051feef5baa0", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=996bfd06ae37bd3bf3ba02903674608c3c4082e1", "patch": "@@ -74,8 +74,8 @@ pub struct CommentWriter {\n \n impl CommentWriter {\n     pub fn new<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n-        CommentWriter {\n-            global_comments: vec![\n+        let mut global_comments = if cfg!(debug_assertions) {\n+            vec![\n                 format!(\"symbol {}\", tcx.symbol_name(instance).name.as_str()),\n                 format!(\"instance {:?}\", instance),\n                 format!(\n@@ -86,7 +86,13 @@ impl CommentWriter {\n                     )\n                 ),\n                 String::new(),\n-            ],\n+            ]\n+        } else {\n+            vec![]\n+        };\n+\n+        CommentWriter {\n+            global_comments,\n             entity_comments: HashMap::new(),\n             inst_comments: HashMap::new(),\n         }"}, {"sha": "64fd30def0687a142a09d06b2cca6c09fa6e327d", "filename": "src/value_and_place.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996bfd06ae37bd3bf3ba02903674608c3c4082e1/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=996bfd06ae37bd3bf3ba02903674608c3c4082e1", "patch": "@@ -299,7 +299,11 @@ impl<'tcx> CPlace<'tcx> {\n     pub fn to_cvalue(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> CValue<'tcx> {\n         let layout = self.layout();\n         match self.inner {\n-            CPlaceInner::Var(var) => CValue::by_val(fx.bcx.use_var(mir_var(var)), layout),\n+            CPlaceInner::Var(var) => {\n+                let val = fx.bcx.use_var(mir_var(var));\n+                fx.bcx.set_val_label(val, cranelift::codegen::ir::ValueLabel::from_u32(var.as_u32()));\n+                CValue::by_val(val, layout)\n+            }\n             CPlaceInner::Addr(addr, extra) => {\n                 assert!(extra.is_none(), \"unsized values are not yet supported\");\n                 CValue::by_ref(addr, layout)\n@@ -419,6 +423,7 @@ impl<'tcx> CPlace<'tcx> {\n         let addr = match self.inner {\n             CPlaceInner::Var(var) => {\n                 let data = from.load_scalar(fx);\n+                fx.bcx.set_val_label(data, cranelift::codegen::ir::ValueLabel::from_u32(var.as_u32()));\n                 fx.bcx.def_var(mir_var(var), data);\n                 return;\n             }"}, {"sha": "4f393ad179720cf83bea794250d515f5b9587eba", "filename": "test.sh", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/996bfd06ae37bd3bf3ba02903674608c3c4082e1/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/996bfd06ae37bd3bf3ba02903674608c3c4082e1/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=996bfd06ae37bd3bf3ba02903674608c3c4082e1", "patch": "@@ -31,11 +31,16 @@ $RUSTC example/mini_core.rs --crate-name mini_core --crate-type lib,dylib\n echo \"[BUILD] example\"\n $RUSTC example/example.rs --crate-type lib\n \n-JIT_ARGS=\"abc bcd\" jit mini_core_hello_world example/mini_core_hello_world.rs\n+#JIT_ARGS=\"abc bcd\" jit mini_core_hello_world example/mini_core_hello_world.rs\n \n echo \"[AOT] mini_core_hello_world\"\n-$RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin\n+$RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin -g\n ./target/out/mini_core_hello_world abc bcd\n+if lldb -v; then\n+(echo \"break set -n main\"; echo \"run\"; sleep 1; echo \"si -c 10\"; sleep 1; echo \"frame variable\") | lldb -- ./target/out/mini_core_hello_world abc bcd\n+fi\n+\n+exit 1\n \n echo \"[AOT] arbitrary_self_types_pointers_and_wrappers\"\n $RUSTC example/arbitrary_self_types_pointers_and_wrappers.rs --crate-name arbitrary_self_types_pointers_and_wrappers --crate-type bin"}]}