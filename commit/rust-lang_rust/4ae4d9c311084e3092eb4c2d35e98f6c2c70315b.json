{"sha": "4ae4d9c311084e3092eb4c2d35e98f6c2c70315b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZTRkOWMzMTEwODRlMzA5MmViNGMyZDM1ZTk4ZjZjMmM3MDMxNWI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-04T20:32:02Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-07T11:35:41Z"}, "message": "Add some more tests", "tree": {"sha": "911bedc5455d984dc2c8720b2b1b04852ded726b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/911bedc5455d984dc2c8720b2b1b04852ded726b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ae4d9c311084e3092eb4c2d35e98f6c2c70315b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ae4d9c311084e3092eb4c2d35e98f6c2c70315b", "html_url": "https://github.com/rust-lang/rust/commit/4ae4d9c311084e3092eb4c2d35e98f6c2c70315b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ae4d9c311084e3092eb4c2d35e98f6c2c70315b/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a73b424e3bcf3e211f87d5a9b175a89231848c6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a73b424e3bcf3e211f87d5a9b175a89231848c6d", "html_url": "https://github.com/rust-lang/rust/commit/a73b424e3bcf3e211f87d5a9b175a89231848c6d"}], "stats": {"total": 205, "additions": 205, "deletions": 0}, "files": [{"sha": "cb5540cb610855d1510be7242962f57981bdc453", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/4ae4d9c311084e3092eb4c2d35e98f6c2c70315b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae4d9c311084e3092eb4c2d35e98f6c2c70315b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=4ae4d9c311084e3092eb4c2d35e98f6c2c70315b", "patch": "@@ -3643,6 +3643,211 @@ fn test<T: Trait1<Type = u32>>(x: T) {\n     \"###\n     );\n }\n+\n+#[test]\n+fn where_clause_trait_in_scope_for_method_resolution() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+mod foo {\n+    trait Trait {\n+        fn foo(&self) -> u32 {}\n+    }\n+}\n+\n+fn test<T: foo::Trait>(x: T) {\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    // FIXME should be u32\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn super_trait_method_resolution() {\n+    assert_snapshot!(\n+        infer(r#\"\n+mod foo {\n+    trait SuperTrait {\n+        fn foo(&self) -> u32 {}\n+    }\n+}\n+trait Trait1: SuperTrait {}\n+trait Trait2 where Self: SuperTrait {}\n+\n+fn test<T: Trait1, U: Trait2>(x: T, y: U) {\n+    x.foo();\n+    y.foo();\n+}\n+\"#),\n+        @r###\"\n+    [50; 54) 'self': &Self\n+    [63; 65) '{}': ()\n+    [172; 173) 'x': T\n+    [178; 179) 'y': U\n+    [184; 213) '{     ...o(); }': ()\n+    [190; 191) 'x': T\n+    [190; 197) 'x.foo()': {unknown}\n+    [203; 204) 'y': U\n+    [203; 210) 'y.foo()': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn super_trait_assoc_type_bounds() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait SuperTrait { type Type; }\n+trait Trait where Self: SuperTrait {}\n+\n+fn get2<U, T: Trait<Type = U>>(t: T) -> U {}\n+fn set<T: Trait<Type = u64>>(t: T) -> T {t}\n+\n+struct S<T>;\n+impl<T> SuperTrait for S<T> { type Type = T; }\n+impl<T> Trait for S<T> {}\n+\n+fn test() {\n+    get2(set(S));\n+}\n+\"#),\n+        @r###\"\n+    [103; 104) 't': T\n+    [114; 116) '{}': ()\n+    [146; 147) 't': T\n+    [157; 160) '{t}': T\n+    [158; 159) 't': T\n+    [259; 280) '{     ...S)); }': ()\n+    [265; 269) 'get2': fn get2<{unknown}, S<{unknown}>>(T) -> U\n+    [265; 277) 'get2(set(S))': {unknown}\n+    [270; 273) 'set': fn set<S<{unknown}>>(T) -> T\n+    [270; 276) 'set(S)': S<{unknown}>\n+    [274; 275) 'S': S<{unknown}>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn fn_trait() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait FnOnce<Args> {\n+    type Output;\n+\n+    fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+fn test<F: FnOnce(u32, u64) -> u128>(f: F) {\n+    f.call_once((1, 2));\n+}\n+\"#),\n+        @r###\"\n+    [57; 61) 'self': Self\n+    [63; 67) 'args': Args\n+    [132; 133) 'f': F\n+    [138; 166) '{     ...2)); }': ()\n+    [144; 145) 'f': F\n+    [144; 163) 'f.call...1, 2))': {unknown}\n+    [156; 162) '(1, 2)': (i32, i32)\n+    [157; 158) '1': i32\n+    [160; 161) '2': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn closure_1() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+\n+enum Option<T> { Some(T), None }\n+impl<T> Option<T> {\n+    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> U {}\n+}\n+\n+fn test() {\n+    let x = Option::Some(1i32);\n+    x.map(|v| v + 1);\n+    x.map(|_v| 1u64);\n+    let y: Option<i64> = x.map(|_v| 1);\n+}\n+\"#),\n+        @r###\"\n+    [128; 132) 'self': Option<T>\n+    [134; 135) 'f': F\n+    [145; 147) '{}': ()\n+    [161; 280) '{     ... 1); }': ()\n+    [171; 172) 'x': Option<i32>\n+    [175; 187) 'Option::Some': Some<i32>(T) -> Option<T>\n+    [175; 193) 'Option...(1i32)': Option<i32>\n+    [188; 192) '1i32': i32\n+    [199; 200) 'x': Option<i32>\n+    [199; 215) 'x.map(...v + 1)': {unknown}\n+    [205; 214) '|v| v + 1': {unknown}\n+    [206; 207) 'v': {unknown}\n+    [209; 210) 'v': {unknown}\n+    [209; 214) 'v + 1': i32\n+    [213; 214) '1': i32\n+    [221; 222) 'x': Option<i32>\n+    [221; 237) 'x.map(... 1u64)': {unknown}\n+    [227; 236) '|_v| 1u64': {unknown}\n+    [228; 230) '_v': {unknown}\n+    [232; 236) '1u64': u64\n+    [247; 248) 'y': Option<i64>\n+    [264; 265) 'x': Option<i32>\n+    [264; 277) 'x.map(|_v| 1)': Option<i64>\n+    [270; 276) '|_v| 1': {unknown}\n+    [271; 273) '_v': {unknown}\n+    [275; 276) '1': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn closure_2() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+\n+fn test<F: FnOnce(u32) -> u64>(f: F) {\n+    f(1);\n+    let g = |v| v + 1;\n+    g(1u64);\n+    let h = |v| 1u128 + v;\n+}\n+\"#),\n+        @r###\"\n+    [73; 74) 'f': F\n+    [79; 155) '{     ...+ v; }': ()\n+    [85; 86) 'f': F\n+    [85; 89) 'f(1)': {unknown}\n+    [87; 88) '1': i32\n+    [99; 100) 'g': {unknown}\n+    [103; 112) '|v| v + 1': {unknown}\n+    [104; 105) 'v': {unknown}\n+    [107; 108) 'v': {unknown}\n+    [107; 112) 'v + 1': i32\n+    [111; 112) '1': i32\n+    [118; 119) 'g': {unknown}\n+    [118; 125) 'g(1u64)': {unknown}\n+    [120; 124) '1u64': u64\n+    [135; 136) 'h': {unknown}\n+    [139; 152) '|v| 1u128 + v': {unknown}\n+    [140; 141) 'v': u128\n+    [143; 148) '1u128': u128\n+    [143; 152) '1u128 + v': u128\n+    [151; 152) 'v': u128\n+    \"###\n+    );\n+}\n+\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();"}]}