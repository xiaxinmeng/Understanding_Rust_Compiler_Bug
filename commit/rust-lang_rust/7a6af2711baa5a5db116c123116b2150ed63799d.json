{"sha": "7a6af2711baa5a5db116c123116b2150ed63799d", "node_id": "C_kwDOAAsO6NoAKDdhNmFmMjcxMWJhYTVhNWRiMTE2YzEyMzExNmIyMTUwZWQ2Mzc5OWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-15T22:53:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-15T22:53:03Z"}, "message": "Auto merge of #105760 - matthiaskrgr:rollup-r8beo9w, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #105481 (Start improving monomorphization items stats)\n - #105674 (Point at method chains on `E0271` errors)\n - #105679 (Suggest constraining type parameter with `Clone`)\n - #105694 (Don't create dummy if val has escaping bounds var)\n - #105727 (Tweak output for bare `dyn Trait` in arguments)\n - #105739 (Migrate Jump to def links background to CSS variable)\n - #105743 (`SimplifiedType` cleanups)\n - #105758 (Move `TypeckResults` to separate module)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "57c23f9217e8b19a812e9180a937eb06f5a6398e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57c23f9217e8b19a812e9180a937eb06f5a6398e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a6af2711baa5a5db116c123116b2150ed63799d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a6af2711baa5a5db116c123116b2150ed63799d", "html_url": "https://github.com/rust-lang/rust/commit/7a6af2711baa5a5db116c123116b2150ed63799d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a6af2711baa5a5db116c123116b2150ed63799d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "html_url": "https://github.com/rust-lang/rust/commit/ec56537c4325ce5b798fc3628cbdd48ba4949ae5"}, {"sha": "2e03ff1b35fa1a8792fbd187188415111d972b7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e03ff1b35fa1a8792fbd187188415111d972b7a", "html_url": "https://github.com/rust-lang/rust/commit/2e03ff1b35fa1a8792fbd187188415111d972b7a"}], "stats": {"total": 2341, "additions": 1345, "deletions": 996}, "files": [{"sha": "243d10bfa062150bf9bda530541b8f235d35ceae", "filename": "compiler/rustc_error_messages/locales/en-US/monomorphize.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -21,3 +21,6 @@ monomorphize_large_assignments =\n     moving {$size} bytes\n     .label = value moved from here\n     .note = The current maximum size is {$limit}, but it can be customized with the move_size_limit attribute: `#![move_size_limit = \"...\"]`\n+\n+monomorphize_couldnt_dump_mono_stats =\n+    unexpected error occurred while dumping monomorphization stats: {$error}"}, {"sha": "407d6ac8544c211a8cce00fa74b0cfb983bddbea", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -13,7 +13,9 @@ use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer;\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Binder, DefIdTree, IsSuggestable, Ty};\n+use rustc_middle::ty::{\n+    self, suggest_constraining_type_params, Binder, DefIdTree, IsSuggestable, ToPredicate, Ty,\n+};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -1276,15 +1278,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             && !results.expr_adjustments(callee_expr).iter().any(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(..)))\n             // Check that we're in fact trying to clone into the expected type\n             && self.can_coerce(*pointee_ty, expected_ty)\n+            && let trait_ref = ty::Binder::dummy(self.tcx.mk_trait_ref(clone_trait_did, [expected_ty]))\n             // And the expected type doesn't implement `Clone`\n             && !self.predicate_must_hold_considering_regions(&traits::Obligation::new(\n                 self.tcx,\n                 traits::ObligationCause::dummy(),\n                 self.param_env,\n-                ty::Binder::dummy(self.tcx.mk_trait_ref(\n-                    clone_trait_did,\n-                    [expected_ty],\n-                )),\n+                trait_ref,\n             ))\n         {\n             diag.span_note(\n@@ -1293,6 +1293,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     \"`{expected_ty}` does not implement `Clone`, so `{found_ty}` was cloned instead\"\n                 ),\n             );\n+            let owner = self.tcx.hir().enclosing_body_owner(expr.hir_id);\n+            if let ty::Param(param) = expected_ty.kind()\n+                && let Some(generics) = self.tcx.hir().get_generics(owner)\n+            {\n+                suggest_constraining_type_params(\n+                    self.tcx,\n+                    generics,\n+                    diag,\n+                    vec![(param.name.as_str(), \"Clone\", Some(clone_trait_did))].into_iter(),\n+                );\n+            } else {\n+                self.suggest_derive(diag, &[(trait_ref.to_predicate(self.tcx), None, None)]);\n+            }\n         }\n     }\n "}, {"sha": "63cec9216eb89fa70f262db6c73cb57b4eee1d6b", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -25,7 +25,7 @@ use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKin\n use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n-use rustc_middle::ty::print::with_crate_prefix;\n+use rustc_middle::ty::print::{with_crate_prefix, with_forced_trimmed_paths};\n use rustc_middle::ty::{self, DefIdTree, GenericArgKind, Ty, TyCtxt, TypeVisitable};\n use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -270,7 +270,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let tcx = self.tcx;\n \n                 let rcvr_ty = self.resolve_vars_if_possible(rcvr_ty);\n-                let ty_str = self.ty_to_string(rcvr_ty);\n+                let ty_str = with_forced_trimmed_paths!(self.ty_to_string(rcvr_ty));\n                 let is_method = mode == Mode::MethodCall;\n                 let item_kind = if is_method {\n                     \"method\"\n@@ -563,7 +563,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let term = pred.skip_binder().term;\n \n                                 let obligation = format!(\"{} = {}\", projection_ty, term);\n-                                let quiet = format!(\"{} = {}\", quiet_projection_ty, term);\n+                                let quiet = with_forced_trimmed_paths!(format!(\n+                                    \"{} = {}\",\n+                                    quiet_projection_ty, term\n+                                ));\n \n                                 bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n                                 Some((obligation, projection_ty.self_ty()))\n@@ -573,7 +576,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n                                 let obligation = format!(\"{}: {}\", self_ty, path);\n-                                let quiet = format!(\"_: {}\", path);\n+                                let quiet = with_forced_trimmed_paths!(format!(\"_: {}\", path));\n                                 bound_span_label(self_ty, &obligation, &quiet);\n                                 Some((obligation, self_ty))\n                             }\n@@ -796,7 +799,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 (None, None)\n                             };\n                         let primary_message = primary_message.unwrap_or_else(|| format!(\n-                            \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, but its trait bounds were not satisfied\"\n+                            \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, \\\n+                             but its trait bounds were not satisfied\"\n                         ));\n                         err.set_primary_message(&primary_message);\n                         if let Some(label) = label {\n@@ -1848,7 +1852,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.suggest_derive(err, &preds);\n     }\n \n-    fn suggest_derive(\n+    pub fn suggest_derive(\n         &self,\n         err: &mut Diagnostic,\n         unsatisfied_predicates: &[("}, {"sha": "1e8d5f7eae87a8881edadb729794f43e43fc9a9e", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -200,6 +200,15 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::GlobalAsm(..) => LOCAL_CRATE,\n         }\n     }\n+\n+    /// Returns the item's `DefId`\n+    pub fn def_id(&self) -> DefId {\n+        match *self {\n+            MonoItem::Fn(Instance { def, .. }) => def.def_id(),\n+            MonoItem::Static(def_id) => def_id,\n+            MonoItem::GlobalAsm(item_id) => item_id.owner_id.to_def_id(),\n+        }\n+    }\n }\n \n impl<'tcx> fmt::Display for MonoItem<'tcx> {"}, {"sha": "173c5ed4feef0f9de96add81d3ddf7094fdacc5d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 11, "deletions": 680, "changes": 691, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -4,8 +4,7 @@\n \n use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKindStruct};\n-use crate::hir::place::Place as HirPlace;\n-use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n+use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::struct_lint_level;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_lifetime;\n@@ -18,13 +17,13 @@ use crate::thir::Thir;\n use crate::traits;\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n-    self, AdtDef, AdtDefData, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n-    ClosureSizeProfileData, Const, ConstS, DefIdTree, FloatTy, FloatVar, FloatVid,\n-    GenericParamDefKind, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n-    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, Region, RegionKind, ReprOptions,\n-    TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, UintTy, Visibility,\n+    self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstS, DefIdTree, FloatTy, FloatVar,\n+    FloatVid, GenericParamDefKind, ImplPolarity, InferTy, IntTy, IntVar, IntVid, List, ParamConst,\n+    ParamTy, PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, Region, RegionKind,\n+    ReprOptions, TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, TypeckResults, UintTy,\n+    Visibility,\n };\n-use crate::ty::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef, UserSubsts};\n+use crate::ty::{GenericArg, InternalSubsts, SubstsRef};\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -35,25 +34,20 @@ use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, WorkerLocal};\n-use rustc_data_structures::unord::UnordSet;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{\n     DecorateLint, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap, LOCAL_CRATE};\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n-use rustc_hir::hir_id::OwnerId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n-    Constness, ExprKind, HirId, ImplItemKind, ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet,\n-    Node, TraitCandidate, TraitItemKind,\n+    Constness, ExprKind, HirId, ImplItemKind, ItemKind, Node, TraitCandidate, TraitItemKind,\n };\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n-use rustc_middle::mir::FakeReadCause;\n use rustc_query_system::dep_graph::DepNodeIndex;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n@@ -75,16 +69,13 @@ use rustc_type_ir::{DynKind, InternAs, InternIteratorElement, Interner, TypeFlag\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n-use std::collections::hash_map::{self, Entry};\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter;\n use std::mem;\n use std::ops::{Bound, Deref};\n use std::sync::Arc;\n \n-use super::{ImplPolarity, RvalueScopes};\n-\n pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n     fn new(sess: &'tcx Session, data: Mmap, start_pos: usize) -> Self\n@@ -284,666 +275,6 @@ pub struct CommonConsts<'tcx> {\n     pub unit: Const<'tcx>,\n }\n \n-pub struct LocalTableInContext<'a, V> {\n-    hir_owner: OwnerId,\n-    data: &'a ItemLocalMap<V>,\n-}\n-\n-/// Validate that the given HirId (respectively its `local_id` part) can be\n-/// safely used as a key in the maps of a TypeckResults. For that to be\n-/// the case, the HirId must have the same `owner` as all the other IDs in\n-/// this table (signified by `hir_owner`). Otherwise the HirId\n-/// would be in a different frame of reference and using its `local_id`\n-/// would result in lookup errors, or worse, in silently wrong data being\n-/// stored/returned.\n-#[inline]\n-fn validate_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n-    if hir_id.owner != hir_owner {\n-        invalid_hir_id_for_typeck_results(hir_owner, hir_id);\n-    }\n-}\n-\n-#[cold]\n-#[inline(never)]\n-fn invalid_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n-    ty::tls::with(|tcx| {\n-        bug!(\n-            \"node {} with HirId::owner {:?} cannot be placed in TypeckResults with hir_owner {:?}\",\n-            tcx.hir().node_to_string(hir_id),\n-            hir_id.owner,\n-            hir_owner\n-        )\n-    });\n-}\n-\n-impl<'a, V> LocalTableInContext<'a, V> {\n-    pub fn contains_key(&self, id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.contains_key(&id.local_id)\n-    }\n-\n-    pub fn get(&self, id: hir::HirId) -> Option<&V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.get(&id.local_id)\n-    }\n-\n-    pub fn iter(&self) -> hash_map::Iter<'_, hir::ItemLocalId, V> {\n-        self.data.iter()\n-    }\n-}\n-\n-impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n-    type Output = V;\n-\n-    fn index(&self, key: hir::HirId) -> &V {\n-        self.get(key).expect(\"LocalTableInContext: key not found\")\n-    }\n-}\n-\n-pub struct LocalTableInContextMut<'a, V> {\n-    hir_owner: OwnerId,\n-    data: &'a mut ItemLocalMap<V>,\n-}\n-\n-impl<'a, V> LocalTableInContextMut<'a, V> {\n-    pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.get_mut(&id.local_id)\n-    }\n-\n-    pub fn entry(&mut self, id: hir::HirId) -> Entry<'_, hir::ItemLocalId, V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.entry(id.local_id)\n-    }\n-\n-    pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.insert(id.local_id, val)\n-    }\n-\n-    pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.remove(&id.local_id)\n-    }\n-}\n-\n-/// Whenever a value may be live across a generator yield, the type of that value winds up in the\n-/// `GeneratorInteriorTypeCause` struct. This struct adds additional information about such\n-/// captured types that can be useful for diagnostics. In particular, it stores the span that\n-/// caused a given type to be recorded, along with the scope that enclosed the value (which can\n-/// be used to find the await that the value is live across).\n-///\n-/// For example:\n-///\n-/// ```ignore (pseudo-Rust)\n-/// async move {\n-///     let x: T = expr;\n-///     foo.await\n-///     ...\n-/// }\n-/// ```\n-///\n-/// Here, we would store the type `T`, the span of the value `x`, the \"scope-span\" for\n-/// the scope that contains `x`, the expr `T` evaluated from, and the span of `foo.await`.\n-#[derive(TyEncodable, TyDecodable, Clone, Debug, Eq, Hash, PartialEq, HashStable)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct GeneratorInteriorTypeCause<'tcx> {\n-    /// Type of the captured binding.\n-    pub ty: Ty<'tcx>,\n-    /// Span of the binding that was captured.\n-    pub span: Span,\n-    /// Span of the scope of the captured binding.\n-    pub scope_span: Option<Span>,\n-    /// Span of `.await` or `yield` expression.\n-    pub yield_span: Span,\n-    /// Expr which the type evaluated from.\n-    pub expr: Option<hir::HirId>,\n-}\n-\n-// This type holds diagnostic information on generators and async functions across crate boundaries\n-// and is used to provide better error messages\n-#[derive(TyEncodable, TyDecodable, Clone, Debug, HashStable)]\n-pub struct GeneratorDiagnosticData<'tcx> {\n-    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n-    pub hir_owner: DefId,\n-    pub nodes_types: ItemLocalMap<Ty<'tcx>>,\n-    pub adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n-}\n-\n-#[derive(TyEncodable, TyDecodable, Debug, HashStable)]\n-pub struct TypeckResults<'tcx> {\n-    /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n-    pub hir_owner: OwnerId,\n-\n-    /// Resolved definitions for `<T>::X` associated paths and\n-    /// method calls, including those of overloaded operators.\n-    type_dependent_defs: ItemLocalMap<Result<(DefKind, DefId), ErrorGuaranteed>>,\n-\n-    /// Resolved field indices for field accesses in expressions (`S { field }`, `obj.field`)\n-    /// or patterns (`S { field }`). The index is often useful by itself, but to learn more\n-    /// about the field you also need definition of the variant to which the field\n-    /// belongs, but it may not exist if it's a tuple field (`tuple.0`).\n-    field_indices: ItemLocalMap<usize>,\n-\n-    /// Stores the types for various nodes in the AST. Note that this table\n-    /// is not guaranteed to be populated outside inference. See\n-    /// typeck::check::fn_ctxt for details.\n-    node_types: ItemLocalMap<Ty<'tcx>>,\n-\n-    /// Stores the type parameters which were substituted to obtain the type\n-    /// of this node. This only applies to nodes that refer to entities\n-    /// parameterized by type parameters, such as generic fns, types, or\n-    /// other items.\n-    node_substs: ItemLocalMap<SubstsRef<'tcx>>,\n-\n-    /// This will either store the canonicalized types provided by the user\n-    /// or the substitutions that the user explicitly gave (if any) attached\n-    /// to `id`. These will not include any inferred values. The canonical form\n-    /// is used to capture things like `_` or other unspecified values.\n-    ///\n-    /// For example, if the user wrote `foo.collect::<Vec<_>>()`, then the\n-    /// canonical substitutions would include only `for<X> { Vec<X> }`.\n-    ///\n-    /// See also `AscribeUserType` statement in MIR.\n-    user_provided_types: ItemLocalMap<CanonicalUserType<'tcx>>,\n-\n-    /// Stores the canonicalized types provided by the user. See also\n-    /// `AscribeUserType` statement in MIR.\n-    pub user_provided_sigs: LocalDefIdMap<CanonicalPolyFnSig<'tcx>>,\n-\n-    adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n-\n-    /// Stores the actual binding mode for all instances of hir::BindingAnnotation.\n-    pat_binding_modes: ItemLocalMap<BindingMode>,\n-\n-    /// Stores the types which were implicitly dereferenced in pattern binding modes\n-    /// for later usage in THIR lowering. For example,\n-    ///\n-    /// ```\n-    /// match &&Some(5i32) {\n-    ///     Some(n) => {},\n-    ///     _ => {},\n-    /// }\n-    /// ```\n-    /// leads to a `vec![&&Option<i32>, &Option<i32>]`. Empty vectors are not stored.\n-    ///\n-    /// See:\n-    /// <https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md#definitions>\n-    pat_adjustments: ItemLocalMap<Vec<Ty<'tcx>>>,\n-\n-    /// Records the reasons that we picked the kind of each closure;\n-    /// not all closures are present in the map.\n-    closure_kind_origins: ItemLocalMap<(Span, HirPlace<'tcx>)>,\n-\n-    /// For each fn, records the \"liberated\" types of its arguments\n-    /// and return type. Liberated means that all bound regions\n-    /// (including late-bound regions) are replaced with free\n-    /// equivalents. This table is not used in codegen (since regions\n-    /// are erased there) and hence is not serialized to metadata.\n-    ///\n-    /// This table also contains the \"revealed\" values for any `impl Trait`\n-    /// that appear in the signature and whose values are being inferred\n-    /// by this function.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # use std::fmt::Debug;\n-    /// fn foo(x: &u32) -> impl Debug { *x }\n-    /// ```\n-    ///\n-    /// The function signature here would be:\n-    ///\n-    /// ```ignore (illustrative)\n-    /// for<'a> fn(&'a u32) -> Foo\n-    /// ```\n-    ///\n-    /// where `Foo` is an opaque type created for this function.\n-    ///\n-    ///\n-    /// The *liberated* form of this would be\n-    ///\n-    /// ```ignore (illustrative)\n-    /// fn(&'a u32) -> u32\n-    /// ```\n-    ///\n-    /// Note that `'a` is not bound (it would be an `ReFree`) and\n-    /// that the `Foo` opaque type is replaced by its hidden type.\n-    liberated_fn_sigs: ItemLocalMap<ty::FnSig<'tcx>>,\n-\n-    /// For each FRU expression, record the normalized types of the fields\n-    /// of the struct - this is needed because it is non-trivial to\n-    /// normalize while preserving regions. This table is used only in\n-    /// MIR construction and hence is not serialized to metadata.\n-    fru_field_types: ItemLocalMap<Vec<Ty<'tcx>>>,\n-\n-    /// For every coercion cast we add the HIR node ID of the cast\n-    /// expression to this set.\n-    coercion_casts: ItemLocalSet,\n-\n-    /// Set of trait imports actually used in the method resolution.\n-    /// This is used for warning unused imports. During type\n-    /// checking, this `Lrc` should not be cloned: it must have a ref-count\n-    /// of 1 so that we can insert things into the set mutably.\n-    pub used_trait_imports: Lrc<UnordSet<LocalDefId>>,\n-\n-    /// If any errors occurred while type-checking this body,\n-    /// this field will be set to `Some(ErrorGuaranteed)`.\n-    pub tainted_by_errors: Option<ErrorGuaranteed>,\n-\n-    /// All the opaque types that have hidden types set\n-    /// by this function. We also store the\n-    /// type here, so that mir-borrowck can use it as a hint for figuring out hidden types,\n-    /// even if they are only set in dead code (which doesn't show up in MIR).\n-    pub concrete_opaque_types: VecMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n-\n-    /// Tracks the minimum captures required for a closure;\n-    /// see `MinCaptureInformationMap` for more details.\n-    pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n-\n-    /// Tracks the fake reads required for a closure and the reason for the fake read.\n-    /// When performing pattern matching for closures, there are times we don't end up\n-    /// reading places that are mentioned in a closure (because of _ patterns). However,\n-    /// to ensure the places are initialized, we introduce fake reads.\n-    /// Consider these two examples:\n-    /// ``` (discriminant matching with only wildcard arm)\n-    /// let x: u8;\n-    /// let c = || match x { _ => () };\n-    /// ```\n-    /// In this example, we don't need to actually read/borrow `x` in `c`, and so we don't\n-    /// want to capture it. However, we do still want an error here, because `x` should have\n-    /// to be initialized at the point where c is created. Therefore, we add a \"fake read\"\n-    /// instead.\n-    /// ``` (destructured assignments)\n-    /// let c = || {\n-    ///     let (t1, t2) = t;\n-    /// }\n-    /// ```\n-    /// In the second example, we capture the disjoint fields of `t` (`t.0` & `t.1`), but\n-    /// we never capture `t`. This becomes an issue when we build MIR as we require\n-    /// information on `t` in order to create place `t.0` and `t.1`. We can solve this\n-    /// issue by fake reading `t`.\n-    pub closure_fake_reads: FxHashMap<LocalDefId, Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>>,\n-\n-    /// Tracks the rvalue scoping rules which defines finer scoping for rvalue expressions\n-    /// by applying extended parameter rules.\n-    /// Details may be find in `rustc_hir_analysis::check::rvalue_scopes`.\n-    pub rvalue_scopes: RvalueScopes,\n-\n-    /// Stores the type, expression, span and optional scope span of all types\n-    /// that are live across the yield of this generator (if a generator).\n-    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n-\n-    /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n-    /// as `&[u8]`, depending on the pattern  in which they are used.\n-    /// This hashset records all instances where we behave\n-    /// like this to allow `const_to_pat` to reliably handle this situation.\n-    pub treat_byte_string_as_slice: ItemLocalSet,\n-\n-    /// Contains the data for evaluating the effect of feature `capture_disjoint_fields`\n-    /// on closure size.\n-    pub closure_size_eval: FxHashMap<LocalDefId, ClosureSizeProfileData<'tcx>>,\n-}\n-\n-impl<'tcx> TypeckResults<'tcx> {\n-    pub fn new(hir_owner: OwnerId) -> TypeckResults<'tcx> {\n-        TypeckResults {\n-            hir_owner,\n-            type_dependent_defs: Default::default(),\n-            field_indices: Default::default(),\n-            user_provided_types: Default::default(),\n-            user_provided_sigs: Default::default(),\n-            node_types: Default::default(),\n-            node_substs: Default::default(),\n-            adjustments: Default::default(),\n-            pat_binding_modes: Default::default(),\n-            pat_adjustments: Default::default(),\n-            closure_kind_origins: Default::default(),\n-            liberated_fn_sigs: Default::default(),\n-            fru_field_types: Default::default(),\n-            coercion_casts: Default::default(),\n-            used_trait_imports: Lrc::new(Default::default()),\n-            tainted_by_errors: None,\n-            concrete_opaque_types: Default::default(),\n-            closure_min_captures: Default::default(),\n-            closure_fake_reads: Default::default(),\n-            rvalue_scopes: Default::default(),\n-            generator_interior_types: ty::Binder::dummy(Default::default()),\n-            treat_byte_string_as_slice: Default::default(),\n-            closure_size_eval: Default::default(),\n-        }\n-    }\n-\n-    /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n-    pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n-        match *qpath {\n-            hir::QPath::Resolved(_, ref path) => path.res,\n-            hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n-                .type_dependent_def(id)\n-                .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),\n-        }\n-    }\n-\n-    pub fn type_dependent_defs(\n-        &self,\n-    ) -> LocalTableInContext<'_, Result<(DefKind, DefId), ErrorGuaranteed>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.type_dependent_defs }\n-    }\n-\n-    pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.type_dependent_defs.get(&id.local_id).cloned().and_then(|r| r.ok())\n-    }\n-\n-    pub fn type_dependent_def_id(&self, id: HirId) -> Option<DefId> {\n-        self.type_dependent_def(id).map(|(_, def_id)| def_id)\n-    }\n-\n-    pub fn type_dependent_defs_mut(\n-        &mut self,\n-    ) -> LocalTableInContextMut<'_, Result<(DefKind, DefId), ErrorGuaranteed>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.type_dependent_defs }\n-    }\n-\n-    pub fn field_indices(&self) -> LocalTableInContext<'_, usize> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.field_indices }\n-    }\n-\n-    pub fn field_indices_mut(&mut self) -> LocalTableInContextMut<'_, usize> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.field_indices }\n-    }\n-\n-    pub fn field_index(&self, id: hir::HirId) -> usize {\n-        self.field_indices().get(id).cloned().expect(\"no index for a field\")\n-    }\n-\n-    pub fn opt_field_index(&self, id: hir::HirId) -> Option<usize> {\n-        self.field_indices().get(id).cloned()\n-    }\n-\n-    pub fn user_provided_types(&self) -> LocalTableInContext<'_, CanonicalUserType<'tcx>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.user_provided_types }\n-    }\n-\n-    pub fn user_provided_types_mut(\n-        &mut self,\n-    ) -> LocalTableInContextMut<'_, CanonicalUserType<'tcx>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.user_provided_types }\n-    }\n-\n-    pub fn node_types(&self) -> LocalTableInContext<'_, Ty<'tcx>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.node_types }\n-    }\n-\n-    pub fn node_types_mut(&mut self) -> LocalTableInContextMut<'_, Ty<'tcx>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_types }\n-    }\n-\n-    pub fn get_generator_diagnostic_data(&self) -> GeneratorDiagnosticData<'tcx> {\n-        let generator_interior_type = self.generator_interior_types.map_bound_ref(|vec| {\n-            vec.iter()\n-                .map(|item| {\n-                    GeneratorInteriorTypeCause {\n-                        ty: item.ty,\n-                        span: item.span,\n-                        scope_span: item.scope_span,\n-                        yield_span: item.yield_span,\n-                        expr: None, //FIXME: Passing expression over crate boundaries is impossible at the moment\n-                    }\n-                })\n-                .collect::<Vec<_>>()\n-        });\n-        GeneratorDiagnosticData {\n-            generator_interior_types: generator_interior_type,\n-            hir_owner: self.hir_owner.to_def_id(),\n-            nodes_types: self.node_types.clone(),\n-            adjustments: self.adjustments.clone(),\n-        }\n-    }\n-\n-    pub fn node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n-        self.node_type_opt(id).unwrap_or_else(|| {\n-            bug!(\"node_type: no type for node `{}`\", tls::with(|tcx| tcx.hir().node_to_string(id)))\n-        })\n-    }\n-\n-    pub fn node_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.node_types.get(&id.local_id).cloned()\n-    }\n-\n-    pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<'_, SubstsRef<'tcx>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_substs }\n-    }\n-\n-    pub fn node_substs(&self, id: hir::HirId) -> SubstsRef<'tcx> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.node_substs.get(&id.local_id).cloned().unwrap_or_else(|| InternalSubsts::empty())\n-    }\n-\n-    pub fn node_substs_opt(&self, id: hir::HirId) -> Option<SubstsRef<'tcx>> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.node_substs.get(&id.local_id).cloned()\n-    }\n-\n-    /// Returns the type of a pattern as a monotype. Like [`expr_ty`], this function\n-    /// doesn't provide type parameter substitutions.\n-    ///\n-    /// [`expr_ty`]: TypeckResults::expr_ty\n-    pub fn pat_ty(&self, pat: &hir::Pat<'_>) -> Ty<'tcx> {\n-        self.node_type(pat.hir_id)\n-    }\n-\n-    /// Returns the type of an expression as a monotype.\n-    ///\n-    /// NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n-    /// some cases, we insert `Adjustment` annotations such as auto-deref or\n-    /// auto-ref.  The type returned by this function does not consider such\n-    /// adjustments.  See `expr_ty_adjusted()` instead.\n-    ///\n-    /// NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n-    /// ask for the type of `id` in `id(3)`, it will return `fn(&isize) -> isize`\n-    /// instead of `fn(ty) -> T with T = isize`.\n-    pub fn expr_ty(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n-        self.node_type(expr.hir_id)\n-    }\n-\n-    pub fn expr_ty_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n-        self.node_type_opt(expr.hir_id)\n-    }\n-\n-    pub fn adjustments(&self) -> LocalTableInContext<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.adjustments }\n-    }\n-\n-    pub fn adjustments_mut(\n-        &mut self,\n-    ) -> LocalTableInContextMut<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.adjustments }\n-    }\n-\n-    pub fn expr_adjustments(&self, expr: &hir::Expr<'_>) -> &[ty::adjustment::Adjustment<'tcx>] {\n-        validate_hir_id_for_typeck_results(self.hir_owner, expr.hir_id);\n-        self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n-    }\n-\n-    /// Returns the type of `expr`, considering any `Adjustment`\n-    /// entry recorded for that expression.\n-    pub fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n-        self.expr_adjustments(expr).last().map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n-    }\n-\n-    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n-        self.expr_adjustments(expr).last().map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n-    }\n-\n-    pub fn is_method_call(&self, expr: &hir::Expr<'_>) -> bool {\n-        // Only paths and method calls/overloaded operators have\n-        // entries in type_dependent_defs, ignore the former here.\n-        if let hir::ExprKind::Path(_) = expr.kind {\n-            return false;\n-        }\n-\n-        matches!(self.type_dependent_defs().get(expr.hir_id), Some(Ok((DefKind::AssocFn, _))))\n-    }\n-\n-    pub fn extract_binding_mode(&self, s: &Session, id: HirId, sp: Span) -> Option<BindingMode> {\n-        self.pat_binding_modes().get(id).copied().or_else(|| {\n-            s.delay_span_bug(sp, \"missing binding mode\");\n-            None\n-        })\n-    }\n-\n-    pub fn pat_binding_modes(&self) -> LocalTableInContext<'_, BindingMode> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_binding_modes }\n-    }\n-\n-    pub fn pat_binding_modes_mut(&mut self) -> LocalTableInContextMut<'_, BindingMode> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_binding_modes }\n-    }\n-\n-    pub fn pat_adjustments(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_adjustments }\n-    }\n-\n-    pub fn pat_adjustments_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_adjustments }\n-    }\n-\n-    /// For a given closure, returns the iterator of `ty::CapturedPlace`s that are captured\n-    /// by the closure.\n-    pub fn closure_min_captures_flattened(\n-        &self,\n-        closure_def_id: LocalDefId,\n-    ) -> impl Iterator<Item = &ty::CapturedPlace<'tcx>> {\n-        self.closure_min_captures\n-            .get(&closure_def_id)\n-            .map(|closure_min_captures| closure_min_captures.values().flat_map(|v| v.iter()))\n-            .into_iter()\n-            .flatten()\n-    }\n-\n-    pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, HirPlace<'tcx>)> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.closure_kind_origins }\n-    }\n-\n-    pub fn closure_kind_origins_mut(\n-        &mut self,\n-    ) -> LocalTableInContextMut<'_, (Span, HirPlace<'tcx>)> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.closure_kind_origins }\n-    }\n-\n-    pub fn liberated_fn_sigs(&self) -> LocalTableInContext<'_, ty::FnSig<'tcx>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.liberated_fn_sigs }\n-    }\n-\n-    pub fn liberated_fn_sigs_mut(&mut self) -> LocalTableInContextMut<'_, ty::FnSig<'tcx>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.liberated_fn_sigs }\n-    }\n-\n-    pub fn fru_field_types(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.fru_field_types }\n-    }\n-\n-    pub fn fru_field_types_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.fru_field_types }\n-    }\n-\n-    pub fn is_coercion_cast(&self, hir_id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_results(self.hir_owner, hir_id);\n-        self.coercion_casts.contains(&hir_id.local_id)\n-    }\n-\n-    pub fn set_coercion_cast(&mut self, id: ItemLocalId) {\n-        self.coercion_casts.insert(id);\n-    }\n-\n-    pub fn coercion_casts(&self) -> &ItemLocalSet {\n-        &self.coercion_casts\n-    }\n-}\n-\n-rustc_index::newtype_index! {\n-    pub struct UserTypeAnnotationIndex {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"UserType({})\",\n-        const START_INDEX = 0,\n-    }\n-}\n-\n-/// Mapping of type annotation indices to canonical user type annotations.\n-pub type CanonicalUserTypeAnnotations<'tcx> =\n-    IndexVec<UserTypeAnnotationIndex, CanonicalUserTypeAnnotation<'tcx>>;\n-\n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable, Lift)]\n-pub struct CanonicalUserTypeAnnotation<'tcx> {\n-    pub user_ty: Box<CanonicalUserType<'tcx>>,\n-    pub span: Span,\n-    pub inferred_ty: Ty<'tcx>,\n-}\n-\n-/// Canonicalized user type annotation.\n-pub type CanonicalUserType<'tcx> = Canonical<'tcx, UserType<'tcx>>;\n-\n-impl<'tcx> CanonicalUserType<'tcx> {\n-    /// Returns `true` if this represents a substitution of the form `[?0, ?1, ?2]`,\n-    /// i.e., each thing is mapped to a canonical variable with the same index.\n-    pub fn is_identity(&self) -> bool {\n-        match self.value {\n-            UserType::Ty(_) => false,\n-            UserType::TypeOf(_, user_substs) => {\n-                if user_substs.user_self_ty.is_some() {\n-                    return false;\n-                }\n-\n-                iter::zip(user_substs.substs, BoundVar::new(0)..).all(|(kind, cvar)| {\n-                    match kind.unpack() {\n-                        GenericArgKind::Type(ty) => match ty.kind() {\n-                            ty::Bound(debruijn, b) => {\n-                                // We only allow a `ty::INNERMOST` index in substitutions.\n-                                assert_eq!(*debruijn, ty::INNERMOST);\n-                                cvar == b.var\n-                            }\n-                            _ => false,\n-                        },\n-\n-                        GenericArgKind::Lifetime(r) => match *r {\n-                            ty::ReLateBound(debruijn, br) => {\n-                                // We only allow a `ty::INNERMOST` index in substitutions.\n-                                assert_eq!(debruijn, ty::INNERMOST);\n-                                cvar == br.var\n-                            }\n-                            _ => false,\n-                        },\n-\n-                        GenericArgKind::Const(ct) => match ct.kind() {\n-                            ty::ConstKind::Bound(debruijn, b) => {\n-                                // We only allow a `ty::INNERMOST` index in substitutions.\n-                                assert_eq!(debruijn, ty::INNERMOST);\n-                                cvar == b\n-                            }\n-                            _ => false,\n-                        },\n-                    }\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-/// A user-given type annotation attached to a constant. These arise\n-/// from constants that are named via paths, like `Foo::<A>::new` and\n-/// so forth.\n-#[derive(Copy, Clone, Debug, PartialEq, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n-pub enum UserType<'tcx> {\n-    Ty(Ty<'tcx>),\n-\n-    /// The canonical type is the result of `type_of(def_id)` with the\n-    /// given substitutions applied.\n-    TypeOf(DefId, UserSubsts<'tcx>),\n-}\n-\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(\n         interners: &CtxtInterners<'tcx>,"}, {"sha": "f785fb5c4b9be5b5c57f78104e7895b029bcbabf", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 10, "deletions": 50, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -6,28 +6,18 @@ use std::fmt::Debug;\n use std::hash::Hash;\n use std::iter;\n \n-use self::SimplifiedTypeGen::*;\n+use self::SimplifiedType::*;\n \n-pub type SimplifiedType = SimplifiedTypeGen<DefId>;\n-\n-/// See `simplify_type`\n-///\n-/// Note that we keep this type generic over the type of identifier it uses\n-/// because we sometimes need to use SimplifiedTypeGen values as stable sorting\n-/// keys (in which case we use a DefPathHash as id-type) but in the general case\n-/// the non-stable but fast to construct DefId-version is the better choice.\n+/// See `simplify_type`.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n-pub enum SimplifiedTypeGen<D>\n-where\n-    D: Copy + Debug + Eq,\n-{\n+pub enum SimplifiedType {\n     BoolSimplifiedType,\n     CharSimplifiedType,\n     IntSimplifiedType(ty::IntTy),\n     UintSimplifiedType(ty::UintTy),\n     FloatSimplifiedType(ty::FloatTy),\n-    AdtSimplifiedType(D),\n-    ForeignSimplifiedType(D),\n+    AdtSimplifiedType(DefId),\n+    ForeignSimplifiedType(DefId),\n     StrSimplifiedType,\n     ArraySimplifiedType,\n     SliceSimplifiedType,\n@@ -38,9 +28,9 @@ where\n     /// A trait object, all of whose components are markers\n     /// (e.g., `dyn Send + Sync`).\n     MarkerTraitObjectSimplifiedType,\n-    TraitSimplifiedType(D),\n-    ClosureSimplifiedType(D),\n-    GeneratorSimplifiedType(D),\n+    TraitSimplifiedType(DefId),\n+    ClosureSimplifiedType(DefId),\n+    GeneratorSimplifiedType(DefId),\n     GeneratorWitnessSimplifiedType(usize),\n     FunctionSimplifiedType(usize),\n     PlaceholderSimplifiedType,\n@@ -142,8 +132,8 @@ pub fn simplify_type<'tcx>(\n     }\n }\n \n-impl<D: Copy + Debug + Eq> SimplifiedTypeGen<D> {\n-    pub fn def(self) -> Option<D> {\n+impl SimplifiedType {\n+    pub fn def(self) -> Option<DefId> {\n         match self {\n             AdtSimplifiedType(d)\n             | ForeignSimplifiedType(d)\n@@ -153,36 +143,6 @@ impl<D: Copy + Debug + Eq> SimplifiedTypeGen<D> {\n             _ => None,\n         }\n     }\n-\n-    pub fn map_def<U, F>(self, map: F) -> SimplifiedTypeGen<U>\n-    where\n-        F: Fn(D) -> U,\n-        U: Copy + Debug + Eq,\n-    {\n-        match self {\n-            BoolSimplifiedType => BoolSimplifiedType,\n-            CharSimplifiedType => CharSimplifiedType,\n-            IntSimplifiedType(t) => IntSimplifiedType(t),\n-            UintSimplifiedType(t) => UintSimplifiedType(t),\n-            FloatSimplifiedType(t) => FloatSimplifiedType(t),\n-            AdtSimplifiedType(d) => AdtSimplifiedType(map(d)),\n-            ForeignSimplifiedType(d) => ForeignSimplifiedType(map(d)),\n-            StrSimplifiedType => StrSimplifiedType,\n-            ArraySimplifiedType => ArraySimplifiedType,\n-            SliceSimplifiedType => SliceSimplifiedType,\n-            RefSimplifiedType(m) => RefSimplifiedType(m),\n-            PtrSimplifiedType(m) => PtrSimplifiedType(m),\n-            NeverSimplifiedType => NeverSimplifiedType,\n-            MarkerTraitObjectSimplifiedType => MarkerTraitObjectSimplifiedType,\n-            TupleSimplifiedType(n) => TupleSimplifiedType(n),\n-            TraitSimplifiedType(d) => TraitSimplifiedType(map(d)),\n-            ClosureSimplifiedType(d) => ClosureSimplifiedType(map(d)),\n-            GeneratorSimplifiedType(d) => GeneratorSimplifiedType(map(d)),\n-            GeneratorWitnessSimplifiedType(n) => GeneratorWitnessSimplifiedType(n),\n-            FunctionSimplifiedType(n) => FunctionSimplifiedType(n),\n-            PlaceholderSimplifiedType => PlaceholderSimplifiedType,\n-        }\n-    }\n }\n \n /// Given generic arguments from an obligation and an impl,"}, {"sha": "7290f0ae7c0350f4d34b3e08be5303af6da875d1", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -83,10 +83,8 @@ pub use self::consts::{\n     Const, ConstInt, ConstKind, ConstS, Expr, InferConst, ScalarInt, UnevaluatedConst, ValTree,\n };\n pub use self::context::{\n-    tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n-    CtxtInterners, DeducedParamAttrs, FreeRegionInfo, GeneratorDiagnosticData,\n-    GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, TyCtxt, TyCtxtFeed, TypeckResults,\n-    UserType, UserTypeAnnotationIndex,\n+    tls, CtxtInterners, DeducedParamAttrs, FreeRegionInfo, GlobalCtxt, Lift, OnDiskCache, TyCtxt,\n+    TyCtxtFeed,\n };\n pub use self::instance::{Instance, InstanceDef, ShortInstance};\n pub use self::list::List;\n@@ -103,6 +101,11 @@ pub use self::sty::{\n     Region, RegionKind, RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts, VarianceDiagInfo,\n };\n pub use self::trait_def::TraitDef;\n+pub use self::typeck_results::{\n+    CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n+    GeneratorDiagnosticData, GeneratorInteriorTypeCause, TypeckResults, UserType,\n+    UserTypeAnnotationIndex,\n+};\n \n pub mod _match;\n pub mod abstract_const;\n@@ -143,6 +146,7 @@ mod parameterized;\n mod rvalue_scopes;\n mod structural_impls;\n mod sty;\n+mod typeck_results;\n \n // Data types\n "}, {"sha": "a21e3961cb627341211579f1a8528bb3a39b34c3", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,15 +1,10 @@\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::{DefId, DefIndex};\n+use rustc_hir::def_id::DefIndex;\n use rustc_index::vec::{Idx, IndexVec};\n \n-use crate::middle::exported_symbols::ExportedSymbol;\n-use crate::mir::Body;\n-use crate::ty::{\n-    self, Clause, Const, FnSig, GeneratorDiagnosticData, GenericPredicates, Predicate, TraitRef, Ty,\n-};\n+use crate::ty;\n \n pub trait ParameterizedOverTcx: 'static {\n-    #[allow(unused_lifetimes)]\n     type Value<'tcx>;\n }\n \n@@ -67,7 +62,7 @@ trivially_parameterized_over_tcx! {\n     ty::TraitDef,\n     ty::Visibility<DefIndex>,\n     ty::adjustment::CoerceUnsizedInfo,\n-    ty::fast_reject::SimplifiedTypeGen<DefId>,\n+    ty::fast_reject::SimplifiedType,\n     rustc_ast::Attribute,\n     rustc_ast::DelimArgs,\n     rustc_attr::ConstStability,\n@@ -100,29 +95,28 @@ trivially_parameterized_over_tcx! {\n     rustc_type_ir::Variance,\n }\n \n-// HACK(compiler-errors): This macro rule can only take an ident,\n-// not a path, due to parsing ambiguity reasons. That means we gotta\n-// import all of these types above.\n+// HACK(compiler-errors): This macro rule can only take a fake path,\n+// not a real, due to parsing ambiguity reasons.\n #[macro_export]\n macro_rules! parameterized_over_tcx {\n-    ($($ident:ident),+ $(,)?) => {\n+    ($($($fake_path:ident)::+),+ $(,)?) => {\n         $(\n-            impl $crate::ty::ParameterizedOverTcx for $ident<'static> {\n-                type Value<'tcx> = $ident<'tcx>;\n+            impl $crate::ty::ParameterizedOverTcx for $($fake_path)::+<'static> {\n+                type Value<'tcx> = $($fake_path)::+<'tcx>;\n             }\n         )*\n     }\n }\n \n parameterized_over_tcx! {\n-    Ty,\n-    FnSig,\n-    GenericPredicates,\n-    TraitRef,\n-    Const,\n-    Predicate,\n-    Clause,\n-    GeneratorDiagnosticData,\n-    Body,\n-    ExportedSymbol,\n+    crate::middle::exported_symbols::ExportedSymbol,\n+    crate::mir::Body,\n+    ty::Ty,\n+    ty::FnSig,\n+    ty::GenericPredicates,\n+    ty::TraitRef,\n+    ty::Const,\n+    ty::Predicate,\n+    ty::Clause,\n+    ty::GeneratorDiagnosticData,\n }"}, {"sha": "a1d53506707c9a2938749623d087c314bad761a6", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -16,6 +16,7 @@ use rustc_session::config::TrimmedDefPaths;\n use rustc_session::cstore::{ExternCrate, ExternCrateSource};\n use rustc_session::Limit;\n use rustc_span::symbol::{kw, Ident, Symbol};\n+use rustc_span::FileNameDisplayPreference;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n use smallvec::SmallVec;\n@@ -818,11 +819,16 @@ pub trait PrettyPrinter<'tcx>:\n                             p!(\"@\", print_def_path(did.to_def_id(), substs));\n                         } else {\n                             let span = self.tcx().def_span(did);\n+                            let preference = if FORCE_TRIMMED_PATH.with(|flag| flag.get()) {\n+                                FileNameDisplayPreference::Short\n+                            } else {\n+                                FileNameDisplayPreference::Remapped\n+                            };\n                             p!(write(\n                                 \"@{}\",\n                                 // This may end up in stderr diagnostics but it may also be emitted\n                                 // into MIR. Hence we use the remapped path if available\n-                                self.tcx().sess.source_map().span_to_embeddable_string(span)\n+                                self.tcx().sess.source_map().span_to_string(span, preference)\n                             ));\n                         }\n                     } else {"}, {"sha": "4fe85d4366f3e3d3b1027800b906f86797a7c32a", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "added", "additions": 689, "deletions": 0, "changes": 689, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -0,0 +1,689 @@\n+use crate::{\n+    hir::place::Place as HirPlace,\n+    infer::canonical::Canonical,\n+    ty::{\n+        self, tls, BindingMode, BoundVar, CanonicalPolyFnSig, ClosureSizeProfileData,\n+        GenericArgKind, InternalSubsts, SubstsRef, Ty, UserSubsts,\n+    },\n+};\n+use rustc_data_structures::{fx::FxHashMap, sync::Lrc, unord::UnordSet, vec_map::VecMap};\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_hir as hir;\n+use rustc_hir::{\n+    def::{DefKind, Res},\n+    def_id::{DefId, LocalDefId, LocalDefIdMap},\n+    hir_id::OwnerId,\n+    HirId, ItemLocalId, ItemLocalMap, ItemLocalSet,\n+};\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_macros::HashStable;\n+use rustc_middle::mir::FakeReadCause;\n+use rustc_session::Session;\n+use rustc_span::Span;\n+use std::{\n+    collections::hash_map::{self, Entry},\n+    hash::Hash,\n+    iter,\n+};\n+\n+use super::RvalueScopes;\n+\n+#[derive(TyEncodable, TyDecodable, Debug, HashStable)]\n+pub struct TypeckResults<'tcx> {\n+    /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n+    pub hir_owner: OwnerId,\n+\n+    /// Resolved definitions for `<T>::X` associated paths and\n+    /// method calls, including those of overloaded operators.\n+    type_dependent_defs: ItemLocalMap<Result<(DefKind, DefId), ErrorGuaranteed>>,\n+\n+    /// Resolved field indices for field accesses in expressions (`S { field }`, `obj.field`)\n+    /// or patterns (`S { field }`). The index is often useful by itself, but to learn more\n+    /// about the field you also need definition of the variant to which the field\n+    /// belongs, but it may not exist if it's a tuple field (`tuple.0`).\n+    field_indices: ItemLocalMap<usize>,\n+\n+    /// Stores the types for various nodes in the AST. Note that this table\n+    /// is not guaranteed to be populated outside inference. See\n+    /// typeck::check::fn_ctxt for details.\n+    node_types: ItemLocalMap<Ty<'tcx>>,\n+\n+    /// Stores the type parameters which were substituted to obtain the type\n+    /// of this node. This only applies to nodes that refer to entities\n+    /// parameterized by type parameters, such as generic fns, types, or\n+    /// other items.\n+    node_substs: ItemLocalMap<SubstsRef<'tcx>>,\n+\n+    /// This will either store the canonicalized types provided by the user\n+    /// or the substitutions that the user explicitly gave (if any) attached\n+    /// to `id`. These will not include any inferred values. The canonical form\n+    /// is used to capture things like `_` or other unspecified values.\n+    ///\n+    /// For example, if the user wrote `foo.collect::<Vec<_>>()`, then the\n+    /// canonical substitutions would include only `for<X> { Vec<X> }`.\n+    ///\n+    /// See also `AscribeUserType` statement in MIR.\n+    user_provided_types: ItemLocalMap<CanonicalUserType<'tcx>>,\n+\n+    /// Stores the canonicalized types provided by the user. See also\n+    /// `AscribeUserType` statement in MIR.\n+    pub user_provided_sigs: LocalDefIdMap<CanonicalPolyFnSig<'tcx>>,\n+\n+    adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n+\n+    /// Stores the actual binding mode for all instances of hir::BindingAnnotation.\n+    pat_binding_modes: ItemLocalMap<BindingMode>,\n+\n+    /// Stores the types which were implicitly dereferenced in pattern binding modes\n+    /// for later usage in THIR lowering. For example,\n+    ///\n+    /// ```\n+    /// match &&Some(5i32) {\n+    ///     Some(n) => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    /// leads to a `vec![&&Option<i32>, &Option<i32>]`. Empty vectors are not stored.\n+    ///\n+    /// See:\n+    /// <https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md#definitions>\n+    pat_adjustments: ItemLocalMap<Vec<Ty<'tcx>>>,\n+\n+    /// Records the reasons that we picked the kind of each closure;\n+    /// not all closures are present in the map.\n+    closure_kind_origins: ItemLocalMap<(Span, HirPlace<'tcx>)>,\n+\n+    /// For each fn, records the \"liberated\" types of its arguments\n+    /// and return type. Liberated means that all bound regions\n+    /// (including late-bound regions) are replaced with free\n+    /// equivalents. This table is not used in codegen (since regions\n+    /// are erased there) and hence is not serialized to metadata.\n+    ///\n+    /// This table also contains the \"revealed\" values for any `impl Trait`\n+    /// that appear in the signature and whose values are being inferred\n+    /// by this function.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::fmt::Debug;\n+    /// fn foo(x: &u32) -> impl Debug { *x }\n+    /// ```\n+    ///\n+    /// The function signature here would be:\n+    ///\n+    /// ```ignore (illustrative)\n+    /// for<'a> fn(&'a u32) -> Foo\n+    /// ```\n+    ///\n+    /// where `Foo` is an opaque type created for this function.\n+    ///\n+    ///\n+    /// The *liberated* form of this would be\n+    ///\n+    /// ```ignore (illustrative)\n+    /// fn(&'a u32) -> u32\n+    /// ```\n+    ///\n+    /// Note that `'a` is not bound (it would be an `ReFree`) and\n+    /// that the `Foo` opaque type is replaced by its hidden type.\n+    liberated_fn_sigs: ItemLocalMap<ty::FnSig<'tcx>>,\n+\n+    /// For each FRU expression, record the normalized types of the fields\n+    /// of the struct - this is needed because it is non-trivial to\n+    /// normalize while preserving regions. This table is used only in\n+    /// MIR construction and hence is not serialized to metadata.\n+    fru_field_types: ItemLocalMap<Vec<Ty<'tcx>>>,\n+\n+    /// For every coercion cast we add the HIR node ID of the cast\n+    /// expression to this set.\n+    coercion_casts: ItemLocalSet,\n+\n+    /// Set of trait imports actually used in the method resolution.\n+    /// This is used for warning unused imports. During type\n+    /// checking, this `Lrc` should not be cloned: it must have a ref-count\n+    /// of 1 so that we can insert things into the set mutably.\n+    pub used_trait_imports: Lrc<UnordSet<LocalDefId>>,\n+\n+    /// If any errors occurred while type-checking this body,\n+    /// this field will be set to `Some(ErrorGuaranteed)`.\n+    pub tainted_by_errors: Option<ErrorGuaranteed>,\n+\n+    /// All the opaque types that have hidden types set\n+    /// by this function. We also store the\n+    /// type here, so that mir-borrowck can use it as a hint for figuring out hidden types,\n+    /// even if they are only set in dead code (which doesn't show up in MIR).\n+    pub concrete_opaque_types: VecMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n+\n+    /// Tracks the minimum captures required for a closure;\n+    /// see `MinCaptureInformationMap` for more details.\n+    pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n+\n+    /// Tracks the fake reads required for a closure and the reason for the fake read.\n+    /// When performing pattern matching for closures, there are times we don't end up\n+    /// reading places that are mentioned in a closure (because of _ patterns). However,\n+    /// to ensure the places are initialized, we introduce fake reads.\n+    /// Consider these two examples:\n+    /// ``` (discriminant matching with only wildcard arm)\n+    /// let x: u8;\n+    /// let c = || match x { _ => () };\n+    /// ```\n+    /// In this example, we don't need to actually read/borrow `x` in `c`, and so we don't\n+    /// want to capture it. However, we do still want an error here, because `x` should have\n+    /// to be initialized at the point where c is created. Therefore, we add a \"fake read\"\n+    /// instead.\n+    /// ``` (destructured assignments)\n+    /// let c = || {\n+    ///     let (t1, t2) = t;\n+    /// }\n+    /// ```\n+    /// In the second example, we capture the disjoint fields of `t` (`t.0` & `t.1`), but\n+    /// we never capture `t`. This becomes an issue when we build MIR as we require\n+    /// information on `t` in order to create place `t.0` and `t.1`. We can solve this\n+    /// issue by fake reading `t`.\n+    pub closure_fake_reads: FxHashMap<LocalDefId, Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>>,\n+\n+    /// Tracks the rvalue scoping rules which defines finer scoping for rvalue expressions\n+    /// by applying extended parameter rules.\n+    /// Details may be find in `rustc_hir_analysis::check::rvalue_scopes`.\n+    pub rvalue_scopes: RvalueScopes,\n+\n+    /// Stores the type, expression, span and optional scope span of all types\n+    /// that are live across the yield of this generator (if a generator).\n+    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n+\n+    /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n+    /// as `&[u8]`, depending on the pattern  in which they are used.\n+    /// This hashset records all instances where we behave\n+    /// like this to allow `const_to_pat` to reliably handle this situation.\n+    pub treat_byte_string_as_slice: ItemLocalSet,\n+\n+    /// Contains the data for evaluating the effect of feature `capture_disjoint_fields`\n+    /// on closure size.\n+    pub closure_size_eval: FxHashMap<LocalDefId, ClosureSizeProfileData<'tcx>>,\n+}\n+\n+/// Whenever a value may be live across a generator yield, the type of that value winds up in the\n+/// `GeneratorInteriorTypeCause` struct. This struct adds additional information about such\n+/// captured types that can be useful for diagnostics. In particular, it stores the span that\n+/// caused a given type to be recorded, along with the scope that enclosed the value (which can\n+/// be used to find the await that the value is live across).\n+///\n+/// For example:\n+///\n+/// ```ignore (pseudo-Rust)\n+/// async move {\n+///     let x: T = expr;\n+///     foo.await\n+///     ...\n+/// }\n+/// ```\n+///\n+/// Here, we would store the type `T`, the span of the value `x`, the \"scope-span\" for\n+/// the scope that contains `x`, the expr `T` evaluated from, and the span of `foo.await`.\n+#[derive(TyEncodable, TyDecodable, Clone, Debug, Eq, Hash, PartialEq, HashStable)]\n+#[derive(TypeFoldable, TypeVisitable)]\n+pub struct GeneratorInteriorTypeCause<'tcx> {\n+    /// Type of the captured binding.\n+    pub ty: Ty<'tcx>,\n+    /// Span of the binding that was captured.\n+    pub span: Span,\n+    /// Span of the scope of the captured binding.\n+    pub scope_span: Option<Span>,\n+    /// Span of `.await` or `yield` expression.\n+    pub yield_span: Span,\n+    /// Expr which the type evaluated from.\n+    pub expr: Option<hir::HirId>,\n+}\n+\n+// This type holds diagnostic information on generators and async functions across crate boundaries\n+// and is used to provide better error messages\n+#[derive(TyEncodable, TyDecodable, Clone, Debug, HashStable)]\n+pub struct GeneratorDiagnosticData<'tcx> {\n+    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n+    pub hir_owner: DefId,\n+    pub nodes_types: ItemLocalMap<Ty<'tcx>>,\n+    pub adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n+}\n+\n+impl<'tcx> TypeckResults<'tcx> {\n+    pub fn new(hir_owner: OwnerId) -> TypeckResults<'tcx> {\n+        TypeckResults {\n+            hir_owner,\n+            type_dependent_defs: Default::default(),\n+            field_indices: Default::default(),\n+            user_provided_types: Default::default(),\n+            user_provided_sigs: Default::default(),\n+            node_types: Default::default(),\n+            node_substs: Default::default(),\n+            adjustments: Default::default(),\n+            pat_binding_modes: Default::default(),\n+            pat_adjustments: Default::default(),\n+            closure_kind_origins: Default::default(),\n+            liberated_fn_sigs: Default::default(),\n+            fru_field_types: Default::default(),\n+            coercion_casts: Default::default(),\n+            used_trait_imports: Lrc::new(Default::default()),\n+            tainted_by_errors: None,\n+            concrete_opaque_types: Default::default(),\n+            closure_min_captures: Default::default(),\n+            closure_fake_reads: Default::default(),\n+            rvalue_scopes: Default::default(),\n+            generator_interior_types: ty::Binder::dummy(Default::default()),\n+            treat_byte_string_as_slice: Default::default(),\n+            closure_size_eval: Default::default(),\n+        }\n+    }\n+\n+    /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n+    pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n+        match *qpath {\n+            hir::QPath::Resolved(_, ref path) => path.res,\n+            hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n+                .type_dependent_def(id)\n+                .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),\n+        }\n+    }\n+\n+    pub fn type_dependent_defs(\n+        &self,\n+    ) -> LocalTableInContext<'_, Result<(DefKind, DefId), ErrorGuaranteed>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.type_dependent_defs }\n+    }\n+\n+    pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.type_dependent_defs.get(&id.local_id).cloned().and_then(|r| r.ok())\n+    }\n+\n+    pub fn type_dependent_def_id(&self, id: HirId) -> Option<DefId> {\n+        self.type_dependent_def(id).map(|(_, def_id)| def_id)\n+    }\n+\n+    pub fn type_dependent_defs_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, Result<(DefKind, DefId), ErrorGuaranteed>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.type_dependent_defs }\n+    }\n+\n+    pub fn field_indices(&self) -> LocalTableInContext<'_, usize> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.field_indices }\n+    }\n+\n+    pub fn field_indices_mut(&mut self) -> LocalTableInContextMut<'_, usize> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.field_indices }\n+    }\n+\n+    pub fn field_index(&self, id: hir::HirId) -> usize {\n+        self.field_indices().get(id).cloned().expect(\"no index for a field\")\n+    }\n+\n+    pub fn opt_field_index(&self, id: hir::HirId) -> Option<usize> {\n+        self.field_indices().get(id).cloned()\n+    }\n+\n+    pub fn user_provided_types(&self) -> LocalTableInContext<'_, CanonicalUserType<'tcx>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.user_provided_types }\n+    }\n+\n+    pub fn user_provided_types_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, CanonicalUserType<'tcx>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.user_provided_types }\n+    }\n+\n+    pub fn node_types(&self) -> LocalTableInContext<'_, Ty<'tcx>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.node_types }\n+    }\n+\n+    pub fn node_types_mut(&mut self) -> LocalTableInContextMut<'_, Ty<'tcx>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_types }\n+    }\n+\n+    pub fn get_generator_diagnostic_data(&self) -> GeneratorDiagnosticData<'tcx> {\n+        let generator_interior_type = self.generator_interior_types.map_bound_ref(|vec| {\n+            vec.iter()\n+                .map(|item| {\n+                    GeneratorInteriorTypeCause {\n+                        ty: item.ty,\n+                        span: item.span,\n+                        scope_span: item.scope_span,\n+                        yield_span: item.yield_span,\n+                        expr: None, //FIXME: Passing expression over crate boundaries is impossible at the moment\n+                    }\n+                })\n+                .collect::<Vec<_>>()\n+        });\n+        GeneratorDiagnosticData {\n+            generator_interior_types: generator_interior_type,\n+            hir_owner: self.hir_owner.to_def_id(),\n+            nodes_types: self.node_types.clone(),\n+            adjustments: self.adjustments.clone(),\n+        }\n+    }\n+\n+    pub fn node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n+        self.node_type_opt(id).unwrap_or_else(|| {\n+            bug!(\"node_type: no type for node `{}`\", tls::with(|tcx| tcx.hir().node_to_string(id)))\n+        })\n+    }\n+\n+    pub fn node_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.node_types.get(&id.local_id).cloned()\n+    }\n+\n+    pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<'_, SubstsRef<'tcx>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_substs }\n+    }\n+\n+    pub fn node_substs(&self, id: hir::HirId) -> SubstsRef<'tcx> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.node_substs.get(&id.local_id).cloned().unwrap_or_else(|| InternalSubsts::empty())\n+    }\n+\n+    pub fn node_substs_opt(&self, id: hir::HirId) -> Option<SubstsRef<'tcx>> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.node_substs.get(&id.local_id).cloned()\n+    }\n+\n+    /// Returns the type of a pattern as a monotype. Like [`expr_ty`], this function\n+    /// doesn't provide type parameter substitutions.\n+    ///\n+    /// [`expr_ty`]: TypeckResults::expr_ty\n+    pub fn pat_ty(&self, pat: &hir::Pat<'_>) -> Ty<'tcx> {\n+        self.node_type(pat.hir_id)\n+    }\n+\n+    /// Returns the type of an expression as a monotype.\n+    ///\n+    /// NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n+    /// some cases, we insert `Adjustment` annotations such as auto-deref or\n+    /// auto-ref.  The type returned by this function does not consider such\n+    /// adjustments.  See `expr_ty_adjusted()` instead.\n+    ///\n+    /// NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n+    /// ask for the type of `id` in `id(3)`, it will return `fn(&isize) -> isize`\n+    /// instead of `fn(ty) -> T with T = isize`.\n+    pub fn expr_ty(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n+        self.node_type(expr.hir_id)\n+    }\n+\n+    pub fn expr_ty_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n+        self.node_type_opt(expr.hir_id)\n+    }\n+\n+    pub fn adjustments(&self) -> LocalTableInContext<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.adjustments }\n+    }\n+\n+    pub fn adjustments_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.adjustments }\n+    }\n+\n+    pub fn expr_adjustments(&self, expr: &hir::Expr<'_>) -> &[ty::adjustment::Adjustment<'tcx>] {\n+        validate_hir_id_for_typeck_results(self.hir_owner, expr.hir_id);\n+        self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n+    }\n+\n+    /// Returns the type of `expr`, considering any `Adjustment`\n+    /// entry recorded for that expression.\n+    pub fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n+        self.expr_adjustments(expr).last().map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n+    }\n+\n+    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n+        self.expr_adjustments(expr).last().map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n+    }\n+\n+    pub fn is_method_call(&self, expr: &hir::Expr<'_>) -> bool {\n+        // Only paths and method calls/overloaded operators have\n+        // entries in type_dependent_defs, ignore the former here.\n+        if let hir::ExprKind::Path(_) = expr.kind {\n+            return false;\n+        }\n+\n+        matches!(self.type_dependent_defs().get(expr.hir_id), Some(Ok((DefKind::AssocFn, _))))\n+    }\n+\n+    pub fn extract_binding_mode(&self, s: &Session, id: HirId, sp: Span) -> Option<BindingMode> {\n+        self.pat_binding_modes().get(id).copied().or_else(|| {\n+            s.delay_span_bug(sp, \"missing binding mode\");\n+            None\n+        })\n+    }\n+\n+    pub fn pat_binding_modes(&self) -> LocalTableInContext<'_, BindingMode> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_binding_modes }\n+    }\n+\n+    pub fn pat_binding_modes_mut(&mut self) -> LocalTableInContextMut<'_, BindingMode> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_binding_modes }\n+    }\n+\n+    pub fn pat_adjustments(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_adjustments }\n+    }\n+\n+    pub fn pat_adjustments_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_adjustments }\n+    }\n+\n+    /// For a given closure, returns the iterator of `ty::CapturedPlace`s that are captured\n+    /// by the closure.\n+    pub fn closure_min_captures_flattened(\n+        &self,\n+        closure_def_id: LocalDefId,\n+    ) -> impl Iterator<Item = &ty::CapturedPlace<'tcx>> {\n+        self.closure_min_captures\n+            .get(&closure_def_id)\n+            .map(|closure_min_captures| closure_min_captures.values().flat_map(|v| v.iter()))\n+            .into_iter()\n+            .flatten()\n+    }\n+\n+    pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, HirPlace<'tcx>)> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.closure_kind_origins }\n+    }\n+\n+    pub fn closure_kind_origins_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, (Span, HirPlace<'tcx>)> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.closure_kind_origins }\n+    }\n+\n+    pub fn liberated_fn_sigs(&self) -> LocalTableInContext<'_, ty::FnSig<'tcx>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.liberated_fn_sigs }\n+    }\n+\n+    pub fn liberated_fn_sigs_mut(&mut self) -> LocalTableInContextMut<'_, ty::FnSig<'tcx>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.liberated_fn_sigs }\n+    }\n+\n+    pub fn fru_field_types(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.fru_field_types }\n+    }\n+\n+    pub fn fru_field_types_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.fru_field_types }\n+    }\n+\n+    pub fn is_coercion_cast(&self, hir_id: hir::HirId) -> bool {\n+        validate_hir_id_for_typeck_results(self.hir_owner, hir_id);\n+        self.coercion_casts.contains(&hir_id.local_id)\n+    }\n+\n+    pub fn set_coercion_cast(&mut self, id: ItemLocalId) {\n+        self.coercion_casts.insert(id);\n+    }\n+\n+    pub fn coercion_casts(&self) -> &ItemLocalSet {\n+        &self.coercion_casts\n+    }\n+}\n+\n+/// Validate that the given HirId (respectively its `local_id` part) can be\n+/// safely used as a key in the maps of a TypeckResults. For that to be\n+/// the case, the HirId must have the same `owner` as all the other IDs in\n+/// this table (signified by `hir_owner`). Otherwise the HirId\n+/// would be in a different frame of reference and using its `local_id`\n+/// would result in lookup errors, or worse, in silently wrong data being\n+/// stored/returned.\n+#[inline]\n+fn validate_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n+    if hir_id.owner != hir_owner {\n+        invalid_hir_id_for_typeck_results(hir_owner, hir_id);\n+    }\n+}\n+\n+#[cold]\n+#[inline(never)]\n+fn invalid_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n+    ty::tls::with(|tcx| {\n+        bug!(\n+            \"node {} with HirId::owner {:?} cannot be placed in TypeckResults with hir_owner {:?}\",\n+            tcx.hir().node_to_string(hir_id),\n+            hir_id.owner,\n+            hir_owner\n+        )\n+    });\n+}\n+\n+pub struct LocalTableInContext<'a, V> {\n+    hir_owner: OwnerId,\n+    data: &'a ItemLocalMap<V>,\n+}\n+\n+impl<'a, V> LocalTableInContext<'a, V> {\n+    pub fn contains_key(&self, id: hir::HirId) -> bool {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.contains_key(&id.local_id)\n+    }\n+\n+    pub fn get(&self, id: hir::HirId) -> Option<&V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.get(&id.local_id)\n+    }\n+\n+    pub fn iter(&self) -> hash_map::Iter<'_, hir::ItemLocalId, V> {\n+        self.data.iter()\n+    }\n+}\n+\n+impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n+    type Output = V;\n+\n+    fn index(&self, key: hir::HirId) -> &V {\n+        self.get(key).expect(\"LocalTableInContext: key not found\")\n+    }\n+}\n+\n+pub struct LocalTableInContextMut<'a, V> {\n+    hir_owner: OwnerId,\n+    data: &'a mut ItemLocalMap<V>,\n+}\n+\n+impl<'a, V> LocalTableInContextMut<'a, V> {\n+    pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.get_mut(&id.local_id)\n+    }\n+\n+    pub fn entry(&mut self, id: hir::HirId) -> Entry<'_, hir::ItemLocalId, V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.entry(id.local_id)\n+    }\n+\n+    pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.insert(id.local_id, val)\n+    }\n+\n+    pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.remove(&id.local_id)\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct UserTypeAnnotationIndex {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"UserType({})\",\n+        const START_INDEX = 0,\n+    }\n+}\n+\n+/// Mapping of type annotation indices to canonical user type annotations.\n+pub type CanonicalUserTypeAnnotations<'tcx> =\n+    IndexVec<UserTypeAnnotationIndex, CanonicalUserTypeAnnotation<'tcx>>;\n+\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable, Lift)]\n+pub struct CanonicalUserTypeAnnotation<'tcx> {\n+    pub user_ty: Box<CanonicalUserType<'tcx>>,\n+    pub span: Span,\n+    pub inferred_ty: Ty<'tcx>,\n+}\n+\n+/// Canonicalized user type annotation.\n+pub type CanonicalUserType<'tcx> = Canonical<'tcx, UserType<'tcx>>;\n+\n+impl<'tcx> CanonicalUserType<'tcx> {\n+    /// Returns `true` if this represents a substitution of the form `[?0, ?1, ?2]`,\n+    /// i.e., each thing is mapped to a canonical variable with the same index.\n+    pub fn is_identity(&self) -> bool {\n+        match self.value {\n+            UserType::Ty(_) => false,\n+            UserType::TypeOf(_, user_substs) => {\n+                if user_substs.user_self_ty.is_some() {\n+                    return false;\n+                }\n+\n+                iter::zip(user_substs.substs, BoundVar::new(0)..).all(|(kind, cvar)| {\n+                    match kind.unpack() {\n+                        GenericArgKind::Type(ty) => match ty.kind() {\n+                            ty::Bound(debruijn, b) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(*debruijn, ty::INNERMOST);\n+                                cvar == b.var\n+                            }\n+                            _ => false,\n+                        },\n+\n+                        GenericArgKind::Lifetime(r) => match *r {\n+                            ty::ReLateBound(debruijn, br) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(debruijn, ty::INNERMOST);\n+                                cvar == br.var\n+                            }\n+                            _ => false,\n+                        },\n+\n+                        GenericArgKind::Const(ct) => match ct.kind() {\n+                            ty::ConstKind::Bound(debruijn, b) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(debruijn, ty::INNERMOST);\n+                                cvar == b\n+                            }\n+                            _ => false,\n+                        },\n+                    }\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+/// A user-given type annotation attached to a constant. These arise\n+/// from constants that are named via paths, like `Foo::<A>::new` and\n+/// so forth.\n+#[derive(Copy, Clone, Debug, PartialEq, TyEncodable, TyDecodable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n+pub enum UserType<'tcx> {\n+    Ty(Ty<'tcx>),\n+\n+    /// The canonical type is the result of `type_of(def_id)` with the\n+    /// given substitutions applied.\n+    TypeOf(DefId, UserSubsts<'tcx>),\n+}"}, {"sha": "f15cf54718e2b7221bbb70fb9261f36af32fd525", "filename": "compiler/rustc_monomorphize/src/errors.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -77,3 +77,9 @@ pub struct SymbolAlreadyDefined {\n     pub span: Option<Span>,\n     pub symbol: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(monomorphize_couldnt_dump_mono_stats)]\n+pub struct CouldntDumpMonoStats {\n+    pub error: String,\n+}"}, {"sha": "38e1d98e44e13f0d72af80666004b666fb21835c", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -95,6 +95,11 @@\n mod default;\n mod merging;\n \n+use std::cmp;\n+use std::fs::{self, File};\n+use std::io::{BufWriter, Write};\n+use std::path::{Path, PathBuf};\n+\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync;\n use rustc_hir::def_id::DefIdSet;\n@@ -104,11 +109,12 @@ use rustc_middle::mir::mono::{CodegenUnit, Linkage};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n+use rustc_session::config::SwitchWithOptPath;\n use rustc_span::symbol::Symbol;\n \n use crate::collector::InliningMap;\n use crate::collector::{self, MonoItemCollectionMode};\n-use crate::errors::{SymbolAlreadyDefined, UnknownPartitionStrategy};\n+use crate::errors::{CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownPartitionStrategy};\n \n pub struct PartitioningCx<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -411,6 +417,15 @@ fn collect_and_partition_mono_items<'tcx>(\n         })\n         .collect();\n \n+    // Output monomorphization stats per def_id\n+    if let SwitchWithOptPath::Enabled(ref path) = tcx.sess.opts.unstable_opts.dump_mono_stats {\n+        if let Err(err) =\n+            dump_mono_items_stats(tcx, &codegen_units, path, tcx.sess.opts.crate_name.as_deref())\n+        {\n+            tcx.sess.emit_fatal(CouldntDumpMonoStats { error: err.to_string() });\n+        }\n+    }\n+\n     if tcx.sess.opts.unstable_opts.print_mono_items.is_some() {\n         let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n \n@@ -465,6 +480,67 @@ fn collect_and_partition_mono_items<'tcx>(\n     (tcx.arena.alloc(mono_items), codegen_units)\n }\n \n+/// Outputs stats about instantation counts and estimated size, per `MonoItem`'s\n+/// def, to a file in the given output directory.\n+fn dump_mono_items_stats<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    codegen_units: &[CodegenUnit<'tcx>],\n+    output_directory: &Option<PathBuf>,\n+    crate_name: Option<&str>,\n+) -> Result<(), Box<dyn std::error::Error>> {\n+    let output_directory = if let Some(ref directory) = output_directory {\n+        fs::create_dir_all(directory)?;\n+        directory\n+    } else {\n+        Path::new(\".\")\n+    };\n+\n+    let filename = format!(\"{}.mono_items.md\", crate_name.unwrap_or(\"unknown-crate\"));\n+    let output_path = output_directory.join(&filename);\n+    let file = File::create(output_path)?;\n+    let mut file = BufWriter::new(file);\n+\n+    // Gather instantiated mono items grouped by def_id\n+    let mut items_per_def_id: FxHashMap<_, Vec<_>> = Default::default();\n+    for cgu in codegen_units {\n+        for (&mono_item, _) in cgu.items() {\n+            // Avoid variable-sized compiler-generated shims\n+            if mono_item.is_user_defined() {\n+                items_per_def_id.entry(mono_item.def_id()).or_default().push(mono_item);\n+            }\n+        }\n+    }\n+\n+    // Output stats sorted by total instantiated size, from heaviest to lightest\n+    let mut stats: Vec<_> = items_per_def_id\n+        .into_iter()\n+        .map(|(def_id, items)| {\n+            let instantiation_count = items.len();\n+            let size_estimate = items[0].size_estimate(tcx);\n+            let total_estimate = instantiation_count * size_estimate;\n+            (def_id, instantiation_count, size_estimate, total_estimate)\n+        })\n+        .collect();\n+    stats.sort_unstable_by_key(|(_, _, _, total_estimate)| cmp::Reverse(*total_estimate));\n+\n+    if !stats.is_empty() {\n+        writeln!(\n+            file,\n+            \"| Item | Instantiation count | Estimated Cost Per Instantiation | Total Estimated Cost |\"\n+        )?;\n+        writeln!(file, \"| --- | ---: | ---: | ---: |\")?;\n+        for (def_id, instantiation_count, size_estimate, total_estimate) in stats {\n+            let item = with_no_trimmed_paths!(tcx.def_path_str(def_id));\n+            writeln!(\n+                file,\n+                \"| {item} | {instantiation_count} | {size_estimate} | {total_estimate} |\"\n+            )?;\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n fn codegened_and_inlined_items<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx DefIdSet {\n     let (items, cgus) = tcx.collect_and_partition_mono_items(());\n     let mut visited = DefIdSet::default();"}, {"sha": "9e130287104f9b1edd38a3d47e3dc11701c14e7f", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1294,6 +1294,9 @@ options! {\n         computed `block` spans (one span encompassing a block's terminator and \\\n         all statements). If `-Z instrument-coverage` is also enabled, create \\\n         an additional `.html` file showing the computed coverage spans.\"),\n+    dump_mono_stats: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n+        parse_switch_with_opt_path, [UNTRACKED],\n+        \"output statistics about monomorphization collection (format: markdown)\"),\n     dwarf_version: Option<u32> = (None, parse_opt_number, [TRACKED],\n         \"version of DWARF debug information to emit (default: 2 or 4, depending on platform)\"),\n     dylib_lto: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "2181c090027b535819aec1eb8afeb1851c0f4841", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -259,6 +259,10 @@ impl RealFileName {\n             FileNameDisplayPreference::Remapped => {\n                 self.remapped_path_if_available().to_string_lossy()\n             }\n+            FileNameDisplayPreference::Short => self\n+                .local_path_if_available()\n+                .file_name()\n+                .map_or_else(|| \"\".into(), |f| f.to_string_lossy()),\n         }\n     }\n }\n@@ -302,6 +306,9 @@ pub enum FileNameDisplayPreference {\n     /// Display the path before the application of rewrite rules provided via `--remap-path-prefix`.\n     /// This is appropriate for use in user-facing output (such as diagnostics).\n     Local,\n+    /// Display only the filename, as a way to reduce the verbosity of the output.\n+    /// This is appropriate for use in user-facing output (such as diagnostics).\n+    Short,\n }\n \n pub struct FileNameDisplay<'a> {"}, {"sha": "d9c87ac0ba82bfb6ecb0c9b3991dc6dee752ea44", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -438,20 +438,27 @@ impl SourceMap {\n         }\n     }\n \n-    fn span_to_string(&self, sp: Span, filename_display_pref: FileNameDisplayPreference) -> String {\n+    pub fn span_to_string(\n+        &self,\n+        sp: Span,\n+        filename_display_pref: FileNameDisplayPreference,\n+    ) -> String {\n         if self.files.borrow().source_files.is_empty() || sp.is_dummy() {\n             return \"no-location\".to_string();\n         }\n \n         let lo = self.lookup_char_pos(sp.lo());\n         let hi = self.lookup_char_pos(sp.hi());\n         format!(\n-            \"{}:{}:{}: {}:{}\",\n+            \"{}:{}:{}{}\",\n             lo.file.name.display(filename_display_pref),\n             lo.line,\n             lo.col.to_usize() + 1,\n-            hi.line,\n-            hi.col.to_usize() + 1,\n+            if let FileNameDisplayPreference::Short = filename_display_pref {\n+                String::new()\n+            } else {\n+                format!(\": {}:{}\", hi.line, hi.col.to_usize() + 1)\n+            }\n         )\n     }\n "}, {"sha": "181316427609e58aa9cd6dddc96b1c459453a3b2", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -35,7 +35,7 @@ use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n-use rustc_middle::ty::print::{FmtPrinter, Print};\n+use rustc_middle::ty::print::{with_forced_trimmed_paths, FmtPrinter, Print};\n use rustc_middle::ty::{\n     self, SubtypePredicate, ToPolyTraitRef, ToPredicate, TraitRef, Ty, TyCtxt, TypeFoldable,\n     TypeVisitable,\n@@ -1757,21 +1757,26 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         let trait_def_id = pred.projection_ty.trait_def_id(self.tcx);\n         let self_ty = pred.projection_ty.self_ty();\n \n-        if Some(pred.projection_ty.def_id) == self.tcx.lang_items().fn_once_output() {\n-            Some(format!(\n-                \"expected `{self_ty}` to be a {fn_kind} that returns `{expected_ty}`, but it returns `{normalized_ty}`\",\n-                fn_kind = self_ty.prefix_string(self.tcx)\n-            ))\n-        } else if Some(trait_def_id) == self.tcx.lang_items().future_trait() {\n-            Some(format!(\n-                \"expected `{self_ty}` to be a future that resolves to `{expected_ty}`, but it resolves to `{normalized_ty}`\"\n-            ))\n-        } else if Some(trait_def_id) == self.tcx.get_diagnostic_item(sym::Iterator) {\n-            Some(format!(\n-                \"expected `{self_ty}` to be an iterator that yields `{expected_ty}`, but it yields `{normalized_ty}`\"\n-            ))\n-        } else {\n-            None\n+        with_forced_trimmed_paths! {\n+            if Some(pred.projection_ty.def_id) == self.tcx.lang_items().fn_once_output() {\n+                Some(format!(\n+                    \"expected `{self_ty}` to be a {fn_kind} that returns `{expected_ty}`, but it \\\n+                     returns `{normalized_ty}`\",\n+                    fn_kind = self_ty.prefix_string(self.tcx)\n+                ))\n+            } else if Some(trait_def_id) == self.tcx.lang_items().future_trait() {\n+                Some(format!(\n+                    \"expected `{self_ty}` to be a future that resolves to `{expected_ty}`, but it \\\n+                     resolves to `{normalized_ty}`\"\n+                ))\n+            } else if Some(trait_def_id) == self.tcx.get_diagnostic_item(sym::Iterator) {\n+                Some(format!(\n+                    \"expected `{self_ty}` to be an iterator that yields `{expected_ty}`, but it \\\n+                     yields `{normalized_ty}`\"\n+                ))\n+            } else {\n+                None\n+            }\n         }\n     }\n "}, {"sha": "057b0a368bf9b7f8ff48b3277d4e412791c4a497", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 140, "deletions": 98, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -352,6 +352,14 @@ pub trait TypeErrCtxtExt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         err: &mut Diagnostic,\n     );\n+    fn probe_assoc_types_at_expr(\n+        &self,\n+        type_diffs: &[TypeError<'tcx>],\n+        span: Span,\n+        prev_ty: Ty<'tcx>,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Vec<Option<(Span, (DefId, Ty<'tcx>))>>;\n }\n \n fn predicate_constraint(generics: &hir::Generics<'_>, pred: ty::Predicate<'_>) -> (Span, String) {\n@@ -1618,7 +1626,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         let trait_obj = if has_dyn { &snippet[4..] } else { &snippet };\n         if only_never_return {\n             // No return paths, probably using `panic!()` or similar.\n-            // Suggest `-> T`, `-> impl Trait`, and if `Trait` is object safe, `-> Box<dyn Trait>`.\n+            // Suggest `-> impl Trait`, and if `Trait` is object safe, `-> Box<dyn Trait>`.\n             suggest_trait_object_return_type_alternatives(\n                 err,\n                 ret_ty.span,\n@@ -2540,6 +2548,25 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n             ObligationCauseCode::SizedArgumentType(sp) => {\n                 if let Some(span) = sp {\n+                    if let ty::PredicateKind::Clause(clause) = predicate.kind().skip_binder()\n+                        && let ty::Clause::Trait(trait_pred) = clause\n+                        && let ty::Dynamic(..) = trait_pred.self_ty().kind()\n+                    {\n+                        let span = if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n+                            && snippet.starts_with(\"dyn \")\n+                        {\n+                            let pos = snippet.len() - snippet[3..].trim_start().len();\n+                            span.with_hi(span.lo() + BytePos(pos as u32))\n+                        } else {\n+                            span.shrink_to_lo()\n+                        };\n+                        err.span_suggestion_verbose(\n+                            span,\n+                            \"you can use `impl Trait` as the argument type\",\n+                            \"impl \".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n                     err.span_suggestion_verbose(\n                         span.shrink_to_lo(),\n                         \"function arguments must have a statically known size, borrowed types \\\n@@ -3152,23 +3179,37 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             if let ObligationCauseCode::ExprBindingObligation(def_id, _, _, idx) = parent_code.deref()\n                 && let predicates = self.tcx.predicates_of(def_id).instantiate_identity(self.tcx)\n                 && let Some(pred) = predicates.predicates.get(*idx)\n-                && let Ok(trait_pred) = pred.kind().try_map_bound(|pred| match pred {\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n-                    _ => Err(()),\n-                })\n             {\n-                let mut c = CollectAllMismatches {\n-                    infcx: self.infcx,\n-                    param_env,\n-                    errors: vec![],\n-                };\n-                if let Ok(trait_predicate) = predicate.kind().try_map_bound(|pred| match pred {\n+                if let Ok(trait_pred) = pred.kind().try_map_bound(|pred| match pred {\n                     ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n                     _ => Err(()),\n-                }) {\n+                })\n+                    && let Ok(trait_predicate) = predicate.kind().try_map_bound(|pred| match pred {\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n+                        _ => Err(()),\n+                    })\n+                {\n+                    let mut c = CollectAllMismatches {\n+                        infcx: self.infcx,\n+                        param_env,\n+                        errors: vec![],\n+                    };\n                     if let Ok(_) = c.relate(trait_pred, trait_predicate) {\n                         type_diffs = c.errors;\n                     }\n+                } else if let ty::PredicateKind::Clause(\n+                    ty::Clause::Projection(proj)\n+                ) = pred.kind().skip_binder()\n+                    && let ty::PredicateKind::Clause(\n+                        ty::Clause::Projection(projection)\n+                    ) = predicate.kind().skip_binder()\n+                {\n+                    type_diffs = vec![\n+                        Sorts(ty::error::ExpectedFound {\n+                            expected: self.tcx.mk_ty(ty::Alias(ty::Projection, proj.projection_ty)),\n+                            found: projection.term.ty().unwrap(),\n+                        }),\n+                    ];\n                 }\n             }\n             if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n@@ -3221,10 +3262,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         let tcx = self.tcx;\n \n+        let mut print_root_expr = true;\n         let mut assocs = vec![];\n-        // We still want to point at the different methods even if there hasn't\n-        // been a change of assoc type.\n-        let mut call_spans = vec![];\n         let mut expr = expr;\n         let mut prev_ty = self.resolve_vars_if_possible(\n             typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n@@ -3234,63 +3273,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n             //               ^^^^^^ ^^^^^^^^^^^\n             expr = rcvr_expr;\n-            let mut assocs_in_this_method = Vec::with_capacity(type_diffs.len());\n-            call_spans.push(span);\n-\n-            let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n-            for diff in &type_diffs {\n-                let Sorts(expected_found) = diff else { continue; };\n-                let ty::Alias(ty::Projection, proj) = expected_found.expected.kind() else { continue; };\n-\n-                let origin =\n-                    TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span };\n-                let trait_def_id = proj.trait_def_id(self.tcx);\n-                // Make `Self` be equivalent to the type of the call chain\n-                // expression we're looking at now, so that we can tell what\n-                // for example `Iterator::Item` is at this point in the chain.\n-                let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n-                    match param.kind {\n-                        ty::GenericParamDefKind::Type { .. } => {\n-                            if param.index == 0 {\n-                                return prev_ty.into();\n-                            }\n-                        }\n-                        ty::GenericParamDefKind::Lifetime\n-                        | ty::GenericParamDefKind::Const { .. } => {}\n-                    }\n-                    self.var_for_def(span, param)\n-                });\n-                // This will hold the resolved type of the associated type, if the\n-                // current expression implements the trait that associated type is\n-                // in. For example, this would be what `Iterator::Item` is here.\n-                let ty_var = self.infcx.next_ty_var(origin);\n-                // This corresponds to `<ExprTy as Iterator>::Item = _`.\n-                let projection = ty::Binder::dummy(ty::PredicateKind::Clause(\n-                    ty::Clause::Projection(ty::ProjectionPredicate {\n-                        projection_ty: tcx.mk_alias_ty(proj.def_id, substs),\n-                        term: ty_var.into(),\n-                    }),\n-                ));\n-                // Add `<ExprTy as Iterator>::Item = _` obligation.\n-                ocx.register_obligation(Obligation::misc(\n-                    self.tcx,\n-                    span,\n-                    expr.hir_id,\n-                    param_env,\n-                    projection,\n-                ));\n-                if ocx.select_where_possible().is_empty() {\n-                    // `ty_var` now holds the type that `Item` is for `ExprTy`.\n-                    let ty_var = self.resolve_vars_if_possible(ty_var);\n-                    assocs_in_this_method.push(Some((span, (proj.def_id, ty_var))));\n-                } else {\n-                    // `<ExprTy as Iterator>` didn't select, so likely we've\n-                    // reached the end of the iterator chain, like the originating\n-                    // `Vec<_>`.\n-                    // Keep the space consistent for later zipping.\n-                    assocs_in_this_method.push(None);\n-                }\n-            }\n+            let assocs_in_this_method =\n+                self.probe_assoc_types_at_expr(&type_diffs, span, prev_ty, expr.hir_id, param_env);\n             assocs.push(assocs_in_this_method);\n             prev_ty = self.resolve_vars_if_possible(\n                 typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n@@ -3300,17 +3284,32 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n                 && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n                 && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n-                && let Some(hir::Node::Local(local)) = self.tcx.hir().find(parent_hir_id)\n-                && let Some(binding_expr) = local.init\n+                && let Some(parent) = self.tcx.hir().find(parent_hir_id)\n             {\n-                // We've reached the root of the method call chain and it is a\n-                // binding. Get the binding creation and try to continue the chain.\n-                expr = binding_expr;\n+                // We've reached the root of the method call chain...\n+                if let hir::Node::Local(local) = parent\n+                    && let Some(binding_expr) = local.init\n+                {\n+                    // ...and it is a binding. Get the binding creation and continue the chain.\n+                    expr = binding_expr;\n+                }\n+                if let hir::Node::Param(param) = parent {\n+                    // ...and it is a an fn argument.\n+                    let prev_ty = self.resolve_vars_if_possible(\n+                        typeck_results.node_type_opt(param.hir_id).unwrap_or(tcx.ty_error()),\n+                    );\n+                    let assocs_in_this_method = self.probe_assoc_types_at_expr(&type_diffs, param.ty_span, prev_ty, param.hir_id, param_env);\n+                    if assocs_in_this_method.iter().any(|a| a.is_some()) {\n+                        assocs.push(assocs_in_this_method);\n+                        print_root_expr = false;\n+                    }\n+                    break;\n+                }\n             }\n         }\n         // We want the type before deref coercions, otherwise we talk about `&[_]`\n         // instead of `Vec<_>`.\n-        if let Some(ty) = typeck_results.expr_ty_opt(expr) {\n+        if let Some(ty) = typeck_results.expr_ty_opt(expr) && print_root_expr {\n             let ty = with_forced_trimmed_paths!(self.ty_to_string(ty));\n             // Point at the root expression\n             // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n@@ -3324,7 +3323,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let Some(prev_assoc_in_method) = assocs.peek() else {\n                 for entry in assocs_in_method {\n                     let Some((span, (assoc, ty))) = entry else { continue; };\n-                    if type_diffs.iter().any(|diff| {\n+                    if primary_spans.is_empty() || type_diffs.iter().any(|diff| {\n                         let Sorts(expected_found) = diff else { return false; };\n                         self.can_eq(param_env, expected_found.found, ty).is_ok()\n                     }) {\n@@ -3353,7 +3352,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         let ty_str = with_forced_trimmed_paths!(self.ty_to_string(ty));\n \n                         let assoc = with_forced_trimmed_paths!(self.tcx.def_path_str(assoc));\n-                        if ty != *prev_ty {\n+                        if self.can_eq(param_env, ty, *prev_ty).is_err() {\n                             if type_diffs.iter().any(|diff| {\n                                 let Sorts(expected_found) = diff else { return false; };\n                                 self.can_eq(param_env, expected_found.found, ty).is_ok()\n@@ -3380,27 +3379,77 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n         }\n-        for span in call_spans {\n-            if span_labels.iter().find(|(s, _)| *s == span).is_none() {\n-                // Ensure we are showing the entire chain, even if the assoc types\n-                // haven't changed.\n-                span_labels.push((span, String::new()));\n-            }\n-        }\n         if !primary_spans.is_empty() {\n             let mut multi_span: MultiSpan = primary_spans.into();\n             for (span, label) in span_labels {\n                 multi_span.push_span_label(span, label);\n             }\n             err.span_note(\n                 multi_span,\n-                format!(\n-                    \"the method call chain might not have had the expected \\\n-                                     associated types\",\n-                ),\n+                format!(\"the method call chain might not have had the expected associated types\"),\n             );\n         }\n     }\n+\n+    fn probe_assoc_types_at_expr(\n+        &self,\n+        type_diffs: &[TypeError<'tcx>],\n+        span: Span,\n+        prev_ty: Ty<'tcx>,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Vec<Option<(Span, (DefId, Ty<'tcx>))>> {\n+        let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n+        let mut assocs_in_this_method = Vec::with_capacity(type_diffs.len());\n+        for diff in type_diffs {\n+            let Sorts(expected_found) = diff else { continue; };\n+            let ty::Alias(ty::Projection, proj) = expected_found.expected.kind() else { continue; };\n+\n+            let origin = TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span };\n+            let trait_def_id = proj.trait_def_id(self.tcx);\n+            // Make `Self` be equivalent to the type of the call chain\n+            // expression we're looking at now, so that we can tell what\n+            // for example `Iterator::Item` is at this point in the chain.\n+            let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n+                match param.kind {\n+                    ty::GenericParamDefKind::Type { .. } => {\n+                        if param.index == 0 {\n+                            return prev_ty.into();\n+                        }\n+                    }\n+                    ty::GenericParamDefKind::Lifetime | ty::GenericParamDefKind::Const { .. } => {}\n+                }\n+                self.var_for_def(span, param)\n+            });\n+            // This will hold the resolved type of the associated type, if the\n+            // current expression implements the trait that associated type is\n+            // in. For example, this would be what `Iterator::Item` is here.\n+            let ty_var = self.infcx.next_ty_var(origin);\n+            // This corresponds to `<ExprTy as Iterator>::Item = _`.\n+            let projection = ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::Projection(\n+                ty::ProjectionPredicate {\n+                    projection_ty: self.tcx.mk_alias_ty(proj.def_id, substs),\n+                    term: ty_var.into(),\n+                },\n+            )));\n+            // Add `<ExprTy as Iterator>::Item = _` obligation.\n+            ocx.register_obligation(Obligation::misc(\n+                self.tcx, span, body_id, param_env, projection,\n+            ));\n+            if ocx.select_where_possible().is_empty() {\n+                // `ty_var` now holds the type that `Item` is for `ExprTy`.\n+                let ty_var = self.resolve_vars_if_possible(ty_var);\n+                assocs_in_this_method.push(Some((span, (proj.def_id, ty_var))));\n+            } else {\n+                // `<ExprTy as Iterator>` didn't select, so likely we've\n+                // reached the end of the iterator chain, like the originating\n+                // `Vec<_>`.\n+                // Keep the space consistent for later zipping.\n+                assocs_in_this_method.push(None);\n+            }\n+        }\n+        assocs_in_this_method\n+    }\n }\n \n /// Add a hint to add a missing borrow or remove an unnecessary one.\n@@ -3580,13 +3629,6 @@ fn suggest_trait_object_return_type_alternatives(\n     trait_obj: &str,\n     is_object_safe: bool,\n ) {\n-    err.span_suggestion(\n-        ret_ty,\n-        \"use some type `T` that is `T: Sized` as the return type if all return paths have the \\\n-            same type\",\n-        \"T\",\n-        Applicability::MaybeIncorrect,\n-    );\n     err.span_suggestion(\n         ret_ty,\n         &format!("}, {"sha": "0e0a883d9f5908ffcf0dfe5c41a34daa5c1639e2", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -451,19 +451,21 @@ impl<'tcx> WfPredicates<'tcx> {\n                 GenericArgKind::Const(ct) => {\n                     match ct.kind() {\n                         ty::ConstKind::Unevaluated(uv) => {\n-                            let obligations = self.nominal_obligations(uv.def.did, uv.substs);\n-                            self.out.extend(obligations);\n-\n-                            let predicate =\n-                                ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(ct));\n-                            let cause = self.cause(traits::WellFormed(None));\n-                            self.out.push(traits::Obligation::with_depth(\n-                                self.tcx(),\n-                                cause,\n-                                self.recursion_depth,\n-                                self.param_env,\n-                                predicate,\n-                            ));\n+                            if !ct.has_escaping_bound_vars() {\n+                                let obligations = self.nominal_obligations(uv.def.did, uv.substs);\n+                                self.out.extend(obligations);\n+\n+                                let predicate =\n+                                    ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(ct));\n+                                let cause = self.cause(traits::WellFormed(None));\n+                                self.out.push(traits::Obligation::with_depth(\n+                                    self.tcx(),\n+                                    cause,\n+                                    self.recursion_depth,\n+                                    self.param_env,\n+                                    predicate,\n+                                ));\n+                            }\n                         }\n                         ty::ConstKind::Infer(_) => {\n                             let cause = self.cause(traits::WellFormed(None));"}, {"sha": "d1601272af7596e709ab607294aa430b953ca4c0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -325,7 +325,7 @@ pub(crate) fn build_impls(\n     // * https://github.com/rust-lang/rust/pull/99917 \u2014 where the feature got used\n     // * https://github.com/rust-lang/rust/issues/53487 \u2014 overall tracking issue for Error\n     if tcx.has_attr(did, sym::rustc_has_incoherent_inherent_impls) {\n-        use rustc_middle::ty::fast_reject::SimplifiedTypeGen::*;\n+        use rustc_middle::ty::fast_reject::SimplifiedType::*;\n         let type_ =\n             if tcx.is_trait(did) { TraitSimplifiedType(did) } else { AdtSimplifiedType(did) };\n         for &did in tcx.incoherent_impls(type_) {"}, {"sha": "7a13e7e36d169c3c50cb31561469381a9414b651", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1870,7 +1870,7 @@ impl PrimitiveType {\n     }\n \n     pub(crate) fn simplified_types() -> &'static SimplifiedTypes {\n-        use ty::fast_reject::SimplifiedTypeGen::*;\n+        use ty::fast_reject::SimplifiedType::*;\n         use ty::{FloatTy, IntTy, UintTy};\n         use PrimitiveType::*;\n         static CELL: OnceCell<SimplifiedTypes> = OnceCell::new();"}, {"sha": "a527e9feaec3758a6c5e104272c5bbb2d0011b12", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1071,6 +1071,10 @@ pre.rust .doccomment {\n \tcolor: var(--code-highlight-doc-comment-color);\n }\n \n+.rustdoc.source .example-wrap pre.rust a {\n+\tbackground: var(--codeblock-link-background);\n+}\n+\n .example-wrap.compile_fail,\n .example-wrap.should_panic {\n \tborder-left: 2px solid var(--codeblock-error-color);"}, {"sha": "de0dfcd469045e74c94e3037f60500bfbc2d50e4", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -88,6 +88,7 @@ Original by Dempfi (https://github.com/dempfi/ayu)\n \t--source-sidebar-background-selected: #14191f;\n \t--source-sidebar-background-hover: #14191f;\n \t--table-alt-row-background-color: #191f26;\n+\t--codeblock-link-background: #333;\n }\n \n h1, h2, h3, h4 {\n@@ -154,9 +155,6 @@ pre, .rustdoc.source .example-wrap {\n .sidebar h3 a {\n \tcolor: white;\n }\n-body.source .example-wrap pre.rust a {\n-\tbackground: #333;\n-}\n \n .result-name .primitive > i, .result-name .keyword > i {\n \tcolor: #788797;"}, {"sha": "dd7fc6892537c35b57a5e12ce63cfc1a71b3e545", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -83,10 +83,7 @@\n \t--source-sidebar-background-selected: #333;\n \t--source-sidebar-background-hover: #444;\n \t--table-alt-row-background-color: #2A2A2A;\n-}\n-\n-body.source .example-wrap pre.rust a {\n-\tbackground: #333;\n+\t--codeblock-link-background: #333;\n }\n \n #titles > button:not(.selected) {"}, {"sha": "b69d8a1cff95753f1255550bc5d87be641af01f0", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -80,10 +80,7 @@\n \t--source-sidebar-background-selected: #fff;\n \t--source-sidebar-background-hover: #e0e0e0;\n \t--table-alt-row-background-color: #F5F5F5;\n-}\n-\n-body.source .example-wrap pre.rust a {\n-\tbackground: #eee;\n+\t--codeblock-link-background: #eee;\n }\n \n #titles > button:not(.selected) {"}, {"sha": "3537e669608d15faf6afbcc26b5410b865225720", "filename": "src/test/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -35,6 +35,7 @@\n     -Z            dump-mir-exclude-pass-number=val -- exclude the pass number when dumping MIR (used in tests) (default: no)\n     -Z                       dump-mir-graphviz=val -- in addition to `.mir` files, create graphviz `.dot` files (and with `-Z instrument-coverage`, also create a `.dot` file for the MIR-derived coverage graph) (default: no)\n     -Z                       dump-mir-spanview=val -- in addition to `.mir` files, create `.html` files to view spans for all `statement`s (including terminators), only `terminator` spans, or computed `block` spans (one span encompassing a block's terminator and all statements). If `-Z instrument-coverage` is also enabled, create an additional `.html` file showing the computed coverage spans.\n+    -Z                         dump-mono-stats=val -- output statistics about monomorphization collection (format: markdown)\n     -Z                           dwarf-version=val -- version of DWARF debug information to emit (default: 2 or 4, depending on platform)\n     -Z                               dylib-lto=val -- enables LTO for dylib crate type\n     -Z                        emit-stack-sizes=val -- emit a section containing stack size metadata (default: no)"}, {"sha": "fed60ccf089d05c85288a7ef3774506f7d2dbd96", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -4,5 +4,5 @@ trait I32Iterator = Iterator<Item = i32>;\n \n fn main() {\n     let _: &dyn I32Iterator<Item = u32> = &vec![42].into_iter();\n-    //~^ ERROR expected `std::vec::IntoIter<u32>` to be an iterator that yields `i32`, but it yields `u32`\n+    //~^ ERROR expected `IntoIter<u32>` to be an iterator that yields `i32`, but it yields `u32`\n }"}, {"sha": "a28a0b74e4accd98c47bbf6f001d9562560f4ff8", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: expected `std::vec::IntoIter<u32>` to be an iterator that yields `i32`, but it yields `u32`\n+error[E0271]: expected `IntoIter<u32>` to be an iterator that yields `i32`, but it yields `u32`\n   --> $DIR/associated-types-overridden-binding-2.rs:6:43\n    |\n LL |     let _: &dyn I32Iterator<Item = u32> = &vec![42].into_iter();"}, {"sha": "3906d64c9462453682f8edf42d47332c5619b14f", "filename": "src/test/ui/confuse-field-and-method/issue-33784.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-33784.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-33784.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-33784.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,4 +1,4 @@\n-error[E0599]: no method named `closure` found for reference `&Obj<[closure@$DIR/issue-33784.rs:25:43: 25:45]>` in the current scope\n+error[E0599]: no method named `closure` found for reference `&Obj<[closure@issue-33784.rs:25:43]>` in the current scope\n   --> $DIR/issue-33784.rs:27:7\n    |\n LL |     p.closure();\n@@ -9,7 +9,7 @@ help: to call the function stored in `closure`, surround the field access with p\n LL |     (p.closure)();\n    |     +         +\n \n-error[E0599]: no method named `fn_ptr` found for reference `&&Obj<[closure@$DIR/issue-33784.rs:25:43: 25:45]>` in the current scope\n+error[E0599]: no method named `fn_ptr` found for reference `&&Obj<[closure@issue-33784.rs:25:43]>` in the current scope\n   --> $DIR/issue-33784.rs:29:7\n    |\n LL |     q.fn_ptr();"}, {"sha": "4237b3cad8e7fd8d33779d104a3145af382c89e0", "filename": "src/test/ui/const-generics/issue-105689.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fconst-generics%2Fissue-105689.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fconst-generics%2Fissue-105689.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-105689.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+// edition:2021\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+#[allow(unused)]\n+async fn foo<'a>() {\n+    let _data = &mut [0u8; { 1 + 4 }];\n+    bar().await\n+}\n+\n+async fn bar() {}\n+\n+fn main() {}"}, {"sha": "0e580aedeaa921e7fd548624dc075a660864600d", "filename": "src/test/ui/empty/empty-struct-braces-expr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fempty%2Fempty-struct-braces-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fempty%2Fempty-struct-braces-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-struct-braces-expr.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -100,22 +100,22 @@ help: a unit struct with a similar name exists\n LL |     let xe1 = XEmpty2();\n    |               ~~~~~~~\n \n-error[E0599]: no variant or associated item named `Empty3` found for enum `empty_struct::XE` in the current scope\n+error[E0599]: no variant or associated item named `Empty3` found for enum `XE` in the current scope\n   --> $DIR/empty-struct-braces-expr.rs:25:19\n    |\n LL |     let xe3 = XE::Empty3;\n    |                   ^^^^^^\n    |                   |\n-   |                   variant or associated item not found in `empty_struct::XE`\n+   |                   variant or associated item not found in `XE`\n    |                   help: there is a variant with a similar name: `XEmpty3`\n \n-error[E0599]: no variant or associated item named `Empty3` found for enum `empty_struct::XE` in the current scope\n+error[E0599]: no variant or associated item named `Empty3` found for enum `XE` in the current scope\n   --> $DIR/empty-struct-braces-expr.rs:26:19\n    |\n LL |     let xe3 = XE::Empty3();\n    |                   ^^^^^^\n    |                   |\n-   |                   variant or associated item not found in `empty_struct::XE`\n+   |                   variant or associated item not found in `XE`\n    |                   help: there is a variant with a similar name: `XEmpty3`\n \n error[E0599]: no variant named `Empty1` found for enum `empty_struct::XE`"}, {"sha": "c04e57843d4b21f4d16e5205630273d4f199cc37", "filename": "src/test/ui/feature-gates/feature-gate-unsized_fn_params.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_fn_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_fn_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_fn_params.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,5 +1,5 @@\n+#![allow(unused, bare_trait_objects)]\n #[repr(align(256))]\n-#[allow(dead_code)]\n struct A {\n     v: u8,\n }\n@@ -14,13 +14,17 @@ impl Foo for A {\n     }\n }\n \n-fn foo(x: dyn Foo) {\n-    //~^ ERROR [E0277]\n+fn foo(x: dyn Foo) { //~ ERROR [E0277]\n     x.foo()\n }\n \n+fn bar(x: Foo) { //~ ERROR [E0277]\n+    x.foo()\n+}\n+\n+fn qux(_: [()]) {} //~ ERROR [E0277]\n+\n fn main() {\n     let x: Box<dyn Foo> = Box::new(A { v: 22 });\n-    foo(*x);\n-    //~^ ERROR [E0277]\n+    foo(*x); //~ ERROR [E0277]\n }"}, {"sha": "92c71392672e197537c6a72525b9059a31c19852", "filename": "src/test/ui/feature-gates/feature-gate-unsized_fn_params.stderr", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_fn_params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_fn_params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_fn_params.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -6,13 +6,47 @@ LL | fn foo(x: dyn Foo) {\n    |\n    = help: the trait `Sized` is not implemented for `(dyn Foo + 'static)`\n    = help: unsized fn params are gated as an unstable feature\n+help: you can use `impl Trait` as the argument type\n+   |\n+LL | fn foo(x: impl Foo) {\n+   |           ~~~~\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n LL | fn foo(x: &dyn Foo) {\n    |           +\n \n error[E0277]: the size for values of type `(dyn Foo + 'static)` cannot be known at compilation time\n-  --> $DIR/feature-gate-unsized_fn_params.rs:24:9\n+  --> $DIR/feature-gate-unsized_fn_params.rs:21:8\n+   |\n+LL | fn bar(x: Foo) {\n+   |        ^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `(dyn Foo + 'static)`\n+   = help: unsized fn params are gated as an unstable feature\n+help: you can use `impl Trait` as the argument type\n+   |\n+LL | fn bar(x: impl Foo) {\n+   |           ++++\n+help: function arguments must have a statically known size, borrowed types always have a known size\n+   |\n+LL | fn bar(x: &Foo) {\n+   |           +\n+\n+error[E0277]: the size for values of type `[()]` cannot be known at compilation time\n+  --> $DIR/feature-gate-unsized_fn_params.rs:25:8\n+   |\n+LL | fn qux(_: [()]) {}\n+   |        ^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `[()]`\n+   = help: unsized fn params are gated as an unstable feature\n+help: function arguments must have a statically known size, borrowed types always have a known size\n+   |\n+LL | fn qux(_: &[()]) {}\n+   |           +\n+\n+error[E0277]: the size for values of type `(dyn Foo + 'static)` cannot be known at compilation time\n+  --> $DIR/feature-gate-unsized_fn_params.rs:29:9\n    |\n LL |     foo(*x);\n    |         ^^ doesn't have a size known at compile-time\n@@ -21,6 +55,6 @@ LL |     foo(*x);\n    = note: all function arguments must have a statically known size\n    = help: unsized fn params are gated as an unstable feature\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "9aeeb88cf04f2befd08f101afdb57860769e220d", "filename": "src/test/ui/feature-gates/feature-gate-unsized_locals.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_locals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_locals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_locals.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -6,6 +6,10 @@ LL | fn f(f: dyn FnOnce()) {}\n    |\n    = help: the trait `Sized` is not implemented for `(dyn FnOnce() + 'static)`\n    = help: unsized fn params are gated as an unstable feature\n+help: you can use `impl Trait` as the argument type\n+   |\n+LL | fn f(f: impl FnOnce()) {}\n+   |         ~~~~\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n LL | fn f(f: &dyn FnOnce()) {}"}, {"sha": "463ac7684ecdfea3a73122953e24915249278b66", "filename": "src/test/ui/functions-closures/fn-help-with-err.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -17,11 +17,11 @@ note: `Bar` defines an item `bar`, perhaps you need to implement it\n LL | trait Bar {\n    | ^^^^^^^^^\n \n-error[E0599]: no method named `bar` found for struct `Arc<[closure@$DIR/fn-help-with-err.rs:22:36: 22:38]>` in the current scope\n+error[E0599]: no method named `bar` found for struct `Arc<[closure@fn-help-with-err.rs:22:36]>` in the current scope\n   --> $DIR/fn-help-with-err.rs:23:10\n    |\n LL |     arc2.bar();\n-   |          ^^^ method not found in `Arc<[closure@$DIR/fn-help-with-err.rs:22:36: 22:38]>`\n+   |          ^^^ method not found in `Arc<[closure@fn-help-with-err.rs:22:36]>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `Bar` defines an item `bar`, perhaps you need to implement it"}, {"sha": "0458d2535f2f56ad83eac2b0d3be6ceaaf28c22b", "filename": "src/test/ui/higher-rank-trait-bounds/issue-30786.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-30786.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-30786.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-30786.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,4 +1,4 @@\n-error[E0599]: the method `filterx` exists for struct `Map<Repeat, [closure@$DIR/issue-30786.rs:117:27: 117:34]>`, but its trait bounds were not satisfied\n+error[E0599]: the method `filterx` exists for struct `Map<Repeat, [closure@issue-30786.rs:117:27]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:118:22\n    |\n LL | pub struct Map<S, F> {\n@@ -8,7 +8,7 @@ LL | pub struct Map<S, F> {\n    | doesn't satisfy `_: StreamExt`\n ...\n LL |     let filter = map.filterx(|x: &_| true);\n-   |                      ^^^^^^^ method cannot be called due to unsatisfied trait bounds\n+   |                      ^^^^^^^ method cannot be called on `Map<Repeat, [closure@issue-30786.rs:117:27]>` due to unsatisfied trait bounds\n    |\n note: the following trait bounds were not satisfied:\n       `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:117:27: 117:34]>: Stream`\n@@ -19,7 +19,7 @@ note: the following trait bounds were not satisfied:\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n \n-error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'a> fn(&'a u64) -> &'a u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:129:30: 129:37]>`, but its trait bounds were not satisfied\n+error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'a> fn(&'a u64) -> &'a u64 {identity::<u64>}>, [closure@issue-30786.rs:129:30]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:130:24\n    |\n LL | pub struct Filter<S, F> {"}, {"sha": "fdd192f43137067a274ebe008c03d2641a9fad0b", "filename": "src/test/ui/higher-rank-trait-bounds/issue-62203-hrtb-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -30,7 +30,7 @@ LL |     where\n LL |         F: for<'r> T0<'r, (<Self as Ty<'r>>::V,), O = <B as Ty<'r>>::V>,\n    |                                                   ^^^^^^^^^^^^^^^^^^^^ required by this bound in `T1::m`\n \n-error[E0271]: expected `[closure@$DIR/issue-62203-hrtb-ice.rs:42:16: 42:19]` to be a closure that returns `Unit3`, but it returns `Unit4`\n+error[E0271]: expected `[closure@issue-62203-hrtb-ice.rs:42:16]` to be a closure that returns `Unit3`, but it returns `Unit4`\n   --> $DIR/issue-62203-hrtb-ice.rs:39:9\n    |\n LL |       let v = Unit2.m("}, {"sha": "7f73d5e12d1962a9288eb62d472d632b983b1ae4", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -70,10 +70,6 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn bak() -> dyn Trait { unimplemented!() }\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-help: use some type `T` that is `T: Sized` as the return type if all return paths have the same type\n-   |\n-LL | fn bak() -> T { unimplemented!() }\n-   |             ~\n help: use `impl Trait` as the return type if all return paths have the same type but you want to expose only the trait in the signature\n    |\n LL | fn bak() -> impl Trait { unimplemented!() }"}, {"sha": "548c89d0a3871372e87270fd08b5ad3b2e1421a4", "filename": "src/test/ui/impl-trait/no-method-suggested-traits.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -145,11 +145,11 @@ note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n LL |     pub trait Bar {\n    |     ^^^^^^^^^^^^^\n \n-error[E0599]: no method named `method2` found for struct `no_method_suggested_traits::Foo` in the current scope\n+error[E0599]: no method named `method2` found for struct `Foo` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:50:37\n    |\n LL |     no_method_suggested_traits::Foo.method2();\n-   |                                     ^^^^^^^ method not found in `no_method_suggested_traits::Foo`\n+   |                                     ^^^^^^^ method not found in `Foo`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n@@ -158,11 +158,11 @@ note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n LL |     pub trait Bar {\n    |     ^^^^^^^^^^^^^\n \n-error[E0599]: no method named `method2` found for struct `Rc<&mut Box<&no_method_suggested_traits::Foo>>` in the current scope\n+error[E0599]: no method named `method2` found for struct `Rc<&mut Box<&Foo>>` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:52:71\n    |\n LL |     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Foo)).method2();\n-   |                                                                       ^^^^^^^ method not found in `Rc<&mut Box<&no_method_suggested_traits::Foo>>`\n+   |                                                                       ^^^^^^^ method not found in `Rc<&mut Box<&Foo>>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n@@ -171,11 +171,11 @@ note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n LL |     pub trait Bar {\n    |     ^^^^^^^^^^^^^\n \n-error[E0599]: no method named `method2` found for enum `no_method_suggested_traits::Bar` in the current scope\n+error[E0599]: no method named `method2` found for enum `Bar` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:54:40\n    |\n LL |     no_method_suggested_traits::Bar::X.method2();\n-   |                                        ^^^^^^^ method not found in `no_method_suggested_traits::Bar`\n+   |                                        ^^^^^^^ method not found in `Bar`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n@@ -184,11 +184,11 @@ note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n LL |     pub trait Bar {\n    |     ^^^^^^^^^^^^^\n \n-error[E0599]: no method named `method2` found for struct `Rc<&mut Box<&no_method_suggested_traits::Bar>>` in the current scope\n+error[E0599]: no method named `method2` found for struct `Rc<&mut Box<&Bar>>` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:56:74\n    |\n LL |     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Bar::X)).method2();\n-   |                                                                          ^^^^^^^ method not found in `Rc<&mut Box<&no_method_suggested_traits::Bar>>`\n+   |                                                                          ^^^^^^^ method not found in `Rc<&mut Box<&Bar>>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n@@ -255,29 +255,29 @@ error[E0599]: no method named `method3` found for struct `Rc<&mut Box<&usize>>`\n LL |     std::rc::Rc::new(&mut Box::new(&1_usize)).method3();\n    |                                               ^^^^^^^ method not found in `Rc<&mut Box<&usize>>`\n \n-error[E0599]: no method named `method3` found for struct `no_method_suggested_traits::Foo` in the current scope\n+error[E0599]: no method named `method3` found for struct `Foo` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:71:37\n    |\n LL |     no_method_suggested_traits::Foo.method3();\n-   |                                     ^^^^^^^ method not found in `no_method_suggested_traits::Foo`\n+   |                                     ^^^^^^^ method not found in `Foo`\n \n-error[E0599]: no method named `method3` found for struct `Rc<&mut Box<&no_method_suggested_traits::Foo>>` in the current scope\n+error[E0599]: no method named `method3` found for struct `Rc<&mut Box<&Foo>>` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:72:71\n    |\n LL |     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Foo)).method3();\n-   |                                                                       ^^^^^^^ method not found in `Rc<&mut Box<&no_method_suggested_traits::Foo>>`\n+   |                                                                       ^^^^^^^ method not found in `Rc<&mut Box<&Foo>>`\n \n-error[E0599]: no method named `method3` found for enum `no_method_suggested_traits::Bar` in the current scope\n+error[E0599]: no method named `method3` found for enum `Bar` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:74:40\n    |\n LL |     no_method_suggested_traits::Bar::X.method3();\n-   |                                        ^^^^^^^ method not found in `no_method_suggested_traits::Bar`\n+   |                                        ^^^^^^^ method not found in `Bar`\n \n-error[E0599]: no method named `method3` found for struct `Rc<&mut Box<&no_method_suggested_traits::Bar>>` in the current scope\n+error[E0599]: no method named `method3` found for struct `Rc<&mut Box<&Bar>>` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:75:74\n    |\n LL |     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Bar::X)).method3();\n-   |                                                                          ^^^^^^^ method not found in `Rc<&mut Box<&no_method_suggested_traits::Bar>>`\n+   |                                                                          ^^^^^^^ method not found in `Rc<&mut Box<&Bar>>`\n \n error: aborting due to 24 previous errors\n "}, {"sha": "1669b550a9bafe26442e406d91bb02a980d135e7", "filename": "src/test/ui/issues/issue-18107.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -4,10 +4,6 @@ error[E0746]: return type cannot have an unboxed trait object\n LL |     dyn AbstractRenderer\n    |     ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-help: use some type `T` that is `T: Sized` as the return type if all return paths have the same type\n-   |\n-LL |     T\n-   |\n help: use `impl AbstractRenderer` as the return type if all return paths have the same type but you want to expose only the trait in the signature\n    |\n LL |     impl AbstractRenderer"}, {"sha": "7808cbf8aa10840644bb7e85e8c9a81045adb8fc", "filename": "src/test/ui/issues/issue-30123.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-30123.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-30123.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30123.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,8 +1,8 @@\n-error[E0599]: no function or associated item named `new_undirected` found for struct `issue_30123_aux::Graph<i32, i32>` in the current scope\n+error[E0599]: no function or associated item named `new_undirected` found for struct `Graph<i32, i32>` in the current scope\n   --> $DIR/issue-30123.rs:7:33\n    |\n LL |     let ug = Graph::<i32, i32>::new_undirected();\n-   |                                 ^^^^^^^^^^^^^^ function or associated item not found in `issue_30123_aux::Graph<i32, i32>`\n+   |                                 ^^^^^^^^^^^^^^ function or associated item not found in `Graph<i32, i32>`\n    |\n    = note: the function or associated item was found for\n            - `issue_30123_aux::Graph<N, E, Undirected>`"}, {"sha": "f3be99f9bcb4b3e09efcd9029b355d188c5ba5ec", "filename": "src/test/ui/issues/issue-31173.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,15 +1,27 @@\n-error[E0271]: expected `TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>` to be an iterator that yields `&_`, but it yields `u8`\n+error[E0271]: expected `TakeWhile<&mut IntoIter<u8>, [closure@issue-31173.rs:7:21]>` to be an iterator that yields `&_`, but it yields `u8`\n   --> $DIR/issue-31173.rs:11:10\n    |\n LL |         .cloned()\n    |          ^^^^^^ expected reference, found `u8`\n    |\n    = note: expected reference `&_`\n                    found type `u8`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/issue-31173.rs:3:20\n+   |\n+LL |   pub fn get_tok(it: &mut IntoIter<u8>) {\n+   |                      ^^^^^^^^^^^^^^^^^ `Iterator::Item` is `u8` here\n+...\n+LL |           .take_while(|&x| {\n+   |  __________-\n+LL | |             found_e = true;\n+LL | |             false\n+LL | |         })\n+   | |__________- `Iterator::Item` remains `u8` here\n note: required by a bound in `cloned`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n-error[E0599]: the method `collect` exists for struct `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>`, but its trait bounds were not satisfied\n+error[E0599]: the method `collect` exists for struct `Cloned<TakeWhile<&mut IntoIter<u8>, [closure@issue-31173.rs:7:21]>>`, but its trait bounds were not satisfied\n   --> $DIR/issue-31173.rs:12:10\n    |\n LL |         .collect();"}, {"sha": "e3b6dcf55a7448296ea39c39de2c428b40e59ff2", "filename": "src/test/ui/issues/issue-33941.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -3,7 +3,7 @@\n use std::collections::HashMap;\n \n fn main() {\n-    for _ in HashMap::new().iter().cloned() {} //~ ERROR expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n-    //~^ ERROR expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n-    //~| ERROR expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+    for _ in HashMap::new().iter().cloned() {} //~ ERROR expected `Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+    //~^ ERROR expected `Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+    //~| ERROR expected `Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n }"}, {"sha": "668eaabca4c463d450fbe59ed71e04280dd0c1e4", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,15 +1,22 @@\n-error[E0271]: expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+error[E0271]: expected `Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n   --> $DIR/issue-33941.rs:6:36\n    |\n LL |     for _ in HashMap::new().iter().cloned() {}\n    |                                    ^^^^^^ expected reference, found tuple\n    |\n    = note: expected reference `&_`\n                   found tuple `(&_, &_)`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/issue-33941.rs:6:29\n+   |\n+LL |     for _ in HashMap::new().iter().cloned() {}\n+   |              -------------- ^^^^^^ `Iterator::Item` is `(&_, &_)` here\n+   |              |\n+   |              this expression has type `HashMap<_, _>`\n note: required by a bound in `cloned`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n-error[E0271]: expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+error[E0271]: expected `Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n   --> $DIR/issue-33941.rs:6:14\n    |\n LL |     for _ in HashMap::new().iter().cloned() {}\n@@ -20,7 +27,7 @@ LL |     for _ in HashMap::new().iter().cloned() {}\n    = note: required for `Cloned<std::collections::hash_map::Iter<'_, _, _>>` to implement `Iterator`\n    = note: required for `Cloned<std::collections::hash_map::Iter<'_, _, _>>` to implement `IntoIterator`\n \n-error[E0271]: expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+error[E0271]: expected `Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n   --> $DIR/issue-33941.rs:6:14\n    |\n LL |     for _ in HashMap::new().iter().cloned() {}"}, {"sha": "00c375f8d2acfaad1da084e0f1b1e5a43c87b9e3", "filename": "src/test/ui/issues/issue-41880.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-41880.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-41880.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41880.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -5,7 +5,7 @@ LL | pub struct Iterate<T, F> {\n    | ------------------------ method `iter` not found for this struct\n ...\n LL |     println!(\"{:?}\", a.iter().take(10).collect::<Vec<usize>>());\n-   |                        ^^^^ method not found in `Iterate<{integer}, [closure@$DIR/issue-41880.rs:26:24: 26:27]>`\n+   |                        ^^^^ method not found in `Iterate<{integer}, [closure@issue-41880.rs:26:24]>`\n \n error: aborting due to previous error\n "}, {"sha": "3ca6a2957e14b91768b6c421dc222634f5886677", "filename": "src/test/ui/issues/issue-42312.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-42312.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-42312.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-42312.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -23,6 +23,10 @@ LL | pub fn f(_: dyn ToString) {}\n    |\n    = help: the trait `Sized` is not implemented for `(dyn ToString + 'static)`\n    = help: unsized fn params are gated as an unstable feature\n+help: you can use `impl Trait` as the argument type\n+   |\n+LL | pub fn f(_: impl ToString) {}\n+   |             ~~~~\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n LL | pub fn f(_: &dyn ToString) {}"}, {"sha": "ffff403e0d4656508d4dbdbf3c4e7b32f6bb749f", "filename": "src/test/ui/issues/issue-5883.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -6,6 +6,10 @@ LL |     r: dyn A + 'static\n    |\n    = help: the trait `Sized` is not implemented for `(dyn A + 'static)`\n    = help: unsized fn params are gated as an unstable feature\n+help: you can use `impl Trait` as the argument type\n+   |\n+LL |     r: impl A + 'static\n+   |        ~~~~\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n LL |     r: &dyn A + 'static"}, {"sha": "ebdf33303c982b311d80fb1b066cf82b52cc6946", "filename": "src/test/ui/iterators/invalid-iterator-chain.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,3 +1,11 @@\n+use std::collections::hash_set::Iter;\n+use std::collections::HashSet;\n+\n+fn iter_to_vec<'b, X>(i: Iter<'b, X>) -> Vec<X> {\n+    let i = i.map(|x| x.clone());\n+    i.collect() //~ ERROR E0277\n+}\n+\n fn main() {\n     let scores = vec![(0, 0)]\n         .iter()\n@@ -38,4 +46,8 @@ fn main() {\n     });\n     let f = e.filter(|_| false);\n     let g: Vec<i32> = f.collect(); //~ ERROR E0277\n+\n+    let mut s = HashSet::new();\n+    s.insert(1u8);\n+    println!(\"{:?}\", iter_to_vec(s.iter()));\n }"}, {"sha": "d76a4bfb7b3ea886c68b8e90b2593fb4e7c477ea", "filename": "src/test/ui/iterators/invalid-iterator-chain.stderr", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,5 +1,23 @@\n+error[E0277]: a value of type `Vec<X>` cannot be built from an iterator over elements of type `&X`\n+  --> $DIR/invalid-iterator-chain.rs:6:7\n+   |\n+LL |     i.collect()\n+   |       ^^^^^^^ value of type `Vec<X>` cannot be built from `std::iter::Iterator<Item=&X>`\n+   |\n+   = help: the trait `FromIterator<&X>` is not implemented for `Vec<X>`\n+   = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:4:26\n+   |\n+LL | fn iter_to_vec<'b, X>(i: Iter<'b, X>) -> Vec<X> {\n+   |                          ^^^^^^^^^^^ `Iterator::Item` is `&X` here\n+LL |     let i = i.map(|x| x.clone());\n+   |               ------------------ `Iterator::Item` remains `&X` here\n+note: required by a bound in `collect`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+\n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n-  --> $DIR/invalid-iterator-chain.rs:7:27\n+  --> $DIR/invalid-iterator-chain.rs:15:27\n    |\n LL |     println!(\"{}\", scores.sum::<i32>());\n    |                           ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=()>`\n@@ -9,7 +27,7 @@ LL |     println!(\"{}\", scores.sum::<i32>());\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:4:10\n+  --> $DIR/invalid-iterator-chain.rs:12:10\n    |\n LL |       let scores = vec![(0, 0)]\n    |                    ------------ this expression has type `Vec<({integer}, {integer})>`\n@@ -24,7 +42,7 @@ note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n-  --> $DIR/invalid-iterator-chain.rs:18:14\n+  --> $DIR/invalid-iterator-chain.rs:26:14\n    |\n LL |             .sum::<i32>(),\n    |              ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=()>`\n@@ -34,7 +52,7 @@ LL |             .sum::<i32>(),\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:12:14\n+  --> $DIR/invalid-iterator-chain.rs:20:14\n    |\n LL |         vec![0, 1]\n    |         ---------- this expression has type `Vec<{integer}>`\n@@ -56,7 +74,7 @@ note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `f64`\n-  --> $DIR/invalid-iterator-chain.rs:28:14\n+  --> $DIR/invalid-iterator-chain.rs:36:14\n    |\n LL |             .sum::<i32>(),\n    |              ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=f64>`\n@@ -66,7 +84,7 @@ LL |             .sum::<i32>(),\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:24:14\n+  --> $DIR/invalid-iterator-chain.rs:32:14\n    |\n LL |         vec![0, 1]\n    |         ---------- this expression has type `Vec<{integer}>`\n@@ -84,7 +102,7 @@ note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n-  --> $DIR/invalid-iterator-chain.rs:30:54\n+  --> $DIR/invalid-iterator-chain.rs:38:54\n    |\n LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n    |                                                      ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=()>`\n@@ -94,7 +112,7 @@ LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:30:38\n+  --> $DIR/invalid-iterator-chain.rs:38:38\n    |\n LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n    |                    ---------- ------ ^^^^^^^^^^^^^^^ `Iterator::Item` changed to `()` here\n@@ -105,7 +123,7 @@ note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `&()`\n-  --> $DIR/invalid-iterator-chain.rs:31:40\n+  --> $DIR/invalid-iterator-chain.rs:39:40\n    |\n LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n    |                                        ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=&()>`\n@@ -115,7 +133,7 @@ LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:31:33\n+  --> $DIR/invalid-iterator-chain.rs:39:33\n    |\n LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n    |                    ------------ ^^^^^^ `Iterator::Item` is `&()` here\n@@ -125,15 +143,15 @@ note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n error[E0277]: a value of type `Vec<i32>` cannot be built from an iterator over elements of type `()`\n-  --> $DIR/invalid-iterator-chain.rs:40:25\n+  --> $DIR/invalid-iterator-chain.rs:48:25\n    |\n LL |     let g: Vec<i32> = f.collect();\n    |                         ^^^^^^^ value of type `Vec<i32>` cannot be built from `std::iter::Iterator<Item=()>`\n    |\n    = help: the trait `FromIterator<()>` is not implemented for `Vec<i32>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:36:15\n+  --> $DIR/invalid-iterator-chain.rs:44:15\n    |\n LL |       let a = vec![0];\n    |               ------- this expression has type `Vec<{integer}>`\n@@ -153,6 +171,6 @@ LL |       let f = e.filter(|_| false);\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "8846efba871b9cd1f845b86b58dfbaa5a0880d1b", "filename": "src/test/ui/methods/method-not-found-generic-arg-elision.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -23,7 +23,7 @@ error[E0599]: no method named `extend` found for struct `Map` in the current sco\n   --> $DIR/method-not-found-generic-arg-elision.rs:87:29\n    |\n LL |     v.iter().map(|x| x * x).extend(std::iter::once(100));\n-   |                             ^^^^^^ method not found in `Map<std::slice::Iter<'_, i32>, [closure@$DIR/method-not-found-generic-arg-elision.rs:87:18: 87:21]>`\n+   |                             ^^^^^^ method not found in `Map<Iter<'_, i32>, [closure@method-not-found-generic-arg-elision.rs:87:18]>`\n \n error[E0599]: no method named `method` found for struct `Wrapper<bool>` in the current scope\n   --> $DIR/method-not-found-generic-arg-elision.rs:90:13"}, {"sha": "72fb0e4d774312780cb81e6e5f8fc1617f0d8113", "filename": "src/test/ui/mismatched_types/issue-36053-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -13,7 +13,7 @@ LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n note: required by a bound in `filter`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n-error[E0599]: the method `count` exists for struct `Filter<Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:7:39: 7:48]>`, but its trait bounds were not satisfied\n+error[E0599]: the method `count` exists for struct `Filter<Fuse<Once<&str>>, [closure@issue-36053-2.rs:7:39]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-36053-2.rs:7:55\n    |\n LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();"}, {"sha": "a0f790dba15ed21adddebbcb5daf9faa8cd909ef", "filename": "src/test/ui/never_type/fallback-closure-wrap.fallback.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: expected `[closure@$DIR/fallback-closure-wrap.rs:18:40: 18:47]` to be a closure that returns `()`, but it returns `!`\n+error[E0271]: expected `[closure@fallback-closure-wrap.rs:18:40]` to be a closure that returns `()`, but it returns `!`\n   --> $DIR/fallback-closure-wrap.rs:18:31\n    |\n LL |       let error = Closure::wrap(Box::new(move || {"}, {"sha": "558e6b7b118d8221125e8cdd953d2ac1b9834bdd", "filename": "src/test/ui/resolve/issue-5035-2.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fresolve%2Fissue-5035-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fresolve%2Fissue-5035-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-5035-2.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -6,6 +6,10 @@ LL | fn foo(_x: K) {}\n    |\n    = help: the trait `Sized` is not implemented for `(dyn I + 'static)`\n    = help: unsized fn params are gated as an unstable feature\n+help: you can use `impl Trait` as the argument type\n+   |\n+LL | fn foo(_x: impl K) {}\n+   |            ++++\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n LL | fn foo(_x: &K) {}"}, {"sha": "4f9e93a47ed1c6bf88bcf5147cf0bff0b48f7322", "filename": "src/test/ui/suggestions/clone-on-unconstrained-borrowed-type-param.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fsuggestions%2Fclone-on-unconstrained-borrowed-type-param.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fsuggestions%2Fclone-on-unconstrained-borrowed-type-param.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fclone-on-unconstrained-borrowed-type-param.fixed?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+fn wat<T: Clone>(t: &T) -> T {\n+    t.clone() //~ ERROR E0308\n+}\n+\n+#[derive(Clone)]\n+struct Foo;\n+\n+fn wut(t: &Foo) -> Foo {\n+    t.clone() //~ ERROR E0308\n+}\n+\n+fn main() {\n+    wat(&42);\n+    wut(&Foo);\n+}"}, {"sha": "89b077d671a513b6018173e77d8e8cf702e89bcb", "filename": "src/test/ui/suggestions/clone-on-unconstrained-borrowed-type-param.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fsuggestions%2Fclone-on-unconstrained-borrowed-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fsuggestions%2Fclone-on-unconstrained-borrowed-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fclone-on-unconstrained-borrowed-type-param.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+fn wat<T>(t: &T) -> T {\n+    t.clone() //~ ERROR E0308\n+}\n+\n+struct Foo;\n+\n+fn wut(t: &Foo) -> Foo {\n+    t.clone() //~ ERROR E0308\n+}\n+\n+fn main() {\n+    wat(&42);\n+    wut(&Foo);\n+}"}, {"sha": "26ab515d9b4b6fd0c84c8b5c58d818ecf88fdf98", "filename": "src/test/ui/suggestions/clone-on-unconstrained-borrowed-type-param.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fsuggestions%2Fclone-on-unconstrained-borrowed-type-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fsuggestions%2Fclone-on-unconstrained-borrowed-type-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fclone-on-unconstrained-borrowed-type-param.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -0,0 +1,43 @@\n+error[E0308]: mismatched types\n+  --> $DIR/clone-on-unconstrained-borrowed-type-param.rs:3:5\n+   |\n+LL | fn wat<T>(t: &T) -> T {\n+   |        -            - expected `T` because of return type\n+   |        |\n+   |        this type parameter\n+LL |     t.clone()\n+   |     ^^^^^^^^^ expected type parameter `T`, found `&T`\n+   |\n+   = note: expected type parameter `T`\n+                   found reference `&T`\n+note: `T` does not implement `Clone`, so `&T` was cloned instead\n+  --> $DIR/clone-on-unconstrained-borrowed-type-param.rs:3:5\n+   |\n+LL |     t.clone()\n+   |     ^\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn wat<T: Clone>(t: &T) -> T {\n+   |         +++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/clone-on-unconstrained-borrowed-type-param.rs:9:5\n+   |\n+LL | fn wut(t: &Foo) -> Foo {\n+   |                    --- expected `Foo` because of return type\n+LL |     t.clone()\n+   |     ^^^^^^^^^ expected struct `Foo`, found `&Foo`\n+   |\n+note: `Foo` does not implement `Clone`, so `&Foo` was cloned instead\n+  --> $DIR/clone-on-unconstrained-borrowed-type-param.rs:9:5\n+   |\n+LL |     t.clone()\n+   |     ^\n+help: consider annotating `Foo` with `#[derive(Clone)]`\n+   |\n+LL | #[derive(Clone)]\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "6910b77d9bc3fa1874c69f464fba0e1b1444ef3b", "filename": "src/test/ui/suggestions/mut-borrow-needed-by-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -20,11 +20,11 @@ LL |     let fp = BufWriter::new(fp);\n note: required by a bound in `BufWriter`\n   --> $SRC_DIR/std/src/io/buffered/bufwriter.rs:LL:COL\n \n-error[E0599]: the method `write_fmt` exists for struct `BufWriter<&dyn std::io::Write>`, but its trait bounds were not satisfied\n+error[E0599]: the method `write_fmt` exists for struct `BufWriter<&dyn Write>`, but its trait bounds were not satisfied\n   --> $DIR/mut-borrow-needed-by-trait.rs:21:5\n    |\n LL |     writeln!(fp, \"hello world\").unwrap();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ method cannot be called on `BufWriter<&dyn std::io::Write>` due to unsatisfied trait bounds\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ method cannot be called on `BufWriter<&dyn Write>` due to unsatisfied trait bounds\n   --> $SRC_DIR/std/src/io/buffered/bufwriter.rs:LL:COL\n    |\n    = note: doesn't satisfy `BufWriter<&dyn std::io::Write>: std::io::Write`"}, {"sha": "65340b2a2092ff5cdf345a4c08703603d70c0ee1", "filename": "src/test/ui/traits/assoc-type-in-superbad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -10,7 +10,7 @@ pub trait Foo: Iterator<Item = <Self as Foo>::Key> {\n \n impl Foo for IntoIter<i32> {\n     type Key = u32;\n-    //~^ ERROR expected `std::vec::IntoIter<i32>` to be an iterator that yields `u32`, but it yields `i32`\n+    //~^ ERROR expected `IntoIter<i32>` to be an iterator that yields `u32`, but it yields `i32`\n }\n \n fn main() {}"}, {"sha": "7fa1d2c2eed67c8fd85f48d77f1aa019a3d36fb7", "filename": "src/test/ui/traits/assoc-type-in-superbad.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: expected `std::vec::IntoIter<i32>` to be an iterator that yields `u32`, but it yields `i32`\n+error[E0271]: expected `IntoIter<i32>` to be an iterator that yields `u32`, but it yields `i32`\n   --> $DIR/assoc-type-in-superbad.rs:12:16\n    |\n LL |     type Key = u32;"}, {"sha": "36b08a7d3093141c3ee61e6ff410794cc2092341", "filename": "src/test/ui/traits/bound/not-on-bare-trait.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fnot-on-bare-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fnot-on-bare-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fnot-on-bare-trait.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -20,6 +20,10 @@ LL | fn foo(_x: Foo + Send) {\n    |\n    = help: the trait `Sized` is not implemented for `(dyn Foo + Send + 'static)`\n    = help: unsized fn params are gated as an unstable feature\n+help: you can use `impl Trait` as the argument type\n+   |\n+LL | fn foo(_x: impl Foo + Send) {\n+   |            ++++\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n LL | fn foo(_x: &Foo + Send) {"}, {"sha": "4aa5966ff25d4cedac7d9db5a84b39087a0ef0f9", "filename": "src/test/ui/type-alias-impl-trait/issue-57961.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -8,7 +8,7 @@ trait Foo {\n \n impl Foo for () {\n     type Bar = std::vec::IntoIter<u32>;\n-    //~^ ERROR expected `std::vec::IntoIter<u32>` to be an iterator that yields `X`, but it yields `u32`\n+    //~^ ERROR expected `IntoIter<u32>` to be an iterator that yields `X`, but it yields `u32`\n }\n \n fn incoherent() {"}, {"sha": "8d11b48888947d91bce4b7039892a34a8cc72b15", "filename": "src/test/ui/type-alias-impl-trait/issue-57961.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: expected `std::vec::IntoIter<u32>` to be an iterator that yields `X`, but it yields `u32`\n+error[E0271]: expected `IntoIter<u32>` to be an iterator that yields `X`, but it yields `u32`\n   --> $DIR/issue-57961.rs:10:16\n    |\n LL | type X = impl Sized;"}, {"sha": "ff36e18d28301ef3b1934208e8ed2175a8ecbe9f", "filename": "src/test/ui/typeck/explain_clone_autoref.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ftypeck%2Fexplain_clone_autoref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Ftypeck%2Fexplain_clone_autoref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fexplain_clone_autoref.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -12,6 +12,10 @@ note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead\n    |\n LL |     nc.clone()\n    |     ^^\n+help: consider annotating `NotClone` with `#[derive(Clone)]`\n+   |\n+LL | #[derive(Clone)]\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "99ec5178340030d15ca4cac950f747182a9e36cc", "filename": "src/test/ui/unboxed-closures/unboxed-closures-static-call-wrong-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -1,8 +1,8 @@\n-error[E0599]: no method named `call` found for closure `[closure@$DIR/unboxed-closures-static-call-wrong-trait.rs:6:26: 6:29]` in the current scope\n+error[E0599]: no method named `call` found for closure `[closure@unboxed-closures-static-call-wrong-trait.rs:6:26]` in the current scope\n   --> $DIR/unboxed-closures-static-call-wrong-trait.rs:7:10\n    |\n LL |     mut_.call((0, ));\n-   |          ^^^^ method not found in `[closure@$DIR/unboxed-closures-static-call-wrong-trait.rs:6:26: 6:29]`\n+   |          ^^^^ method not found in `[closure@unboxed-closures-static-call-wrong-trait.rs:6:26]`\n \n error: aborting due to previous error\n "}, {"sha": "652f8b4d3c56ef7109668aface5f83bf35cc8514", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6af2711baa5a5db116c123116b2150ed63799d/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=7a6af2711baa5a5db116c123116b2150ed63799d", "patch": "@@ -97,7 +97,7 @@ use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::ty as rustc_ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc_middle::ty::binding::BindingMode;\n-use rustc_middle::ty::fast_reject::SimplifiedTypeGen::{\n+use rustc_middle::ty::fast_reject::SimplifiedType::{\n     ArraySimplifiedType, BoolSimplifiedType, CharSimplifiedType, FloatSimplifiedType, IntSimplifiedType,\n     PtrSimplifiedType, SliceSimplifiedType, StrSimplifiedType, UintSimplifiedType,\n };"}]}