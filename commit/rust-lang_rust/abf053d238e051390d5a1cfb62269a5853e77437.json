{"sha": "abf053d238e051390d5a1cfb62269a5853e77437", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZjA1M2QyMzhlMDUxMzkwZDVhMWNmYjYyMjY5YTU4NTNlNzc0Mzc=", "commit": {"author": {"name": "Christoph Schmidler", "email": "c.schmidler@gmail.com", "date": "2019-12-09T06:46:10Z"}, "committer": {"name": "Christoph Schmidler", "email": "c.schmidler@gmail.com", "date": "2019-12-09T06:46:10Z"}, "message": "Merge branch 'master' of github.com:TheSamsa/rust", "tree": {"sha": "d1c98f5b876a0d8f092f7003cab372b5dbe00f16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1c98f5b876a0d8f092f7003cab372b5dbe00f16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abf053d238e051390d5a1cfb62269a5853e77437", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abf053d238e051390d5a1cfb62269a5853e77437", "html_url": "https://github.com/rust-lang/rust/commit/abf053d238e051390d5a1cfb62269a5853e77437", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abf053d238e051390d5a1cfb62269a5853e77437/comments", "author": {"login": "TheSamsa", "id": 13667299, "node_id": "MDQ6VXNlcjEzNjY3Mjk5", "avatar_url": "https://avatars.githubusercontent.com/u/13667299?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TheSamsa", "html_url": "https://github.com/TheSamsa", "followers_url": "https://api.github.com/users/TheSamsa/followers", "following_url": "https://api.github.com/users/TheSamsa/following{/other_user}", "gists_url": "https://api.github.com/users/TheSamsa/gists{/gist_id}", "starred_url": "https://api.github.com/users/TheSamsa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TheSamsa/subscriptions", "organizations_url": "https://api.github.com/users/TheSamsa/orgs", "repos_url": "https://api.github.com/users/TheSamsa/repos", "events_url": "https://api.github.com/users/TheSamsa/events{/privacy}", "received_events_url": "https://api.github.com/users/TheSamsa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TheSamsa", "id": 13667299, "node_id": "MDQ6VXNlcjEzNjY3Mjk5", "avatar_url": "https://avatars.githubusercontent.com/u/13667299?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TheSamsa", "html_url": "https://github.com/TheSamsa", "followers_url": "https://api.github.com/users/TheSamsa/followers", "following_url": "https://api.github.com/users/TheSamsa/following{/other_user}", "gists_url": "https://api.github.com/users/TheSamsa/gists{/gist_id}", "starred_url": "https://api.github.com/users/TheSamsa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TheSamsa/subscriptions", "organizations_url": "https://api.github.com/users/TheSamsa/orgs", "repos_url": "https://api.github.com/users/TheSamsa/repos", "events_url": "https://api.github.com/users/TheSamsa/events{/privacy}", "received_events_url": "https://api.github.com/users/TheSamsa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "969926fcfe68787595d384f53d19cf6b8c9df3e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/969926fcfe68787595d384f53d19cf6b8c9df3e3", "html_url": "https://github.com/rust-lang/rust/commit/969926fcfe68787595d384f53d19cf6b8c9df3e3"}, {"sha": "e862c01aadb2d029864f7bb256cf6c85bbb5d7e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e862c01aadb2d029864f7bb256cf6c85bbb5d7e4", "html_url": "https://github.com/rust-lang/rust/commit/e862c01aadb2d029864f7bb256cf6c85bbb5d7e4"}], "stats": {"total": 44231, "additions": 23958, "deletions": 20273}, "files": [{"sha": "8fbbd7c4a2e49b0ac2e86dae076ce6e6248ad21e", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -150,13 +150,13 @@ All pull requests are reviewed by another person. We have a bot,\n request.\n \n If you want to request that a specific person reviews your pull request,\n-you can add an `r?` to the message. For example, [Steve][steveklabnik] usually reviews\n+you can add an `r?` to the pull request description. For example, [Steve][steveklabnik] usually reviews\n documentation changes. So if you were to make a documentation change, add\n \n     r? @steveklabnik\n \n-to the end of the message, and @rust-highfive will assign [@steveklabnik][steveklabnik] instead\n-of a random person. This is entirely optional.\n+to the end of the pull request description, and [@rust-highfive][rust-highfive] will assign\n+[@steveklabnik][steveklabnik] instead of a random person. This is entirely optional.\n \n After someone has reviewed your pull request, they will leave an annotation\n on the pull request with an `r+`. It will look something like this:"}, {"sha": "26727c5c1db6039702653ed28a54400d13211777", "filename": "Cargo.lock", "status": "modified", "additions": 53, "deletions": 40, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -466,15 +466,17 @@ dependencies = [\n  \"cargo_metadata 0.9.0\",\n  \"clippy-mini-macro-test\",\n  \"clippy_lints\",\n- \"compiletest_rs 0.4.0\",\n+ \"compiletest_rs\",\n  \"derive-new\",\n+ \"git2\",\n  \"lazy_static 1.3.0\",\n  \"regex\",\n  \"rustc-workspace-hack\",\n  \"rustc_tools_util 0.2.0\",\n  \"semver\",\n  \"serde\",\n- \"tester 0.7.0\",\n+ \"tempfile\",\n+ \"tester\",\n ]\n \n [[package]]\n@@ -595,28 +597,6 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n-[[package]]\n-name = \"compiletest_rs\"\n-version = \"0.3.26\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d7d8975604ebad8b6660796802377eb6495045c5606168fc1b8d19a4dd9bfa46\"\n-dependencies = [\n- \"diff\",\n- \"filetime\",\n- \"getopts\",\n- \"libc\",\n- \"log\",\n- \"miow 0.3.3\",\n- \"regex\",\n- \"rustfix\",\n- \"serde\",\n- \"serde_derive\",\n- \"serde_json\",\n- \"tempfile\",\n- \"tester 0.6.0\",\n- \"winapi 0.3.8\",\n-]\n-\n [[package]]\n name = \"compiletest_rs\"\n version = \"0.4.0\"\n@@ -635,7 +615,7 @@ dependencies = [\n  \"serde_derive\",\n  \"serde_json\",\n  \"tempfile\",\n- \"tester 0.7.0\",\n+ \"tester\",\n  \"winapi 0.3.8\",\n ]\n \n@@ -1314,7 +1294,7 @@ checksum = \"473a1265acc8ff1e808cd0a1af8cee3c2ee5200916058a2ca113c29f2d903571\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n- \"wasi\",\n+ \"wasi 0.7.0\",\n ]\n \n [[package]]\n@@ -2223,7 +2203,7 @@ dependencies = [\n  \"byteorder\",\n  \"cargo_metadata 0.9.0\",\n  \"colored\",\n- \"compiletest_rs 0.3.26\",\n+ \"compiletest_rs\",\n  \"directories\",\n  \"env_logger 0.7.1\",\n  \"getrandom\",\n@@ -3221,9 +3201,11 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_error_codes\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_fs_util\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_session\",\n  \"rustc_target\",\n  \"scoped-tls\",\n  \"serialize\",\n@@ -3537,6 +3519,7 @@ dependencies = [\n  \"rustc_fs_util\",\n  \"rustc_incremental\",\n  \"rustc_index\",\n+ \"rustc_session\",\n  \"rustc_target\",\n  \"serialize\",\n  \"syntax\",\n@@ -3596,6 +3579,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_error_codes\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_interface\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n@@ -3629,6 +3613,15 @@ dependencies = [\n  \"unicode-width\",\n ]\n \n+[[package]]\n+name = \"rustc_feature\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"lazy_static 1.3.0\",\n+ \"rustc_data_structures\",\n+ \"syntax_pos\",\n+]\n+\n [[package]]\n name = \"rustc_fs_util\"\n version = \"0.0.0\"\n@@ -3643,6 +3636,7 @@ dependencies = [\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n+ \"rustc_session\",\n  \"serialize\",\n  \"syntax\",\n  \"syntax_pos\",\n@@ -3704,7 +3698,9 @@ dependencies = [\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_error_codes\",\n+ \"rustc_feature\",\n  \"rustc_index\",\n+ \"rustc_session\",\n  \"rustc_target\",\n  \"syntax\",\n  \"syntax_pos\",\n@@ -3808,8 +3804,8 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_error_codes\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_lexer\",\n- \"rustc_target\",\n  \"smallvec 1.0.0\",\n  \"syntax\",\n  \"syntax_pos\",\n@@ -3824,6 +3820,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_error_codes\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_index\",\n  \"rustc_parse\",\n  \"rustc_target\",\n@@ -3866,6 +3863,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_error_codes\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_metadata\",\n  \"smallvec 1.0.0\",\n  \"syntax\",\n@@ -3889,6 +3887,22 @@ dependencies = [\n  \"syntax_pos\",\n ]\n \n+[[package]]\n+name = \"rustc_session\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log\",\n+ \"num_cpus\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_feature\",\n+ \"rustc_fs_util\",\n+ \"rustc_index\",\n+ \"rustc_target\",\n+ \"serialize\",\n+ \"syntax_pos\",\n+]\n+\n [[package]]\n name = \"rustc_target\"\n version = \"0.0.0\"\n@@ -4306,7 +4320,7 @@ dependencies = [\n  \"rustc_msan\",\n  \"rustc_tsan\",\n  \"unwind\",\n- \"wasi\",\n+ \"wasi 0.9.0+wasi-snapshot-preview1\",\n ]\n \n [[package]]\n@@ -4464,9 +4478,11 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_error_codes\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n  \"rustc_macros\",\n+ \"rustc_session\",\n  \"scoped-tls\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n@@ -4480,6 +4496,7 @@ dependencies = [\n  \"log\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_lexer\",\n  \"rustc_parse\",\n  \"serialize\",\n@@ -4497,6 +4514,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_error_codes\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_parse\",\n  \"rustc_target\",\n  \"smallvec 1.0.0\",\n@@ -4621,17 +4639,6 @@ dependencies = [\n  \"term 0.0.0\",\n ]\n \n-[[package]]\n-name = \"tester\"\n-version = \"0.6.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7647e6d732eb84375d8e7abda37818f81861ddbfc7235e33f4983cb254b71e4f\"\n-dependencies = [\n- \"getopts\",\n- \"libc\",\n- \"term 0.6.0\",\n-]\n-\n [[package]]\n name = \"tester\"\n version = \"0.7.0\"\n@@ -5185,6 +5192,12 @@ name = \"wasi\"\n version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b89c3ce4ce14bdc6fb6beaf9ec7928ca331de5df7e5ea278375642a2f478570d\"\n+\n+[[package]]\n+name = \"wasi\"\n+version = \"0.9.0+wasi-snapshot-preview1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\","}, {"sha": "bb169414886de2da6e0c37c50928b47fe0e604ef", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -643,7 +643,9 @@ def build_bootstrap(self):\n         env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n             (os.pathsep + env[\"LIBRARY_PATH\"]) \\\n             if \"LIBRARY_PATH\" in env else \"\"\n-        env[\"RUSTFLAGS\"] = \"-Cdebuginfo=2 \"\n+        # preserve existing RUSTFLAGS\n+        env.setdefault(\"RUSTFLAGS\", \"\")\n+        env[\"RUSTFLAGS\"] += \" -Cdebuginfo=2\"\n \n         build_section = \"target.{}\".format(self.build_triple())\n         target_features = []\n@@ -652,13 +654,13 @@ def build_bootstrap(self):\n         elif self.get_toml(\"crt-static\", build_section) == \"false\":\n             target_features += [\"-crt-static\"]\n         if target_features:\n-            env[\"RUSTFLAGS\"] += \"-C target-feature=\" + (\",\".join(target_features)) + \" \"\n+            env[\"RUSTFLAGS\"] += \" -C target-feature=\" + (\",\".join(target_features))\n         target_linker = self.get_toml(\"linker\", build_section)\n         if target_linker is not None:\n-            env[\"RUSTFLAGS\"] += \"-C linker=\" + target_linker + \" \"\n-        env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes \"\n+            env[\"RUSTFLAGS\"] += \" -C linker=\" + target_linker\n+        env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes\"\n         if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n-            env[\"RUSTFLAGS\"] += \"-Dwarnings \"\n+            env[\"RUSTFLAGS\"] += \" -Dwarnings\"\n \n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]"}, {"sha": "f686dfe71b93733fdb4aff7296914dc76483f51a", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -113,7 +113,7 @@ impl Step for Std {\n     }\n }\n \n-/// Copies third pary objects needed by various targets.\n+/// Copies third party objects needed by various targets.\n fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target: Interned<String>)\n     -> Vec<PathBuf>\n {"}, {"sha": "f8734ebdf4254213b743dfa125fbc701250addba", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -260,7 +260,7 @@ install!((self, builder, _config),\n     };\n     Rustc, \"src/librustc\", true, only_hosts: true, {\n         builder.ensure(dist::Rustc {\n-            compiler: self.compiler,\n+            compiler: builder.compiler(builder.top_stage, self.target),\n         });\n         install_rustc(builder, self.compiler.stage, self.target);\n     };"}, {"sha": "7ea2bb126a641ca8fa9ceb38b327ccdd3327bcbb", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -810,6 +810,7 @@ impl Build {\n                   !target.contains(\"emscripten\") &&\n                   !target.contains(\"wasm32\") &&\n                   !target.contains(\"nvptx\") &&\n+                  !target.contains(\"fortanix\") &&\n                   !target.contains(\"fuchsia\") {\n             Some(self.cc(target))\n         } else {"}, {"sha": "be13b9aa2eb49cde97ca8cc50c24bf5be67f9415", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -294,11 +294,11 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n     let mut parts = version.split('.').take(2)\n         .filter_map(|s| s.parse::<u32>().ok());\n     if let (Some(major), Some(_minor)) = (parts.next(), parts.next()) {\n-        if major >= 6 {\n+        if major >= 7 {\n             return\n         }\n     }\n-    panic!(\"\\n\\nbad LLVM version: {}, need >=6.0\\n\\n\", version)\n+    panic!(\"\\n\\nbad LLVM version: {}, need >=7.0\\n\\n\", version)\n }\n \n fn configure_cmake(builder: &Builder<'_>,"}, {"sha": "70d6bad297dce4c890ee98a1c7b611a4dd831d32", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -18,7 +18,7 @@ jobs:\n   - template: steps/run.yml\n   strategy:\n     matrix:\n-      x86_64-gnu-llvm-6.0:\n+      x86_64-gnu-llvm-7:\n         RUST_BACKTRACE: 1\n       dist-x86_64-linux: {}\n       dist-x86_64-linux-alt:"}, {"sha": "1f0be53677de22b37b3230de04daed686be09fec", "filename": "src/ci/azure-pipelines/pr.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Fazure-pipelines%2Fpr.yml", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Fazure-pipelines%2Fpr.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fpr.yml?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -18,7 +18,7 @@ jobs:\n     - template: steps/run.yml\n   strategy:\n     matrix:\n-      x86_64-gnu-llvm-6.0: {}\n+      x86_64-gnu-llvm-7: {}\n       mingw-check: {}\n       x86_64-gnu-tools:\n         CI_ONLY_WHEN_SUBMODULES_CHANGED: 1"}, {"sha": "b6177b2cc9b25c826fb9e47092a4fe4ab1e25853", "filename": "src/ci/azure-pipelines/try.yml", "status": "modified", "additions": 59, "deletions": 10, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Fazure-pipelines%2Ftry.yml", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Fazure-pipelines%2Ftry.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Ftry.yml?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -6,19 +6,68 @@ variables:\n - group: prod-credentials\n \n jobs:\n-- job: Windows\n+- job: Linux\n   timeoutInMinutes: 600\n   pool:\n-    vmImage: 'vs2017-win2016'\n+    vmImage: ubuntu-16.04\n   steps:\n   - template: steps/run.yml\n   strategy:\n     matrix:\n-      dist-x86_64-msvc:\n-        RUST_CONFIGURE_ARGS: >-\n-          --build=x86_64-pc-windows-msvc\n-          --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n-          --enable-full-tools\n-          --enable-profiler\n-        SCRIPT: python x.py dist\n-        DIST_REQUIRE_ALL_TOOLS: 1\n+      dist-x86_64-linux: {}\n+      dist-x86_64-linux-alt:\n+        IMAGE: dist-x86_64-linux\n+\n+# The macOS and Windows builds here are currently disabled due to them not being\n+# overly necessary on `try` builds. We also don't actually have anything that\n+# consumes the artifacts currently. Perhaps one day we can reenable, but for now\n+# it helps free up capacity on Azure.\n+# - job: macOS\n+#   timeoutInMinutes: 600\n+#   pool:\n+#     vmImage: macos-10.13\n+#   steps:\n+#   - template: steps/run.yml\n+#   strategy:\n+#     matrix:\n+#       dist-x86_64-apple:\n+#         SCRIPT: ./x.py dist\n+#         RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n+#         DEPLOY: 1\n+#         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+#         MACOSX_DEPLOYMENT_TARGET: 10.7\n+#         NO_LLVM_ASSERTIONS: 1\n+#         NO_DEBUG_ASSERTIONS: 1\n+#         DIST_REQUIRE_ALL_TOOLS: 1\n+#\n+#       dist-x86_64-apple-alt:\n+#         SCRIPT: ./x.py dist\n+#         RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n+#         DEPLOY_ALT: 1\n+#         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+#         MACOSX_DEPLOYMENT_TARGET: 10.7\n+#         NO_LLVM_ASSERTIONS: 1\n+#         NO_DEBUG_ASSERTIONS: 1\n+#\n+# - job: Windows\n+#   timeoutInMinutes: 600\n+#   pool:\n+#     vmImage: 'vs2017-win2016'\n+#   steps:\n+#   - template: steps/run.yml\n+#   strategy:\n+#     matrix:\n+#       dist-x86_64-msvc:\n+#         RUST_CONFIGURE_ARGS: >\n+#           --build=x86_64-pc-windows-msvc\n+#           --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n+#           --enable-full-tools\n+#           --enable-profiler\n+#         SCRIPT: python x.py dist\n+#         DIST_REQUIRE_ALL_TOOLS: 1\n+#         DEPLOY: 1\n+#\n+#       dist-x86_64-msvc-alt:\n+#         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n+#         SCRIPT: python x.py dist\n+#         DEPLOY_ALT: 1"}, {"sha": "872f2c3467d202729241b31dabe0936a2f37dcd9", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -16,6 +16,13 @@ for example:\n \n Images will output artifacts in an `obj` dir at the root of a repository.\n \n+**NOTE**: Re-using the same `obj` dir with different docker images with\n+the same target triple (e.g. `dist-x86_64-linux` and `dist-various-1`)\n+may result in strange linker errors, due shared library versions differing between platforms.\n+\n+If you encounter any issues when using multiple Docker images, try deleting your `obj` directory\n+before running your command.\n+\n ## Filesystem layout\n \n - Each directory, excluding `scripts` and `disabled`, corresponds to a docker image"}, {"sha": "925d5ca0223b1f8bd7b3cb136ebd23b546331fc4", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -12,7 +12,7 @@ export PATH=`pwd`/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n git clone https://github.com/CraneStation/wasi-libc\n \n cd wasi-libc\n-git reset --hard a94d2d04e7722b323573da2bd04e909a5763d35b\n+git reset --hard f645f498dfbbbc00a7a97874d33082d3605c3f21\n make -j$(nproc) INSTALL_DIR=/wasm32-wasi install\n \n cd .."}, {"sha": "a1c9c13fc471a463879385bcc03ab5686ab9c740", "filename": "src/ci/docker/x86_64-gnu-llvm-7/Dockerfile", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:16.04\n+FROM ubuntu:18.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n@@ -11,7 +11,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n-  llvm-6.0-tools \\\n+  llvm-7-tools \\\n   libedit-dev \\\n   libssl-dev \\\n   pkg-config \\\n@@ -24,7 +24,7 @@ RUN sh /scripts/sccache.sh\n # using llvm-link-shared due to libffi issues -- see #34486\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n-      --llvm-root=/usr/lib/llvm-6.0 \\\n+      --llvm-root=/usr/lib/llvm-7 \\\n       --enable-llvm-link-shared\n ENV SCRIPT python2.7 ../x.py test src/tools/tidy && python2.7 ../x.py test\n ", "previous_filename": "src/ci/docker/x86_64-gnu-llvm-6.0/Dockerfile"}, {"sha": "38d1d2baf25075cc06fb2f296a8a12fa66e82c0c", "filename": "src/ci/run.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -23,7 +23,7 @@ fi\n ci_dir=`cd $(dirname $0) && pwd`\n source \"$ci_dir/shared.sh\"\n \n-if [ ! isCI ] || isCiBranch auto || isCiBranch beta; then\n+if ! isCI || isCiBranch auto || isCiBranch beta; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings --enable-verbose-tests\"\n fi\n "}, {"sha": "386f6008d06aad0b1b15741662ec43fad2529cf4", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -307,18 +307,6 @@ warning: path statement with no effect\n   |\n ```\n \n-## plugin-as-library\n-\n-This lint detects when compiler plugins are used as ordinary library in\n-non-plugin crate. Some example code that triggers this lint:\n-\n-```rust,ignore\n-#![feature(plugin)]\n-#![plugin(macro_crate_test)]\n-\n-extern crate macro_crate_test;\n-```\n-\n ## private-in-public\n \n This lint detects private items in public interfaces not caught by the old implementation. Some"}, {"sha": "96fa4344b04b726525805979156a6a12ba25219a", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,7 +1,7 @@\n # Documentation tests\n \n `rustdoc` supports executing your documentation examples as tests. This makes sure\n-that your tests are up to date and working.\n+that examples within your documentation are up to date and working.\n \n The basic idea is this:\n "}, {"sha": "949f24ab9c11eb5337050c3fadfdc51bcf3bcf91", "filename": "src/doc/unstable-book/src/language-features/cfg-sanitize.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -0,0 +1,36 @@\n+# `cfg_sanitize`\n+\n+The tracking issue for this feature is: [#39699]\n+\n+[#39699]: https://github.com/rust-lang/rust/issues/39699\n+\n+------------------------\n+\n+The `cfg_sanitize` feature makes it possible to execute different code\n+depending on whether a particular sanitizer is enabled or not.\n+\n+## Examples\n+\n+``` rust\n+#![feature(cfg_sanitize)]\n+\n+#[cfg(sanitize = \"thread\")]\n+fn a() {\n+  // ...\n+}\n+\n+#[cfg(not(sanitize = \"thread\"))]\n+fn a() {\n+  // ...\n+}\n+\n+fn b() {\n+  if cfg!(sanitize = \"leak\") {\n+    // ...\n+  } else {\n+    // ...\n+  }\n+}\n+\n+```\n+"}, {"sha": "495cdee62c87dc798f6049ba5a21278d79409012", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -21,15 +21,10 @@ the crate attribute `#![plugin(...)]`.  See the\n `rustc_driver::plugin` documentation for more about the\n mechanics of defining and loading a plugin.\n \n-If present, arguments passed as `#![plugin(foo(... args ...))]` are not\n-interpreted by rustc itself.  They are provided to the plugin through the\n-`Registry`'s `args` method.\n-\n In the vast majority of cases, a plugin should *only* be used through\n `#![plugin]` and not through an `extern crate` item.  Linking a plugin would\n pull in all of libsyntax and librustc as dependencies of your crate.  This is\n-generally unwanted unless you are building another plugin.  The\n-`plugin_as_library` lint checks these guidelines.\n+generally unwanted unless you are building another plugin.\n \n The usual practice is to put compiler plugins in their own crate, separate from\n any `macro_rules!` macros or ordinary Rust code meant to be used by consumers"}, {"sha": "85395d2ecdfc75b8e5593a02bda842d413e1b3c5", "filename": "src/etc/dec2flt_table.py", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fetc%2Fdec2flt_table.py", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fetc%2Fdec2flt_table.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdec2flt_table.py?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -111,14 +111,18 @@ def print_proper_powers():\n     print(\"pub const MIN_E: i16 = {};\".format(MIN_E))\n     print(\"pub const MAX_E: i16 = {};\".format(MAX_E))\n     print()\n+    print(\"#[rustfmt::skip]\")\n     typ = \"([u64; {0}], [i16; {0}])\".format(len(powers))\n-    print(\"pub const POWERS: \", typ, \" = ([\", sep='')\n+    print(\"pub const POWERS: \", typ, \" = (\", sep='')\n+    print(\"    [\")\n     for z in powers:\n-        print(\"    0x{:x},\".format(z.sig))\n-    print(\"], [\")\n+        print(\"        0x{:x},\".format(z.sig))\n+    print(\"    ],\")\n+    print(\"    [\")\n     for z in powers:\n-        print(\"    {},\".format(z.exp))\n-    print(\"]);\")\n+        print(\"        {},\".format(z.exp))\n+    print(\"    ],\")\n+    print(\");\")\n \n \n def print_short_powers(num_bits, significand_size):\n@@ -127,6 +131,7 @@ def print_short_powers(num_bits, significand_size):\n     max_e = int(ceil(log(max_sig, 5)))\n     e_range = range(max_e)\n     typ = \"[f{}; {}]\".format(num_bits, len(e_range))\n+    print(\"#[rustfmt::skip]\")\n     print(\"pub const F\", num_bits, \"_SHORT_POWERS: \", typ, \" = [\", sep='')\n     for e in e_range:\n         print(\"    1e{},\".format(e))"}, {"sha": "956298d7836b854a2be3d10535c8d84630588ec2", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,15 +1,15 @@\n use super::*;\n \n extern crate test;\n-use test::Bencher;\n use crate::boxed::Box;\n+use test::Bencher;\n \n #[test]\n fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n-        let ptr = Global.alloc_zeroed(layout.clone())\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr =\n+            Global.alloc_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         let mut i = ptr.cast::<u8>().as_ptr();\n         let end = i.add(layout.size());"}, {"sha": "eb5f51d9adc584b39efbc6760685828e6723ecb6", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,12 +1,12 @@\n+use std::collections::BTreeMap;\n use std::iter::Iterator;\n use std::vec::Vec;\n-use std::collections::BTreeMap;\n \n-use rand::{Rng, seq::SliceRandom, thread_rng};\n-use test::{Bencher, black_box};\n+use rand::{seq::SliceRandom, thread_rng, Rng};\n+use test::{black_box, Bencher};\n \n macro_rules! map_insert_rand_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let n: usize = $n;\n@@ -27,11 +27,11 @@ macro_rules! map_insert_rand_bench {\n             });\n             black_box(map);\n         }\n-    )\n+    };\n }\n \n macro_rules! map_insert_seq_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n@@ -50,11 +50,11 @@ macro_rules! map_insert_seq_bench {\n             });\n             black_box(map);\n         }\n-    )\n+    };\n }\n \n macro_rules! map_find_rand_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n@@ -78,11 +78,11 @@ macro_rules! map_find_rand_bench {\n                 black_box(t);\n             })\n         }\n-    )\n+    };\n }\n \n macro_rules! map_find_seq_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n@@ -101,20 +101,20 @@ macro_rules! map_find_seq_bench {\n                 black_box(x);\n             })\n         }\n-    )\n+    };\n }\n \n-map_insert_rand_bench!{insert_rand_100,    100,    BTreeMap}\n-map_insert_rand_bench!{insert_rand_10_000, 10_000, BTreeMap}\n+map_insert_rand_bench! {insert_rand_100,    100,    BTreeMap}\n+map_insert_rand_bench! {insert_rand_10_000, 10_000, BTreeMap}\n \n-map_insert_seq_bench!{insert_seq_100,    100,    BTreeMap}\n-map_insert_seq_bench!{insert_seq_10_000, 10_000, BTreeMap}\n+map_insert_seq_bench! {insert_seq_100,    100,    BTreeMap}\n+map_insert_seq_bench! {insert_seq_10_000, 10_000, BTreeMap}\n \n-map_find_rand_bench!{find_rand_100,    100,    BTreeMap}\n-map_find_rand_bench!{find_rand_10_000, 10_000, BTreeMap}\n+map_find_rand_bench! {find_rand_100,    100,    BTreeMap}\n+map_find_rand_bench! {find_rand_10_000, 10_000, BTreeMap}\n \n-map_find_seq_bench!{find_seq_100,    100,    BTreeMap}\n-map_find_seq_bench!{find_seq_10_000, 10_000, BTreeMap}\n+map_find_seq_bench! {find_seq_100,    100,    BTreeMap}\n+map_find_seq_bench! {find_seq_10_000, 10_000, BTreeMap}\n \n fn bench_iter(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();"}, {"sha": "e20c043286e6fedd50cc43a87c616c3bda9e58b0", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,9 +1,9 @@\n use std::{mem, ptr};\n \n+use rand::distributions::{Alphanumeric, Standard};\n use rand::{thread_rng, Rng, SeedableRng};\n-use rand::distributions::{Standard, Alphanumeric};\n use rand_xorshift::XorShiftRng;\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn iterator(b: &mut Bencher) {\n@@ -239,7 +239,7 @@ macro_rules! sort {\n             b.iter(|| v.clone().$f());\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n-    }\n+    };\n }\n \n macro_rules! sort_strings {\n@@ -251,7 +251,7 @@ macro_rules! sort_strings {\n             b.iter(|| v.clone().$f());\n             b.bytes = $len * mem::size_of::<&str>() as u64;\n         }\n-    }\n+    };\n }\n \n macro_rules! sort_expensive {\n@@ -273,7 +273,7 @@ macro_rules! sort_expensive {\n             });\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n-    }\n+    };\n }\n \n macro_rules! sort_lexicographic {\n@@ -284,7 +284,7 @@ macro_rules! sort_lexicographic {\n             b.iter(|| v.clone().$f(|x| x.to_string()));\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n-    }\n+    };\n }\n \n sort!(sort, sort_small_ascending, gen_ascending, 10);\n@@ -325,57 +325,58 @@ macro_rules! reverse {\n         fn $name(b: &mut Bencher) {\n             // odd length and offset by 1 to be as unaligned as possible\n             let n = 0xFFFFF;\n-            let mut v: Vec<_> =\n-                (0..1+(n / mem::size_of::<$ty>() as u64))\n-                .map($f)\n-                .collect();\n+            let mut v: Vec<_> = (0..1 + (n / mem::size_of::<$ty>() as u64)).map($f).collect();\n             b.iter(|| black_box(&mut v[1..]).reverse());\n             b.bytes = n;\n         }\n-    }\n+    };\n }\n \n reverse!(reverse_u8, u8, |x| x as u8);\n reverse!(reverse_u16, u16, |x| x as u16);\n-reverse!(reverse_u8x3, [u8;3], |x| [x as u8, (x>>8) as u8, (x>>16) as u8]);\n+reverse!(reverse_u8x3, [u8; 3], |x| [x as u8, (x >> 8) as u8, (x >> 16) as u8]);\n reverse!(reverse_u32, u32, |x| x as u32);\n reverse!(reverse_u64, u64, |x| x as u64);\n reverse!(reverse_u128, u128, |x| x as u128);\n-#[repr(simd)] struct F64x4(f64, f64, f64, f64);\n-reverse!(reverse_simd_f64x4, F64x4, |x| { let x = x as f64; F64x4(x,x,x,x) });\n+#[repr(simd)]\n+struct F64x4(f64, f64, f64, f64);\n+reverse!(reverse_simd_f64x4, F64x4, |x| {\n+    let x = x as f64;\n+    F64x4(x, x, x, x)\n+});\n \n macro_rules! rotate {\n     ($name:ident, $gen:expr, $len:expr, $mid:expr) => {\n         #[bench]\n         fn $name(b: &mut Bencher) {\n             let size = mem::size_of_val(&$gen(1)[0]);\n             let mut v = $gen($len * 8 / size);\n-            b.iter(|| black_box(&mut v).rotate_left(($mid*8+size-1)/size));\n+            b.iter(|| black_box(&mut v).rotate_left(($mid * 8 + size - 1) / size));\n             b.bytes = (v.len() * size) as u64;\n         }\n-    }\n+    };\n }\n \n rotate!(rotate_tiny_by1, gen_random, 16, 1);\n-rotate!(rotate_tiny_half, gen_random, 16, 16/2);\n-rotate!(rotate_tiny_half_plus_one, gen_random, 16, 16/2+1);\n+rotate!(rotate_tiny_half, gen_random, 16, 16 / 2);\n+rotate!(rotate_tiny_half_plus_one, gen_random, 16, 16 / 2 + 1);\n \n rotate!(rotate_medium_by1, gen_random, 9158, 1);\n rotate!(rotate_medium_by727_u64, gen_random, 9158, 727);\n rotate!(rotate_medium_by727_bytes, gen_random_bytes, 9158, 727);\n rotate!(rotate_medium_by727_strings, gen_strings, 9158, 727);\n-rotate!(rotate_medium_half, gen_random, 9158, 9158/2);\n-rotate!(rotate_medium_half_plus_one, gen_random, 9158, 9158/2+1);\n+rotate!(rotate_medium_half, gen_random, 9158, 9158 / 2);\n+rotate!(rotate_medium_half_plus_one, gen_random, 9158, 9158 / 2 + 1);\n \n // Intended to use more RAM than the machine has cache\n-rotate!(rotate_huge_by1, gen_random, 5*1024*1024, 1);\n-rotate!(rotate_huge_by9199_u64, gen_random, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by9199_bytes, gen_random_bytes, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by9199_strings, gen_strings, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by9199_big, gen_big_random, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by1234577_u64, gen_random, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_by1234577_bytes, gen_random_bytes, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_by1234577_strings, gen_strings, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_by1234577_big, gen_big_random, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_half, gen_random, 5*1024*1024, 5*1024*1024/2);\n-rotate!(rotate_huge_half_plus_one, gen_random, 5*1024*1024, 5*1024*1024/2+1);\n+rotate!(rotate_huge_by1, gen_random, 5 * 1024 * 1024, 1);\n+rotate!(rotate_huge_by9199_u64, gen_random, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by9199_bytes, gen_random_bytes, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by9199_strings, gen_strings, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by9199_big, gen_big_random, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by1234577_u64, gen_random, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_by1234577_bytes, gen_random_bytes, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_by1234577_strings, gen_strings, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_by1234577_big, gen_big_random, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_half, gen_random, 5 * 1024 * 1024, 5 * 1024 * 1024 / 2);\n+rotate!(rotate_huge_half_plus_one, gen_random, 5 * 1024 * 1024, 5 * 1024 * 1024 / 2 + 1);"}, {"sha": "391475bc0c75deda0ca0e47e15f8e7ad9cb2f8f3", "filename": "src/liballoc/benches/str.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fbenches%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fbenches%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstr.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,4 +1,4 @@\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn char_iterator(b: &mut Bencher) {\n@@ -12,7 +12,9 @@ fn char_iterator_for(b: &mut Bencher) {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n \n     b.iter(|| {\n-        for ch in s.chars() { black_box(ch); }\n+        for ch in s.chars() {\n+            black_box(ch);\n+        }\n     });\n }\n \n@@ -40,7 +42,9 @@ fn char_iterator_rev_for(b: &mut Bencher) {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n \n     b.iter(|| {\n-        for ch in s.chars().rev() { black_box(ch); }\n+        for ch in s.chars().rev() {\n+            black_box(ch);\n+        }\n     });\n }\n \n@@ -79,7 +83,9 @@ fn split_ascii(b: &mut Bencher) {\n fn split_extern_fn(b: &mut Bencher) {\n     let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n     let len = s.split(' ').count();\n-    fn pred(c: char) -> bool { c == ' ' }\n+    fn pred(c: char) -> bool {\n+        c == ' '\n+    }\n \n     b.iter(|| assert_eq!(s.split(pred).count(), len));\n }\n@@ -185,16 +191,19 @@ fn bench_contains_equal(b: &mut Bencher) {\n     })\n }\n \n-\n macro_rules! make_test_inner {\n     ($s:ident, $code:expr, $name:ident, $str:expr, $iters:expr) => {\n         #[bench]\n         fn $name(bencher: &mut Bencher) {\n             let mut $s = $str;\n             black_box(&mut $s);\n-            bencher.iter(|| for _ in 0..$iters { black_box($code); });\n+            bencher.iter(|| {\n+                for _ in 0..$iters {\n+                    black_box($code);\n+                }\n+            });\n         }\n-    }\n+    };\n }\n \n macro_rules! make_test {\n@@ -261,15 +270,9 @@ make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n \n make_test!(split_a_str, s, s.split(\"a\").count());\n \n-make_test!(trim_ascii_char, s, {\n-    s.trim_matches(|c: char| c.is_ascii())\n-});\n-make_test!(trim_start_ascii_char, s, {\n-    s.trim_start_matches(|c: char| c.is_ascii())\n-});\n-make_test!(trim_end_ascii_char, s, {\n-    s.trim_end_matches(|c: char| c.is_ascii())\n-});\n+make_test!(trim_ascii_char, s, { s.trim_matches(|c: char| c.is_ascii()) });\n+make_test!(trim_start_ascii_char, s, { s.trim_start_matches(|c: char| c.is_ascii()) });\n+make_test!(trim_end_ascii_char, s, { s.trim_end_matches(|c: char| c.is_ascii()) });\n \n make_test!(find_underscore_char, s, s.find('_'));\n make_test!(rfind_underscore_char, s, s.rfind('_'));"}, {"sha": "bf2dffd1e931eecfbc52c1b48c5811e196085958", "filename": "src/liballoc/benches/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,5 +1,5 @@\n use std::collections::VecDeque;\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn bench_new(b: &mut Bencher) {"}, {"sha": "5825bdc355f2d173d4ab3aff19bd9e509aa8eb9e", "filename": "src/liballoc/benches/vec_deque_append.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -30,8 +30,5 @@ fn main() {\n \n     assert!(BENCH_N % 2 == 0);\n     let median = (durations[(l / 2) - 1] + durations[l / 2]) / 2;\n-    println!(\n-        \"\\ncustom-bench vec_deque_append {:?} ns/iter\\n\",\n-        median.as_nanos()\n-    );\n+    println!(\"\\ncustom-bench vec_deque_append {:?} ns/iter\\n\", median.as_nanos());\n }"}, {"sha": "51ad3a04e87fe6b7791ce14af0ff204f094b864b", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -152,6 +152,33 @@ impl<T> Box<T> {\n         Box(ptr.cast().into())\n     }\n \n+    /// Constructs a new `Box` with uninitialized contents, with the memory\n+    /// being filled with `0` bytes.\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let zero = Box::<u32>::new_zeroed();\n+    /// let zero = unsafe { zero.assume_init() };\n+    ///\n+    /// assert_eq!(*zero, 0)\n+    /// ```\n+    ///\n+    /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_zeroed() -> Box<mem::MaybeUninit<T>> {\n+        unsafe {\n+            let mut uninit = Self::new_uninit();\n+            ptr::write_bytes::<T>(uninit.as_mut_ptr(), 0, 1);\n+            uninit\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n     /// `x` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]"}, {"sha": "f73a24d09916bb1cbd448fb83868a541c4db84af", "filename": "src/liballoc/collections/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,6 +1,6 @@\n+pub mod map;\n mod node;\n mod search;\n-pub mod map;\n pub mod set;\n \n #[doc(hidden)]"}, {"sha": "ab010b35f6ad1568eb3233f767abefc0437dde2d", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -596,7 +596,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n             // (We might be one-past-the-end, but that is allowed by LLVM.)\n             // Getting the pointer is tricky though.  `NodeHeader` does not have a `keys`\n             // field because we want its size to not depend on the alignment of `K`\n-            // (needed becuase `as_header` should be safe).  We cannot call `as_leaf`\n+            // (needed because `as_header` should be safe).  We cannot call `as_leaf`\n             // because we might be the shared root.\n             // For this reason, `NodeHeader` has this `K2` parameter (that's usually `()`\n             // and hence just adds a size-0-align-1 field, not affecting layout)."}, {"sha": "3f3c49a2ef875246600f87cf976b1b4ea538d370", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,21 +1,23 @@\n use core::borrow::Borrow;\n use core::cmp::Ordering;\n \n-use super::node::{Handle, NodeRef, marker, ForceResult::*};\n+use super::node::{marker, ForceResult::*, Handle, NodeRef};\n \n use SearchResult::*;\n \n pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n     Found(Handle<NodeRef<BorrowType, K, V, FoundType>, marker::KV>),\n-    GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>)\n+    GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>),\n }\n \n pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n     mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-    key: &Q\n+    key: &Q,\n ) -> SearchResult<BorrowType, K, V, marker::LeafOrInternal, marker::Leaf>\n-        where Q: Ord, K: Borrow<Q> {\n-\n+where\n+    Q: Ord,\n+    K: Borrow<Q>,\n+{\n     loop {\n         match search_node(node, key) {\n             Found(handle) => return Found(handle),\n@@ -25,38 +27,38 @@ pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n                     node = internal.descend();\n                     continue;\n                 }\n-            }\n+            },\n         }\n     }\n }\n \n pub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n     node: NodeRef<BorrowType, K, V, Type>,\n-    key: &Q\n+    key: &Q,\n ) -> SearchResult<BorrowType, K, V, Type, Type>\n-        where Q: Ord, K: Borrow<Q> {\n-\n+where\n+    Q: Ord,\n+    K: Borrow<Q>,\n+{\n     match search_linear(&node, key) {\n-        (idx, true) => Found(\n-            Handle::new_kv(node, idx)\n-        ),\n-        (idx, false) => SearchResult::GoDown(\n-            Handle::new_edge(node, idx)\n-        )\n+        (idx, true) => Found(Handle::new_kv(node, idx)),\n+        (idx, false) => SearchResult::GoDown(Handle::new_edge(node, idx)),\n     }\n }\n \n pub fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n     node: &NodeRef<BorrowType, K, V, Type>,\n-    key: &Q\n+    key: &Q,\n ) -> (usize, bool)\n-        where Q: Ord, K: Borrow<Q> {\n-\n+where\n+    Q: Ord,\n+    K: Borrow<Q>,\n+{\n     for (i, k) in node.keys().iter().enumerate() {\n         match key.cmp(k.borrow()) {\n-            Ordering::Greater => {},\n+            Ordering::Greater => {}\n             Ordering::Equal => return (i, true),\n-            Ordering::Less => return (i, false)\n+            Ordering::Less => return (i, false),\n         }\n     }\n     (node.keys().len(), false)"}, {"sha": "94b92df12940098e5d68b888970e57fa553bfe1b", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -177,8 +177,7 @@ fn test_insert_prev() {\n     }\n     check_links(&m);\n     assert_eq!(m.len(), 3 + len * 2);\n-    assert_eq!(m.into_iter().collect::<Vec<_>>(),\n-                [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n }\n \n #[test]\n@@ -187,13 +186,13 @@ fn test_insert_prev() {\n fn test_send() {\n     let n = list_from(&[1, 2, 3]);\n     thread::spawn(move || {\n-            check_links(&n);\n-            let a: &[_] = &[&1, &2, &3];\n-            assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n-        })\n-        .join()\n-        .ok()\n-        .unwrap();\n+        check_links(&n);\n+        let a: &[_] = &[&1, &2, &3];\n+        assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n+    })\n+    .join()\n+    .ok()\n+    .unwrap();\n }\n \n #[test]"}, {"sha": "8dc097cc088051a4fdb5d8472fa52c00840314ce", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -66,11 +66,8 @@ fn test_swap_front_back_remove() {\n         let final_len = usable_cap / 2;\n \n         for len in 0..final_len {\n-            let expected: VecDeque<_> = if back {\n-                (0..len).collect()\n-            } else {\n-                (0..len).rev().collect()\n-            };\n+            let expected: VecDeque<_> =\n+                if back { (0..len).collect() } else { (0..len).rev().collect() };\n             for tail_pos in 0..usable_cap {\n                 tester.tail = tail_pos;\n                 tester.head = tail_pos;\n@@ -111,7 +108,6 @@ fn test_insert() {\n     // this test isn't covering what it wants to\n     let cap = tester.capacity();\n \n-\n     // len is the length *after* insertion\n     for len in 1..cap {\n         // 0, 1, 2, .., len - 1\n@@ -198,9 +194,7 @@ fn test_drain() {\n                     assert!(tester.head < tester.cap());\n \n                     // We should see the correct values in the VecDeque\n-                    let expected: VecDeque<_> = (0..drain_start)\n-                        .chain(drain_end..len)\n-                        .collect();\n+                    let expected: VecDeque<_> = (0..drain_start).chain(drain_end..len).collect();\n                     assert_eq!(expected, tester);\n                 }\n             }"}, {"sha": "18ebae333098f9f42ea80c1ceb982825b5eae924", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -516,24 +516,24 @@\n \n #[unstable(feature = \"fmt_internals\", issue = \"0\")]\n pub use core::fmt::rt;\n+#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n+pub use core::fmt::Alignment;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{Formatter, Result, Write};\n+pub use core::fmt::Error;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::fmt::{write, ArgumentV1, Arguments};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{Binary, Octal};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{Debug, Display};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{LowerHex, Pointer, UpperHex};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{LowerExp, UpperExp};\n+pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::Error;\n+pub use core::fmt::{Formatter, Result, Write};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{write, ArgumentV1, Arguments};\n+pub use core::fmt::{LowerExp, UpperExp};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n-#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n-pub use core::fmt::{Alignment};\n+pub use core::fmt::{LowerHex, Pointer, UpperHex};\n \n use crate::string;\n \n@@ -568,8 +568,6 @@ use crate::string;\n pub fn format(args: Arguments<'_>) -> string::String {\n     let capacity = args.estimated_capacity();\n     let mut output = string::String::with_capacity(capacity);\n-    output\n-        .write_fmt(args)\n-        .expect(\"a formatting trait implementation returned an error\");\n+    output.write_fmt(args).expect(\"a formatting trait implementation returned an error\");\n     output\n }"}, {"sha": "6a53b4ca1f6ca961f1c53703c3a56c5e4ca21f72", "filename": "src/liballoc/prelude/v1.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude%2Fv1.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -4,7 +4,11 @@\n \n #![unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n \n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::borrow::ToOwned;\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::boxed::Box;\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::string::{String, ToString};\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::vec::Vec;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::borrow::ToOwned;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::boxed::Box;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::string::{String, ToString};\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::vec::Vec;"}, {"sha": "b214cef30111516146e2ea14488dba664118f180", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -16,15 +16,20 @@ fn allocator_param() {\n \n     // A dumb allocator that consumes a fixed amount of fuel\n     // before allocation attempts start failing.\n-    struct BoundedAlloc { fuel: usize }\n+    struct BoundedAlloc {\n+        fuel: usize,\n+    }\n     unsafe impl Alloc for BoundedAlloc {\n         unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);\n             }\n             match Global.alloc(layout) {\n-                ok @ Ok(_) => { self.fuel -= size; ok }\n+                ok @ Ok(_) => {\n+                    self.fuel -= size;\n+                    ok\n+                }\n                 err @ Err(_) => err,\n             }\n         }"}, {"sha": "1ff1c3c834f4ea4c10b3ed5133ec765601f040bf", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -361,6 +361,35 @@ impl<T> Rc<T> {\n         }\n     }\n \n+    /// Constructs a new `Rc` with uninitialized contents, with the memory\n+    /// being filled with `0` bytes.\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and\n+    /// incorrect usage of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let zero = Rc::<u32>::new_zeroed();\n+    /// let zero = unsafe { zero.assume_init() };\n+    ///\n+    /// assert_eq!(*zero, 0)\n+    /// ```\n+    ///\n+    /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_zeroed() -> Rc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            let mut uninit = Self::new_uninit();\n+            ptr::write_bytes::<T>(Rc::get_mut_unchecked(&mut uninit).as_mut_ptr(), 0, 1);\n+            uninit\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then\n     /// `value` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -897,7 +926,7 @@ impl<T: ?Sized> Rc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<RcBox<()>>()\n             .extend(value_layout).unwrap().0\n-            .pad_to_align().unwrap();\n+            .pad_to_align();\n \n         // Allocate for the layout.\n         let mem = Global.alloc(layout)\n@@ -1619,10 +1648,8 @@ impl<T> Weak<T> {\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n-    /// It is up to the caller to ensure that the object is still alive when accessing it through\n-    /// the pointer.\n-    ///\n-    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    /// The pointer is valid only if there are some strong references. The pointer may be dangling\n+    /// or even [`null`] otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -1702,14 +1729,18 @@ impl<T> Weak<T> {\n     /// This can be used to safely get a strong reference (by calling [`upgrade`]\n     /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n     ///\n-    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n-    /// returned.\n+    /// It takes ownership of one weak count (with the exception of pointers created by [`new`],\n+    /// as these don't have any corresponding weak count).\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n-    /// is or *was* managed by an [`Rc`] and the weak count of that [`Rc`] must not have reached\n-    /// 0. It is allowed for the strong count to be 0.\n+    /// The pointer must have originated from the [`into_raw`] (or [`as_raw`], provided there was\n+    /// a corresponding [`forget`] on the `Weak<T>`) and must still own its potential weak reference\n+    /// count.\n+    ///\n+    /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n+    /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n+    /// by [`new`]).\n     ///\n     /// # Examples\n     ///\n@@ -1734,11 +1765,13 @@ impl<T> Weak<T> {\n     /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n-    /// [`null`]: ../../std/ptr/fn.null.html\n     /// [`into_raw`]: struct.Weak.html#method.into_raw\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`Rc`]: struct.Rc.html\n     /// [`Weak`]: struct.Weak.html\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    /// [`new`]: struct.Weak.html#method.new\n+    /// [`forget`]: ../../std/mem/fn.forget.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {"}, {"sha": "2f6d10c027be38bcd742a8a525d158ebada6b62b", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 92, "deletions": 81, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -82,7 +82,6 @@\n //! [`.chunks`]: ../../std/primitive.slice.html#method.chunks\n //! [`.windows`]: ../../std/primitive.slice.html#method.windows\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n // Many of the usings in this module are only used in the test configuration.\n // It's cleaner to just turn off the unused_imports warning than to fix them.\n #![cfg_attr(test, allow(unused_imports, dead_code))]\n@@ -91,32 +90,32 @@ use core::borrow::{Borrow, BorrowMut};\n use core::cmp::Ordering::{self, Less};\n use core::mem::{self, size_of};\n use core::ptr;\n-use core::{u8, u16, u32};\n+use core::{u16, u32, u8};\n \n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n \n+#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+pub use core::slice::SliceIndex;\n+#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n+pub use core::slice::{from_mut, from_ref};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{Chunks, Windows};\n+pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{Iter, IterMut};\n+pub use core::slice::{Chunks, Windows};\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+pub use core::slice::{ChunksExact, ChunksExactMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{SplitMut, ChunksMut, Split};\n+pub use core::slice::{ChunksMut, Split, SplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n+pub use core::slice::{Iter, IterMut};\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+pub use core::slice::{RChunks, RChunksExact, RChunksExactMut, RChunksMut};\n #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n pub use core::slice::{RSplit, RSplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n-#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n-pub use core::slice::{from_ref, from_mut};\n-#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-pub use core::slice::SliceIndex;\n-#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n-pub use core::slice::{ChunksExact, ChunksExactMut};\n-#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n-pub use core::slice::{RChunks, RChunksMut, RChunksExact, RChunksExactMut};\n+pub use core::slice::{RSplitN, RSplitNMut, SplitN, SplitNMut};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n@@ -138,9 +137,9 @@ pub use hack::to_vec;\n // `test_permutations` test\n mod hack {\n     use crate::boxed::Box;\n-    use crate::vec::Vec;\n     #[cfg(test)]\n     use crate::string::ToString;\n+    use crate::vec::Vec;\n \n     pub fn into_vec<T>(b: Box<[T]>) -> Vec<T> {\n         unsafe {\n@@ -153,7 +152,8 @@ mod hack {\n \n     #[inline]\n     pub fn to_vec<T>(s: &[T]) -> Vec<T>\n-        where T: Clone\n+    where\n+        T: Clone,\n     {\n         let mut vector = Vec::with_capacity(s.len());\n         vector.extend_from_slice(s);\n@@ -193,7 +193,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort(&mut self)\n-        where T: Ord\n+    where\n+        T: Ord,\n     {\n         merge_sort(self, |a, b| a.lt(b));\n     }\n@@ -246,7 +247,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort_by<F>(&mut self, mut compare: F)\n-        where F: FnMut(&T, &T) -> Ordering\n+    where\n+        F: FnMut(&T, &T) -> Ordering,\n     {\n         merge_sort(self, |a, b| compare(a, b) == Less);\n     }\n@@ -285,7 +287,9 @@ impl<T> [T] {\n     #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n     #[inline]\n     pub fn sort_by_key<K, F>(&mut self, mut f: F)\n-        where F: FnMut(&T) -> K, K: Ord\n+    where\n+        F: FnMut(&T) -> K,\n+        K: Ord,\n     {\n         merge_sort(self, |a, b| f(a).lt(&f(b)));\n     }\n@@ -325,11 +329,13 @@ impl<T> [T] {\n     #[stable(feature = \"slice_sort_by_cached_key\", since = \"1.34.0\")]\n     #[inline]\n     pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n-        where F: FnMut(&T) -> K, K: Ord\n+    where\n+        F: FnMut(&T) -> K,\n+        K: Ord,\n     {\n         // Helper macro for indexing our vector by the smallest possible type, to reduce allocation.\n         macro_rules! sort_by_key {\n-            ($t:ty, $slice:ident, $f:ident) => ({\n+            ($t:ty, $slice:ident, $f:ident) => {{\n                 let mut indices: Vec<_> =\n                     $slice.iter().map($f).enumerate().map(|(i, k)| (k, i as $t)).collect();\n                 // The elements of `indices` are unique, as they are indexed, so any sort will be\n@@ -344,19 +350,27 @@ impl<T> [T] {\n                     indices[i].1 = index;\n                     $slice.swap(i, index as usize);\n                 }\n-            })\n+            }};\n         }\n \n-        let sz_u8    = mem::size_of::<(K, u8)>();\n-        let sz_u16   = mem::size_of::<(K, u16)>();\n-        let sz_u32   = mem::size_of::<(K, u32)>();\n+        let sz_u8 = mem::size_of::<(K, u8)>();\n+        let sz_u16 = mem::size_of::<(K, u16)>();\n+        let sz_u32 = mem::size_of::<(K, u32)>();\n         let sz_usize = mem::size_of::<(K, usize)>();\n \n         let len = self.len();\n-        if len < 2 { return }\n-        if sz_u8  < sz_u16   && len <= ( u8::MAX as usize) { return sort_by_key!( u8, self, f) }\n-        if sz_u16 < sz_u32   && len <= (u16::MAX as usize) { return sort_by_key!(u16, self, f) }\n-        if sz_u32 < sz_usize && len <= (u32::MAX as usize) { return sort_by_key!(u32, self, f) }\n+        if len < 2 {\n+            return;\n+        }\n+        if sz_u8 < sz_u16 && len <= (u8::MAX as usize) {\n+            return sort_by_key!(u8, self, f);\n+        }\n+        if sz_u16 < sz_u32 && len <= (u16::MAX as usize) {\n+            return sort_by_key!(u16, self, f);\n+        }\n+        if sz_u32 < sz_usize && len <= (u32::MAX as usize) {\n+            return sort_by_key!(u32, self, f);\n+        }\n         sort_by_key!(usize, self, f)\n     }\n \n@@ -373,7 +387,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_vec(&self) -> Vec<T>\n-        where T: Clone\n+    where\n+        T: Clone,\n     {\n         // N.B., see the `hack` module in this file for more details.\n         hack::to_vec(self)\n@@ -421,7 +436,10 @@ impl<T> [T] {\n     /// b\"0123456789abcdef\".repeat(usize::max_value());\n     /// ```\n     #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n-    pub fn repeat(&self, n: usize) -> Vec<T> where T: Copy {\n+    pub fn repeat(&self, n: usize) -> Vec<T>\n+    where\n+        T: Copy,\n+    {\n         if n == 0 {\n             return Vec::new();\n         }\n@@ -486,7 +504,8 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n-        where Self: Concat<Item>\n+    where\n+        Self: Concat<Item>,\n     {\n         Concat::concat(self)\n     }\n@@ -503,7 +522,8 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n     pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n-        where Self: Join<Separator>\n+    where\n+        Self: Join<Separator>,\n     {\n         Join::join(self, sep)\n     }\n@@ -521,11 +541,11 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n     pub fn connect<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n-        where Self: Join<Separator>\n+    where\n+        Self: Join<Separator>,\n     {\n         Join::join(self, sep)\n     }\n-\n }\n \n #[lang = \"slice_u8_alloc\"]\n@@ -668,8 +688,8 @@ impl<T: Clone, V: Borrow<[T]>> Join<&[T]> for [V] {\n             Some(first) => first,\n             None => return vec![],\n         };\n-        let size = slice.iter().map(|v| v.borrow().len()).sum::<usize>() +\n-            sep.len() * (slice.len() - 1);\n+        let size =\n+            slice.iter().map(|v| v.borrow().len()).sum::<usize>() + sep.len() * (slice.len() - 1);\n         let mut result = Vec::with_capacity(size);\n         result.extend_from_slice(first.borrow());\n \n@@ -734,7 +754,8 @@ impl<T: Clone> ToOwned for [T] {\n ///\n /// This is the integral subroutine of insertion sort.\n fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     if v.len() >= 2 && is_less(&v[1], &v[0]) {\n         unsafe {\n@@ -767,10 +788,7 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n             // If `is_less` panics at any point during the process, `hole` will get dropped and\n             // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n             // initially held exactly once.\n-            let mut hole = InsertionHole {\n-                src: &mut *tmp,\n-                dest: &mut v[1],\n-            };\n+            let mut hole = InsertionHole { src: &mut *tmp, dest: &mut v[1] };\n             ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n \n             for i in 2..v.len() {\n@@ -792,7 +810,9 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n \n     impl<T> Drop for InsertionHole<T> {\n         fn drop(&mut self) {\n-            unsafe { ptr::copy_nonoverlapping(self.src, self.dest, 1); }\n+            unsafe {\n+                ptr::copy_nonoverlapping(self.src, self.dest, 1);\n+            }\n         }\n     }\n }\n@@ -805,7 +825,8 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n /// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n /// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n     let v = v.as_mut_ptr();\n@@ -834,11 +855,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n     if mid <= len - mid {\n         // The left run is shorter.\n         ptr::copy_nonoverlapping(v, buf, mid);\n-        hole = MergeHole {\n-            start: buf,\n-            end: buf.add(mid),\n-            dest: v,\n-        };\n+        hole = MergeHole { start: buf, end: buf.add(mid), dest: v };\n \n         // Initially, these pointers point to the beginnings of their arrays.\n         let left = &mut hole.start;\n@@ -858,11 +875,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n     } else {\n         // The right run is shorter.\n         ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n-        hole = MergeHole {\n-            start: buf,\n-            end: buf.add(len - mid),\n-            dest: v_mid,\n-        };\n+        hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };\n \n         // Initially, these pointers point past the ends of their arrays.\n         let left = &mut hole.dest;\n@@ -905,7 +918,9 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n         fn drop(&mut self) {\n             // `T` is not a zero-sized type, so it's okay to divide by its size.\n             let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n-            unsafe { ptr::copy_nonoverlapping(self.start, self.dest, len); }\n+            unsafe {\n+                ptr::copy_nonoverlapping(self.start, self.dest, len);\n+            }\n         }\n     }\n }\n@@ -923,7 +938,8 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n ///\n /// The invariants ensure that the total running time is `O(n log n)` worst-case.\n fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Slices of up to this length get sorted using insertion sort.\n     const MAX_INSERTION: usize = 20;\n@@ -940,7 +956,7 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n     // Short arrays get sorted in-place via insertion sort to avoid allocations.\n     if len <= MAX_INSERTION {\n         if len >= 2 {\n-            for i in (0..len-1).rev() {\n+            for i in (0..len - 1).rev() {\n                 insert_head(&mut v[i..], &mut is_less);\n             }\n         }\n@@ -966,14 +982,13 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n             start -= 1;\n             unsafe {\n                 if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n-                    while start > 0 && is_less(v.get_unchecked(start),\n-                                               v.get_unchecked(start - 1)) {\n+                    while start > 0 && is_less(v.get_unchecked(start), v.get_unchecked(start - 1)) {\n                         start -= 1;\n                     }\n                     v[start..end].reverse();\n                 } else {\n-                    while start > 0 && !is_less(v.get_unchecked(start),\n-                                                v.get_unchecked(start - 1)) {\n+                    while start > 0 && !is_less(v.get_unchecked(start), v.get_unchecked(start - 1))\n+                    {\n                         start -= 1;\n                     }\n                 }\n@@ -988,24 +1003,22 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n         }\n \n         // Push this run onto the stack.\n-        runs.push(Run {\n-            start,\n-            len: end - start,\n-        });\n+        runs.push(Run { start, len: end - start });\n         end = start;\n \n         // Merge some pairs of adjacent runs to satisfy the invariants.\n         while let Some(r) = collapse(&runs) {\n             let left = runs[r + 1];\n             let right = runs[r];\n             unsafe {\n-                merge(&mut v[left.start .. right.start + right.len], left.len, buf.as_mut_ptr(),\n-                      &mut is_less);\n+                merge(\n+                    &mut v[left.start..right.start + right.len],\n+                    left.len,\n+                    buf.as_mut_ptr(),\n+                    &mut is_less,\n+                );\n             }\n-            runs[r] = Run {\n-                start: left.start,\n-                len: left.len + right.len,\n-            };\n+            runs[r] = Run { start: left.start, len: left.len + right.len };\n             runs.remove(r + 1);\n         }\n     }\n@@ -1030,15 +1043,13 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n     #[inline]\n     fn collapse(runs: &[Run]) -> Option<usize> {\n         let n = runs.len();\n-        if n >= 2 && (runs[n - 1].start == 0 ||\n-                      runs[n - 2].len <= runs[n - 1].len ||\n-                      (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len) ||\n-                      (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len)) {\n-            if n >= 3 && runs[n - 3].len < runs[n - 1].len {\n-                Some(n - 3)\n-            } else {\n-                Some(n - 2)\n-            }\n+        if n >= 2\n+            && (runs[n - 1].start == 0\n+                || runs[n - 2].len <= runs[n - 1].len\n+                || (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len)\n+                || (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len))\n+        {\n+            if n >= 3 && runs[n - 3].len < runs[n - 1].len { Some(n - 3) } else { Some(n - 2) }\n         } else {\n             None\n         }"}, {"sha": "19b0086fa333cc1a25005ff83c99b105c55232eb", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -341,6 +341,35 @@ impl<T> Arc<T> {\n         }\n     }\n \n+    /// Constructs a new `Arc` with uninitialized contents, with the memory\n+    /// being filled with `0` bytes.\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let zero = Arc::<u32>::new_zeroed();\n+    /// let zero = unsafe { zero.assume_init() };\n+    ///\n+    /// assert_eq!(*zero, 0)\n+    /// ```\n+    ///\n+    /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_zeroed() -> Arc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            let mut uninit = Self::new_uninit();\n+            ptr::write_bytes::<T>(Arc::get_mut_unchecked(&mut uninit).as_mut_ptr(), 0, 1);\n+            uninit\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Arc<T>>`. If `T` does not implement `Unpin`, then\n     /// `data` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -751,7 +780,7 @@ impl<T: ?Sized> Arc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>()\n             .extend(value_layout).unwrap().0\n-            .pad_to_align().unwrap();\n+            .pad_to_align();\n \n         let mem = Global.alloc(layout)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n@@ -1295,10 +1324,8 @@ impl<T> Weak<T> {\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n-    /// It is up to the caller to ensure that the object is still alive when accessing it through\n-    /// the pointer.\n-    ///\n-    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    /// The pointer is valid only if there are some strong references. The pointer may be dangling\n+    /// or even [`null`] otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -1379,14 +1406,18 @@ impl<T> Weak<T> {\n     /// This can be used to safely get a strong reference (by calling [`upgrade`]\n     /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n     ///\n-    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n-    /// returned.\n+    /// It takes ownership of one weak count (with the exception of pointers created by [`new`],\n+    /// as these don't have any corresponding weak count).\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n-    /// is or *was* managed by an [`Arc`] and the weak count of that [`Arc`] must not have reached\n-    /// 0. It is allowed for the strong count to be 0.\n+    /// The pointer must have originated from the [`into_raw`] (or [`as_raw'], provided there was\n+    /// a corresponding [`forget`] on the `Weak<T>`) and must still own its potential weak reference\n+    /// count.\n+    ///\n+    /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n+    /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n+    /// by [`new`]).\n     ///\n     /// # Examples\n     ///\n@@ -1411,11 +1442,13 @@ impl<T> Weak<T> {\n     /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n-    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    /// [`new`]: struct.Weak.html#method.new\n     /// [`into_raw`]: struct.Weak.html#method.into_raw\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`Weak`]: struct.Weak.html\n     /// [`Arc`]: struct.Arc.html\n+    /// [`forget`]: ../../std/mem/fn.forget.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {"}, {"sha": "1b6e0bb291c35c17aba17233df5f574a68b8f091", "filename": "src/liballoc/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,12 +1,12 @@\n //! Test for `boxed` mod.\n \n use core::any::Any;\n-use core::convert::TryInto;\n-use core::ops::Deref;\n-use core::result::Result::{Err, Ok};\n use core::clone::Clone;\n+use core::convert::TryInto;\n use core::f64;\n use core::i64;\n+use core::ops::Deref;\n+use core::result::Result::{Err, Ok};\n \n use std::boxed::Box;\n "}, {"sha": "2fbb59b0419e020422fd77aa20ec45b3d52d48ac", "filename": "src/liballoc/tests/arc.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,9 +1,9 @@\n use std::any::Any;\n-use std::sync::{Arc, Weak};\n use std::cell::RefCell;\n use std::cmp::PartialEq;\n use std::iter::TrustedLen;\n use std::mem;\n+use std::sync::{Arc, Weak};\n \n #[test]\n fn uninhabited() {\n@@ -12,16 +12,16 @@ fn uninhabited() {\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n \n-    let mut a: Weak<dyn Any> = a;  // Unsizing\n+    let mut a: Weak<dyn Any> = a; // Unsizing\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n }\n \n #[test]\n fn slice() {\n     let a: Arc<[u32; 3]> = Arc::new([3, 2, 1]);\n-    let a: Arc<[u32]> = a;  // Unsizing\n-    let b: Arc<[u32]> = Arc::from(&[3, 2, 1][..]);  // Conversion\n+    let a: Arc<[u32]> = a; // Unsizing\n+    let b: Arc<[u32]> = Arc::from(&[3, 2, 1][..]); // Conversion\n     assert_eq!(a, b);\n \n     // Exercise is_dangling() with a DST\n@@ -33,7 +33,7 @@ fn slice() {\n #[test]\n fn trait_object() {\n     let a: Arc<u32> = Arc::new(4);\n-    let a: Arc<dyn Any> = a;  // Unsizing\n+    let a: Arc<dyn Any> = a; // Unsizing\n \n     // Exercise is_dangling() with a DST\n     let mut a = Arc::downgrade(&a);\n@@ -43,7 +43,7 @@ fn trait_object() {\n     let mut b = Weak::<u32>::new();\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n-    let mut b: Weak<dyn Any> = b;  // Unsizing\n+    let mut b: Weak<dyn Any> = b; // Unsizing\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n }\n@@ -57,7 +57,7 @@ fn float_nan_ne() {\n \n #[test]\n fn partial_eq() {\n-    struct TestPEq (RefCell<usize>);\n+    struct TestPEq(RefCell<usize>);\n     impl PartialEq for TestPEq {\n         fn eq(&self, other: &TestPEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -74,7 +74,7 @@ fn partial_eq() {\n #[test]\n fn eq() {\n     #[derive(Eq)]\n-    struct TestEq (RefCell<usize>);\n+    struct TestEq(RefCell<usize>);\n     impl PartialEq for TestEq {\n         fn eq(&self, other: &TestEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -160,13 +160,10 @@ fn shared_from_iter_trustedlen_normal() {\n fn shared_from_iter_trustedlen_panic() {\n     // Exercise the `TrustedLen` implementation when `size_hint()` matches\n     // `(_, Some(exact_len))` but where `.next()` drops before the last iteration.\n-    let iter = (0..SHARED_ITER_MAX)\n-        .map(|val| {\n-            match val {\n-                98 => panic!(\"I've almost got 99 problems.\"),\n-                _ => Box::new(val),\n-            }\n-        });\n+    let iter = (0..SHARED_ITER_MAX).map(|val| match val {\n+        98 => panic!(\"I've almost got 99 problems.\"),\n+        _ => Box::new(val),\n+    });\n     assert_trusted_len(&iter);\n     let _ = iter.collect::<Rc<[_]>>();\n \n@@ -193,16 +190,8 @@ fn shared_from_iter_trustedlen_no_fuse() {\n         }\n     }\n \n-    let vec = vec![\n-        Some(Box::new(42)),\n-        Some(Box::new(24)),\n-        None,\n-        Some(Box::new(12)),\n-    ];\n+    let vec = vec![Some(Box::new(42)), Some(Box::new(24)), None, Some(Box::new(12))];\n     let iter = Iter(vec.into_iter());\n     assert_trusted_len(&iter);\n-    assert_eq!(\n-        &[Box::new(42), Box::new(24)],\n-        &*iter.collect::<Rc<[_]>>()\n-    );\n+    assert_eq!(&[Box::new(42), Box::new(24)], &*iter.collect::<Rc<[_]>>());\n }"}, {"sha": "a896a1064d9e17070bdef52f43e9cd0cc48dce1b", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -347,7 +347,7 @@ fn assert_covariance() {\n // Destructors must be called exactly once per element.\n // FIXME: re-enable emscripten once it can unwind again\n #[test]\n-#[cfg(not(any(miri, target_os = \"emscripten\")))] // Miri does not support catching panics\n+#[cfg(not(target_os = \"emscripten\"))]\n fn panic_safe() {\n     use std::cmp;\n     use std::panic::{self, AssertUnwindSafe};\n@@ -376,7 +376,10 @@ fn panic_safe() {\n     }\n     let mut rng = thread_rng();\n     const DATASZ: usize = 32;\n+    #[cfg(not(miri))] // Miri is too slow\n     const NTEST: usize = 10;\n+    #[cfg(miri)]\n+    const NTEST: usize = 1;\n \n     // don't use 0 in the data -- we want to catch the zeroed-out case.\n     let data = (1..=DATASZ).collect::<Vec<_>>();"}, {"sha": "66782ecbeb7f6deaa686e98206be3758f03fdd28", "filename": "src/liballoc/tests/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fboxed.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,5 +1,5 @@\n-use std::ptr::NonNull;\n use std::mem::MaybeUninit;\n+use std::ptr::NonNull;\n \n #[test]\n fn unitialized_zero_size_box() {"}, {"sha": "1d08ae13e054011cd3e9f9285539fb15dfc34675", "filename": "src/liballoc/tests/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -11,12 +11,7 @@ struct DeterministicRng {\n \n impl DeterministicRng {\n     fn new() -> Self {\n-        DeterministicRng {\n-            x: 0x193a6754,\n-            y: 0xa8a7d469,\n-            z: 0x97830e05,\n-            w: 0x113ba7bb,\n-        }\n+        DeterministicRng { x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n     }\n \n     fn next(&mut self) -> u32 {"}, {"sha": "daa49c48c6a92461532c3dfe97ca08b8f0536976", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 30, "deletions": 45, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -102,7 +102,6 @@ fn test_split_off() {\n         assert_eq!(m.back(), Some(&1));\n         assert_eq!(m.front(), Some(&1));\n     }\n-\n }\n \n #[test]\n@@ -305,8 +304,7 @@ fn test_show() {\n     assert_eq!(format!(\"{:?}\", list), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n     let list: LinkedList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n-    assert_eq!(format!(\"{:?}\", list),\n-               \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+    assert_eq!(format!(\"{:?}\", list), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n }\n \n #[test]\n@@ -446,19 +444,14 @@ fn drain_filter_true() {\n \n #[test]\n fn drain_filter_complex() {\n-\n-    {   //                [+xxx++++++xxxxx++++x+x++]\n+    {\n+        //                [+xxx++++++xxxxx++++x+x++]\n         let mut list = vec![\n-            1,\n-            2, 4, 6,\n-            7, 9, 11, 13, 15, 17,\n-            18, 20, 22, 24, 26,\n-            27, 29, 31, 33,\n-            34,\n-            35,\n-            36,\n-            37, 39\n-        ].into_iter().collect::<LinkedList<_>>();\n+            1, 2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37,\n+            39,\n+        ]\n+        .into_iter()\n+        .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -471,17 +464,13 @@ fn drain_filter_complex() {\n         );\n     }\n \n-    {   // [xxx++++++xxxxx++++x+x++]\n+    {\n+        // [xxx++++++xxxxx++++x+x++]\n         let mut list = vec![\n-            2, 4, 6,\n-            7, 9, 11, 13, 15, 17,\n-            18, 20, 22, 24, 26,\n-            27, 29, 31, 33,\n-            34,\n-            35,\n-            36,\n-            37, 39\n-        ].into_iter().collect::<LinkedList<_>>();\n+            2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37, 39,\n+        ]\n+        .into_iter()\n+        .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -494,16 +483,12 @@ fn drain_filter_complex() {\n         );\n     }\n \n-    {   // [xxx++++++xxxxx++++x+x]\n-        let mut list = vec![\n-            2, 4, 6,\n-            7, 9, 11, 13, 15, 17,\n-            18, 20, 22, 24, 26,\n-            27, 29, 31, 33,\n-            34,\n-            35,\n-            36\n-        ].into_iter().collect::<LinkedList<_>>();\n+    {\n+        // [xxx++++++xxxxx++++x+x]\n+        let mut list =\n+            vec![2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36]\n+                .into_iter()\n+                .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -516,11 +501,11 @@ fn drain_filter_complex() {\n         );\n     }\n \n-    {   // [xxxxxxxxxx+++++++++++]\n-        let mut list = vec![\n-            2, 4, 6, 8, 10, 12, 14, 16, 18, 20,\n-            1, 3, 5, 7, 9, 11, 13, 15, 17, 19\n-        ].into_iter().collect::<LinkedList<_>>();\n+    {\n+        // [xxxxxxxxxx+++++++++++]\n+        let mut list = vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n+            .into_iter()\n+            .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -530,11 +515,11 @@ fn drain_filter_complex() {\n         assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n     }\n \n-    {   // [+++++++++++xxxxxxxxxx]\n-        let mut list = vec![\n-            1, 3, 5, 7, 9, 11, 13, 15, 17, 19,\n-            2, 4, 6, 8, 10, 12, 14, 16, 18, 20\n-        ].into_iter().collect::<LinkedList<_>>();\n+    {\n+        // [+++++++++++xxxxxxxxxx]\n+        let mut list = vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n+            .into_iter()\n+            .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);"}, {"sha": "e77c57d9a5a09ef38b6721587799b0191b51d71f", "filename": "src/liballoc/tests/rc.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,9 +1,9 @@\n use std::any::Any;\n-use std::rc::{Rc, Weak};\n use std::cell::RefCell;\n use std::cmp::PartialEq;\n-use std::mem;\n use std::iter::TrustedLen;\n+use std::mem;\n+use std::rc::{Rc, Weak};\n \n #[test]\n fn uninhabited() {\n@@ -12,16 +12,16 @@ fn uninhabited() {\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n \n-    let mut a: Weak<dyn Any> = a;  // Unsizing\n+    let mut a: Weak<dyn Any> = a; // Unsizing\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n }\n \n #[test]\n fn slice() {\n     let a: Rc<[u32; 3]> = Rc::new([3, 2, 1]);\n-    let a: Rc<[u32]> = a;  // Unsizing\n-    let b: Rc<[u32]> = Rc::from(&[3, 2, 1][..]);  // Conversion\n+    let a: Rc<[u32]> = a; // Unsizing\n+    let b: Rc<[u32]> = Rc::from(&[3, 2, 1][..]); // Conversion\n     assert_eq!(a, b);\n \n     // Exercise is_dangling() with a DST\n@@ -33,7 +33,7 @@ fn slice() {\n #[test]\n fn trait_object() {\n     let a: Rc<u32> = Rc::new(4);\n-    let a: Rc<dyn Any> = a;  // Unsizing\n+    let a: Rc<dyn Any> = a; // Unsizing\n \n     // Exercise is_dangling() with a DST\n     let mut a = Rc::downgrade(&a);\n@@ -43,7 +43,7 @@ fn trait_object() {\n     let mut b = Weak::<u32>::new();\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n-    let mut b: Weak<dyn Any> = b;  // Unsizing\n+    let mut b: Weak<dyn Any> = b; // Unsizing\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n }\n@@ -57,7 +57,7 @@ fn float_nan_ne() {\n \n #[test]\n fn partial_eq() {\n-    struct TestPEq (RefCell<usize>);\n+    struct TestPEq(RefCell<usize>);\n     impl PartialEq for TestPEq {\n         fn eq(&self, other: &TestPEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -74,7 +74,7 @@ fn partial_eq() {\n #[test]\n fn eq() {\n     #[derive(Eq)]\n-    struct TestEq (RefCell<usize>);\n+    struct TestEq(RefCell<usize>);\n     impl PartialEq for TestEq {\n         fn eq(&self, other: &TestEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -156,13 +156,10 @@ fn shared_from_iter_trustedlen_normal() {\n fn shared_from_iter_trustedlen_panic() {\n     // Exercise the `TrustedLen` implementation when `size_hint()` matches\n     // `(_, Some(exact_len))` but where `.next()` drops before the last iteration.\n-    let iter = (0..SHARED_ITER_MAX)\n-        .map(|val| {\n-            match val {\n-                98 => panic!(\"I've almost got 99 problems.\"),\n-                _ => Box::new(val),\n-            }\n-        });\n+    let iter = (0..SHARED_ITER_MAX).map(|val| match val {\n+        98 => panic!(\"I've almost got 99 problems.\"),\n+        _ => Box::new(val),\n+    });\n     assert_trusted_len(&iter);\n     let _ = iter.collect::<Rc<[_]>>();\n \n@@ -189,16 +186,8 @@ fn shared_from_iter_trustedlen_no_fuse() {\n         }\n     }\n \n-    let vec = vec![\n-        Some(Box::new(42)),\n-        Some(Box::new(24)),\n-        None,\n-        Some(Box::new(12)),\n-    ];\n+    let vec = vec![Some(Box::new(42)), Some(Box::new(24)), None, Some(Box::new(12))];\n     let iter = Iter(vec.into_iter());\n     assert_trusted_len(&iter);\n-    assert_eq!(\n-        &[Box::new(42), Box::new(24)],\n-        &*iter.collect::<Rc<[_]>>()\n-    );\n+    assert_eq!(&[Box::new(42), Box::new(24)], &*iter.collect::<Rc<[_]>>());\n }"}, {"sha": "d9707b95740785bc4600d0973da1c2f6b5f093a9", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -4,7 +4,6 @@ use std::mem;\n use std::panic;\n use std::rc::Rc;\n use std::sync::atomic::{Ordering::Relaxed, AtomicUsize};\n-use std::thread;\n \n use rand::{Rng, RngCore, thread_rng};\n use rand::seq::SliceRandom;\n@@ -1406,11 +1405,9 @@ fn test_box_slice_clone() {\n #[test]\n #[allow(unused_must_use)] // here, we care about the side effects of `.clone()`\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg(not(miri))] // Miri does not support threads\n fn test_box_slice_clone_panics() {\n     use std::sync::Arc;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n-    use std::thread::spawn;\n \n     struct Canary {\n         count: Arc<AtomicUsize>,\n@@ -1446,15 +1443,14 @@ fn test_box_slice_clone_panics() {\n         panics: true,\n     };\n \n-    spawn(move || {\n+    std::panic::catch_unwind(move || {\n             // When xs is dropped, +5.\n             let xs = vec![canary.clone(), canary.clone(), canary.clone(), panic, canary]\n                 .into_boxed_slice();\n \n             // When panic is cloned, +3.\n             xs.clone();\n         })\n-        .join()\n         .unwrap_err();\n \n     // Total = 8\n@@ -1566,7 +1562,7 @@ macro_rules! test {\n             }\n \n             let v = $input.to_owned();\n-            let _ = thread::spawn(move || {\n+            let _ = std::panic::catch_unwind(move || {\n                 let mut v = v;\n                 let mut panic_countdown = panic_countdown;\n                 v.$func(|a, b| {\n@@ -1577,7 +1573,7 @@ macro_rules! test {\n                     panic_countdown -= 1;\n                     a.cmp(b)\n                 })\n-            }).join();\n+            });\n \n             // Check that the number of things dropped is exactly\n             // what we expect (i.e., the contents of `v`).\n@@ -1598,7 +1594,6 @@ thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n-#[cfg(not(miri))] // Miri does not support threads\n fn panic_safe() {\n     let prev = panic::take_hook();\n     panic::set_hook(Box::new(move |info| {\n@@ -1609,8 +1604,18 @@ fn panic_safe() {\n \n     let mut rng = thread_rng();\n \n-    for len in (1..20).chain(70..MAX_LEN) {\n-        for &modulus in &[5, 20, 50] {\n+    #[cfg(not(miri))] // Miri is too slow\n+    let lens = (1..20).chain(70..MAX_LEN);\n+    #[cfg(not(miri))] // Miri is too slow\n+    let moduli = &[5, 20, 50];\n+\n+    #[cfg(miri)]\n+    let lens = (1..13);\n+    #[cfg(miri)]\n+    let moduli = &[10];\n+\n+    for len in lens {\n+        for &modulus in moduli {\n             for &has_runs in &[false, true] {\n                 let mut input = (0..len)\n                     .map(|id| {\n@@ -1643,6 +1648,9 @@ fn panic_safe() {\n             }\n         }\n     }\n+\n+    // Set default panic hook again.\n+    drop(panic::take_hook());\n }\n \n #[test]"}, {"sha": "9ee254f99acdfa34611443c5fee088580fa79f66", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -944,10 +944,9 @@ fn drain_filter_complex() {\n     }\n }\n \n-// Miri does not support catching panics\n // FIXME: re-enable emscripten once it can unwind again\n #[test]\n-#[cfg(not(any(miri, target_os = \"emscripten\")))]\n+#[cfg(not(target_os = \"emscripten\"))]\n fn drain_filter_consumed_panic() {\n     use std::rc::Rc;\n     use std::sync::Mutex;\n@@ -985,7 +984,7 @@ fn drain_filter_consumed_panic() {\n         };\n         let drain = data.drain_filter(filter);\n \n-        // NOTE: The DrainFilter is explictly consumed\n+        // NOTE: The DrainFilter is explicitly consumed\n         drain.for_each(drop);\n     });\n \n@@ -999,7 +998,7 @@ fn drain_filter_consumed_panic() {\n \n // FIXME: Re-enable emscripten once it can catch panics\n #[test]\n-#[cfg(not(any(miri, target_os = \"emscripten\")))] // Miri does not support catching panics\n+#[cfg(not(target_os = \"emscripten\"))]\n fn drain_filter_unconsumed_panic() {\n     use std::rc::Rc;\n     use std::sync::Mutex;"}, {"sha": "5a0162a536175295cb89b0e9897afc6efe88395e", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,8 +1,8 @@\n-use std::fmt::Debug;\n-use std::collections::{VecDeque, vec_deque::Drain};\n use std::collections::TryReserveError::*;\n+use std::collections::{vec_deque::Drain, VecDeque};\n+use std::fmt::Debug;\n use std::mem::size_of;\n-use std::{usize, isize};\n+use std::{isize, usize};\n \n use crate::hash;\n \n@@ -148,34 +148,20 @@ fn test_param_taggy() {\n \n #[test]\n fn test_param_taggypar() {\n-    test_parameterized::<Taggypar<i32>>(Onepar::<i32>(1),\n-                                        Twopar::<i32>(1, 2),\n-                                        Threepar::<i32>(1, 2, 3),\n-                                        Twopar::<i32>(17, 42));\n+    test_parameterized::<Taggypar<i32>>(\n+        Onepar::<i32>(1),\n+        Twopar::<i32>(1, 2),\n+        Threepar::<i32>(1, 2, 3),\n+        Twopar::<i32>(17, 42),\n+    );\n }\n \n #[test]\n fn test_param_reccy() {\n-    let reccy1 = RecCy {\n-        x: 1,\n-        y: 2,\n-        t: One(1),\n-    };\n-    let reccy2 = RecCy {\n-        x: 345,\n-        y: 2,\n-        t: Two(1, 2),\n-    };\n-    let reccy3 = RecCy {\n-        x: 1,\n-        y: 777,\n-        t: Three(1, 2, 3),\n-    };\n-    let reccy4 = RecCy {\n-        x: 19,\n-        y: 252,\n-        t: Two(17, 42),\n-    };\n+    let reccy1 = RecCy { x: 1, y: 2, t: One(1) };\n+    let reccy2 = RecCy { x: 345, y: 2, t: Two(1, 2) };\n+    let reccy3 = RecCy { x: 1, y: 777, t: Three(1, 2, 3) };\n+    let reccy4 = RecCy { x: 19, y: 252, t: Two(17, 42) };\n     test_parameterized::<RecCy>(reccy1, reccy2, reccy3, reccy4);\n }\n \n@@ -320,8 +306,7 @@ fn test_mut_rev_iter_wrap() {\n     assert_eq!(d.pop_front(), Some(1));\n     d.push_back(4);\n \n-    assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<_>>(),\n-               vec![4, 3, 2]);\n+    assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<_>>(), vec![4, 3, 2]);\n }\n \n #[test]\n@@ -372,7 +357,6 @@ fn test_mut_rev_iter() {\n \n #[test]\n fn test_into_iter() {\n-\n     // Empty iter\n     {\n         let d: VecDeque<i32> = VecDeque::new();\n@@ -431,7 +415,6 @@ fn test_into_iter() {\n \n #[test]\n fn test_drain() {\n-\n     // Empty iter\n     {\n         let mut d: VecDeque<i32> = VecDeque::new();\n@@ -650,12 +633,8 @@ fn test_show() {\n     let ringbuf: VecDeque<_> = (0..10).collect();\n     assert_eq!(format!(\"{:?}\", ringbuf), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-    let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"]\n-        .iter()\n-        .cloned()\n-        .collect();\n-    assert_eq!(format!(\"{:?}\", ringbuf),\n-               \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+    let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n+    assert_eq!(format!(\"{:?}\", ringbuf), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n }\n \n #[test]\n@@ -955,7 +934,6 @@ fn test_append_permutations() {\n             // doesn't pop more values than are pushed\n             for src_pop_back in 0..(src_push_back + src_push_front) {\n                 for src_pop_front in 0..(src_push_back + src_push_front - src_pop_back) {\n-\n                     let src = construct_vec_deque(\n                         src_push_back,\n                         src_pop_back,\n@@ -966,8 +944,8 @@ fn test_append_permutations() {\n                     for dst_push_back in 0..MAX {\n                         for dst_push_front in 0..MAX {\n                             for dst_pop_back in 0..(dst_push_back + dst_push_front) {\n-                                for dst_pop_front\n-                                    in 0..(dst_push_back + dst_push_front - dst_pop_back)\n+                                for dst_pop_front in\n+                                    0..(dst_push_back + dst_push_front - dst_pop_back)\n                                 {\n                                     let mut dst = construct_vec_deque(\n                                         dst_push_back,\n@@ -1124,7 +1102,6 @@ fn test_reserve_exact_2() {\n #[test]\n #[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve() {\n-\n     // These are the interesting cases:\n     // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n     // * > isize::MAX should always fail\n@@ -1158,22 +1135,27 @@ fn test_try_reserve() {\n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n+            }\n \n             // Check usize::MAX does count as overflow\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an overflow!\")\n+            }\n         } else {\n             // Check isize::MAX is an OOM\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n             if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n     }\n \n-\n     {\n         // Same basic idea, but with non-zero len\n         let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n@@ -1186,47 +1168,54 @@ fn test_try_reserve() {\n         }\n         if guards_against_isize {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n             if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         // Should always overflow in the add-to-len\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n \n-\n     {\n         // Same basic idea, but with interesting type size\n         let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         // Should fail in the mul-by-size\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\");\n         }\n     }\n-\n }\n \n #[test]\n #[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n-\n     // This is exactly the same as test_try_reserve with the method changed.\n     // See that test for comments.\n \n@@ -1247,21 +1236,26 @@ fn test_try_reserve_exact() {\n \n         if guards_against_isize {\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n+            }\n \n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an overflow!\")\n+            }\n         } else {\n             // Check isize::MAX is an OOM\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n             if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n     }\n \n-\n     {\n         let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n@@ -1273,36 +1267,46 @@ fn test_try_reserve_exact() {\n         }\n         if guards_against_isize {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n             if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n \n-\n     {\n         let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n-\n }\n \n #[test]\n@@ -1404,9 +1408,8 @@ fn test_rotate_right_parts() {\n #[test]\n fn test_rotate_left_random() {\n     let shifts = [\n-        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1,\n-        4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11,\n-        9, 4, 12, 3, 12, 9, 11, 1, 7, 9, 7, 2,\n+        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1, 4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11, 9, 4, 12, 3,\n+        12, 9, 11, 1, 7, 9, 7, 2,\n     ];\n     let n = 12;\n     let mut v: VecDeque<_> = (0..n).collect();\n@@ -1423,9 +1426,8 @@ fn test_rotate_left_random() {\n #[test]\n fn test_rotate_right_random() {\n     let shifts = [\n-        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1,\n-        4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11,\n-        9, 4, 12, 3, 12, 9, 11, 1, 7, 9, 7, 2,\n+        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1, 4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11, 9, 4, 12, 3,\n+        12, 9, 11, 1, 7, 9, 7, 2,\n     ];\n     let n = 12;\n     let mut v: VecDeque<_> = (0..n).collect();\n@@ -1447,8 +1449,7 @@ fn test_try_fold_empty() {\n #[test]\n fn test_try_fold_none() {\n     let v: VecDeque<u32> = (0..12).collect();\n-    assert_eq!(None, v.into_iter().try_fold(0, |a, b|\n-        if b < 11 { Some(a + b) } else { None }));\n+    assert_eq!(None, v.into_iter().try_fold(0, |a, b| if b < 11 { Some(a + b) } else { None }));\n }\n \n #[test]\n@@ -1463,7 +1464,6 @@ fn test_try_fold_unit() {\n     assert_eq!(Some(()), v.into_iter().try_fold((), |(), ()| Some(())));\n }\n \n-\n #[test]\n fn test_try_fold_unit_none() {\n     let v: std::collections::VecDeque<()> = [(); 10].iter().cloned().collect();\n@@ -1534,7 +1534,7 @@ fn test_try_rfold_rotated() {\n \n #[test]\n fn test_try_rfold_moves_iter() {\n-    let v : VecDeque<_> = [10, 20, 30, 40, 100, 60, 70, 80, 90].iter().collect();\n+    let v: VecDeque<_> = [10, 20, 30, 40, 100, 60, 70, 80, 90].iter().collect();\n     let mut iter = v.into_iter();\n     assert_eq!(iter.try_rfold(0_i8, |acc, &x| acc.checked_add(x)), None);\n     assert_eq!(iter.next_back(), Some(&70));"}, {"sha": "1a700b990569c39ac854f72150200a3131e64463", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -629,6 +629,8 @@ impl<T> Vec<T> {\n     /// The capacity will remain at least as large as both the length\n     /// and the supplied value.\n     ///\n+    /// # Panics\n+    ///\n     /// Panics if the current capacity is smaller than the supplied\n     /// minimum capacity.\n     ///\n@@ -2701,6 +2703,9 @@ impl<T> ExactSizeIterator for Drain<'_, T> {\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for Drain<'_, T> {}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Drain<'_, T> {}\n \n@@ -2837,7 +2842,7 @@ pub struct DrainFilter<'a, T, F>\n     old_len: usize,\n     /// The filter test predicate.\n     pred: F,\n-    /// A flag that indicates a panic has occured in the filter test prodicate.\n+    /// A flag that indicates a panic has occurred in the filter test prodicate.\n     /// This is used as a hint in the drop implmentation to prevent consumption\n     /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n     /// backshifted in the `vec`, but no further items will be dropped or"}, {"sha": "20248f7f6c13e374e471f423a37b48ef14556f24", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -53,7 +53,7 @@ pub struct Layout {\n \n impl Layout {\n     /// Constructs a `Layout` from a given `size` and `align`,\n-    /// or returns `LayoutErr` if either of the following conditions\n+    /// or returns `LayoutErr` if any of the following conditions\n     /// are not met:\n     ///\n     /// * `align` must not be zero,\n@@ -137,7 +137,7 @@ impl Layout {\n     #[inline]\n     pub fn for_value<T: ?Sized>(t: &T) -> Self {\n         let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n-        // See rationale in `new` for why this us using an unsafe variant below\n+        // See rationale in `new` for why this is using an unsafe variant below\n         debug_assert!(Layout::from_size_align(size, align).is_ok());\n         unsafe {\n             Layout::from_size_align_unchecked(size, align)\n@@ -196,7 +196,7 @@ impl Layout {\n         //    valid.\n         //\n         // 2. `len + align - 1` can overflow by at most `align - 1`,\n-        //    so the &-mask wth `!(align - 1)` will ensure that in the\n+        //    so the &-mask with `!(align - 1)` will ensure that in the\n         //    case of overflow, `len_rounded_up` will itself be 0.\n         //    Thus the returned padding, when added to `len`, yields 0,\n         //    which trivially satisfies the alignment `align`.\n@@ -213,18 +213,19 @@ impl Layout {\n     /// Creates a layout by rounding the size of this layout up to a multiple\n     /// of the layout's alignment.\n     ///\n-    /// Returns `Err` if the padded size would overflow.\n-    ///\n     /// This is equivalent to adding the result of `padding_needed_for`\n     /// to the layout's current size.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n     #[inline]\n-    pub fn pad_to_align(&self) -> Result<Layout, LayoutErr> {\n+    pub fn pad_to_align(&self) -> Layout {\n         let pad = self.padding_needed_for(self.align());\n-        let new_size = self.size().checked_add(pad)\n-            .ok_or(LayoutErr { private: () })?;\n+        // This cannot overflow. Quoting from the invariant of Layout:\n+        // > `size`, when rounded up to the nearest multiple of `align`,\n+        // > must not overflow (i.e., the rounded value must be less than\n+        // > `usize::MAX`)\n+        let new_size = self.size() + pad;\n \n-        Layout::from_size_align(new_size, self.align())\n+        Layout::from_size_align(new_size, self.align()).unwrap()\n     }\n \n     /// Creates a layout describing the record for `n` instances of"}, {"sha": "466750fc7d2c63035f6f4cc46cba596ccf5827fe", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -68,7 +68,7 @@ use crate::intrinsics;\n // Any trait\n ///////////////////////////////////////////////////////////////////////////////\n \n-/// A type to emulate dynamic typing.\n+/// A trait to emulate dynamic typing.\n ///\n /// Most types implement `Any`. However, any type which contains a non-`'static` reference does not.\n /// See the [module-level documentation][mod] for more details."}, {"sha": "38d248d701d4a96138aec8877b50ead1bd5fd792", "filename": "src/libcore/array/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,5 +1,5 @@\n //! Implementations of things like `Eq` for fixed-length arrays\n-//! up to a certain length. Eventually we should able to generalize\n+//! up to a certain length. Eventually, we should be able to generalize\n //! to all lengths.\n //!\n //! *[See also the array primitive type](../../std/primitive.array.html).*"}, {"sha": "e78dfd1ed4abfca43a6b2d1d304b78ff505790ca", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -12,8 +12,8 @@\n #![stable(feature = \"core_ascii\", since = \"1.26.0\")]\n \n use crate::fmt;\n-use crate::ops::Range;\n use crate::iter::FusedIterator;\n+use crate::ops::Range;\n use crate::str::from_utf8_unchecked;\n \n /// An iterator over the escaped version of a byte.\n@@ -100,15 +100,15 @@ pub fn escape_default(c: u8) -> EscapeDefault {\n         b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n         b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n         b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n-        b'\\x20' ..= b'\\x7e' => ([c, 0, 0, 0], 1),\n+        b'\\x20'..=b'\\x7e' => ([c, 0, 0, 0], 1),\n         _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n     };\n \n     return EscapeDefault { range: 0..len, data };\n \n     fn hexify(b: u8) -> u8 {\n         match b {\n-            0 ..= 9 => b'0' + b,\n+            0..=9 => b'0' + b,\n             _ => b'a' + b - 10,\n         }\n     }\n@@ -117,9 +117,15 @@ pub fn escape_default(c: u8) -> EscapeDefault {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for EscapeDefault {\n     type Item = u8;\n-    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n-    fn last(mut self) -> Option<u8> { self.next_back() }\n+    fn next(&mut self) -> Option<u8> {\n+        self.range.next().map(|i| self.data[i])\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.range.size_hint()\n+    }\n+    fn last(mut self) -> Option<u8> {\n+        self.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl DoubleEndedIterator for EscapeDefault {"}, {"sha": "1b3c254a05f98126a3ff6b0a47ed1b407dba3671", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -9,12 +9,12 @@ impl bool {\n     /// ```\n     /// #![feature(bool_to_option)]\n     ///\n-    /// assert_eq!(false.then(0), None);\n-    /// assert_eq!(true.then(0), Some(0));\n+    /// assert_eq!(false.then_some(0), None);\n+    /// assert_eq!(true.then_some(0), Some(0));\n     /// ```\n     #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n     #[inline]\n-    pub fn then<T>(self, t: T) -> Option<T> {\n+    pub fn then_some<T>(self, t: T) -> Option<T> {\n         if self {\n             Some(t)\n         } else {\n@@ -29,12 +29,12 @@ impl bool {\n     /// ```\n     /// #![feature(bool_to_option)]\n     ///\n-    /// assert_eq!(false.then_with(|| 0), None);\n-    /// assert_eq!(true.then_with(|| 0), Some(0));\n+    /// assert_eq!(false.then(|| 0), None);\n+    /// assert_eq!(true.then(|| 0), Some(0));\n     /// ```\n     #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n     #[inline]\n-    pub fn then_with<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {\n+    pub fn then<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {\n         if self {\n             Some(f())\n         } else {"}, {"sha": "dd21c72e745dd70498f59caf1220b999ff4be538", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -158,7 +158,6 @@ impl From<u8> for char {\n     }\n }\n \n-\n /// An error which can be returned when parsing a char.\n #[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -167,16 +166,16 @@ pub struct ParseCharError {\n }\n \n impl ParseCharError {\n-    #[unstable(feature = \"char_error_internals\",\n-               reason = \"this method should not be available publicly\",\n-               issue = \"0\")]\n+    #[unstable(\n+        feature = \"char_error_internals\",\n+        reason = \"this method should not be available publicly\",\n+        issue = \"0\"\n+    )]\n     #[doc(hidden)]\n     pub fn __description(&self) -> &str {\n         match self.kind {\n-            CharErrorKind::EmptyString => {\n-                \"cannot parse char from empty string\"\n-            },\n-            CharErrorKind::TooManyChars => \"too many characters in string\"\n+            CharErrorKind::EmptyString => \"cannot parse char from empty string\",\n+            CharErrorKind::TooManyChars => \"too many characters in string\",\n         }\n     }\n }\n@@ -194,7 +193,6 @@ impl fmt::Display for ParseCharError {\n     }\n }\n \n-\n #[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n impl FromStr for char {\n     type Err = ParseCharError;\n@@ -203,18 +201,13 @@ impl FromStr for char {\n     fn from_str(s: &str) -> Result<Self, Self::Err> {\n         let mut chars = s.chars();\n         match (chars.next(), chars.next()) {\n-            (None, _) => {\n-                Err(ParseCharError { kind: CharErrorKind::EmptyString })\n-            },\n+            (None, _) => Err(ParseCharError { kind: CharErrorKind::EmptyString }),\n             (Some(c), None) => Ok(c),\n-            _ => {\n-                Err(ParseCharError { kind: CharErrorKind::TooManyChars })\n-            }\n+            _ => Err(ParseCharError { kind: CharErrorKind::TooManyChars }),\n         }\n     }\n }\n \n-\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl TryFrom<u32> for char {\n     type Error = CharTryFromError;\n@@ -304,11 +297,7 @@ pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n     }\n     if num < radix {\n         let num = num as u8;\n-        if num < 10 {\n-            Some((b'0' + num) as char)\n-        } else {\n-            Some((b'a' + num - 10) as char)\n-        }\n+        if num < 10 { Some((b'0' + num) as char) } else { Some((b'a' + num - 10) as char) }\n     } else {\n         None\n     }"}, {"sha": "5e7784730e3c9c56141712d816641ac68690c0bc", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -8,7 +8,8 @@ use super::from_u32_unchecked;\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n #[derive(Clone, Debug)]\n pub struct DecodeUtf16<I>\n-    where I: Iterator<Item = u16>\n+where\n+    I: Iterator<Item = u16>,\n {\n     iter: I,\n     buf: Option<u16>,\n@@ -70,10 +71,7 @@ pub struct DecodeUtf16Error {\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n #[inline]\n pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n-    DecodeUtf16 {\n-        iter: iter.into_iter(),\n-        buf: None,\n-    }\n+    DecodeUtf16 { iter: iter.into_iter(), buf: None }\n }\n \n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n@@ -83,7 +81,7 @@ impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n     fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n         let u = match self.buf.take() {\n             Some(buf) => buf,\n-            None => self.iter.next()?\n+            None => self.iter.next()?,\n         };\n \n         if u < 0xD800 || 0xDFFF < u {"}, {"sha": "1ec614edbe2ebdd1d67728e2e613fcda3f946489", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -130,11 +130,7 @@ impl char {\n             }\n         };\n \n-        if val < radix {\n-            Some(val)\n-        } else {\n-            None\n-        }\n+        if val < radix { Some(val) } else { None }\n     }\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a\n@@ -950,11 +946,7 @@ impl char {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> char {\n-        if self.is_ascii() {\n-            (*self as u8).to_ascii_uppercase() as char\n-        } else {\n-            *self\n-        }\n+        if self.is_ascii() { (*self as u8).to_ascii_uppercase() as char } else { *self }\n     }\n \n     /// Makes a copy of the value in its ASCII lower case equivalent.\n@@ -982,11 +974,7 @@ impl char {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> char {\n-        if self.is_ascii() {\n-            (*self as u8).to_ascii_lowercase() as char\n-        } else {\n-            *self\n-        }\n+        if self.is_ascii() { (*self as u8).to_ascii_lowercase() as char } else { *self }\n     }\n \n     /// Checks that two values are an ASCII case-insensitive match."}, {"sha": "a655ee6e7e32ae542c353662dadeea32a4194930", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -24,14 +24,14 @@ mod decode;\n mod methods;\n \n // stable re-exports\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::convert::{from_u32, from_digit};\n #[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n pub use self::convert::from_u32_unchecked;\n-#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n-pub use self::convert::ParseCharError;\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub use self::convert::CharTryFromError;\n+#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n+pub use self::convert::ParseCharError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::convert::{from_digit, from_u32};\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n \n@@ -45,13 +45,13 @@ use crate::fmt::{self, Write};\n use crate::iter::FusedIterator;\n \n // UTF-8 ranges and tags for encoding characters\n-const TAG_CONT: u8     = 0b1000_0000;\n-const TAG_TWO_B: u8    = 0b1100_0000;\n-const TAG_THREE_B: u8  = 0b1110_0000;\n-const TAG_FOUR_B: u8   = 0b1111_0000;\n-const MAX_ONE_B: u32   =     0x80;\n-const MAX_TWO_B: u32   =    0x800;\n-const MAX_THREE_B: u32 =  0x10000;\n+const TAG_CONT: u8 = 0b1000_0000;\n+const TAG_TWO_B: u8 = 0b1100_0000;\n+const TAG_THREE_B: u8 = 0b1110_0000;\n+const TAG_FOUR_B: u8 = 0b1111_0000;\n+const MAX_ONE_B: u32 = 0x80;\n+const MAX_TWO_B: u32 = 0x800;\n+const MAX_THREE_B: u32 = 0x10000;\n \n /*\n     Lu  Uppercase_Letter        an uppercase letter\n@@ -190,11 +190,11 @@ impl Iterator for EscapeUnicode {\n         match self.state {\n             EscapeUnicodeState::Done => None,\n \n-            EscapeUnicodeState::RightBrace |\n-            EscapeUnicodeState::Value |\n-            EscapeUnicodeState::LeftBrace |\n-            EscapeUnicodeState::Type |\n-            EscapeUnicodeState::Backslash => Some('}'),\n+            EscapeUnicodeState::RightBrace\n+            | EscapeUnicodeState::Value\n+            | EscapeUnicodeState::LeftBrace\n+            | EscapeUnicodeState::Type\n+            | EscapeUnicodeState::Backslash => Some('}'),\n         }\n     }\n }\n@@ -204,14 +204,15 @@ impl ExactSizeIterator for EscapeUnicode {\n     #[inline]\n     fn len(&self) -> usize {\n         // The match is a single memory access with no branching\n-        self.hex_digit_idx + match self.state {\n-            EscapeUnicodeState::Done => 0,\n-            EscapeUnicodeState::RightBrace => 1,\n-            EscapeUnicodeState::Value => 2,\n-            EscapeUnicodeState::LeftBrace => 3,\n-            EscapeUnicodeState::Type => 4,\n-            EscapeUnicodeState::Backslash => 5,\n-        }\n+        self.hex_digit_idx\n+            + match self.state {\n+                EscapeUnicodeState::Done => 0,\n+                EscapeUnicodeState::RightBrace => 1,\n+                EscapeUnicodeState::Value => 2,\n+                EscapeUnicodeState::LeftBrace => 3,\n+                EscapeUnicodeState::Type => 4,\n+                EscapeUnicodeState::Backslash => 5,\n+            }\n     }\n }\n \n@@ -238,7 +239,7 @@ impl fmt::Display for EscapeUnicode {\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeDefault {\n-    state: EscapeDefaultState\n+    state: EscapeDefaultState,\n }\n \n #[derive(Clone, Debug)]\n@@ -284,24 +285,20 @@ impl Iterator for EscapeDefault {\n             EscapeDefaultState::Backslash(c) if n == 0 => {\n                 self.state = EscapeDefaultState::Char(c);\n                 Some('\\\\')\n-            },\n+            }\n             EscapeDefaultState::Backslash(c) if n == 1 => {\n                 self.state = EscapeDefaultState::Done;\n                 Some(c)\n-            },\n+            }\n             EscapeDefaultState::Backslash(_) => {\n                 self.state = EscapeDefaultState::Done;\n                 None\n-            },\n+            }\n             EscapeDefaultState::Char(c) => {\n                 self.state = EscapeDefaultState::Done;\n \n-                if n == 0 {\n-                    Some(c)\n-                } else {\n-                    None\n-                }\n-            },\n+                if n == 0 { Some(c) } else { None }\n+            }\n             EscapeDefaultState::Done => None,\n             EscapeDefaultState::Unicode(ref mut i) => i.nth(n),\n         }\n@@ -355,12 +352,16 @@ pub struct EscapeDebug(EscapeDefault);\n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n impl Iterator for EscapeDebug {\n     type Item = char;\n-    fn next(&mut self) -> Option<char> { self.0.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n+    fn next(&mut self) -> Option<char> {\n+        self.0.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n }\n \n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n-impl ExactSizeIterator for EscapeDebug { }\n+impl ExactSizeIterator for EscapeDebug {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EscapeDebug {}\n@@ -440,7 +441,7 @@ impl CaseMappingIter {\n     fn new(chars: [char; 3]) -> CaseMappingIter {\n         if chars[2] == '\\0' {\n             if chars[1] == '\\0' {\n-                CaseMappingIter::One(chars[0])  // Including if chars[0] == '\\0'\n+                CaseMappingIter::One(chars[0]) // Including if chars[0] == '\\0'\n             } else {\n                 CaseMappingIter::Two(chars[0], chars[1])\n             }\n@@ -493,9 +494,7 @@ impl fmt::Display for CaseMappingIter {\n                 f.write_char(b)?;\n                 f.write_char(c)\n             }\n-            CaseMappingIter::One(c) => {\n-                f.write_char(c)\n-            }\n+            CaseMappingIter::One(c) => f.write_char(c),\n             CaseMappingIter::Zero => Ok(()),\n         }\n     }"}, {"sha": "6e7a46ba62aabf2c39f77e0103d5cd6a13650d56", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -107,7 +107,7 @@\n /// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"clone\"]\n-pub trait Clone : Sized {\n+pub trait Clone: Sized {\n     /// Returns a copy of the value.\n     ///\n     /// # Examples\n@@ -137,24 +137,34 @@ pub trait Clone : Sized {\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n-pub macro Clone($item:item) { /* compiler built-in */ }\n+pub macro Clone($item:item) {\n+    /* compiler built-in */\n+}\n \n // FIXME(aburka): these structs are used solely by #[derive] to\n // assert that every component of a type implements Clone or Copy.\n //\n // These structs should never appear in user code.\n #[doc(hidden)]\n #[allow(missing_debug_implementations)]\n-#[unstable(feature = \"derive_clone_copy\",\n-           reason = \"deriving hack, should not be public\",\n-           issue = \"0\")]\n-pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: crate::marker::PhantomData<T> }\n+#[unstable(\n+    feature = \"derive_clone_copy\",\n+    reason = \"deriving hack, should not be public\",\n+    issue = \"0\"\n+)]\n+pub struct AssertParamIsClone<T: Clone + ?Sized> {\n+    _field: crate::marker::PhantomData<T>,\n+}\n #[doc(hidden)]\n #[allow(missing_debug_implementations)]\n-#[unstable(feature = \"derive_clone_copy\",\n-           reason = \"deriving hack, should not be public\",\n-           issue = \"0\")]\n-pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: crate::marker::PhantomData<T> }\n+#[unstable(\n+    feature = \"derive_clone_copy\",\n+    reason = \"deriving hack, should not be public\",\n+    issue = \"0\"\n+)]\n+pub struct AssertParamIsCopy<T: Copy + ?Sized> {\n+    _field: crate::marker::PhantomData<T>,\n+}\n \n /// Implementations of `Clone` for primitive types.\n ///\n@@ -217,5 +227,4 @@ mod impls {\n             *self\n         }\n     }\n-\n }"}, {"sha": "a5f355cd9a73ec333c51d2deea214324f6bade77", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -464,9 +464,9 @@ impl<T: PartialOrd> PartialOrd for Reverse<T> {\n     #[inline]\n     fn le(&self, other: &Self) -> bool { other.0 <= self.0 }\n     #[inline]\n-    fn ge(&self, other: &Self) -> bool { other.0 >= self.0 }\n-    #[inline]\n     fn gt(&self, other: &Self) -> bool { other.0 > self.0 }\n+    #[inline]\n+    fn ge(&self, other: &Self) -> bool { other.0 >= self.0 }\n }\n \n #[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n@@ -534,7 +534,6 @@ impl<T: Ord> Ord for Reverse<T> {\n ///     }\n /// }\n /// ```\n-#[lang = \"ord\"]\n #[doc(alias = \"<\")]\n #[doc(alias = \">\")]\n #[doc(alias = \"<=\")]\n@@ -1176,9 +1175,9 @@ mod impls {\n         #[inline]\n         fn le(&self, other: & &B) -> bool { PartialOrd::le(*self, *other) }\n         #[inline]\n-        fn ge(&self, other: & &B) -> bool { PartialOrd::ge(*self, *other) }\n-        #[inline]\n         fn gt(&self, other: & &B) -> bool { PartialOrd::gt(*self, *other) }\n+        #[inline]\n+        fn ge(&self, other: & &B) -> bool { PartialOrd::ge(*self, *other) }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<A: ?Sized> Ord for &A where A: Ord {\n@@ -1208,9 +1207,9 @@ mod impls {\n         #[inline]\n         fn le(&self, other: &&mut B) -> bool { PartialOrd::le(*self, *other) }\n         #[inline]\n-        fn ge(&self, other: &&mut B) -> bool { PartialOrd::ge(*self, *other) }\n-        #[inline]\n         fn gt(&self, other: &&mut B) -> bool { PartialOrd::gt(*self, *other) }\n+        #[inline]\n+        fn ge(&self, other: &&mut B) -> bool { PartialOrd::ge(*self, *other) }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<A: ?Sized> Ord for &mut A where A: Ord {"}, {"sha": "5414d9ac2344ab25a287596a97ba973d5cf9c672", "filename": "src/libcore/convert/mod.rs", "status": "renamed", "additions": 40, "deletions": 17, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -40,6 +40,11 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+mod num;\n+\n+#[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+pub use num::FloatToInt;\n+\n /// The identity function.\n ///\n /// Two things are important to note about this function:\n@@ -95,7 +100,9 @@\n /// ```\n #[stable(feature = \"convert_id\", since = \"1.33.0\")]\n #[inline]\n-pub const fn identity<T>(x: T) -> T { x }\n+pub const fn identity<T>(x: T) -> T {\n+    x\n+}\n \n /// Used to do a cheap reference-to-reference conversion.\n ///\n@@ -364,12 +371,10 @@ pub trait Into<T>: Sized {\n /// [`from`]: trait.From.html#tymethod.from\n /// [book]: ../../book/ch09-00-error-handling.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(\n-    on(\n-        all(_Self=\"&str\", T=\"std::string::String\"),\n-        note=\"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\",\n-    )\n-)]\n+#[rustc_on_unimplemented(on(\n+    all(_Self = \"&str\", T = \"std::string::String\"),\n+    note = \"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\",\n+))]\n pub trait From<T>: Sized {\n     /// Performs the conversion.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -490,7 +495,9 @@ pub trait TryFrom<T>: Sized {\n \n // As lifts over &\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, U: ?Sized> AsRef<U> for &T where T: AsRef<U>\n+impl<T: ?Sized, U: ?Sized> AsRef<U> for &T\n+where\n+    T: AsRef<U>,\n {\n     fn as_ref(&self) -> &U {\n         <T as AsRef<U>>::as_ref(*self)\n@@ -499,7 +506,9 @@ impl<T: ?Sized, U: ?Sized> AsRef<U> for &T where T: AsRef<U>\n \n // As lifts over &mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T where T: AsRef<U>\n+impl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T\n+where\n+    T: AsRef<U>,\n {\n     fn as_ref(&self) -> &U {\n         <T as AsRef<U>>::as_ref(*self)\n@@ -516,7 +525,9 @@ impl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T where T: AsRef<U>\n \n // AsMut lifts over &mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T where T: AsMut<U>\n+impl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T\n+where\n+    T: AsMut<U>,\n {\n     fn as_mut(&mut self) -> &mut U {\n         (*self).as_mut()\n@@ -533,7 +544,9 @@ impl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T where T: AsMut<U>\n \n // From implies Into\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, U> Into<U> for T where U: From<T>\n+impl<T, U> Into<U> for T\n+where\n+    U: From<T>,\n {\n     fn into(self) -> U {\n         U::from(self)\n@@ -543,7 +556,9 @@ impl<T, U> Into<U> for T where U: From<T>\n // From (and thus Into) is reflexive\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> From<T> for T {\n-    fn from(t: T) -> T { t }\n+    fn from(t: T) -> T {\n+        t\n+    }\n }\n \n /// **Stability note:** This impl does not yet exist, but we are\n@@ -552,15 +567,20 @@ impl<T> From<T> for T {\n ///\n /// [#64715]: https://github.com/rust-lang/rust/issues/64715\n #[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-#[rustc_reservation_impl=\"permitting this impl would forbid us from adding \\\n-`impl<T> From<!> for T` later; see rust-lang/rust#64715 for details\"]\n+#[allow(unused_attributes)] // FIXME(#58633): do a principled fix instead.\n+#[rustc_reservation_impl = \"permitting this impl would forbid us from adding \\\n+                            `impl<T> From<!> for T` later; see rust-lang/rust#64715 for details\"]\n impl<T> From<!> for T {\n-    fn from(t: !) -> T { t }\n+    fn from(t: !) -> T {\n+        t\n+    }\n }\n \n // TryFrom implies TryInto\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-impl<T, U> TryInto<U> for T where U: TryFrom<T>\n+impl<T, U> TryInto<U> for T\n+where\n+    U: TryFrom<T>,\n {\n     type Error = U::Error;\n \n@@ -572,7 +592,10 @@ impl<T, U> TryInto<U> for T where U: TryFrom<T>\n // Infallible conversions are semantically equivalent to fallible conversions\n // with an uninhabited error type.\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-impl<T, U> TryFrom<U> for T where U: Into<T> {\n+impl<T, U> TryFrom<U> for T\n+where\n+    U: Into<T>,\n+{\n     type Error = Infallible;\n \n     fn try_from(value: U) -> Result<Self, Self::Error> {", "previous_filename": "src/libcore/convert.rs"}, {"sha": "0877dacb38dd2ee80662e021f02219274f9a7997", "filename": "src/libcore/convert/num.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -0,0 +1,369 @@\n+use super::{From, TryFrom};\n+use crate::num::TryFromIntError;\n+\n+mod private {\n+    /// This trait being unreachable from outside the crate\n+    /// prevents other implementations of the `FloatToInt` trait,\n+    /// which allows potentially adding more trait methods after the trait is `#[stable]`.\n+    #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+    pub trait Sealed {}\n+}\n+\n+/// Supporting trait for inherent methods of `f32` and `f64` such as `round_unchecked_to`.\n+/// Typically doesn\u2019t need to be used directly.\n+#[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+pub trait FloatToInt<Int>: private::Sealed + Sized {\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[doc(hidden)]\n+    unsafe fn approx_unchecked(self) -> Int;\n+}\n+\n+macro_rules! impl_float_to_int {\n+    ( $Float: ident => $( $Int: ident )+ ) => {\n+        #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+        impl private::Sealed for $Float {}\n+        $(\n+            #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+            impl FloatToInt<$Int> for $Float {\n+                #[cfg(not(bootstrap))]\n+                #[doc(hidden)]\n+                #[inline]\n+                unsafe fn approx_unchecked(self) -> $Int {\n+                    crate::intrinsics::float_to_int_approx_unchecked(self)\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+impl_float_to_int!(f32 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n+impl_float_to_int!(f64 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n+\n+// Conversion traits for primitive integer and float types\n+// Conversions T -> T are covered by a blanket impl and therefore excluded\n+// Some conversions from and to usize/isize are not implemented due to portability concerns\n+macro_rules! impl_from {\n+    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n+        #[$attr]\n+        #[doc = $doc]\n+        impl From<$Small> for $Large {\n+            #[inline]\n+            fn from(small: $Small) -> $Large {\n+                small as $Large\n+            }\n+        }\n+    };\n+    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n+        impl_from!($Small,\n+                   $Large,\n+                   #[$attr],\n+                   concat!(\"Converts `\",\n+                           stringify!($Small),\n+                           \"` to `\",\n+                           stringify!($Large),\n+                           \"` losslessly.\"));\n+    }\n+}\n+\n+macro_rules! impl_from_bool {\n+    ($target: ty, #[$attr:meta]) => {\n+        impl_from!(bool, $target, #[$attr], concat!(\"Converts a `bool` to a `\",\n+            stringify!($target), \"`. The resulting value is `0` for `false` and `1` for `true`\n+values.\n+\n+# Examples\n+\n+```\n+assert_eq!(\", stringify!($target), \"::from(true), 1);\n+assert_eq!(\", stringify!($target), \"::from(false), 0);\n+```\"));\n+    };\n+}\n+\n+// Bool -> Any\n+impl_from_bool! { u8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { usize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { isize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+\n+// Unsigned -> Unsigned\n+impl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// Signed -> Signed\n+impl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// Unsigned -> Signed\n+impl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n+// which imply that pointer-sized integers must be at least 16 bits:\n+// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\n+impl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+\n+// RISC-V defines the possibility of a 128-bit address space (RV128).\n+\n+// CHERI proposes 256-bit \u201ccapabilities\u201d. Unclear if this would be relevant to usize/isize.\n+// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n+// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n+\n+\n+// Note: integers can only be represented with full precision in a float if\n+// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n+// Lossy float conversions are not implemented at this time.\n+\n+// Signed -> Float\n+impl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// Unsigned -> Float\n+impl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// Float -> Float\n+impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// no possible bounds violation\n+macro_rules! try_from_unbounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(value: $source) -> Result<Self, Self::Error> {\n+                Ok(value as $target)\n+            }\n+        }\n+    )*}\n+}\n+\n+// only negative bounds\n+macro_rules! try_from_lower_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                if u >= 0 {\n+                    Ok(u as $target)\n+                } else {\n+                    Err(TryFromIntError(()))\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+// unsigned to signed (only positive bound)\n+macro_rules! try_from_upper_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                if u > (<$target>::max_value() as $source) {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+// all other cases\n+macro_rules! try_from_both_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                let min = <$target>::min_value() as $source;\n+                let max = <$target>::max_value() as $source;\n+                if u < min || u > max {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+macro_rules! rev {\n+    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n+        $mac!($target, $source);\n+    )*}\n+}\n+\n+// intra-sign conversions\n+try_from_upper_bounded!(u16, u8);\n+try_from_upper_bounded!(u32, u16, u8);\n+try_from_upper_bounded!(u64, u32, u16, u8);\n+try_from_upper_bounded!(u128, u64, u32, u16, u8);\n+\n+try_from_both_bounded!(i16, i8);\n+try_from_both_bounded!(i32, i16, i8);\n+try_from_both_bounded!(i64, i32, i16, i8);\n+try_from_both_bounded!(i128, i64, i32, i16, i8);\n+\n+// unsigned-to-signed\n+try_from_upper_bounded!(u8, i8);\n+try_from_upper_bounded!(u16, i8, i16);\n+try_from_upper_bounded!(u32, i8, i16, i32);\n+try_from_upper_bounded!(u64, i8, i16, i32, i64);\n+try_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n+\n+// signed-to-unsigned\n+try_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\n+try_from_lower_bounded!(i16, u16, u32, u64, u128);\n+try_from_lower_bounded!(i32, u32, u64, u128);\n+try_from_lower_bounded!(i64, u64, u128);\n+try_from_lower_bounded!(i128, u128);\n+try_from_both_bounded!(i16, u8);\n+try_from_both_bounded!(i32, u16, u8);\n+try_from_both_bounded!(i64, u32, u16, u8);\n+try_from_both_bounded!(i128, u64, u32, u16, u8);\n+\n+// usize/isize\n+try_from_upper_bounded!(usize, isize);\n+try_from_lower_bounded!(isize, usize);\n+\n+#[cfg(target_pointer_width = \"16\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8);\n+    try_from_unbounded!(usize, u16, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16);\n+    try_from_unbounded!(usize, i32, i64, i128);\n+\n+    try_from_both_bounded!(isize, u8);\n+    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n+    try_from_both_bounded!(isize, i8);\n+    try_from_unbounded!(isize, i16, i32, i64, i128);\n+\n+    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16);\n+    rev!(try_from_both_bounded, usize, i32, i64, i128);\n+\n+    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n+    rev!(try_from_both_bounded, isize, i32, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8, u16);\n+    try_from_unbounded!(usize, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32);\n+    try_from_unbounded!(usize, i64, i128);\n+\n+    try_from_both_bounded!(isize, u8, u16);\n+    try_from_lower_bounded!(isize, u32, u64, u128);\n+    try_from_both_bounded!(isize, i8, i16);\n+    try_from_unbounded!(isize, i32, i64, i128);\n+\n+    rev!(try_from_unbounded, usize, u32);\n+    rev!(try_from_upper_bounded, usize, u64, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n+    rev!(try_from_both_bounded, usize, i64, i128);\n+\n+    rev!(try_from_unbounded, isize, u16);\n+    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n+    rev!(try_from_unbounded, isize, i32);\n+    rev!(try_from_both_bounded, isize, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8, u16, u32);\n+    try_from_unbounded!(usize, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n+    try_from_unbounded!(usize, i128);\n+\n+    try_from_both_bounded!(isize, u8, u16, u32);\n+    try_from_lower_bounded!(isize, u64, u128);\n+    try_from_both_bounded!(isize, i8, i16, i32);\n+    try_from_unbounded!(isize, i64, i128);\n+\n+    rev!(try_from_unbounded, usize, u32, u64);\n+    rev!(try_from_upper_bounded, usize, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n+    rev!(try_from_both_bounded, usize, i128);\n+\n+    rev!(try_from_unbounded, isize, u16, u32);\n+    rev!(try_from_upper_bounded, isize, u64, u128);\n+    rev!(try_from_unbounded, isize, i32, i64);\n+    rev!(try_from_both_bounded, isize, i128);\n+}"}, {"sha": "15ac3aea8b7baa2832e726fdd31325a5ab43dfb8", "filename": "src/libcore/default.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -119,7 +119,9 @@ pub trait Default: Sized {\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n-pub macro Default($item:item) { /* compiler built-in */ }\n+pub macro Default($item:item) {\n+    /* compiler built-in */\n+}\n \n macro_rules! default_impl {\n     ($t:ty, $v:expr, $doc:tt) => {"}, {"sha": "74ec24939a3109716e91f1c7d61cdc192480a876", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 164, "deletions": 119, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,5 +1,4 @@\n #![stable(feature = \"\", since = \"1.30.0\")]\n-\n #![allow(non_camel_case_types)]\n \n //! Utilities related to FFI bindings.\n@@ -36,12 +35,20 @@ use crate::ops::{Deref, DerefMut};\n #[repr(u8)]\n #[stable(feature = \"core_c_void\", since = \"1.30.0\")]\n pub enum c_void {\n-    #[unstable(feature = \"c_void_variant\", reason = \"temporary implementation detail\",\n-               issue = \"0\")]\n-    #[doc(hidden)] __variant1,\n-    #[unstable(feature = \"c_void_variant\", reason = \"temporary implementation detail\",\n-               issue = \"0\")]\n-    #[doc(hidden)] __variant2,\n+    #[unstable(\n+        feature = \"c_void_variant\",\n+        reason = \"temporary implementation detail\",\n+        issue = \"0\"\n+    )]\n+    #[doc(hidden)]\n+    __variant1,\n+    #[unstable(\n+        feature = \"c_void_variant\",\n+        reason = \"temporary implementation detail\",\n+        issue = \"0\"\n+    )]\n+    #[doc(hidden)]\n+    __variant2,\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -53,17 +60,20 @@ impl fmt::Debug for c_void {\n \n /// Basic implementation of a `va_list`.\n // The name is WIP, using `VaListImpl` for now.\n-#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\")),\n-          all(target_arch = \"aarch64\", target_os = \"ios\"),\n-          target_arch = \"wasm32\",\n-          target_arch = \"asmjs\",\n-          windows))]\n+#[cfg(any(\n+    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n+    all(target_arch = \"aarch64\", target_os = \"ios\"),\n+    target_arch = \"wasm32\",\n+    target_arch = \"asmjs\",\n+    windows\n+))]\n #[repr(transparent)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n #[lang = \"va_list\"]\n pub struct VaListImpl<'f> {\n     ptr: *mut c_void,\n@@ -73,16 +83,19 @@ pub struct VaListImpl<'f> {\n     _marker: PhantomData<&'f mut &'f c_void>,\n }\n \n-#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\")),\n-          all(target_arch = \"aarch64\", target_os = \"ios\"),\n-          target_arch = \"wasm32\",\n-          target_arch = \"asmjs\",\n-          windows))]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[cfg(any(\n+    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n+    all(target_arch = \"aarch64\", target_os = \"ios\"),\n+    target_arch = \"wasm32\",\n+    target_arch = \"asmjs\",\n+    windows\n+))]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> fmt::Debug for VaListImpl<'f> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"va_list* {:p}\", self.ptr)\n@@ -97,10 +110,12 @@ impl<'f> fmt::Debug for VaListImpl<'f> {\n #[cfg(all(target_arch = \"aarch64\", not(target_os = \"ios\"), not(windows)))]\n #[repr(C)]\n #[derive(Debug)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n #[lang = \"va_list\"]\n pub struct VaListImpl<'f> {\n     stack: *mut c_void,\n@@ -115,10 +130,12 @@ pub struct VaListImpl<'f> {\n #[cfg(all(target_arch = \"powerpc\", not(windows)))]\n #[repr(C)]\n #[derive(Debug)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n #[lang = \"va_list\"]\n pub struct VaListImpl<'f> {\n     gpr: u8,\n@@ -133,10 +150,12 @@ pub struct VaListImpl<'f> {\n #[cfg(all(target_arch = \"x86_64\", not(windows)))]\n #[repr(C)]\n #[derive(Debug)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n #[lang = \"va_list\"]\n pub struct VaListImpl<'f> {\n     gp_offset: i32,\n@@ -149,76 +168,86 @@ pub struct VaListImpl<'f> {\n /// A wrapper for a `va_list`\n #[repr(transparent)]\n #[derive(Debug)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n pub struct VaList<'a, 'f: 'a> {\n-    #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-                  not(target_arch = \"x86_64\")),\n-              all(target_arch = \"aarch64\", target_os = \"ios\"),\n-              target_arch = \"wasm32\",\n-              target_arch = \"asmjs\",\n-              windows))]\n+    #[cfg(any(\n+        all(\n+            not(target_arch = \"aarch64\"),\n+            not(target_arch = \"powerpc\"),\n+            not(target_arch = \"x86_64\")\n+        ),\n+        all(target_arch = \"aarch64\", target_os = \"ios\"),\n+        target_arch = \"wasm32\",\n+        target_arch = \"asmjs\",\n+        windows\n+    ))]\n     inner: VaListImpl<'f>,\n \n-    #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\",\n-                  target_arch = \"x86_64\"),\n-              any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n-              not(target_arch = \"wasm32\"),\n-              not(target_arch = \"asmjs\"),\n-              not(windows)))]\n+    #[cfg(all(\n+        any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n+        any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n+        not(target_arch = \"wasm32\"),\n+        not(target_arch = \"asmjs\"),\n+        not(windows)\n+    ))]\n     inner: &'a mut VaListImpl<'f>,\n \n     _marker: PhantomData<&'a mut VaListImpl<'f>>,\n }\n \n-#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\")),\n-          all(target_arch = \"aarch64\", target_os = \"ios\"),\n-          target_arch = \"wasm32\",\n-          target_arch = \"asmjs\",\n-          windows))]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[cfg(any(\n+    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n+    all(target_arch = \"aarch64\", target_os = \"ios\"),\n+    target_arch = \"wasm32\",\n+    target_arch = \"asmjs\",\n+    windows\n+))]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> VaListImpl<'f> {\n     /// Convert a `VaListImpl` into a `VaList` that is binary-compatible with C's `va_list`.\n     #[inline]\n     pub fn as_va_list<'a>(&'a mut self) -> VaList<'a, 'f> {\n-        VaList {\n-            inner: VaListImpl { ..*self },\n-            _marker: PhantomData,\n-        }\n+        VaList { inner: VaListImpl { ..*self }, _marker: PhantomData }\n     }\n }\n \n-#[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\",\n-              target_arch = \"x86_64\"),\n-          any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n-          not(target_arch = \"wasm32\"),\n-          not(target_arch = \"asmjs\"),\n-          not(windows)))]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[cfg(all(\n+    any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n+    any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n+    not(target_arch = \"wasm32\"),\n+    not(target_arch = \"asmjs\"),\n+    not(windows)\n+))]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> VaListImpl<'f> {\n     /// Convert a `VaListImpl` into a `VaList` that is binary-compatible with C's `va_list`.\n     #[inline]\n     pub fn as_va_list<'a>(&'a mut self) -> VaList<'a, 'f> {\n-        VaList {\n-            inner: self,\n-            _marker: PhantomData,\n-        }\n+        VaList { inner: self, _marker: PhantomData }\n     }\n }\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'a, 'f: 'a> Deref for VaList<'a, 'f> {\n     type Target = VaListImpl<'f>;\n \n@@ -228,10 +257,12 @@ impl<'a, 'f: 'a> Deref for VaList<'a, 'f> {\n     }\n }\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'a, 'f: 'a> DerefMut for VaList<'a, 'f> {\n     #[inline]\n     fn deref_mut(&mut self) -> &mut VaListImpl<'f> {\n@@ -252,10 +283,12 @@ mod sealed_trait {\n     /// Trait which whitelists the allowed types to be used with [VaList::arg]\n     ///\n     /// [VaList::va_arg]: struct.VaList.html#method.arg\n-    #[unstable(feature = \"c_variadic\",\n-               reason = \"the `c_variadic` feature has not been properly tested on \\\n-                         all supported platforms\",\n-               issue = \"44930\")]\n+    #[unstable(\n+        feature = \"c_variadic\",\n+        reason = \"the `c_variadic` feature has not been properly tested on \\\n+                  all supported platforms\",\n+        issue = \"44930\"\n+    )]\n     pub trait VaArgSafe {}\n }\n \n@@ -271,25 +304,31 @@ macro_rules! impl_va_arg_safe {\n     }\n }\n \n-impl_va_arg_safe!{i8, i16, i32, i64, usize}\n-impl_va_arg_safe!{u8, u16, u32, u64, isize}\n-impl_va_arg_safe!{f64}\n+impl_va_arg_safe! {i8, i16, i32, i64, usize}\n+impl_va_arg_safe! {u8, u16, u32, u64, isize}\n+impl_va_arg_safe! {f64}\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<T> sealed_trait::VaArgSafe for *mut T {}\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<T> sealed_trait::VaArgSafe for *const T {}\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> VaListImpl<'f> {\n     /// Advance to the next arg.\n     #[inline]\n@@ -299,18 +338,22 @@ impl<'f> VaListImpl<'f> {\n \n     /// Copies the `va_list` at the current location.\n     pub unsafe fn with_copy<F, R>(&self, f: F) -> R\n-            where F: for<'copy> FnOnce(VaList<'copy, 'f>) -> R {\n+    where\n+        F: for<'copy> FnOnce(VaList<'copy, 'f>) -> R,\n+    {\n         let mut ap = self.clone();\n         let ret = f(ap.as_va_list());\n         va_end(&mut ap);\n         ret\n     }\n }\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> Clone for VaListImpl<'f> {\n     #[inline]\n     fn clone(&self) -> Self {\n@@ -323,10 +366,12 @@ impl<'f> Clone for VaListImpl<'f> {\n     }\n }\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> Drop for VaListImpl<'f> {\n     fn drop(&mut self) {\n         // FIXME: this should call `va_end`, but there's no clean way to"}, {"sha": "284e94926dc8524f173dc13ea263a5488fbf50e6", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 86, "deletions": 37, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,4 +1,4 @@\n-use crate::fmt::{Formatter, Result, LowerExp, UpperExp, Display, Debug};\n+use crate::fmt::{Debug, Display, Formatter, LowerExp, Result, UpperExp};\n use crate::mem::MaybeUninit;\n use crate::num::flt2dec;\n \n@@ -7,9 +7,14 @@ use crate::num::flt2dec;\n // Don't inline this so callers don't use the stack space this function\n // requires unless they have to.\n #[inline(never)]\n-fn float_to_decimal_common_exact<T>(fmt: &mut Formatter<'_>, num: &T,\n-                                    sign: flt2dec::Sign, precision: usize) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_decimal_common_exact<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    sign: flt2dec::Sign,\n+    precision: usize,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n@@ -19,43 +24,65 @@ fn float_to_decimal_common_exact<T>(fmt: &mut Formatter<'_>, num: &T,\n         // we decided whether that is valid or not.\n         // We can do this only because we are libstd and coupled to the compiler.\n         // (FWIW, using `freeze` would not be enough; `flt2dec::Part` is an enum!)\n-        let formatted = flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact,\n-                                                    *num, sign, precision,\n-                                                    false, buf.get_mut(), parts.get_mut());\n+        let formatted = flt2dec::to_exact_fixed_str(\n+            flt2dec::strategy::grisu::format_exact,\n+            *num,\n+            sign,\n+            precision,\n+            false,\n+            buf.get_mut(),\n+            parts.get_mut(),\n+        );\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n \n // Don't inline this so callers that call both this and the above won't wind\n // up using the combined stack space of both functions in some cases.\n #[inline(never)]\n-fn float_to_decimal_common_shortest<T>(fmt: &mut Formatter<'_>, num: &T,\n-                                       sign: flt2dec::Sign, precision: usize) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_decimal_common_shortest<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    sign: flt2dec::Sign,\n+    precision: usize,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     unsafe {\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 4]>::uninit();\n         // FIXME(#53491)\n-        let formatted = flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num,\n-                                                 sign, precision, false, buf.get_mut(),\n-                                                 parts.get_mut());\n+        let formatted = flt2dec::to_shortest_str(\n+            flt2dec::strategy::grisu::format_shortest,\n+            *num,\n+            sign,\n+            precision,\n+            false,\n+            buf.get_mut(),\n+            parts.get_mut(),\n+        );\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n \n // Common code of floating point Debug and Display.\n-fn float_to_decimal_common<T>(fmt: &mut Formatter<'_>, num: &T,\n-                              negative_zero: bool, min_precision: usize) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_decimal_common<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    negative_zero: bool,\n+    min_precision: usize,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     let force_sign = fmt.sign_plus();\n     let sign = match (force_sign, negative_zero) {\n         (false, false) => flt2dec::Sign::Minus,\n-        (false, true)  => flt2dec::Sign::MinusRaw,\n-        (true,  false) => flt2dec::Sign::MinusPlus,\n-        (true,  true)  => flt2dec::Sign::MinusPlusRaw,\n+        (false, true) => flt2dec::Sign::MinusRaw,\n+        (true, false) => flt2dec::Sign::MinusPlus,\n+        (true, true) => flt2dec::Sign::MinusPlusRaw,\n     };\n \n     if let Some(precision) = fmt.precision {\n@@ -68,50 +95,72 @@ fn float_to_decimal_common<T>(fmt: &mut Formatter<'_>, num: &T,\n // Don't inline this so callers don't use the stack space this function\n // requires unless they have to.\n #[inline(never)]\n-fn float_to_exponential_common_exact<T>(fmt: &mut Formatter<'_>, num: &T,\n-                                        sign: flt2dec::Sign, precision: usize,\n-                                        upper: bool) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_exponential_common_exact<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    sign: flt2dec::Sign,\n+    precision: usize,\n+    upper: bool,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 6]>::uninit();\n         // FIXME(#53491)\n-        let formatted = flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact,\n-                                                  *num, sign, precision,\n-                                                  upper, buf.get_mut(), parts.get_mut());\n+        let formatted = flt2dec::to_exact_exp_str(\n+            flt2dec::strategy::grisu::format_exact,\n+            *num,\n+            sign,\n+            precision,\n+            upper,\n+            buf.get_mut(),\n+            parts.get_mut(),\n+        );\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n \n // Don't inline this so callers that call both this and the above won't wind\n // up using the combined stack space of both functions in some cases.\n #[inline(never)]\n-fn float_to_exponential_common_shortest<T>(fmt: &mut Formatter<'_>,\n-                                           num: &T, sign: flt2dec::Sign,\n-                                           upper: bool) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_exponential_common_shortest<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    sign: flt2dec::Sign,\n+    upper: bool,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     unsafe {\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 6]>::uninit();\n         // FIXME(#53491)\n-        let formatted = flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest,\n-                                                     *num, sign, (0, 0), upper,\n-                                                     buf.get_mut(), parts.get_mut());\n+        let formatted = flt2dec::to_shortest_exp_str(\n+            flt2dec::strategy::grisu::format_shortest,\n+            *num,\n+            sign,\n+            (0, 0),\n+            upper,\n+            buf.get_mut(),\n+            parts.get_mut(),\n+        );\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n \n // Common code of floating point LowerExp and UpperExp.\n fn float_to_exponential_common<T>(fmt: &mut Formatter<'_>, num: &T, upper: bool) -> Result\n-    where T: flt2dec::DecodableFloat\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     let force_sign = fmt.sign_plus();\n     let sign = match force_sign {\n         false => flt2dec::Sign::Minus,\n-        true  => flt2dec::Sign::MinusPlus,\n+        true => flt2dec::Sign::MinusPlus,\n     };\n \n     if let Some(precision) = fmt.precision {\n@@ -123,7 +172,7 @@ fn float_to_exponential_common<T>(fmt: &mut Formatter<'_>, num: &T, upper: bool)\n }\n \n macro_rules! floating {\n-    ($ty:ident) => (\n+    ($ty:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Debug for $ty {\n             fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n@@ -151,7 +200,7 @@ macro_rules! floating {\n                 float_to_exponential_common(fmt, self, true)\n             }\n         }\n-    )\n+    };\n }\n \n floating! { f32 }"}, {"sha": "e2f49ee25a756f92b58b6521852d8fc485035e45", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 118, "deletions": 117, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -4,7 +4,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::cell::{UnsafeCell, Cell, RefCell, Ref, RefMut};\n+use crate::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\n use crate::marker::PhantomData;\n use crate::mem;\n use crate::num::flt2dec;\n@@ -13,9 +13,9 @@ use crate::result;\n use crate::slice;\n use crate::str;\n \n+mod builders;\n mod float;\n mod num;\n-mod builders;\n \n #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n /// Possible alignments returned by `Formatter::align`\n@@ -33,10 +33,9 @@ pub enum Alignment {\n }\n \n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-pub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugList, DebugMap};\n+pub use self::builders::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n \n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-           issue = \"0\")]\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n #[doc(hidden)]\n pub mod rt {\n     pub mod v1;\n@@ -234,7 +233,7 @@ pub struct Formatter<'a> {\n     width: Option<usize>,\n     precision: Option<usize>,\n \n-    buf: &'a mut (dyn Write+'a),\n+    buf: &'a mut (dyn Write + 'a),\n     curarg: slice::Iter<'a, ArgumentV1<'a>>,\n     args: &'a [ArgumentV1<'a>],\n }\n@@ -260,8 +259,7 @@ struct Void {\n /// types, and then this struct is used to canonicalize arguments to one type.\n #[derive(Copy, Clone)]\n #[allow(missing_debug_implementations)]\n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-           issue = \"0\")]\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n #[doc(hidden)]\n pub struct ArgumentV1<'a> {\n     value: &'a Void,\n@@ -275,21 +273,13 @@ impl<'a> ArgumentV1<'a> {\n     }\n \n     #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n-    pub fn new<'b, T>(x: &'b T,\n-                      f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n-        unsafe {\n-            ArgumentV1 {\n-                formatter: mem::transmute(f),\n-                value: mem::transmute(x)\n-            }\n-        }\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n+    pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n+        unsafe { ArgumentV1 { formatter: mem::transmute(f), value: mem::transmute(x) } }\n     }\n \n     #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n     pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n         ArgumentV1::new(x, ArgumentV1::show_usize)\n     }\n@@ -305,21 +295,23 @@ impl<'a> ArgumentV1<'a> {\n \n // flags available in the v1 format of format_args\n #[derive(Copy, Clone)]\n-enum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, DebugLowerHex, DebugUpperHex }\n+enum FlagV1 {\n+    SignPlus,\n+    SignMinus,\n+    Alternate,\n+    SignAwareZeroPad,\n+    DebugLowerHex,\n+    DebugUpperHex,\n+}\n \n impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n-    #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n-    pub fn new_v1(pieces: &'a [&'a str],\n-                  args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n-        Arguments {\n-            pieces,\n-            fmt: None,\n-            args,\n-        }\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n+    pub fn new_v1(pieces: &'a [&'a str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+        Arguments { pieces, fmt: None, args }\n     }\n \n     /// This function is used to specify nonstandard formatting parameters.\n@@ -328,29 +320,26 @@ impl<'a> Arguments<'a> {\n     /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n     /// created with `argumentusize`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n-    #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n-    pub fn new_v1_formatted(pieces: &'a [&'a str],\n-                            args: &'a [ArgumentV1<'a>],\n-                            fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {\n-        Arguments {\n-            pieces,\n-            fmt: Some(fmt),\n-            args,\n-        }\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n+    pub fn new_v1_formatted(\n+        pieces: &'a [&'a str],\n+        args: &'a [ArgumentV1<'a>],\n+        fmt: &'a [rt::v1::Argument],\n+    ) -> Arguments<'a> {\n+        Arguments { pieces, fmt: Some(fmt), args }\n     }\n \n     /// Estimates the length of the formatted text.\n     ///\n     /// This is intended to be used for setting initial `String` capacity\n     /// when using `format!`. Note: this is neither the lower nor upper bound.\n-    #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n     pub fn estimated_capacity(&self) -> usize {\n-        let pieces_length: usize = self.pieces.iter()\n-            .map(|x| x.len()).sum();\n+        let pieces_length: usize = self.pieces.iter().map(|x| x.len()).sum();\n \n         if self.args.is_empty() {\n             pieces_length\n@@ -514,10 +503,13 @@ impl Display for Arguments<'_> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n-    on(crate_local, label=\"`{Self}` cannot be formatted using `{{:?}}`\",\n-                    note=\"add `#[derive(Debug)]` or manually implement `{Debug}`\"),\n-    message=\"`{Self}` doesn't implement `{Debug}`\",\n-    label=\"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\",\n+    on(\n+        crate_local,\n+        label = \"`{Self}` cannot be formatted using `{{:?}}`\",\n+        note = \"add `#[derive(Debug)]` or manually implement `{Debug}`\"\n+    ),\n+    message = \"`{Self}` doesn't implement `{Debug}`\",\n+    label = \"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\"\n )]\n #[doc(alias = \"{:?}\")]\n #[rustc_diagnostic_item = \"debug_trait\"]\n@@ -553,7 +545,9 @@ pub(crate) mod macros {\n     #[rustc_builtin_macro]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n-    pub macro Debug($item:item) { /* compiler built-in */ }\n+    pub macro Debug($item:item) {\n+        /* compiler built-in */\n+    }\n }\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(inline)]\n@@ -594,14 +588,14 @@ pub use macros::Debug;\n /// ```\n #[rustc_on_unimplemented(\n     on(\n-        _Self=\"std::path::Path\",\n-        label=\"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n-        note=\"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n-              as they may contain non-Unicode data\"\n+        _Self = \"std::path::Path\",\n+        label = \"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n+        note = \"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n+                as they may contain non-Unicode data\"\n     ),\n-    message=\"`{Self}` doesn't implement `{Display}`\",\n-    label=\"`{Self}` cannot be formatted with the default formatter\",\n-    note=\"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\",\n+    message = \"`{Self}` doesn't implement `{Display}`\",\n+    label = \"`{Self}` cannot be formatted with the default formatter\",\n+    note = \"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\"\n )]\n #[doc(alias = \"{}\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -668,7 +662,7 @@ pub trait Display {\n ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         let val = self.0;\n ///\n-///         write!(f, \"{:o}\", val) // delegate to i32's implementation\n+///         fmt::Octal::fmt(&val, f) // delegate to i32's implementation\n ///     }\n /// }\n ///\n@@ -718,7 +712,7 @@ pub trait Octal {\n ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         let val = self.0;\n ///\n-///         write!(f, \"{:b}\", val) // delegate to i32's implementation\n+///         fmt::Binary::fmt(&val, f) // delegate to i32's implementation\n ///     }\n /// }\n ///\n@@ -777,7 +771,7 @@ pub trait Binary {\n ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         let val = self.0;\n ///\n-///         write!(f, \"{:x}\", val) // delegate to i32's implementation\n+///         fmt::LowerHex::fmt(&val, f) // delegate to i32's implementation\n ///     }\n /// }\n ///\n@@ -830,7 +824,7 @@ pub trait LowerHex {\n ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         let val = self.0;\n ///\n-///         write!(f, \"{:X}\", val) // delegate to i32's implementation\n+///         fmt::UpperHex::fmt(&val, f) // delegate to i32's implementation\n ///     }\n /// }\n ///\n@@ -875,7 +869,8 @@ pub trait UpperHex {\n ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         // use `as` to convert to a `*const T`, which implements Pointer, which we can use\n ///\n-///         write!(f, \"{:p}\", self as *const Length)\n+///         let ptr = self as *const Self;\n+///         fmt::Pointer::fmt(&ptr, f)\n ///     }\n /// }\n ///\n@@ -1073,7 +1068,9 @@ impl PostPadding {\n \n impl<'a> Formatter<'a> {\n     fn wrap_buf<'b, 'c, F>(&'b mut self, wrap: F) -> Formatter<'c>\n-        where 'b: 'c, F: FnOnce(&'b mut (dyn Write+'b)) -> &'c mut (dyn Write+'c)\n+    where\n+        'b: 'c,\n+        F: FnOnce(&'b mut (dyn Write + 'b)) -> &'c mut (dyn Write + 'c),\n     {\n         Formatter {\n             // We want to change this\n@@ -1106,7 +1103,7 @@ impl<'a> Formatter<'a> {\n \n         // Extract the correct argument\n         let value = match arg.position {\n-            rt::v1::Position::Next => { *self.curarg.next().unwrap() }\n+            rt::v1::Position::Next => *self.curarg.next().unwrap(),\n             rt::v1::Position::At(i) => self.args[i],\n         };\n \n@@ -1118,12 +1115,8 @@ impl<'a> Formatter<'a> {\n         match *cnt {\n             rt::v1::Count::Is(n) => Some(n),\n             rt::v1::Count::Implied => None,\n-            rt::v1::Count::Param(i) => {\n-                self.args[i].as_usize()\n-            }\n-            rt::v1::Count::NextParam => {\n-                self.curarg.next()?.as_usize()\n-            }\n+            rt::v1::Count::Param(i) => self.args[i].as_usize(),\n+            rt::v1::Count::NextParam => self.curarg.next()?.as_usize(),\n         }\n     }\n \n@@ -1174,18 +1167,16 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn pad_integral(&mut self,\n-                        is_nonnegative: bool,\n-                        prefix: &str,\n-                        buf: &str)\n-                        -> Result {\n+    pub fn pad_integral(&mut self, is_nonnegative: bool, prefix: &str, buf: &str) -> Result {\n         let mut width = buf.len();\n \n         let mut sign = None;\n         if !is_nonnegative {\n-            sign = Some('-'); width += 1;\n+            sign = Some('-');\n+            width += 1;\n         } else if self.sign_plus() {\n-            sign = Some('+'); width += 1;\n+            sign = Some('+');\n+            width += 1;\n         }\n \n         let prefix = if self.alternate() {\n@@ -1201,11 +1192,7 @@ impl<'a> Formatter<'a> {\n             if let Some(c) = sign {\n                 f.buf.write_char(c)?;\n             }\n-            if let Some(prefix) = prefix {\n-                f.buf.write_str(prefix)\n-            } else {\n-                Ok(())\n-            }\n+            if let Some(prefix) = prefix { f.buf.write_str(prefix) } else { Ok(()) }\n         }\n \n         // The `width` field is more of a `min-width` parameter at this point.\n@@ -1301,9 +1288,7 @@ impl<'a> Formatter<'a> {\n             None => self.buf.write_str(s),\n             // If we're under the maximum width, check if we're over the minimum\n             // width, if so it's as easy as just emitting the string.\n-            Some(width) if s.chars().count() >= width => {\n-                self.buf.write_str(s)\n-            }\n+            Some(width) if s.chars().count() >= width => self.buf.write_str(s),\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n@@ -1321,17 +1306,16 @@ impl<'a> Formatter<'a> {\n     fn padding(\n         &mut self,\n         padding: usize,\n-        default: rt::v1::Alignment\n+        default: rt::v1::Alignment,\n     ) -> result::Result<PostPadding, Error> {\n         let align = match self.align {\n             rt::v1::Alignment::Unknown => default,\n-            _ => self.align\n+            _ => self.align,\n         };\n \n         let (pre_pad, post_pad) = match align {\n             rt::v1::Alignment::Left => (0, padding),\n-            rt::v1::Alignment::Right |\n-            rt::v1::Alignment::Unknown => (padding, 0),\n+            rt::v1::Alignment::Right | rt::v1::Alignment::Unknown => (padding, 0),\n             rt::v1::Alignment::Center => (padding / 2, (padding + 1) / 2),\n         };\n \n@@ -1368,7 +1352,8 @@ impl<'a> Formatter<'a> {\n \n             // remaining parts go through the ordinary padding process.\n             let len = formatted.len();\n-            let ret = if width <= len { // no padding\n+            let ret = if width <= len {\n+                // no padding\n                 self.write_formatted_parts(&formatted)\n             } else {\n                 let post_padding = self.padding(width - len, align)?;\n@@ -1473,10 +1458,14 @@ impl<'a> Formatter<'a> {\n \n     /// Flags for formatting\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.24.0\",\n-                       reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n-                                 or `sign_aware_zero_pad` methods instead\")]\n-    pub fn flags(&self) -> u32 { self.flags }\n+    #[rustc_deprecated(\n+        since = \"1.24.0\",\n+        reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n+                  or `sign_aware_zero_pad` methods instead\"\n+    )]\n+    pub fn flags(&self) -> u32 {\n+        self.flags\n+    }\n \n     /// Character used as 'fill' whenever there is alignment.\n     ///\n@@ -1506,7 +1495,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{:t>6}\", Foo), \"tttttt\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn fill(&self) -> char { self.fill }\n+    pub fn fill(&self) -> char {\n+        self.fill\n+    }\n \n     /// Flag indicating what form of alignment was requested.\n     ///\n@@ -1574,7 +1565,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn width(&self) -> Option<usize> { self.width }\n+    pub fn width(&self) -> Option<usize> {\n+        self.width\n+    }\n \n     /// Optionally specified precision for numeric types.\n     ///\n@@ -1601,7 +1594,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn precision(&self) -> Option<usize> { self.precision }\n+    pub fn precision(&self) -> Option<usize> {\n+        self.precision\n+    }\n \n     /// Determines if the `+` flag was specified.\n     ///\n@@ -1629,7 +1624,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn sign_plus(&self) -> bool { self.flags & (1 << FlagV1::SignPlus as u32) != 0 }\n+    pub fn sign_plus(&self) -> bool {\n+        self.flags & (1 << FlagV1::SignPlus as u32) != 0\n+    }\n \n     /// Determines if the `-` flag was specified.\n     ///\n@@ -1655,7 +1652,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn sign_minus(&self) -> bool { self.flags & (1 << FlagV1::SignMinus as u32) != 0 }\n+    pub fn sign_minus(&self) -> bool {\n+        self.flags & (1 << FlagV1::SignMinus as u32) != 0\n+    }\n \n     /// Determines if the `#` flag was specified.\n     ///\n@@ -1680,7 +1679,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23)), \"23\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn alternate(&self) -> bool { self.flags & (1 << FlagV1::Alternate as u32) != 0 }\n+    pub fn alternate(&self) -> bool {\n+        self.flags & (1 << FlagV1::Alternate as u32) != 0\n+    }\n \n     /// Determines if the `0` flag was specified.\n     ///\n@@ -1709,9 +1710,13 @@ impl<'a> Formatter<'a> {\n \n     // FIXME: Decide what public API we want for these two flags.\n     // https://github.com/rust-lang/rust/issues/48584\n-    fn debug_lower_hex(&self) -> bool { self.flags & (1 << FlagV1::DebugLowerHex as u32) != 0 }\n+    fn debug_lower_hex(&self) -> bool {\n+        self.flags & (1 << FlagV1::DebugLowerHex as u32) != 0\n+    }\n \n-    fn debug_upper_hex(&self) -> bool { self.flags & (1 << FlagV1::DebugUpperHex as u32) != 0 }\n+    fn debug_upper_hex(&self) -> bool {\n+        self.flags & (1 << FlagV1::DebugUpperHex as u32) != 0\n+    }\n \n     /// Creates a [`DebugStruct`] builder designed to assist with creation of\n     /// [`fmt::Debug`] implementations for structs.\n@@ -2067,11 +2072,15 @@ impl<T: ?Sized> Pointer for &mut T {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Debug for *const T {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> Result { Pointer::fmt(self, f) }\n+    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+        Pointer::fmt(self, f)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Debug for *mut T {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> Result { Pointer::fmt(self, f) }\n+    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+        Pointer::fmt(self, f)\n+    }\n }\n \n macro_rules! peel {\n@@ -2129,21 +2138,15 @@ impl<T: ?Sized> Debug for PhantomData<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Copy + Debug> Debug for Cell<T> {\n     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n-        f.debug_struct(\"Cell\")\n-            .field(\"value\", &self.get())\n-            .finish()\n+        f.debug_struct(\"Cell\").field(\"value\", &self.get()).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Debug> Debug for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n         match self.try_borrow() {\n-            Ok(borrow) => {\n-                f.debug_struct(\"RefCell\")\n-                    .field(\"value\", &borrow)\n-                    .finish()\n-            }\n+            Ok(borrow) => f.debug_struct(\"RefCell\").field(\"value\", &borrow).finish(),\n             Err(_) => {\n                 // The RefCell is mutably borrowed so we can't look at its value\n                 // here. Show a placeholder instead.\n@@ -2155,9 +2158,7 @@ impl<T: ?Sized + Debug> Debug for RefCell<T> {\n                     }\n                 }\n \n-                f.debug_struct(\"RefCell\")\n-                    .field(\"value\", &BorrowedPlaceholder)\n-                    .finish()\n+                f.debug_struct(\"RefCell\").field(\"value\", &BorrowedPlaceholder).finish()\n             }\n         }\n     }"}, {"sha": "0db8d86ebbf529cc56f89ece36e15ff4275478b5", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -192,7 +192,8 @@ pub trait Hash {\n     /// [`Hasher`]: trait.Hasher.html\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n     fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n-        where Self: Sized\n+    where\n+        Self: Sized,\n     {\n         for piece in data {\n             piece.hash(state);\n@@ -206,7 +207,9 @@ pub(crate) mod macros {\n     #[rustc_builtin_macro]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n-    pub macro Hash($item:item) { /* compiler built-in */ }\n+    pub macro Hash($item:item) {\n+        /* compiler built-in */\n+    }\n }\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(inline)]\n@@ -666,7 +669,6 @@ mod impls {\n         }\n     }\n \n-\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: ?Sized + Hash> Hash for &T {\n         fn hash<H: Hasher>(&self, state: &mut H) {\n@@ -689,9 +691,7 @@ mod impls {\n                 state.write_usize(*self as *const () as usize);\n             } else {\n                 // Fat pointer\n-                let (a, b) = unsafe {\n-                    *(self as *const Self as *const (usize, usize))\n-                };\n+                let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n                 state.write_usize(a);\n                 state.write_usize(b);\n             }\n@@ -706,9 +706,7 @@ mod impls {\n                 state.write_usize(*self as *const () as usize);\n             } else {\n                 // Fat pointer\n-                let (a, b) = unsafe {\n-                    *(self as *const Self as *const (usize, usize))\n-                };\n+                let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n                 state.write_usize(a);\n                 state.write_usize(b);\n             }"}, {"sha": "0aa3b97ebcf15d6725ad2598f537dd5259c9cae6", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 62, "deletions": 51, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -4,10 +4,10 @@\n \n #![allow(deprecated)] // the types in this module are deprecated\n \n-use crate::marker::PhantomData;\n-use crate::ptr;\n use crate::cmp;\n+use crate::marker::PhantomData;\n use crate::mem;\n+use crate::ptr;\n \n /// An implementation of SipHash 1-3.\n ///\n@@ -16,8 +16,10 @@ use crate::mem;\n ///\n /// See: <https://131002.net/siphash>\n #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n-#[rustc_deprecated(since = \"1.13.0\",\n-                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+#[rustc_deprecated(\n+    since = \"1.13.0\",\n+    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+)]\n #[derive(Debug, Clone, Default)]\n #[doc(hidden)]\n pub struct SipHasher13 {\n@@ -28,8 +30,10 @@ pub struct SipHasher13 {\n ///\n /// See: <https://131002.net/siphash/>\n #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n-#[rustc_deprecated(since = \"1.13.0\",\n-                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+#[rustc_deprecated(\n+    since = \"1.13.0\",\n+    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+)]\n #[derive(Debug, Clone, Default)]\n struct SipHasher24 {\n     hasher: Hasher<Sip24Rounds>,\n@@ -48,8 +52,10 @@ struct SipHasher24 {\n /// it is not intended for cryptographic purposes. As such, all\n /// cryptographic uses of this implementation are _strongly discouraged_.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(since = \"1.13.0\",\n-                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+#[rustc_deprecated(\n+    since = \"1.13.0\",\n+    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+)]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher(SipHasher24);\n \n@@ -58,9 +64,9 @@ struct Hasher<S: Sip> {\n     k0: u64,\n     k1: u64,\n     length: usize, // how many bytes we've processed\n-    state: State, // hash State\n-    tail: u64, // unprocessed bytes le\n-    ntail: usize, // how many bytes in tail are valid\n+    state: State,  // hash State\n+    tail: u64,     // unprocessed bytes le\n+    ntail: usize,  // how many bytes in tail are valid\n     _marker: PhantomData<S>,\n }\n \n@@ -78,18 +84,23 @@ struct State {\n }\n \n macro_rules! compress {\n-    ($state:expr) => ({\n-        compress!($state.v0, $state.v1, $state.v2, $state.v3)\n-    });\n-    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n-    ({\n-        $v0 = $v0.wrapping_add($v1); $v1 = $v1.rotate_left(13); $v1 ^= $v0;\n+    ($state:expr) => {{ compress!($state.v0, $state.v1, $state.v2, $state.v3) }};\n+    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) => {{\n+        $v0 = $v0.wrapping_add($v1);\n+        $v1 = $v1.rotate_left(13);\n+        $v1 ^= $v0;\n         $v0 = $v0.rotate_left(32);\n-        $v2 = $v2.wrapping_add($v3); $v3 = $v3.rotate_left(16); $v3 ^= $v2;\n-        $v0 = $v0.wrapping_add($v3); $v3 = $v3.rotate_left(21); $v3 ^= $v0;\n-        $v2 = $v2.wrapping_add($v1); $v1 = $v1.rotate_left(17); $v1 ^= $v2;\n+        $v2 = $v2.wrapping_add($v3);\n+        $v3 = $v3.rotate_left(16);\n+        $v3 ^= $v2;\n+        $v0 = $v0.wrapping_add($v3);\n+        $v3 = $v3.rotate_left(21);\n+        $v3 ^= $v0;\n+        $v2 = $v2.wrapping_add($v1);\n+        $v1 = $v1.rotate_left(17);\n+        $v1 ^= $v2;\n         $v2 = $v2.rotate_left(32);\n-    });\n+    }};\n }\n \n /// Loads an integer of the desired type from a byte stream, in LE order. Uses\n@@ -98,15 +109,16 @@ macro_rules! compress {\n ///\n /// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\n macro_rules! load_int_le {\n-    ($buf:expr, $i:expr, $int_ty:ident) =>\n-    ({\n-       debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n-       let mut data = 0 as $int_ty;\n-       ptr::copy_nonoverlapping($buf.get_unchecked($i),\n-                                &mut data as *mut _ as *mut u8,\n-                                mem::size_of::<$int_ty>());\n-       data.to_le()\n-    });\n+    ($buf:expr, $i:expr, $int_ty:ident) => {{\n+        debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n+        let mut data = 0 as $int_ty;\n+        ptr::copy_nonoverlapping(\n+            $buf.get_unchecked($i),\n+            &mut data as *mut _ as *mut u8,\n+            mem::size_of::<$int_ty>(),\n+        );\n+        data.to_le()\n+    }};\n }\n \n /// Loads an u64 using up to 7 bytes of a byte slice.\n@@ -137,43 +149,47 @@ impl SipHasher {\n     /// Creates a new `SipHasher` with the two initial keys set to 0.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+    #[rustc_deprecated(\n+        since = \"1.13.0\",\n+        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+    )]\n     pub fn new() -> SipHasher {\n         SipHasher::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher` that is keyed off the provided keys.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+    #[rustc_deprecated(\n+        since = \"1.13.0\",\n+        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+    )]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n-        SipHasher(SipHasher24 {\n-            hasher: Hasher::new_with_keys(key0, key1)\n-        })\n+        SipHasher(SipHasher24 { hasher: Hasher::new_with_keys(key0, key1) })\n     }\n }\n \n impl SipHasher13 {\n     /// Creates a new `SipHasher13` with the two initial keys set to 0.\n     #[inline]\n     #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+    #[rustc_deprecated(\n+        since = \"1.13.0\",\n+        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+    )]\n     pub fn new() -> SipHasher13 {\n         SipHasher13::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher13` that is keyed off the provided keys.\n     #[inline]\n     #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+    #[rustc_deprecated(\n+        since = \"1.13.0\",\n+        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+    )]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n-        SipHasher13 {\n-            hasher: Hasher::new_with_keys(key0, key1)\n-        }\n+        SipHasher13 { hasher: Hasher::new_with_keys(key0, key1) }\n     }\n }\n \n@@ -184,12 +200,7 @@ impl<S: Sip> Hasher<S> {\n             k0: key0,\n             k1: key1,\n             length: 0,\n-            state: State {\n-                v0: 0,\n-                v1: 0,\n-                v2: 0,\n-                v3: 0,\n-            },\n+            state: State { v0: 0, v1: 0, v2: 0, v3: 0 },\n             tail: 0,\n             ntail: 0,\n             _marker: PhantomData,\n@@ -294,7 +305,7 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n             self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << 8 * self.ntail;\n             if length < needed {\n                 self.ntail += length;\n-                return\n+                return;\n             } else {\n                 self.state.v3 ^= self.tail;\n                 S::c_rounds(&mut self.state);"}, {"sha": "a295e65bb5511cb7de07e0758ac971ea0404271e", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -113,7 +113,7 @@ pub fn spin_loop() {\n pub fn black_box<T>(dummy: T) -> T {\n     // We need to \"use\" the argument in some way LLVM can't introspect, and on\n     // targets that support it we can typically leverage inline assembly to do\n-    // this. LLVM's intepretation of inline assembly is that it's, well, a black\n+    // this. LLVM's interpretation of inline assembly is that it's, well, a black\n     // box. This isn't the greatest implementation since it probably deoptimizes\n     // more than we want, but it's so far good enough.\n     unsafe {"}, {"sha": "18aae59573d7d56a0707f586617bf86570a816ad", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -939,6 +939,7 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_transmute\")]\n     pub fn transmute<T, U>(e: T) -> U;\n \n     /// Returns `true` if the actual type given as `T` requires drop\n@@ -1143,6 +1144,11 @@ extern \"rust-intrinsic\" {\n     /// May assume inputs are finite.\n     pub fn frem_fast<T>(a: T, b: T) -> T;\n \n+    /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n+    /// https://github.com/rust-lang/rust/issues/10184\n+    #[cfg(not(bootstrap))]\n+    pub fn float_to_int_approx_unchecked<Float, Int>(value: Float) -> Int;\n+\n \n     /// Returns the number of bits set in an integer type `T`\n     pub fn ctpop<T>(x: T) -> T;\n@@ -1279,7 +1285,7 @@ extern \"rust-intrinsic\" {\n     /// undefined behavior when `x + y > T::max_value()` or `x + y < T::min_value()`.\n     pub fn unchecked_add<T>(x: T, y: T) -> T;\n \n-    /// Returns the result of an unchecked substraction, resulting in\n+    /// Returns the result of an unchecked subtraction, resulting in\n     /// undefined behavior when `x - y > T::max_value()` or `x - y < T::min_value()`.\n     pub fn unchecked_sub<T>(x: T, y: T) -> T;\n \n@@ -1348,9 +1354,11 @@ extern \"rust-intrinsic\" {\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// Internal hook used by Miri to implement unwinding.\n+    /// Compiles to a NOP during non-Miri codegen.\n+    ///\n     /// Perma-unstable: do not use\n     #[cfg(not(bootstrap))]\n-    pub fn miri_start_panic(data: *mut (dyn crate::any::Any + crate::marker::Send)) -> !;\n+    pub fn miri_start_panic(data: *mut (dyn crate::any::Any + crate::marker::Send)) -> ();\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "0a7a9f26f891257211a68aff95006aed783eb152", "filename": "src/libcore/iter/adapters/flatten.rs", "status": "modified", "additions": 91, "deletions": 37, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,7 +1,7 @@\n use crate::fmt;\n use crate::ops::Try;\n \n-use super::super::{Iterator, DoubleEndedIterator, FusedIterator};\n+use super::super::{DoubleEndedIterator, FusedIterator, Iterator};\n use super::Map;\n \n /// An iterator that maps each element to an iterator, and yields the elements\n@@ -15,7 +15,7 @@ use super::Map;\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct FlatMap<I, U: IntoIterator, F> {\n-    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n+    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>,\n }\n impl<I: Iterator, U: IntoIterator, F: FnMut(I::Item) -> U> FlatMap<I, U, F> {\n     pub(in super::super) fn new(iter: I, f: F) -> FlatMap<I, U, F> {\n@@ -28,7 +28,9 @@ impl<I: Clone, U, F: Clone> Clone for FlatMap<I, U, F>\n where\n     U: Clone + IntoIterator<IntoIter: Clone>,\n {\n-    fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n+    fn clone(&self) -> Self {\n+        FlatMap { inner: self.inner.clone() }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -43,26 +45,35 @@ where\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n-    where F: FnMut(I::Item) -> U,\n+where\n+    F: FnMut(I::Item) -> U,\n {\n     type Item = U::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+    fn next(&mut self) -> Option<U::Item> {\n+        self.inner.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.inner.try_fold(init, fold)\n     }\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.inner.fold(init, fold)\n     }\n@@ -75,26 +86,37 @@ where\n     U: IntoIterator<IntoIter: DoubleEndedIterator>,\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<U::Item> {\n+        self.inner.next_back()\n+    }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.inner.try_rfold(init, fold)\n     }\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.inner.rfold(init, fold)\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n-    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n+where\n+    I: FusedIterator,\n+    U: IntoIterator,\n+    F: FnMut(I::Item) -> U,\n+{\n+}\n \n /// An iterator that flattens one level of nesting in an iterator of things\n /// that can be turned into iterators.\n@@ -133,7 +155,9 @@ where\n     I: Clone + Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n     U: Clone + Iterator,\n {\n-    fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n+    fn clone(&self) -> Self {\n+        Flatten { inner: self.inner.clone() }\n+    }\n }\n \n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n@@ -145,21 +169,29 @@ where\n     type Item = U::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+    fn next(&mut self) -> Option<U::Item> {\n+        self.inner.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.inner.try_fold(init, fold)\n     }\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.inner.fold(init, fold)\n     }\n@@ -172,18 +204,24 @@ where\n     U: DoubleEndedIterator,\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<U::Item> {\n+        self.inner.next_back()\n+    }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.inner.try_rfold(init, fold)\n     }\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.inner.rfold(init, fold)\n     }\n@@ -194,7 +232,8 @@ impl<I, U> FusedIterator for Flatten<I>\n where\n     I: FusedIterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n     U: Iterator,\n-{}\n+{\n+}\n \n /// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n /// this type.\n@@ -222,7 +261,9 @@ where\n     fn next(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.frontiter {\n-                if let elt@Some(_) = inner.next() { return elt }\n+                if let elt @ Some(_) = inner.next() {\n+                    return elt;\n+                }\n             }\n             match self.iter.next() {\n                 None => return self.backiter.as_mut()?.next(),\n@@ -238,13 +279,16 @@ where\n         let lo = flo.saturating_add(blo);\n         match (self.iter.size_hint(), fhi, bhi) {\n             ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n-            _ => (lo, None)\n+            _ => (lo, None),\n         }\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         #[inline]\n         fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n@@ -277,7 +321,8 @@ where\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         #[inline]\n         fn flatten<U: Iterator, Acc>(\n@@ -286,7 +331,8 @@ where\n             move |acc, iter| iter.fold(acc, &mut *fold)\n         }\n \n-        self.frontiter.into_iter()\n+        self.frontiter\n+            .into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n             .fold(init, flatten(fold))\n@@ -302,7 +348,9 @@ where\n     fn next_back(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.backiter {\n-                if let elt@Some(_) = inner.next_back() { return elt }\n+                if let elt @ Some(_) = inner.next_back() {\n+                    return elt;\n+                }\n             }\n             match self.iter.next_back() {\n                 None => return self.frontiter.as_mut()?.next_back(),\n@@ -312,14 +360,18 @@ where\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         #[inline]\n         fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n             backiter: &'a mut Option<T::IntoIter>,\n             fold: &'a mut impl FnMut(Acc, T::Item) -> R,\n-        ) -> impl FnMut(Acc, T) -> R + 'a where\n+        ) -> impl FnMut(Acc, T) -> R + 'a\n+        where\n             T::IntoIter: DoubleEndedIterator,\n         {\n             move |acc, x| {\n@@ -348,7 +400,8 @@ where\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         #[inline]\n         fn flatten<U: DoubleEndedIterator, Acc>(\n@@ -357,7 +410,8 @@ where\n             move |acc, iter| iter.rfold(acc, &mut *fold)\n         }\n \n-        self.frontiter.into_iter()\n+        self.frontiter\n+            .into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n             .rfold(init, flatten(fold))"}, {"sha": "ffac7d4e995389981fcb65d557cba78457751df4", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -12,23 +12,29 @@ use super::{FusedIterator, TrustedLen};\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Repeat<A> {\n-    element: A\n+    element: A,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> Iterator for Repeat<A> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> { Some(self.element.clone()) }\n+    fn next(&mut self) -> Option<A> {\n+        Some(self.element.clone())\n+    }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { Some(self.element.clone()) }\n+    fn next_back(&mut self) -> Option<A> {\n+        Some(self.element.clone())\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -91,7 +97,7 @@ unsafe impl<A: Clone> TrustedLen for Repeat<A> {}\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n-    Repeat{element: elt}\n+    Repeat { element: elt }\n }\n \n /// An iterator that repeats elements of type `A` endlessly by\n@@ -104,18 +110,22 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n #[derive(Copy, Clone, Debug)]\n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n pub struct RepeatWith<F> {\n-    repeater: F\n+    repeater: F,\n }\n \n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n impl<A, F: FnMut() -> A> Iterator for RepeatWith<F> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> { Some((self.repeater)()) }\n+    fn next(&mut self) -> Option<A> {\n+        Some((self.repeater)())\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n }\n \n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n@@ -213,7 +223,7 @@ impl<T> Iterator for Empty<T> {\n         None\n     }\n \n-    fn size_hint(&self) -> (usize, Option<usize>){\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         (0, Some(0))\n     }\n }\n@@ -283,7 +293,7 @@ pub const fn empty<T>() -> Empty<T> {\n #[derive(Clone, Debug)]\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n pub struct Once<T> {\n-    inner: crate::option::IntoIter<T>\n+    inner: crate::option::IntoIter<T>,\n }\n \n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n@@ -530,7 +540,8 @@ pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n #[inline]\n #[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n pub fn from_fn<T, F>(f: F) -> FromFn<F>\n-    where F: FnMut() -> Option<T>\n+where\n+    F: FnMut() -> Option<T>,\n {\n     FromFn(f)\n }\n@@ -547,7 +558,8 @@ pub struct FromFn<F>(F);\n \n #[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n impl<T, F> Iterator for FromFn<F>\n-    where F: FnMut() -> Option<T>\n+where\n+    F: FnMut() -> Option<T>,\n {\n     type Item = T;\n \n@@ -577,15 +589,13 @@ impl<F> fmt::Debug for FromFn<F> {\n /// ```\n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n pub fn successors<T, F>(first: Option<T>, succ: F) -> Successors<T, F>\n-    where F: FnMut(&T) -> Option<T>\n+where\n+    F: FnMut(&T) -> Option<T>,\n {\n     // If this function returned `impl Iterator<Item=T>`\n     // it could be based on `unfold` and not need a dedicated type.\n     // However having a named `Successors<T, F>` type allows it to be `Clone` when `T` and `F` are.\n-    Successors {\n-        next: first,\n-        succ,\n-    }\n+    Successors { next: first, succ }\n }\n \n /// An new iterator where each successive item is computed based on the preceding one.\n@@ -603,7 +613,8 @@ pub struct Successors<T, F> {\n \n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n impl<T, F> Iterator for Successors<T, F>\n-    where F: FnMut(&T) -> Option<T>\n+where\n+    F: FnMut(&T) -> Option<T>,\n {\n     type Item = T;\n \n@@ -616,24 +627,16 @@ impl<T, F> Iterator for Successors<T, F>\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.next.is_some() {\n-            (1, None)\n-        } else {\n-            (0, Some(0))\n-        }\n+        if self.next.is_some() { (1, None) } else { (0, Some(0)) }\n     }\n }\n \n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-impl<T, F> FusedIterator for Successors<T, F>\n-    where F: FnMut(&T) -> Option<T>\n-{}\n+impl<T, F> FusedIterator for Successors<T, F> where F: FnMut(&T) -> Option<T> {}\n \n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n impl<T: fmt::Debug, F> fmt::Debug for Successors<T, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Successors\")\n-            .field(\"next\", &self.next)\n-            .finish()\n+        f.debug_struct(\"Successors\").field(\"next\", &self.next).finish()\n     }\n }"}, {"sha": "65af671ddf2045005f24cf1a8b92a1eea5eb7e4b", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,6 +1,6 @@\n-use crate::ops::{Mul, Add};\n-use crate::num::Wrapping;\n use crate::iter;\n+use crate::num::Wrapping;\n+use crate::ops::{Add, Mul};\n \n /// Trait to represent types that can be created by summing up an iterator.\n ///\n@@ -17,7 +17,7 @@ pub trait Sum<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by\n     /// \"summing up\" the items.\n     #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-    fn sum<I: Iterator<Item=A>>(iter: I) -> Self;\n+    fn sum<I: Iterator<Item = A>>(iter: I) -> Self;\n }\n \n /// Trait to represent types that can be created by multiplying elements of an\n@@ -36,7 +36,7 @@ pub trait Product<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by\n     /// multiplying the items.\n     #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-    fn product<I: Iterator<Item=A>>(iter: I) -> Self;\n+    fn product<I: Iterator<Item = A>>(iter: I) -> Self;\n }\n \n // N.B., explicitly use Add and Mul here to inherit overflow checks\n@@ -115,9 +115,10 @@ macro_rules! float_sum_product {\n integer_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n float_sum_product! { f32 f64 }\n \n-#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n+#[stable(feature = \"iter_arith_traits_result\", since = \"1.16.0\")]\n impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n-    where T: Sum<U>,\n+where\n+    T: Sum<U>,\n {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n@@ -137,21 +138,24 @@ impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n     /// assert_eq!(res, Ok(3));\n     /// ```\n     fn sum<I>(iter: I) -> Result<T, E>\n-        where I: Iterator<Item = Result<U, E>>,\n+    where\n+        I: Iterator<Item = Result<U, E>>,\n     {\n         iter::process_results(iter, |i| i.sum())\n     }\n }\n \n-#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n+#[stable(feature = \"iter_arith_traits_result\", since = \"1.16.0\")]\n impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n-    where T: Product<U>,\n+where\n+    T: Product<U>,\n {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n     /// the product of all elements is returned.\n     fn product<I>(iter: I) -> Result<T, E>\n-        where I: Iterator<Item = Result<U, E>>,\n+    where\n+        I: Iterator<Item = Result<U, E>>,\n     {\n         iter::process_results(iter, |i| i.product())\n     }"}, {"sha": "d6ae5cfe9e00e86147358de9996c063e89461f70", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -91,9 +91,9 @@\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n-    message=\"a collection of type `{Self}` cannot be built from an iterator \\\n+    message=\"a value of type `{Self}` cannot be built from an iterator \\\n              over elements of type `{A}`\",\n-    label=\"a collection of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\",\n+    label=\"value of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\",\n )]\n pub trait FromIterator<A>: Sized {\n     /// Creates a value from an iterator."}, {"sha": "104724d9fb63a2bae43f7e5c14f0fa08a0928054", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,5 +1,5 @@\n-use crate::ops::Try;\n use crate::iter::LoopState;\n+use crate::ops::Try;\n \n /// An iterator able to yield elements from both ends.\n ///\n@@ -113,7 +113,9 @@ pub trait DoubleEndedIterator: Iterator {\n     #[stable(feature = \"iter_nth_back\", since = \"1.37.0\")]\n     fn nth_back(&mut self, mut n: usize) -> Option<Self::Item> {\n         for x in self.rev() {\n-            if n == 0 { return Some(x) }\n+            if n == 0 {\n+                return Some(x);\n+            }\n             n -= 1;\n         }\n         None\n@@ -157,7 +159,7 @@ pub trait DoubleEndedIterator: Iterator {\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok=B>\n+        R: Try<Ok = B>,\n     {\n         let mut accum = init;\n         while let Some(x) = self.next_back() {\n@@ -279,7 +281,7 @@ pub trait DoubleEndedIterator: Iterator {\n     fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         Self: Sized,\n-        P: FnMut(&Self::Item) -> bool\n+        P: FnMut(&Self::Item) -> bool,\n     {\n         #[inline]\n         fn check<T>("}, {"sha": "8a514f1e78e807d6efe5889931709ba6a241b52e", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -74,6 +74,8 @@\n #![feature(const_fn)]\n #![feature(const_fn_union)]\n #![feature(const_generics)]\n+#![cfg_attr(not(bootstrap), feature(const_ptr_offset_from))]\n+#![cfg_attr(not(bootstrap), feature(const_type_name))]\n #![feature(custom_inner_attributes)]\n #![feature(decl_macro)]\n #![feature(doc_cfg)]\n@@ -100,6 +102,7 @@\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(stmt_expr_attributes)]\n+#![cfg_attr(not(bootstrap), feature(track_caller))]\n #![feature(transparent_unions)]\n #![feature(unboxed_closures)]\n #![feature(unsized_locals)]"}, {"sha": "cf460745ffa3032faea6500731a7c0cffcbeda80", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 141, "deletions": 64, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -337,13 +337,17 @@ macro_rules! matches {\n #[rustc_deprecated(since = \"1.39.0\", reason = \"use the `?` operator instead\")]\n #[doc(alias = \"?\")]\n macro_rules! r#try {\n-    ($expr:expr) => (match $expr {\n-        $crate::result::Result::Ok(val) => val,\n-        $crate::result::Result::Err(err) => {\n-            return $crate::result::Result::Err($crate::convert::From::from(err))\n+    ($expr:expr) => {\n+        match $expr {\n+            $crate::result::Result::Ok(val) => val,\n+            $crate::result::Result::Err(err) => {\n+                return $crate::result::Result::Err($crate::convert::From::from(err));\n+            }\n         }\n-    });\n-    ($expr:expr,) => ($crate::r#try!($expr));\n+    };\n+    ($expr:expr,) => {\n+        $crate::r#try!($expr)\n+    };\n }\n \n /// Writes formatted data into a buffer.\n@@ -734,8 +738,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! compile_error {\n-        ($msg:expr) => ({ /* compiler built-in */ });\n-        ($msg:expr,) => ({ /* compiler built-in */ })\n+        ($msg:expr) => {{ /* compiler built-in */ }};\n+        ($msg:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Constructs parameters for the other string-formatting macros.\n@@ -788,20 +792,23 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! format_args {\n-        ($fmt:expr) => ({ /* compiler built-in */ });\n-        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+        ($fmt:expr) => {{ /* compiler built-in */ }};\n+        ($fmt:expr, $($args:tt)*) => {{ /* compiler built-in */ }};\n     }\n \n     /// Same as `format_args`, but adds a newline in the end.\n-    #[unstable(feature = \"format_args_nl\", issue = \"0\",\n-               reason = \"`format_args_nl` is only for internal \\\n-                         language use and is subject to change\")]\n+    #[unstable(\n+        feature = \"format_args_nl\",\n+        issue = \"0\",\n+        reason = \"`format_args_nl` is only for internal \\\n+                  language use and is subject to change\"\n+    )]\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! format_args_nl {\n-        ($fmt:expr) => ({ /* compiler built-in */ });\n-        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+        ($fmt:expr) => {{ /* compiler built-in */ }};\n+        ($fmt:expr, $($args:tt)*) => {{ /* compiler built-in */ }};\n     }\n \n     /// Inspects an environment variable at compile time.\n@@ -839,8 +846,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ })\n+        ($name:expr) => {{ /* compiler built-in */ }};\n+        ($name:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Optionally inspects an environment variable at compile time.\n@@ -866,8 +873,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! option_env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ })\n+        ($name:expr) => {{ /* compiler built-in */ }};\n+        ($name:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Concatenates identifiers into one identifier.\n@@ -894,13 +901,16 @@ pub(crate) mod builtin {\n     /// // fn concat_idents!(new, fun, name) { } // not usable in this way!\n     /// # }\n     /// ```\n-    #[unstable(feature = \"concat_idents\", issue = \"29599\",\n-               reason = \"`concat_idents` is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"concat_idents\",\n+        issue = \"29599\",\n+        reason = \"`concat_idents` is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! concat_idents {\n-        ($($e:ident),+) => ({ /* compiler built-in */ });\n-        ($($e:ident,)+) => ({ /* compiler built-in */ })\n+        ($($e:ident),+) => {{ /* compiler built-in */ }};\n+        ($($e:ident,)+) => {{ /* compiler built-in */ }};\n     }\n \n     /// Concatenates literals into a static string slice.\n@@ -922,8 +932,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! concat {\n-        ($($e:expr),*) => ({ /* compiler built-in */ });\n-        ($($e:expr,)*) => ({ /* compiler built-in */ })\n+        ($($e:expr),*) => {{ /* compiler built-in */ }};\n+        ($($e:expr,)*) => {{ /* compiler built-in */ }};\n     }\n \n     /// Expands to the line number on which it was invoked.\n@@ -950,7 +960,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! line { () => { /* compiler built-in */ } }\n+    macro_rules! line {\n+        () => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Expands to the column number at which it was invoked.\n     ///\n@@ -976,7 +990,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! column { () => { /* compiler built-in */ } }\n+    macro_rules! column {\n+        () => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Expands to the file name in which it was invoked.\n     ///\n@@ -1001,7 +1019,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! file { () => { /* compiler built-in */ } }\n+    macro_rules! file {\n+        () => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Stringifies its arguments.\n     ///\n@@ -1021,7 +1043,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! stringify { ($($t:tt)*) => { /* compiler built-in */ } }\n+    macro_rules! stringify {\n+        ($($t:tt)*) => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Includes a utf8-encoded file as a string.\n     ///\n@@ -1057,8 +1083,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! include_str {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ })\n+        ($file:expr) => {{ /* compiler built-in */ }};\n+        ($file:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Includes a file as a reference to a byte array.\n@@ -1095,8 +1121,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! include_bytes {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ })\n+        ($file:expr) => {{ /* compiler built-in */ }};\n+        ($file:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Expands to a string that represents the current module path.\n@@ -1119,7 +1145,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! module_path { () => { /* compiler built-in */ } }\n+    macro_rules! module_path {\n+        () => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Evaluates boolean combinations of configuration flags at compile-time.\n     ///\n@@ -1144,7 +1174,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! cfg { ($($cfg:tt)*) => { /* compiler built-in */ } }\n+    macro_rules! cfg {\n+        ($($cfg:tt)*) => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Parses a file as an expression or an item according to the context.\n     ///\n@@ -1189,8 +1223,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! include {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ })\n+        ($file:expr) => {{ /* compiler built-in */ }};\n+        ($file:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Asserts that a boolean expression is `true` at runtime.\n@@ -1242,85 +1276,128 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! assert {\n-        ($cond:expr) => ({ /* compiler built-in */ });\n-        ($cond:expr,) => ({ /* compiler built-in */ });\n-        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ })\n+        ($cond:expr) => {{ /* compiler built-in */ }};\n+        ($cond:expr,) => {{ /* compiler built-in */ }};\n+        ($cond:expr, $($arg:tt)+) => {{ /* compiler built-in */ }};\n     }\n \n     /// Inline assembly.\n     ///\n     /// Read the [unstable book] for the usage.\n     ///\n     /// [unstable book]: ../unstable-book/library-features/asm.html\n-    #[unstable(feature = \"asm\", issue = \"29722\",\n-               reason = \"inline assembly is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"asm\",\n+        issue = \"29722\",\n+        reason = \"inline assembly is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! asm { (\"assembly template\"\n+    macro_rules! asm {\n+        (\"assembly template\"\n                         : $(\"output\"(operand),)*\n                         : $(\"input\"(operand),)*\n                         : $(\"clobbers\",)*\n-                        : $(\"options\",)*) => { /* compiler built-in */ } }\n+                        : $(\"options\",)*) => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Module-level inline assembly.\n-    #[unstable(feature = \"global_asm\", issue = \"35119\",\n-               reason = \"`global_asm!` is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"global_asm\",\n+        issue = \"35119\",\n+        reason = \"`global_asm!` is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! global_asm { (\"assembly\") => { /* compiler built-in */ } }\n+    macro_rules! global_asm {\n+        (\"assembly\") => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Prints passed tokens into the standard output.\n-    #[unstable(feature = \"log_syntax\", issue = \"29598\",\n-               reason = \"`log_syntax!` is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"log_syntax\",\n+        issue = \"29598\",\n+        reason = \"`log_syntax!` is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! log_syntax { ($($arg:tt)*) => { /* compiler built-in */ } }\n+    macro_rules! log_syntax {\n+        ($($arg:tt)*) => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Enables or disables tracing functionality used for debugging other macros.\n-    #[unstable(feature = \"trace_macros\", issue = \"29598\",\n-               reason = \"`trace_macros` is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"trace_macros\",\n+        issue = \"29598\",\n+        reason = \"`trace_macros` is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! trace_macros {\n-        (true) => ({ /* compiler built-in */ });\n-        (false) => ({ /* compiler built-in */ })\n+        (true) => {{ /* compiler built-in */ }};\n+        (false) => {{ /* compiler built-in */ }};\n     }\n \n     /// Attribute macro applied to a function to turn it into a unit test.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    pub macro test($item:item) { /* compiler built-in */ }\n+    pub macro test($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// Attribute macro applied to a function to turn it into a benchmark test.\n-    #[unstable(soft, feature = \"test\", issue = \"50297\",\n-               reason = \"`bench` is a part of custom test frameworks which are unstable\")]\n+    #[unstable(\n+        feature = \"test\",\n+        issue = \"50297\",\n+        soft,\n+        reason = \"`bench` is a part of custom test frameworks which are unstable\"\n+    )]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    pub macro bench($item:item) { /* compiler built-in */ }\n+    pub macro bench($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// An implementation detail of the `#[test]` and `#[bench]` macros.\n-    #[unstable(feature = \"custom_test_frameworks\", issue = \"50297\",\n-               reason = \"custom test frameworks are an unstable feature\")]\n+    #[unstable(\n+        feature = \"custom_test_frameworks\",\n+        issue = \"50297\",\n+        reason = \"custom test frameworks are an unstable feature\"\n+    )]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    pub macro test_case($item:item) { /* compiler built-in */ }\n+    pub macro test_case($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// Attribute macro applied to a static to register it as a global allocator.\n     #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n     #[allow_internal_unstable(rustc_attrs)]\n     #[rustc_builtin_macro]\n-    pub macro global_allocator($item:item) { /* compiler built-in */ }\n+    pub macro global_allocator($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n-    pub macro RustcDecodable($item:item) { /* compiler built-in */ }\n+    pub macro RustcDecodable($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n-    pub macro RustcEncodable($item:item) { /* compiler built-in */ }\n+    pub macro RustcEncodable($item:item) {\n+        /* compiler built-in */\n+    }\n }"}, {"sha": "34fc0618ea2ae182655e4db3e02b95a2ef9c846f", "filename": "src/libcore/mem/manually_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,5 +1,5 @@\n-use crate::ptr;\n use crate::ops::{Deref, DerefMut};\n+use crate::ptr;\n \n /// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n ///"}, {"sha": "6661df2ae0d8414c4a17e27102fc3b4d7acf345f", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,3 +1,5 @@\n+use crate::any::type_name;\n+use crate::fmt;\n use crate::intrinsics;\n use crate::mem::ManuallyDrop;\n \n@@ -232,6 +234,13 @@ impl<T: Copy> Clone for MaybeUninit<T> {\n     }\n }\n \n+#[stable(feature = \"maybe_uninit_debug\", since = \"1.41.0\")]\n+impl<T> fmt::Debug for MaybeUninit<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(type_name::<Self>())\n+    }\n+}\n+\n impl<T> MaybeUninit<T> {\n     /// Creates a new `MaybeUninit<T>` initialized with the given value.\n     /// It is safe to call [`assume_init`] on the return value of this function."}, {"sha": "b8ddd5322a1da04245272c1dfdc98f0c8aa99d67", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -12,13 +12,15 @@\n // This module is only for dec2flt and flt2dec, and only public because of coretests.\n // It is not intended to ever be stabilized.\n #![doc(hidden)]\n-#![unstable(feature = \"core_private_bignum\",\n-            reason = \"internal routines only exposed for testing\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"core_private_bignum\",\n+    reason = \"internal routines only exposed for testing\",\n+    issue = \"0\"\n+)]\n #![macro_use]\n \n-use crate::mem;\n use crate::intrinsics;\n+use crate::mem;\n \n /// Arithmetic operations required by bignums.\n pub trait FullOps: Sized {\n@@ -36,10 +38,8 @@ pub trait FullOps: Sized {\n \n     /// Returns `(quo, rem)` such that `borrow * 2^W + self = quo * other + rem`\n     /// and `0 <= rem < other`, where `W` is the number of bits in `Self`.\n-    fn full_div_rem(self,\n-                    other: Self,\n-                    borrow: Self)\n-                    -> (Self /* quotient */, Self /* remainder */);\n+    fn full_div_rem(self, other: Self, borrow: Self)\n+    -> (Self /* quotient */, Self /* remainder */);\n }\n \n macro_rules! impl_full_ops {\n@@ -98,7 +98,7 @@ impl_full_ops! {\n const SMALL_POW5: [(u64, usize); 3] = [(125, 3), (15625, 6), (1_220_703_125, 13)];\n \n macro_rules! define_bignum {\n-    ($name:ident: type=$ty:ty, n=$n:expr) => (\n+    ($name:ident: type=$ty:ty, n=$n:expr) => {\n         /// Stack-allocated arbitrary-precision (up to certain limit) integer.\n         ///\n         /// This is backed by a fixed-size array of given type (\"digit\").\n@@ -115,7 +115,7 @@ macro_rules! define_bignum {\n             size: usize,\n             /// Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`\n             /// where `W` is the number of bits in the digit type.\n-            base: [$ty; $n]\n+            base: [$ty; $n],\n         }\n \n         impl $name {\n@@ -180,7 +180,7 @@ macro_rules! define_bignum {\n                 }\n                 // This could be optimized with leading_zeros() and bit shifts, but that's\n                 // probably not worth the hassle.\n-                let digitbits = mem::size_of::<$ty>()* 8;\n+                let digitbits = mem::size_of::<$ty>() * 8;\n                 let mut i = nonzero.len() * digitbits - 1;\n                 while self.get_bit(i) == 0 {\n                     i -= 1;\n@@ -272,12 +272,12 @@ macro_rules! define_bignum {\n                 let bits = bits % digitbits;\n \n                 assert!(digits < $n);\n-                debug_assert!(self.base[$n-digits..].iter().all(|&v| v == 0));\n-                debug_assert!(bits == 0 || (self.base[$n-digits-1] >> (digitbits - bits)) == 0);\n+                debug_assert!(self.base[$n - digits..].iter().all(|&v| v == 0));\n+                debug_assert!(bits == 0 || (self.base[$n - digits - 1] >> (digitbits - bits)) == 0);\n \n                 // shift by `digits * digitbits` bits\n                 for i in (0..self.size).rev() {\n-                    self.base[i+digits] = self.base[i];\n+                    self.base[i + digits] = self.base[i];\n                 }\n                 for i in 0..digits {\n                     self.base[i] = 0;\n@@ -287,14 +287,14 @@ macro_rules! define_bignum {\n                 let mut sz = self.size + digits;\n                 if bits > 0 {\n                     let last = sz;\n-                    let overflow = self.base[last-1] >> (digitbits - bits);\n+                    let overflow = self.base[last - 1] >> (digitbits - bits);\n                     if overflow > 0 {\n                         self.base[last] = overflow;\n                         sz += 1;\n                     }\n-                    for i in (digits+1..last).rev() {\n-                        self.base[i] = (self.base[i] << bits) |\n-                                       (self.base[i-1] >> (digitbits - bits));\n+                    for i in (digits + 1..last).rev() {\n+                        self.base[i] =\n+                            (self.base[i] << bits) | (self.base[i - 1] >> (digitbits - bits));\n                     }\n                     self.base[digits] <<= bits;\n                     // self.base[..digits] is zero, no need to shift\n@@ -331,7 +331,6 @@ macro_rules! define_bignum {\n                 self\n             }\n \n-\n             /// Multiplies itself by a number described by `other[0] + other[1] * 2^W +\n             /// other[2] * 2^(2W) + ...` (where `W` is the number of bits in the digit type)\n             /// and returns its own mutable reference.\n@@ -342,7 +341,9 @@ macro_rules! define_bignum {\n \n                     let mut retsz = 0;\n                     for (i, &a) in aa.iter().enumerate() {\n-                        if a == 0 { continue; }\n+                        if a == 0 {\n+                            continue;\n+                        }\n                         let mut sz = bb.len();\n                         let mut carry = 0;\n                         for (j, &b) in bb.iter().enumerate() {\n@@ -430,11 +431,12 @@ macro_rules! define_bignum {\n         }\n \n         impl crate::cmp::PartialEq for $name {\n-            fn eq(&self, other: &$name) -> bool { self.base[..] == other.base[..] }\n+            fn eq(&self, other: &$name) -> bool {\n+                self.base[..] == other.base[..]\n+            }\n         }\n \n-        impl crate::cmp::Eq for $name {\n-        }\n+        impl crate::cmp::Eq for $name {}\n \n         impl crate::cmp::PartialOrd for $name {\n             fn partial_cmp(&self, other: &$name) -> crate::option::Option<crate::cmp::Ordering> {\n@@ -462,17 +464,17 @@ macro_rules! define_bignum {\n             fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n                 use crate::mem;\n \n-                let sz = if self.size < 1 {1} else {self.size};\n+                let sz = if self.size < 1 { 1 } else { self.size };\n                 let digitlen = mem::size_of::<$ty>() * 2;\n \n-                write!(f, \"{:#x}\", self.base[sz-1])?;\n-                for &v in self.base[..sz-1].iter().rev() {\n+                write!(f, \"{:#x}\", self.base[sz - 1])?;\n+                for &v in self.base[..sz - 1].iter().rev() {\n                     write!(f, \"_{:01$x}\", v, digitlen)?;\n                 }\n                 crate::result::Result::Ok(())\n             }\n         }\n-    )\n+    };\n }\n \n /// The digit type for `Big32x40`."}, {"sha": "c5f6903f379c405cc294695ddb5d129044ba67c0", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,11 +1,11 @@\n //! The various algorithms from the paper.\n \n use crate::cmp::min;\n-use crate::cmp::Ordering::{Less, Equal, Greater};\n-use crate::num::diy_float::Fp;\n-use crate::num::dec2flt::table;\n-use crate::num::dec2flt::rawfp::{self, Unpacked, RawFloat, fp_to_float, next_float, prev_float};\n+use crate::cmp::Ordering::{Equal, Greater, Less};\n use crate::num::dec2flt::num::{self, Big};\n+use crate::num::dec2flt::rawfp::{self, fp_to_float, next_float, prev_float, RawFloat, Unpacked};\n+use crate::num::dec2flt::table;\n+use crate::num::diy_float::Fp;\n \n /// Number of significand bits in Fp\n const P: u32 = 64;\n@@ -23,17 +23,17 @@ fn power_of_ten(e: i16) -> Fp {\n \n // In most architectures, floating point operations have an explicit bit size, therefore the\n // precision of the computation is determined on a per-operation basis.\n-#[cfg(any(not(target_arch=\"x86\"), target_feature=\"sse2\"))]\n+#[cfg(any(not(target_arch = \"x86\"), target_feature = \"sse2\"))]\n mod fpu_precision {\n-    pub fn set_precision<T>() { }\n+    pub fn set_precision<T>() {}\n }\n \n // On x86, the x87 FPU is used for float operations if the SSE/SSE2 extensions are not available.\n // The x87 FPU operates with 80 bits of precision by default, which means that operations will\n // round to 80 bits causing double rounding to happen when values are eventually represented as\n // 32/64 bit float values. To overcome this, the FPU control word can be set so that the\n // computations are performed in the desired precision.\n-#[cfg(all(target_arch=\"x86\", not(target_feature=\"sse2\")))]\n+#[cfg(all(target_arch = \"x86\", not(target_feature = \"sse2\")))]\n mod fpu_precision {\n     use crate::mem::size_of;\n "}, {"sha": "6fe9af8cbd8ee93bd2cd00067a398a0f594a233d", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -78,23 +78,25 @@\n //! turned into {positive,negative} {zero,infinity}.\n \n #![doc(hidden)]\n-#![unstable(feature = \"dec2flt\",\n-            reason = \"internal routines only exposed for testing\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"dec2flt\",\n+    reason = \"internal routines only exposed for testing\",\n+    issue = \"0\"\n+)]\n \n use crate::fmt;\n use crate::str::FromStr;\n \n-use self::parse::{parse_decimal, Decimal, Sign, ParseResult};\n use self::num::digits_to_big;\n+use self::parse::{parse_decimal, Decimal, ParseResult, Sign};\n use self::rawfp::RawFloat;\n \n mod algorithm;\n-mod table;\n mod num;\n+mod table;\n // These two have their own tests.\n-pub mod rawfp;\n pub mod parse;\n+pub mod rawfp;\n \n macro_rules! from_str_float_impl {\n     ($t:ty) => {\n@@ -155,7 +157,7 @@ macro_rules! from_str_float_impl {\n                 dec2flt(src)\n             }\n         }\n-    }\n+    };\n }\n from_str_float_impl!(f32);\n from_str_float_impl!(f64);\n@@ -171,7 +173,7 @@ from_str_float_impl!(f64);\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseFloatError {\n-    kind: FloatErrorKind\n+    kind: FloatErrorKind,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -181,10 +183,12 @@ enum FloatErrorKind {\n }\n \n impl ParseFloatError {\n-    #[unstable(feature = \"int_error_internals\",\n-               reason = \"available through Error trait and this method should \\\n-                         not be exposed publicly\",\n-               issue = \"0\")]\n+    #[unstable(\n+        feature = \"int_error_internals\",\n+        reason = \"available through Error trait and this method should \\\n+                  not be exposed publicly\",\n+        issue = \"0\"\n+    )]\n     #[doc(hidden)]\n     pub fn __description(&self) -> &str {\n         match self.kind {\n@@ -222,7 +226,7 @@ fn extract_sign(s: &str) -> (Sign, &str) {\n /// Converts a decimal string into a floating point number.\n fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n     if s.is_empty() {\n-        return Err(pfe_empty())\n+        return Err(pfe_empty());\n     }\n     let (sign, s) = extract_sign(s);\n     let flt = match parse_decimal(s) {\n@@ -232,8 +236,10 @@ fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n         ParseResult::Invalid => match s {\n             \"inf\" => T::INFINITY,\n             \"NaN\" => T::NAN,\n-            _ => { return Err(pfe_invalid()); }\n-        }\n+            _ => {\n+                return Err(pfe_invalid());\n+            }\n+        },\n     };\n \n     match sign {"}, {"sha": "208783dd32fd5df8c271cbb0c69e308b4f3e1f2b", "filename": "src/libcore/num/dec2flt/num.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -2,7 +2,7 @@\n \n // FIXME This module's name is a bit unfortunate, since other modules also import `core::num`.\n \n-use crate::cmp::Ordering::{self, Less, Equal, Greater};\n+use crate::cmp::Ordering::{self, Equal, Greater, Less};\n \n pub use crate::num::bignum::Big32x40 as Big;\n \n@@ -36,7 +36,10 @@ pub fn compare_with_half_ulp(f: &Big, ones_place: usize) -> Ordering {\n /// 1. using `FromStr` on `&[u8]` requires `from_utf8_unchecked`, which is bad, and\n /// 2. piecing together the results of `integral.parse()` and `fractional.parse()` is\n ///    more complicated than this entire function.\n-pub fn from_str_unchecked<'a, T>(bytes: T) -> u64 where T : IntoIterator<Item=&'a u8> {\n+pub fn from_str_unchecked<'a, T>(bytes: T) -> u64\n+where\n+    T: IntoIterator<Item = &'a u8>,\n+{\n     let mut result = 0;\n     for &c in bytes {\n         result = result * 10 + (c - b'0') as u64;\n@@ -61,14 +64,9 @@ pub fn digits_to_big(integral: &[u8], fractional: &[u8]) -> Big {\n pub fn to_u64(x: &Big) -> u64 {\n     assert!(x.bit_length() < 64);\n     let d = x.digits();\n-    if d.len() < 2 {\n-        d[0] as u64\n-    } else {\n-        (d[1] as u64) << 32 | d[0] as u64\n-    }\n+    if d.len() < 2 { d[0] as u64 } else { (d[1] as u64) << 32 | d[0] as u64 }\n }\n \n-\n /// Extracts a range of bits.\n \n /// Index 0 is the least significant bit and the range is half-open as usual."}, {"sha": "93b08bce853c7e44e143229016be2572232b07af", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -10,8 +10,8 @@\n //! modules rely on to not panic (or overflow) in turn.\n //! To make matters worse, all that happens in a single pass over the input.\n //! So, be careful when modifying anything, and double-check with the other modules.\n+use self::ParseResult::{Invalid, ShortcutToInf, ShortcutToZero, Valid};\n use super::num;\n-use self::ParseResult::{Valid, ShortcutToInf, ShortcutToZero, Invalid};\n \n #[derive(Debug)]\n pub enum Sign {"}, {"sha": "a127c6c3fa7ceef4b886664e4ae35da7a95951b2", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -17,15 +17,15 @@\n //! Many functions in this module only handle normal numbers. The dec2flt routines conservatively\n //! take the universally-correct slow path (Algorithm M) for very small and very large numbers.\n //! That algorithm needs only next_float() which does handle subnormals and zeros.\n-use crate::cmp::Ordering::{Less, Equal, Greater};\n+use crate::cmp::Ordering::{Equal, Greater, Less};\n use crate::convert::{TryFrom, TryInto};\n-use crate::ops::{Add, Mul, Div, Neg};\n use crate::fmt::{Debug, LowerExp};\n-use crate::num::diy_float::Fp;\n-use crate::num::FpCategory::{Infinite, Zero, Subnormal, Normal, Nan};\n-use crate::num::FpCategory;\n use crate::num::dec2flt::num::{self, Big};\n use crate::num::dec2flt::table;\n+use crate::num::diy_float::Fp;\n+use crate::num::FpCategory;\n+use crate::num::FpCategory::{Infinite, Nan, Normal, Subnormal, Zero};\n+use crate::ops::{Add, Div, Mul, Neg};\n \n #[derive(Copy, Clone, Debug)]\n pub struct Unpacked {\n@@ -44,13 +44,8 @@ impl Unpacked {\n /// See the parent module's doc comment for why this is necessary.\n ///\n /// Should **never ever** be implemented for other types or be used outside the dec2flt module.\n-pub trait RawFloat\n-    : Copy\n-    + Debug\n-    + LowerExp\n-    + Mul<Output=Self>\n-    + Div<Output=Self>\n-    + Neg<Output=Self>\n+pub trait RawFloat:\n+    Copy + Debug + LowerExp + Mul<Output = Self> + Div<Output = Self> + Neg<Output = Self>\n {\n     const INFINITY: Self;\n     const NAN: Self;\n@@ -144,7 +139,7 @@ macro_rules! other_constants {\n         const INFINITY: Self = $crate::$type::INFINITY;\n         const NAN: Self = $crate::$type::NAN;\n         const ZERO: Self = 0.0;\n-    }\n+    };\n }\n \n impl RawFloat for f32 {\n@@ -163,11 +158,8 @@ impl RawFloat for f32 {\n         let bits = self.to_bits();\n         let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0x7fffff) << 1\n-        } else {\n-            (bits & 0x7fffff) | 0x800000\n-        };\n+        let mantissa =\n+            if exponent == 0 { (bits & 0x7fffff) << 1 } else { (bits & 0x7fffff) | 0x800000 };\n         // Exponent bias + mantissa shift\n         exponent -= 127 + 23;\n         (mantissa as u64, exponent, sign)\n@@ -188,12 +180,17 @@ impl RawFloat for f32 {\n         table::F32_SHORT_POWERS[e]\n     }\n \n-    fn classify(self) -> FpCategory { self.classify() }\n-    fn to_bits(self) -> Self::Bits { self.to_bits() }\n-    fn from_bits(v: Self::Bits) -> Self { Self::from_bits(v) }\n+    fn classify(self) -> FpCategory {\n+        self.classify()\n+    }\n+    fn to_bits(self) -> Self::Bits {\n+        self.to_bits()\n+    }\n+    fn from_bits(v: Self::Bits) -> Self {\n+        Self::from_bits(v)\n+    }\n }\n \n-\n impl RawFloat for f64 {\n     type Bits = u64;\n \n@@ -235,9 +232,15 @@ impl RawFloat for f64 {\n         table::F64_SHORT_POWERS[e]\n     }\n \n-    fn classify(self) -> FpCategory { self.classify() }\n-    fn to_bits(self) -> Self::Bits { self.to_bits() }\n-    fn from_bits(v: Self::Bits) -> Self { Self::from_bits(v) }\n+    fn classify(self) -> FpCategory {\n+        self.classify()\n+    }\n+    fn to_bits(self) -> Self::Bits {\n+        self.to_bits()\n+    }\n+    fn from_bits(v: Self::Bits) -> Self {\n+        Self::from_bits(v)\n+    }\n }\n \n /// Converts an `Fp` to the closest machine float type.\n@@ -248,7 +251,7 @@ pub fn fp_to_float<T: RawFloat>(x: Fp) -> T {\n     let e = x.e + 63;\n     if e > T::MAX_EXP {\n         panic!(\"fp_to_float: exponent {} too large\", e)\n-    }  else if e > T::MIN_EXP {\n+    } else if e > T::MIN_EXP {\n         encode_normal(round_normal::<T>(x))\n     } else {\n         panic!(\"fp_to_float: exponent {} too small\", e)\n@@ -278,14 +281,15 @@ pub fn round_normal<T: RawFloat>(x: Fp) -> Unpacked {\n /// Inverse of `RawFloat::unpack()` for normalized numbers.\n /// Panics if the significand or exponent are not valid for normalized numbers.\n pub fn encode_normal<T: RawFloat>(x: Unpacked) -> T {\n-    debug_assert!(T::MIN_SIG <= x.sig && x.sig <= T::MAX_SIG,\n-        \"encode_normal: significand not normalized\");\n+    debug_assert!(\n+        T::MIN_SIG <= x.sig && x.sig <= T::MAX_SIG,\n+        \"encode_normal: significand not normalized\"\n+    );\n     // Remove the hidden bit\n     let sig_enc = x.sig & !(1 << T::EXPLICIT_SIG_BITS);\n     // Adjust the exponent for exponent bias and mantissa shift\n     let k_enc = x.k + T::MAX_EXP + T::EXPLICIT_SIG_BITS as i16;\n-    debug_assert!(k_enc != 0 && k_enc < T::MAX_ENCODED_EXP,\n-        \"encode_normal: exponent out of range\");\n+    debug_assert!(k_enc != 0 && k_enc < T::MAX_ENCODED_EXP, \"encode_normal: exponent out of range\");\n     // Leave sign bit at 0 (\"+\"), our numbers are all positive\n     let bits = (k_enc as u64) << T::EXPLICIT_SIG_BITS | sig_enc;\n     T::from_bits(bits.try_into().unwrap_or_else(|_| unreachable!()))\n@@ -315,7 +319,7 @@ pub fn big_to_fp(f: &Big) -> Fp {\n         Equal | Greater => match leading.checked_add(1) {\n             Some(f) => Fp { f, e }.normalize(),\n             None => Fp { f: 1 << 63, e: e + 1 },\n-        }\n+        },\n     }\n }\n \n@@ -354,8 +358,6 @@ pub fn next_float<T: RawFloat>(x: T) -> T {\n         // want, and the mantissa bits become zero. Because of the hidden bit convention, this\n         // too is exactly what we want!\n         // Finally, f64::MAX + 1 = 7eff...f + 1 = 7ff0...0 = f64::INFINITY.\n-        Zero | Subnormal | Normal => {\n-            T::from_bits(x.to_bits() + T::Bits::from(1u8))\n-        }\n+        Zero | Subnormal | Normal => T::from_bits(x.to_bits() + T::Bits::from(1u8)),\n     }\n }"}, {"sha": "1bd94ffa04e0e327b011271e294c4b8f5e20ec57", "filename": "src/libcore/num/dec2flt/table.rs", "status": "modified", "additions": 1231, "deletions": 1225, "changes": 2456, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdec2flt%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdec2flt%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Ftable.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -4,1232 +4,1237 @@\n pub const MIN_E: i16 = -305;\n pub const MAX_E: i16 = 305;\n \n-pub const POWERS: ([u64; 611], [i16; 611]) = ([\n-    0xe0b62e2929aba83c,\n-    0x8c71dcd9ba0b4926,\n-    0xaf8e5410288e1b6f,\n-    0xdb71e91432b1a24b,\n-    0x892731ac9faf056f,\n-    0xab70fe17c79ac6ca,\n-    0xd64d3d9db981787d,\n-    0x85f0468293f0eb4e,\n-    0xa76c582338ed2622,\n-    0xd1476e2c07286faa,\n-    0x82cca4db847945ca,\n-    0xa37fce126597973d,\n-    0xcc5fc196fefd7d0c,\n-    0xff77b1fcbebcdc4f,\n-    0x9faacf3df73609b1,\n-    0xc795830d75038c1e,\n-    0xf97ae3d0d2446f25,\n-    0x9becce62836ac577,\n-    0xc2e801fb244576d5,\n-    0xf3a20279ed56d48a,\n-    0x9845418c345644d7,\n-    0xbe5691ef416bd60c,\n-    0xedec366b11c6cb8f,\n-    0x94b3a202eb1c3f39,\n-    0xb9e08a83a5e34f08,\n-    0xe858ad248f5c22ca,\n-    0x91376c36d99995be,\n-    0xb58547448ffffb2e,\n-    0xe2e69915b3fff9f9,\n-    0x8dd01fad907ffc3c,\n-    0xb1442798f49ffb4b,\n-    0xdd95317f31c7fa1d,\n-    0x8a7d3eef7f1cfc52,\n-    0xad1c8eab5ee43b67,\n-    0xd863b256369d4a41,\n-    0x873e4f75e2224e68,\n-    0xa90de3535aaae202,\n-    0xd3515c2831559a83,\n-    0x8412d9991ed58092,\n-    0xa5178fff668ae0b6,\n-    0xce5d73ff402d98e4,\n-    0x80fa687f881c7f8e,\n-    0xa139029f6a239f72,\n-    0xc987434744ac874f,\n-    0xfbe9141915d7a922,\n-    0x9d71ac8fada6c9b5,\n-    0xc4ce17b399107c23,\n-    0xf6019da07f549b2b,\n-    0x99c102844f94e0fb,\n-    0xc0314325637a193a,\n-    0xf03d93eebc589f88,\n-    0x96267c7535b763b5,\n-    0xbbb01b9283253ca3,\n-    0xea9c227723ee8bcb,\n-    0x92a1958a7675175f,\n-    0xb749faed14125d37,\n-    0xe51c79a85916f485,\n-    0x8f31cc0937ae58d3,\n-    0xb2fe3f0b8599ef08,\n-    0xdfbdcece67006ac9,\n-    0x8bd6a141006042be,\n-    0xaecc49914078536d,\n-    0xda7f5bf590966849,\n-    0x888f99797a5e012d,\n-    0xaab37fd7d8f58179,\n-    0xd5605fcdcf32e1d7,\n-    0x855c3be0a17fcd26,\n-    0xa6b34ad8c9dfc070,\n-    0xd0601d8efc57b08c,\n-    0x823c12795db6ce57,\n-    0xa2cb1717b52481ed,\n-    0xcb7ddcdda26da269,\n-    0xfe5d54150b090b03,\n-    0x9efa548d26e5a6e2,\n-    0xc6b8e9b0709f109a,\n-    0xf867241c8cc6d4c1,\n-    0x9b407691d7fc44f8,\n-    0xc21094364dfb5637,\n-    0xf294b943e17a2bc4,\n-    0x979cf3ca6cec5b5b,\n-    0xbd8430bd08277231,\n-    0xece53cec4a314ebe,\n-    0x940f4613ae5ed137,\n-    0xb913179899f68584,\n-    0xe757dd7ec07426e5,\n-    0x9096ea6f3848984f,\n-    0xb4bca50b065abe63,\n-    0xe1ebce4dc7f16dfc,\n-    0x8d3360f09cf6e4bd,\n-    0xb080392cc4349ded,\n-    0xdca04777f541c568,\n-    0x89e42caaf9491b61,\n-    0xac5d37d5b79b6239,\n-    0xd77485cb25823ac7,\n-    0x86a8d39ef77164bd,\n-    0xa8530886b54dbdec,\n-    0xd267caa862a12d67,\n-    0x8380dea93da4bc60,\n-    0xa46116538d0deb78,\n-    0xcd795be870516656,\n-    0x806bd9714632dff6,\n-    0xa086cfcd97bf97f4,\n-    0xc8a883c0fdaf7df0,\n-    0xfad2a4b13d1b5d6c,\n-    0x9cc3a6eec6311a64,\n-    0xc3f490aa77bd60fd,\n-    0xf4f1b4d515acb93c,\n-    0x991711052d8bf3c5,\n-    0xbf5cd54678eef0b7,\n-    0xef340a98172aace5,\n-    0x9580869f0e7aac0f,\n-    0xbae0a846d2195713,\n-    0xe998d258869facd7,\n-    0x91ff83775423cc06,\n-    0xb67f6455292cbf08,\n-    0xe41f3d6a7377eeca,\n-    0x8e938662882af53e,\n-    0xb23867fb2a35b28e,\n-    0xdec681f9f4c31f31,\n-    0x8b3c113c38f9f37f,\n-    0xae0b158b4738705f,\n-    0xd98ddaee19068c76,\n-    0x87f8a8d4cfa417ca,\n-    0xa9f6d30a038d1dbc,\n-    0xd47487cc8470652b,\n-    0x84c8d4dfd2c63f3b,\n-    0xa5fb0a17c777cf0a,\n-    0xcf79cc9db955c2cc,\n-    0x81ac1fe293d599c0,\n-    0xa21727db38cb0030,\n-    0xca9cf1d206fdc03c,\n-    0xfd442e4688bd304b,\n-    0x9e4a9cec15763e2f,\n-    0xc5dd44271ad3cdba,\n-    0xf7549530e188c129,\n-    0x9a94dd3e8cf578ba,\n-    0xc13a148e3032d6e8,\n-    0xf18899b1bc3f8ca2,\n-    0x96f5600f15a7b7e5,\n-    0xbcb2b812db11a5de,\n-    0xebdf661791d60f56,\n-    0x936b9fcebb25c996,\n-    0xb84687c269ef3bfb,\n-    0xe65829b3046b0afa,\n-    0x8ff71a0fe2c2e6dc,\n-    0xb3f4e093db73a093,\n-    0xe0f218b8d25088b8,\n-    0x8c974f7383725573,\n-    0xafbd2350644eead0,\n-    0xdbac6c247d62a584,\n-    0x894bc396ce5da772,\n-    0xab9eb47c81f5114f,\n-    0xd686619ba27255a3,\n-    0x8613fd0145877586,\n-    0xa798fc4196e952e7,\n-    0xd17f3b51fca3a7a1,\n-    0x82ef85133de648c5,\n-    0xa3ab66580d5fdaf6,\n-    0xcc963fee10b7d1b3,\n-    0xffbbcfe994e5c620,\n-    0x9fd561f1fd0f9bd4,\n-    0xc7caba6e7c5382c9,\n-    0xf9bd690a1b68637b,\n-    0x9c1661a651213e2d,\n-    0xc31bfa0fe5698db8,\n-    0xf3e2f893dec3f126,\n-    0x986ddb5c6b3a76b8,\n-    0xbe89523386091466,\n-    0xee2ba6c0678b597f,\n-    0x94db483840b717f0,\n-    0xba121a4650e4ddec,\n-    0xe896a0d7e51e1566,\n-    0x915e2486ef32cd60,\n-    0xb5b5ada8aaff80b8,\n-    0xe3231912d5bf60e6,\n-    0x8df5efabc5979c90,\n-    0xb1736b96b6fd83b4,\n-    0xddd0467c64bce4a1,\n-    0x8aa22c0dbef60ee4,\n-    0xad4ab7112eb3929e,\n-    0xd89d64d57a607745,\n-    0x87625f056c7c4a8b,\n-    0xa93af6c6c79b5d2e,\n-    0xd389b47879823479,\n-    0x843610cb4bf160cc,\n-    0xa54394fe1eedb8ff,\n-    0xce947a3da6a9273e,\n-    0x811ccc668829b887,\n-    0xa163ff802a3426a9,\n-    0xc9bcff6034c13053,\n-    0xfc2c3f3841f17c68,\n-    0x9d9ba7832936edc1,\n-    0xc5029163f384a931,\n-    0xf64335bcf065d37d,\n-    0x99ea0196163fa42e,\n-    0xc06481fb9bcf8d3a,\n-    0xf07da27a82c37088,\n-    0x964e858c91ba2655,\n-    0xbbe226efb628afeb,\n-    0xeadab0aba3b2dbe5,\n-    0x92c8ae6b464fc96f,\n-    0xb77ada0617e3bbcb,\n-    0xe55990879ddcaabe,\n-    0x8f57fa54c2a9eab7,\n-    0xb32df8e9f3546564,\n-    0xdff9772470297ebd,\n-    0x8bfbea76c619ef36,\n-    0xaefae51477a06b04,\n-    0xdab99e59958885c5,\n-    0x88b402f7fd75539b,\n-    0xaae103b5fcd2a882,\n-    0xd59944a37c0752a2,\n-    0x857fcae62d8493a5,\n-    0xa6dfbd9fb8e5b88f,\n-    0xd097ad07a71f26b2,\n-    0x825ecc24c8737830,\n-    0xa2f67f2dfa90563b,\n-    0xcbb41ef979346bca,\n-    0xfea126b7d78186bd,\n-    0x9f24b832e6b0f436,\n-    0xc6ede63fa05d3144,\n-    0xf8a95fcf88747d94,\n-    0x9b69dbe1b548ce7d,\n-    0xc24452da229b021c,\n-    0xf2d56790ab41c2a3,\n-    0x97c560ba6b0919a6,\n-    0xbdb6b8e905cb600f,\n-    0xed246723473e3813,\n-    0x9436c0760c86e30c,\n-    0xb94470938fa89bcf,\n-    0xe7958cb87392c2c3,\n-    0x90bd77f3483bb9ba,\n-    0xb4ecd5f01a4aa828,\n-    0xe2280b6c20dd5232,\n-    0x8d590723948a535f,\n-    0xb0af48ec79ace837,\n-    0xdcdb1b2798182245,\n-    0x8a08f0f8bf0f156b,\n-    0xac8b2d36eed2dac6,\n-    0xd7adf884aa879177,\n-    0x86ccbb52ea94baeb,\n-    0xa87fea27a539e9a5,\n-    0xd29fe4b18e88640f,\n-    0x83a3eeeef9153e89,\n-    0xa48ceaaab75a8e2b,\n-    0xcdb02555653131b6,\n-    0x808e17555f3ebf12,\n-    0xa0b19d2ab70e6ed6,\n-    0xc8de047564d20a8c,\n-    0xfb158592be068d2f,\n-    0x9ced737bb6c4183d,\n-    0xc428d05aa4751e4d,\n-    0xf53304714d9265e0,\n-    0x993fe2c6d07b7fac,\n-    0xbf8fdb78849a5f97,\n-    0xef73d256a5c0f77d,\n-    0x95a8637627989aae,\n-    0xbb127c53b17ec159,\n-    0xe9d71b689dde71b0,\n-    0x9226712162ab070e,\n-    0xb6b00d69bb55c8d1,\n-    0xe45c10c42a2b3b06,\n-    0x8eb98a7a9a5b04e3,\n-    0xb267ed1940f1c61c,\n-    0xdf01e85f912e37a3,\n-    0x8b61313bbabce2c6,\n-    0xae397d8aa96c1b78,\n-    0xd9c7dced53c72256,\n-    0x881cea14545c7575,\n-    0xaa242499697392d3,\n-    0xd4ad2dbfc3d07788,\n-    0x84ec3c97da624ab5,\n-    0xa6274bbdd0fadd62,\n-    0xcfb11ead453994ba,\n-    0x81ceb32c4b43fcf5,\n-    0xa2425ff75e14fc32,\n-    0xcad2f7f5359a3b3e,\n-    0xfd87b5f28300ca0e,\n-    0x9e74d1b791e07e48,\n-    0xc612062576589ddb,\n-    0xf79687aed3eec551,\n-    0x9abe14cd44753b53,\n-    0xc16d9a0095928a27,\n-    0xf1c90080baf72cb1,\n-    0x971da05074da7bef,\n-    0xbce5086492111aeb,\n-    0xec1e4a7db69561a5,\n-    0x9392ee8e921d5d07,\n-    0xb877aa3236a4b449,\n-    0xe69594bec44de15b,\n-    0x901d7cf73ab0acd9,\n-    0xb424dc35095cd80f,\n-    0xe12e13424bb40e13,\n-    0x8cbccc096f5088cc,\n-    0xafebff0bcb24aaff,\n-    0xdbe6fecebdedd5bf,\n-    0x89705f4136b4a597,\n-    0xabcc77118461cefd,\n-    0xd6bf94d5e57a42bc,\n-    0x8637bd05af6c69b6,\n-    0xa7c5ac471b478423,\n-    0xd1b71758e219652c,\n-    0x83126e978d4fdf3b,\n-    0xa3d70a3d70a3d70a,\n-    0xcccccccccccccccd,\n-    0x8000000000000000,\n-    0xa000000000000000,\n-    0xc800000000000000,\n-    0xfa00000000000000,\n-    0x9c40000000000000,\n-    0xc350000000000000,\n-    0xf424000000000000,\n-    0x9896800000000000,\n-    0xbebc200000000000,\n-    0xee6b280000000000,\n-    0x9502f90000000000,\n-    0xba43b74000000000,\n-    0xe8d4a51000000000,\n-    0x9184e72a00000000,\n-    0xb5e620f480000000,\n-    0xe35fa931a0000000,\n-    0x8e1bc9bf04000000,\n-    0xb1a2bc2ec5000000,\n-    0xde0b6b3a76400000,\n-    0x8ac7230489e80000,\n-    0xad78ebc5ac620000,\n-    0xd8d726b7177a8000,\n-    0x878678326eac9000,\n-    0xa968163f0a57b400,\n-    0xd3c21bcecceda100,\n-    0x84595161401484a0,\n-    0xa56fa5b99019a5c8,\n-    0xcecb8f27f4200f3a,\n-    0x813f3978f8940984,\n-    0xa18f07d736b90be5,\n-    0xc9f2c9cd04674edf,\n-    0xfc6f7c4045812296,\n-    0x9dc5ada82b70b59e,\n-    0xc5371912364ce305,\n-    0xf684df56c3e01bc7,\n-    0x9a130b963a6c115c,\n-    0xc097ce7bc90715b3,\n-    0xf0bdc21abb48db20,\n-    0x96769950b50d88f4,\n-    0xbc143fa4e250eb31,\n-    0xeb194f8e1ae525fd,\n-    0x92efd1b8d0cf37be,\n-    0xb7abc627050305ae,\n-    0xe596b7b0c643c719,\n-    0x8f7e32ce7bea5c70,\n-    0xb35dbf821ae4f38c,\n-    0xe0352f62a19e306f,\n-    0x8c213d9da502de45,\n-    0xaf298d050e4395d7,\n-    0xdaf3f04651d47b4c,\n-    0x88d8762bf324cd10,\n-    0xab0e93b6efee0054,\n-    0xd5d238a4abe98068,\n-    0x85a36366eb71f041,\n-    0xa70c3c40a64e6c52,\n-    0xd0cf4b50cfe20766,\n-    0x82818f1281ed44a0,\n-    0xa321f2d7226895c8,\n-    0xcbea6f8ceb02bb3a,\n-    0xfee50b7025c36a08,\n-    0x9f4f2726179a2245,\n-    0xc722f0ef9d80aad6,\n-    0xf8ebad2b84e0d58c,\n-    0x9b934c3b330c8577,\n-    0xc2781f49ffcfa6d5,\n-    0xf316271c7fc3908b,\n-    0x97edd871cfda3a57,\n-    0xbde94e8e43d0c8ec,\n-    0xed63a231d4c4fb27,\n-    0x945e455f24fb1cf9,\n-    0xb975d6b6ee39e437,\n-    0xe7d34c64a9c85d44,\n-    0x90e40fbeea1d3a4b,\n-    0xb51d13aea4a488dd,\n-    0xe264589a4dcdab15,\n-    0x8d7eb76070a08aed,\n-    0xb0de65388cc8ada8,\n-    0xdd15fe86affad912,\n-    0x8a2dbf142dfcc7ab,\n-    0xacb92ed9397bf996,\n-    0xd7e77a8f87daf7fc,\n-    0x86f0ac99b4e8dafd,\n-    0xa8acd7c0222311bd,\n-    0xd2d80db02aabd62c,\n-    0x83c7088e1aab65db,\n-    0xa4b8cab1a1563f52,\n-    0xcde6fd5e09abcf27,\n-    0x80b05e5ac60b6178,\n-    0xa0dc75f1778e39d6,\n-    0xc913936dd571c84c,\n-    0xfb5878494ace3a5f,\n-    0x9d174b2dcec0e47b,\n-    0xc45d1df942711d9a,\n-    0xf5746577930d6501,\n-    0x9968bf6abbe85f20,\n-    0xbfc2ef456ae276e9,\n-    0xefb3ab16c59b14a3,\n-    0x95d04aee3b80ece6,\n-    0xbb445da9ca61281f,\n-    0xea1575143cf97227,\n-    0x924d692ca61be758,\n-    0xb6e0c377cfa2e12e,\n-    0xe498f455c38b997a,\n-    0x8edf98b59a373fec,\n-    0xb2977ee300c50fe7,\n-    0xdf3d5e9bc0f653e1,\n-    0x8b865b215899f46d,\n-    0xae67f1e9aec07188,\n-    0xda01ee641a708dea,\n-    0x884134fe908658b2,\n-    0xaa51823e34a7eedf,\n-    0xd4e5e2cdc1d1ea96,\n-    0x850fadc09923329e,\n-    0xa6539930bf6bff46,\n-    0xcfe87f7cef46ff17,\n-    0x81f14fae158c5f6e,\n-    0xa26da3999aef774a,\n-    0xcb090c8001ab551c,\n-    0xfdcb4fa002162a63,\n-    0x9e9f11c4014dda7e,\n-    0xc646d63501a1511e,\n-    0xf7d88bc24209a565,\n-    0x9ae757596946075f,\n-    0xc1a12d2fc3978937,\n-    0xf209787bb47d6b85,\n-    0x9745eb4d50ce6333,\n-    0xbd176620a501fc00,\n-    0xec5d3fa8ce427b00,\n-    0x93ba47c980e98ce0,\n-    0xb8a8d9bbe123f018,\n-    0xe6d3102ad96cec1e,\n-    0x9043ea1ac7e41393,\n-    0xb454e4a179dd1877,\n-    0xe16a1dc9d8545e95,\n-    0x8ce2529e2734bb1d,\n-    0xb01ae745b101e9e4,\n-    0xdc21a1171d42645d,\n-    0x899504ae72497eba,\n-    0xabfa45da0edbde69,\n-    0xd6f8d7509292d603,\n-    0x865b86925b9bc5c2,\n-    0xa7f26836f282b733,\n-    0xd1ef0244af2364ff,\n-    0x8335616aed761f1f,\n-    0xa402b9c5a8d3a6e7,\n-    0xcd036837130890a1,\n-    0x802221226be55a65,\n-    0xa02aa96b06deb0fe,\n-    0xc83553c5c8965d3d,\n-    0xfa42a8b73abbf48d,\n-    0x9c69a97284b578d8,\n-    0xc38413cf25e2d70e,\n-    0xf46518c2ef5b8cd1,\n-    0x98bf2f79d5993803,\n-    0xbeeefb584aff8604,\n-    0xeeaaba2e5dbf6785,\n-    0x952ab45cfa97a0b3,\n-    0xba756174393d88e0,\n-    0xe912b9d1478ceb17,\n-    0x91abb422ccb812ef,\n-    0xb616a12b7fe617aa,\n-    0xe39c49765fdf9d95,\n-    0x8e41ade9fbebc27d,\n-    0xb1d219647ae6b31c,\n-    0xde469fbd99a05fe3,\n-    0x8aec23d680043bee,\n-    0xada72ccc20054aea,\n-    0xd910f7ff28069da4,\n-    0x87aa9aff79042287,\n-    0xa99541bf57452b28,\n-    0xd3fa922f2d1675f2,\n-    0x847c9b5d7c2e09b7,\n-    0xa59bc234db398c25,\n-    0xcf02b2c21207ef2f,\n-    0x8161afb94b44f57d,\n-    0xa1ba1ba79e1632dc,\n-    0xca28a291859bbf93,\n-    0xfcb2cb35e702af78,\n-    0x9defbf01b061adab,\n-    0xc56baec21c7a1916,\n-    0xf6c69a72a3989f5c,\n-    0x9a3c2087a63f6399,\n-    0xc0cb28a98fcf3c80,\n-    0xf0fdf2d3f3c30b9f,\n-    0x969eb7c47859e744,\n-    0xbc4665b596706115,\n-    0xeb57ff22fc0c795a,\n-    0x9316ff75dd87cbd8,\n-    0xb7dcbf5354e9bece,\n-    0xe5d3ef282a242e82,\n-    0x8fa475791a569d11,\n-    0xb38d92d760ec4455,\n-    0xe070f78d3927556b,\n-    0x8c469ab843b89563,\n-    0xaf58416654a6babb,\n-    0xdb2e51bfe9d0696a,\n-    0x88fcf317f22241e2,\n-    0xab3c2fddeeaad25b,\n-    0xd60b3bd56a5586f2,\n-    0x85c7056562757457,\n-    0xa738c6bebb12d16d,\n-    0xd106f86e69d785c8,\n-    0x82a45b450226b39d,\n-    0xa34d721642b06084,\n-    0xcc20ce9bd35c78a5,\n-    0xff290242c83396ce,\n-    0x9f79a169bd203e41,\n-    0xc75809c42c684dd1,\n-    0xf92e0c3537826146,\n-    0x9bbcc7a142b17ccc,\n-    0xc2abf989935ddbfe,\n-    0xf356f7ebf83552fe,\n-    0x98165af37b2153df,\n-    0xbe1bf1b059e9a8d6,\n-    0xeda2ee1c7064130c,\n-    0x9485d4d1c63e8be8,\n-    0xb9a74a0637ce2ee1,\n-    0xe8111c87c5c1ba9a,\n-    0x910ab1d4db9914a0,\n-    0xb54d5e4a127f59c8,\n-    0xe2a0b5dc971f303a,\n-    0x8da471a9de737e24,\n-    0xb10d8e1456105dad,\n-    0xdd50f1996b947519,\n-    0x8a5296ffe33cc930,\n-    0xace73cbfdc0bfb7b,\n-    0xd8210befd30efa5a,\n-    0x8714a775e3e95c78,\n-    0xa8d9d1535ce3b396,\n-    0xd31045a8341ca07c,\n-    0x83ea2b892091e44e,\n-    0xa4e4b66b68b65d61,\n-    0xce1de40642e3f4b9,\n-    0x80d2ae83e9ce78f4,\n-    0xa1075a24e4421731,\n-    0xc94930ae1d529cfd,\n-    0xfb9b7cd9a4a7443c,\n-    0x9d412e0806e88aa6,\n-    0xc491798a08a2ad4f,\n-    0xf5b5d7ec8acb58a3,\n-    0x9991a6f3d6bf1766,\n-    0xbff610b0cc6edd3f,\n-    0xeff394dcff8a948f,\n-    0x95f83d0a1fb69cd9,\n-    0xbb764c4ca7a44410,\n-    0xea53df5fd18d5514,\n-    0x92746b9be2f8552c,\n-    0xb7118682dbb66a77,\n-    0xe4d5e82392a40515,\n-    0x8f05b1163ba6832d,\n-    0xb2c71d5bca9023f8,\n-    0xdf78e4b2bd342cf7,\n-    0x8bab8eefb6409c1a,\n-    0xae9672aba3d0c321,\n-    0xda3c0f568cc4f3e9,\n-    0x8865899617fb1871,\n-    0xaa7eebfb9df9de8e,\n-    0xd51ea6fa85785631,\n-    0x8533285c936b35df,\n-    0xa67ff273b8460357,\n-    0xd01fef10a657842c,\n-    0x8213f56a67f6b29c,\n-    0xa298f2c501f45f43,\n-    0xcb3f2f7642717713,\n-    0xfe0efb53d30dd4d8,\n-    0x9ec95d1463e8a507,\n-    0xc67bb4597ce2ce49,\n-    0xf81aa16fdc1b81db,\n-    0x9b10a4e5e9913129,\n-    0xc1d4ce1f63f57d73,\n-    0xf24a01a73cf2dcd0,\n-    0x976e41088617ca02,\n-    0xbd49d14aa79dbc82,\n-    0xec9c459d51852ba3,\n-    0x93e1ab8252f33b46,\n-    0xb8da1662e7b00a17,\n-    0xe7109bfba19c0c9d,\n-    0x906a617d450187e2,\n-    0xb484f9dc9641e9db,\n-    0xe1a63853bbd26451,\n-    0x8d07e33455637eb3,\n-    0xb049dc016abc5e60,\n-    0xdc5c5301c56b75f7,\n-    0x89b9b3e11b6329bb,\n-    0xac2820d9623bf429,\n-    0xd732290fbacaf134,\n-    0x867f59a9d4bed6c0,\n-    0xa81f301449ee8c70,\n-    0xd226fc195c6a2f8c,\n-    0x83585d8fd9c25db8,\n-    0xa42e74f3d032f526,\n-    0xcd3a1230c43fb26f,\n-    0x80444b5e7aa7cf85,\n-    0xa0555e361951c367,\n-    0xc86ab5c39fa63441,\n-    0xfa856334878fc151,\n-    0x9c935e00d4b9d8d2,\n-    0xc3b8358109e84f07,\n-    0xf4a642e14c6262c9,\n-    0x98e7e9cccfbd7dbe,\n-    0xbf21e44003acdd2d,\n-    0xeeea5d5004981478,\n-    0x95527a5202df0ccb,\n-    0xbaa718e68396cffe,\n-    0xe950df20247c83fd,\n-    0x91d28b7416cdd27e,\n-], [\n-    -1077,\n-    -1073,\n-    -1070,\n-    -1067,\n-    -1063,\n-    -1060,\n-    -1057,\n-    -1053,\n-    -1050,\n-    -1047,\n-    -1043,\n-    -1040,\n-    -1037,\n-    -1034,\n-    -1030,\n-    -1027,\n-    -1024,\n-    -1020,\n-    -1017,\n-    -1014,\n-    -1010,\n-    -1007,\n-    -1004,\n-    -1000,\n-    -997,\n-    -994,\n-    -990,\n-    -987,\n-    -984,\n-    -980,\n-    -977,\n-    -974,\n-    -970,\n-    -967,\n-    -964,\n-    -960,\n-    -957,\n-    -954,\n-    -950,\n-    -947,\n-    -944,\n-    -940,\n-    -937,\n-    -934,\n-    -931,\n-    -927,\n-    -924,\n-    -921,\n-    -917,\n-    -914,\n-    -911,\n-    -907,\n-    -904,\n-    -901,\n-    -897,\n-    -894,\n-    -891,\n-    -887,\n-    -884,\n-    -881,\n-    -877,\n-    -874,\n-    -871,\n-    -867,\n-    -864,\n-    -861,\n-    -857,\n-    -854,\n-    -851,\n-    -847,\n-    -844,\n-    -841,\n-    -838,\n-    -834,\n-    -831,\n-    -828,\n-    -824,\n-    -821,\n-    -818,\n-    -814,\n-    -811,\n-    -808,\n-    -804,\n-    -801,\n-    -798,\n-    -794,\n-    -791,\n-    -788,\n-    -784,\n-    -781,\n-    -778,\n-    -774,\n-    -771,\n-    -768,\n-    -764,\n-    -761,\n-    -758,\n-    -754,\n-    -751,\n-    -748,\n-    -744,\n-    -741,\n-    -738,\n-    -735,\n-    -731,\n-    -728,\n-    -725,\n-    -721,\n-    -718,\n-    -715,\n-    -711,\n-    -708,\n-    -705,\n-    -701,\n-    -698,\n-    -695,\n-    -691,\n-    -688,\n-    -685,\n-    -681,\n-    -678,\n-    -675,\n-    -671,\n-    -668,\n-    -665,\n-    -661,\n-    -658,\n-    -655,\n-    -651,\n-    -648,\n-    -645,\n-    -642,\n-    -638,\n-    -635,\n-    -632,\n-    -628,\n-    -625,\n-    -622,\n-    -618,\n-    -615,\n-    -612,\n-    -608,\n-    -605,\n-    -602,\n-    -598,\n-    -595,\n-    -592,\n-    -588,\n-    -585,\n-    -582,\n-    -578,\n-    -575,\n-    -572,\n-    -568,\n-    -565,\n-    -562,\n-    -558,\n-    -555,\n-    -552,\n-    -549,\n-    -545,\n-    -542,\n-    -539,\n-    -535,\n-    -532,\n-    -529,\n-    -525,\n-    -522,\n-    -519,\n-    -515,\n-    -512,\n-    -509,\n-    -505,\n-    -502,\n-    -499,\n-    -495,\n-    -492,\n-    -489,\n-    -485,\n-    -482,\n-    -479,\n-    -475,\n-    -472,\n-    -469,\n-    -465,\n-    -462,\n-    -459,\n-    -455,\n-    -452,\n-    -449,\n-    -446,\n-    -442,\n-    -439,\n-    -436,\n-    -432,\n-    -429,\n-    -426,\n-    -422,\n-    -419,\n-    -416,\n-    -412,\n-    -409,\n-    -406,\n-    -402,\n-    -399,\n-    -396,\n-    -392,\n-    -389,\n-    -386,\n-    -382,\n-    -379,\n-    -376,\n-    -372,\n-    -369,\n-    -366,\n-    -362,\n-    -359,\n-    -356,\n-    -353,\n-    -349,\n-    -346,\n-    -343,\n-    -339,\n-    -336,\n-    -333,\n-    -329,\n-    -326,\n-    -323,\n-    -319,\n-    -316,\n-    -313,\n-    -309,\n-    -306,\n-    -303,\n-    -299,\n-    -296,\n-    -293,\n-    -289,\n-    -286,\n-    -283,\n-    -279,\n-    -276,\n-    -273,\n-    -269,\n-    -266,\n-    -263,\n-    -259,\n-    -256,\n-    -253,\n-    -250,\n-    -246,\n-    -243,\n-    -240,\n-    -236,\n-    -233,\n-    -230,\n-    -226,\n-    -223,\n-    -220,\n-    -216,\n-    -213,\n-    -210,\n-    -206,\n-    -203,\n-    -200,\n-    -196,\n-    -193,\n-    -190,\n-    -186,\n-    -183,\n-    -180,\n-    -176,\n-    -173,\n-    -170,\n-    -166,\n-    -163,\n-    -160,\n-    -157,\n-    -153,\n-    -150,\n-    -147,\n-    -143,\n-    -140,\n-    -137,\n-    -133,\n-    -130,\n-    -127,\n-    -123,\n-    -120,\n-    -117,\n-    -113,\n-    -110,\n-    -107,\n-    -103,\n-    -100,\n-    -97,\n-    -93,\n-    -90,\n-    -87,\n-    -83,\n-    -80,\n-    -77,\n-    -73,\n-    -70,\n-    -67,\n-    -63,\n-    -60,\n-    -57,\n-    -54,\n-    -50,\n-    -47,\n-    -44,\n-    -40,\n-    -37,\n-    -34,\n-    -30,\n-    -27,\n-    -24,\n-    -20,\n-    -17,\n-    -14,\n-    -10,\n-    -7,\n-    -4,\n-    0,\n-    3,\n-    6,\n-    10,\n-    13,\n-    16,\n-    20,\n-    23,\n-    26,\n-    30,\n-    33,\n-    36,\n-    39,\n-    43,\n-    46,\n-    49,\n-    53,\n-    56,\n-    59,\n-    63,\n-    66,\n-    69,\n-    73,\n-    76,\n-    79,\n-    83,\n-    86,\n-    89,\n-    93,\n-    96,\n-    99,\n-    103,\n-    106,\n-    109,\n-    113,\n-    116,\n-    119,\n-    123,\n-    126,\n-    129,\n-    132,\n-    136,\n-    139,\n-    142,\n-    146,\n-    149,\n-    152,\n-    156,\n-    159,\n-    162,\n-    166,\n-    169,\n-    172,\n-    176,\n-    179,\n-    182,\n-    186,\n-    189,\n-    192,\n-    196,\n-    199,\n-    202,\n-    206,\n-    209,\n-    212,\n-    216,\n-    219,\n-    222,\n-    226,\n-    229,\n-    232,\n-    235,\n-    239,\n-    242,\n-    245,\n-    249,\n-    252,\n-    255,\n-    259,\n-    262,\n-    265,\n-    269,\n-    272,\n-    275,\n-    279,\n-    282,\n-    285,\n-    289,\n-    292,\n-    295,\n-    299,\n-    302,\n-    305,\n-    309,\n-    312,\n-    315,\n-    319,\n-    322,\n-    325,\n-    328,\n-    332,\n-    335,\n-    338,\n-    342,\n-    345,\n-    348,\n-    352,\n-    355,\n-    358,\n-    362,\n-    365,\n-    368,\n-    372,\n-    375,\n-    378,\n-    382,\n-    385,\n-    388,\n-    392,\n-    395,\n-    398,\n-    402,\n-    405,\n-    408,\n-    412,\n-    415,\n-    418,\n-    422,\n-    425,\n-    428,\n-    431,\n-    435,\n-    438,\n-    441,\n-    445,\n-    448,\n-    451,\n-    455,\n-    458,\n-    461,\n-    465,\n-    468,\n-    471,\n-    475,\n-    478,\n-    481,\n-    485,\n-    488,\n-    491,\n-    495,\n-    498,\n-    501,\n-    505,\n-    508,\n-    511,\n-    515,\n-    518,\n-    521,\n-    524,\n-    528,\n-    531,\n-    534,\n-    538,\n-    541,\n-    544,\n-    548,\n-    551,\n-    554,\n-    558,\n-    561,\n-    564,\n-    568,\n-    571,\n-    574,\n-    578,\n-    581,\n-    584,\n-    588,\n-    591,\n-    594,\n-    598,\n-    601,\n-    604,\n-    608,\n-    611,\n-    614,\n-    617,\n-    621,\n-    624,\n-    627,\n-    631,\n-    634,\n-    637,\n-    641,\n-    644,\n-    647,\n-    651,\n-    654,\n-    657,\n-    661,\n-    664,\n-    667,\n-    671,\n-    674,\n-    677,\n-    681,\n-    684,\n-    687,\n-    691,\n-    694,\n-    697,\n-    701,\n-    704,\n-    707,\n-    711,\n-    714,\n-    717,\n-    720,\n-    724,\n-    727,\n-    730,\n-    734,\n-    737,\n-    740,\n-    744,\n-    747,\n-    750,\n-    754,\n-    757,\n-    760,\n-    764,\n-    767,\n-    770,\n-    774,\n-    777,\n-    780,\n-    784,\n-    787,\n-    790,\n-    794,\n-    797,\n-    800,\n-    804,\n-    807,\n-    810,\n-    813,\n-    817,\n-    820,\n-    823,\n-    827,\n-    830,\n-    833,\n-    837,\n-    840,\n-    843,\n-    847,\n-    850,\n-    853,\n-    857,\n-    860,\n-    863,\n-    867,\n-    870,\n-    873,\n-    877,\n-    880,\n-    883,\n-    887,\n-    890,\n-    893,\n-    897,\n-    900,\n-    903,\n-    907,\n-    910,\n-    913,\n-    916,\n-    920,\n-    923,\n-    926,\n-    930,\n-    933,\n-    936,\n-    940,\n-    943,\n-    946,\n-    950,\n-]);\n+#[rustfmt::skip]\n+pub const POWERS: ([u64; 611], [i16; 611]) = (\n+    [\n+        0xe0b62e2929aba83c,\n+        0x8c71dcd9ba0b4926,\n+        0xaf8e5410288e1b6f,\n+        0xdb71e91432b1a24b,\n+        0x892731ac9faf056f,\n+        0xab70fe17c79ac6ca,\n+        0xd64d3d9db981787d,\n+        0x85f0468293f0eb4e,\n+        0xa76c582338ed2622,\n+        0xd1476e2c07286faa,\n+        0x82cca4db847945ca,\n+        0xa37fce126597973d,\n+        0xcc5fc196fefd7d0c,\n+        0xff77b1fcbebcdc4f,\n+        0x9faacf3df73609b1,\n+        0xc795830d75038c1e,\n+        0xf97ae3d0d2446f25,\n+        0x9becce62836ac577,\n+        0xc2e801fb244576d5,\n+        0xf3a20279ed56d48a,\n+        0x9845418c345644d7,\n+        0xbe5691ef416bd60c,\n+        0xedec366b11c6cb8f,\n+        0x94b3a202eb1c3f39,\n+        0xb9e08a83a5e34f08,\n+        0xe858ad248f5c22ca,\n+        0x91376c36d99995be,\n+        0xb58547448ffffb2e,\n+        0xe2e69915b3fff9f9,\n+        0x8dd01fad907ffc3c,\n+        0xb1442798f49ffb4b,\n+        0xdd95317f31c7fa1d,\n+        0x8a7d3eef7f1cfc52,\n+        0xad1c8eab5ee43b67,\n+        0xd863b256369d4a41,\n+        0x873e4f75e2224e68,\n+        0xa90de3535aaae202,\n+        0xd3515c2831559a83,\n+        0x8412d9991ed58092,\n+        0xa5178fff668ae0b6,\n+        0xce5d73ff402d98e4,\n+        0x80fa687f881c7f8e,\n+        0xa139029f6a239f72,\n+        0xc987434744ac874f,\n+        0xfbe9141915d7a922,\n+        0x9d71ac8fada6c9b5,\n+        0xc4ce17b399107c23,\n+        0xf6019da07f549b2b,\n+        0x99c102844f94e0fb,\n+        0xc0314325637a193a,\n+        0xf03d93eebc589f88,\n+        0x96267c7535b763b5,\n+        0xbbb01b9283253ca3,\n+        0xea9c227723ee8bcb,\n+        0x92a1958a7675175f,\n+        0xb749faed14125d37,\n+        0xe51c79a85916f485,\n+        0x8f31cc0937ae58d3,\n+        0xb2fe3f0b8599ef08,\n+        0xdfbdcece67006ac9,\n+        0x8bd6a141006042be,\n+        0xaecc49914078536d,\n+        0xda7f5bf590966849,\n+        0x888f99797a5e012d,\n+        0xaab37fd7d8f58179,\n+        0xd5605fcdcf32e1d7,\n+        0x855c3be0a17fcd26,\n+        0xa6b34ad8c9dfc070,\n+        0xd0601d8efc57b08c,\n+        0x823c12795db6ce57,\n+        0xa2cb1717b52481ed,\n+        0xcb7ddcdda26da269,\n+        0xfe5d54150b090b03,\n+        0x9efa548d26e5a6e2,\n+        0xc6b8e9b0709f109a,\n+        0xf867241c8cc6d4c1,\n+        0x9b407691d7fc44f8,\n+        0xc21094364dfb5637,\n+        0xf294b943e17a2bc4,\n+        0x979cf3ca6cec5b5b,\n+        0xbd8430bd08277231,\n+        0xece53cec4a314ebe,\n+        0x940f4613ae5ed137,\n+        0xb913179899f68584,\n+        0xe757dd7ec07426e5,\n+        0x9096ea6f3848984f,\n+        0xb4bca50b065abe63,\n+        0xe1ebce4dc7f16dfc,\n+        0x8d3360f09cf6e4bd,\n+        0xb080392cc4349ded,\n+        0xdca04777f541c568,\n+        0x89e42caaf9491b61,\n+        0xac5d37d5b79b6239,\n+        0xd77485cb25823ac7,\n+        0x86a8d39ef77164bd,\n+        0xa8530886b54dbdec,\n+        0xd267caa862a12d67,\n+        0x8380dea93da4bc60,\n+        0xa46116538d0deb78,\n+        0xcd795be870516656,\n+        0x806bd9714632dff6,\n+        0xa086cfcd97bf97f4,\n+        0xc8a883c0fdaf7df0,\n+        0xfad2a4b13d1b5d6c,\n+        0x9cc3a6eec6311a64,\n+        0xc3f490aa77bd60fd,\n+        0xf4f1b4d515acb93c,\n+        0x991711052d8bf3c5,\n+        0xbf5cd54678eef0b7,\n+        0xef340a98172aace5,\n+        0x9580869f0e7aac0f,\n+        0xbae0a846d2195713,\n+        0xe998d258869facd7,\n+        0x91ff83775423cc06,\n+        0xb67f6455292cbf08,\n+        0xe41f3d6a7377eeca,\n+        0x8e938662882af53e,\n+        0xb23867fb2a35b28e,\n+        0xdec681f9f4c31f31,\n+        0x8b3c113c38f9f37f,\n+        0xae0b158b4738705f,\n+        0xd98ddaee19068c76,\n+        0x87f8a8d4cfa417ca,\n+        0xa9f6d30a038d1dbc,\n+        0xd47487cc8470652b,\n+        0x84c8d4dfd2c63f3b,\n+        0xa5fb0a17c777cf0a,\n+        0xcf79cc9db955c2cc,\n+        0x81ac1fe293d599c0,\n+        0xa21727db38cb0030,\n+        0xca9cf1d206fdc03c,\n+        0xfd442e4688bd304b,\n+        0x9e4a9cec15763e2f,\n+        0xc5dd44271ad3cdba,\n+        0xf7549530e188c129,\n+        0x9a94dd3e8cf578ba,\n+        0xc13a148e3032d6e8,\n+        0xf18899b1bc3f8ca2,\n+        0x96f5600f15a7b7e5,\n+        0xbcb2b812db11a5de,\n+        0xebdf661791d60f56,\n+        0x936b9fcebb25c996,\n+        0xb84687c269ef3bfb,\n+        0xe65829b3046b0afa,\n+        0x8ff71a0fe2c2e6dc,\n+        0xb3f4e093db73a093,\n+        0xe0f218b8d25088b8,\n+        0x8c974f7383725573,\n+        0xafbd2350644eead0,\n+        0xdbac6c247d62a584,\n+        0x894bc396ce5da772,\n+        0xab9eb47c81f5114f,\n+        0xd686619ba27255a3,\n+        0x8613fd0145877586,\n+        0xa798fc4196e952e7,\n+        0xd17f3b51fca3a7a1,\n+        0x82ef85133de648c5,\n+        0xa3ab66580d5fdaf6,\n+        0xcc963fee10b7d1b3,\n+        0xffbbcfe994e5c620,\n+        0x9fd561f1fd0f9bd4,\n+        0xc7caba6e7c5382c9,\n+        0xf9bd690a1b68637b,\n+        0x9c1661a651213e2d,\n+        0xc31bfa0fe5698db8,\n+        0xf3e2f893dec3f126,\n+        0x986ddb5c6b3a76b8,\n+        0xbe89523386091466,\n+        0xee2ba6c0678b597f,\n+        0x94db483840b717f0,\n+        0xba121a4650e4ddec,\n+        0xe896a0d7e51e1566,\n+        0x915e2486ef32cd60,\n+        0xb5b5ada8aaff80b8,\n+        0xe3231912d5bf60e6,\n+        0x8df5efabc5979c90,\n+        0xb1736b96b6fd83b4,\n+        0xddd0467c64bce4a1,\n+        0x8aa22c0dbef60ee4,\n+        0xad4ab7112eb3929e,\n+        0xd89d64d57a607745,\n+        0x87625f056c7c4a8b,\n+        0xa93af6c6c79b5d2e,\n+        0xd389b47879823479,\n+        0x843610cb4bf160cc,\n+        0xa54394fe1eedb8ff,\n+        0xce947a3da6a9273e,\n+        0x811ccc668829b887,\n+        0xa163ff802a3426a9,\n+        0xc9bcff6034c13053,\n+        0xfc2c3f3841f17c68,\n+        0x9d9ba7832936edc1,\n+        0xc5029163f384a931,\n+        0xf64335bcf065d37d,\n+        0x99ea0196163fa42e,\n+        0xc06481fb9bcf8d3a,\n+        0xf07da27a82c37088,\n+        0x964e858c91ba2655,\n+        0xbbe226efb628afeb,\n+        0xeadab0aba3b2dbe5,\n+        0x92c8ae6b464fc96f,\n+        0xb77ada0617e3bbcb,\n+        0xe55990879ddcaabe,\n+        0x8f57fa54c2a9eab7,\n+        0xb32df8e9f3546564,\n+        0xdff9772470297ebd,\n+        0x8bfbea76c619ef36,\n+        0xaefae51477a06b04,\n+        0xdab99e59958885c5,\n+        0x88b402f7fd75539b,\n+        0xaae103b5fcd2a882,\n+        0xd59944a37c0752a2,\n+        0x857fcae62d8493a5,\n+        0xa6dfbd9fb8e5b88f,\n+        0xd097ad07a71f26b2,\n+        0x825ecc24c8737830,\n+        0xa2f67f2dfa90563b,\n+        0xcbb41ef979346bca,\n+        0xfea126b7d78186bd,\n+        0x9f24b832e6b0f436,\n+        0xc6ede63fa05d3144,\n+        0xf8a95fcf88747d94,\n+        0x9b69dbe1b548ce7d,\n+        0xc24452da229b021c,\n+        0xf2d56790ab41c2a3,\n+        0x97c560ba6b0919a6,\n+        0xbdb6b8e905cb600f,\n+        0xed246723473e3813,\n+        0x9436c0760c86e30c,\n+        0xb94470938fa89bcf,\n+        0xe7958cb87392c2c3,\n+        0x90bd77f3483bb9ba,\n+        0xb4ecd5f01a4aa828,\n+        0xe2280b6c20dd5232,\n+        0x8d590723948a535f,\n+        0xb0af48ec79ace837,\n+        0xdcdb1b2798182245,\n+        0x8a08f0f8bf0f156b,\n+        0xac8b2d36eed2dac6,\n+        0xd7adf884aa879177,\n+        0x86ccbb52ea94baeb,\n+        0xa87fea27a539e9a5,\n+        0xd29fe4b18e88640f,\n+        0x83a3eeeef9153e89,\n+        0xa48ceaaab75a8e2b,\n+        0xcdb02555653131b6,\n+        0x808e17555f3ebf12,\n+        0xa0b19d2ab70e6ed6,\n+        0xc8de047564d20a8c,\n+        0xfb158592be068d2f,\n+        0x9ced737bb6c4183d,\n+        0xc428d05aa4751e4d,\n+        0xf53304714d9265e0,\n+        0x993fe2c6d07b7fac,\n+        0xbf8fdb78849a5f97,\n+        0xef73d256a5c0f77d,\n+        0x95a8637627989aae,\n+        0xbb127c53b17ec159,\n+        0xe9d71b689dde71b0,\n+        0x9226712162ab070e,\n+        0xb6b00d69bb55c8d1,\n+        0xe45c10c42a2b3b06,\n+        0x8eb98a7a9a5b04e3,\n+        0xb267ed1940f1c61c,\n+        0xdf01e85f912e37a3,\n+        0x8b61313bbabce2c6,\n+        0xae397d8aa96c1b78,\n+        0xd9c7dced53c72256,\n+        0x881cea14545c7575,\n+        0xaa242499697392d3,\n+        0xd4ad2dbfc3d07788,\n+        0x84ec3c97da624ab5,\n+        0xa6274bbdd0fadd62,\n+        0xcfb11ead453994ba,\n+        0x81ceb32c4b43fcf5,\n+        0xa2425ff75e14fc32,\n+        0xcad2f7f5359a3b3e,\n+        0xfd87b5f28300ca0e,\n+        0x9e74d1b791e07e48,\n+        0xc612062576589ddb,\n+        0xf79687aed3eec551,\n+        0x9abe14cd44753b53,\n+        0xc16d9a0095928a27,\n+        0xf1c90080baf72cb1,\n+        0x971da05074da7bef,\n+        0xbce5086492111aeb,\n+        0xec1e4a7db69561a5,\n+        0x9392ee8e921d5d07,\n+        0xb877aa3236a4b449,\n+        0xe69594bec44de15b,\n+        0x901d7cf73ab0acd9,\n+        0xb424dc35095cd80f,\n+        0xe12e13424bb40e13,\n+        0x8cbccc096f5088cc,\n+        0xafebff0bcb24aaff,\n+        0xdbe6fecebdedd5bf,\n+        0x89705f4136b4a597,\n+        0xabcc77118461cefd,\n+        0xd6bf94d5e57a42bc,\n+        0x8637bd05af6c69b6,\n+        0xa7c5ac471b478423,\n+        0xd1b71758e219652c,\n+        0x83126e978d4fdf3b,\n+        0xa3d70a3d70a3d70a,\n+        0xcccccccccccccccd,\n+        0x8000000000000000,\n+        0xa000000000000000,\n+        0xc800000000000000,\n+        0xfa00000000000000,\n+        0x9c40000000000000,\n+        0xc350000000000000,\n+        0xf424000000000000,\n+        0x9896800000000000,\n+        0xbebc200000000000,\n+        0xee6b280000000000,\n+        0x9502f90000000000,\n+        0xba43b74000000000,\n+        0xe8d4a51000000000,\n+        0x9184e72a00000000,\n+        0xb5e620f480000000,\n+        0xe35fa931a0000000,\n+        0x8e1bc9bf04000000,\n+        0xb1a2bc2ec5000000,\n+        0xde0b6b3a76400000,\n+        0x8ac7230489e80000,\n+        0xad78ebc5ac620000,\n+        0xd8d726b7177a8000,\n+        0x878678326eac9000,\n+        0xa968163f0a57b400,\n+        0xd3c21bcecceda100,\n+        0x84595161401484a0,\n+        0xa56fa5b99019a5c8,\n+        0xcecb8f27f4200f3a,\n+        0x813f3978f8940984,\n+        0xa18f07d736b90be5,\n+        0xc9f2c9cd04674edf,\n+        0xfc6f7c4045812296,\n+        0x9dc5ada82b70b59e,\n+        0xc5371912364ce305,\n+        0xf684df56c3e01bc7,\n+        0x9a130b963a6c115c,\n+        0xc097ce7bc90715b3,\n+        0xf0bdc21abb48db20,\n+        0x96769950b50d88f4,\n+        0xbc143fa4e250eb31,\n+        0xeb194f8e1ae525fd,\n+        0x92efd1b8d0cf37be,\n+        0xb7abc627050305ae,\n+        0xe596b7b0c643c719,\n+        0x8f7e32ce7bea5c70,\n+        0xb35dbf821ae4f38c,\n+        0xe0352f62a19e306f,\n+        0x8c213d9da502de45,\n+        0xaf298d050e4395d7,\n+        0xdaf3f04651d47b4c,\n+        0x88d8762bf324cd10,\n+        0xab0e93b6efee0054,\n+        0xd5d238a4abe98068,\n+        0x85a36366eb71f041,\n+        0xa70c3c40a64e6c52,\n+        0xd0cf4b50cfe20766,\n+        0x82818f1281ed44a0,\n+        0xa321f2d7226895c8,\n+        0xcbea6f8ceb02bb3a,\n+        0xfee50b7025c36a08,\n+        0x9f4f2726179a2245,\n+        0xc722f0ef9d80aad6,\n+        0xf8ebad2b84e0d58c,\n+        0x9b934c3b330c8577,\n+        0xc2781f49ffcfa6d5,\n+        0xf316271c7fc3908b,\n+        0x97edd871cfda3a57,\n+        0xbde94e8e43d0c8ec,\n+        0xed63a231d4c4fb27,\n+        0x945e455f24fb1cf9,\n+        0xb975d6b6ee39e437,\n+        0xe7d34c64a9c85d44,\n+        0x90e40fbeea1d3a4b,\n+        0xb51d13aea4a488dd,\n+        0xe264589a4dcdab15,\n+        0x8d7eb76070a08aed,\n+        0xb0de65388cc8ada8,\n+        0xdd15fe86affad912,\n+        0x8a2dbf142dfcc7ab,\n+        0xacb92ed9397bf996,\n+        0xd7e77a8f87daf7fc,\n+        0x86f0ac99b4e8dafd,\n+        0xa8acd7c0222311bd,\n+        0xd2d80db02aabd62c,\n+        0x83c7088e1aab65db,\n+        0xa4b8cab1a1563f52,\n+        0xcde6fd5e09abcf27,\n+        0x80b05e5ac60b6178,\n+        0xa0dc75f1778e39d6,\n+        0xc913936dd571c84c,\n+        0xfb5878494ace3a5f,\n+        0x9d174b2dcec0e47b,\n+        0xc45d1df942711d9a,\n+        0xf5746577930d6501,\n+        0x9968bf6abbe85f20,\n+        0xbfc2ef456ae276e9,\n+        0xefb3ab16c59b14a3,\n+        0x95d04aee3b80ece6,\n+        0xbb445da9ca61281f,\n+        0xea1575143cf97227,\n+        0x924d692ca61be758,\n+        0xb6e0c377cfa2e12e,\n+        0xe498f455c38b997a,\n+        0x8edf98b59a373fec,\n+        0xb2977ee300c50fe7,\n+        0xdf3d5e9bc0f653e1,\n+        0x8b865b215899f46d,\n+        0xae67f1e9aec07188,\n+        0xda01ee641a708dea,\n+        0x884134fe908658b2,\n+        0xaa51823e34a7eedf,\n+        0xd4e5e2cdc1d1ea96,\n+        0x850fadc09923329e,\n+        0xa6539930bf6bff46,\n+        0xcfe87f7cef46ff17,\n+        0x81f14fae158c5f6e,\n+        0xa26da3999aef774a,\n+        0xcb090c8001ab551c,\n+        0xfdcb4fa002162a63,\n+        0x9e9f11c4014dda7e,\n+        0xc646d63501a1511e,\n+        0xf7d88bc24209a565,\n+        0x9ae757596946075f,\n+        0xc1a12d2fc3978937,\n+        0xf209787bb47d6b85,\n+        0x9745eb4d50ce6333,\n+        0xbd176620a501fc00,\n+        0xec5d3fa8ce427b00,\n+        0x93ba47c980e98ce0,\n+        0xb8a8d9bbe123f018,\n+        0xe6d3102ad96cec1e,\n+        0x9043ea1ac7e41393,\n+        0xb454e4a179dd1877,\n+        0xe16a1dc9d8545e95,\n+        0x8ce2529e2734bb1d,\n+        0xb01ae745b101e9e4,\n+        0xdc21a1171d42645d,\n+        0x899504ae72497eba,\n+        0xabfa45da0edbde69,\n+        0xd6f8d7509292d603,\n+        0x865b86925b9bc5c2,\n+        0xa7f26836f282b733,\n+        0xd1ef0244af2364ff,\n+        0x8335616aed761f1f,\n+        0xa402b9c5a8d3a6e7,\n+        0xcd036837130890a1,\n+        0x802221226be55a65,\n+        0xa02aa96b06deb0fe,\n+        0xc83553c5c8965d3d,\n+        0xfa42a8b73abbf48d,\n+        0x9c69a97284b578d8,\n+        0xc38413cf25e2d70e,\n+        0xf46518c2ef5b8cd1,\n+        0x98bf2f79d5993803,\n+        0xbeeefb584aff8604,\n+        0xeeaaba2e5dbf6785,\n+        0x952ab45cfa97a0b3,\n+        0xba756174393d88e0,\n+        0xe912b9d1478ceb17,\n+        0x91abb422ccb812ef,\n+        0xb616a12b7fe617aa,\n+        0xe39c49765fdf9d95,\n+        0x8e41ade9fbebc27d,\n+        0xb1d219647ae6b31c,\n+        0xde469fbd99a05fe3,\n+        0x8aec23d680043bee,\n+        0xada72ccc20054aea,\n+        0xd910f7ff28069da4,\n+        0x87aa9aff79042287,\n+        0xa99541bf57452b28,\n+        0xd3fa922f2d1675f2,\n+        0x847c9b5d7c2e09b7,\n+        0xa59bc234db398c25,\n+        0xcf02b2c21207ef2f,\n+        0x8161afb94b44f57d,\n+        0xa1ba1ba79e1632dc,\n+        0xca28a291859bbf93,\n+        0xfcb2cb35e702af78,\n+        0x9defbf01b061adab,\n+        0xc56baec21c7a1916,\n+        0xf6c69a72a3989f5c,\n+        0x9a3c2087a63f6399,\n+        0xc0cb28a98fcf3c80,\n+        0xf0fdf2d3f3c30b9f,\n+        0x969eb7c47859e744,\n+        0xbc4665b596706115,\n+        0xeb57ff22fc0c795a,\n+        0x9316ff75dd87cbd8,\n+        0xb7dcbf5354e9bece,\n+        0xe5d3ef282a242e82,\n+        0x8fa475791a569d11,\n+        0xb38d92d760ec4455,\n+        0xe070f78d3927556b,\n+        0x8c469ab843b89563,\n+        0xaf58416654a6babb,\n+        0xdb2e51bfe9d0696a,\n+        0x88fcf317f22241e2,\n+        0xab3c2fddeeaad25b,\n+        0xd60b3bd56a5586f2,\n+        0x85c7056562757457,\n+        0xa738c6bebb12d16d,\n+        0xd106f86e69d785c8,\n+        0x82a45b450226b39d,\n+        0xa34d721642b06084,\n+        0xcc20ce9bd35c78a5,\n+        0xff290242c83396ce,\n+        0x9f79a169bd203e41,\n+        0xc75809c42c684dd1,\n+        0xf92e0c3537826146,\n+        0x9bbcc7a142b17ccc,\n+        0xc2abf989935ddbfe,\n+        0xf356f7ebf83552fe,\n+        0x98165af37b2153df,\n+        0xbe1bf1b059e9a8d6,\n+        0xeda2ee1c7064130c,\n+        0x9485d4d1c63e8be8,\n+        0xb9a74a0637ce2ee1,\n+        0xe8111c87c5c1ba9a,\n+        0x910ab1d4db9914a0,\n+        0xb54d5e4a127f59c8,\n+        0xe2a0b5dc971f303a,\n+        0x8da471a9de737e24,\n+        0xb10d8e1456105dad,\n+        0xdd50f1996b947519,\n+        0x8a5296ffe33cc930,\n+        0xace73cbfdc0bfb7b,\n+        0xd8210befd30efa5a,\n+        0x8714a775e3e95c78,\n+        0xa8d9d1535ce3b396,\n+        0xd31045a8341ca07c,\n+        0x83ea2b892091e44e,\n+        0xa4e4b66b68b65d61,\n+        0xce1de40642e3f4b9,\n+        0x80d2ae83e9ce78f4,\n+        0xa1075a24e4421731,\n+        0xc94930ae1d529cfd,\n+        0xfb9b7cd9a4a7443c,\n+        0x9d412e0806e88aa6,\n+        0xc491798a08a2ad4f,\n+        0xf5b5d7ec8acb58a3,\n+        0x9991a6f3d6bf1766,\n+        0xbff610b0cc6edd3f,\n+        0xeff394dcff8a948f,\n+        0x95f83d0a1fb69cd9,\n+        0xbb764c4ca7a44410,\n+        0xea53df5fd18d5514,\n+        0x92746b9be2f8552c,\n+        0xb7118682dbb66a77,\n+        0xe4d5e82392a40515,\n+        0x8f05b1163ba6832d,\n+        0xb2c71d5bca9023f8,\n+        0xdf78e4b2bd342cf7,\n+        0x8bab8eefb6409c1a,\n+        0xae9672aba3d0c321,\n+        0xda3c0f568cc4f3e9,\n+        0x8865899617fb1871,\n+        0xaa7eebfb9df9de8e,\n+        0xd51ea6fa85785631,\n+        0x8533285c936b35df,\n+        0xa67ff273b8460357,\n+        0xd01fef10a657842c,\n+        0x8213f56a67f6b29c,\n+        0xa298f2c501f45f43,\n+        0xcb3f2f7642717713,\n+        0xfe0efb53d30dd4d8,\n+        0x9ec95d1463e8a507,\n+        0xc67bb4597ce2ce49,\n+        0xf81aa16fdc1b81db,\n+        0x9b10a4e5e9913129,\n+        0xc1d4ce1f63f57d73,\n+        0xf24a01a73cf2dcd0,\n+        0x976e41088617ca02,\n+        0xbd49d14aa79dbc82,\n+        0xec9c459d51852ba3,\n+        0x93e1ab8252f33b46,\n+        0xb8da1662e7b00a17,\n+        0xe7109bfba19c0c9d,\n+        0x906a617d450187e2,\n+        0xb484f9dc9641e9db,\n+        0xe1a63853bbd26451,\n+        0x8d07e33455637eb3,\n+        0xb049dc016abc5e60,\n+        0xdc5c5301c56b75f7,\n+        0x89b9b3e11b6329bb,\n+        0xac2820d9623bf429,\n+        0xd732290fbacaf134,\n+        0x867f59a9d4bed6c0,\n+        0xa81f301449ee8c70,\n+        0xd226fc195c6a2f8c,\n+        0x83585d8fd9c25db8,\n+        0xa42e74f3d032f526,\n+        0xcd3a1230c43fb26f,\n+        0x80444b5e7aa7cf85,\n+        0xa0555e361951c367,\n+        0xc86ab5c39fa63441,\n+        0xfa856334878fc151,\n+        0x9c935e00d4b9d8d2,\n+        0xc3b8358109e84f07,\n+        0xf4a642e14c6262c9,\n+        0x98e7e9cccfbd7dbe,\n+        0xbf21e44003acdd2d,\n+        0xeeea5d5004981478,\n+        0x95527a5202df0ccb,\n+        0xbaa718e68396cffe,\n+        0xe950df20247c83fd,\n+        0x91d28b7416cdd27e,\n+    ],\n+    [\n+        -1077,\n+        -1073,\n+        -1070,\n+        -1067,\n+        -1063,\n+        -1060,\n+        -1057,\n+        -1053,\n+        -1050,\n+        -1047,\n+        -1043,\n+        -1040,\n+        -1037,\n+        -1034,\n+        -1030,\n+        -1027,\n+        -1024,\n+        -1020,\n+        -1017,\n+        -1014,\n+        -1010,\n+        -1007,\n+        -1004,\n+        -1000,\n+        -997,\n+        -994,\n+        -990,\n+        -987,\n+        -984,\n+        -980,\n+        -977,\n+        -974,\n+        -970,\n+        -967,\n+        -964,\n+        -960,\n+        -957,\n+        -954,\n+        -950,\n+        -947,\n+        -944,\n+        -940,\n+        -937,\n+        -934,\n+        -931,\n+        -927,\n+        -924,\n+        -921,\n+        -917,\n+        -914,\n+        -911,\n+        -907,\n+        -904,\n+        -901,\n+        -897,\n+        -894,\n+        -891,\n+        -887,\n+        -884,\n+        -881,\n+        -877,\n+        -874,\n+        -871,\n+        -867,\n+        -864,\n+        -861,\n+        -857,\n+        -854,\n+        -851,\n+        -847,\n+        -844,\n+        -841,\n+        -838,\n+        -834,\n+        -831,\n+        -828,\n+        -824,\n+        -821,\n+        -818,\n+        -814,\n+        -811,\n+        -808,\n+        -804,\n+        -801,\n+        -798,\n+        -794,\n+        -791,\n+        -788,\n+        -784,\n+        -781,\n+        -778,\n+        -774,\n+        -771,\n+        -768,\n+        -764,\n+        -761,\n+        -758,\n+        -754,\n+        -751,\n+        -748,\n+        -744,\n+        -741,\n+        -738,\n+        -735,\n+        -731,\n+        -728,\n+        -725,\n+        -721,\n+        -718,\n+        -715,\n+        -711,\n+        -708,\n+        -705,\n+        -701,\n+        -698,\n+        -695,\n+        -691,\n+        -688,\n+        -685,\n+        -681,\n+        -678,\n+        -675,\n+        -671,\n+        -668,\n+        -665,\n+        -661,\n+        -658,\n+        -655,\n+        -651,\n+        -648,\n+        -645,\n+        -642,\n+        -638,\n+        -635,\n+        -632,\n+        -628,\n+        -625,\n+        -622,\n+        -618,\n+        -615,\n+        -612,\n+        -608,\n+        -605,\n+        -602,\n+        -598,\n+        -595,\n+        -592,\n+        -588,\n+        -585,\n+        -582,\n+        -578,\n+        -575,\n+        -572,\n+        -568,\n+        -565,\n+        -562,\n+        -558,\n+        -555,\n+        -552,\n+        -549,\n+        -545,\n+        -542,\n+        -539,\n+        -535,\n+        -532,\n+        -529,\n+        -525,\n+        -522,\n+        -519,\n+        -515,\n+        -512,\n+        -509,\n+        -505,\n+        -502,\n+        -499,\n+        -495,\n+        -492,\n+        -489,\n+        -485,\n+        -482,\n+        -479,\n+        -475,\n+        -472,\n+        -469,\n+        -465,\n+        -462,\n+        -459,\n+        -455,\n+        -452,\n+        -449,\n+        -446,\n+        -442,\n+        -439,\n+        -436,\n+        -432,\n+        -429,\n+        -426,\n+        -422,\n+        -419,\n+        -416,\n+        -412,\n+        -409,\n+        -406,\n+        -402,\n+        -399,\n+        -396,\n+        -392,\n+        -389,\n+        -386,\n+        -382,\n+        -379,\n+        -376,\n+        -372,\n+        -369,\n+        -366,\n+        -362,\n+        -359,\n+        -356,\n+        -353,\n+        -349,\n+        -346,\n+        -343,\n+        -339,\n+        -336,\n+        -333,\n+        -329,\n+        -326,\n+        -323,\n+        -319,\n+        -316,\n+        -313,\n+        -309,\n+        -306,\n+        -303,\n+        -299,\n+        -296,\n+        -293,\n+        -289,\n+        -286,\n+        -283,\n+        -279,\n+        -276,\n+        -273,\n+        -269,\n+        -266,\n+        -263,\n+        -259,\n+        -256,\n+        -253,\n+        -250,\n+        -246,\n+        -243,\n+        -240,\n+        -236,\n+        -233,\n+        -230,\n+        -226,\n+        -223,\n+        -220,\n+        -216,\n+        -213,\n+        -210,\n+        -206,\n+        -203,\n+        -200,\n+        -196,\n+        -193,\n+        -190,\n+        -186,\n+        -183,\n+        -180,\n+        -176,\n+        -173,\n+        -170,\n+        -166,\n+        -163,\n+        -160,\n+        -157,\n+        -153,\n+        -150,\n+        -147,\n+        -143,\n+        -140,\n+        -137,\n+        -133,\n+        -130,\n+        -127,\n+        -123,\n+        -120,\n+        -117,\n+        -113,\n+        -110,\n+        -107,\n+        -103,\n+        -100,\n+        -97,\n+        -93,\n+        -90,\n+        -87,\n+        -83,\n+        -80,\n+        -77,\n+        -73,\n+        -70,\n+        -67,\n+        -63,\n+        -60,\n+        -57,\n+        -54,\n+        -50,\n+        -47,\n+        -44,\n+        -40,\n+        -37,\n+        -34,\n+        -30,\n+        -27,\n+        -24,\n+        -20,\n+        -17,\n+        -14,\n+        -10,\n+        -7,\n+        -4,\n+        0,\n+        3,\n+        6,\n+        10,\n+        13,\n+        16,\n+        20,\n+        23,\n+        26,\n+        30,\n+        33,\n+        36,\n+        39,\n+        43,\n+        46,\n+        49,\n+        53,\n+        56,\n+        59,\n+        63,\n+        66,\n+        69,\n+        73,\n+        76,\n+        79,\n+        83,\n+        86,\n+        89,\n+        93,\n+        96,\n+        99,\n+        103,\n+        106,\n+        109,\n+        113,\n+        116,\n+        119,\n+        123,\n+        126,\n+        129,\n+        132,\n+        136,\n+        139,\n+        142,\n+        146,\n+        149,\n+        152,\n+        156,\n+        159,\n+        162,\n+        166,\n+        169,\n+        172,\n+        176,\n+        179,\n+        182,\n+        186,\n+        189,\n+        192,\n+        196,\n+        199,\n+        202,\n+        206,\n+        209,\n+        212,\n+        216,\n+        219,\n+        222,\n+        226,\n+        229,\n+        232,\n+        235,\n+        239,\n+        242,\n+        245,\n+        249,\n+        252,\n+        255,\n+        259,\n+        262,\n+        265,\n+        269,\n+        272,\n+        275,\n+        279,\n+        282,\n+        285,\n+        289,\n+        292,\n+        295,\n+        299,\n+        302,\n+        305,\n+        309,\n+        312,\n+        315,\n+        319,\n+        322,\n+        325,\n+        328,\n+        332,\n+        335,\n+        338,\n+        342,\n+        345,\n+        348,\n+        352,\n+        355,\n+        358,\n+        362,\n+        365,\n+        368,\n+        372,\n+        375,\n+        378,\n+        382,\n+        385,\n+        388,\n+        392,\n+        395,\n+        398,\n+        402,\n+        405,\n+        408,\n+        412,\n+        415,\n+        418,\n+        422,\n+        425,\n+        428,\n+        431,\n+        435,\n+        438,\n+        441,\n+        445,\n+        448,\n+        451,\n+        455,\n+        458,\n+        461,\n+        465,\n+        468,\n+        471,\n+        475,\n+        478,\n+        481,\n+        485,\n+        488,\n+        491,\n+        495,\n+        498,\n+        501,\n+        505,\n+        508,\n+        511,\n+        515,\n+        518,\n+        521,\n+        524,\n+        528,\n+        531,\n+        534,\n+        538,\n+        541,\n+        544,\n+        548,\n+        551,\n+        554,\n+        558,\n+        561,\n+        564,\n+        568,\n+        571,\n+        574,\n+        578,\n+        581,\n+        584,\n+        588,\n+        591,\n+        594,\n+        598,\n+        601,\n+        604,\n+        608,\n+        611,\n+        614,\n+        617,\n+        621,\n+        624,\n+        627,\n+        631,\n+        634,\n+        637,\n+        641,\n+        644,\n+        647,\n+        651,\n+        654,\n+        657,\n+        661,\n+        664,\n+        667,\n+        671,\n+        674,\n+        677,\n+        681,\n+        684,\n+        687,\n+        691,\n+        694,\n+        697,\n+        701,\n+        704,\n+        707,\n+        711,\n+        714,\n+        717,\n+        720,\n+        724,\n+        727,\n+        730,\n+        734,\n+        737,\n+        740,\n+        744,\n+        747,\n+        750,\n+        754,\n+        757,\n+        760,\n+        764,\n+        767,\n+        770,\n+        774,\n+        777,\n+        780,\n+        784,\n+        787,\n+        790,\n+        794,\n+        797,\n+        800,\n+        804,\n+        807,\n+        810,\n+        813,\n+        817,\n+        820,\n+        823,\n+        827,\n+        830,\n+        833,\n+        837,\n+        840,\n+        843,\n+        847,\n+        850,\n+        853,\n+        857,\n+        860,\n+        863,\n+        867,\n+        870,\n+        873,\n+        877,\n+        880,\n+        883,\n+        887,\n+        890,\n+        893,\n+        897,\n+        900,\n+        903,\n+        907,\n+        910,\n+        913,\n+        916,\n+        920,\n+        923,\n+        926,\n+        930,\n+        933,\n+        936,\n+        940,\n+        943,\n+        946,\n+        950,\n+    ],\n+);\n \n+#[rustfmt::skip]\n pub const F32_SHORT_POWERS: [f32; 11] = [\n     1e0,\n     1e1,\n@@ -1244,6 +1249,7 @@ pub const F32_SHORT_POWERS: [f32; 11] = [\n     1e10,\n ];\n \n+#[rustfmt::skip]\n pub const F64_SHORT_POWERS: [f64; 23] = [\n     1e0,\n     1e1,"}, {"sha": "0e601d45a2124ba8bfc569641fe7e9f5eb4102b4", "filename": "src/libcore/num/diy_float.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdiy_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fdiy_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdiy_float.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -3,9 +3,11 @@\n // This module is only for dec2flt and flt2dec, and only public because of coretests.\n // It is not intended to ever be stabilized.\n #![doc(hidden)]\n-#![unstable(feature = \"core_private_diy_float\",\n-            reason = \"internal routines only exposed for testing\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"core_private_diy_float\",\n+    reason = \"internal routines only exposed for testing\",\n+    issue = \"0\"\n+)]\n \n /// A custom 64-bit floating point type, representing `f * 2^e`.\n #[derive(Copy, Clone, Debug)]\n@@ -74,9 +76,6 @@ impl Fp {\n         assert!(edelta >= 0);\n         let edelta = edelta as usize;\n         assert_eq!(self.f << edelta >> edelta, self.f);\n-        Fp {\n-            f: self.f << edelta,\n-            e,\n-        }\n+        Fp { f: self.f << edelta, e }\n     }\n }"}, {"sha": "ac06f95e244b6f97c407804b0812dac9d151fa12", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -7,9 +7,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[cfg(not(bootstrap))]\n+use crate::convert::FloatToInt;\n #[cfg(not(test))]\n use crate::intrinsics;\n-\n use crate::mem;\n use crate::num::FpCategory;\n \n@@ -26,7 +27,7 @@ pub const DIGITS: u32 = 6;\n \n /// [Machine epsilon] value for `f32`.\n ///\n-/// This is the difference between `1.0` and the next largest representable number.\n+/// This is the difference between `1.0` and the next larger representable number.\n ///\n /// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -75,6 +76,12 @@ pub mod consts {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const PI: f32 = 3.14159265358979323846264338327950288_f32;\n \n+    /// The full circle constant (\u03c4)\n+    ///\n+    /// Equal to 2\u03c0.\n+    #[unstable(feature = \"tau_constant\", issue = \"66770\")]\n+    pub const TAU: f32 = 6.28318530717958647692528676655900577_f32;\n+\n     /// \u03c0/2\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;\n@@ -394,6 +401,35 @@ impl f32 {\n         intrinsics::minnumf32(self, other)\n     }\n \n+    /// Rounds toward zero and converts to any primitive integer type,\n+    /// assuming that the value is finite and fits in that type.\n+    ///\n+    /// ```\n+    /// #![feature(float_approx_unchecked_to)]\n+    ///\n+    /// let value = 4.6_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<u16>() };\n+    /// assert_eq!(rounded, 4);\n+    ///\n+    /// let value = -128.9_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<i8>() };\n+    /// assert_eq!(rounded, std::i8::MIN);\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The value must:\n+    ///\n+    /// * Not be `NaN`\n+    /// * Not be infinite\n+    /// * Be representable in the return type `Int`, after truncating off its fractional part\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[inline]\n+    pub unsafe fn approx_unchecked_to<Int>(self) -> Int where Self: FloatToInt<Int> {\n+        FloatToInt::<Int>::approx_unchecked(self)\n+    }\n+\n     /// Raw transmutation to `u32`.\n     ///\n     /// This is currently identical to `transmute::<f32, u32>(self)` on all platforms."}, {"sha": "794f77fcfc1be379e879214ee5a4cd2672ac9ae8", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -7,9 +7,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[cfg(not(bootstrap))]\n+use crate::convert::FloatToInt;\n #[cfg(not(test))]\n use crate::intrinsics;\n-\n use crate::mem;\n use crate::num::FpCategory;\n \n@@ -26,7 +27,7 @@ pub const DIGITS: u32 = 15;\n \n /// [Machine epsilon] value for `f64`.\n ///\n-/// This is the difference between `1.0` and the next largest representable number.\n+/// This is the difference between `1.0` and the next larger representable number.\n ///\n /// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -75,6 +76,12 @@ pub mod consts {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const PI: f64 = 3.14159265358979323846264338327950288_f64;\n \n+    /// The full circle constant (\u03c4)\n+    ///\n+    /// Equal to 2\u03c0.\n+    #[unstable(feature = \"tau_constant\", issue = \"66770\")]\n+    pub const TAU: f64 = 6.28318530717958647692528676655900577_f64;\n+\n     /// \u03c0/2\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;\n@@ -407,6 +414,35 @@ impl f64 {\n         intrinsics::minnumf64(self, other)\n     }\n \n+    /// Rounds toward zero and converts to any primitive integer type,\n+    /// assuming that the value is finite and fits in that type.\n+    ///\n+    /// ```\n+    /// #![feature(float_approx_unchecked_to)]\n+    ///\n+    /// let value = 4.6_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<u16>() };\n+    /// assert_eq!(rounded, 4);\n+    ///\n+    /// let value = -128.9_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<i8>() };\n+    /// assert_eq!(rounded, std::i8::MIN);\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The value must:\n+    ///\n+    /// * Not be `NaN`\n+    /// * Not be infinite\n+    /// * Be representable in the return type `Int`, after truncating off its fractional part\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[inline]\n+    pub unsafe fn approx_unchecked_to<Int>(self) -> Int where Self: FloatToInt<Int> {\n+        FloatToInt::<Int>::approx_unchecked(self)\n+    }\n+\n     /// Raw transmutation to `u64`.\n     ///\n     /// This is currently identical to `transmute::<f64, u64>(self)` on all platforms."}, {"sha": "2b74effbe2e988e5ae7645091a1e6d95cba985e9", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,8 +1,8 @@\n //! Decodes a floating-point value into individual parts and error ranges.\n \n-use crate::{f32, f64};\n-use crate::num::FpCategory;\n use crate::num::dec2flt::rawfp::RawFloat;\n+use crate::num::FpCategory;\n+use crate::{f32, f64};\n \n /// Decoded unsigned finite value, such that:\n ///\n@@ -47,11 +47,15 @@ pub trait DecodableFloat: RawFloat + Copy {\n }\n \n impl DecodableFloat for f32 {\n-    fn min_pos_norm_value() -> Self { f32::MIN_POSITIVE }\n+    fn min_pos_norm_value() -> Self {\n+        f32::MIN_POSITIVE\n+    }\n }\n \n impl DecodableFloat for f64 {\n-    fn min_pos_norm_value() -> Self { f64::MIN_POSITIVE }\n+    fn min_pos_norm_value() -> Self {\n+        f64::MIN_POSITIVE\n+    }\n }\n \n /// Returns a sign (true when negative) and `FullDecoded` value\n@@ -67,20 +71,29 @@ pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n             // neighbors: (mant - 2, exp) -- (mant, exp) -- (mant + 2, exp)\n             // Float::integer_decode always preserves the exponent,\n             // so the mantissa is scaled for subnormals.\n-            FullDecoded::Finite(Decoded { mant, minus: 1, plus: 1,\n-                                          exp, inclusive: even })\n+            FullDecoded::Finite(Decoded { mant, minus: 1, plus: 1, exp, inclusive: even })\n         }\n         FpCategory::Normal => {\n             let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();\n             if mant == minnorm.0 {\n                 // neighbors: (maxmant, exp - 1) -- (minnormmant, exp) -- (minnormmant + 1, exp)\n                 // where maxmant = minnormmant * 2 - 1\n-                FullDecoded::Finite(Decoded { mant: mant << 2, minus: 1, plus: 2,\n-                                              exp: exp - 2, inclusive: even })\n+                FullDecoded::Finite(Decoded {\n+                    mant: mant << 2,\n+                    minus: 1,\n+                    plus: 2,\n+                    exp: exp - 2,\n+                    inclusive: even,\n+                })\n             } else {\n                 // neighbors: (mant - 1, exp) -- (mant, exp) -- (mant + 1, exp)\n-                FullDecoded::Finite(Decoded { mant: mant << 1, minus: 1, plus: 1,\n-                                              exp: exp - 1, inclusive: even })\n+                FullDecoded::Finite(Decoded {\n+                    mant: mant << 1,\n+                    minus: 1,\n+                    plus: 1,\n+                    exp: exp - 1,\n+                    inclusive: even,\n+                })\n             }\n         }\n     };"}, {"sha": "63df5613453238988f1720f79eaf6fec1b97ca74", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 145, "deletions": 51, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -116,15 +116,17 @@ functions.\n // while this is extensively documented, this is in principle private which is\n // only made public for testing. do not expose us.\n #![doc(hidden)]\n-#![unstable(feature = \"flt2dec\",\n-            reason = \"internal routines only exposed for testing\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"flt2dec\",\n+    reason = \"internal routines only exposed for testing\",\n+    issue = \"0\"\n+)]\n \n+pub use self::decoder::{decode, DecodableFloat, Decoded, FullDecoded};\n use crate::i16;\n-pub use self::decoder::{decode, DecodableFloat, FullDecoded, Decoded};\n \n-pub mod estimator;\n pub mod decoder;\n+pub mod estimator;\n \n /// Digit-generation algorithms.\n pub mod strategy {\n@@ -144,17 +146,24 @@ pub const MAX_SIG_DIGITS: usize = 17;\n #[doc(hidden)]\n pub fn round_up(d: &mut [u8], n: usize) -> Option<u8> {\n     match d[..n].iter().rposition(|&c| c != b'9') {\n-        Some(i) => { // d[i+1..n] is all nines\n+        Some(i) => {\n+            // d[i+1..n] is all nines\n             d[i] += 1;\n-            for j in i+1..n { d[j] = b'0'; }\n+            for j in i + 1..n {\n+                d[j] = b'0';\n+            }\n             None\n         }\n-        None if n > 0 => { // 999..999 rounds to 1000..000 with an increased exponent\n+        None if n > 0 => {\n+            // 999..999 rounds to 1000..000 with an increased exponent\n             d[0] = b'1';\n-            for j in 1..n { d[j] = b'0'; }\n+            for j in 1..n {\n+                d[j] = b'0';\n+            }\n             Some(b'0')\n         }\n-        None => { // an empty buffer rounds up (a bit strange but reasonable)\n+        None => {\n+            // an empty buffer rounds up (a bit strange but reasonable)\n             Some(b'1')\n         }\n     }\n@@ -176,8 +185,19 @@ impl<'a> Part<'a> {\n     pub fn len(&self) -> usize {\n         match *self {\n             Part::Zero(nzeroes) => nzeroes,\n-            Part::Num(v) => if v < 1_000 { if v < 10 { 1 } else if v < 100 { 2 } else { 3 } }\n-                            else { if v < 10_000 { 4 } else { 5 } },\n+            Part::Num(v) => {\n+                if v < 1_000 {\n+                    if v < 10 {\n+                        1\n+                    } else if v < 100 {\n+                        2\n+                    } else {\n+                        3\n+                    }\n+                } else {\n+                    if v < 10_000 { 4 } else { 5 }\n+                }\n+            }\n             Part::Copy(buf) => buf.len(),\n         }\n     }\n@@ -190,7 +210,9 @@ impl<'a> Part<'a> {\n         if out.len() >= len {\n             match *self {\n                 Part::Zero(nzeroes) => {\n-                    for c in &mut out[..nzeroes] { *c = b'0'; }\n+                    for c in &mut out[..nzeroes] {\n+                        *c = b'0';\n+                    }\n                 }\n                 Part::Num(mut v) => {\n                     for c in out[..len].iter_mut().rev() {\n@@ -234,7 +256,9 @@ impl<'a> Formatted<'a> {\n     /// Returns the number of written bytes, or `None` if the buffer is not enough.\n     /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n     pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n-        if out.len() < self.sign.len() { return None; }\n+        if out.len() < self.sign.len() {\n+            return None;\n+        }\n         out[..self.sign.len()].copy_from_slice(self.sign);\n \n         let mut written = self.sign.len();\n@@ -254,8 +278,12 @@ impl<'a> Formatted<'a> {\n /// it will be ignored and full digits will be printed. It is only used to print\n /// additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n /// it will only print given digits and nothing else.\n-fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,\n-                         parts: &'a mut [Part<'a>]) -> &'a [Part<'a>] {\n+fn digits_to_dec_str<'a>(\n+    buf: &'a [u8],\n+    exp: i16,\n+    frac_digits: usize,\n+    parts: &'a mut [Part<'a>],\n+) -> &'a [Part<'a>] {\n     assert!(!buf.is_empty());\n     assert!(buf[0] > b'0');\n     assert!(parts.len() >= 4);\n@@ -322,8 +350,13 @@ fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,\n /// it will be ignored and full digits will be printed. It is only used to print\n /// additional zeroes after rendered digits. Thus, `min_digits == 0` means that\n /// it will only print the given digits and nothing else.\n-fn digits_to_exp_str<'a>(buf: &'a [u8], exp: i16, min_ndigits: usize, upper: bool,\n-                         parts: &'a mut [Part<'a>]) -> &'a [Part<'a>] {\n+fn digits_to_exp_str<'a>(\n+    buf: &'a [u8],\n+    exp: i16,\n+    min_ndigits: usize,\n+    upper: bool,\n+    parts: &'a mut [Part<'a>],\n+) -> &'a [Part<'a>] {\n     assert!(!buf.is_empty());\n     assert!(buf[0] > b'0');\n     assert!(parts.len() >= 6);\n@@ -359,11 +392,11 @@ fn digits_to_exp_str<'a>(buf: &'a [u8], exp: i16, min_ndigits: usize, upper: boo\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Sign {\n     /// Prints `-` only for the negative non-zero values.\n-    Minus,        // -inf -1  0  0  1  inf nan\n+    Minus, // -inf -1  0  0  1  inf nan\n     /// Prints `-` only for any negative values (including the negative zero).\n-    MinusRaw,     // -inf -1 -0  0  1  inf nan\n+    MinusRaw, // -inf -1 -0  0  1  inf nan\n     /// Prints `-` for the negative non-zero values, or `+` otherwise.\n-    MinusPlus,    // -inf -1 +0 +0 +1 +inf nan\n+    MinusPlus, // -inf -1 +0 +0 +1 +inf nan\n     /// Prints `-` for any negative values (including the negative zero), or `+` otherwise.\n     MinusPlusRaw, // -inf -1 -0 +0 +1 +inf nan\n }\n@@ -374,11 +407,35 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n     match (*decoded, sign) {\n         (FullDecoded::Nan, _) => b\"\",\n         (FullDecoded::Zero, Sign::Minus) => b\"\",\n-        (FullDecoded::Zero, Sign::MinusRaw) => if negative { b\"-\" } else { b\"\" },\n+        (FullDecoded::Zero, Sign::MinusRaw) => {\n+            if negative {\n+                b\"-\"\n+            } else {\n+                b\"\"\n+            }\n+        }\n         (FullDecoded::Zero, Sign::MinusPlus) => b\"+\",\n-        (FullDecoded::Zero, Sign::MinusPlusRaw) => if negative { b\"-\" } else { b\"+\" },\n-        (_, Sign::Minus) | (_, Sign::MinusRaw) => if negative { b\"-\" } else { b\"\" },\n-        (_, Sign::MinusPlus) | (_, Sign::MinusPlusRaw) => if negative { b\"-\" } else { b\"+\" },\n+        (FullDecoded::Zero, Sign::MinusPlusRaw) => {\n+            if negative {\n+                b\"-\"\n+            } else {\n+                b\"+\"\n+            }\n+        }\n+        (_, Sign::Minus) | (_, Sign::MinusRaw) => {\n+            if negative {\n+                b\"-\"\n+            } else {\n+                b\"\"\n+            }\n+        }\n+        (_, Sign::MinusPlus) | (_, Sign::MinusPlusRaw) => {\n+            if negative {\n+                b\"-\"\n+            } else {\n+                b\"+\"\n+            }\n+        }\n     }\n }\n \n@@ -400,10 +457,19 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n /// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n /// There should be at least 4 parts available, due to the worst case like\n /// `[+][0.][0000][2][0000]` with `frac_digits = 10`.\n-pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n-                                 sign: Sign, frac_digits: usize, _upper: bool,\n-                                 buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n-        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+pub fn to_shortest_str<'a, T, F>(\n+    mut format_shortest: F,\n+    v: T,\n+    sign: Sign,\n+    frac_digits: usize,\n+    _upper: bool,\n+    buf: &'a mut [u8],\n+    parts: &'a mut [Part<'a>],\n+) -> Formatted<'a>\n+where\n+    T: DecodableFloat,\n+    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+{\n     assert!(parts.len() >= 4);\n     assert!(buf.len() >= MAX_SIG_DIGITS);\n \n@@ -419,7 +485,8 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n             Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n-            if frac_digits > 0 { // [0.][0000]\n+            if frac_digits > 0 {\n+                // [0.][0000]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(frac_digits);\n                 Formatted { sign, parts: &parts[..2] }\n@@ -430,8 +497,7 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n         }\n         FullDecoded::Finite(ref decoded) => {\n             let (len, exp) = format_shortest(decoded, buf);\n-            Formatted { sign,\n-                        parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n+            Formatted { sign, parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n         }\n     }\n }\n@@ -455,10 +521,19 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n /// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n /// There should be at least 6 parts available, due to the worst case like\n /// `[+][1][.][2345][e][-][6]`.\n-pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n-                                     sign: Sign, dec_bounds: (i16, i16), upper: bool,\n-                                     buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n-        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+pub fn to_shortest_exp_str<'a, T, F>(\n+    mut format_shortest: F,\n+    v: T,\n+    sign: Sign,\n+    dec_bounds: (i16, i16),\n+    upper: bool,\n+    buf: &'a mut [u8],\n+    parts: &'a mut [Part<'a>],\n+) -> Formatted<'a>\n+where\n+    T: DecodableFloat,\n+    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+{\n     assert!(parts.len() >= 6);\n     assert!(buf.len() >= MAX_SIG_DIGITS);\n     assert!(dec_bounds.0 <= dec_bounds.1);\n@@ -534,10 +609,19 @@ fn estimate_max_buf_len(exp: i16) -> usize {\n /// (The tipping point for `f64` is about 800, so 1000 bytes should be enough.)\n /// There should be at least 6 parts available, due to the worst case like\n /// `[+][1][.][2345][e][-][6]`.\n-pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n-                                  sign: Sign, ndigits: usize, upper: bool,\n-                                  buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n-        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+pub fn to_exact_exp_str<'a, T, F>(\n+    mut format_exact: F,\n+    v: T,\n+    sign: Sign,\n+    ndigits: usize,\n+    upper: bool,\n+    buf: &'a mut [u8],\n+    parts: &'a mut [Part<'a>],\n+) -> Formatted<'a>\n+where\n+    T: DecodableFloat,\n+    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+{\n     assert!(parts.len() >= 6);\n     assert!(ndigits > 0);\n \n@@ -553,7 +637,8 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n             Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n-            if ndigits > 1 { // [0.][0000][e0]\n+            if ndigits > 1 {\n+                // [0.][0000][e0]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(ndigits - 1);\n                 parts[2] = Part::Copy(if upper { b\"E0\" } else { b\"e0\" });\n@@ -569,8 +654,7 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n \n             let trunc = if ndigits < maxlen { ndigits } else { maxlen };\n             let (len, exp) = format_exact(decoded, &mut buf[..trunc], i16::MIN);\n-            Formatted { sign,\n-                        parts: digits_to_exp_str(&buf[..len], exp, ndigits, upper, parts) }\n+            Formatted { sign, parts: digits_to_exp_str(&buf[..len], exp, ndigits, upper, parts) }\n         }\n     }\n }\n@@ -590,10 +674,19 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n /// (The tipping point for `f64` is about 800, and 1000 bytes should be enough.)\n /// There should be at least 4 parts available, due to the worst case like\n /// `[+][0.][0000][2][0000]` with `frac_digits = 10`.\n-pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n-                                    sign: Sign, frac_digits: usize, _upper: bool,\n-                                    buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n-        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+pub fn to_exact_fixed_str<'a, T, F>(\n+    mut format_exact: F,\n+    v: T,\n+    sign: Sign,\n+    frac_digits: usize,\n+    _upper: bool,\n+    buf: &'a mut [u8],\n+    parts: &'a mut [Part<'a>],\n+) -> Formatted<'a>\n+where\n+    T: DecodableFloat,\n+    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+{\n     assert!(parts.len() >= 4);\n \n     let (negative, full_decoded) = decode(v);\n@@ -608,7 +701,8 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n             Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n-            if frac_digits > 0 { // [0.][0000]\n+            if frac_digits > 0 {\n+                // [0.][0000]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(frac_digits);\n                 Formatted { sign, parts: &parts[..2] }\n@@ -631,7 +725,8 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n                 // `exp` was. this does not include the case that the restriction has been met\n                 // only after the final rounding-up; it's a regular case with `exp = limit + 1`.\n                 debug_assert_eq!(len, 0);\n-                if frac_digits > 0 { // [0.][0000]\n+                if frac_digits > 0 {\n+                    // [0.][0000]\n                     parts[0] = Part::Copy(b\"0.\");\n                     parts[1] = Part::Zero(frac_digits);\n                     Formatted { sign, parts: &parts[..2] }\n@@ -640,8 +735,7 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n                     Formatted { sign, parts: &parts[..1] }\n                 }\n             } else {\n-                Formatted { sign,\n-                            parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n+                Formatted { sign, parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n             }\n         }\n     }"}, {"sha": "c8de0004352efed9e9fd24d961b4bce2ec6fee75", "filename": "src/libcore/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 100, "deletions": 43, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -6,38 +6,54 @@\n \n use crate::cmp::Ordering;\n \n-use crate::num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};\n-use crate::num::flt2dec::estimator::estimate_scaling_factor;\n-use crate::num::bignum::Digit32 as Digit;\n use crate::num::bignum::Big32x40 as Big;\n+use crate::num::bignum::Digit32 as Digit;\n+use crate::num::flt2dec::estimator::estimate_scaling_factor;\n+use crate::num::flt2dec::{round_up, Decoded, MAX_SIG_DIGITS};\n \n-static POW10: [Digit; 10] = [1, 10, 100, 1000, 10000, 100000,\n-                             1000000, 10000000, 100000000, 1000000000];\n-static TWOPOW10: [Digit; 10] = [2, 20, 200, 2000, 20000, 200000,\n-                                2000000, 20000000, 200000000, 2000000000];\n+static POW10: [Digit; 10] =\n+    [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];\n+static TWOPOW10: [Digit; 10] =\n+    [2, 20, 200, 2000, 20000, 200000, 2000000, 20000000, 200000000, 2000000000];\n \n // precalculated arrays of `Digit`s for 10^(2^n)\n static POW10TO16: [Digit; 2] = [0x6fc10000, 0x2386f2];\n static POW10TO32: [Digit; 4] = [0, 0x85acef81, 0x2d6d415b, 0x4ee];\n static POW10TO64: [Digit; 7] = [0, 0, 0xbf6a1f01, 0x6e38ed64, 0xdaa797ed, 0xe93ff9f4, 0x184f03];\n-static POW10TO128: [Digit; 14] =\n-    [0, 0, 0, 0, 0x2e953e01, 0x3df9909, 0xf1538fd, 0x2374e42f, 0xd3cff5ec, 0xc404dc08,\n-     0xbccdb0da, 0xa6337f19, 0xe91f2603, 0x24e];\n-static POW10TO256: [Digit; 27] =\n-    [0, 0, 0, 0, 0, 0, 0, 0, 0x982e7c01, 0xbed3875b, 0xd8d99f72, 0x12152f87, 0x6bde50c6,\n-     0xcf4a6e70, 0xd595d80f, 0x26b2716e, 0xadc666b0, 0x1d153624, 0x3c42d35a, 0x63ff540e,\n-     0xcc5573c0, 0x65f9ef17, 0x55bc28f2, 0x80dcc7f7, 0xf46eeddc, 0x5fdcefce, 0x553f7];\n+static POW10TO128: [Digit; 14] = [\n+    0, 0, 0, 0, 0x2e953e01, 0x3df9909, 0xf1538fd, 0x2374e42f, 0xd3cff5ec, 0xc404dc08, 0xbccdb0da,\n+    0xa6337f19, 0xe91f2603, 0x24e,\n+];\n+static POW10TO256: [Digit; 27] = [\n+    0, 0, 0, 0, 0, 0, 0, 0, 0x982e7c01, 0xbed3875b, 0xd8d99f72, 0x12152f87, 0x6bde50c6, 0xcf4a6e70,\n+    0xd595d80f, 0x26b2716e, 0xadc666b0, 0x1d153624, 0x3c42d35a, 0x63ff540e, 0xcc5573c0, 0x65f9ef17,\n+    0x55bc28f2, 0x80dcc7f7, 0xf46eeddc, 0x5fdcefce, 0x553f7,\n+];\n \n #[doc(hidden)]\n pub fn mul_pow10(x: &mut Big, n: usize) -> &mut Big {\n     debug_assert!(n < 512);\n-    if n &   7 != 0 { x.mul_small(POW10[n & 7]); }\n-    if n &   8 != 0 { x.mul_small(POW10[8]); }\n-    if n &  16 != 0 { x.mul_digits(&POW10TO16); }\n-    if n &  32 != 0 { x.mul_digits(&POW10TO32); }\n-    if n &  64 != 0 { x.mul_digits(&POW10TO64); }\n-    if n & 128 != 0 { x.mul_digits(&POW10TO128); }\n-    if n & 256 != 0 { x.mul_digits(&POW10TO256); }\n+    if n & 7 != 0 {\n+        x.mul_small(POW10[n & 7]);\n+    }\n+    if n & 8 != 0 {\n+        x.mul_small(POW10[8]);\n+    }\n+    if n & 16 != 0 {\n+        x.mul_digits(&POW10TO16);\n+    }\n+    if n & 32 != 0 {\n+        x.mul_digits(&POW10TO32);\n+    }\n+    if n & 64 != 0 {\n+        x.mul_digits(&POW10TO64);\n+    }\n+    if n & 128 != 0 {\n+        x.mul_digits(&POW10TO128);\n+    }\n+    if n & 256 != 0 {\n+        x.mul_digits(&POW10TO256);\n+    }\n     x\n }\n \n@@ -52,13 +68,30 @@ fn div_2pow10(x: &mut Big, mut n: usize) -> &mut Big {\n }\n \n // only usable when `x < 16 * scale`; `scaleN` should be `scale.mul_small(N)`\n-fn div_rem_upto_16<'a>(x: &'a mut Big, scale: &Big,\n-                       scale2: &Big, scale4: &Big, scale8: &Big) -> (u8, &'a mut Big) {\n+fn div_rem_upto_16<'a>(\n+    x: &'a mut Big,\n+    scale: &Big,\n+    scale2: &Big,\n+    scale4: &Big,\n+    scale8: &Big,\n+) -> (u8, &'a mut Big) {\n     let mut d = 0;\n-    if *x >= *scale8 { x.sub(scale8); d += 8; }\n-    if *x >= *scale4 { x.sub(scale4); d += 4; }\n-    if *x >= *scale2 { x.sub(scale2); d += 2; }\n-    if *x >= *scale  { x.sub(scale);  d += 1; }\n+    if *x >= *scale8 {\n+        x.sub(scale8);\n+        d += 8;\n+    }\n+    if *x >= *scale4 {\n+        x.sub(scale4);\n+        d += 4;\n+    }\n+    if *x >= *scale2 {\n+        x.sub(scale2);\n+        d += 2;\n+    }\n+    if *x >= *scale {\n+        x.sub(scale);\n+        d += 1;\n+    }\n     debug_assert!(*x < *scale);\n     (d, x)\n }\n@@ -85,7 +118,7 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n     assert!(buf.len() >= MAX_SIG_DIGITS);\n \n     // `a.cmp(&b) < rounding` is `if d.inclusive {a <= b} else {a < b}`\n-    let rounding = if d.inclusive {Ordering::Greater} else {Ordering::Equal};\n+    let rounding = if d.inclusive { Ordering::Greater } else { Ordering::Equal };\n \n     // estimate `k_0` from original inputs satisfying `10^(k_0-1) < high <= 10^(k_0+1)`.\n     // the tight bound `k` satisfying `10^(k-1) < high <= 10^k` is calculated later.\n@@ -132,9 +165,12 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n     }\n \n     // cache `(2, 4, 8) * scale` for digit generation.\n-    let mut scale2 = scale.clone(); scale2.mul_pow2(1);\n-    let mut scale4 = scale.clone(); scale4.mul_pow2(2);\n-    let mut scale8 = scale.clone(); scale8.mul_pow2(3);\n+    let mut scale2 = scale.clone();\n+    scale2.mul_pow2(1);\n+    let mut scale4 = scale.clone();\n+    scale4.mul_pow2(2);\n+    let mut scale8 = scale.clone();\n+    scale8.mul_pow2(3);\n \n     let mut down;\n     let mut up;\n@@ -186,7 +222,9 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n         // - keep generating otherwise.\n         down = mant.cmp(&minus) < rounding;\n         up = scale.cmp(mant.clone().add(&plus)) < rounding;\n-        if down || up { break; } // we have the shortest representation, proceed to the rounding\n+        if down || up {\n+            break;\n+        } // we have the shortest representation, proceed to the rounding\n \n         // restore the invariants.\n         // this makes the algorithm always terminating: `minus` and `plus` always increases,\n@@ -269,22 +307,40 @@ pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usi\n     if len > 0 {\n         // cache `(2, 4, 8) * scale` for digit generation.\n         // (this can be expensive, so do not calculate them when the buffer is empty.)\n-        let mut scale2 = scale.clone(); scale2.mul_pow2(1);\n-        let mut scale4 = scale.clone(); scale4.mul_pow2(2);\n-        let mut scale8 = scale.clone(); scale8.mul_pow2(3);\n+        let mut scale2 = scale.clone();\n+        scale2.mul_pow2(1);\n+        let mut scale4 = scale.clone();\n+        scale4.mul_pow2(2);\n+        let mut scale8 = scale.clone();\n+        scale8.mul_pow2(3);\n \n         for i in 0..len {\n-            if mant.is_zero() { // following digits are all zeroes, we stop here\n+            if mant.is_zero() {\n+                // following digits are all zeroes, we stop here\n                 // do *not* try to perform rounding! rather, fill remaining digits.\n-                for c in &mut buf[i..len] { *c = b'0'; }\n+                for c in &mut buf[i..len] {\n+                    *c = b'0';\n+                }\n                 return (len, k);\n             }\n \n             let mut d = 0;\n-            if mant >= scale8 { mant.sub(&scale8); d += 8; }\n-            if mant >= scale4 { mant.sub(&scale4); d += 4; }\n-            if mant >= scale2 { mant.sub(&scale2); d += 2; }\n-            if mant >= scale  { mant.sub(&scale);  d += 1; }\n+            if mant >= scale8 {\n+                mant.sub(&scale8);\n+                d += 8;\n+            }\n+            if mant >= scale4 {\n+                mant.sub(&scale4);\n+                d += 4;\n+            }\n+            if mant >= scale2 {\n+                mant.sub(&scale2);\n+                d += 2;\n+            }\n+            if mant >= scale {\n+                mant.sub(&scale);\n+                d += 1;\n+            }\n             debug_assert!(mant < scale);\n             debug_assert!(d < 10);\n             buf[i] = b'0' + d;\n@@ -296,8 +352,9 @@ pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usi\n     // if the following digits are exactly 5000..., check the prior digit and try to\n     // round to even (i.e., avoid rounding up when the prior digit is even).\n     let order = mant.cmp(scale.mul_small(5));\n-    if order == Ordering::Greater || (order == Ordering::Equal &&\n-                                      (len == 0 || buf[len-1] & 1 == 1)) {\n+    if order == Ordering::Greater\n+        || (order == Ordering::Equal && (len == 0 || buf[len - 1] & 1 == 1))\n+    {\n         // if rounding up changes the length, the exponent should also change.\n         // but we've been requested a fixed number of digits, so do not alter the buffer...\n         if let Some(c) = round_up(buf, len) {"}, {"sha": "1e2db212dd0de03a22acc82b504caa37d410d0da", "filename": "src/libcore/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 169, "deletions": 123, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -6,12 +6,13 @@\n //!   accurately with integers. SIGPLAN Not. 45, 6 (June 2010), 233-243.\n \n use crate::num::diy_float::Fp;\n-use crate::num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};\n-\n+use crate::num::flt2dec::{round_up, Decoded, MAX_SIG_DIGITS};\n \n // see the comments in `format_shortest_opt` for the rationale.\n-#[doc(hidden)] pub const ALPHA: i16 = -60;\n-#[doc(hidden)] pub const GAMMA: i16 = -32;\n+#[doc(hidden)]\n+pub const ALPHA: i16 = -60;\n+#[doc(hidden)]\n+pub const GAMMA: i16 = -32;\n \n /*\n # the following Python code generates this table:\n@@ -24,92 +25,95 @@ for i in xrange(-308, 333, 8):\n */\n \n #[doc(hidden)]\n-pub static CACHED_POW10: [(u64, i16, i16); 81] = [ // (f, e, k)\n+pub static CACHED_POW10: [(u64, i16, i16); 81] = [\n+    // (f, e, k)\n     (0xe61acf033d1a45df, -1087, -308),\n     (0xab70fe17c79ac6ca, -1060, -300),\n     (0xff77b1fcbebcdc4f, -1034, -292),\n     (0xbe5691ef416bd60c, -1007, -284),\n-    (0x8dd01fad907ffc3c,  -980, -276),\n-    (0xd3515c2831559a83,  -954, -268),\n-    (0x9d71ac8fada6c9b5,  -927, -260),\n-    (0xea9c227723ee8bcb,  -901, -252),\n-    (0xaecc49914078536d,  -874, -244),\n-    (0x823c12795db6ce57,  -847, -236),\n-    (0xc21094364dfb5637,  -821, -228),\n-    (0x9096ea6f3848984f,  -794, -220),\n-    (0xd77485cb25823ac7,  -768, -212),\n-    (0xa086cfcd97bf97f4,  -741, -204),\n-    (0xef340a98172aace5,  -715, -196),\n-    (0xb23867fb2a35b28e,  -688, -188),\n-    (0x84c8d4dfd2c63f3b,  -661, -180),\n-    (0xc5dd44271ad3cdba,  -635, -172),\n-    (0x936b9fcebb25c996,  -608, -164),\n-    (0xdbac6c247d62a584,  -582, -156),\n-    (0xa3ab66580d5fdaf6,  -555, -148),\n-    (0xf3e2f893dec3f126,  -529, -140),\n-    (0xb5b5ada8aaff80b8,  -502, -132),\n-    (0x87625f056c7c4a8b,  -475, -124),\n-    (0xc9bcff6034c13053,  -449, -116),\n-    (0x964e858c91ba2655,  -422, -108),\n-    (0xdff9772470297ebd,  -396, -100),\n-    (0xa6dfbd9fb8e5b88f,  -369,  -92),\n-    (0xf8a95fcf88747d94,  -343,  -84),\n-    (0xb94470938fa89bcf,  -316,  -76),\n-    (0x8a08f0f8bf0f156b,  -289,  -68),\n-    (0xcdb02555653131b6,  -263,  -60),\n-    (0x993fe2c6d07b7fac,  -236,  -52),\n-    (0xe45c10c42a2b3b06,  -210,  -44),\n-    (0xaa242499697392d3,  -183,  -36),\n-    (0xfd87b5f28300ca0e,  -157,  -28),\n-    (0xbce5086492111aeb,  -130,  -20),\n-    (0x8cbccc096f5088cc,  -103,  -12),\n-    (0xd1b71758e219652c,   -77,   -4),\n-    (0x9c40000000000000,   -50,    4),\n-    (0xe8d4a51000000000,   -24,   12),\n-    (0xad78ebc5ac620000,     3,   20),\n-    (0x813f3978f8940984,    30,   28),\n-    (0xc097ce7bc90715b3,    56,   36),\n-    (0x8f7e32ce7bea5c70,    83,   44),\n-    (0xd5d238a4abe98068,   109,   52),\n-    (0x9f4f2726179a2245,   136,   60),\n-    (0xed63a231d4c4fb27,   162,   68),\n-    (0xb0de65388cc8ada8,   189,   76),\n-    (0x83c7088e1aab65db,   216,   84),\n-    (0xc45d1df942711d9a,   242,   92),\n-    (0x924d692ca61be758,   269,  100),\n-    (0xda01ee641a708dea,   295,  108),\n-    (0xa26da3999aef774a,   322,  116),\n-    (0xf209787bb47d6b85,   348,  124),\n-    (0xb454e4a179dd1877,   375,  132),\n-    (0x865b86925b9bc5c2,   402,  140),\n-    (0xc83553c5c8965d3d,   428,  148),\n-    (0x952ab45cfa97a0b3,   455,  156),\n-    (0xde469fbd99a05fe3,   481,  164),\n-    (0xa59bc234db398c25,   508,  172),\n-    (0xf6c69a72a3989f5c,   534,  180),\n-    (0xb7dcbf5354e9bece,   561,  188),\n-    (0x88fcf317f22241e2,   588,  196),\n-    (0xcc20ce9bd35c78a5,   614,  204),\n-    (0x98165af37b2153df,   641,  212),\n-    (0xe2a0b5dc971f303a,   667,  220),\n-    (0xa8d9d1535ce3b396,   694,  228),\n-    (0xfb9b7cd9a4a7443c,   720,  236),\n-    (0xbb764c4ca7a44410,   747,  244),\n-    (0x8bab8eefb6409c1a,   774,  252),\n-    (0xd01fef10a657842c,   800,  260),\n-    (0x9b10a4e5e9913129,   827,  268),\n-    (0xe7109bfba19c0c9d,   853,  276),\n-    (0xac2820d9623bf429,   880,  284),\n-    (0x80444b5e7aa7cf85,   907,  292),\n-    (0xbf21e44003acdd2d,   933,  300),\n-    (0x8e679c2f5e44ff8f,   960,  308),\n-    (0xd433179d9c8cb841,   986,  316),\n-    (0x9e19db92b4e31ba9,  1013,  324),\n-    (0xeb96bf6ebadf77d9,  1039,  332),\n+    (0x8dd01fad907ffc3c, -980, -276),\n+    (0xd3515c2831559a83, -954, -268),\n+    (0x9d71ac8fada6c9b5, -927, -260),\n+    (0xea9c227723ee8bcb, -901, -252),\n+    (0xaecc49914078536d, -874, -244),\n+    (0x823c12795db6ce57, -847, -236),\n+    (0xc21094364dfb5637, -821, -228),\n+    (0x9096ea6f3848984f, -794, -220),\n+    (0xd77485cb25823ac7, -768, -212),\n+    (0xa086cfcd97bf97f4, -741, -204),\n+    (0xef340a98172aace5, -715, -196),\n+    (0xb23867fb2a35b28e, -688, -188),\n+    (0x84c8d4dfd2c63f3b, -661, -180),\n+    (0xc5dd44271ad3cdba, -635, -172),\n+    (0x936b9fcebb25c996, -608, -164),\n+    (0xdbac6c247d62a584, -582, -156),\n+    (0xa3ab66580d5fdaf6, -555, -148),\n+    (0xf3e2f893dec3f126, -529, -140),\n+    (0xb5b5ada8aaff80b8, -502, -132),\n+    (0x87625f056c7c4a8b, -475, -124),\n+    (0xc9bcff6034c13053, -449, -116),\n+    (0x964e858c91ba2655, -422, -108),\n+    (0xdff9772470297ebd, -396, -100),\n+    (0xa6dfbd9fb8e5b88f, -369, -92),\n+    (0xf8a95fcf88747d94, -343, -84),\n+    (0xb94470938fa89bcf, -316, -76),\n+    (0x8a08f0f8bf0f156b, -289, -68),\n+    (0xcdb02555653131b6, -263, -60),\n+    (0x993fe2c6d07b7fac, -236, -52),\n+    (0xe45c10c42a2b3b06, -210, -44),\n+    (0xaa242499697392d3, -183, -36),\n+    (0xfd87b5f28300ca0e, -157, -28),\n+    (0xbce5086492111aeb, -130, -20),\n+    (0x8cbccc096f5088cc, -103, -12),\n+    (0xd1b71758e219652c, -77, -4),\n+    (0x9c40000000000000, -50, 4),\n+    (0xe8d4a51000000000, -24, 12),\n+    (0xad78ebc5ac620000, 3, 20),\n+    (0x813f3978f8940984, 30, 28),\n+    (0xc097ce7bc90715b3, 56, 36),\n+    (0x8f7e32ce7bea5c70, 83, 44),\n+    (0xd5d238a4abe98068, 109, 52),\n+    (0x9f4f2726179a2245, 136, 60),\n+    (0xed63a231d4c4fb27, 162, 68),\n+    (0xb0de65388cc8ada8, 189, 76),\n+    (0x83c7088e1aab65db, 216, 84),\n+    (0xc45d1df942711d9a, 242, 92),\n+    (0x924d692ca61be758, 269, 100),\n+    (0xda01ee641a708dea, 295, 108),\n+    (0xa26da3999aef774a, 322, 116),\n+    (0xf209787bb47d6b85, 348, 124),\n+    (0xb454e4a179dd1877, 375, 132),\n+    (0x865b86925b9bc5c2, 402, 140),\n+    (0xc83553c5c8965d3d, 428, 148),\n+    (0x952ab45cfa97a0b3, 455, 156),\n+    (0xde469fbd99a05fe3, 481, 164),\n+    (0xa59bc234db398c25, 508, 172),\n+    (0xf6c69a72a3989f5c, 534, 180),\n+    (0xb7dcbf5354e9bece, 561, 188),\n+    (0x88fcf317f22241e2, 588, 196),\n+    (0xcc20ce9bd35c78a5, 614, 204),\n+    (0x98165af37b2153df, 641, 212),\n+    (0xe2a0b5dc971f303a, 667, 220),\n+    (0xa8d9d1535ce3b396, 694, 228),\n+    (0xfb9b7cd9a4a7443c, 720, 236),\n+    (0xbb764c4ca7a44410, 747, 244),\n+    (0x8bab8eefb6409c1a, 774, 252),\n+    (0xd01fef10a657842c, 800, 260),\n+    (0x9b10a4e5e9913129, 827, 268),\n+    (0xe7109bfba19c0c9d, 853, 276),\n+    (0xac2820d9623bf429, 880, 284),\n+    (0x80444b5e7aa7cf85, 907, 292),\n+    (0xbf21e44003acdd2d, 933, 300),\n+    (0x8e679c2f5e44ff8f, 960, 308),\n+    (0xd433179d9c8cb841, 986, 316),\n+    (0x9e19db92b4e31ba9, 1013, 324),\n+    (0xeb96bf6ebadf77d9, 1039, 332),\n ];\n \n-#[doc(hidden)] pub const CACHED_POW10_FIRST_E: i16 = -1087;\n-#[doc(hidden)] pub const CACHED_POW10_LAST_E: i16 = 1039;\n+#[doc(hidden)]\n+pub const CACHED_POW10_FIRST_E: i16 = -1087;\n+#[doc(hidden)]\n+pub const CACHED_POW10_LAST_E: i16 = 1039;\n \n #[doc(hidden)]\n pub fn cached_power(alpha: i16, gamma: i16) -> (i16, Fp) {\n@@ -128,30 +132,39 @@ pub fn max_pow10_no_more_than(x: u32) -> (u8, u32) {\n     debug_assert!(x > 0);\n \n     const X9: u32 = 10_0000_0000;\n-    const X8: u32 =  1_0000_0000;\n-    const X7: u32 =    1000_0000;\n-    const X6: u32 =     100_0000;\n-    const X5: u32 =      10_0000;\n-    const X4: u32 =       1_0000;\n-    const X3: u32 =         1000;\n-    const X2: u32 =          100;\n-    const X1: u32 =           10;\n+    const X8: u32 = 1_0000_0000;\n+    const X7: u32 = 1000_0000;\n+    const X6: u32 = 100_0000;\n+    const X5: u32 = 10_0000;\n+    const X4: u32 = 1_0000;\n+    const X3: u32 = 1000;\n+    const X2: u32 = 100;\n+    const X1: u32 = 10;\n \n     if x < X4 {\n-        if x < X2 { if x < X1 {(0,  1)} else {(1, X1)} }\n-        else      { if x < X3 {(2, X2)} else {(3, X3)} }\n+        if x < X2 {\n+            if x < X1 { (0, 1) } else { (1, X1) }\n+        } else {\n+            if x < X3 { (2, X2) } else { (3, X3) }\n+        }\n     } else {\n-        if x < X6      { if x < X5 {(4, X4)} else {(5, X5)} }\n-        else if x < X8 { if x < X7 {(6, X6)} else {(7, X7)} }\n-        else           { if x < X9 {(8, X8)} else {(9, X9)} }\n+        if x < X6 {\n+            if x < X5 { (4, X4) } else { (5, X5) }\n+        } else if x < X8 {\n+            if x < X7 { (6, X6) } else { (7, X7) }\n+        } else {\n+            if x < X9 { (8, X8) } else { (9, X9) }\n+        }\n     }\n }\n \n /// The shortest mode implementation for Grisu.\n ///\n /// It returns `None` when it would return an inexact representation otherwise.\n-pub fn format_shortest_opt(d: &Decoded,\n-                           buf: &mut [u8]) -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n+pub fn format_shortest_opt(\n+    d: &Decoded,\n+    buf: &mut [u8],\n+) -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n     assert!(d.mant > 0);\n     assert!(d.minus > 0);\n     assert!(d.plus > 0);\n@@ -208,8 +221,8 @@ pub fn format_shortest_opt(d: &Decoded,\n     // we start with the correct repr within the unsafe region, and try to find the closest repr\n     // to `v` which is also within the safe region. if we can't, we give up.\n     let plus1 = plus.f + 1;\n-//  let plus0 = plus.f - 1; // only for explanation\n-//  let minus0 = minus.f + 1; // only for explanation\n+    //  let plus0 = plus.f - 1; // only for explanation\n+    //  let minus0 = minus.f + 1; // only for explanation\n     let minus1 = minus.f - 1;\n     let e = -plus.e as usize; // shared exponent\n \n@@ -235,14 +248,15 @@ pub fn format_shortest_opt(d: &Decoded,\n     // (e.g., `x` = 32000, `y` = 32777; `kappa` = 2 since `y mod 10^3 = 777 < y - x = 777`.)\n     // the algorithm relies on the later verification phase to exclude `y`.\n     let delta1 = plus1 - minus1;\n-//  let delta1int = (delta1 >> e) as usize; // only for explanation\n+    //  let delta1int = (delta1 >> e) as usize; // only for explanation\n     let delta1frac = delta1 & ((1 << e) - 1);\n \n     // render integral parts, while checking for the accuracy at each step.\n     let mut kappa = max_kappa as i16;\n     let mut ten_kappa = max_ten_kappa; // 10^kappa\n     let mut remainder = plus1int; // digits yet to be rendered\n-    loop { // we always have at least one digit to render, as `plus1 >= 10^kappa`\n+    loop {\n+        // we always have at least one digit to render, as `plus1 >= 10^kappa`\n         // invariants:\n         // - `delta1int <= remainder < 10^(kappa+1)`\n         // - `plus1int = d[0..n-1] * 10^(kappa+1) + remainder`\n@@ -281,7 +295,8 @@ pub fn format_shortest_opt(d: &Decoded,\n     let mut remainder = plus1frac;\n     let mut threshold = delta1frac;\n     let mut ulp = 1;\n-    loop { // the next digit should be significant as we've tested that before breaking out\n+    loop {\n+        // the next digit should be significant as we've tested that before breaking out\n         // invariants, where `m = max_kappa + 1` (# of digits in the integral part):\n         // - `remainder < 2^e`\n         // - `plus1frac * 10^(n-m) = d[m..n-1] * 2^e + remainder`\n@@ -300,8 +315,15 @@ pub fn format_shortest_opt(d: &Decoded,\n \n         if r < threshold {\n             let ten_kappa = 1 << e; // implicit divisor\n-            return round_and_weed(&mut buf[..i], exp, r, threshold,\n-                                  (plus1 - v.f) * ulp, ten_kappa, ulp);\n+            return round_and_weed(\n+                &mut buf[..i],\n+                exp,\n+                r,\n+                threshold,\n+                (plus1 - v.f) * ulp,\n+                ten_kappa,\n+                ulp,\n+            );\n         }\n \n         // restore invariants\n@@ -325,8 +347,15 @@ pub fn format_shortest_opt(d: &Decoded,\n     // - `plus1v = (plus1 - v) * k` (and also, `threshold > plus1v` from prior invariants)\n     // - `ten_kappa = 10^kappa * k`\n     // - `ulp = 2^-e * k`\n-    fn round_and_weed(buf: &mut [u8], exp: i16, remainder: u64, threshold: u64, plus1v: u64,\n-                      ten_kappa: u64, ulp: u64) -> Option<(usize, i16)> {\n+    fn round_and_weed(\n+        buf: &mut [u8],\n+        exp: i16,\n+        remainder: u64,\n+        threshold: u64,\n+        plus1v: u64,\n+        ten_kappa: u64,\n+        ulp: u64,\n+    ) -> Option<(usize, i16)> {\n         assert!(!buf.is_empty());\n \n         // produce two approximations to `v` (actually `plus1 - v`) within 1.5 ulps.\n@@ -381,10 +410,11 @@ pub fn format_shortest_opt(d: &Decoded,\n             //\n             // consequently, we should stop when `TC1 || TC2 || (TC3a && TC3b)`. the following is\n             // equal to its inverse, `!TC1 && !TC2 && (!TC3a || !TC3b)`.\n-            while plus1w < plus1v_up &&\n-                  threshold - plus1w >= ten_kappa &&\n-                  (plus1w + ten_kappa < plus1v_up ||\n-                   plus1v_up - plus1w >= plus1w + ten_kappa - plus1v_up) {\n+            while plus1w < plus1v_up\n+                && threshold - plus1w >= ten_kappa\n+                && (plus1w + ten_kappa < plus1v_up\n+                    || plus1v_up - plus1w >= plus1w + ten_kappa - plus1v_up)\n+            {\n                 *last -= 1;\n                 debug_assert!(*last > b'0'); // the shortest repr cannot end with `0`\n                 plus1w += ten_kappa;\n@@ -395,10 +425,11 @@ pub fn format_shortest_opt(d: &Decoded,\n         //\n         // this is simply same to the terminating conditions for `v + 1 ulp`, with all `plus1v_up`\n         // replaced by `plus1v_down` instead. overflow analysis equally holds.\n-        if plus1w < plus1v_down &&\n-           threshold - plus1w >= ten_kappa &&\n-           (plus1w + ten_kappa < plus1v_down ||\n-            plus1v_down - plus1w >= plus1w + ten_kappa - plus1v_down) {\n+        if plus1w < plus1v_down\n+            && threshold - plus1w >= ten_kappa\n+            && (plus1w + ten_kappa < plus1v_down\n+                || plus1v_down - plus1w >= plus1w + ten_kappa - plus1v_down)\n+        {\n             return None;\n         }\n \n@@ -428,8 +459,11 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n /// The exact and fixed mode implementation for Grisu.\n ///\n /// It returns `None` when it would return an inexact representation otherwise.\n-pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n-                                -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n+pub fn format_exact_opt(\n+    d: &Decoded,\n+    buf: &mut [u8],\n+    limit: i16,\n+) -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n     assert!(d.mant > 0);\n     assert!(d.mant < (1 << 61)); // we need at least three bits of additional precision\n     assert!(!buf.is_empty());\n@@ -489,7 +523,8 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n     let mut kappa = max_kappa as i16;\n     let mut ten_kappa = max_ten_kappa; // 10^kappa\n     let mut remainder = vint; // digits yet to be rendered\n-    loop { // we always have at least one digit to render\n+    loop {\n+        // we always have at least one digit to render\n         // invariants:\n         // - `remainder < 10^(kappa+1)`\n         // - `vint = d[0..n-1] * 10^(kappa+1) + remainder`\n@@ -575,8 +610,15 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n     // - `remainder = (v % 10^kappa) * k`\n     // - `ten_kappa = 10^kappa * k`\n     // - `ulp = 2^-e * k`\n-    fn possibly_round(buf: &mut [u8], mut len: usize, mut exp: i16, limit: i16,\n-                      remainder: u64, ten_kappa: u64, ulp: u64) -> Option<(usize, i16)> {\n+    fn possibly_round(\n+        buf: &mut [u8],\n+        mut len: usize,\n+        mut exp: i16,\n+        limit: i16,\n+        remainder: u64,\n+        ten_kappa: u64,\n+        ulp: u64,\n+    ) -> Option<(usize, i16)> {\n         debug_assert!(remainder < ten_kappa);\n \n         //           10^kappa\n@@ -593,7 +635,9 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n         //\n         // error is too large that there are at least three possible representations\n         // between `v - 1 ulp` and `v + 1 ulp`. we cannot determine which one is correct.\n-        if ulp >= ten_kappa { return None; }\n+        if ulp >= ten_kappa {\n+            return None;\n+        }\n \n         //    10^kappa\n         //   :<------->:\n@@ -607,7 +651,9 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n         // in fact, 1/2 ulp is enough to introduce two possible representations.\n         // (remember that we need a unique representation for both `v - 1 ulp` and `v + 1 ulp`.)\n         // this won't overflow, as `ulp < ten_kappa` from the first check.\n-        if ten_kappa - ulp <= ulp { return None; }\n+        if ten_kappa - ulp <= ulp {\n+            return None;\n+        }\n \n         //     remainder\n         //       :<->|                           :"}, {"sha": "585f144cf8a9f3b76ce64f2851c47a03409acc48", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 330, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -4,7 +4,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::convert::TryFrom;\n use crate::fmt;\n use crate::intrinsics;\n use crate::mem;\n@@ -4701,7 +4700,7 @@ from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n /// The error type returned when a checked integral type conversion fails.\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub struct TryFromIntError(());\n+pub struct TryFromIntError(pub(crate) ());\n \n impl TryFromIntError {\n     #[unstable(feature = \"int_error_internals\",\n@@ -4728,206 +4727,6 @@ impl From<!> for TryFromIntError {\n     }\n }\n \n-// no possible bounds violation\n-macro_rules! try_from_unbounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(value: $source) -> Result<Self, Self::Error> {\n-                Ok(value as $target)\n-            }\n-        }\n-    )*}\n-}\n-\n-// only negative bounds\n-macro_rules! try_from_lower_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                if u >= 0 {\n-                    Ok(u as $target)\n-                } else {\n-                    Err(TryFromIntError(()))\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-// unsigned to signed (only positive bound)\n-macro_rules! try_from_upper_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                if u > (<$target>::max_value() as $source) {\n-                    Err(TryFromIntError(()))\n-                } else {\n-                    Ok(u as $target)\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-// all other cases\n-macro_rules! try_from_both_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                let min = <$target>::min_value() as $source;\n-                let max = <$target>::max_value() as $source;\n-                if u < min || u > max {\n-                    Err(TryFromIntError(()))\n-                } else {\n-                    Ok(u as $target)\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-macro_rules! rev {\n-    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n-        $mac!($target, $source);\n-    )*}\n-}\n-\n-// intra-sign conversions\n-try_from_upper_bounded!(u16, u8);\n-try_from_upper_bounded!(u32, u16, u8);\n-try_from_upper_bounded!(u64, u32, u16, u8);\n-try_from_upper_bounded!(u128, u64, u32, u16, u8);\n-\n-try_from_both_bounded!(i16, i8);\n-try_from_both_bounded!(i32, i16, i8);\n-try_from_both_bounded!(i64, i32, i16, i8);\n-try_from_both_bounded!(i128, i64, i32, i16, i8);\n-\n-// unsigned-to-signed\n-try_from_upper_bounded!(u8, i8);\n-try_from_upper_bounded!(u16, i8, i16);\n-try_from_upper_bounded!(u32, i8, i16, i32);\n-try_from_upper_bounded!(u64, i8, i16, i32, i64);\n-try_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n-\n-// signed-to-unsigned\n-try_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\n-try_from_lower_bounded!(i16, u16, u32, u64, u128);\n-try_from_lower_bounded!(i32, u32, u64, u128);\n-try_from_lower_bounded!(i64, u64, u128);\n-try_from_lower_bounded!(i128, u128);\n-try_from_both_bounded!(i16, u8);\n-try_from_both_bounded!(i32, u16, u8);\n-try_from_both_bounded!(i64, u32, u16, u8);\n-try_from_both_bounded!(i128, u64, u32, u16, u8);\n-\n-// usize/isize\n-try_from_upper_bounded!(usize, isize);\n-try_from_lower_bounded!(isize, usize);\n-\n-#[cfg(target_pointer_width = \"16\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8);\n-    try_from_unbounded!(usize, u16, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16);\n-    try_from_unbounded!(usize, i32, i64, i128);\n-\n-    try_from_both_bounded!(isize, u8);\n-    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8);\n-    try_from_unbounded!(isize, i16, i32, i64, i128);\n-\n-    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16);\n-    rev!(try_from_both_bounded, usize, i32, i64, i128);\n-\n-    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n-    rev!(try_from_both_bounded, isize, i32, i64, i128);\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8, u16);\n-    try_from_unbounded!(usize, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32);\n-    try_from_unbounded!(usize, i64, i128);\n-\n-    try_from_both_bounded!(isize, u8, u16);\n-    try_from_lower_bounded!(isize, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16);\n-    try_from_unbounded!(isize, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u32);\n-    rev!(try_from_upper_bounded, usize, u64, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n-    rev!(try_from_both_bounded, usize, i64, i128);\n-\n-    rev!(try_from_unbounded, isize, u16);\n-    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i32);\n-    rev!(try_from_both_bounded, isize, i64, i128);\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8, u16, u32);\n-    try_from_unbounded!(usize, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n-    try_from_unbounded!(usize, i128);\n-\n-    try_from_both_bounded!(isize, u8, u16, u32);\n-    try_from_lower_bounded!(isize, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16, i32);\n-    try_from_unbounded!(isize, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u32, u64);\n-    rev!(try_from_upper_bounded, usize, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n-    rev!(try_from_both_bounded, usize, i128);\n-\n-    rev!(try_from_unbounded, isize, u16, u32);\n-    rev!(try_from_upper_bounded, isize, u64, u128);\n-    rev!(try_from_unbounded, isize, i32, i64);\n-    rev!(try_from_both_bounded, isize, i128);\n-}\n-\n #[doc(hidden)]\n trait FromStrRadixHelper: PartialOrd + Copy {\n     fn min_value() -> Self;\n@@ -5110,131 +4909,3 @@ impl fmt::Display for ParseIntError {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::num::dec2flt::ParseFloatError;\n-\n-// Conversion traits for primitive integer and float types\n-// Conversions T -> T are covered by a blanket impl and therefore excluded\n-// Some conversions from and to usize/isize are not implemented due to portability concerns\n-macro_rules! impl_from {\n-    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n-        #[$attr]\n-        #[doc = $doc]\n-        impl From<$Small> for $Large {\n-            #[inline]\n-            fn from(small: $Small) -> $Large {\n-                small as $Large\n-            }\n-        }\n-    };\n-    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n-        impl_from!($Small,\n-                   $Large,\n-                   #[$attr],\n-                   concat!(\"Converts `\",\n-                           stringify!($Small),\n-                           \"` to `\",\n-                           stringify!($Large),\n-                           \"` losslessly.\"));\n-    }\n-}\n-\n-macro_rules! impl_from_bool {\n-    ($target: ty, #[$attr:meta]) => {\n-        impl_from!(bool, $target, #[$attr], concat!(\"Converts a `bool` to a `\",\n-            stringify!($target), \"`. The resulting value is `0` for `false` and `1` for `true`\n-values.\n-\n-# Examples\n-\n-```\n-assert_eq!(\", stringify!($target), \"::from(true), 1);\n-assert_eq!(\", stringify!($target), \"::from(false), 0);\n-```\"));\n-    };\n-}\n-\n-// Bool -> Any\n-impl_from_bool! { u8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { usize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { isize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-\n-// Unsigned -> Unsigned\n-impl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// Signed -> Signed\n-impl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// Unsigned -> Signed\n-impl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n-// which imply that pointer-sized integers must be at least 16 bits:\n-// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\n-impl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-impl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-\n-// RISC-V defines the possibility of a 128-bit address space (RV128).\n-\n-// CHERI proposes 256-bit \u201ccapabilities\u201d. Unclear if this would be relevant to usize/isize.\n-// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n-// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n-\n-\n-// Note: integers can only be represented with full precision in a float if\n-// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n-// Lossy float conversions are not implemented at this time.\n-\n-// Signed -> Float\n-impl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-\n-// Unsigned -> Float\n-impl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-\n-// Float -> Float\n-impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }"}, {"sha": "0ddfbd02aa5b02250b453f8d5e31dc10da69130a", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -4,7 +4,7 @@ use crate::ops::*;\n \n #[allow(unused_macros)]\n macro_rules! sh_impl_signed {\n-    ($t:ident, $f:ident) => (\n+    ($t:ident, $f:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -19,7 +19,7 @@ macro_rules! sh_impl_signed {\n             }\n         }\n         forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n-                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n+        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n@@ -44,7 +44,7 @@ macro_rules! sh_impl_signed {\n             }\n         }\n         forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n-                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n+        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n@@ -54,11 +54,11 @@ macro_rules! sh_impl_signed {\n             }\n         }\n         forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n-    )\n+    };\n }\n \n macro_rules! sh_impl_unsigned {\n-    ($t:ident, $f:ident) => (\n+    ($t:ident, $f:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -69,7 +69,7 @@ macro_rules! sh_impl_unsigned {\n             }\n         }\n         forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n-                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n+        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n@@ -90,7 +90,7 @@ macro_rules! sh_impl_unsigned {\n             }\n         }\n         forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n-                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n+        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n@@ -100,7 +100,7 @@ macro_rules! sh_impl_unsigned {\n             }\n         }\n         forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n-    )\n+    };\n }\n \n // FIXME (#23545): uncomment the remaining impls"}, {"sha": "59a72799e256726e20dbf7728f4c94298269d7d9", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -66,19 +66,13 @@\n #[lang = \"add\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n-    on(\n-        all(_Self=\"{integer}\", Rhs=\"{float}\"),\n-        message=\"cannot add a float to an integer\",\n-    ),\n-    on(\n-        all(_Self=\"{float}\", Rhs=\"{integer}\"),\n-        message=\"cannot add an integer to a float\",\n-    ),\n-    message=\"cannot add `{Rhs}` to `{Self}`\",\n-    label=\"no implementation for `{Self} + {Rhs}`\",\n+    on(all(_Self = \"{integer}\", Rhs = \"{float}\"), message = \"cannot add a float to an integer\",),\n+    on(all(_Self = \"{float}\", Rhs = \"{integer}\"), message = \"cannot add an integer to a float\",),\n+    message = \"cannot add `{Rhs}` to `{Self}`\",\n+    label = \"no implementation for `{Self} + {Rhs}`\"\n )]\n #[doc(alias = \"+\")]\n-pub trait Add<Rhs=Self> {\n+pub trait Add<Rhs = Self> {\n     /// The resulting type after applying the `+` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -173,10 +167,12 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"sub\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"cannot subtract `{Rhs}` from `{Self}`\",\n-                         label=\"no implementation for `{Self} - {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot subtract `{Rhs}` from `{Self}`\",\n+    label = \"no implementation for `{Self} - {Rhs}`\"\n+)]\n #[doc(alias = \"-\")]\n-pub trait Sub<Rhs=Self> {\n+pub trait Sub<Rhs = Self> {\n     /// The resulting type after applying the `-` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -293,10 +289,12 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"mul\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"cannot multiply `{Rhs}` to `{Self}`\",\n-                         label=\"no implementation for `{Self} * {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot multiply `{Rhs}` to `{Self}`\",\n+    label = \"no implementation for `{Self} * {Rhs}`\"\n+)]\n #[doc(alias = \"*\")]\n-pub trait Mul<Rhs=Self> {\n+pub trait Mul<Rhs = Self> {\n     /// The resulting type after applying the `*` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -417,10 +415,12 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"div\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"cannot divide `{Self}` by `{Rhs}`\",\n-                         label=\"no implementation for `{Self} / {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot divide `{Self}` by `{Rhs}`\",\n+    label = \"no implementation for `{Self} / {Rhs}`\"\n+)]\n #[doc(alias = \"/\")]\n-pub trait Div<Rhs=Self> {\n+pub trait Div<Rhs = Self> {\n     /// The resulting type after applying the `/` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -502,10 +502,12 @@ div_impl_float! { f32 f64 }\n /// ```\n #[lang = \"rem\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"cannot mod `{Self}` by `{Rhs}`\",\n-                         label=\"no implementation for `{Self} % {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot mod `{Self}` by `{Rhs}`\",\n+    label = \"no implementation for `{Self} % {Rhs}`\"\n+)]\n #[doc(alias = \"%\")]\n-pub trait Rem<Rhs=Self> {\n+pub trait Rem<Rhs = Self> {\n     /// The resulting type after applying the `%` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -534,7 +536,6 @@ macro_rules! rem_impl_integer {\n \n rem_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n-\n macro_rules! rem_impl_float {\n     ($($t:ty)*) => ($(\n \n@@ -616,8 +617,6 @@ pub trait Neg {\n     fn neg(self) -> Self::Output;\n }\n \n-\n-\n macro_rules! neg_impl_core {\n     ($id:ident => $body:expr, $($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -679,11 +678,13 @@ neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"add_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot add-assign `{Rhs}` to `{Self}`\",\n-                         label=\"no implementation for `{Self} += {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot add-assign `{Rhs}` to `{Self}`\",\n+    label = \"no implementation for `{Self} += {Rhs}`\"\n+)]\n #[doc(alias = \"+\")]\n #[doc(alias = \"+=\")]\n-pub trait AddAssign<Rhs=Self> {\n+pub trait AddAssign<Rhs = Self> {\n     /// Performs the `+=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn add_assign(&mut self, rhs: Rhs);\n@@ -735,11 +736,13 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"sub_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot subtract-assign `{Rhs}` from `{Self}`\",\n-                         label=\"no implementation for `{Self} -= {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot subtract-assign `{Rhs}` from `{Self}`\",\n+    label = \"no implementation for `{Self} -= {Rhs}`\"\n+)]\n #[doc(alias = \"-\")]\n #[doc(alias = \"-=\")]\n-pub trait SubAssign<Rhs=Self> {\n+pub trait SubAssign<Rhs = Self> {\n     /// Performs the `-=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn sub_assign(&mut self, rhs: Rhs);\n@@ -782,11 +785,13 @@ sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"mul_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot multiply-assign `{Rhs}` to `{Self}`\",\n-                         label=\"no implementation for `{Self} *= {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot multiply-assign `{Rhs}` to `{Self}`\",\n+    label = \"no implementation for `{Self} *= {Rhs}`\"\n+)]\n #[doc(alias = \"*\")]\n #[doc(alias = \"*=\")]\n-pub trait MulAssign<Rhs=Self> {\n+pub trait MulAssign<Rhs = Self> {\n     /// Performs the `*=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn mul_assign(&mut self, rhs: Rhs);\n@@ -829,11 +834,13 @@ mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"div_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot divide-assign `{Self}` by `{Rhs}`\",\n-                         label=\"no implementation for `{Self} /= {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot divide-assign `{Self}` by `{Rhs}`\",\n+    label = \"no implementation for `{Self} /= {Rhs}`\"\n+)]\n #[doc(alias = \"/\")]\n #[doc(alias = \"/=\")]\n-pub trait DivAssign<Rhs=Self> {\n+pub trait DivAssign<Rhs = Self> {\n     /// Performs the `/=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn div_assign(&mut self, rhs: Rhs);\n@@ -879,11 +886,13 @@ div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"rem_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot mod-assign `{Self}` by `{Rhs}``\",\n-                         label=\"no implementation for `{Self} %= {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot mod-assign `{Self}` by `{Rhs}``\",\n+    label = \"no implementation for `{Self} %= {Rhs}`\"\n+)]\n #[doc(alias = \"%\")]\n #[doc(alias = \"%=\")]\n-pub trait RemAssign<Rhs=Self> {\n+pub trait RemAssign<Rhs = Self> {\n     /// Performs the `%=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn rem_assign(&mut self, rhs: Rhs);"}, {"sha": "bcfff4a223bec7b63fad2b0f3d96c00dae05c9bc", "filename": "src/libcore/ops/bit.rs", "status": "modified", "additions": 58, "deletions": 38, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -112,9 +112,11 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitand\"]\n #[doc(alias = \"&\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} & {Rhs}`\",\n-                         label=\"no implementation for `{Self} & {Rhs}`\")]\n-pub trait BitAnd<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} & {Rhs}`\",\n+    label = \"no implementation for `{Self} & {Rhs}`\"\n+)]\n+pub trait BitAnd<Rhs = Self> {\n     /// The resulting type after applying the `&` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -196,9 +198,11 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitor\"]\n #[doc(alias = \"|\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} | {Rhs}`\",\n-                         label=\"no implementation for `{Self} | {Rhs}`\")]\n-pub trait BitOr<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} | {Rhs}`\",\n+    label = \"no implementation for `{Self} | {Rhs}`\"\n+)]\n+pub trait BitOr<Rhs = Self> {\n     /// The resulting type after applying the `|` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -283,9 +287,11 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitxor\"]\n #[doc(alias = \"^\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} ^ {Rhs}`\",\n-                         label=\"no implementation for `{Self} ^ {Rhs}`\")]\n-pub trait BitXor<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} ^ {Rhs}`\",\n+    label = \"no implementation for `{Self} ^ {Rhs}`\"\n+)]\n+pub trait BitXor<Rhs = Self> {\n     /// The resulting type after applying the `^` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -371,9 +377,11 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"shl\"]\n #[doc(alias = \"<<\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} << {Rhs}`\",\n-                         label=\"no implementation for `{Self} << {Rhs}`\")]\n-pub trait Shl<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} << {Rhs}`\",\n+    label = \"no implementation for `{Self} << {Rhs}`\"\n+)]\n+pub trait Shl<Rhs = Self> {\n     /// The resulting type after applying the `<<` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -385,7 +393,7 @@ pub trait Shl<Rhs=Self> {\n }\n \n macro_rules! shl_impl {\n-    ($t:ty, $f:ty) => (\n+    ($t:ty, $f:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for $t {\n             type Output = $t;\n@@ -398,7 +406,7 @@ macro_rules! shl_impl {\n         }\n \n         forward_ref_binop! { impl Shl, shl for $t, $f }\n-    )\n+    };\n }\n \n macro_rules! shl_impl_all {\n@@ -480,9 +488,11 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n #[lang = \"shr\"]\n #[doc(alias = \">>\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} >> {Rhs}`\",\n-                         label=\"no implementation for `{Self} >> {Rhs}`\")]\n-pub trait Shr<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} >> {Rhs}`\",\n+    label = \"no implementation for `{Self} >> {Rhs}`\"\n+)]\n+pub trait Shr<Rhs = Self> {\n     /// The resulting type after applying the `>>` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -494,7 +504,7 @@ pub trait Shr<Rhs=Self> {\n }\n \n macro_rules! shr_impl {\n-    ($t:ty, $f:ty) => (\n+    ($t:ty, $f:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shr<$f> for $t {\n             type Output = $t;\n@@ -507,7 +517,7 @@ macro_rules! shr_impl {\n         }\n \n         forward_ref_binop! { impl Shr, shr for $t, $f }\n-    )\n+    };\n }\n \n macro_rules! shr_impl_all {\n@@ -596,9 +606,11 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n #[lang = \"bitand_assign\"]\n #[doc(alias = \"&=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} &= {Rhs}`\",\n-                         label=\"no implementation for `{Self} &= {Rhs}`\")]\n-pub trait BitAndAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} &= {Rhs}`\",\n+    label = \"no implementation for `{Self} &= {Rhs}`\"\n+)]\n+pub trait BitAndAssign<Rhs = Self> {\n     /// Performs the `&=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitand_assign(&mut self, rhs: Rhs);\n@@ -645,9 +657,11 @@ bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitor_assign\"]\n #[doc(alias = \"|=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} |= {Rhs}`\",\n-                         label=\"no implementation for `{Self} |= {Rhs}`\")]\n-pub trait BitOrAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} |= {Rhs}`\",\n+    label = \"no implementation for `{Self} |= {Rhs}`\"\n+)]\n+pub trait BitOrAssign<Rhs = Self> {\n     /// Performs the `|=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitor_assign(&mut self, rhs: Rhs);\n@@ -694,9 +708,11 @@ bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitxor_assign\"]\n #[doc(alias = \"^=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} ^= {Rhs}`\",\n-                         label=\"no implementation for `{Self} ^= {Rhs}`\")]\n-pub trait BitXorAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} ^= {Rhs}`\",\n+    label = \"no implementation for `{Self} ^= {Rhs}`\"\n+)]\n+pub trait BitXorAssign<Rhs = Self> {\n     /// Performs the `^=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitxor_assign(&mut self, rhs: Rhs);\n@@ -741,16 +757,18 @@ bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"shl_assign\"]\n #[doc(alias = \"<<=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} <<= {Rhs}`\",\n-                         label=\"no implementation for `{Self} <<= {Rhs}`\")]\n-pub trait ShlAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} <<= {Rhs}`\",\n+    label = \"no implementation for `{Self} <<= {Rhs}`\"\n+)]\n+pub trait ShlAssign<Rhs = Self> {\n     /// Performs the `<<=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shl_assign(&mut self, rhs: Rhs);\n }\n \n macro_rules! shl_assign_impl {\n-    ($t:ty, $f:ty) => (\n+    ($t:ty, $f:ty) => {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for $t {\n             #[inline]\n@@ -761,7 +779,7 @@ macro_rules! shl_assign_impl {\n         }\n \n         forward_ref_op_assign! { impl ShlAssign, shl_assign for $t, $f }\n-    )\n+    };\n }\n \n macro_rules! shl_assign_impl_all {\n@@ -809,16 +827,18 @@ shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n #[lang = \"shr_assign\"]\n #[doc(alias = \">>=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} >>= {Rhs}`\",\n-                         label=\"no implementation for `{Self} >>= {Rhs}`\")]\n-pub trait ShrAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} >>= {Rhs}`\",\n+    label = \"no implementation for `{Self} >>= {Rhs}`\"\n+)]\n+pub trait ShrAssign<Rhs = Self> {\n     /// Performs the `>>=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shr_assign(&mut self, rhs: Rhs);\n }\n \n macro_rules! shr_assign_impl {\n-    ($t:ty, $f:ty) => (\n+    ($t:ty, $f:ty) => {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for $t {\n             #[inline]\n@@ -829,7 +849,7 @@ macro_rules! shr_assign_impl {\n         }\n \n         forward_ref_op_assign! { impl ShrAssign, shr_assign for $t, $f }\n-    )\n+    };\n }\n \n macro_rules! shr_assign_impl_all {"}, {"sha": "f521355a90722a07ae2c57d1eae8f29dab72e480", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -76,14 +76,18 @@ pub trait Deref {\n impl<T: ?Sized> Deref for &T {\n     type Target = T;\n \n-    fn deref(&self) -> &T { *self }\n+    fn deref(&self) -> &T {\n+        *self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for &mut T {\n     type Target = T;\n \n-    fn deref(&self) -> &T { *self }\n+    fn deref(&self) -> &T {\n+        *self\n+    }\n }\n \n /// Used for mutable dereferencing operations, like in `*v = 1;`.\n@@ -165,7 +169,9 @@ pub trait DerefMut: Deref {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> DerefMut for &mut T {\n-    fn deref_mut(&mut self) -> &mut T { *self }\n+    fn deref_mut(&mut self) -> &mut T {\n+        *self\n+    }\n }\n \n /// Indicates that a struct can be used as a method receiver, without the"}, {"sha": "505a65cee3de0265f5f0047395b656805e4ee33a", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -57,13 +57,16 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n-    on(Args=\"()\", note=\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n-    message=\"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n-    label=\"expected an `Fn<{Args}>` closure, found `{Self}`\",\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n+    ),\n+    message = \"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `Fn<{Args}>` closure, found `{Self}`\"\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n-pub trait Fn<Args> : FnMut<Args> {\n+pub trait Fn<Args>: FnMut<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n@@ -136,13 +139,16 @@ pub trait Fn<Args> : FnMut<Args> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n-    on(Args=\"()\", note=\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n-    message=\"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n-    label=\"expected an `FnMut<{Args}>` closure, found `{Self}`\",\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n+    ),\n+    message = \"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `FnMut<{Args}>` closure, found `{Self}`\"\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n-pub trait FnMut<Args> : FnOnce<Args> {\n+pub trait FnMut<Args>: FnOnce<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n@@ -207,9 +213,12 @@ pub trait FnMut<Args> : FnOnce<Args> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n-    on(Args=\"()\", note=\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n-    message=\"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n-    label=\"expected an `FnOnce<{Args}>` closure, found `{Self}`\",\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n+    ),\n+    message = \"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `FnOnce<{Args}>` closure, found `{Self}`\"\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n@@ -225,26 +234,29 @@ pub trait FnOnce<Args> {\n \n mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> Fn<A> for &F\n-        where F : Fn<A>\n+    impl<A, F: ?Sized> Fn<A> for &F\n+    where\n+        F: Fn<A>,\n     {\n         extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n             (**self).call(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> FnMut<A> for &F\n-        where F : Fn<A>\n+    impl<A, F: ?Sized> FnMut<A> for &F\n+    where\n+        F: Fn<A>,\n     {\n         extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n             (**self).call(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> FnOnce<A> for &F\n-        where F : Fn<A>\n+    impl<A, F: ?Sized> FnOnce<A> for &F\n+    where\n+        F: Fn<A>,\n     {\n         type Output = F::Output;\n \n@@ -254,17 +266,19 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> FnMut<A> for &mut F\n-        where F : FnMut<A>\n+    impl<A, F: ?Sized> FnMut<A> for &mut F\n+    where\n+        F: FnMut<A>,\n     {\n         extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n             (*self).call_mut(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> FnOnce<A> for &mut F\n-        where F : FnMut<A>\n+    impl<A, F: ?Sized> FnOnce<A> for &mut F\n+    where\n+        F: FnMut<A>,\n     {\n         type Output = F::Output;\n         extern \"rust-call\" fn call_once(self, args: A) -> F::Output {"}, {"sha": "aae0691122415ce4d3d766b294a026314da048db", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -51,8 +51,8 @@\n /// ```\n #[lang = \"index\"]\n #[rustc_on_unimplemented(\n-    message=\"the type `{Self}` cannot be indexed by `{Idx}`\",\n-    label=\"`{Self}` cannot be indexed by `{Idx}`\",\n+    message = \"the type `{Self}` cannot be indexed by `{Idx}`\",\n+    label = \"`{Self}` cannot be indexed by `{Idx}`\"\n )]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"]\")]\n@@ -142,22 +142,22 @@ pub trait Index<Idx: ?Sized> {\n #[lang = \"index_mut\"]\n #[rustc_on_unimplemented(\n     on(\n-        _Self=\"&str\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n+        _Self = \"&str\",\n+        note = \"you can use `.chars().nth()` or `.bytes().nth()`\n see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n     ),\n     on(\n-        _Self=\"str\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n+        _Self = \"str\",\n+        note = \"you can use `.chars().nth()` or `.bytes().nth()`\n see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n     ),\n     on(\n-        _Self=\"std::string::String\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n+        _Self = \"std::string::String\",\n+        note = \"you can use `.chars().nth()` or `.bytes().nth()`\n see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n     ),\n-    message=\"the type `{Self}` cannot be mutably indexed by `{Idx}`\",\n-    label=\"`{Self}` cannot be mutably indexed by `{Idx}`\",\n+    message = \"the type `{Self}` cannot be mutably indexed by `{Idx}`\",\n+    label = \"`{Self}` cannot be mutably indexed by `{Idx}`\"\n )]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"[\")]"}, {"sha": "80ab906961ee79b5f344bdbb221d98831e9f5fad", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -156,12 +156,12 @@ mod r#try;\n mod unsize;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::arith::{Add, Sub, Mul, Div, Rem, Neg};\n+pub use self::arith::{Add, Div, Mul, Neg, Rem, Sub};\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-pub use self::arith::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n+pub use self::arith::{AddAssign, DivAssign, MulAssign, RemAssign, SubAssign};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::bit::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n+pub use self::bit::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n pub use self::bit::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssign};\n \n@@ -184,7 +184,7 @@ pub use self::index::{Index, IndexMut};\n pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-pub use self::range::{RangeInclusive, RangeToInclusive, RangeBounds, Bound};\n+pub use self::range::{Bound, RangeBounds, RangeInclusive, RangeToInclusive};\n \n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n pub use self::r#try::Try;"}, {"sha": "a2250337a4dcab131b63c2c3590e2d535f0490c4", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -399,11 +399,7 @@ impl<Idx> RangeInclusive<Idx> {\n     #[inline]\n     #[rustc_promotable]\n     pub const fn new(start: Idx, end: Idx) -> Self {\n-        Self {\n-            start,\n-            end,\n-            is_empty: None,\n-        }\n+        Self { start, end, is_empty: None }\n     }\n \n     /// Returns the lower bound of the range (inclusive)."}, {"sha": "a748ee87ef99aa7ff915a872092522b2a7c35d33", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -5,19 +5,20 @@\n /// extracting those success or failure values from an existing instance and\n /// creating a new instance from a success or failure value.\n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n-#[rustc_on_unimplemented(\n+#[cfg_attr(not(bootstrap), rustc_on_unimplemented(\n on(all(\n any(from_method=\"from_error\", from_method=\"from_ok\"),\n from_desugaring=\"QuestionMark\"),\n message=\"the `?` operator can only be used in {ItemContext} \\\n                that returns `Result` or `Option` \\\n                (or another type that implements `{Try}`)\",\n-label=\"cannot use the `?` operator in {ItemContext} that returns `{Self}`\"),\n+label=\"cannot use the `?` operator in {ItemContext} that returns `{Self}`\",\n+enclosing_scope=\"this function should return `Result` or `Option` to accept `?`\"),\n on(all(from_method=\"into_result\", from_desugaring=\"QuestionMark\"),\n message=\"the `?` operator can only be applied to values \\\n                that implement `{Try}`\",\n label=\"the `?` operator cannot be applied to type `{Self}`\")\n-)]\n+))]\n #[doc(alias = \"?\")]\n pub trait Try {\n     /// The type of this value when viewed as successful."}, {"sha": "80fb5642a6a76d87228ab661fb03659858ca879a", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -39,35 +39,34 @@ pub trait CoerceUnsized<T: ?Sized> {\n \n // &mut T -> &mut U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n // &mut T -> &U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n+impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n // &mut T -> *mut U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n // &mut T -> *const U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n \n // &T -> &U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n // &T -> *const U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n \n // *mut T -> *mut U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n // *mut T -> *const U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n \n // *const T -> *const U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n-\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n \n /// This is used for object safety, to check that a method's receiver type can be dispatched on.\n ///\n@@ -90,13 +89,13 @@ pub trait DispatchFromDyn<T> {\n \n // &T -> &U\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n // &mut T -> &mut U\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut T {}\n // *const T -> *const U\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n // *mut T -> *mut U\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}"}, {"sha": "2066a484dac8091a3a294227c15093dca5e4d403", "filename": "src/libcore/option.rs", "status": "modified", "additions": 53, "deletions": 29, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -138,8 +138,11 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n-use crate::{convert, fmt, hint, mem, ops::{self, Deref, DerefMut}};\n use crate::pin::Pin;\n+use crate::{\n+    convert, fmt, hint, mem,\n+    ops::{self, Deref, DerefMut},\n+};\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n // `Iterator`, which is one. The compiler assumes that the `next` method of\n@@ -230,7 +233,10 @@ impl<T> Option<T> {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"option_result_contains\", issue = \"62358\")]\n-    pub fn contains<U>(&self, x: &U) -> bool where U: PartialEq<T> {\n+    pub fn contains<U>(&self, x: &U) -> bool\n+    where\n+        U: PartialEq<T>,\n+    {\n         match self {\n             Some(y) => x == y,\n             None => false,\n@@ -291,16 +297,13 @@ impl<T> Option<T> {\n         }\n     }\n \n-\n     /// Converts from [`Pin`]`<&Option<T>>` to `Option<`[`Pin`]`<&T>>`.\n     ///\n     /// [`Pin`]: ../pin/struct.Pin.html\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {\n-        unsafe {\n-            Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x))\n-        }\n+        unsafe { Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x)) }\n     }\n \n     /// Converts from [`Pin`]`<&mut Option<T>>` to `Option<`[`Pin`]`<&mut T>>`.\n@@ -309,9 +312,7 @@ impl<T> Option<T> {\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {\n-        unsafe {\n-            Pin::get_unchecked_mut(self).as_mut().map(|x| Pin::new_unchecked(x))\n-        }\n+        unsafe { Pin::get_unchecked_mut(self).as_mut().map(|x| Pin::new_unchecked(x)) }\n     }\n \n     /////////////////////////////////////////////////////////////////////////\n@@ -690,7 +691,7 @@ impl<T> Option<T> {\n     pub fn filter<P: FnOnce(&T) -> bool>(self, predicate: P) -> Self {\n         if let Some(x) = self {\n             if predicate(&x) {\n-                return Some(x)\n+                return Some(x);\n             }\n         }\n         None\n@@ -1228,7 +1229,9 @@ impl<T> Default for Option<T> {\n     /// assert!(opt.is_none());\n     /// ```\n     #[inline]\n-    fn default() -> Option<T> { None }\n+    fn default() -> Option<T> {\n+        None\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1302,7 +1305,7 @@ impl<'a, T> From<&'a mut Option<T>> for Option<&'a mut T> {\n \n #[derive(Clone, Debug)]\n struct Item<A> {\n-    opt: Option<A>\n+    opt: Option<A>,\n }\n \n impl<A> Iterator for Item<A> {\n@@ -1344,22 +1347,30 @@ unsafe impl<A> TrustedLen for Item<A> {}\n /// [`Option::iter`]: enum.Option.html#method.iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n-pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n+pub struct Iter<'a, A: 'a> {\n+    inner: Item<&'a A>,\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for Iter<'a, A> {\n     type Item = &'a A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<&'a A> { self.inner.next() }\n+    fn next(&mut self) -> Option<&'a A> {\n+        self.inner.next()\n+    }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<&'a A> {\n+        self.inner.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1390,22 +1401,30 @@ impl<A> Clone for Iter<'_, A> {\n /// [`Option::iter_mut`]: enum.Option.html#method.iter_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n-pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n+pub struct IterMut<'a, A: 'a> {\n+    inner: Item<&'a mut A>,\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for IterMut<'a, A> {\n     type Item = &'a mut A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }\n+    fn next(&mut self) -> Option<&'a mut A> {\n+        self.inner.next()\n+    }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<&'a mut A> {\n+        self.inner.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1427,22 +1446,30 @@ unsafe impl<A> TrustedLen for IterMut<'_, A> {}\n /// [`Option::into_iter`]: enum.Option.html#method.into_iter\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<A> { inner: Item<A> }\n+pub struct IntoIter<A> {\n+    inner: Item<A>,\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> { self.inner.next() }\n+    fn next(&mut self) -> Option<A> {\n+        self.inner.next()\n+    }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<A> {\n+        self.inner.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1523,14 +1550,11 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     ///\n     /// [`Iterator`]: ../iter/trait.Iterator.html\n     #[inline]\n-    fn from_iter<I: IntoIterator<Item=Option<A>>>(iter: I) -> Option<V> {\n+    fn from_iter<I: IntoIterator<Item = Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n-        iter.into_iter()\n-            .map(|x| x.ok_or(()))\n-            .collect::<Result<_, _>>()\n-            .ok()\n+        iter.into_iter().map(|x| x.ok_or(())).collect::<Result<_, _>>().ok()\n     }\n }\n "}, {"sha": "e924ee2036988781481131303e75f4fa1ae18330", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -176,6 +176,60 @@ pub struct Location<'a> {\n     col: u32,\n }\n \n+impl<'a> Location<'a> {\n+    /// Returns the source location of the caller of this function. If that function's caller is\n+    /// annotated then its call location will be returned, and so on up the stack to the first call\n+    /// within a non-tracked function body.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(track_caller)]\n+    /// use core::panic::Location;\n+    ///\n+    /// /// Returns the [`Location`] at which it is called.\n+    /// #[track_caller]\n+    /// fn get_caller_location() -> &'static Location<'static> {\n+    ///     Location::caller()\n+    /// }\n+    ///\n+    /// /// Returns a [`Location`] from within this function's definition.\n+    /// fn get_just_one_location() -> &'static Location<'static> {\n+    ///     get_caller_location()\n+    /// }\n+    ///\n+    /// let fixed_location = get_just_one_location();\n+    /// assert_eq!(fixed_location.file(), file!());\n+    /// assert_eq!(fixed_location.line(), 15);\n+    /// assert_eq!(fixed_location.column(), 5);\n+    ///\n+    /// // running the same untracked function in a different location gives us the same result\n+    /// let second_fixed_location = get_just_one_location();\n+    /// assert_eq!(fixed_location.file(), second_fixed_location.file());\n+    /// assert_eq!(fixed_location.line(), second_fixed_location.line());\n+    /// assert_eq!(fixed_location.column(), second_fixed_location.column());\n+    ///\n+    /// let this_location = get_caller_location();\n+    /// assert_eq!(this_location.file(), file!());\n+    /// assert_eq!(this_location.line(), 29);\n+    /// assert_eq!(this_location.column(), 21);\n+    ///\n+    /// // running the tracked function in a different location produces a different value\n+    /// let another_location = get_caller_location();\n+    /// assert_eq!(this_location.file(), another_location.file());\n+    /// assert_ne!(this_location.line(), another_location.line());\n+    /// assert_ne!(this_location.column(), another_location.column());\n+    /// ```\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"track_caller\",\n+               reason = \"uses #[track_caller] which is not yet stable\",\n+               issue = \"47809\")]\n+    #[track_caller]\n+    pub const fn caller() -> &'static Location<'static> {\n+        crate::intrinsics::caller_location()\n+    }\n+}\n+\n impl<'a> Location<'a> {\n     #![unstable(feature = \"panic_internals\",\n                 reason = \"internal details of the implementation of the `panic!` \\\n@@ -266,6 +320,16 @@ impl fmt::Display for Location<'_> {\n #[unstable(feature = \"std_internals\", issue = \"0\")]\n #[doc(hidden)]\n pub unsafe trait BoxMeUp {\n-    fn box_me_up(&mut self) -> *mut (dyn Any + Send);\n+    /// Take full ownership of the contents.\n+    /// The return type is actually `Box<dyn Any + Send>`, but we cannot use `Box` in libcore.\n+    ///\n+    /// After this method got called, only some dummy default value is left in `self`.\n+    /// Calling this method twice, or calling `get` after calling this method, is an error.\n+    ///\n+    /// The argument is borrowed because the panic runtime (`__rust_start_panic`) only\n+    /// gets a borrowed `dyn BoxMeUp`.\n+    fn take_box(&mut self) -> *mut (dyn Any + Send);\n+\n+    /// Just borrow the contents.\n     fn get(&mut self) -> &(dyn Any + Send);\n }"}, {"sha": "5a8d647396ddab6b3f5512f0d35e69b43332b355", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -11,13 +11,13 @@\n //! ```\n //!\n //! This definition allows for panicking with any general message, but it does not\n-//! allow for failing with a `Box<Any>` value. The reason for this is that libcore\n-//! is not allowed to allocate.\n+//! allow for failing with a `Box<Any>` value. (`PanicInfo` just contains a `&(dyn Any + Send)`,\n+//! for which we fill in a dummy value in `PanicInfo::internal_constructor`.)\n+//! The reason for this is that libcore is not allowed to allocate.\n //!\n //! This module contains a few other panicking functions, but these are just the\n //! necessary lang items for the compiler. All panics are funneled through this\n-//! one function. Currently, the actual symbol is declared in the standard\n-//! library, but the location of this may change over time.\n+//! one function. The actual symbol is declared through the `#[panic_handler]` attribute.\n \n // ignore-tidy-undocumented-unsafe\n \n@@ -72,6 +72,7 @@ pub fn panic_fmt(fmt: fmt::Arguments<'_>, location: &Location<'_>) -> ! {\n     }\n \n     // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n+    // that gets resolved to the `#[panic_handler]` function.\n     extern \"Rust\" {\n         #[lang = \"panic_impl\"]\n         fn panic_impl(pi: &PanicInfo<'_>) -> !;"}, {"sha": "88fa718ae9e62c37cb5ff890cf62c23c0fbb98ec", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -374,10 +374,10 @@\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]\n \n+use crate::cmp::{self, PartialEq, PartialOrd};\n use crate::fmt;\n use crate::marker::{Sized, Unpin};\n-use crate::cmp::{self, PartialEq, PartialOrd};\n-use crate::ops::{Deref, DerefMut, Receiver, CoerceUnsized, DispatchFromDyn};\n+use crate::ops::{CoerceUnsized, Deref, DerefMut, DispatchFromDyn, Receiver};\n \n /// A pinned pointer.\n ///\n@@ -646,7 +646,8 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     ///\n     /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U> where\n+    pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U>\n+    where\n         F: FnOnce(&T) -> &U,\n     {\n         let pointer = &*self.pointer;\n@@ -698,7 +699,8 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn get_mut(self) -> &'a mut T\n-        where T: Unpin,\n+    where\n+        T: Unpin,\n     {\n         self.pointer\n     }\n@@ -735,7 +737,8 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     ///\n     /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U> where\n+    pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U>\n+    where\n         F: FnOnce(&mut T) -> &mut U,\n     {\n         let pointer = Pin::get_unchecked_mut(self);\n@@ -789,13 +792,7 @@ impl<P: fmt::Pointer> fmt::Pointer for Pin<P> {\n // for other reasons, though, so we just need to take care not to allow such\n // impls to land in std.\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<P, U> CoerceUnsized<Pin<U>> for Pin<P>\n-where\n-    P: CoerceUnsized<U>,\n-{}\n+impl<P, U> CoerceUnsized<Pin<U>> for Pin<P> where P: CoerceUnsized<U> {}\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P>\n-where\n-    P: DispatchFromDyn<U>,\n-{}\n+impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}"}, {"sha": "66b5a90b77b919f6f6a1c894e3f185e2a64a5de2", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -25,25 +25,25 @@ pub use crate::mem::drop;\n pub use crate::clone::Clone;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::cmp::{PartialEq, PartialOrd, Eq, Ord};\n+pub use crate::cmp::{Eq, Ord, PartialEq, PartialOrd};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::convert::{AsRef, AsMut, Into, From};\n+pub use crate::convert::{AsMut, AsRef, From, Into};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n pub use crate::default::Default;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::iter::{Iterator, Extend, IntoIterator};\n+pub use crate::iter::{DoubleEndedIterator, ExactSizeIterator};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::iter::{DoubleEndedIterator, ExactSizeIterator};\n+pub use crate::iter::{Extend, IntoIterator, Iterator};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::option::Option::{self, Some, None};\n+pub use crate::option::Option::{self, None, Some};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::result::Result::{self, Ok, Err};\n+pub use crate::result::Result::{self, Err, Ok};\n \n // Re-exported built-in macros\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n@@ -56,37 +56,14 @@ pub use crate::hash::macros::Hash;\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(no_inline)]\n pub use crate::{\n-    asm,\n-    assert,\n-    cfg,\n-    column,\n-    compile_error,\n-    concat,\n-    concat_idents,\n-    env,\n-    file,\n-    format_args,\n-    format_args_nl,\n-    global_asm,\n-    include,\n-    include_bytes,\n-    include_str,\n-    line,\n-    log_syntax,\n-    module_path,\n-    option_env,\n-    stringify,\n-    trace_macros,\n+    asm, assert, cfg, column, compile_error, concat, concat_idents, env, file, format_args,\n+    format_args_nl, global_asm, include, include_bytes, include_str, line, log_syntax, module_path,\n+    option_env, stringify, trace_macros,\n };\n \n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow(deprecated)]\n #[doc(no_inline)]\n pub use crate::macros::builtin::{\n-    RustcDecodable,\n-    RustcEncodable,\n-    bench,\n-    global_allocator,\n-    test,\n-    test_case,\n+    bench, global_allocator, test, test_case, RustcDecodable, RustcEncodable,\n };"}, {"sha": "1e051dbebcaf82519fce4f8ff3cced23daffe80f", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1074,17 +1074,22 @@ impl<T: ?Sized> *const T {\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n     ///\n-    /// When calling this method, you have to ensure that if the pointer is\n-    /// non-NULL, then it is properly aligned, dereferencable (for the whole\n-    /// size of `T`) and points to an initialized instance of `T`. This applies\n-    /// even if the result of this method is unused!\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    /// - it is properly aligned\n+    /// - it must point to an initialized instance of T; in particular, the pointer must be\n+    ///   \"dereferencable\" in the sense defined [here].\n+    ///\n+    /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n     /// it is, the only safe approach is to ensure that they are indeed initialized.)\n     ///\n     /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. It is up to the\n-    /// caller to ensure that for the duration of this lifetime, the memory this\n-    /// pointer points to does not get written to outside of `UnsafeCell<U>`.\n+    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n+    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n+    /// the memory the pointer points to must not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// [here]: crate::ptr#safety\n     ///\n     /// # Examples\n     ///\n@@ -1929,18 +1934,23 @@ impl<T: ?Sized> *mut T {\n     /// of the returned pointer, nor can it ensure that the lifetime `'a`\n     /// returned is indeed a valid lifetime for the contained data.\n     ///\n-    /// When calling this method, you have to ensure that if the pointer is\n-    /// non-NULL, then it is properly aligned, dereferencable (for the whole\n-    /// size of `T`) and points to an initialized instance of `T`. This applies\n-    /// even if the result of this method is unused!\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    /// - it is properly aligned\n+    /// - it must point to an initialized instance of T; in particular, the pointer must be\n+    ///   \"dereferencable\" in the sense defined [here].\n+    ///\n+    /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n     /// it is the only safe approach is to ensure that they are indeed initialized.)\n     ///\n     /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. It is up to the\n-    /// caller to ensure that for the duration of this lifetime, the memory this\n-    /// pointer points to does not get accessed through any other pointer.\n+    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n+    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n+    /// the memory this pointer points to must not get accessed (read or written)\n+    /// through any other pointer.\n     ///\n+    /// [here]: crate::ptr#safety\n     /// [`as_ref`]: #method.as_ref\n     ///\n     /// # Examples"}, {"sha": "a121389bef3c9e5ad0bdfc56d963601fa7cc9b44", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,11 +1,11 @@\n+use crate::cmp::Ordering;\n use crate::convert::From;\n-use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::fmt;\n use crate::hash;\n use crate::marker::Unsize;\n use crate::mem;\n+use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::Unique;\n-use crate::cmp::Ordering;\n \n // ignore-tidy-undocumented-unsafe\n \n@@ -48,12 +48,12 @@ pub struct NonNull<T: ?Sized> {\n /// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n // N.B., this impl is unnecessary, but should provide better error messages.\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> !Send for NonNull<T> { }\n+impl<T: ?Sized> !Send for NonNull<T> {}\n \n /// `NonNull` pointers are not `Sync` because the data they reference may be aliased.\n // N.B., this impl is unnecessary, but should provide better error messages.\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> !Sync for NonNull<T> { }\n+impl<T: ?Sized> !Sync for NonNull<T> {}\n \n impl<T: Sized> NonNull<T> {\n     /// Creates a new `NonNull` that is dangling, but well-aligned.\n@@ -91,11 +91,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub fn new(ptr: *mut T) -> Option<Self> {\n-        if !ptr.is_null() {\n-            Some(unsafe { Self::new_unchecked(ptr) })\n-        } else {\n-            None\n-        }\n+        if !ptr.is_null() { Some(unsafe { Self::new_unchecked(ptr) }) } else { None }\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n@@ -131,9 +127,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> NonNull<U> {\n-        unsafe {\n-            NonNull::new_unchecked(self.as_ptr() as *mut U)\n-        }\n+        unsafe { NonNull::new_unchecked(self.as_ptr() as *mut U) }\n     }\n }\n \n@@ -146,13 +140,13 @@ impl<T: ?Sized> Clone for NonNull<T> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> Copy for NonNull<T> { }\n+impl<T: ?Sized> Copy for NonNull<T> {}\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n \n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<T: ?Sized> fmt::Debug for NonNull<T> {"}, {"sha": "546b7c9d777f59c39c99cc67a10d062192656afb", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,8 +1,8 @@\n use crate::convert::From;\n-use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::fmt;\n use crate::marker::{PhantomData, Unsize};\n use crate::mem;\n+use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::NonNull;\n \n // ignore-tidy-undocumented-unsafe\n@@ -27,9 +27,12 @@ use crate::ptr::NonNull;\n ///\n /// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n /// for any type which upholds Unique's aliasing requirements.\n-#[unstable(feature = \"ptr_internals\", issue = \"0\",\n-           reason = \"use `NonNull` instead and consider `PhantomData<T>` \\\n-                     (if you also use `#[may_dangle]`), `Send`, and/or `Sync`\")]\n+#[unstable(\n+    feature = \"ptr_internals\",\n+    issue = \"0\",\n+    reason = \"use `NonNull` instead and consider `PhantomData<T>` \\\n+              (if you also use `#[may_dangle]`), `Send`, and/or `Sync`\"\n+)]\n #[doc(hidden)]\n #[repr(transparent)]\n #[rustc_layout_scalar_valid_range_start(1)]\n@@ -48,14 +51,14 @@ pub struct Unique<T: ?Sized> {\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n+unsafe impl<T: Send + ?Sized> Send for Unique<T> {}\n \n /// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n+unsafe impl<T: Sync + ?Sized> Sync for Unique<T> {}\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: Sized> Unique<T> {\n@@ -71,9 +74,7 @@ impl<T: Sized> Unique<T> {\n     // FIXME: rename to dangling() to match NonNull?\n     #[inline]\n     pub const fn empty() -> Self {\n-        unsafe {\n-            Unique::new_unchecked(mem::align_of::<T>() as *mut T)\n-        }\n+        unsafe { Unique::new_unchecked(mem::align_of::<T>() as *mut T) }\n     }\n }\n \n@@ -128,9 +129,7 @@ impl<T: ?Sized> Unique<T> {\n     /// Casts to a pointer of another type.\n     #[inline]\n     pub const fn cast<U>(self) -> Unique<U> {\n-        unsafe {\n-            Unique::new_unchecked(self.as_ptr() as *mut U)\n-        }\n+        unsafe { Unique::new_unchecked(self.as_ptr() as *mut U) }\n     }\n }\n \n@@ -143,13 +142,13 @@ impl<T: ?Sized> Clone for Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> Copy for Unique<T> { }\n+impl<T: ?Sized> Copy for Unique<T> {}\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> {}\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> {}\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: ?Sized> fmt::Debug for Unique<T> {"}, {"sha": "019832e16f89cd20d25f6c508c55d5bfa081e72f", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 73, "deletions": 51, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -20,13 +20,16 @@ struct CopyOnDrop<T> {\n \n impl<T> Drop for CopyOnDrop<T> {\n     fn drop(&mut self) {\n-        unsafe { ptr::copy_nonoverlapping(self.src, self.dest, 1); }\n+        unsafe {\n+            ptr::copy_nonoverlapping(self.src, self.dest, 1);\n+        }\n     }\n }\n \n /// Shifts the first element to the right until it encounters a greater or equal element.\n fn shift_head<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n     unsafe {\n@@ -36,10 +39,7 @@ fn shift_head<T, F>(v: &mut [T], is_less: &mut F)\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n             let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(0)));\n-            let mut hole = CopyOnDrop {\n-                src: &mut *tmp,\n-                dest: v.get_unchecked_mut(1),\n-            };\n+            let mut hole = CopyOnDrop { src: &mut *tmp, dest: v.get_unchecked_mut(1) };\n             ptr::copy_nonoverlapping(v.get_unchecked(1), v.get_unchecked_mut(0), 1);\n \n             for i in 2..len {\n@@ -58,7 +58,8 @@ fn shift_head<T, F>(v: &mut [T], is_less: &mut F)\n \n /// Shifts the last element to the left until it encounters a smaller or equal element.\n fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n     unsafe {\n@@ -68,13 +69,10 @@ fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n             let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));\n-            let mut hole = CopyOnDrop {\n-                src: &mut *tmp,\n-                dest: v.get_unchecked_mut(len - 2),\n-            };\n+            let mut hole = CopyOnDrop { src: &mut *tmp, dest: v.get_unchecked_mut(len - 2) };\n             ptr::copy_nonoverlapping(v.get_unchecked(len - 2), v.get_unchecked_mut(len - 1), 1);\n \n-            for i in (0..len-2).rev() {\n+            for i in (0..len - 2).rev() {\n                 if !is_less(&*tmp, v.get_unchecked(i)) {\n                     break;\n                 }\n@@ -93,7 +91,8 @@ fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n /// Returns `true` if the slice is sorted at the end. This function is `O(n)` worst-case.\n #[cold]\n fn partial_insertion_sort<T, F>(v: &mut [T], is_less: &mut F) -> bool\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Maximum number of adjacent out-of-order pairs that will get shifted.\n     const MAX_STEPS: usize = 5;\n@@ -136,17 +135,19 @@ fn partial_insertion_sort<T, F>(v: &mut [T], is_less: &mut F) -> bool\n \n /// Sorts a slice using insertion sort, which is `O(n^2)` worst-case.\n fn insertion_sort<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     for i in 1..v.len() {\n-        shift_tail(&mut v[..i+1], is_less);\n+        shift_tail(&mut v[..i + 1], is_less);\n     }\n }\n \n /// Sorts `v` using heapsort, which guarantees `O(n log n)` worst-case.\n #[cold]\n pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // This binary heap respects the invariant `parent >= child`.\n     let mut sift_down = |v: &mut [T], mut node| {\n@@ -156,11 +157,8 @@ pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n             let right = 2 * node + 2;\n \n             // Choose the greater child.\n-            let greater = if right < v.len() && is_less(&v[left], &v[right]) {\n-                right\n-            } else {\n-                left\n-            };\n+            let greater =\n+                if right < v.len() && is_less(&v[left], &v[right]) { right } else { left };\n \n             // Stop if the invariant holds at `node`.\n             if greater >= v.len() || !is_less(&v[node], &v[greater]) {\n@@ -174,12 +172,12 @@ pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n     };\n \n     // Build the heap in linear time.\n-    for i in (0 .. v.len() / 2).rev() {\n+    for i in (0..v.len() / 2).rev() {\n         sift_down(v, i);\n     }\n \n     // Pop maximal elements from the heap.\n-    for i in (1 .. v.len()).rev() {\n+    for i in (1..v.len()).rev() {\n         v.swap(0, i);\n         sift_down(&mut v[..i], 0);\n     }\n@@ -195,7 +193,8 @@ pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n ///\n /// [pdf]: http://drops.dagstuhl.de/opus/volltexte/2016/6389/pdf/LIPIcs-ESA-2016-38.pdf\n fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Number of elements in a typical block.\n     const BLOCK: usize = 128;\n@@ -298,8 +297,16 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n         let count = cmp::min(width(start_l, end_l), width(start_r, end_r));\n \n         if count > 0 {\n-            macro_rules! left { () => { l.offset(*start_l as isize) } }\n-            macro_rules! right { () => { r.offset(-(*start_r as isize) - 1) } }\n+            macro_rules! left {\n+                () => {\n+                    l.offset(*start_l as isize)\n+                };\n+            }\n+            macro_rules! right {\n+                () => {\n+                    r.offset(-(*start_r as isize) - 1)\n+                };\n+            }\n \n             // Instead of swapping one pair at the time, it is more efficient to perform a cyclic\n             // permutation. This is not strictly equivalent to swapping, but produces a similar\n@@ -379,7 +386,8 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n /// 1. Number of elements smaller than `v[pivot]`.\n /// 2. True if `v` was already partitioned.\n fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     let (mid, was_partitioned) = {\n         // Place the pivot at the beginning of slice.\n@@ -390,10 +398,7 @@ fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n         // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n         // operation panics, the pivot will be automatically written back into the slice.\n         let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n-        let _pivot_guard = CopyOnDrop {\n-            src: &mut *tmp,\n-            dest: pivot,\n-        };\n+        let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n         let pivot = &*tmp;\n \n         // Find the first pair of out-of-order elements.\n@@ -429,7 +434,8 @@ fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n /// Returns the number of elements equal to the pivot. It is assumed that `v` does not contain\n /// elements smaller than the pivot.\n fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Place the pivot at the beginning of slice.\n     v.swap(0, pivot);\n@@ -439,10 +445,7 @@ fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n     // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n     // operation panics, the pivot will be automatically written back into the slice.\n     let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n-    let _pivot_guard = CopyOnDrop {\n-        src: &mut *tmp,\n-        dest: pivot,\n-    };\n+    let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n     let pivot = &*tmp;\n \n     // Now partition the slice.\n@@ -528,7 +531,8 @@ fn break_patterns<T>(v: &mut [T]) {\n ///\n /// Elements in `v` might be reordered in the process.\n fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Minimum length to choose the median-of-medians method.\n     // Shorter slices use the simple median-of-three method.\n@@ -596,7 +600,8 @@ fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n /// `limit` is the number of allowed imbalanced partitions before switching to `heapsort`. If zero,\n /// this function will immediately switch to heapsort.\n fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T>, mut limit: usize)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Slices of up to this length get sorted using insertion sort.\n     const MAX_INSERTION: usize = 20;\n@@ -650,7 +655,7 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n                 let mid = partition_equal(v, pivot, is_less);\n \n                 // Continue sorting elements greater than the pivot.\n-                v = &mut {v}[mid..];\n+                v = &mut { v }[mid..];\n                 continue;\n             }\n         }\n@@ -661,7 +666,7 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n         was_partitioned = was_p;\n \n         // Split the slice into `left`, `pivot`, and `right`.\n-        let (left, right) = {v}.split_at_mut(mid);\n+        let (left, right) = { v }.split_at_mut(mid);\n         let (pivot, right) = right.split_at_mut(1);\n         let pivot = &pivot[0];\n \n@@ -681,7 +686,8 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n \n /// Sorts `v` using pattern-defeating quicksort, which is `O(n log n)` worst-case.\n pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Sorting has no meaningful behavior on zero-sized types.\n     if mem::size_of::<T>() == 0 {\n@@ -694,8 +700,13 @@ pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n     recurse(v, &mut is_less, None, limit);\n }\n \n-fn partition_at_index_loop<'a, T, F>( mut v: &'a mut [T], mut index: usize, is_less: &mut F\n-                                    , mut pred: Option<&'a T>) where F: FnMut(&T, &T) -> bool\n+fn partition_at_index_loop<'a, T, F>(\n+    mut v: &'a mut [T],\n+    mut index: usize,\n+    is_less: &mut F,\n+    mut pred: Option<&'a T>,\n+) where\n+    F: FnMut(&T, &T) -> bool,\n {\n     loop {\n         // For slices of up to this length it's probably faster to simply sort them.\n@@ -731,7 +742,7 @@ fn partition_at_index_loop<'a, T, F>( mut v: &'a mut [T], mut index: usize, is_l\n         let (mid, _) = partition(v, pivot, is_less);\n \n         // Split the slice into `left`, `pivot`, and `right`.\n-        let (left, right) = {v}.split_at_mut(mid);\n+        let (left, right) = { v }.split_at_mut(mid);\n         let (pivot, right) = right.split_at_mut(1);\n         let pivot = &pivot[0];\n \n@@ -749,11 +760,16 @@ fn partition_at_index_loop<'a, T, F>( mut v: &'a mut [T], mut index: usize, is_l\n     }\n }\n \n-pub fn partition_at_index<T, F>(v: &mut [T], index: usize, mut is_less: F)\n-                                -> (&mut [T], &mut T, &mut [T]) where F: FnMut(&T, &T) -> bool\n+pub fn partition_at_index<T, F>(\n+    v: &mut [T],\n+    index: usize,\n+    mut is_less: F,\n+) -> (&mut [T], &mut T, &mut [T])\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n-    use cmp::Ordering::Less;\n     use cmp::Ordering::Greater;\n+    use cmp::Ordering::Less;\n \n     if index >= v.len() {\n         panic!(\"partition_at_index index {} greater than length of slice {}\", index, v.len());\n@@ -764,14 +780,20 @@ pub fn partition_at_index<T, F>(v: &mut [T], index: usize, mut is_less: F)\n     } else if index == v.len() - 1 {\n         // Find max element and place it in the last position of the array. We're free to use\n         // `unwrap()` here because we know v must not be empty.\n-        let (max_index, _) = v.iter().enumerate().max_by(\n-            |&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater }).unwrap();\n+        let (max_index, _) = v\n+            .iter()\n+            .enumerate()\n+            .max_by(|&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater })\n+            .unwrap();\n         v.swap(max_index, index);\n     } else if index == 0 {\n         // Find min element and place it in the first position of the array. We're free to use\n         // `unwrap()` here because we know v must not be empty.\n-        let (min_index, _) = v.iter().enumerate().min_by(\n-            |&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater }).unwrap();\n+        let (min_index, _) = v\n+            .iter()\n+            .enumerate()\n+            .min_by(|&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater })\n+            .unwrap();\n         v.swap(min_index, index);\n     } else {\n         partition_at_index_loop(v, index, &mut is_less, None);"}, {"sha": "b2a420f3c43778cc06d992c62dbaaa89410f931a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -3371,8 +3371,8 @@ impl str {\n     /// An iterator over the disjoint matches of a pattern within the given string\n     /// slice.\n     ///\n-    /// The pattern can be any type that implements the Pattern trait. Notable\n-    /// examples are `&str`, [`char`], and closures that determines the split.\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n     ///\n     /// # Iterator behavior\n     ///"}, {"sha": "6e1aac00c7bc5401e536dcba652394b4afb6428e", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -27,7 +27,7 @@\n //!\n //! Atomic variables are safe to share between threads (they implement [`Sync`])\n //! but they do not themselves provide the mechanism for sharing and follow the\n-//! [threading model](../../../std/thread/index.html#the-threading-model) of rust.\n+//! [threading model](../../../std/thread/index.html#the-threading-model) of Rust.\n //! The most common way to share an atomic variable is to put it into an [`Arc`][arc] (an\n //! atomically-reference-counted shared pointer).\n //!\n@@ -802,6 +802,43 @@ impl AtomicBool {\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n+\n+    /// Returns a mutable pointer to the underlying [`bool`].\n+    ///\n+    /// Doing non-atomic reads and writes on the resulting integer can be a data race.\n+    /// This method is mostly useful for FFI, where the function signature may use\n+    /// `*mut bool` instead of `&AtomicBool`.\n+    ///\n+    /// Returning an `*mut` pointer from a shared reference to this atomic is safe because the\n+    /// atomic types work with interior mutability. All modifications of an atomic change the value\n+    /// through a shared reference, and can do so safely as long as they use atomic operations. Any\n+    /// use of the returned raw pointer requires an `unsafe` block and still has to uphold the same\n+    /// restriction: operations on it must be atomic.\n+    ///\n+    /// [`bool`]: ../../../std/primitive.bool.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore (extern-declaration)\n+    /// # fn main() {\n+    /// use std::sync::atomic::AtomicBool;\n+    /// extern {\n+    ///     fn my_atomic_op(arg: *mut bool);\n+    /// }\n+    ///\n+    /// let mut atomic = AtomicBool::new(true);\n+    /// unsafe {\n+    ///     my_atomic_op(atomic.as_mut_ptr());\n+    /// }\n+    /// # }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"atomic_mut_ptr\",\n+           reason = \"recently added\",\n+           issue = \"66893\")]\n+    pub fn as_mut_ptr(&self) -> *mut bool {\n+        self.v.get() as *mut bool\n+    }\n }\n \n #[cfg(target_has_atomic_load_store = \"ptr\")]\n@@ -1891,6 +1928,43 @@ assert_eq!(min_foo, 12);\n                 }\n             }\n \n+            doc_comment! {\n+                concat!(\"Returns a mutable pointer to the underlying integer.\n+\n+Doing non-atomic reads and writes on the resulting integer can be a data race.\n+This method is mostly useful for FFI, where the function signature may use\n+`*mut \", stringify!($int_type), \"` instead of `&\", stringify!($atomic_type), \"`.\n+\n+Returning an `*mut` pointer from a shared reference to this atomic is safe because the\n+atomic types work with interior mutability. All modifications of an atomic change the value\n+through a shared reference, and can do so safely as long as they use atomic operations. Any\n+use of the returned raw pointer requires an `unsafe` block and still has to uphold the same\n+restriction: operations on it must be atomic.\n+\n+# Examples\n+\n+```ignore (extern-declaration)\n+# fn main() {\n+\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n+\n+extern {\n+    fn my_atomic_op(arg: *mut \", stringify!($int_type), \");\n+}\n+\n+let mut atomic = \", stringify!($atomic_type), \"::new(1);\n+unsafe {\n+    my_atomic_op(atomic.as_mut_ptr());\n+}\n+# }\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"atomic_mut_ptr\",\n+                       reason = \"recently added\",\n+                       issue = \"66893\")]\n+                pub fn as_mut_ptr(&self) -> *mut $int_type {\n+                    self.v.get()\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "27760749c1d4b63ddca3afbf14d25da6d2c5ef3e", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -8,4 +8,4 @@ pub use self::poll::Poll;\n \n mod wake;\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-pub use self::wake::{Context, Waker, RawWaker, RawWakerVTable};\n+pub use self::wake::{Context, RawWaker, RawWakerVTable, Waker};"}, {"sha": "d567ae545774ef56726de81f2a55c2ac3bb3be96", "filename": "src/libcore/task/poll.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -11,10 +11,7 @@ use crate::result::Result;\n pub enum Poll<T> {\n     /// Represents that a value is immediately ready.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-    Ready(\n-        #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-        T\n-    ),\n+    Ready(#[stable(feature = \"futures_api\", since = \"1.36.0\")] T),\n \n     /// Represents that a value is not ready yet.\n     ///\n@@ -29,7 +26,8 @@ impl<T> Poll<T> {\n     /// Changes the ready value of this `Poll` with the closure provided.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn map<U, F>(self, f: F) -> Poll<U>\n-        where F: FnOnce(T) -> U\n+    where\n+        F: FnOnce(T) -> U,\n     {\n         match self {\n             Poll::Ready(t) => Poll::Ready(f(t)),\n@@ -59,7 +57,8 @@ impl<T, E> Poll<Result<T, E>> {\n     /// Changes the success value of this `Poll` with the closure provided.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n-        where F: FnOnce(T) -> U\n+    where\n+        F: FnOnce(T) -> U,\n     {\n         match self {\n             Poll::Ready(Ok(t)) => Poll::Ready(Ok(f(t))),\n@@ -71,7 +70,8 @@ impl<T, E> Poll<Result<T, E>> {\n     /// Changes the error value of this `Poll` with the closure provided.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n-        where F: FnOnce(E) -> U\n+    where\n+        F: FnOnce(E) -> U,\n     {\n         match self {\n             Poll::Ready(Ok(t)) => Poll::Ready(Ok(t)),\n@@ -85,7 +85,8 @@ impl<T, E> Poll<Option<Result<T, E>>> {\n     /// Changes the success value of this `Poll` with the closure provided.\n     #[unstable(feature = \"poll_map\", issue = \"63514\")]\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Option<Result<U, E>>>\n-        where F: FnOnce(T) -> U\n+    where\n+        F: FnOnce(T) -> U,\n     {\n         match self {\n             Poll::Ready(Some(Ok(t))) => Poll::Ready(Some(Ok(f(t)))),\n@@ -98,7 +99,8 @@ impl<T, E> Poll<Option<Result<T, E>>> {\n     /// Changes the error value of this `Poll` with the closure provided.\n     #[unstable(feature = \"poll_map\", issue = \"63514\")]\n     pub fn map_err<U, F>(self, f: F) -> Poll<Option<Result<T, U>>>\n-        where F: FnOnce(E) -> U\n+    where\n+        F: FnOnce(E) -> U,\n     {\n         match self {\n             Poll::Ready(Some(Ok(t))) => Poll::Ready(Some(Ok(t))),"}, {"sha": "0759ff93ea85f0da49acb9f346068da1b0622a83", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -40,10 +40,7 @@ impl RawWaker {\n     #[rustc_promotable]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub const fn new(data: *const (), vtable: &'static RawWakerVTable) -> RawWaker {\n-        RawWaker {\n-            data,\n-            vtable,\n-        }\n+        RawWaker { data, vtable }\n     }\n }\n \n@@ -160,12 +157,7 @@ impl RawWakerVTable {\n         wake_by_ref: unsafe fn(*const ()),\n         drop: unsafe fn(*const ()),\n     ) -> Self {\n-        Self {\n-            clone,\n-            wake,\n-            wake_by_ref,\n-            drop,\n-        }\n+        Self { clone, wake, wake_by_ref, drop }\n     }\n }\n \n@@ -188,10 +180,7 @@ impl<'a> Context<'a> {\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     #[inline]\n     pub fn from_waker(waker: &'a Waker) -> Self {\n-        Context {\n-            waker,\n-            _marker: PhantomData,\n-        }\n+        Context { waker, _marker: PhantomData }\n     }\n \n     /// Returns a reference to the `Waker` for the current task.\n@@ -205,9 +194,7 @@ impl<'a> Context<'a> {\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl fmt::Debug for Context<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Context\")\n-            .field(\"waker\", &self.waker)\n-            .finish()\n+        f.debug_struct(\"Context\").field(\"waker\", &self.waker).finish()\n     }\n }\n \n@@ -291,9 +278,7 @@ impl Waker {\n     #[inline]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub unsafe fn from_raw(waker: RawWaker) -> Waker {\n-        Waker {\n-            waker,\n-        }\n+        Waker { waker }\n     }\n }\n "}, {"sha": "e89eb2c7f94d5731a04e320de4427c0dc4d2af68", "filename": "src/libcore/tests/bool.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftests%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftests%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fbool.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,7 +1,7 @@\n #[test]\n fn test_bool_to_option() {\n-    assert_eq!(false.then(0), None);\n-    assert_eq!(true.then(0), Some(0));\n-    assert_eq!(false.then_with(|| 0), None);\n-    assert_eq!(true.then_with(|| 0), Some(0));\n+    assert_eq!(false.then_some(0), None);\n+    assert_eq!(true.then_some(0), Some(0));\n+    assert_eq!(false.then(|| 0), None);\n+    assert_eq!(true.then(|| 0), Some(0));\n }"}, {"sha": "50a3ec046ad1374a52f8c6fdeafb50a881ef14cf", "filename": "src/libcore/tests/num/bignum.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,4 +1,3 @@\n-use std::prelude::v1::*;\n use core::num::bignum::tests::Big8x3 as Big;\n \n #[test]"}, {"sha": "f85369ce40b8db256f8e48e450561ffbc144048a", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,4 +1,3 @@\n-use std::prelude::v1::*;\n use std::{str, i16, f32, f64, fmt};\n \n use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};"}, {"sha": "0c545b4d88714f3d34f50502fc6720fa611f8657", "filename": "src/libcore/tests/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,4 +1,3 @@\n-use std::prelude::v1::*;\n use super::super::*;\n use core::num::bignum::Big32x40 as Big;\n use core::num::flt2dec::strategy::dragon::*;"}, {"sha": "70ec1e42fd71b6981d27c8c02e2e0ee4fd198f07", "filename": "src/libcore/time.rs", "status": "modified", "additions": 33, "deletions": 39, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -12,9 +12,9 @@\n //! assert_eq!(Duration::new(5, 0), Duration::from_secs(5));\n //! ```\n \n-use crate::{fmt, u64};\n use crate::iter::Sum;\n-use crate::ops::{Add, Sub, Mul, Div, AddAssign, SubAssign, MulAssign, DivAssign};\n+use crate::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n+use crate::{fmt, u64};\n \n const NANOS_PER_SEC: u32 = 1_000_000_000;\n const NANOS_PER_MILLI: u32 = 1_000_000;\n@@ -131,8 +131,8 @@ impl Duration {\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n     pub fn new(secs: u64, nanos: u32) -> Duration {\n-        let secs = secs.checked_add((nanos / NANOS_PER_SEC) as u64)\n-            .expect(\"overflow in Duration::new\");\n+        let secs =\n+            secs.checked_add((nanos / NANOS_PER_SEC) as u64).expect(\"overflow in Duration::new\");\n         let nanos = nanos % NANOS_PER_SEC;\n         Duration { secs, nanos }\n     }\n@@ -252,7 +252,9 @@ impl Duration {\n     /// [`subsec_nanos`]: #method.subsec_nanos\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n-    pub const fn as_secs(&self) -> u64 { self.secs }\n+    pub const fn as_secs(&self) -> u64 {\n+        self.secs\n+    }\n \n     /// Returns the fractional part of this `Duration`, in whole milliseconds.\n     ///\n@@ -271,7 +273,9 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n     #[inline]\n-    pub const fn subsec_millis(&self) -> u32 { self.nanos / NANOS_PER_MILLI }\n+    pub const fn subsec_millis(&self) -> u32 {\n+        self.nanos / NANOS_PER_MILLI\n+    }\n \n     /// Returns the fractional part of this `Duration`, in whole microseconds.\n     ///\n@@ -290,7 +294,9 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n     #[inline]\n-    pub const fn subsec_micros(&self) -> u32 { self.nanos / NANOS_PER_MICRO }\n+    pub const fn subsec_micros(&self) -> u32 {\n+        self.nanos / NANOS_PER_MICRO\n+    }\n \n     /// Returns the fractional part of this `Duration`, in nanoseconds.\n     ///\n@@ -309,7 +315,9 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n-    pub const fn subsec_nanos(&self) -> u32 { self.nanos }\n+    pub const fn subsec_nanos(&self) -> u32 {\n+        self.nanos\n+    }\n \n     /// Returns the total number of whole milliseconds contained by this `Duration`.\n     ///\n@@ -388,10 +396,7 @@ impl Duration {\n                 }\n             }\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration {\n-                secs,\n-                nanos,\n-            })\n+            Some(Duration { secs, nanos })\n         } else {\n             None\n         }\n@@ -455,14 +460,11 @@ impl Duration {\n         let total_nanos = self.nanos as u64 * rhs as u64;\n         let extra_secs = total_nanos / (NANOS_PER_SEC as u64);\n         let nanos = (total_nanos % (NANOS_PER_SEC as u64)) as u32;\n-        if let Some(secs) = self.secs\n-            .checked_mul(rhs as u64)\n-            .and_then(|s| s.checked_add(extra_secs)) {\n+        if let Some(secs) =\n+            self.secs.checked_mul(rhs as u64).and_then(|s| s.checked_add(extra_secs))\n+        {\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration {\n-                secs,\n-                nanos,\n-            })\n+            Some(Duration { secs, nanos })\n         } else {\n             None\n         }\n@@ -549,9 +551,8 @@ impl Duration {\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[inline]\n     pub fn from_secs_f64(secs: f64) -> Duration {\n-        const MAX_NANOS_F64: f64 =\n-            ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f64;\n-        let nanos =  secs * (NANOS_PER_SEC as f64);\n+        const MAX_NANOS_F64: f64 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f64;\n+        let nanos = secs * (NANOS_PER_SEC as f64);\n         if !nanos.is_finite() {\n             panic!(\"got non-finite value when converting float to duration\");\n         }\n@@ -561,7 +562,7 @@ impl Duration {\n         if nanos < 0.0 {\n             panic!(\"underflow when converting float to duration\");\n         }\n-        let nanos =  nanos as u128;\n+        let nanos = nanos as u128;\n         Duration {\n             secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n             nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n@@ -584,9 +585,8 @@ impl Duration {\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[inline]\n     pub fn from_secs_f32(secs: f32) -> Duration {\n-        const MAX_NANOS_F32: f32 =\n-            ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f32;\n-        let nanos =  secs * (NANOS_PER_SEC as f32);\n+        const MAX_NANOS_F32: f32 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f32;\n+        let nanos = secs * (NANOS_PER_SEC as f32);\n         if !nanos.is_finite() {\n             panic!(\"got non-finite value when converting float to duration\");\n         }\n@@ -596,7 +596,7 @@ impl Duration {\n         if nanos < 0.0 {\n             panic!(\"underflow when converting float to duration\");\n         }\n-        let nanos =  nanos as u128;\n+        let nanos = nanos as u128;\n         Duration {\n             secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n             nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n@@ -799,9 +799,8 @@ macro_rules! sum_durations {\n         let mut total_nanos: u64 = 0;\n \n         for entry in $iter {\n-            total_secs = total_secs\n-                .checked_add(entry.secs)\n-                .expect(\"overflow in iter::sum over durations\");\n+            total_secs =\n+                total_secs.checked_add(entry.secs).expect(\"overflow in iter::sum over durations\");\n             total_nanos = match total_nanos.checked_add(entry.nanos as u64) {\n                 Some(n) => n,\n                 None => {\n@@ -816,23 +815,20 @@ macro_rules! sum_durations {\n             .checked_add(total_nanos / NANOS_PER_SEC as u64)\n             .expect(\"overflow in iter::sum over durations\");\n         total_nanos = total_nanos % NANOS_PER_SEC as u64;\n-        Duration {\n-            secs: total_secs,\n-            nanos: total_nanos as u32,\n-        }\n+        Duration { secs: total_secs, nanos: total_nanos as u32 }\n     }};\n }\n \n #[stable(feature = \"duration_sum\", since = \"1.16.0\")]\n impl Sum for Duration {\n-    fn sum<I: Iterator<Item=Duration>>(iter: I) -> Duration {\n+    fn sum<I: Iterator<Item = Duration>>(iter: I) -> Duration {\n         sum_durations!(iter)\n     }\n }\n \n #[stable(feature = \"duration_sum\", since = \"1.16.0\")]\n impl<'a> Sum<&'a Duration> for Duration {\n-    fn sum<I: Iterator<Item=&'a Duration>>(iter: I) -> Duration {\n+    fn sum<I: Iterator<Item = &'a Duration>>(iter: I) -> Duration {\n         sum_durations!(iter)\n     }\n }\n@@ -922,9 +918,7 @@ impl fmt::Debug for Duration {\n             } else {\n                 // SAFETY: We are only writing ASCII digits into the buffer and it was\n                 // initialized with '0's, so it contains valid UTF8.\n-                let s = unsafe {\n-                    crate::str::from_utf8_unchecked(&buf[..end])\n-                };\n+                let s = unsafe { crate::str::from_utf8_unchecked(&buf[..end]) };\n \n                 // If the user request a precision > 9, we pad '0's at the end.\n                 let w = f.precision().unwrap_or(pos);"}, {"sha": "9f8a3a1de420116d50f89d515f9930d8120ac44c", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,7 +1,7 @@\n // See src/libstd/primitive_docs.rs for documentation.\n \n-use crate::cmp::*;\n use crate::cmp::Ordering::*;\n+use crate::cmp::*;\n \n // macro for implementing n-ary tuple functions and operations\n macro_rules! tuple_impls {"}, {"sha": "b7fba88a540f9012dbc01efd9b5758d86e30709d", "filename": "src/libcore/unicode/bool_trie.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Funicode%2Fbool_trie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Funicode%2Fbool_trie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fbool_trie.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -19,16 +19,16 @@\n /// non-BMP range of most Unicode sets.\n pub struct BoolTrie {\n     // 0..0x800 (corresponding to 1 and 2 byte utf-8 sequences)\n-    pub r1: [u64; 32],   // leaves\n+    pub r1: [u64; 32], // leaves\n \n     // 0x800..0x10000 (corresponding to 3 byte utf-8 sequences)\n     pub r2: [u8; 992],      // first level\n-    pub r3: &'static [u64],  // leaves\n+    pub r3: &'static [u64], // leaves\n \n     // 0x10000..0x110000 (corresponding to 4 byte utf-8 sequences)\n-    pub r4: [u8; 256],       // first level\n-    pub r5: &'static [u8],   // second level\n-    pub r6: &'static [u64],  // leaves\n+    pub r4: [u8; 256],      // first level\n+    pub r5: &'static [u8],  // second level\n+    pub r6: &'static [u64], // leaves\n }\n impl BoolTrie {\n     pub fn lookup(&self, c: char) -> bool {\n@@ -48,7 +48,7 @@ impl BoolTrie {\n \n pub struct SmallBoolTrie {\n     pub(crate) r1: &'static [u8],  // first level\n-    pub(crate) r2: &'static [u64],  // leaves\n+    pub(crate) r2: &'static [u64], // leaves\n }\n \n impl SmallBoolTrie {"}, {"sha": "91db6381c9b6670ccc5a69e29feeac257cb017c5", "filename": "src/libcore/unicode/printable.py", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Funicode%2Fprintable.py", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Funicode%2Fprintable.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.py?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -111,16 +111,19 @@ def compress_normal(normal):\n     return compressed\n \n def print_singletons(uppers, lowers, uppersname, lowersname):\n+    print(\"#[rustfmt::skip]\")\n     print(\"const {}: &[(u8, u8)] = &[\".format(uppersname))\n     for u, c in uppers:\n         print(\"    ({:#04x}, {}),\".format(u, c))\n     print(\"];\")\n+    print(\"#[rustfmt::skip]\")\n     print(\"const {}: &[u8] = &[\".format(lowersname))\n     for i in range(0, len(lowers), 8):\n         print(\"    {}\".format(\" \".join(\"{:#04x},\".format(l) for l in lowers[i:i+8])))\n     print(\"];\")\n \n def print_normal(normal, normalname):\n+    print(\"#[rustfmt::skip]\")\n     print(\"const {}: &[u8] = &[\".format(normalname))\n     for v in normal:\n         print(\"    {}\".format(\" \".join(\"{:#04x},\".format(i) for i in v)))\n@@ -170,8 +173,7 @@ def main():\n // NOTE: The following code was generated by \"src/libcore/unicode/printable.py\",\n //       do not edit directly!\n \n-fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8],\n-         normal: &[u8]) -> bool {\n+fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8], normal: &[u8]) -> bool {\n     let xupper = (x >> 8) as u8;\n     let mut lowerstart = 0;\n     for &(upper, lowercount) in singletonuppers {"}, {"sha": "eee9ea52ef0d2e2387c8d6ef43c0682e6f2b8454", "filename": "src/libcore/unicode/printable.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Funicode%2Fprintable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Funicode%2Fprintable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,8 +1,7 @@\n // NOTE: The following code was generated by \"src/libcore/unicode/printable.py\",\n //       do not edit directly!\n \n-fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8],\n-         normal: &[u8]) -> bool {\n+fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8], normal: &[u8]) -> bool {\n     let xupper = (x >> 8) as u8;\n     let mut lowerstart = 0;\n     for &(upper, lowercount) in singletonuppers {\n@@ -70,6 +69,7 @@ pub(crate) fn is_printable(x: char) -> bool {\n     }\n }\n \n+#[rustfmt::skip]\n const SINGLETONS0U: &[(u8, u8)] = &[\n     (0x00, 1),\n     (0x03, 5),\n@@ -113,6 +113,7 @@ const SINGLETONS0U: &[(u8, u8)] = &[\n     (0xfe, 3),\n     (0xff, 9),\n ];\n+#[rustfmt::skip]\n const SINGLETONS0L: &[u8] = &[\n     0xad, 0x78, 0x79, 0x8b, 0x8d, 0xa2, 0x30, 0x57,\n     0x58, 0x8b, 0x8c, 0x90, 0x1c, 0x1d, 0xdd, 0x0e,\n@@ -152,6 +153,7 @@ const SINGLETONS0L: &[u8] = &[\n     0xff, 0x53, 0x67, 0x75, 0xc8, 0xc9, 0xd0, 0xd1,\n     0xd8, 0xd9, 0xe7, 0xfe, 0xff,\n ];\n+#[rustfmt::skip]\n const SINGLETONS1U: &[(u8, u8)] = &[\n     (0x00, 6),\n     (0x01, 1),\n@@ -189,6 +191,7 @@ const SINGLETONS1U: &[(u8, u8)] = &[\n     (0xf9, 6),\n     (0xfa, 2),\n ];\n+#[rustfmt::skip]\n const SINGLETONS1L: &[u8] = &[\n     0x0c, 0x27, 0x3b, 0x3e, 0x4e, 0x4f, 0x8f, 0x9e,\n     0x9e, 0x9f, 0x06, 0x07, 0x09, 0x36, 0x3d, 0x3e,\n@@ -212,6 +215,7 @@ const SINGLETONS1L: &[u8] = &[\n     0xa4, 0xaa, 0xaf, 0xb0, 0xc0, 0xd0, 0x0c, 0x72,\n     0xa3, 0xa4, 0xcb, 0xcc, 0x6e, 0x6f,\n ];\n+#[rustfmt::skip]\n const NORMAL0: &[u8] = &[\n     0x00, 0x20,\n     0x5f, 0x22,\n@@ -355,6 +359,7 @@ const NORMAL0: &[u8] = &[\n     0x1b, 0x03,\n     0x0f, 0x0d,\n ];\n+#[rustfmt::skip]\n const NORMAL1: &[u8] = &[\n     0x5e, 0x22,\n     0x7b, 0x05,"}, {"sha": "3fa125e8fea15fc9921ce35af4660c76554f619c", "filename": "src/libcore/unicode/tables.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Funicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Funicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Ftables.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -2,19 +2,16 @@\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case, clippy::unreadable_literal)]\n \n-use crate::unicode::version::UnicodeVersion;\n use crate::unicode::bool_trie::{BoolTrie, SmallBoolTrie};\n+use crate::unicode::version::UnicodeVersion;\n \n /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n /// `char` and `str` methods are based on.\n #[unstable(feature = \"unicode_version\", issue = \"49726\")]\n-pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n-    major: 12,\n-    minor: 1,\n-    micro: 0,\n-    _priv: (),\n-};\n+pub const UNICODE_VERSION: UnicodeVersion =\n+    UnicodeVersion { major: 12, minor: 1, micro: 0, _priv: () };\n pub(crate) mod general_category {\n+    #[rustfmt::skip]\n     const Cc_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 0\n@@ -28,6 +25,7 @@ pub(crate) mod general_category {\n         Cc_table.lookup(c)\n     }\n \n+    #[rustfmt::skip]\n     const N_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x03ff000000000000, 0x0000000000000000, 0x720c000000000000, 0x0000000000000000,\n@@ -138,10 +136,10 @@ pub(crate) mod general_category {\n     pub fn N(c: char) -> bool {\n         N_table.lookup(c)\n     }\n-\n }\n \n pub(crate) mod derived_property {\n+    #[rustfmt::skip]\n     const Alphabetic_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n@@ -327,6 +325,7 @@ pub(crate) mod derived_property {\n         Alphabetic_table.lookup(c)\n     }\n \n+    #[rustfmt::skip]\n     const Case_Ignorable_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0400408000000000, 0x0000000140000000, 0x0190a10000000000, 0x0000000000000000,\n@@ -464,6 +463,7 @@ pub(crate) mod derived_property {\n         Case_Ignorable_table.lookup(c)\n     }\n \n+    #[rustfmt::skip]\n     const Cased_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n@@ -565,6 +565,7 @@ pub(crate) mod derived_property {\n         Cased_table.lookup(c)\n     }\n \n+    #[rustfmt::skip]\n     const Grapheme_Extend_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n@@ -689,6 +690,7 @@ pub(crate) mod derived_property {\n         Grapheme_Extend_table.lookup(c)\n     }\n \n+    #[rustfmt::skip]\n     const Lowercase_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe00000000, 0x0420040000000000, 0xff7fffff80000000,\n@@ -789,6 +791,7 @@ pub(crate) mod derived_property {\n         Lowercase_table.lookup(c)\n     }\n \n+    #[rustfmt::skip]\n     const Uppercase_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x0000000007fffffe, 0x0000000000000000, 0x000000007f7fffff,\n@@ -889,10 +892,10 @@ pub(crate) mod derived_property {\n     pub fn Uppercase(c: char) -> bool {\n         Uppercase_table.lookup(c)\n     }\n-\n }\n \n pub(crate) mod property {\n+    #[rustfmt::skip]\n     const White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n@@ -912,20 +915,19 @@ pub(crate) mod property {\n     pub fn White_Space(c: char) -> bool {\n         White_Space_table.lookup(c)\n     }\n-\n }\n \n pub(crate) mod conversions {\n     pub fn to_lower(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_lowercase_table) {\n-            None        => [c, '\\0', '\\0'],\n+            None => [c, '\\0', '\\0'],\n             Some(index) => to_lowercase_table[index].1,\n         }\n     }\n \n     pub fn to_upper(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_uppercase_table) {\n-            None        => [c, '\\0', '\\0'],\n+            None => [c, '\\0', '\\0'],\n             Some(index) => to_uppercase_table[index].1,\n         }\n     }\n@@ -934,6 +936,7 @@ pub(crate) mod conversions {\n         table.binary_search_by(|&(key, _)| key.cmp(&c)).ok()\n     }\n \n+    #[rustfmt::skip]\n     const to_lowercase_table: &[(char, [char; 3])] = &[\n         ('\\u{41}', ['\\u{61}', '\\0', '\\0']), ('\\u{42}', ['\\u{62}', '\\0', '\\0']), ('\\u{43}',\n         ['\\u{63}', '\\0', '\\0']), ('\\u{44}', ['\\u{64}', '\\0', '\\0']), ('\\u{45}', ['\\u{65}', '\\0',\n@@ -1558,6 +1561,7 @@ pub(crate) mod conversions {\n         ('\\u{1e920}', ['\\u{1e942}', '\\0', '\\0']), ('\\u{1e921}', ['\\u{1e943}', '\\0', '\\0'])\n     ];\n \n+    #[rustfmt::skip]\n     const to_uppercase_table: &[(char, [char; 3])] = &[\n         ('\\u{61}', ['\\u{41}', '\\0', '\\0']), ('\\u{62}', ['\\u{42}', '\\0', '\\0']), ('\\u{63}',\n         ['\\u{43}', '\\0', '\\0']), ('\\u{64}', ['\\u{44}', '\\0', '\\0']), ('\\u{65}', ['\\u{45}', '\\0',\n@@ -2228,5 +2232,4 @@ pub(crate) mod conversions {\n         ('\\u{1e940}', ['\\u{1e91e}', '\\0', '\\0']), ('\\u{1e941}', ['\\u{1e91f}', '\\0', '\\0']),\n         ('\\u{1e942}', ['\\u{1e920}', '\\0', '\\0']), ('\\u{1e943}', ['\\u{1e921}', '\\0', '\\0'])\n     ];\n-\n }"}, {"sha": "97df92a56da66ea2b0527a35d4a5eb28f6457390", "filename": "src/libcore/unicode/unicode.py", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Funicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Funicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode.py?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -81,8 +81,8 @@ class UnicodeFiles(object):\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case, clippy::unreadable_literal)]\n \n-use crate::unicode::version::UnicodeVersion;\n use crate::unicode::bool_trie::{{BoolTrie, SmallBoolTrie}};\n+use crate::unicode::version::UnicodeVersion;\n \"\"\".format(year=datetime.datetime.now().year)\n \n # Mapping taken from Table 12 from:\n@@ -555,6 +555,8 @@ def generate_table(\n     if is_pub:\n         pub_string = \"pub \"\n \n+    yield \"\\n\"\n+    yield \"    #[rustfmt::skip]\\n\"\n     yield \"    %sconst %s: %s = &[\\n\" % (pub_string, name, decl_type)\n \n     data = []\n@@ -568,7 +570,7 @@ def generate_table(\n     for table_line in generate_table_lines(\"\".join(data).split(\",\"), 8):\n         yield table_line\n \n-    yield \"\\n    ];\\n\\n\"\n+    yield \"\\n    ];\\n\"\n \n \n def compute_trie(raw_data, chunk_size):\n@@ -634,6 +636,9 @@ def generate_bool_trie(name, codepoint_ranges, is_pub=False):\n     pub_string = \"\"\n     if is_pub:\n         pub_string = \"pub \"\n+\n+    yield \"\\n\"\n+    yield \"    #[rustfmt::skip]\\n\"\n     yield \"    %sconst %s: &super::BoolTrie = &super::BoolTrie {\\n\" % (pub_string, name)\n     yield \"        r1: [\\n\"\n     data = (\"0x%016x\" % chunk for chunk in chunks[:0x800 // chunk_size])\n@@ -678,7 +683,7 @@ def generate_bool_trie(name, codepoint_ranges, is_pub=False):\n         yield fragment\n     yield \"\\n        ],\\n\"\n \n-    yield \"    };\\n\\n\"\n+    yield \"    };\\n\"\n \n \n def generate_small_bool_trie(name, codepoint_ranges, is_pub=False):\n@@ -700,6 +705,8 @@ def generate_small_bool_trie(name, codepoint_ranges, is_pub=False):\n     if is_pub:\n         pub_string = \"pub \"\n \n+    yield \"\\n\"\n+    yield \"    #[rustfmt::skip]\\n\"\n     yield (\"    %sconst %s: &super::SmallBoolTrie = &super::SmallBoolTrie {\\n\"\n            % (pub_string, name))\n \n@@ -717,7 +724,7 @@ def generate_small_bool_trie(name, codepoint_ranges, is_pub=False):\n         yield fragment\n     yield \"\\n        ],\\n\"\n \n-    yield \"    };\\n\\n\"\n+    yield \"    };\\n\"\n \n \n def generate_property_module(mod, grouped_categories, category_subset):\n@@ -726,7 +733,7 @@ def generate_property_module(mod, grouped_categories, category_subset):\n     Generate Rust code for module defining properties.\n     \"\"\"\n \n-    yield \"pub(crate) mod %s {\\n\" % mod\n+    yield \"pub(crate) mod %s {\" % mod\n     for cat in sorted(category_subset):\n         if cat in (\"Cc\", \"White_Space\"):\n             generator = generate_small_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n@@ -736,9 +743,10 @@ def generate_property_module(mod, grouped_categories, category_subset):\n         for fragment in generator:\n             yield fragment\n \n+        yield \"\\n\"\n         yield \"    pub fn %s(c: char) -> bool {\\n\" % cat\n         yield \"        %s_table.lookup(c)\\n\" % cat\n-        yield \"    }\\n\\n\"\n+        yield \"    }\\n\"\n \n     yield \"}\\n\\n\"\n \n@@ -753,21 +761,21 @@ def generate_conversions_module(unicode_data):\n     yield \"\"\"\n     pub fn to_lower(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_lowercase_table) {\n-            None        => [c, '\\\\0', '\\\\0'],\n+            None => [c, '\\\\0', '\\\\0'],\n             Some(index) => to_lowercase_table[index].1,\n         }\n     }\n \n     pub fn to_upper(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_uppercase_table) {\n-            None        => [c, '\\\\0', '\\\\0'],\n+            None => [c, '\\\\0', '\\\\0'],\n             Some(index) => to_uppercase_table[index].1,\n         }\n     }\n \n     fn bsearch_case_table(c: char, table: &[(char, [char; 3])]) -> Option<usize> {\n         table.binary_search_by(|&(key, _)| key.cmp(&c)).ok()\n-    }\\n\\n\"\"\"\n+    }\\n\"\"\"\n \n     decl_type = \"&[(char, [char; 3])]\"\n     format_conversion = lambda x: \"({},[{},{},{}])\".format(*(\n@@ -827,13 +835,9 @@ def main():\n     /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n     /// `char` and `str` methods are based on.\n     #[unstable(feature = \"unicode_version\", issue = \"49726\")]\n-    pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {{\n-        major: {version.major},\n-        minor: {version.minor},\n-        micro: {version.micro},\n-        _priv: (),\n-    }};\n-    \"\"\").format(version=unicode_version)\n+    pub const UNICODE_VERSION: UnicodeVersion =\n+        UnicodeVersion {{ major: {v.major}, minor: {v.minor}, micro: {v.micro}, _priv: () }};\n+    \"\"\").format(v=unicode_version)\n     buf.write(unicode_version_notice)\n \n     get_path = lambda f: get_unicode_file_path(unicode_version, f)"}, {"sha": "f41f4a5e94a76ee5b585b9575636cfa4b7e66aab", "filename": "src/libcore/unit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibcore%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funit.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -15,7 +15,7 @@ use crate::iter::FromIterator;\n /// ```\n #[stable(feature = \"unit_from_iter\", since = \"1.23.0\")]\n impl FromIterator<()> for () {\n-    fn from_iter<I: IntoIterator<Item=()>>(iter: I) -> Self {\n+    fn from_iter<I: IntoIterator<Item = ()>>(iter: I) -> Self {\n         iter.into_iter().for_each(|()| {})\n     }\n }"}, {"sha": "2ecbe770729b5b278f21213df8902e31104ef224", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -11,6 +11,7 @@\n #![feature(nll)]\n #![feature(rustc_private)]\n #![feature(unicode_internals)]\n+#![feature(bool_to_option)]\n \n pub use Piece::*;\n pub use Position::*;\n@@ -442,20 +443,9 @@ impl<'a> Parser<'a> {\n             Some(ArgumentIs(i))\n         } else {\n             match self.cur.peek() {\n-                Some(&(_, c)) if c.is_alphabetic() => {\n+                Some(&(_, c)) if rustc_lexer::is_id_start(c) => {\n                     Some(ArgumentNamed(Symbol::intern(self.word())))\n                 }\n-                Some(&(pos, c)) if c == '_' => {\n-                    let invalid_name = self.string(pos);\n-                    self.err_with_note(format!(\"invalid argument name `{}`\", invalid_name),\n-                                       \"invalid argument name\",\n-                                       \"argument names cannot start with an underscore\",\n-                                        self.to_span_index(pos).to(\n-                                            self.to_span_index(pos + invalid_name.len())\n-                                        ),\n-                                        );\n-                    Some(ArgumentNamed(Symbol::intern(invalid_name)))\n-                },\n \n                 // This is an `ArgumentNext`.\n                 // Record the fact and do the resolution after parsing the\n@@ -611,22 +601,34 @@ impl<'a> Parser<'a> {\n     /// Rust identifier, except that it can't start with `_` character.\n     fn word(&mut self) -> &'a str {\n         let start = match self.cur.peek() {\n-            Some(&(pos, c)) if c != '_' && rustc_lexer::is_id_start(c) => {\n+            Some(&(pos, c)) if rustc_lexer::is_id_start(c) => {\n                 self.cur.next();\n                 pos\n             }\n             _ => {\n-                return &self.input[..0];\n+                return \"\";\n             }\n         };\n+        let mut end = None;\n         while let Some(&(pos, c)) = self.cur.peek() {\n             if rustc_lexer::is_id_continue(c) {\n                 self.cur.next();\n             } else {\n-                return &self.input[start..pos];\n+                end = Some(pos);\n+                break;\n             }\n         }\n-        &self.input[start..self.input.len()]\n+        let end = end.unwrap_or(self.input.len());\n+        let word = &self.input[start..end];\n+        if word == \"_\" {\n+            self.err_with_note(\n+                \"invalid argument name `_`\",\n+                \"invalid argument name\",\n+                \"argument name cannot be a single underscore\",\n+                self.to_span_index(start).to(self.to_span_index(end)),\n+            );\n+        }\n+        word\n     }\n \n     /// Optionally parses an integer at the current position. This doesn't deal\n@@ -643,11 +645,7 @@ impl<'a> Parser<'a> {\n                 break;\n             }\n         }\n-        if found {\n-            Some(cur)\n-        } else {\n-            None\n-        }\n+        found.then_some(cur)\n     }\n }\n "}, {"sha": "242eb6750b3dfdb5a0f163ec009ec8d8e54c11f6", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -130,7 +130,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>, foreign_e\n fn interpret_cs_action(cs_action: u64, lpad: usize, foreign_exception: bool) -> EHAction {\n     if cs_action == 0 {\n         // If cs_action is 0 then this is a cleanup (Drop::drop). We run these\n-        // for both Rust panics and foriegn exceptions.\n+        // for both Rust panics and foreign exceptions.\n         EHAction::Cleanup(lpad)\n     } else if foreign_exception {\n         // catch_unwind should not catch foreign exceptions, only Rust panics."}, {"sha": "3a14197c77bec3ba289315fc1cfb8773f58a6a2f", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -36,10 +36,7 @@ use core::raw;\n use core::panic::BoxMeUp;\n \n cfg_if::cfg_if! {\n-    if #[cfg(miri)] {\n-        #[path = \"miri.rs\"]\n-        mod imp;\n-    } else if #[cfg(target_os = \"emscripten\")] {\n+    if #[cfg(target_os = \"emscripten\")] {\n         #[path = \"emcc.rs\"]\n         mod imp;\n     } else if #[cfg(target_arch = \"wasm32\")] {\n@@ -94,5 +91,14 @@ pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n #[unwind(allowed)]\n pub unsafe extern \"C\" fn __rust_start_panic(payload: usize) -> u32 {\n     let payload = payload as *mut &mut dyn BoxMeUp;\n-    imp::panic(Box::from_raw((*payload).box_me_up()))\n+    let payload = (*payload).take_box();\n+\n+    // Miri panic support: cfg'd out of normal builds just to be sure.\n+    // When going through normal codegen, `miri_start_panic` is a NOP, so the\n+    // Miri-enabled sysroot still supports normal unwinding. But when executed in\n+    // Miri, this line initiates unwinding.\n+    #[cfg(miri)]\n+    core::intrinsics::miri_start_panic(payload);\n+\n+    imp::panic(Box::from_raw(payload))\n }"}, {"sha": "f26c42fd4bcbaac9c707b22ff7b50fd961b64e98", "filename": "src/libpanic_unwind/miri.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/969926fcfe68787595d384f53d19cf6b8c9df3e3/src%2Flibpanic_unwind%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969926fcfe68787595d384f53d19cf6b8c9df3e3/src%2Flibpanic_unwind%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fmiri.rs?ref=969926fcfe68787595d384f53d19cf6b8c9df3e3", "patch": "@@ -1,42 +0,0 @@\n-#![allow(nonstandard_style)]\n-\n-use core::any::Any;\n-use alloc::boxed::Box;\n-\n-pub fn payload() -> *mut u8 {\n-    core::ptr::null_mut()\n-}\n-\n-pub unsafe fn panic(data: Box<dyn Any + Send>) -> ! {\n-    core::intrinsics::miri_start_panic(Box::into_raw(data))\n-}\n-\n-pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n-    Box::from_raw(ptr)\n-}\n-\n-// This is required by the compiler to exist (e.g., it's a lang item),\n-// but is never used by Miri. Therefore, we just use a stub here\n-#[lang = \"eh_personality\"]\n-#[cfg(not(test))]\n-fn rust_eh_personality() {\n-    unsafe { core::intrinsics::abort() }\n-}\n-\n-// The rest is required on *some* targets to exist (specifically, MSVC targets that use SEH).\n-// We just add it on all targets. Copied from `seh.rs`.\n-#[repr(C)]\n-pub struct _TypeDescriptor {\n-    pub pVFTable: *const u8,\n-    pub spare: *mut u8,\n-    pub name: [u8; 11],\n-}\n-\n-const TYPE_NAME: [u8; 11] = *b\"rust_panic\\0\";\n-\n-#[cfg_attr(not(test), lang = \"eh_catch_typeinfo\")]\n-static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n-    pVFTable: core::ptr::null(),\n-    spare: core::ptr::null_mut(),\n-    name: TYPE_NAME,\n-};"}, {"sha": "f8ad6f8f30edb00eb26bf2b94b64e1e37925c636", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -22,6 +22,7 @@ rustc-rayon = \"0.3.0\"\n rustc-rayon-core = \"0.3.0\"\n polonius-engine  = \"0.10.0\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n+rustc_feature = { path = \"../librustc_feature\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n@@ -38,3 +39,4 @@ rustc_fs_util = { path = \"../librustc_fs_util\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.4\"\n rustc_error_codes = { path = \"../librustc_error_codes\" }\n+rustc_session = { path = \"../librustc_session\" }"}, {"sha": "eb7a17098015468304fc21395657360e1c0f938e", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -23,17 +23,17 @@ macro_rules! arena_types {\n             [] generics: rustc::ty::Generics,\n             [] trait_def: rustc::ty::TraitDef,\n             [] adt_def: rustc::ty::AdtDef,\n-            [] steal_mir: rustc::ty::steal::Steal<rustc::mir::Body<$tcx>>,\n-            [] mir: rustc::mir::Body<$tcx>,\n+            [] steal_mir: rustc::ty::steal::Steal<rustc::mir::BodyAndCache<$tcx>>,\n+            [] mir: rustc::mir::BodyAndCache<$tcx>,\n             [] steal_promoted: rustc::ty::steal::Steal<\n                 rustc_index::vec::IndexVec<\n                     rustc::mir::Promoted,\n-                    rustc::mir::Body<$tcx>\n+                    rustc::mir::BodyAndCache<$tcx>\n                 >\n             >,\n             [] promoted: rustc_index::vec::IndexVec<\n                 rustc::mir::Promoted,\n-                rustc::mir::Body<$tcx>\n+                rustc::mir::BodyAndCache<$tcx>\n             >,\n             [] tables: rustc::ty::TypeckTables<$tcx>,\n             [] const_allocs: rustc::mir::interpret::Allocation,\n@@ -93,14 +93,15 @@ macro_rules! arena_types {\n                         rustc::hir::def_id::CrateNum\n                     >\n                 >,\n+            [few] hir_forest: rustc::hir::map::Forest,\n             [few] diagnostic_items: rustc_data_structures::fx::FxHashMap<\n                 syntax::symbol::Symbol,\n                 rustc::hir::def_id::DefId,\n             >,\n             [few] resolve_lifetimes: rustc::middle::resolve_lifetime::ResolveLifetimes,\n             [few] lint_levels: rustc::lint::LintLevelMap,\n             [few] stability_index: rustc::middle::stability::Index<'tcx>,\n-            [few] features: syntax::feature_gate::Features,\n+            [few] features: rustc_feature::Features,\n             [few] all_traits: Vec<rustc::hir::def_id::DefId>,\n             [few] privacy_access_levels: rustc::middle::privacy::AccessLevels,\n             [few] target_features_whitelist: rustc_data_structures::fx::FxHashMap<"}, {"sha": "d952bf7ab9e2541ee18f8d4c62e4c8a3ea14a494", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -710,14 +710,25 @@ impl DepGraph {\n                                 return None\n                             }\n                             None => {\n-                                if !tcx.sess.has_errors() {\n+                                if !tcx.sess.has_errors_or_delayed_span_bugs() {\n                                     bug!(\"try_mark_previous_green() - Forcing the DepNode \\\n                                           should have set its color\")\n                                 } else {\n-                                    // If the query we just forced has resulted\n-                                    // in some kind of compilation error, we\n-                                    // don't expect that the corresponding\n-                                    // dep-node color has been updated.\n+                                    // If the query we just forced has resulted in\n+                                    // some kind of compilation error, we cannot rely on\n+                                    // the dep-node color having been properly updated.\n+                                    // This means that the query system has reached an\n+                                    // invalid state. We let the compiler continue (by\n+                                    // returning `None`) so it can emit error messages\n+                                    // and wind down, but rely on the fact that this\n+                                    // invalid state will not be persisted to the\n+                                    // incremental compilation cache because of\n+                                    // compilation errors being present.\n+                                    debug!(\"try_mark_previous_green({:?}) - END - \\\n+                                            dependency {:?} resulted in compilation error\",\n+                                           dep_node,\n+                                           dep_dep_node);\n+                                    return None\n                                 }\n                             }\n                         }"}, {"sha": "a1321d50f28bb99bab97983b352781e41b0a916a", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -5,7 +5,6 @@ mod prev;\n mod query;\n mod safe;\n mod serialized;\n-pub mod cgu_reuse_tracker;\n \n pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, RecoverKey, label_strs};\n pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, TaskDeps, hash_result};"}, {"sha": "e13f6cabb5296296b8d3106e73ae17b20094fb55", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1003,7 +1003,7 @@ impl<'a> LoweringContext<'a> {\n             AttrKind::Normal(ref item) => {\n                 AttrKind::Normal(AttrItem {\n                     path: item.path.clone(),\n-                    tokens: self.lower_token_stream(item.tokens.clone()),\n+                    args: self.lower_mac_args(&item.args),\n                 })\n             }\n             AttrKind::DocComment(comment) => AttrKind::DocComment(comment)\n@@ -1017,6 +1017,16 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn lower_mac_args(&mut self, args: &MacArgs) -> MacArgs {\n+        match *args {\n+            MacArgs::Empty => MacArgs::Empty,\n+            MacArgs::Delimited(dspan, delim, ref tokens) =>\n+                MacArgs::Delimited(dspan, delim, self.lower_token_stream(tokens.clone())),\n+            MacArgs::Eq(eq_span, ref tokens) =>\n+                MacArgs::Eq(eq_span, self.lower_token_stream(tokens.clone())),\n+        }\n+    }\n+\n     fn lower_token_stream(&mut self, tokens: TokenStream) -> TokenStream {\n         tokens\n             .into_trees()"}, {"sha": "ff9d8c85df8b9dd3661df2d3092faf3bb354d3ab", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -233,7 +233,7 @@ impl LoweringContext<'_> {\n \n         if let ItemKind::MacroDef(ref def) = i.kind {\n             if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n-                let body = self.lower_token_stream(def.stream());\n+                let body = self.lower_token_stream(def.body.inner_tokens());\n                 let hir_id = self.lower_node_id(i.id);\n                 self.exported_macros.push(hir::MacroDef {\n                     name: ident.name,"}, {"sha": "8f9f3983262372fdcd28e8782d6e6855c4ed933c", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -147,13 +147,7 @@ impl<'a> FnLikeNode<'a> {\n             map::Node::Expr(e) => e.is_fn_like(),\n             _ => false\n         };\n-        if fn_like {\n-            Some(FnLikeNode {\n-                node,\n-            })\n-        } else {\n-            None\n-        }\n+        fn_like.then_some(FnLikeNode { node })\n     }\n \n     pub fn body(self) -> ast::BodyId {"}, {"sha": "5bf5a93ad010271833671248ea41dbb6916ef412", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -200,7 +200,7 @@ pub struct Map<'hir> {\n \n     map: HirEntryMap<'hir>,\n \n-    definitions: &'hir Definitions,\n+    definitions: Definitions,\n \n     /// The reverse mapping of `node_to_hir_id`.\n     hir_to_node_id: FxHashMap<HirId, NodeId>,\n@@ -267,8 +267,8 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn definitions(&self) -> &'hir Definitions {\n-        self.definitions\n+    pub fn definitions(&self) -> &Definitions {\n+        &self.definitions\n     }\n \n     pub fn def_key(&self, def_id: DefId) -> DefKey {\n@@ -1251,7 +1251,7 @@ impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n pub fn map_crate<'hir>(sess: &crate::session::Session,\n                        cstore: &CrateStoreDyn,\n                        forest: &'hir Forest,\n-                       definitions: &'hir Definitions)\n+                       definitions: Definitions)\n                        -> Map<'hir> {\n     let _prof_timer = sess.prof.generic_activity(\"build_hir_map\");\n \n@@ -1260,7 +1260,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n         .map(|(node_id, &hir_id)| (hir_id, node_id)).collect();\n \n     let (map, crate_hash) = {\n-        let hcx = crate::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n+        let hcx = crate::ich::StableHashingContext::new(sess, &forest.krate, &definitions, cstore);\n \n         let mut collector = NodeCollector::root(sess,\n                                                 &forest.krate,"}, {"sha": "6499e56325a42aca2aa41bdc2287eaaecbcafe01", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -4,7 +4,6 @@\n use crate::ich::StableHashingContext;\n \n use syntax::ast;\n-use syntax::feature_gate;\n use syntax_pos::SourceFile;\n \n use crate::hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n@@ -156,7 +155,7 @@ fn stable_normalized_pos(np: ::syntax_pos::NormalizedPos,\n }\n \n \n-impl<'tcx> HashStable<StableHashingContext<'tcx>> for feature_gate::Features {\n+impl<'tcx> HashStable<StableHashingContext<'tcx>> for rustc_feature::Features {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n         // Unfortunately we cannot exhaustively list fields here, since the\n         // struct is macro generated."}, {"sha": "58c1498faa9dedbe017a69f05f810dcb2af0a3b0", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -463,7 +463,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         terr: &TypeError<'tcx>,\n-        sp: Span,\n     ) {\n         use hir::def_id::CrateNum;\n         use hir::map::DisambiguatedDefPathData;\n@@ -577,14 +576,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 };\n                 if same_path().unwrap_or(false) {\n                     let crate_name = self.tcx.crate_name(did1.krate);\n-                    err.span_note(\n-                        sp,\n-                        &format!(\n-                            \"Perhaps two different versions \\\n-                             of crate `{}` are being used?\",\n-                            crate_name\n-                        ),\n-                    );\n+                    err.note(&format!(\n+                        \"perhaps two different versions of crate `{}` are being used?\",\n+                        crate_name\n+                    ));\n                 }\n             }\n         };\n@@ -1434,7 +1429,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .unwrap_or_else(|| {\n                 self.tcx.hir().body_owner_def_id(hir::BodyId { hir_id: cause.body_id })\n             });\n-        self.check_and_note_conflicting_crates(diag, terr, span);\n+        self.check_and_note_conflicting_crates(diag, terr);\n         self.tcx.note_and_explain_type_err(diag, terr, span, body_owner_def_id);\n \n         // It reads better to have the error origin as the final\n@@ -1550,8 +1545,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::Types(ref exp_found) => self.expected_found_str_ty(exp_found),\n             infer::Regions(ref exp_found) => self.expected_found_str(exp_found),\n             infer::Consts(ref exp_found) => self.expected_found_str(exp_found),\n-            infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n-            infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n+            infer::TraitRefs(ref exp_found) => {\n+                let pretty_exp_found = ty::error::ExpectedFound {\n+                    expected: exp_found.expected.print_only_trait_path(),\n+                    found: exp_found.found.print_only_trait_path()\n+                };\n+                self.expected_found_str(&pretty_exp_found)\n+            },\n+            infer::PolyTraitRefs(ref exp_found) => {\n+                let pretty_exp_found = ty::error::ExpectedFound {\n+                    expected: exp_found.expected.print_only_trait_path(),\n+                    found: exp_found.found.print_only_trait_path()\n+                };\n+                self.expected_found_str(&pretty_exp_found)\n+            },\n         }\n     }\n \n@@ -1802,12 +1809,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             sub_region,\n                             \"...\",\n                         );\n-                        err.note(&format!(\n-                            \"...so that the {}:\\nexpected {}\\n   found {}\",\n-                            sup_trace.cause.as_requirement_str(),\n-                            sup_expected.content(),\n-                            sup_found.content()\n+                        err.span_note(sup_trace.cause.span, &format!(\n+                            \"...so that the {}\",\n+                            sup_trace.cause.as_requirement_str()\n                         ));\n+\n+                        err.note_expected_found(\n+                            &\"\",\n+                            sup_expected,\n+                            &\"\",\n+                            sup_found\n+                        );\n                         err.emit();\n                         return;\n                     }"}, {"sha": "3b4d06aab27ef6827334fab02e3049b2739831b8", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -401,15 +401,15 @@ impl NiceRegionError<'me, 'tcx> {\n                 format!(\n                     \"{}`{}` would have to be implemented for the type `{}`\",\n                     if leading_ellipsis { \"...\" } else { \"\" },\n-                    expected_trait_ref,\n+                    expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n                     expected_trait_ref.map(|tr| tr.self_ty()),\n                 )\n             } else {\n                 format!(\n                     \"{}`{}` must implement `{}`\",\n                     if leading_ellipsis { \"...\" } else { \"\" },\n                     expected_trait_ref.map(|tr| tr.self_ty()),\n-                    expected_trait_ref,\n+                    expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n                 )\n             };\n \n@@ -449,14 +449,14 @@ impl NiceRegionError<'me, 'tcx> {\n             let mut note = if passive_voice {\n                 format!(\n                     \"...but `{}` is actually implemented for the type `{}`\",\n-                    actual_trait_ref,\n+                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n                     actual_trait_ref.map(|tr| tr.self_ty()),\n                 )\n             } else {\n                 format!(\n                     \"...but `{}` actually implements `{}`\",\n                     actual_trait_ref.map(|tr| tr.self_ty()),\n-                    actual_trait_ref,\n+                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n                 )\n             };\n "}, {"sha": "4b933735fc75f4eb472869de845881a0b0750c20", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -13,12 +13,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         match *origin {\n             infer::Subtype(ref trace) => {\n                 if let Some((expected, found)) = self.values_str(&trace.values) {\n-                    let expected = expected.content();\n-                    let found = found.content();\n-                    err.note(&format!(\"...so that the {}:\\nexpected {}\\n   found {}\",\n-                                      trace.cause.as_requirement_str(),\n-                                      expected,\n-                                      found));\n+                    err.span_note(\n+                        trace.cause.span,\n+                        &format!(\n+                            \"...so that the {}\",\n+                            trace.cause.as_requirement_str()\n+                        )\n+                    );\n+\n+                    err.note_expected_found(\n+                        &\"\",\n+                        expected,\n+                        &\"\",\n+                        found\n+                    );\n                 } else {\n                     // FIXME: this really should be handled at some earlier stage. Our\n                     // handling of region checking when type errors are present is"}, {"sha": "b3ddffc8b12f1e782629aa45c9026d2f76163e23", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1292,7 +1292,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n-        self.resolve_vars_if_possible(t).to_string()\n+        self.resolve_vars_if_possible(t).print_only_trait_path().to_string()\n     }\n \n     /// If `TyVar(vid)` resolves to a type, return that type. Else, return the"}, {"sha": "3e28145c0fa0a544b7022a2050fa74a93ea322a6", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -211,11 +211,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n                 (r, p)\n             );\n             let p_ty = p.to_ty(tcx);\n-            if compare_ty(p_ty) {\n-                Some(ty::OutlivesPredicate(p_ty, r))\n-            } else {\n-                None\n-            }\n+            compare_ty(p_ty).then_some(ty::OutlivesPredicate(p_ty, r))\n         });\n \n         param_bounds"}, {"sha": "24b87ffc80c2a5b60a425a1a17dfa6683080560b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -29,6 +29,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(arbitrary_self_types)]\n+#![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(const_fn)]\n@@ -64,7 +65,6 @@\n #![recursion_limit=\"512\"]\n \n #[macro_use] extern crate bitflags;\n-extern crate getopts;\n #[macro_use] extern crate scoped_tls;\n #[cfg(windows)]\n extern crate libc;\n@@ -74,10 +74,6 @@ extern crate libc;\n #[macro_use] extern crate syntax;\n #[macro_use] extern crate smallvec;\n \n-// Use the test crate here so we depend on getopts through it. This allow tools to link to both\n-// librustc_driver and libtest.\n-extern crate test as _;\n-\n #[cfg(test)]\n mod tests;\n \n@@ -96,15 +92,13 @@ pub mod infer;\n pub mod lint;\n \n pub mod middle {\n-    pub mod expr_use_visitor;\n     pub mod cstore;\n     pub mod dependency_format;\n     pub mod diagnostic_items;\n     pub mod exported_symbols;\n     pub mod free_region;\n     pub mod lib_features;\n     pub mod lang_items;\n-    pub mod mem_categorization;\n     pub mod privacy;\n     pub mod reachable;\n     pub mod region;\n@@ -115,7 +109,7 @@ pub mod middle {\n }\n \n pub mod mir;\n-pub mod session;\n+pub use rustc_session as session;\n pub mod traits;\n pub mod ty;\n "}, {"sha": "c4bc9773d23128369f91c1a7d3d4f1e78535c514", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -12,6 +12,8 @@ use syntax::ast;\n use syntax::edition::Edition;\n use syntax::source_map::Span;\n use syntax::symbol::Symbol;\n+use syntax::early_buffered_lints::{ILL_FORMED_ATTRIBUTE_INPUT, META_VARIABLE_MISUSE};\n+use rustc_session::declare_lint;\n \n declare_lint! {\n     pub EXCEEDING_BITSHIFTS,\n@@ -327,7 +329,7 @@ declare_lint! {\n \n declare_lint! {\n     pub UNUSED_LABELS,\n-    Allow,\n+    Warn,\n     \"detects labels that are never used\"\n }\n \n@@ -404,31 +406,6 @@ declare_lint! {\n     };\n }\n \n-/// Some lints that are buffered from `libsyntax`. See `syntax::early_buffered_lints`.\n-pub mod parser {\n-    declare_lint! {\n-        pub ILL_FORMED_ATTRIBUTE_INPUT,\n-        Deny,\n-        \"ill-formed attribute inputs that were previously accepted and used in practice\",\n-        @future_incompatible = super::FutureIncompatibleInfo {\n-            reference: \"issue #57571 <https://github.com/rust-lang/rust/issues/57571>\",\n-            edition: None,\n-        };\n-    }\n-\n-    declare_lint! {\n-        pub META_VARIABLE_MISUSE,\n-        Allow,\n-        \"possible meta-variable misuse at macro definition\"\n-    }\n-\n-    declare_lint! {\n-        pub INCOMPLETE_INCLUDE,\n-        Deny,\n-        \"trailing content in included file\"\n-    }\n-}\n-\n declare_lint! {\n     pub DEPRECATED_IN_FUTURE,\n     Allow,\n@@ -520,8 +497,8 @@ declare_lint_pass! {\n         PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n         MACRO_USE_EXTERN_CRATE,\n         MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n-        parser::ILL_FORMED_ATTRIBUTE_INPUT,\n-        parser::META_VARIABLE_MISUSE,\n+        ILL_FORMED_ATTRIBUTE_INPUT,\n+        META_VARIABLE_MISUSE,\n         DEPRECATED_IN_FUTURE,\n         AMBIGUOUS_ASSOCIATED_ITEMS,\n         MUTABLE_BORROW_RESERVATION_CONFLICT,"}, {"sha": "7f72154e42c61eb0f7fcb447d12e04a295a4c33a", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -47,8 +47,7 @@ use rustc_error_codes::*;\n /// This is basically the subset of `Context` that we can\n /// build early in the compile pipeline.\n pub struct LintStore {\n-    /// Registered lints. The bool is true if the lint was\n-    /// added by a plugin.\n+    /// Registered lints.\n     lints: Vec<&'static Lint>,\n \n     /// Constructor functions for each variety of lint pass.\n@@ -800,8 +799,13 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n                 // This shouldn't ever be needed, but just in case:\n                 path.push(match trait_ref {\n                     Some(trait_ref) => {\n-                        Symbol::intern(&format!(\"<impl {} for {}>\", trait_ref,\n-                                                    self_ty))\n+                        Symbol::intern(\n+                            &format!(\n+                                \"<impl {} for {}>\",\n+                                trait_ref.print_only_trait_path(),\n+                                self_ty\n+                            )\n+                        )\n                     },\n                     None => Symbol::intern(&format!(\"<impl {}>\", self_ty)),\n                 });"}, {"sha": "10c0c63995ca276c7f3e9f2ae15ec185e3d24d65", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -9,6 +9,7 @@ use errors::Applicability;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::{Ident, Item, ItemKind};\n use syntax::symbol::{sym, Symbol};\n+use rustc_session::declare_tool_lint;\n \n declare_tool_lint! {\n     pub rustc::DEFAULT_HASH_TYPES,"}, {"sha": "f29d1a3789aea493275d1e91a7ecde847b705fb7", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -8,7 +8,7 @@ use crate::lint::{self, Lint, LintId, Level, LintSource};\n use crate::session::Session;\n use crate::util::nodemap::FxHashMap;\n use errors::{Applicability, DiagnosticBuilder};\n-use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate;\n@@ -93,7 +93,7 @@ impl LintLevelSets {\n \n         // If `level` is none then we actually assume the default level for this\n         // lint.\n-        let mut level = level.unwrap_or_else(|| lint.default_level(sess));\n+        let mut level = level.unwrap_or_else(|| lint.default_level(sess.edition()));\n \n         // If we're about to issue a warning, check at the last minute for any\n         // directives against the warnings \"lint\". If, for example, there's an\n@@ -232,13 +232,13 @@ impl<'a> LintLevelsBuilder<'a> {\n                             // don't have any lint names (`#[level(reason = \"foo\")]`)\n                             if let ast::LitKind::Str(rationale, _) = name_value.kind {\n                                 if !self.sess.features_untracked().lint_reasons {\n-                                    feature_gate::emit_feature_err(\n+                                    feature_gate::feature_err(\n                                         &self.sess.parse_sess,\n                                         sym::lint_reasons,\n                                         item.span,\n-                                        feature_gate::GateIssue::Language,\n                                         \"lint reasons are experimental\"\n-                                    );\n+                                    )\n+                                    .emit();\n                                 }\n                                 reason = Some(rationale);\n                             } else {\n@@ -566,19 +566,3 @@ impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n         })\n     }\n }\n-\n-impl<HCX> HashStable<HCX> for LintId {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n-        self.lint_name_raw().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<HCX> ToStableHashKey<HCX> for LintId {\n-    type KeyType = &'static str;\n-\n-    #[inline]\n-    fn to_stable_hash_key(&self, _: &HCX) -> &'static str {\n-        self.lint_name_raw()\n-    }\n-}"}, {"sha": "a8d886866795eef22f1760bc105d0d53fdaa0eb5", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 230, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -27,170 +27,22 @@ use crate::hir::def_id::{CrateNum, LOCAL_CRATE};\n use crate::hir::intravisit;\n use crate::hir;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n-use crate::lint::builtin::parser::{ILL_FORMED_ATTRIBUTE_INPUT, META_VARIABLE_MISUSE};\n-use crate::lint::builtin::parser::INCOMPLETE_INCLUDE;\n use crate::session::{Session, DiagnosticMessageId};\n use crate::ty::TyCtxt;\n use crate::ty::query::Providers;\n use crate::util::nodemap::NodeMap;\n use errors::{DiagnosticBuilder, DiagnosticId};\n-use std::{hash, ptr};\n use syntax::ast;\n use syntax::source_map::{MultiSpan, ExpnKind, DesugaringKind};\n-use syntax::early_buffered_lints::BufferedEarlyLintId;\n-use syntax::edition::Edition;\n-use syntax::symbol::{Symbol, sym};\n+use syntax::symbol::Symbol;\n use syntax_pos::hygiene::MacroKind;\n use syntax_pos::Span;\n \n pub use crate::lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n                         check_crate, check_ast_crate, late_lint_mod, CheckLintNameResult,\n                         BufferedEarlyLint,};\n \n-/// Specification of a single lint.\n-#[derive(Copy, Clone, Debug)]\n-pub struct Lint {\n-    /// A string identifier for the lint.\n-    ///\n-    /// This identifies the lint in attributes and in command-line arguments.\n-    /// In those contexts it is always lowercase, but this field is compared\n-    /// in a way which is case-insensitive for ASCII characters. This allows\n-    /// `declare_lint!()` invocations to follow the convention of upper-case\n-    /// statics without repeating the name.\n-    ///\n-    /// The name is written with underscores, e.g., \"unused_imports\".\n-    /// On the command line, underscores become dashes.\n-    pub name: &'static str,\n-\n-    /// Default level for the lint.\n-    pub default_level: Level,\n-\n-    /// Description of the lint or the issue it detects.\n-    ///\n-    /// e.g., \"imports that are never used\"\n-    pub desc: &'static str,\n-\n-    /// Starting at the given edition, default to the given lint level. If this is `None`, then use\n-    /// `default_level`.\n-    pub edition_lint_opts: Option<(Edition, Level)>,\n-\n-    /// `true` if this lint is reported even inside expansions of external macros.\n-    pub report_in_external_macro: bool,\n-\n-    pub future_incompatible: Option<FutureIncompatibleInfo>,\n-\n-    pub is_plugin: bool,\n-}\n-\n-/// Extra information for a future incompatibility lint.\n-#[derive(Copy, Clone, Debug)]\n-pub struct FutureIncompatibleInfo {\n-    /// e.g., a URL for an issue/PR/RFC or error code\n-    pub reference: &'static str,\n-    /// If this is an edition fixing lint, the edition in which\n-    /// this lint becomes obsolete\n-    pub edition: Option<Edition>,\n-}\n-\n-impl Lint {\n-    pub const fn default_fields_for_macro() -> Self {\n-        Lint {\n-            name: \"\",\n-            default_level: Level::Forbid,\n-            desc: \"\",\n-            edition_lint_opts: None,\n-            is_plugin: false,\n-            report_in_external_macro: false,\n-            future_incompatible: None,\n-        }\n-    }\n-\n-    /// Returns the `rust::lint::Lint` for a `syntax::early_buffered_lints::BufferedEarlyLintId`.\n-    pub fn from_parser_lint_id(lint_id: BufferedEarlyLintId) -> &'static Self {\n-        match lint_id {\n-            BufferedEarlyLintId::IllFormedAttributeInput => ILL_FORMED_ATTRIBUTE_INPUT,\n-            BufferedEarlyLintId::MetaVariableMisuse => META_VARIABLE_MISUSE,\n-            BufferedEarlyLintId::IncompleteInclude => INCOMPLETE_INCLUDE,\n-        }\n-    }\n-\n-    /// Gets the lint's name, with ASCII letters converted to lowercase.\n-    pub fn name_lower(&self) -> String {\n-        self.name.to_ascii_lowercase()\n-    }\n-\n-    pub fn default_level(&self, session: &Session) -> Level {\n-        self.edition_lint_opts\n-            .filter(|(e, _)| *e <= session.edition())\n-            .map(|(_, l)| l)\n-            .unwrap_or(self.default_level)\n-    }\n-}\n-\n-/// Declares a static item of type `&'static Lint`.\n-#[macro_export]\n-macro_rules! declare_lint {\n-    ($vis: vis $NAME: ident, $Level: ident, $desc: expr) => (\n-        declare_lint!(\n-            $vis $NAME, $Level, $desc,\n-        );\n-    );\n-    ($vis: vis $NAME: ident, $Level: ident, $desc: expr,\n-     $(@future_incompatible = $fi:expr;)? $($v:ident),*) => (\n-        $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n-            name: stringify!($NAME),\n-            default_level: $crate::lint::$Level,\n-            desc: $desc,\n-            edition_lint_opts: None,\n-            is_plugin: false,\n-            $($v: true,)*\n-            $(future_incompatible: Some($fi),)*\n-            ..$crate::lint::Lint::default_fields_for_macro()\n-        };\n-    );\n-    ($vis: vis $NAME: ident, $Level: ident, $desc: expr,\n-     $lint_edition: expr => $edition_level: ident\n-    ) => (\n-        $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n-            name: stringify!($NAME),\n-            default_level: $crate::lint::$Level,\n-            desc: $desc,\n-            edition_lint_opts: Some(($lint_edition, $crate::lint::Level::$edition_level)),\n-            report_in_external_macro: false,\n-            is_plugin: false,\n-        };\n-    );\n-}\n-\n-#[macro_export]\n-macro_rules! declare_tool_lint {\n-    (\n-        $(#[$attr:meta])* $vis:vis $tool:ident ::$NAME:ident, $Level: ident, $desc: expr\n-    ) => (\n-        declare_tool_lint!{$(#[$attr])* $vis $tool::$NAME, $Level, $desc, false}\n-    );\n-    (\n-        $(#[$attr:meta])* $vis:vis $tool:ident ::$NAME:ident, $Level:ident, $desc:expr,\n-        report_in_external_macro: $rep:expr\n-    ) => (\n-         declare_tool_lint!{$(#[$attr])* $vis $tool::$NAME, $Level, $desc, $rep}\n-    );\n-    (\n-        $(#[$attr:meta])* $vis:vis $tool:ident ::$NAME:ident, $Level:ident, $desc:expr,\n-        $external:expr\n-    ) => (\n-        $(#[$attr])*\n-        $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n-            name: &concat!(stringify!($tool), \"::\", stringify!($NAME)),\n-            default_level: $crate::lint::$Level,\n-            desc: $desc,\n-            edition_lint_opts: None,\n-            report_in_external_macro: $external,\n-            future_incompatible: None,\n-            is_plugin: true,\n-        };\n-    );\n-}\n+pub use rustc_session::lint::{Lint, LintId, Level, FutureIncompatibleInfo};\n \n /// Declares a static `LintArray` and return it as an expression.\n #[macro_export]\n@@ -502,86 +354,6 @@ pub type EarlyLintPassObject = Box<dyn EarlyLintPass + sync::Send + sync::Sync +\n pub type LateLintPassObject = Box<dyn for<'a, 'tcx> LateLintPass<'a, 'tcx> + sync::Send\n                                                                            + sync::Sync + 'static>;\n \n-/// Identifies a lint known to the compiler.\n-#[derive(Clone, Copy, Debug)]\n-pub struct LintId {\n-    // Identity is based on pointer equality of this field.\n-    lint: &'static Lint,\n-}\n-\n-impl PartialEq for LintId {\n-    fn eq(&self, other: &LintId) -> bool {\n-        ptr::eq(self.lint, other.lint)\n-    }\n-}\n-\n-impl Eq for LintId { }\n-\n-impl hash::Hash for LintId {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        let ptr = self.lint as *const Lint;\n-        ptr.hash(state);\n-    }\n-}\n-\n-impl LintId {\n-    /// Gets the `LintId` for a `Lint`.\n-    pub fn of(lint: &'static Lint) -> LintId {\n-        LintId {\n-            lint,\n-        }\n-    }\n-\n-    pub fn lint_name_raw(&self) -> &'static str {\n-        self.lint.name\n-    }\n-\n-    /// Gets the name of the lint.\n-    pub fn to_string(&self) -> String {\n-        self.lint.name_lower()\n-    }\n-}\n-\n-/// Setting for how to handle a lint.\n-#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash, HashStable)]\n-pub enum Level {\n-    Allow, Warn, Deny, Forbid,\n-}\n-\n-impl Level {\n-    /// Converts a level to a lower-case string.\n-    pub fn as_str(self) -> &'static str {\n-        match self {\n-            Allow => \"allow\",\n-            Warn => \"warn\",\n-            Deny => \"deny\",\n-            Forbid => \"forbid\",\n-        }\n-    }\n-\n-    /// Converts a lower-case string to a level.\n-    pub fn from_str(x: &str) -> Option<Level> {\n-        match x {\n-            \"allow\" => Some(Allow),\n-            \"warn\" => Some(Warn),\n-            \"deny\" => Some(Deny),\n-            \"forbid\" => Some(Forbid),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Converts a symbol to a level.\n-    pub fn from_symbol(x: Symbol) -> Option<Level> {\n-        match x {\n-            sym::allow => Some(Allow),\n-            sym::warn => Some(Warn),\n-            sym::deny => Some(Deny),\n-            sym::forbid => Some(Forbid),\n-            _ => None,\n-        }\n-    }\n-}\n-\n /// How a lint level was set.\n #[derive(Clone, Copy, PartialEq, Eq, HashStable)]\n pub enum LintSource {"}, {"sha": "324b01316fa4a63216b153ef005240e9e332cc24", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -20,6 +20,7 @@ use rustc_target::spec::Target;\n use rustc_data_structures::sync::{self, MetadataRef};\n use rustc_macros::HashStable;\n \n+pub use rustc_session::utils::NativeLibraryKind;\n pub use self::NativeLibraryKind::*;\n \n // lonely orphan structs and enums looking for a better home\n@@ -94,21 +95,6 @@ pub enum LinkagePreference {\n     RequireStatic,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n-         RustcEncodable, RustcDecodable, HashStable)]\n-pub enum NativeLibraryKind {\n-    /// native static library (.a archive)\n-    NativeStatic,\n-    /// native static library, which doesn't get bundled into .rlibs\n-    NativeStaticNobundle,\n-    /// macOS-specific\n-    NativeFramework,\n-    /// Windows dynamic library without import library.\n-    NativeRawDylib,\n-    /// default way to specify a dynamic library\n-    NativeUnknown,\n-}\n-\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n@@ -146,6 +132,13 @@ impl ExternCrate {\n     pub fn is_direct(&self) -> bool {\n         self.dependency_of == LOCAL_CRATE\n     }\n+\n+    pub fn rank(&self) -> impl PartialOrd {\n+        // Prefer:\n+        // - direct extern crate to indirect\n+        // - shorter paths to longer\n+        (self.is_direct(), !self.path_len)\n+    }\n }\n \n #[derive(Copy, Clone, Debug, HashStable)]\n@@ -204,7 +197,7 @@ pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n /// (it'd break incremental compilation) and should only be called pre-HIR (e.g.\n /// during resolve)\n pub trait CrateStore {\n-    fn crate_data_as_any(&self, cnum: CrateNum) -> &dyn Any;\n+    fn as_any(&self) -> &dyn Any;\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey;\n@@ -217,9 +210,7 @@ pub trait CrateStore {\n     fn crate_is_private_dep_untracked(&self, cnum: CrateNum) -> bool;\n     fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> CrateDisambiguator;\n     fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh;\n-    fn crate_host_hash_untracked(&self, cnum: CrateNum) -> Option<Svh>;\n     fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics;\n-    fn postorder_cnums_untracked(&self) -> Vec<CrateNum>;\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n@@ -228,7 +219,6 @@ pub trait CrateStore {\n     // utility functions\n     fn encode_metadata(&self, tcx: TyCtxt<'_>) -> EncodedMetadata;\n     fn metadata_encoding_version(&self) -> &[u8];\n-    fn injected_panic_runtime(&self) -> Option<CrateNum>;\n     fn allocator_kind(&self) -> Option<AllocatorKind>;\n }\n "}, {"sha": "6f7a022eccfb843538a55875ee37b93aca02be27", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -358,7 +358,6 @@ language_item_table! {\n     // Don't be fooled by the naming here: this lang item denotes `PartialEq`, not `Eq`.\n     EqTraitLangItem,             \"eq\",                 eq_trait,                Target::Trait;\n     PartialOrdTraitLangItem,     \"partial_ord\",        partial_ord_trait,       Target::Trait;\n-    OrdTraitLangItem,            \"ord\",                ord_trait,               Target::Trait;\n \n     // A number of panic-related lang items. The `panic` item corresponds to\n     // divide-by-zero and various panic cases with `match`. The"}, {"sha": "3510fe4d12359d967f55942e918644cf375201c1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "removed", "additions": 0, "deletions": 1508, "changes": 1508, "blob_url": "https://github.com/rust-lang/rust/blob/969926fcfe68787595d384f53d19cf6b8c9df3e3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969926fcfe68787595d384f53d19cf6b8c9df3e3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=969926fcfe68787595d384f53d19cf6b8c9df3e3", "patch": "@@ -1,1508 +0,0 @@\n-//! # Categorization\n-//!\n-//! The job of the categorization module is to analyze an expression to\n-//! determine what kind of memory is used in evaluating it (for example,\n-//! where dereferences occur and what kind of pointer is dereferenced;\n-//! whether the memory is mutable, etc.).\n-//!\n-//! Categorization effectively transforms all of our expressions into\n-//! expressions of the following forms (the actual enum has many more\n-//! possibilities, naturally, but they are all variants of these base\n-//! forms):\n-//!\n-//!     E = rvalue    // some computed rvalue\n-//!       | x         // address of a local variable or argument\n-//!       | *E        // deref of a ptr\n-//!       | E.comp    // access to an interior component\n-//!\n-//! Imagine a routine ToAddr(Expr) that evaluates an expression and returns an\n-//! address where the result is to be found. If Expr is a place, then this\n-//! is the address of the place. If `Expr` is an rvalue, this is the address of\n-//! some temporary spot in memory where the result is stored.\n-//!\n-//! Now, `cat_expr()` classifies the expression `Expr` and the address `A = ToAddr(Expr)`\n-//! as follows:\n-//!\n-//! - `cat`: what kind of expression was this? This is a subset of the\n-//!   full expression forms which only includes those that we care about\n-//!   for the purpose of the analysis.\n-//! - `mutbl`: mutability of the address `A`.\n-//! - `ty`: the type of data found at the address `A`.\n-//!\n-//! The resulting categorization tree differs somewhat from the expressions\n-//! themselves. For example, auto-derefs are explicit. Also, an index a[b] is\n-//! decomposed into two operations: a dereference to reach the array data and\n-//! then an index to jump forward to the relevant item.\n-//!\n-//! ## By-reference upvars\n-//!\n-//! One part of the codegen which may be non-obvious is that we translate\n-//! closure upvars into the dereference of a borrowed pointer; this more closely\n-//! resembles the runtime codegen. So, for example, if we had:\n-//!\n-//!     let mut x = 3;\n-//!     let y = 5;\n-//!     let inc = || x += y;\n-//!\n-//! Then when we categorize `x` (*within* the closure) we would yield a\n-//! result of `*x'`, effectively, where `x'` is a `Categorization::Upvar` reference\n-//! tied to `x`. The type of `x'` will be a borrowed pointer.\n-\n-#![allow(non_camel_case_types)]\n-\n-pub use self::PointerKind::*;\n-pub use self::InteriorKind::*;\n-pub use self::MutabilityCategory::*;\n-pub use self::AliasableReason::*;\n-pub use self::Note::*;\n-\n-use self::Aliasability::*;\n-\n-use crate::middle::region;\n-use crate::hir::def_id::{DefId, LocalDefId};\n-use crate::hir::Node;\n-use crate::infer::InferCtxt;\n-use crate::hir::def::{CtorOf, Res, DefKind, CtorKind};\n-use crate::ty::adjustment;\n-use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n-use crate::ty::fold::TypeFoldable;\n-\n-use crate::hir::{Mutability, PatKind};\n-use crate::hir::pat_util::EnumerateAndAdjustIterator;\n-use crate::hir;\n-use syntax::ast::{self, Name};\n-use syntax::symbol::sym;\n-use syntax_pos::Span;\n-\n-use std::borrow::Cow;\n-use std::fmt;\n-use std::hash::{Hash, Hasher};\n-use rustc_data_structures::fx::FxIndexMap;\n-use std::rc::Rc;\n-\n-#[derive(Clone, Debug, PartialEq)]\n-pub enum Categorization<'tcx> {\n-    Rvalue,                              // temporary val\n-    ThreadLocal,                         // value that cannot move, but still restricted in scope\n-    StaticItem,\n-    Upvar(Upvar),                        // upvar referenced by closure env\n-    Local(hir::HirId),                   // local variable\n-    Deref(cmt<'tcx>, PointerKind<'tcx>), // deref of a ptr\n-    Interior(cmt<'tcx>, InteriorKind),   // something interior: field, tuple, etc\n-    Downcast(cmt<'tcx>, DefId),          // selects a particular enum variant (*1)\n-\n-    // (*1) downcast is only required if the enum has more than one variant\n-}\n-\n-// Represents any kind of upvar\n-#[derive(Clone, Copy, PartialEq)]\n-pub struct Upvar {\n-    pub id: ty::UpvarId,\n-    pub kind: ty::ClosureKind\n-}\n-\n-// different kinds of pointers:\n-#[derive(Clone, Copy, Debug, PartialEq)]\n-pub enum PointerKind<'tcx> {\n-    /// `Box<T>`\n-    Unique,\n-\n-    /// `&T`\n-    BorrowedPtr(ty::BorrowKind, ty::Region<'tcx>),\n-\n-    /// `*T`\n-    UnsafePtr(hir::Mutability),\n-}\n-\n-// We use the term \"interior\" to mean \"something reachable from the\n-// base without a pointer dereference\", e.g., a field\n-#[derive(Clone, PartialEq)]\n-pub enum InteriorKind {\n-    InteriorField(FieldIndex),\n-    InteriorElement(InteriorOffsetKind),\n-}\n-\n-// Contains index of a field that is actually used for loan path comparisons and\n-// string representation of the field that should be used only for diagnostics.\n-#[derive(Clone, Copy, Eq)]\n-pub struct FieldIndex(pub usize, pub Name);\n-\n-impl PartialEq for FieldIndex {\n-    fn eq(&self, rhs: &Self) -> bool {\n-        self.0 == rhs.0\n-    }\n-}\n-\n-impl Hash for FieldIndex {\n-    fn hash<H: Hasher>(&self, h: &mut H) {\n-        self.0.hash(h)\n-    }\n-}\n-\n-#[derive(Clone, PartialEq)]\n-pub enum InteriorOffsetKind {\n-    Index,   // e.g., `array_expr[index_expr]`\n-    Pattern, // e.g., `fn foo([_, a, _, _]: [A; 4]) { ... }`\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Debug)]\n-pub enum MutabilityCategory {\n-    McImmutable, // Immutable.\n-    McDeclared,  // Directly declared as mutable.\n-    McInherited, // Inherited from the fact that owner is mutable.\n-}\n-\n-// A note about the provenance of a `cmt`.  This is used for\n-// special-case handling of upvars such as mutability inference.\n-// Upvar categorization can generate a variable number of nested\n-// derefs.  The note allows detecting them without deep pattern\n-// matching on the categorization.\n-#[derive(Clone, Copy, PartialEq, Debug)]\n-pub enum Note {\n-    NoteClosureEnv(ty::UpvarId), // Deref through closure env\n-    NoteUpvarRef(ty::UpvarId),   // Deref through by-ref upvar\n-    NoteIndex,                   // Deref as part of desugaring `x[]` into its two components\n-    NoteNone                     // Nothing special\n-}\n-\n-// `cmt`: \"Category, Mutability, and Type\".\n-//\n-// a complete categorization of a value indicating where it originated\n-// and how it is located, as well as the mutability of the memory in\n-// which the value is stored.\n-//\n-// *WARNING* The field `cmt.type` is NOT necessarily the same as the\n-// result of `node_type(cmt.id)`.\n-//\n-// (FIXME: rewrite the following comment given that `@x` managed\n-// pointers have been obsolete for quite some time.)\n-//\n-// This is because the `id` is always the `id` of the node producing the\n-// type; in an expression like `*x`, the type of this deref node is the\n-// deref'd type (`T`), but in a pattern like `@x`, the `@x` pattern is\n-// again a dereference, but its type is the type *before* the\n-// dereference (`@T`). So use `cmt.ty` to find the type of the value in\n-// a consistent fashion. For more details, see the method `cat_pattern`\n-#[derive(Clone, Debug, PartialEq)]\n-pub struct cmt_<'tcx> {\n-    pub hir_id: hir::HirId,        // HIR id of expr/pat producing this value\n-    pub span: Span,                // span of same expr/pat\n-    pub cat: Categorization<'tcx>, // categorization of expr\n-    pub mutbl: MutabilityCategory, // mutability of expr as place\n-    pub ty: Ty<'tcx>,              // type of the expr (*see WARNING above*)\n-    pub note: Note,                // Note about the provenance of this cmt\n-}\n-\n-pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n-\n-pub trait HirNode {\n-    fn hir_id(&self) -> hir::HirId;\n-    fn span(&self) -> Span;\n-}\n-\n-impl HirNode for hir::Expr {\n-    fn hir_id(&self) -> hir::HirId { self.hir_id }\n-    fn span(&self) -> Span { self.span }\n-}\n-\n-impl HirNode for hir::Pat {\n-    fn hir_id(&self) -> hir::HirId { self.hir_id }\n-    fn span(&self) -> Span { self.span }\n-}\n-\n-#[derive(Clone)]\n-pub struct MemCategorizationContext<'a, 'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    pub body_owner: DefId,\n-    pub upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n-    pub region_scope_tree: &'a region::ScopeTree,\n-    pub tables: &'a ty::TypeckTables<'tcx>,\n-    infcx: Option<&'a InferCtxt<'a, 'tcx>>,\n-}\n-\n-pub type McResult<T> = Result<T, ()>;\n-\n-impl MutabilityCategory {\n-    pub fn from_mutbl(m: hir::Mutability) -> MutabilityCategory {\n-        let ret = match m {\n-            Mutability::Immutable => McImmutable,\n-            Mutability::Mutable => McDeclared\n-        };\n-        debug!(\"MutabilityCategory::{}({:?}) => {:?}\",\n-               \"from_mutbl\", m, ret);\n-        ret\n-    }\n-\n-    pub fn from_borrow_kind(borrow_kind: ty::BorrowKind) -> MutabilityCategory {\n-        let ret = match borrow_kind {\n-            ty::ImmBorrow => McImmutable,\n-            ty::UniqueImmBorrow => McImmutable,\n-            ty::MutBorrow => McDeclared,\n-        };\n-        debug!(\"MutabilityCategory::{}({:?}) => {:?}\",\n-               \"from_borrow_kind\", borrow_kind, ret);\n-        ret\n-    }\n-\n-    fn from_pointer_kind(base_mutbl: MutabilityCategory,\n-                         ptr: PointerKind<'_>) -> MutabilityCategory {\n-        let ret = match ptr {\n-            Unique => {\n-                base_mutbl.inherit()\n-            }\n-            BorrowedPtr(borrow_kind, _) => {\n-                MutabilityCategory::from_borrow_kind(borrow_kind)\n-            }\n-            UnsafePtr(m) => {\n-                MutabilityCategory::from_mutbl(m)\n-            }\n-        };\n-        debug!(\"MutabilityCategory::{}({:?}, {:?}) => {:?}\",\n-               \"from_pointer_kind\", base_mutbl, ptr, ret);\n-        ret\n-    }\n-\n-    fn from_local(\n-        tcx: TyCtxt<'_>,\n-        tables: &ty::TypeckTables<'_>,\n-        id: hir::HirId,\n-    ) -> MutabilityCategory {\n-        let ret = match tcx.hir().get(id) {\n-            Node::Binding(p) => match p.kind {\n-                PatKind::Binding(..) => {\n-                    let bm = *tables.pat_binding_modes()\n-                                    .get(p.hir_id)\n-                                    .expect(\"missing binding mode\");\n-                    if bm == ty::BindByValue(Mutability::Mutable) {\n-                        McDeclared\n-                    } else {\n-                        McImmutable\n-                    }\n-                }\n-                _ => span_bug!(p.span, \"expected identifier pattern\")\n-            },\n-            _ => span_bug!(tcx.hir().span(id), \"expected identifier pattern\")\n-        };\n-        debug!(\"MutabilityCategory::{}(tcx, id={:?}) => {:?}\",\n-               \"from_local\", id, ret);\n-        ret\n-    }\n-\n-    pub fn inherit(&self) -> MutabilityCategory {\n-        let ret = match *self {\n-            McImmutable => McImmutable,\n-            McDeclared => McInherited,\n-            McInherited => McInherited,\n-        };\n-        debug!(\"{:?}.inherit() => {:?}\", self, ret);\n-        ret\n-    }\n-\n-    pub fn is_mutable(&self) -> bool {\n-        let ret = match *self {\n-            McImmutable => false,\n-            McInherited => true,\n-            McDeclared => true,\n-        };\n-        debug!(\"{:?}.is_mutable() => {:?}\", self, ret);\n-        ret\n-    }\n-\n-    pub fn is_immutable(&self) -> bool {\n-        let ret = match *self {\n-            McImmutable => true,\n-            McDeclared | McInherited => false\n-        };\n-        debug!(\"{:?}.is_immutable() => {:?}\", self, ret);\n-        ret\n-    }\n-\n-    pub fn to_user_str(&self) -> &'static str {\n-        match *self {\n-            McDeclared | McInherited => \"mutable\",\n-            McImmutable => \"immutable\",\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        body_owner: DefId,\n-        region_scope_tree: &'a region::ScopeTree,\n-        tables: &'a ty::TypeckTables<'tcx>,\n-    ) -> MemCategorizationContext<'a, 'tcx> {\n-        MemCategorizationContext {\n-            tcx,\n-            body_owner,\n-            upvars: tcx.upvars(body_owner),\n-            region_scope_tree,\n-            tables,\n-            infcx: None,\n-            param_env,\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n-    /// Creates a `MemCategorizationContext` during type inference.\n-    /// This is used during upvar analysis and a few other places.\n-    /// Because the typeck tables are not yet complete, the results\n-    /// from the analysis must be used with caution:\n-    ///\n-    /// - rvalue promotions are not known, so the lifetimes of\n-    ///   temporaries may be overly conservative;\n-    /// - similarly, as the results of upvar analysis are not yet\n-    ///   known, the results around upvar accesses may be incorrect.\n-    pub fn with_infer(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        body_owner: DefId,\n-        region_scope_tree: &'a region::ScopeTree,\n-        tables: &'a ty::TypeckTables<'tcx>,\n-    ) -> MemCategorizationContext<'a, 'tcx> {\n-        let tcx = infcx.tcx;\n-\n-        MemCategorizationContext {\n-            tcx,\n-            body_owner,\n-            upvars: tcx.upvars(body_owner),\n-            region_scope_tree,\n-            tables,\n-            infcx: Some(infcx),\n-            param_env,\n-        }\n-    }\n-\n-    pub fn type_is_copy_modulo_regions(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> bool {\n-        self.infcx.map(|infcx| infcx.type_is_copy_modulo_regions(param_env, ty, span))\n-            .or_else(|| {\n-                if (param_env, ty).has_local_value() {\n-                    None\n-                } else {\n-                    Some(ty.is_copy_modulo_regions(self.tcx, param_env, span))\n-                }\n-            })\n-            .unwrap_or(true)\n-    }\n-\n-    fn resolve_vars_if_possible<T>(&self, value: &T) -> T\n-        where T: TypeFoldable<'tcx>\n-    {\n-        self.infcx.map(|infcx| infcx.resolve_vars_if_possible(value))\n-            .unwrap_or_else(|| value.clone())\n-    }\n-\n-    fn is_tainted_by_errors(&self) -> bool {\n-        self.infcx.map_or(false, |infcx| infcx.is_tainted_by_errors())\n-    }\n-\n-    fn resolve_type_vars_or_error(&self,\n-                                  id: hir::HirId,\n-                                  ty: Option<Ty<'tcx>>)\n-                                  -> McResult<Ty<'tcx>> {\n-        match ty {\n-            Some(ty) => {\n-                let ty = self.resolve_vars_if_possible(&ty);\n-                if ty.references_error() || ty.is_ty_var() {\n-                    debug!(\"resolve_type_vars_or_error: error from {:?}\", ty);\n-                    Err(())\n-                } else {\n-                    Ok(ty)\n-                }\n-            }\n-            // FIXME\n-            None if self.is_tainted_by_errors() => Err(()),\n-            None => {\n-                bug!(\"no type for node {}: {} in mem_categorization\",\n-                     id, self.tcx.hir().node_to_string(id));\n-            }\n-        }\n-    }\n-\n-    pub fn node_ty(&self,\n-                   hir_id: hir::HirId)\n-                   -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(hir_id,\n-                                        self.tables.node_type_opt(hir_id))\n-    }\n-\n-    pub fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_opt(expr))\n-    }\n-\n-    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_adjusted_opt(expr))\n-    }\n-\n-    /// Returns the type of value that this pattern matches against.\n-    /// Some non-obvious cases:\n-    ///\n-    /// - a `ref x` binding matches against a value of type `T` and gives\n-    ///   `x` the type `&T`; we return `T`.\n-    /// - a pattern with implicit derefs (thanks to default binding\n-    ///   modes #42640) may look like `Some(x)` but in fact have\n-    ///   implicit deref patterns attached (e.g., it is really\n-    ///   `&Some(x)`). In that case, we return the \"outermost\" type\n-    ///   (e.g., `&Option<T>).\n-    pub fn pat_ty_adjusted(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n-        // Check for implicit `&` types wrapping the pattern; note\n-        // that these are never attached to binding patterns, so\n-        // actually this is somewhat \"disjoint\" from the code below\n-        // that aims to account for `ref x`.\n-        if let Some(vec) = self.tables.pat_adjustments().get(pat.hir_id) {\n-            if let Some(first_ty) = vec.first() {\n-                debug!(\"pat_ty(pat={:?}) found adjusted ty `{:?}`\", pat, first_ty);\n-                return Ok(first_ty);\n-            }\n-        }\n-\n-        self.pat_ty_unadjusted(pat)\n-    }\n-\n-\n-    /// Like `pat_ty`, but ignores implicit `&` patterns.\n-    fn pat_ty_unadjusted(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n-        let base_ty = self.node_ty(pat.hir_id)?;\n-        debug!(\"pat_ty(pat={:?}) base_ty={:?}\", pat, base_ty);\n-\n-        // This code detects whether we are looking at a `ref x`,\n-        // and if so, figures out what the type *being borrowed* is.\n-        let ret_ty = match pat.kind {\n-            PatKind::Binding(..) => {\n-                let bm = *self.tables\n-                              .pat_binding_modes()\n-                              .get(pat.hir_id)\n-                              .expect(\"missing binding mode\");\n-\n-                if let ty::BindByReference(_) = bm {\n-                    // a bind-by-ref means that the base_ty will be the type of the ident itself,\n-                    // but what we want here is the type of the underlying value being borrowed.\n-                    // So peel off one-level, turning the &T into T.\n-                    match base_ty.builtin_deref(false) {\n-                        Some(t) => t.ty,\n-                        None => {\n-                            debug!(\"By-ref binding of non-derefable type {:?}\", base_ty);\n-                            return Err(());\n-                        }\n-                    }\n-                } else {\n-                    base_ty\n-                }\n-            }\n-            _ => base_ty,\n-        };\n-        debug!(\"pat_ty(pat={:?}) ret_ty={:?}\", pat, ret_ty);\n-\n-        Ok(ret_ty)\n-    }\n-\n-    pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt_<'tcx>> {\n-        // This recursion helper avoids going through *too many*\n-        // adjustments, since *only* non-overloaded deref recurses.\n-        fn helper<'a, 'tcx>(\n-            mc: &MemCategorizationContext<'a, 'tcx>,\n-            expr: &hir::Expr,\n-            adjustments: &[adjustment::Adjustment<'tcx>],\n-        ) -> McResult<cmt_<'tcx>> {\n-            match adjustments.split_last() {\n-                None => mc.cat_expr_unadjusted(expr),\n-                Some((adjustment, previous)) => {\n-                    mc.cat_expr_adjusted_with(expr, || helper(mc, expr, previous), adjustment)\n-                }\n-            }\n-        }\n-\n-        helper(self, expr, self.tables.expr_adjustments(expr))\n-    }\n-\n-    pub fn cat_expr_adjusted(&self, expr: &hir::Expr,\n-                             previous: cmt_<'tcx>,\n-                             adjustment: &adjustment::Adjustment<'tcx>)\n-                             -> McResult<cmt_<'tcx>> {\n-        self.cat_expr_adjusted_with(expr, || Ok(previous), adjustment)\n-    }\n-\n-    fn cat_expr_adjusted_with<F>(&self, expr: &hir::Expr,\n-                                 previous: F,\n-                                 adjustment: &adjustment::Adjustment<'tcx>)\n-                                 -> McResult<cmt_<'tcx>>\n-        where F: FnOnce() -> McResult<cmt_<'tcx>>\n-    {\n-        debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n-        let target = self.resolve_vars_if_possible(&adjustment.target);\n-        match adjustment.kind {\n-            adjustment::Adjust::Deref(overloaded) => {\n-                // Equivalent to *expr or something similar.\n-                let base = Rc::new(if let Some(deref) = overloaded {\n-                    let ref_ty = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n-                        ty: target,\n-                        mutbl: deref.mutbl,\n-                    });\n-                    self.cat_rvalue_node(expr.hir_id, expr.span, ref_ty)\n-                } else {\n-                    previous()?\n-                });\n-                self.cat_deref(expr, base, NoteNone)\n-            }\n-\n-            adjustment::Adjust::NeverToAny |\n-            adjustment::Adjust::Pointer(_) |\n-            adjustment::Adjust::Borrow(_) => {\n-                // Result is an rvalue.\n-                Ok(self.cat_rvalue_node(expr.hir_id, expr.span, target))\n-            }\n-        }\n-    }\n-\n-    pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<cmt_<'tcx>> {\n-        debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n-\n-        let expr_ty = self.expr_ty(expr)?;\n-        match expr.kind {\n-            hir::ExprKind::Unary(hir::UnDeref, ref e_base) => {\n-                if self.tables.is_method_call(expr) {\n-                    self.cat_overloaded_place(expr, e_base, NoteNone)\n-                } else {\n-                    let base_cmt = Rc::new(self.cat_expr(&e_base)?);\n-                    self.cat_deref(expr, base_cmt, NoteNone)\n-                }\n-            }\n-\n-            hir::ExprKind::Field(ref base, f_ident) => {\n-                let base_cmt = Rc::new(self.cat_expr(&base)?);\n-                debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n-                       expr.hir_id,\n-                       expr,\n-                       base_cmt);\n-                let f_index = self.tcx.field_index(expr.hir_id, self.tables);\n-                Ok(self.cat_field(expr, base_cmt, f_index, f_ident, expr_ty))\n-            }\n-\n-            hir::ExprKind::Index(ref base, _) => {\n-                if self.tables.is_method_call(expr) {\n-                    // If this is an index implemented by a method call, then it\n-                    // will include an implicit deref of the result.\n-                    // The call to index() returns a `&T` value, which\n-                    // is an rvalue. That is what we will be\n-                    // dereferencing.\n-                    self.cat_overloaded_place(expr, base, NoteIndex)\n-                } else {\n-                    let base_cmt = Rc::new(self.cat_expr(&base)?);\n-                    self.cat_index(expr, base_cmt, expr_ty, InteriorOffsetKind::Index)\n-                }\n-            }\n-\n-            hir::ExprKind::Path(ref qpath) => {\n-                let res = self.tables.qpath_res(qpath, expr.hir_id);\n-                self.cat_res(expr.hir_id, expr.span, expr_ty, res)\n-            }\n-\n-            hir::ExprKind::Type(ref e, _) => {\n-                self.cat_expr(&e)\n-            }\n-\n-            hir::ExprKind::AddrOf(..) | hir::ExprKind::Call(..) |\n-            hir::ExprKind::Assign(..) | hir::ExprKind::AssignOp(..) |\n-            hir::ExprKind::Closure(..) | hir::ExprKind::Ret(..) |\n-            hir::ExprKind::Unary(..) | hir::ExprKind::Yield(..) |\n-            hir::ExprKind::MethodCall(..) | hir::ExprKind::Cast(..) | hir::ExprKind::DropTemps(..) |\n-            hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) |\n-            hir::ExprKind::Binary(..) |\n-            hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) | hir::ExprKind::Match(..) |\n-            hir::ExprKind::Lit(..) | hir::ExprKind::Break(..) |\n-            hir::ExprKind::Continue(..) | hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n-            hir::ExprKind::InlineAsm(..) | hir::ExprKind::Box(..) | hir::ExprKind::Err => {\n-                Ok(self.cat_rvalue_node(expr.hir_id, expr.span, expr_ty))\n-            }\n-        }\n-    }\n-\n-    pub fn cat_res(&self,\n-                   hir_id: hir::HirId,\n-                   span: Span,\n-                   expr_ty: Ty<'tcx>,\n-                   res: Res)\n-                   -> McResult<cmt_<'tcx>> {\n-        debug!(\"cat_res: id={:?} expr={:?} def={:?}\",\n-               hir_id, expr_ty, res);\n-\n-        match res {\n-            Res::Def(DefKind::Ctor(..), _)\n-            | Res::Def(DefKind::Const, _)\n-            | Res::Def(DefKind::ConstParam, _)\n-            | Res::Def(DefKind::AssocConst, _)\n-            | Res::Def(DefKind::Fn, _)\n-            | Res::Def(DefKind::Method, _)\n-            | Res::SelfCtor(..) => {\n-                Ok(self.cat_rvalue_node(hir_id, span, expr_ty))\n-            }\n-\n-            Res::Def(DefKind::Static, def_id) => {\n-                // `#[thread_local]` statics may not outlive the current function, but\n-                // they also cannot be moved out of.\n-                let is_thread_local = self.tcx.get_attrs(def_id)[..]\n-                    .iter()\n-                    .any(|attr| attr.check_name(sym::thread_local));\n-\n-                let cat = if is_thread_local {\n-                    Categorization::ThreadLocal\n-                } else {\n-                    Categorization::StaticItem\n-                };\n-\n-                Ok(cmt_ {\n-                    hir_id,\n-                    span,\n-                    cat,\n-                    mutbl: match self.tcx.static_mutability(def_id).unwrap() {\n-                        Mutability::Immutable => McImmutable,\n-                        Mutability::Mutable => McDeclared,\n-                    },\n-                    ty:expr_ty,\n-                    note: NoteNone\n-                })\n-            }\n-\n-            Res::Local(var_id) => {\n-                if self.upvars.map_or(false, |upvars| upvars.contains_key(&var_id)) {\n-                    self.cat_upvar(hir_id, span, var_id)\n-                } else {\n-                    Ok(cmt_ {\n-                        hir_id,\n-                        span,\n-                        cat: Categorization::Local(var_id),\n-                        mutbl: MutabilityCategory::from_local(self.tcx, self.tables, var_id),\n-                        ty: expr_ty,\n-                        note: NoteNone\n-                    })\n-                }\n-            }\n-\n-            def => span_bug!(span, \"unexpected definition in memory categorization: {:?}\", def)\n-        }\n-    }\n-\n-    // Categorize an upvar, complete with invisible derefs of closure\n-    // environment and upvar reference as appropriate.\n-    fn cat_upvar(\n-        &self,\n-        hir_id: hir::HirId,\n-        span: Span,\n-        var_id: hir::HirId,\n-    ) -> McResult<cmt_<'tcx>> {\n-        // An upvar can have up to 3 components. We translate first to a\n-        // `Categorization::Upvar`, which is itself a fiction -- it represents the reference to the\n-        // field from the environment.\n-        //\n-        // `Categorization::Upvar`.  Next, we add a deref through the implicit\n-        // environment pointer with an anonymous free region 'env and\n-        // appropriate borrow kind for closure kinds that take self by\n-        // reference.  Finally, if the upvar was captured\n-        // by-reference, we add a deref through that reference.  The\n-        // region of this reference is an inference variable 'up that\n-        // was previously generated and recorded in the upvar borrow\n-        // map.  The borrow kind bk is inferred by based on how the\n-        // upvar is used.\n-        //\n-        // This results in the following table for concrete closure\n-        // types:\n-        //\n-        //                | move                 | ref\n-        // ---------------+----------------------+-------------------------------\n-        // Fn             | copied -> &'env      | upvar -> &'env -> &'up bk\n-        // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n-        // FnOnce         | copied               | upvar -> &'up bk\n-\n-        let closure_expr_def_id = self.body_owner;\n-        let fn_hir_id = self.tcx.hir().local_def_id_to_hir_id(\n-            LocalDefId::from_def_id(closure_expr_def_id),\n-        );\n-        let ty = self.node_ty(fn_hir_id)?;\n-        let kind = match ty.kind {\n-            ty::Generator(..) => ty::ClosureKind::FnOnce,\n-            ty::Closure(closure_def_id, substs) => {\n-                match self.infcx {\n-                    // During upvar inference we may not know the\n-                    // closure kind, just use the LATTICE_BOTTOM value.\n-                    Some(infcx) =>\n-                        infcx.closure_kind(\n-                            closure_def_id,\n-                            substs\n-                        ).unwrap_or(ty::ClosureKind::LATTICE_BOTTOM),\n-\n-                    None =>\n-                        substs.as_closure().kind(closure_def_id, self.tcx),\n-                }\n-            }\n-            _ => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", ty),\n-        };\n-\n-        let upvar_id = ty::UpvarId {\n-            var_path: ty::UpvarPath { hir_id: var_id },\n-            closure_expr_id: closure_expr_def_id.to_local(),\n-        };\n-\n-        let var_ty = self.node_ty(var_id)?;\n-\n-        // Mutability of original variable itself\n-        let var_mutbl = MutabilityCategory::from_local(self.tcx, self.tables, var_id);\n-\n-        // Construct the upvar. This represents access to the field\n-        // from the environment (perhaps we should eventually desugar\n-        // this field further, but it will do for now).\n-        let cmt_result = cmt_ {\n-            hir_id,\n-            span,\n-            cat: Categorization::Upvar(Upvar {id: upvar_id, kind: kind}),\n-            mutbl: var_mutbl,\n-            ty: var_ty,\n-            note: NoteNone\n-        };\n-\n-        // If this is a `FnMut` or `Fn` closure, then the above is\n-        // conceptually a `&mut` or `&` reference, so we have to add a\n-        // deref.\n-        let cmt_result = match kind {\n-            ty::ClosureKind::FnOnce => {\n-                cmt_result\n-            }\n-            ty::ClosureKind::FnMut => {\n-                self.env_deref(hir_id, span, upvar_id, var_mutbl, ty::MutBorrow, cmt_result)\n-            }\n-            ty::ClosureKind::Fn => {\n-                self.env_deref(hir_id, span, upvar_id, var_mutbl, ty::ImmBorrow, cmt_result)\n-            }\n-        };\n-\n-        // If this is a by-ref capture, then the upvar we loaded is\n-        // actually a reference, so we have to add an implicit deref\n-        // for that.\n-        let upvar_capture = self.tables.upvar_capture(upvar_id);\n-        let cmt_result = match upvar_capture {\n-            ty::UpvarCapture::ByValue => {\n-                cmt_result\n-            }\n-            ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n-                cmt_ {\n-                    hir_id,\n-                    span,\n-                    cat: Categorization::Deref(Rc::new(cmt_result), ptr),\n-                    mutbl: MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n-                    ty: var_ty,\n-                    note: NoteUpvarRef(upvar_id)\n-                }\n-            }\n-        };\n-\n-        let ret = cmt_result;\n-        debug!(\"cat_upvar ret={:?}\", ret);\n-        Ok(ret)\n-    }\n-\n-    fn env_deref(&self,\n-                 hir_id: hir::HirId,\n-                 span: Span,\n-                 upvar_id: ty::UpvarId,\n-                 upvar_mutbl: MutabilityCategory,\n-                 env_borrow_kind: ty::BorrowKind,\n-                 cmt_result: cmt_<'tcx>)\n-                 -> cmt_<'tcx>\n-    {\n-        // Region of environment pointer\n-        let env_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-            // The environment of a closure is guaranteed to\n-            // outlive any bindings introduced in the body of the\n-            // closure itself.\n-            scope: upvar_id.closure_expr_id.to_def_id(),\n-            bound_region: ty::BrEnv\n-        }));\n-\n-        let env_ptr = BorrowedPtr(env_borrow_kind, env_region);\n-\n-        let var_ty = cmt_result.ty;\n-\n-        // We need to add the env deref.  This means\n-        // that the above is actually immutable and\n-        // has a ref type.  However, nothing should\n-        // actually look at the type, so we can get\n-        // away with stuffing a `Error` in there\n-        // instead of bothering to construct a proper\n-        // one.\n-        let cmt_result = cmt_ {\n-            mutbl: McImmutable,\n-            ty: self.tcx.types.err,\n-            ..cmt_result\n-        };\n-\n-        let mut deref_mutbl = MutabilityCategory::from_borrow_kind(env_borrow_kind);\n-\n-        // Issue #18335. If variable is declared as immutable, override the\n-        // mutability from the environment and substitute an `&T` anyway.\n-        match upvar_mutbl {\n-            McImmutable => { deref_mutbl = McImmutable; }\n-            McDeclared | McInherited => { }\n-        }\n-\n-        let ret = cmt_ {\n-            hir_id,\n-            span,\n-            cat: Categorization::Deref(Rc::new(cmt_result), env_ptr),\n-            mutbl: deref_mutbl,\n-            ty: var_ty,\n-            note: NoteClosureEnv(upvar_id)\n-        };\n-\n-        debug!(\"env_deref ret {:?}\", ret);\n-\n-        ret\n-    }\n-\n-    pub fn cat_rvalue_node(&self,\n-                           hir_id: hir::HirId,\n-                           span: Span,\n-                           expr_ty: Ty<'tcx>)\n-                           -> cmt_<'tcx> {\n-        debug!(\"cat_rvalue_node(id={:?}, span={:?}, expr_ty={:?})\",\n-               hir_id, span, expr_ty);\n-\n-        let ret = self.cat_rvalue(hir_id, span, expr_ty);\n-        debug!(\"cat_rvalue_node ret {:?}\", ret);\n-        ret\n-    }\n-\n-    pub fn cat_rvalue(&self,\n-                      cmt_hir_id: hir::HirId,\n-                      span: Span,\n-                      expr_ty: Ty<'tcx>) -> cmt_<'tcx> {\n-        let ret = cmt_ {\n-            hir_id: cmt_hir_id,\n-            span:span,\n-            cat:Categorization::Rvalue,\n-            mutbl:McDeclared,\n-            ty:expr_ty,\n-            note: NoteNone\n-        };\n-        debug!(\"cat_rvalue ret {:?}\", ret);\n-        ret\n-    }\n-\n-    pub fn cat_field<N: HirNode>(&self,\n-                                 node: &N,\n-                                 base_cmt: cmt<'tcx>,\n-                                 f_index: usize,\n-                                 f_ident: ast::Ident,\n-                                 f_ty: Ty<'tcx>)\n-                                 -> cmt_<'tcx> {\n-        let ret = cmt_ {\n-            hir_id: node.hir_id(),\n-            span: node.span(),\n-            mutbl: base_cmt.mutbl.inherit(),\n-            cat: Categorization::Interior(base_cmt,\n-                                          InteriorField(FieldIndex(f_index, f_ident.name))),\n-            ty: f_ty,\n-            note: NoteNone\n-        };\n-        debug!(\"cat_field ret {:?}\", ret);\n-        ret\n-    }\n-\n-    fn cat_overloaded_place(\n-        &self,\n-        expr: &hir::Expr,\n-        base: &hir::Expr,\n-        note: Note,\n-    ) -> McResult<cmt_<'tcx>> {\n-        debug!(\"cat_overloaded_place(expr={:?}, base={:?}, note={:?})\",\n-               expr,\n-               base,\n-               note);\n-\n-        // Reconstruct the output assuming it's a reference with the\n-        // same region and mutability as the receiver. This holds for\n-        // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n-        let place_ty = self.expr_ty(expr)?;\n-        let base_ty = self.expr_ty_adjusted(base)?;\n-\n-        let (region, mutbl) = match base_ty.kind {\n-            ty::Ref(region, _, mutbl) => (region, mutbl),\n-            _ => span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\")\n-        };\n-        let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut {\n-            ty: place_ty,\n-            mutbl,\n-        });\n-\n-        let base_cmt = Rc::new(self.cat_rvalue_node(expr.hir_id, expr.span, ref_ty));\n-        self.cat_deref(expr, base_cmt, note)\n-    }\n-\n-    pub fn cat_deref(\n-        &self,\n-        node: &impl HirNode,\n-        base_cmt: cmt<'tcx>,\n-        note: Note,\n-    ) -> McResult<cmt_<'tcx>> {\n-        debug!(\"cat_deref: base_cmt={:?}\", base_cmt);\n-\n-        let base_cmt_ty = base_cmt.ty;\n-        let deref_ty = match base_cmt_ty.builtin_deref(true) {\n-            Some(mt) => mt.ty,\n-            None => {\n-                debug!(\"explicit deref of non-derefable type: {:?}\", base_cmt_ty);\n-                return Err(());\n-            }\n-        };\n-\n-        let ptr = match base_cmt.ty.kind {\n-            ty::Adt(def, ..) if def.is_box() => Unique,\n-            ty::RawPtr(ref mt) => UnsafePtr(mt.mutbl),\n-            ty::Ref(r, _, mutbl) => {\n-                let bk = ty::BorrowKind::from_mutbl(mutbl);\n-                BorrowedPtr(bk, r)\n-            }\n-            _ => bug!(\"unexpected type in cat_deref: {:?}\", base_cmt.ty)\n-        };\n-        let ret = cmt_ {\n-            hir_id: node.hir_id(),\n-            span: node.span(),\n-            // For unique ptrs, we inherit mutability from the owning reference.\n-            mutbl: MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n-            cat: Categorization::Deref(base_cmt, ptr),\n-            ty: deref_ty,\n-            note: note,\n-        };\n-        debug!(\"cat_deref ret {:?}\", ret);\n-        Ok(ret)\n-    }\n-\n-    fn cat_index<N: HirNode>(&self,\n-                             elt: &N,\n-                             base_cmt: cmt<'tcx>,\n-                             element_ty: Ty<'tcx>,\n-                             context: InteriorOffsetKind)\n-                             -> McResult<cmt_<'tcx>> {\n-        //! Creates a cmt for an indexing operation (`[]`).\n-        //!\n-        //! One subtle aspect of indexing that may not be\n-        //! immediately obvious: for anything other than a fixed-length\n-        //! vector, an operation like `x[y]` actually consists of two\n-        //! disjoint (from the point of view of borrowck) operations.\n-        //! The first is a deref of `x` to create a pointer `p` that points\n-        //! at the first element in the array. The second operation is\n-        //! an index which adds `y*sizeof(T)` to `p` to obtain the\n-        //! pointer to `x[y]`. `cat_index` will produce a resulting\n-        //! cmt containing both this deref and the indexing,\n-        //! presuming that `base_cmt` is not of fixed-length type.\n-        //!\n-        //! # Parameters\n-        //! - `elt`: the HIR node being indexed\n-        //! - `base_cmt`: the cmt of `elt`\n-\n-        let interior_elem = InteriorElement(context);\n-        let ret = self.cat_imm_interior(elt, base_cmt, element_ty, interior_elem);\n-        debug!(\"cat_index ret {:?}\", ret);\n-        return Ok(ret);\n-    }\n-\n-    pub fn cat_imm_interior<N:HirNode>(&self,\n-                                       node: &N,\n-                                       base_cmt: cmt<'tcx>,\n-                                       interior_ty: Ty<'tcx>,\n-                                       interior: InteriorKind)\n-                                       -> cmt_<'tcx> {\n-        let ret = cmt_ {\n-            hir_id: node.hir_id(),\n-            span: node.span(),\n-            mutbl: base_cmt.mutbl.inherit(),\n-            cat: Categorization::Interior(base_cmt, interior),\n-            ty: interior_ty,\n-            note: NoteNone\n-        };\n-        debug!(\"cat_imm_interior ret={:?}\", ret);\n-        ret\n-    }\n-\n-    pub fn cat_downcast_if_needed<N:HirNode>(&self,\n-                                             node: &N,\n-                                             base_cmt: cmt<'tcx>,\n-                                             variant_did: DefId)\n-                                             -> cmt<'tcx> {\n-        // univariant enums do not need downcasts\n-        let base_did = self.tcx.parent(variant_did).unwrap();\n-        if self.tcx.adt_def(base_did).variants.len() != 1 {\n-            let base_ty = base_cmt.ty;\n-            let ret = Rc::new(cmt_ {\n-                hir_id: node.hir_id(),\n-                span: node.span(),\n-                mutbl: base_cmt.mutbl.inherit(),\n-                cat: Categorization::Downcast(base_cmt, variant_did),\n-                ty: base_ty,\n-                note: NoteNone\n-            });\n-            debug!(\"cat_downcast ret={:?}\", ret);\n-            ret\n-        } else {\n-            debug!(\"cat_downcast univariant={:?}\", base_cmt);\n-            base_cmt\n-        }\n-    }\n-\n-    pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n-        where F: FnMut(cmt<'tcx>, &hir::Pat),\n-    {\n-        self.cat_pattern_(cmt, pat, &mut op)\n-    }\n-\n-    // FIXME(#19596) This is a workaround, but there should be a better way to do this\n-    fn cat_pattern_<F>(&self, mut cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F) -> McResult<()>\n-        where F : FnMut(cmt<'tcx>, &hir::Pat)\n-    {\n-        // Here, `cmt` is the categorization for the value being\n-        // matched and pat is the pattern it is being matched against.\n-        //\n-        // In general, the way that this works is that we walk down\n-        // the pattern, constructing a cmt that represents the path\n-        // that will be taken to reach the value being matched.\n-        //\n-        // When we encounter named bindings, we take the cmt that has\n-        // been built up and pass it off to guarantee_valid() so that\n-        // we can be sure that the binding will remain valid for the\n-        // duration of the arm.\n-        //\n-        // (*2) There is subtlety concerning the correspondence between\n-        // pattern ids and types as compared to *expression* ids and\n-        // types. This is explained briefly. on the definition of the\n-        // type `cmt`, so go off and read what it says there, then\n-        // come back and I'll dive into a bit more detail here. :) OK,\n-        // back?\n-        //\n-        // In general, the id of the cmt should be the node that\n-        // \"produces\" the value---patterns aren't executable code\n-        // exactly, but I consider them to \"execute\" when they match a\n-        // value, and I consider them to produce the value that was\n-        // matched. So if you have something like:\n-        //\n-        // (FIXME: `@@3` is not legal code anymore!)\n-        //\n-        //     let x = @@3;\n-        //     match x {\n-        //       @@y { ... }\n-        //     }\n-        //\n-        // In this case, the cmt and the relevant ids would be:\n-        //\n-        //     CMT             Id                  Type of Id Type of cmt\n-        //\n-        //     local(x)->@->@\n-        //     ^~~~~~~^        `x` from discr      @@int      @@int\n-        //     ^~~~~~~~~~^     `@@y` pattern node  @@int      @int\n-        //     ^~~~~~~~~~~~~^  `@y` pattern node   @int       int\n-        //\n-        // You can see that the types of the id and the cmt are in\n-        // sync in the first line, because that id is actually the id\n-        // of an expression. But once we get to pattern ids, the types\n-        // step out of sync again. So you'll see below that we always\n-        // get the type of the *subpattern* and use that.\n-\n-        debug!(\"cat_pattern(pat={:?}, cmt={:?})\", pat, cmt);\n-\n-        // If (pattern) adjustments are active for this pattern, adjust the `cmt` correspondingly.\n-        // `cmt`s are constructed differently from patterns. For example, in\n-        //\n-        // ```\n-        // match foo {\n-        //     &&Some(x, ) => { ... },\n-        //     _ => { ... },\n-        // }\n-        // ```\n-        //\n-        // the pattern `&&Some(x,)` is represented as `Ref { Ref { TupleStruct }}`. To build the\n-        // corresponding `cmt` we start with a `cmt` for `foo`, and then, by traversing the\n-        // pattern, try to answer the question: given the address of `foo`, how is `x` reached?\n-        //\n-        // `&&Some(x,)` `cmt_foo`\n-        //  `&Some(x,)` `deref { cmt_foo}`\n-        //   `Some(x,)` `deref { deref { cmt_foo }}`\n-        //        (x,)` `field0 { deref { deref { cmt_foo }}}` <- resulting cmt\n-        //\n-        // The above example has no adjustments. If the code were instead the (after adjustments,\n-        // equivalent) version\n-        //\n-        // ```\n-        // match foo {\n-        //     Some(x, ) => { ... },\n-        //     _ => { ... },\n-        // }\n-        // ```\n-        //\n-        // Then we see that to get the same result, we must start with `deref { deref { cmt_foo }}`\n-        // instead of `cmt_foo` since the pattern is now `Some(x,)` and not `&&Some(x,)`, even\n-        // though its assigned type is that of `&&Some(x,)`.\n-        for _ in 0..self.tables\n-                        .pat_adjustments()\n-                        .get(pat.hir_id)\n-                        .map(|v| v.len())\n-                        .unwrap_or(0)\n-        {\n-            debug!(\"cat_pattern: applying adjustment to cmt={:?}\", cmt);\n-            cmt = Rc::new(self.cat_deref(pat, cmt, NoteNone)?);\n-        }\n-        let cmt = cmt; // lose mutability\n-        debug!(\"cat_pattern: applied adjustment derefs to get cmt={:?}\", cmt);\n-\n-        // Invoke the callback, but only now, after the `cmt` has adjusted.\n-        //\n-        // To see that this makes sense, consider `match &Some(3) { Some(x) => { ... }}`. In that\n-        // case, the initial `cmt` will be that for `&Some(3)` and the pattern is `Some(x)`. We\n-        // don't want to call `op` with these incompatible values. As written, what happens instead\n-        // is that `op` is called with the adjusted cmt (that for `*&Some(3)`) and the pattern\n-        // `Some(x)` (which matches). Recursing once more, `*&Some(3)` and the pattern `Some(x)`\n-        // result in the cmt `Downcast<Some>(*&Some(3)).0` associated to `x` and invoke `op` with\n-        // that (where the `ref` on `x` is implied).\n-        op(cmt.clone(), pat);\n-\n-        match pat.kind {\n-            PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-                let res = self.tables.qpath_res(qpath, pat.hir_id);\n-                let (cmt, expected_len) = match res {\n-                    Res::Err => {\n-                        debug!(\"access to unresolvable pattern {:?}\", pat);\n-                        return Err(())\n-                    }\n-                    Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), variant_ctor_did) => {\n-                        let variant_did = self.tcx.parent(variant_ctor_did).unwrap();\n-                        let enum_did = self.tcx.parent(variant_did).unwrap();\n-                        (self.cat_downcast_if_needed(pat, cmt, variant_did),\n-                         self.tcx.adt_def(enum_did)\n-                             .variant_with_ctor_id(variant_ctor_did).fields.len())\n-                    }\n-                    Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), _)\n-                    | Res::SelfCtor(..) => {\n-                        let ty = self.pat_ty_unadjusted(&pat)?;\n-                        match ty.kind {\n-                            ty::Adt(adt_def, _) => {\n-                                (cmt, adt_def.non_enum_variant().fields.len())\n-                            }\n-                            _ => {\n-                                span_bug!(pat.span,\n-                                          \"tuple struct pattern unexpected type {:?}\", ty);\n-                            }\n-                        }\n-                    }\n-                    def => {\n-                        debug!(\n-                            \"tuple struct pattern didn't resolve to variant or struct {:?} at {:?}\",\n-                            def,\n-                            pat.span,\n-                        );\n-                        self.tcx.sess.delay_span_bug(pat.span, &format!(\n-                            \"tuple struct pattern didn't resolve to variant or struct {:?}\",\n-                            def,\n-                        ));\n-                        return Err(());\n-                    }\n-                };\n-\n-                for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                    let subpat_ty = self.pat_ty_adjusted(&subpat)?; // see (*2)\n-                    let interior = InteriorField(FieldIndex(i, sym::integer(i)));\n-                    let subcmt = Rc::new(\n-                        self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n-                    self.cat_pattern_(subcmt, &subpat, op)?;\n-                }\n-            }\n-\n-            PatKind::Struct(ref qpath, ref field_pats, _) => {\n-                // {f1: p1, ..., fN: pN}\n-                let res = self.tables.qpath_res(qpath, pat.hir_id);\n-                let cmt = match res {\n-                    Res::Err => {\n-                        debug!(\"access to unresolvable pattern {:?}\", pat);\n-                        return Err(())\n-                    }\n-                    Res::Def(DefKind::Ctor(CtorOf::Variant, _), variant_ctor_did) => {\n-                        let variant_did = self.tcx.parent(variant_ctor_did).unwrap();\n-                        self.cat_downcast_if_needed(pat, cmt, variant_did)\n-                    }\n-                    Res::Def(DefKind::Variant, variant_did) => {\n-                        self.cat_downcast_if_needed(pat, cmt, variant_did)\n-                    }\n-                    _ => cmt,\n-                };\n-\n-                for fp in field_pats {\n-                    let field_ty = self.pat_ty_adjusted(&fp.pat)?; // see (*2)\n-                    let f_index = self.tcx.field_index(fp.hir_id, self.tables);\n-                    let cmt_field = Rc::new(self.cat_field(pat, cmt.clone(), f_index,\n-                                                           fp.ident, field_ty));\n-                    self.cat_pattern_(cmt_field, &fp.pat, op)?;\n-                }\n-            }\n-\n-            PatKind::Or(ref pats) => {\n-                for pat in pats {\n-                    self.cat_pattern_(cmt.clone(), &pat, op)?;\n-                }\n-            }\n-\n-            PatKind::Binding(.., Some(ref subpat)) => {\n-                self.cat_pattern_(cmt, &subpat, op)?;\n-            }\n-\n-            PatKind::Tuple(ref subpats, ddpos) => {\n-                // (p1, ..., pN)\n-                let ty = self.pat_ty_unadjusted(&pat)?;\n-                let expected_len = match ty.kind {\n-                    ty::Tuple(ref tys) => tys.len(),\n-                    _ => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n-                };\n-                for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                    let subpat_ty = self.pat_ty_adjusted(&subpat)?; // see (*2)\n-                    let interior = InteriorField(FieldIndex(i, sym::integer(i)));\n-                    let subcmt = Rc::new(\n-                        self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n-                    self.cat_pattern_(subcmt, &subpat, op)?;\n-                }\n-            }\n-\n-            PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n-                // box p1, &p1, &mut p1.  we can ignore the mutability of\n-                // PatKind::Ref since that information is already contained\n-                // in the type.\n-                let subcmt = Rc::new(self.cat_deref(pat, cmt, NoteNone)?);\n-                self.cat_pattern_(subcmt, &subpat, op)?;\n-            }\n-\n-            PatKind::Slice(ref before, ref slice, ref after) => {\n-                let element_ty = match cmt.ty.builtin_index() {\n-                    Some(ty) => ty,\n-                    None => {\n-                        debug!(\"explicit index of non-indexable type {:?}\", cmt);\n-                        return Err(());\n-                    }\n-                };\n-                let context = InteriorOffsetKind::Pattern;\n-                let elt_cmt = Rc::new(self.cat_index(pat, cmt, element_ty, context)?);\n-                for before_pat in before {\n-                    self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n-                }\n-                if let Some(ref slice_pat) = *slice {\n-                    self.cat_pattern_(elt_cmt.clone(), &slice_pat, op)?;\n-                }\n-                for after_pat in after {\n-                    self.cat_pattern_(elt_cmt.clone(), &after_pat, op)?;\n-                }\n-            }\n-\n-            PatKind::Path(_) | PatKind::Binding(.., None) |\n-            PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild => {\n-                // always ok\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub enum Aliasability {\n-    FreelyAliasable(AliasableReason),\n-    NonAliasable,\n-    ImmutableUnique(Box<Aliasability>),\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum AliasableReason {\n-    AliasableBorrowed,\n-    AliasableStatic,\n-    AliasableStaticMut,\n-}\n-\n-impl<'tcx> cmt_<'tcx> {\n-    pub fn guarantor(&self) -> cmt_<'tcx> {\n-        //! Returns `self` after stripping away any derefs or\n-        //! interior content. The return value is basically the `cmt` which\n-        //! determines how long the value in `self` remains live.\n-\n-        match self.cat {\n-            Categorization::Rvalue |\n-            Categorization::StaticItem |\n-            Categorization::ThreadLocal |\n-            Categorization::Local(..) |\n-            Categorization::Deref(_, UnsafePtr(..)) |\n-            Categorization::Deref(_, BorrowedPtr(..)) |\n-            Categorization::Upvar(..) => {\n-                (*self).clone()\n-            }\n-            Categorization::Downcast(ref b, _) |\n-            Categorization::Interior(ref b, _) |\n-            Categorization::Deref(ref b, Unique) => {\n-                b.guarantor()\n-            }\n-        }\n-    }\n-\n-    /// Returns `FreelyAliasable(_)` if this place represents a freely aliasable pointer type.\n-    pub fn freely_aliasable(&self) -> Aliasability {\n-        // Maybe non-obvious: copied upvars can only be considered\n-        // non-aliasable in once closures, since any other kind can be\n-        // aliased and eventually recused.\n-\n-        match self.cat {\n-            Categorization::Deref(ref b, BorrowedPtr(ty::MutBorrow, _)) |\n-            Categorization::Deref(ref b, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n-            Categorization::Deref(ref b, Unique) |\n-            Categorization::Downcast(ref b, _) |\n-            Categorization::Interior(ref b, _) => {\n-                // Aliasability depends on base cmt\n-                b.freely_aliasable()\n-            }\n-\n-            Categorization::Rvalue |\n-            Categorization::ThreadLocal |\n-            Categorization::Local(..) |\n-            Categorization::Upvar(..) |\n-            Categorization::Deref(_, UnsafePtr(..)) => { // yes, it's aliasable, but...\n-                NonAliasable\n-            }\n-\n-            Categorization::StaticItem => {\n-                if self.mutbl.is_mutable() {\n-                    FreelyAliasable(AliasableStaticMut)\n-                } else {\n-                    FreelyAliasable(AliasableStatic)\n-                }\n-            }\n-\n-            Categorization::Deref(_, BorrowedPtr(ty::ImmBorrow, _)) => {\n-                FreelyAliasable(AliasableBorrowed)\n-            }\n-        }\n-    }\n-\n-    // Digs down through one or two layers of deref and grabs the\n-    // Categorization of the cmt for the upvar if a note indicates there is\n-    // one.\n-    pub fn upvar_cat(&self) -> Option<&Categorization<'tcx>> {\n-        match self.note {\n-            NoteClosureEnv(..) | NoteUpvarRef(..) => {\n-                Some(match self.cat {\n-                    Categorization::Deref(ref inner, _) => {\n-                        match inner.cat {\n-                            Categorization::Deref(ref inner, _) => &inner.cat,\n-                            Categorization::Upvar(..) => &inner.cat,\n-                            _ => bug!()\n-                        }\n-                    }\n-                    _ => bug!()\n-                })\n-            }\n-            NoteIndex | NoteNone => None\n-        }\n-    }\n-\n-    pub fn descriptive_string(&self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n-        match self.cat {\n-            Categorization::StaticItem => {\n-                \"static item\".into()\n-            }\n-            Categorization::ThreadLocal => {\n-                \"thread-local static item\".into()\n-            }\n-            Categorization::Rvalue => {\n-                \"non-place\".into()\n-            }\n-            Categorization::Local(vid) => {\n-                if tcx.hir().is_argument(vid) {\n-                    \"argument\"\n-                } else {\n-                    \"local variable\"\n-                }.into()\n-            }\n-            Categorization::Deref(_, pk) => {\n-                match self.upvar_cat() {\n-                    Some(&Categorization::Upvar(ref var)) => {\n-                        var.to_string().into()\n-                    }\n-                    Some(_) => bug!(),\n-                    None => {\n-                        match pk {\n-                            Unique => {\n-                                \"`Box` content\"\n-                            }\n-                            UnsafePtr(..) => {\n-                                \"dereference of raw pointer\"\n-                            }\n-                            BorrowedPtr(..) => {\n-                                match self.note {\n-                                    NoteIndex => \"indexed content\",\n-                                    _ => \"borrowed content\"\n-                                }\n-                            }\n-                        }.into()\n-                    }\n-                }\n-            }\n-            Categorization::Interior(_, InteriorField(..)) => {\n-                \"field\".into()\n-            }\n-            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Index)) => {\n-                \"indexed content\".into()\n-            }\n-            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Pattern)) => {\n-                \"pattern-bound indexed content\".into()\n-            }\n-            Categorization::Upvar(ref var) => {\n-                var.to_string().into()\n-            }\n-            Categorization::Downcast(ref cmt, _) => {\n-                cmt.descriptive_string(tcx).into()\n-            }\n-        }\n-    }\n-}\n-\n-pub fn ptr_sigil(ptr: PointerKind<'_>) -> &'static str {\n-    match ptr {\n-        Unique => \"Box\",\n-        BorrowedPtr(ty::ImmBorrow, _) => \"&\",\n-        BorrowedPtr(ty::MutBorrow, _) => \"&mut\",\n-        BorrowedPtr(ty::UniqueImmBorrow, _) => \"&unique\",\n-        UnsafePtr(_) => \"*\",\n-    }\n-}\n-\n-impl fmt::Debug for InteriorKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            InteriorField(FieldIndex(_, info)) => write!(f, \"{}\", info),\n-            InteriorElement(..) => write!(f, \"[]\"),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for Upvar {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}/{:?}\", self.id, self.kind)\n-    }\n-}\n-\n-impl fmt::Display for Upvar {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let kind = match self.kind {\n-            ty::ClosureKind::Fn => \"Fn\",\n-            ty::ClosureKind::FnMut => \"FnMut\",\n-            ty::ClosureKind::FnOnce => \"FnOnce\",\n-        };\n-        write!(f, \"captured outer variable in an `{}` closure\", kind)\n-    }\n-}"}, {"sha": "54aafe2114dac04cef756414a9a55658d33cb608", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -13,11 +13,12 @@ use crate::ty::query::Providers;\n use crate::middle::privacy::AccessLevels;\n use crate::session::{DiagnosticMessageId, Session};\n use errors::DiagnosticBuilder;\n+use rustc_feature::GateIssue;\n use syntax::symbol::{Symbol, sym};\n use syntax_pos::{Span, MultiSpan};\n use syntax::ast::{Attribute, CRATE_NODE_ID};\n use syntax::errors::Applicability;\n-use syntax::feature_gate::{GateIssue, emit_feature_err};\n+use syntax::feature_gate::{feature_err, feature_err_issue};\n use syntax::attr::{self, Stability, Deprecation, RustcDeprecation};\n use crate::ty::{self, TyCtxt};\n use crate::util::nodemap::{FxHashSet, FxHashMap};\n@@ -512,9 +513,8 @@ pub fn report_unstable(\n         if is_soft {\n             soft_handler(lint::builtin::SOFT_UNSTABLE, span, &msg)\n         } else {\n-            emit_feature_err(\n-                &sess.parse_sess, feature, span, GateIssue::Library(issue), &msg\n-            );\n+            feature_err_issue(&sess.parse_sess, feature, span, GateIssue::Library(issue), &msg)\n+                .emit();\n         }\n     }\n }\n@@ -842,15 +842,19 @@ impl Visitor<'tcx> for Checker<'tcx> {\n                 let ty = self.tcx.type_of(def_id);\n \n                 if adt_def.has_dtor(self.tcx) {\n-                    emit_feature_err(&self.tcx.sess.parse_sess,\n-                                     sym::untagged_unions, item.span, GateIssue::Language,\n-                                     \"unions with `Drop` implementations are unstable\");\n+                    feature_err(\n+                        &self.tcx.sess.parse_sess, sym::untagged_unions, item.span,\n+                        \"unions with `Drop` implementations are unstable\"\n+                    )\n+                    .emit();\n                 } else {\n                     let param_env = self.tcx.param_env(def_id);\n                     if !param_env.can_type_implement_copy(self.tcx, ty).is_ok() {\n-                        emit_feature_err(&self.tcx.sess.parse_sess,\n-                                         sym::untagged_unions, item.span, GateIssue::Language,\n-                                         \"unions with non-`Copy` fields are unstable\");\n+                        feature_err(\n+                            &self.tcx.sess.parse_sess, sym::untagged_unions, item.span,\n+                            \"unions with non-`Copy` fields are unstable\"\n+                        )\n+                        .emit();\n                     }\n                 }\n             }"}, {"sha": "0704771f6ee95447abd31d18843b5a227f6e5aa2", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 239, "deletions": 23, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,16 +1,19 @@\n use rustc_index::vec::IndexVec;\n-use rustc_data_structures::sync::{RwLock, MappedReadGuard, ReadGuard};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n use crate::ich::StableHashingContext;\n-use crate::mir::{Body, BasicBlock};\n+use crate::mir::{BasicBlock, BasicBlockData, Body, LocalDecls, Location, Successors};\n+use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n+use rustc_data_structures::graph::dominators::{dominators, Dominators};\n+use std::iter;\n+use std::ops::{Deref, DerefMut, Index, IndexMut};\n+use std::vec::IntoIter;\n \n #[derive(Clone, Debug)]\n pub struct Cache {\n-    predecessors: RwLock<Option<IndexVec<BasicBlock, Vec<BasicBlock>>>>\n+    predecessors: Option<IndexVec<BasicBlock, Vec<BasicBlock>>>,\n }\n \n-\n impl rustc_serialize::Encodable for Cache {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         Encodable::encode(&(), s)\n@@ -31,39 +34,252 @@ impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n \n impl Cache {\n     pub fn new() -> Self {\n-        Cache {\n-            predecessors: RwLock::new(None)\n+        Self {\n+            predecessors: None,\n         }\n     }\n \n-    pub fn invalidate(&self) {\n+    pub fn invalidate_predecessors(&mut self) {\n         // FIXME: consider being more fine-grained\n-        *self.predecessors.borrow_mut() = None;\n+        self.predecessors = None;\n     }\n \n-    pub fn predecessors(\n-        &self,\n-        body: &Body<'_>\n-    ) -> MappedReadGuard<'_, IndexVec<BasicBlock, Vec<BasicBlock>>> {\n-        if self.predecessors.borrow().is_none() {\n-            *self.predecessors.borrow_mut() = Some(calculate_predecessors(body));\n+    pub fn ensure_predecessors(&mut self, body: &Body<'_>) {\n+        if self.predecessors.is_none() {\n+            let mut result = IndexVec::from_elem(vec![], body.basic_blocks());\n+            for (bb, data) in body.basic_blocks().iter_enumerated() {\n+                if let Some(ref term) = data.terminator {\n+                    for &tgt in term.successors() {\n+                        result[tgt].push(bb);\n+                    }\n+                }\n+            }\n+\n+            self.predecessors = Some(result)\n         }\n+    }\n+\n+    /// This will recompute the predecessors cache if it is not available\n+    fn predecessors(&mut self, body: &Body<'_>) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+        self.ensure_predecessors(body);\n+        self.predecessors.as_ref().unwrap()\n+    }\n+\n+    fn unwrap_predecessors_for(&self, bb: BasicBlock) -> &[BasicBlock] {\n+        &self.predecessors.as_ref().unwrap()[bb]\n+    }\n+\n+    fn unwrap_predecessor_locations<'a>(\n+        &'a self,\n+        loc: Location,\n+        body: &'a Body<'a>\n+    ) -> impl Iterator<Item = Location> + 'a {\n+        let if_zero_locations = if loc.statement_index == 0 {\n+            let predecessor_blocks = self.unwrap_predecessors_for(loc.block);\n+            let num_predecessor_blocks = predecessor_blocks.len();\n+            Some(\n+                (0..num_predecessor_blocks)\n+                    .map(move |i| predecessor_blocks[i])\n+                    .map(move |bb| body.terminator_loc(bb)),\n+            )\n+        } else {\n+            None\n+        };\n+\n+        let if_not_zero_locations = if loc.statement_index == 0 {\n+            None\n+        } else {\n+            Some(Location { block: loc.block, statement_index: loc.statement_index - 1 })\n+        };\n \n-        ReadGuard::map(self.predecessors.borrow(), |p| p.as_ref().unwrap())\n+        if_zero_locations.into_iter().flatten().chain(if_not_zero_locations)\n+    }\n+\n+    pub fn basic_blocks_mut<'a, 'tcx>(\n+        &mut self,\n+        body: &'a mut Body<'tcx>\n+    ) -> &'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        debug!(\"bbm: Clearing predecessors cache for body at: {:?}\", body.span.data());\n+        self.invalidate_predecessors();\n+        &mut body.basic_blocks\n+    }\n+\n+    pub fn basic_blocks_and_local_decls_mut<'a, 'tcx>(\n+        &mut self,\n+        body: &'a mut Body<'tcx>\n+    ) -> (&'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &'a mut LocalDecls<'tcx>) {\n+        debug!(\"bbaldm: Clearing predecessors cache for body at: {:?}\", body.span.data());\n+        self.invalidate_predecessors();\n+        (&mut body.basic_blocks, &mut body.local_decls)\n     }\n }\n \n-fn calculate_predecessors(body: &Body<'_>) -> IndexVec<BasicBlock, Vec<BasicBlock>> {\n-    let mut result = IndexVec::from_elem(vec![], body.basic_blocks());\n-    for (bb, data) in body.basic_blocks().iter_enumerated() {\n-        if let Some(ref term) = data.terminator {\n-            for &tgt in term.successors() {\n-                result[tgt].push(bb);\n-            }\n+#[derive(Clone, Debug, HashStable, RustcEncodable, RustcDecodable, TypeFoldable)]\n+pub struct BodyAndCache<'tcx> {\n+    body: Body<'tcx>,\n+    cache: Cache,\n+}\n+\n+impl BodyAndCache<'tcx> {\n+    pub fn new(body: Body<'tcx>) -> Self {\n+        Self {\n+            body,\n+            cache: Cache::new(),\n+        }\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! read_only {\n+    ($body:expr) => {\n+        {\n+            $body.ensure_predecessors();\n+            $body.unwrap_read_only()\n+        }\n+    };\n+}\n+\n+impl BodyAndCache<'tcx> {\n+    pub fn ensure_predecessors(&mut self) {\n+        self.cache.ensure_predecessors(&self.body);\n+    }\n+\n+    pub fn predecessors(&mut self) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+        self.cache.predecessors(&self.body)\n+    }\n+\n+    pub fn unwrap_read_only(&self) -> ReadOnlyBodyAndCache<'_, 'tcx> {\n+        ReadOnlyBodyAndCache::new(&self.body, &self.cache)\n+    }\n+\n+    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        self.cache.basic_blocks_mut(&mut self.body)\n+    }\n+\n+    pub fn basic_blocks_and_local_decls_mut(\n+        &mut self\n+    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n+        self.cache.basic_blocks_and_local_decls_mut(&mut self.body)\n+    }\n+}\n+\n+impl<'tcx> Index<BasicBlock> for BodyAndCache<'tcx> {\n+    type Output = BasicBlockData<'tcx>;\n+\n+    fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n+        &self.body[index]\n+    }\n+}\n+\n+impl<'tcx> IndexMut<BasicBlock> for BodyAndCache<'tcx> {\n+    fn index_mut(&mut self, index: BasicBlock) -> &mut Self::Output {\n+        &mut self.basic_blocks_mut()[index]\n+    }\n+}\n+\n+impl<'tcx> Deref for BodyAndCache<'tcx> {\n+    type Target = Body<'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.body\n+    }\n+}\n+\n+impl<'tcx> DerefMut for BodyAndCache<'tcx> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.body\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct ReadOnlyBodyAndCache<'a, 'tcx> {\n+    body: &'a Body<'tcx>,\n+    cache: &'a Cache,\n+}\n+\n+impl ReadOnlyBodyAndCache<'a, 'tcx> {\n+    fn new(body: &'a Body<'tcx>, cache: &'a Cache) -> Self {\n+        assert!(\n+            cache.predecessors.is_some(),\n+            \"Cannot construct ReadOnlyBodyAndCache without computed predecessors\");\n+        Self {\n+            body,\n+            cache,\n         }\n     }\n \n-    result\n+    pub fn predecessors(&self) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+        self.cache.predecessors.as_ref().unwrap()\n+    }\n+\n+    pub fn predecessors_for(&self, bb: BasicBlock) -> &[BasicBlock] {\n+        self.cache.unwrap_predecessors_for(bb)\n+    }\n+\n+    pub fn predecessor_locations(&self, loc: Location) -> impl Iterator<Item = Location> + '_ {\n+        self.cache.unwrap_predecessor_locations(loc, self.body)\n+    }\n+\n+    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        &self.body.basic_blocks\n+    }\n+\n+    pub fn dominators(&self) -> Dominators<BasicBlock> {\n+        dominators(self)\n+    }\n+}\n+\n+impl graph::DirectedGraph for ReadOnlyBodyAndCache<'a, 'tcx> {\n+    type Node = BasicBlock;\n+}\n+\n+impl graph::GraphPredecessors<'graph> for ReadOnlyBodyAndCache<'a, 'tcx> {\n+    type Item = BasicBlock;\n+    type Iter = IntoIter<BasicBlock>;\n+}\n+\n+impl graph::WithPredecessors for ReadOnlyBodyAndCache<'a, 'tcx> {\n+    fn predecessors(\n+        &self,\n+        node: Self::Node,\n+    ) -> <Self as GraphPredecessors<'_>>::Iter {\n+        self.cache.unwrap_predecessors_for(node).to_vec().into_iter()\n+    }\n+}\n+\n+impl graph::WithNumNodes for ReadOnlyBodyAndCache<'a, 'tcx> {\n+    fn num_nodes(&self) -> usize {\n+        self.body.num_nodes()\n+    }\n+}\n+\n+impl graph::WithStartNode for ReadOnlyBodyAndCache<'a, 'tcx> {\n+    fn start_node(&self) -> Self::Node {\n+        self.body.start_node()\n+    }\n+}\n+\n+impl graph::WithSuccessors for ReadOnlyBodyAndCache<'a, 'tcx> {\n+    fn successors(\n+        &self,\n+        node: Self::Node,\n+    ) -> <Self as GraphSuccessors<'_>>::Iter {\n+        self.body.successors(node)\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> graph::GraphSuccessors<'b> for ReadOnlyBodyAndCache<'a, 'tcx> {\n+    type Item = BasicBlock;\n+    type Iter = iter::Cloned<Successors<'b>>;\n+}\n+\n+\n+impl Deref for ReadOnlyBodyAndCache<'a, 'tcx> {\n+    type Target = &'a Body<'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.body\n+    }\n }\n \n CloneTypeFoldableAndLiftImpls! {"}, {"sha": "0dec7c071bfeee860a176578dd964ea336c09143", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -13,8 +13,8 @@ use rustc_macros::HashStable;\n use rustc_target::spec::abi::Abi;\n use syntax_pos::{Pos, Span};\n use syntax::symbol::Symbol;\n-\n-use std::{fmt, env};\n+use hir::GeneratorKind;\n+use std::{fmt, env, any::Any};\n \n use rustc_error_codes::*;\n \n@@ -44,14 +44,14 @@ CloneTypeFoldableImpls! {\n pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug)]\n pub struct ConstEvalErr<'tcx> {\n     pub span: Span,\n     pub error: crate::mir::interpret::InterpError<'tcx>,\n     pub stacktrace: Vec<FrameInfo<'tcx>>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Debug)]\n pub struct FrameInfo<'tcx> {\n     /// This span is in the caller.\n     pub call_site: Span,\n@@ -138,6 +138,7 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         lint_root: Option<hir::HirId>,\n     ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n         let must_error = match self.error {\n+            InterpError::MachineStop(_) => bug!(\"CTFE does not stop\"),\n             err_inval!(Layout(LayoutError::Unknown(_))) |\n             err_inval!(TooGeneric) =>\n                 return Err(ErrorHandled::TooGeneric),\n@@ -185,11 +186,11 @@ pub fn struct_error<'tcx>(tcx: TyCtxtAt<'tcx>, msg: &str) -> DiagnosticBuilder<'\n }\n \n /// Packages the kind of error we got from the const code interpreter\n-/// up with a Rust-level backtrace of where the error occured.\n+/// up with a Rust-level backtrace of where the error occurred.\n /// Thsese should always be constructed by calling `.into()` on\n /// a `InterpError`. In `librustc_mir::interpret`, we have `throw_err_*`\n /// macros for this.\n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub struct InterpErrorInfo<'tcx> {\n     pub kind: InterpError<'tcx>,\n     backtrace: Option<Box<Backtrace>>,\n@@ -264,8 +265,8 @@ pub enum PanicInfo<O> {\n     OverflowNeg,\n     DivisionByZero,\n     RemainderByZero,\n-    GeneratorResumedAfterReturn,\n-    GeneratorResumedAfterPanic,\n+    ResumedAfterReturn(GeneratorKind),\n+    ResumedAfterPanic(GeneratorKind),\n }\n \n /// Type for MIR `Assert` terminator error messages.\n@@ -300,10 +301,14 @@ impl<O> PanicInfo<O> {\n                 \"attempt to divide by zero\",\n             RemainderByZero =>\n                 \"attempt to calculate the remainder with a divisor of zero\",\n-            GeneratorResumedAfterReturn =>\n+            ResumedAfterReturn(GeneratorKind::Gen) =>\n                 \"generator resumed after completion\",\n-            GeneratorResumedAfterPanic =>\n+            ResumedAfterReturn(GeneratorKind::Async(_)) =>\n+                \"`async fn` resumed after completion\",\n+            ResumedAfterPanic(GeneratorKind::Gen) =>\n                 \"generator resumed after panicking\",\n+            ResumedAfterPanic(GeneratorKind::Async(_)) =>\n+                \"`async fn` resumed after panicking\",\n             Panic { .. } | BoundsCheck { .. } =>\n                 bug!(\"Unexpected PanicInfo\"),\n         }\n@@ -327,7 +332,6 @@ impl<O: fmt::Debug> fmt::Debug for PanicInfo<O> {\n /// Error information for when the program we executed turned out not to actually be a valid\n /// program. This cannot happen in stand-alone Miri, but it can happen during CTFE/ConstProp\n /// where we work on generic code or execution does not have all information available.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum InvalidProgramInfo<'tcx> {\n     /// Resolution can fail if we are in a too generic context.\n     TooGeneric,\n@@ -357,7 +361,6 @@ impl fmt::Debug for InvalidProgramInfo<'tcx> {\n }\n \n /// Error information for when the program caused Undefined Behavior.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UndefinedBehaviorInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Ub(String),\n@@ -367,6 +370,14 @@ pub enum UndefinedBehaviorInfo {\n     Unreachable,\n     /// An enum discriminant was set to a value which was outside the range of valid values.\n     InvalidDiscriminant(ScalarMaybeUndef),\n+    /// A slice/array index projection went out-of-bounds.\n+    BoundsCheckFailed { len: u64, index: u64 },\n+    /// Something was divided by 0 (x / 0).\n+    DivisionByZero,\n+    /// Something was \"remainded\" by 0 (x % 0).\n+    RemainderByZero,\n+    /// Overflowing inbounds pointer arithmetic.\n+    PointerArithOverflow,\n }\n \n impl fmt::Debug for UndefinedBehaviorInfo {\n@@ -376,9 +387,18 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n             Ub(msg) | UbExperimental(msg) =>\n                 write!(f, \"{}\", msg),\n             Unreachable =>\n-                write!(f, \"entered unreachable code\"),\n+                write!(f, \"entering unreachable code\"),\n             InvalidDiscriminant(val) =>\n-                write!(f, \"encountered invalid enum discriminant {}\", val),\n+                write!(f, \"encountering invalid enum discriminant {}\", val),\n+            BoundsCheckFailed { ref len, ref index } =>\n+                write!(f, \"indexing out of bounds: the len is {:?} but the index is {:?}\",\n+                    len, index),\n+            DivisionByZero =>\n+                write!(f, \"dividing by zero\"),\n+            RemainderByZero =>\n+                write!(f, \"calculating the remainder with a divisor of zero\"),\n+            PointerArithOverflow =>\n+                write!(f, \"overflowing in-bounds pointer arithmetic\"),\n         }\n     }\n }\n@@ -390,11 +410,14 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n ///\n /// Currently, we also use this as fall-back error kind for errors that have not been\n /// categorized yet.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsupportedOpInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n \n+    /// When const-prop encounters a situation it does not support, it raises this error.\n+    /// This must not allocate for performance reasons.\n+    ConstPropUnsupported(&'tcx str),\n+\n     // -- Everything below is not categorized yet --\n     FunctionAbiMismatch(Abi, Abi),\n     FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n@@ -555,13 +578,14 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n                     not a power of two\"),\n             Unsupported(ref msg) =>\n                 write!(f, \"{}\", msg),\n+            ConstPropUnsupported(ref msg) =>\n+                write!(f, \"Constant propagation encountered an unsupported situation: {}\", msg),\n         }\n     }\n }\n \n /// Error information for when the program exhausted the resources granted to it\n /// by the interpreter.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ResourceExhaustionInfo {\n     /// The stack grew too big.\n     StackFrameLimitReached,\n@@ -582,7 +606,6 @@ impl fmt::Debug for ResourceExhaustionInfo {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum InterpError<'tcx> {\n     /// The program panicked.\n     Panic(PanicInfo<u64>),\n@@ -591,14 +614,14 @@ pub enum InterpError<'tcx> {\n     /// The program did something the interpreter does not support (some of these *might* be UB\n     /// but the interpreter is not sure).\n     Unsupported(UnsupportedOpInfo<'tcx>),\n-    /// The program was invalid (ill-typed, not sufficiently monomorphized, ...).\n+    /// The program was invalid (ill-typed, bad MIR, not sufficiently monomorphized, ...).\n     InvalidProgram(InvalidProgramInfo<'tcx>),\n     /// The program exhausted the interpreter's resources (stack/heap too big,\n-    /// execution takes too long, ..).\n+    /// execution takes too long, ...).\n     ResourceExhaustion(ResourceExhaustionInfo),\n-    /// Not actually an interpreter error -- used to signal that execution has exited\n-    /// with the given status code.  Used by Miri, but not by CTFE.\n-    Exit(i32),\n+    /// Stop execution for a machine-controlled reason. This is never raised by\n+    /// the core engine itself.\n+    MachineStop(Box<dyn Any + Send>),\n }\n \n pub type InterpResult<'tcx, T = ()> = Result<T, InterpErrorInfo<'tcx>>;\n@@ -624,8 +647,8 @@ impl fmt::Debug for InterpError<'_> {\n                 write!(f, \"{:?}\", msg),\n             Panic(ref msg) =>\n                 write!(f, \"{:?}\", msg),\n-            Exit(code) =>\n-                write!(f, \"exited with status code {}\", code),\n+            MachineStop(_) =>\n+                write!(f, \"machine caused execution to stop\"),\n         }\n     }\n }"}, {"sha": "fff876752db55ab971a45126f726f5a81742f092", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -90,6 +90,13 @@ macro_rules! throw_exhaust {\n     ($($tt:tt)*) => { return Err(err_exhaust!($($tt)*).into()) };\n }\n \n+#[macro_export]\n+macro_rules! throw_machine_stop {\n+    ($($tt:tt)*) => {\n+        return Err($crate::mir::interpret::InterpError::MachineStop(Box::new($($tt)*)).into())\n+    };\n+}\n+\n mod error;\n mod value;\n mod allocation;\n@@ -123,7 +130,10 @@ use rustc_data_structures::tiny_list::TinyList;\n use rustc_macros::HashStable;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n \n-/// Uniquely identifies a specific constant or static.\n+/// Uniquely identifies one of the following:\n+/// - A constant\n+/// - A static\n+/// - A const fn where all arguments (if any) are zero-sized types\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, Lift)]\n pub struct GlobalId<'tcx> {"}, {"sha": "0b27f512e55b8c44b36d4f9d64837fe1ef5ee314", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,6 +1,5 @@\n use super::{AllocId, InterpResult};\n \n-use crate::mir;\n use crate::ty::layout::{self, HasDataLayout, Size};\n \n use rustc_macros::HashStable;\n@@ -88,13 +87,13 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     #[inline]\n     fn offset<'tcx>(&self, val: u64, i: u64) -> InterpResult<'tcx, u64> {\n         let (res, over) = self.overflowing_offset(val, i);\n-        if over { throw_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+        if over { throw_ub!(PointerArithOverflow) } else { Ok(res) }\n     }\n \n     #[inline]\n     fn signed_offset<'tcx>(&self, val: u64, i: i64) -> InterpResult<'tcx, u64> {\n         let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n-        if over { throw_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+        if over { throw_ub!(PointerArithOverflow) } else { Ok(res) }\n     }\n }\n "}, {"sha": "a038ca23ae92d6e1939d420cb937fec91148cf7b", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -458,7 +458,7 @@ impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n     }\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, Eq, PartialEq, RustcEncodable, RustcDecodable, HashStable, Hash)]\n pub enum ScalarMaybeUndef<Tag = (), Id = AllocId> {\n     Scalar(Scalar<Tag, Id>),\n     Undef,\n@@ -471,6 +471,13 @@ impl<Tag> From<Scalar<Tag>> for ScalarMaybeUndef<Tag> {\n     }\n }\n \n+impl<Tag> From<Pointer<Tag>> for ScalarMaybeUndef<Tag> {\n+    #[inline(always)]\n+    fn from(s: Pointer<Tag>) -> Self {\n+        ScalarMaybeUndef::Scalar(s.into())\n+    }\n+}\n+\n impl<Tag: fmt::Debug, Id: fmt::Debug> fmt::Debug for ScalarMaybeUndef<Tag, Id> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {"}, {"sha": "a7f5a2269251530c93cccdb2310c4b26e76d9ae2", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 76, "deletions": 153, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -6,7 +6,7 @@\n \n use crate::hir::def::{CtorKind, Namespace};\n use crate::hir::def_id::DefId;\n-use crate::hir;\n+use crate::hir::{self, GeneratorKind};\n use crate::mir::interpret::{GlobalAlloc, PanicInfo, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n@@ -21,25 +21,25 @@ use crate::ty::{\n use polonius_engine::Atom;\n use rustc_index::bit_set::BitMatrix;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::graph::dominators::{dominators, Dominators};\n-use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n+use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_data_structures::graph::{self, GraphSuccessors};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::sync::MappedReadGuard;\n use rustc_macros::HashStable;\n use rustc_serialize::{Encodable, Decodable};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n-use std::ops::{Index, IndexMut};\n+use std::ops::Index;\n use std::slice;\n-use std::vec::IntoIter;\n use std::{iter, mem, option, u32};\n use syntax::ast::Name;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use crate::mir::interpret::AssertMessage;\n+pub use crate::mir::cache::{BodyAndCache, ReadOnlyBodyAndCache};\n+pub use crate::read_only;\n \n mod cache;\n pub mod interpret;\n@@ -104,19 +104,19 @@ pub struct Body<'tcx> {\n     /// and used for debuginfo. Indexed by a `SourceScope`.\n     pub source_scopes: IndexVec<SourceScope, SourceScopeData>,\n \n-    /// Crate-local information for each source scope, that can't (and\n-    /// needn't) be tracked across crates.\n-    pub source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n-\n     /// The yield type of the function, if it is a generator.\n     pub yield_ty: Option<Ty<'tcx>>,\n \n     /// Generator drop glue.\n-    pub generator_drop: Option<Box<Body<'tcx>>>,\n+    pub generator_drop: Option<Box<BodyAndCache<'tcx>>>,\n \n     /// The layout of a generator. Produced by the state transformation.\n     pub generator_layout: Option<GeneratorLayout<'tcx>>,\n \n+    /// If this is a generator then record the type of source expression that caused this generator\n+    /// to be created.\n+    pub generator_kind: Option<GeneratorKind>,\n+\n     /// Declarations of locals.\n     ///\n     /// The first local is the return value pointer, followed by `arg_count`\n@@ -141,14 +141,8 @@ pub struct Body<'tcx> {\n     /// This is used for the \"rust-call\" ABI.\n     pub spread_arg: Option<Local>,\n \n-    /// Names and capture modes of all the closure upvars, assuming\n-    /// the first argument is either the closure or a reference to it.\n-    //\n-    // NOTE(eddyb) This is *strictly* a temporary hack for codegen\n-    // debuginfo generation, and will be removed at some point.\n-    // Do **NOT** use it for anything else; upvar information should not be\n-    // in the MIR, so please rely on local crate HIR or other side-channels.\n-    pub __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n+    /// Debug information pertaining to user variables, including captures.\n+    pub var_debug_info: Vec<VarDebugInfo<'tcx>>,\n \n     /// Mark this MIR of a const context other than const functions as having converted a `&&` or\n     /// `||` expression into `&` or `|` respectively. This is problematic because if we ever stop\n@@ -160,23 +154,19 @@ pub struct Body<'tcx> {\n \n     /// A span representing this MIR, for error reporting.\n     pub span: Span,\n-\n-    /// A cache for various calculations.\n-    cache: cache::Cache,\n }\n \n impl<'tcx> Body<'tcx> {\n     pub fn new(\n         basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n         source_scopes: IndexVec<SourceScope, SourceScopeData>,\n-        source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n-        yield_ty: Option<Ty<'tcx>>,\n         local_decls: LocalDecls<'tcx>,\n         user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n         arg_count: usize,\n-        __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n+        var_debug_info: Vec<VarDebugInfo<'tcx>>,\n         span: Span,\n         control_flow_destroyed: Vec<(Span, String)>,\n+        generator_kind : Option<GeneratorKind>,\n     ) -> Self {\n         // We need `arg_count` locals, and one for the return place.\n         assert!(\n@@ -190,17 +180,16 @@ impl<'tcx> Body<'tcx> {\n             phase: MirPhase::Build,\n             basic_blocks,\n             source_scopes,\n-            source_scope_local_data,\n-            yield_ty,\n+            yield_ty: None,\n             generator_drop: None,\n             generator_layout: None,\n+            generator_kind,\n             local_decls,\n             user_type_annotations,\n             arg_count,\n-            __upvar_debuginfo_codegen_only_do_not_use,\n             spread_arg: None,\n+            var_debug_info,\n             span,\n-            cache: cache::Cache::new(),\n             control_flow_destroyed,\n         }\n     }\n@@ -210,58 +199,6 @@ impl<'tcx> Body<'tcx> {\n         &self.basic_blocks\n     }\n \n-    #[inline]\n-    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        self.cache.invalidate();\n-        &mut self.basic_blocks\n-    }\n-\n-    #[inline]\n-    pub fn basic_blocks_and_local_decls_mut(\n-        &mut self,\n-    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n-        self.cache.invalidate();\n-        (&mut self.basic_blocks, &mut self.local_decls)\n-    }\n-\n-    #[inline]\n-    pub fn predecessors(&self) -> MappedReadGuard<'_, IndexVec<BasicBlock, Vec<BasicBlock>>> {\n-        self.cache.predecessors(self)\n-    }\n-\n-    #[inline]\n-    pub fn predecessors_for(&self, bb: BasicBlock) -> MappedReadGuard<'_, Vec<BasicBlock>> {\n-        MappedReadGuard::map(self.predecessors(), |p| &p[bb])\n-    }\n-\n-    #[inline]\n-    pub fn predecessor_locations(&self, loc: Location) -> impl Iterator<Item = Location> + '_ {\n-        let if_zero_locations = if loc.statement_index == 0 {\n-            let predecessor_blocks = self.predecessors_for(loc.block);\n-            let num_predecessor_blocks = predecessor_blocks.len();\n-            Some(\n-                (0..num_predecessor_blocks)\n-                    .map(move |i| predecessor_blocks[i])\n-                    .map(move |bb| self.terminator_loc(bb)),\n-            )\n-        } else {\n-            None\n-        };\n-\n-        let if_not_zero_locations = if loc.statement_index == 0 {\n-            None\n-        } else {\n-            Some(Location { block: loc.block, statement_index: loc.statement_index - 1 })\n-        };\n-\n-        if_zero_locations.into_iter().flatten().chain(if_not_zero_locations)\n-    }\n-\n-    #[inline]\n-    pub fn dominators(&self) -> Dominators<BasicBlock> {\n-        dominators(self)\n-    }\n-\n     /// Returns `true` if a cycle exists in the control-flow graph that is reachable from the\n     /// `START_BLOCK`.\n     pub fn is_cfg_cyclic(&self) -> bool {\n@@ -280,7 +217,7 @@ impl<'tcx> Body<'tcx> {\n             LocalKind::ReturnPointer\n         } else if index < self.arg_count + 1 {\n             LocalKind::Arg\n-        } else if self.local_decls[local].name.is_some() {\n+        } else if self.local_decls[local].is_user_variable() {\n             LocalKind::Var\n         } else {\n             LocalKind::Temp\n@@ -305,11 +242,7 @@ impl<'tcx> Body<'tcx> {\n     pub fn vars_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n         (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n-            if self.local_decls[local].is_user_variable() {\n-                Some(local)\n-            } else {\n-                None\n-            }\n+            self.local_decls[local].is_user_variable().then_some(local)\n         })\n     }\n \n@@ -362,7 +295,7 @@ impl<'tcx> Body<'tcx> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n     /// invalidating statement indices in `Location`s.\n     pub fn make_statement_nop(&mut self, location: Location) {\n-        let block = &mut self[location.block];\n+        let block = &mut self.basic_blocks[location.block];\n         debug_assert!(location.statement_index < block.statements.len());\n         block.statements[location.statement_index].make_nop()\n     }\n@@ -422,20 +355,20 @@ impl<'tcx> Index<BasicBlock> for Body<'tcx> {\n     }\n }\n \n-impl<'tcx> IndexMut<BasicBlock> for Body<'tcx> {\n-    #[inline]\n-    fn index_mut(&mut self, index: BasicBlock) -> &mut BasicBlockData<'tcx> {\n-        &mut self.basic_blocks_mut()[index]\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable)]\n pub enum ClearCrossCrate<T> {\n     Clear,\n     Set(T),\n }\n \n impl<T> ClearCrossCrate<T> {\n+    pub fn as_ref(&'a self) -> ClearCrossCrate<&'a T> {\n+        match self {\n+            ClearCrossCrate::Clear => ClearCrossCrate::Clear,\n+            ClearCrossCrate::Set(v) => ClearCrossCrate::Set(v),\n+        }\n+    }\n+\n     pub fn assert_crate_local(self) -> T {\n         match self {\n             ClearCrossCrate::Clear => bug!(\"unwrapping cross-crate data\"),\n@@ -450,7 +383,7 @@ impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<\n /// Grouped information about the source code origin of a MIR entity.\n /// Intended to be inspected by diagnostics and debuginfo.\n /// Most passes can work with it as a whole, within a single function.\n-// The unoffical Cranelift backend, at least as of #65828, needs `SourceInfo` to implement `Eq` and\n+// The unofficial Cranelift backend, at least as of #65828, needs `SourceInfo` to implement `Eq` and\n // `Hash`. Please ping @bjorn3 if removing them.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub struct SourceInfo {\n@@ -728,12 +661,6 @@ pub struct LocalDecl<'tcx> {\n     // FIXME(matthewjasper) Don't store in this in `Body`\n     pub user_ty: UserTypeProjections,\n \n-    /// The name of the local, used in debuginfo and pretty-printing.\n-    ///\n-    /// Note that function arguments can also have this set to `Some(_)`\n-    /// to generate better debuginfo.\n-    pub name: Option<Name>,\n-\n     /// The *syntactic* (i.e., not visibility) source scope the local is defined\n     /// in. If the local was defined in a let-statement, this\n     /// is *within* the let-statement, rather than outside\n@@ -785,9 +712,9 @@ pub struct LocalDecl<'tcx> {\n     /// `drop(x)`, we want it to refer to `x: u32`.\n     ///\n     /// To allow both uses to work, we need to have more than a single scope\n-    /// for a local. We have the `source_info.scope` represent the\n-    /// \"syntactic\" lint scope (with a variable being under its let\n-    /// block) while the `visibility_scope` represents the \"local variable\"\n+    /// for a local. We have the `source_info.scope` represent the \"syntactic\"\n+    /// lint scope (with a variable being under its let block) while the\n+    /// `var_debug_info.source_info.scope` represents the \"local variable\"\n     /// scope (where the \"rest\" of a block is under all prior let-statements).\n     ///\n     /// The end result looks like this:\n@@ -806,18 +733,14 @@ pub struct LocalDecl<'tcx> {\n     ///  \u2502 \u2502\n     ///  \u2502 \u2502 \u2502{ let y: u32 }\n     ///  \u2502 \u2502 \u2502\n-    ///  \u2502 \u2502 \u2502\u2190 y.visibility_scope\n+    ///  \u2502 \u2502 \u2502\u2190 y.var_debug_info.source_info.scope\n     ///  \u2502 \u2502 \u2502\u2190 `y + 2`\n     ///  \u2502\n     ///  \u2502 \u2502{ let x: u32 }\n-    ///  \u2502 \u2502\u2190 x.visibility_scope\n+    ///  \u2502 \u2502\u2190 x.var_debug_info.source_info.scope\n     ///  \u2502 \u2502\u2190 `drop(x)` // This accesses `x: u32`.\n     /// ```\n     pub source_info: SourceInfo,\n-\n-    /// Source scope within which the local is visible (for debuginfo)\n-    /// (see `source_info` for more details).\n-    pub visibility_scope: SourceScope,\n }\n \n /// Extra information about a local that's used for diagnostics.\n@@ -955,9 +878,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             mutability,\n             ty,\n             user_ty: UserTypeProjections::none(),\n-            name: None,\n             source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n-            visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal,\n             local_info: LocalInfo::Other,\n             is_block_tail: None,\n@@ -974,22 +895,27 @@ impl<'tcx> LocalDecl<'tcx> {\n             ty: return_ty,\n             user_ty: UserTypeProjections::none(),\n             source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n-            visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: false,\n             is_block_tail: None,\n-            name: None, // FIXME maybe we do want some name here?\n             local_info: LocalInfo::Other,\n         }\n     }\n }\n \n-/// A closure capture, with its name and mode.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct UpvarDebuginfo {\n-    pub debug_name: Name,\n+/// Debug information pertaining to a user variable.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VarDebugInfo<'tcx> {\n+    pub name: Name,\n \n-    /// If true, the capture is behind a reference.\n-    pub by_ref: bool,\n+    /// Source info of the user variable, including the scope\n+    /// within which the variable is visible (to debuginfo)\n+    /// (see `LocalDecl`'s `source_info` field for more details).\n+    pub source_info: SourceInfo,\n+\n+    /// Where the data for this user variable is to be found.\n+    /// NOTE(eddyb) There's an unenforced invariant that this `Place` is\n+    /// based on a `Local`, not a `Static`, and contains no indexing.\n+    pub place: Place<'tcx>,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -2035,6 +1961,10 @@ rustc_index::newtype_index! {\n pub struct SourceScopeData {\n     pub span: Span,\n     pub parent_scope: Option<SourceScope>,\n+\n+    /// Crate-local information for this source scope, that can't (and\n+    /// needn't) be tracked across crates.\n+    pub local_data: ClearCrossCrate<SourceScopeLocalData>,\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n@@ -2316,10 +2246,14 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         }\n                     }\n \n-                    AggregateKind::Closure(def_id, _) => ty::tls::with(|tcx| {\n+                    AggregateKind::Closure(def_id, substs) => ty::tls::with(|tcx| {\n                         if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n-                                format!(\"[closure@{:?}]\", hir_id)\n+                                let substs = tcx.lift(&substs).unwrap();\n+                                format!(\n+                                    \"[closure@{}]\",\n+                                    tcx.def_path_str_with_substs(def_id, substs),\n+                                )\n                             } else {\n                                 format!(\"[closure@{:?}]\", tcx.hir().span(hir_id))\n                             };\n@@ -2617,15 +2551,6 @@ impl<'tcx> graph::WithStartNode for Body<'tcx> {\n     }\n }\n \n-impl<'tcx> graph::WithPredecessors for Body<'tcx> {\n-    fn predecessors(\n-        &self,\n-        node: Self::Node,\n-    ) -> <Self as GraphPredecessors<'_>>::Iter {\n-        self.predecessors_for(node).clone().into_iter()\n-    }\n-}\n-\n impl<'tcx> graph::WithSuccessors for Body<'tcx> {\n     fn successors(\n         &self,\n@@ -2635,11 +2560,6 @@ impl<'tcx> graph::WithSuccessors for Body<'tcx> {\n     }\n }\n \n-impl<'a, 'b> graph::GraphPredecessors<'b> for Body<'a> {\n-    type Item = BasicBlock;\n-    type Iter = IntoIter<BasicBlock>;\n-}\n-\n impl<'a, 'b> graph::GraphSuccessors<'b> for Body<'a> {\n     type Item = BasicBlock;\n     type Iter = iter::Cloned<Successors<'b>>;\n@@ -2674,21 +2594,25 @@ impl Location {\n     }\n \n     /// Returns `true` if `other` is earlier in the control flow graph than `self`.\n-    pub fn is_predecessor_of<'tcx>(&self, other: Location, body: &Body<'tcx>) -> bool {\n+    pub fn is_predecessor_of<'tcx>(\n+        &self,\n+        other: Location,\n+        body: ReadOnlyBodyAndCache<'_, 'tcx>\n+    ) -> bool {\n         // If we are in the same block as the other location and are an earlier statement\n         // then we are a predecessor of `other`.\n         if self.block == other.block && self.statement_index < other.statement_index {\n             return true;\n         }\n \n         // If we're in another block, then we want to check that block is a predecessor of `other`.\n-        let mut queue: Vec<BasicBlock> = body.predecessors_for(other.block).clone();\n+        let mut queue: Vec<BasicBlock> = body.predecessors_for(other.block).to_vec();\n         let mut visited = FxHashSet::default();\n \n         while let Some(block) = queue.pop() {\n             // If we haven't visited this block before, then make sure we visit it's predecessors.\n             if visited.insert(block) {\n-                queue.append(&mut body.predecessors_for(block).clone());\n+                queue.extend(body.predecessors_for(block).iter().cloned());\n             } else {\n                 continue;\n             }\n@@ -2758,16 +2682,6 @@ pub struct GeneratorLayout<'tcx> {\n     /// have conflicts with each other are allowed to overlap in the computed\n     /// layout.\n     pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n-\n-    /// The names and scopes of all the stored generator locals.\n-    ///\n-    /// N.B., this is *strictly* a temporary hack for codegen\n-    /// debuginfo generation, and will be removed at some point.\n-    /// Do **NOT** use it for anything else, local information should not be\n-    /// in the MIR, please rely on local crate HIR or other side-channels.\n-    //\n-    // FIXME(tmandry): see above.\n-    pub __local_debuginfo_codegen_only_do_not_use: IndexVec<GeneratorSavedLocal, LocalDecl<'tcx>>,\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n@@ -2946,7 +2860,6 @@ CloneTypeFoldableAndLiftImpls! {\n     MirPhase,\n     Mutability,\n     SourceInfo,\n-    UpvarDebuginfo,\n     FakeReadCause,\n     RetagKind,\n     SourceScope,\n@@ -3000,7 +2913,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                             index: index.fold_with(folder),\n                         },\n                     Panic { .. } | Overflow(_) | OverflowNeg | DivisionByZero | RemainderByZero |\n-                    GeneratorResumedAfterReturn | GeneratorResumedAfterPanic =>\n+                    ResumedAfterReturn(_) | ResumedAfterPanic(_)  =>\n                         msg.clone(),\n                 };\n                 Assert { cond: cond.fold_with(folder), expected, msg, target, cleanup }\n@@ -3046,7 +2959,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                             len.visit_with(visitor) || index.visit_with(visitor),\n                         Panic { .. } | Overflow(_) | OverflowNeg |\n                         DivisionByZero | RemainderByZero |\n-                        GeneratorResumedAfterReturn | GeneratorResumedAfterPanic =>\n+                        ResumedAfterReturn(_) | ResumedAfterPanic(_) =>\n                             false\n                     }\n                 } else {\n@@ -3065,6 +2978,16 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Place {"}, {"sha": "703e0cc78c207b73821d12f58e21d19cc81284bc", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 55, "deletions": 9, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -65,13 +65,25 @@ use syntax_pos::Span;\n // variant argument) that does not require visiting, as in\n // `is_cleanup` above.\n \n+macro_rules! body_cache_type {\n+    (mut $a:lifetime, $tcx:lifetime) => {\n+        &mut BodyAndCache<$tcx>\n+    };\n+    ($a:lifetime, $tcx:lifetime) => {\n+        ReadOnlyBodyAndCache<$a, $tcx>\n+    };\n+}\n+\n macro_rules! make_mir_visitor {\n     ($visitor_trait_name:ident, $($mutability:ident)?) => {\n         pub trait $visitor_trait_name<'tcx> {\n             // Override these, and call `self.super_xxx` to revert back to the\n             // default behavior.\n \n-            fn visit_body(&mut self, body: & $($mutability)? Body<'tcx>) {\n+            fn visit_body(\n+                &mut self,\n+                body: body_cache_type!($($mutability)? '_, 'tcx)\n+            ) {\n                 self.super_body(body);\n             }\n \n@@ -221,6 +233,11 @@ macro_rules! make_mir_visitor {\n                 self.super_local_decl(local, local_decl);\n             }\n \n+            fn visit_var_debug_info(&mut self,\n+                                    var_debug_info: & $($mutability)* VarDebugInfo<'tcx>) {\n+                self.super_var_debug_info(var_debug_info);\n+            }\n+\n             fn visit_local(&mut self,\n                             _local: & $($mutability)? Local,\n                             _context: PlaceContext,\n@@ -235,11 +252,14 @@ macro_rules! make_mir_visitor {\n             // The `super_xxx` methods comprise the default behavior and are\n             // not meant to be overridden.\n \n-            fn super_body(&mut self,\n-                         body: & $($mutability)? Body<'tcx>) {\n+            fn super_body(\n+                &mut self,\n+                $($mutability)? body: body_cache_type!($($mutability)? '_, 'tcx)\n+            ) {\n+                let span = body.span;\n                 if let Some(yield_ty) = &$($mutability)? body.yield_ty {\n                     self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n-                        span: body.span,\n+                        span,\n                         scope: OUTERMOST_SOURCE_SCOPE,\n                     }));\n                 }\n@@ -255,6 +275,7 @@ macro_rules! make_mir_visitor {\n                     self.visit_basic_block_data(bb, data);\n                 }\n \n+                let body: & $($mutability)? Body<'_> = & $($mutability)? body;\n                 for scope in &$($mutability)? body.source_scopes {\n                     self.visit_source_scope_data(scope);\n                 }\n@@ -279,6 +300,10 @@ macro_rules! make_mir_visitor {\n                     );\n                 }\n \n+                for var_debug_info in &$($mutability)? body.var_debug_info {\n+                    self.visit_var_debug_info(var_debug_info);\n+                }\n+\n                 self.visit_span(&$($mutability)? body.span);\n             }\n \n@@ -308,6 +333,7 @@ macro_rules! make_mir_visitor {\n                 let SourceScopeData {\n                     span,\n                     parent_scope,\n+                    local_data: _,\n                 } = scope_data;\n \n                 self.visit_span(span);\n@@ -508,7 +534,7 @@ macro_rules! make_mir_visitor {\n                         self.visit_operand(index, location);\n                     }\n                     Panic { .. } | Overflow(_) | OverflowNeg | DivisionByZero | RemainderByZero |\n-                    GeneratorResumedAfterReturn | GeneratorResumedAfterPanic => {\n+                    ResumedAfterReturn(_) | ResumedAfterPanic(_) => {\n                         // Nothing to visit\n                     }\n                 }\n@@ -687,9 +713,7 @@ macro_rules! make_mir_visitor {\n                     mutability: _,\n                     ty,\n                     user_ty,\n-                    name: _,\n                     source_info,\n-                    visibility_scope,\n                     internal: _,\n                     local_info: _,\n                     is_block_tail: _,\n@@ -703,7 +727,23 @@ macro_rules! make_mir_visitor {\n                     self.visit_user_type_projection(user_ty);\n                 }\n                 self.visit_source_info(source_info);\n-                self.visit_source_scope(visibility_scope);\n+            }\n+\n+            fn super_var_debug_info(&mut self,\n+                                    var_debug_info: & $($mutability)? VarDebugInfo<'tcx>) {\n+                let VarDebugInfo {\n+                    name: _,\n+                    source_info,\n+                    place,\n+                } = var_debug_info;\n+\n+                self.visit_source_info(source_info);\n+                let location = START_BLOCK.start_location();\n+                self.visit_place(\n+                    place,\n+                    PlaceContext::NonUse(NonUseContext::VarDebugInfo),\n+                    location,\n+                );\n             }\n \n             fn super_source_scope(&mut self,\n@@ -766,7 +806,11 @@ macro_rules! make_mir_visitor {\n \n             // Convenience methods\n \n-            fn visit_location(&mut self, body: & $($mutability)? Body<'tcx>, location: Location) {\n+            fn visit_location(\n+                &mut self,\n+                body: body_cache_type!($($mutability)? '_, 'tcx),\n+                location: Location\n+            ) {\n                 let basic_block = & $($mutability)? body[location.block];\n                 if basic_block.statements.len() == location.statement_index {\n                     if let Some(ref $($mutability)? terminator) = basic_block.terminator {\n@@ -1029,6 +1073,8 @@ pub enum NonUseContext {\n     StorageDead,\n     /// User type annotation assertions for NLL.\n     AscribeUserTy,\n+    /// The data of an user variable, for debug info.\n+    VarDebugInfo,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}, {"sha": "538b13c79ce1ccd45960bcf98850a44d5079321e", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -106,44 +106,54 @@ rustc_queries! {\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n-        query mir_built(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {}\n+        query mir_built(_: DefId) -> &'tcx Steal<mir::BodyAndCache<'tcx>> {}\n \n         /// Fetch the MIR for a given `DefId` up till the point where it is\n         /// ready for const evaluation.\n         ///\n         /// See the README for the `mir` module for details.\n-        query mir_const(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {\n+        query mir_const(_: DefId) -> &'tcx Steal<mir::BodyAndCache<'tcx>> {\n             no_hash\n         }\n \n         query mir_validated(_: DefId) ->\n             (\n-                &'tcx Steal<mir::Body<'tcx>>,\n-                &'tcx Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n+                &'tcx Steal<mir::BodyAndCache<'tcx>>,\n+                &'tcx Steal<IndexVec<mir::Promoted, mir::BodyAndCache<'tcx>>>\n             ) {\n             no_hash\n         }\n \n         /// MIR after our optimization passes have run. This is MIR that is ready\n         /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n-        query optimized_mir(key: DefId) -> &'tcx mir::Body<'tcx> {\n+        query optimized_mir(key: DefId) -> &'tcx mir::BodyAndCache<'tcx> {\n             cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n-                let mir: Option<crate::mir::Body<'tcx>> = tcx.queries.on_disk_cache\n-                                                            .try_load_query_result(tcx, id);\n-                mir.map(|x| &*tcx.arena.alloc(x))\n+                let mir: Option<crate::mir::BodyAndCache<'tcx>>\n+                    = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n+                mir.map(|x| {\n+                    let cache = tcx.arena.alloc(x);\n+                    cache.ensure_predecessors();\n+                    &*cache\n+                })\n             }\n         }\n \n-        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> {\n+        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::BodyAndCache<'tcx>> {\n             cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n                 let promoted: Option<\n                     rustc_index::vec::IndexVec<\n                         crate::mir::Promoted,\n-                        crate::mir::Body<'tcx>\n+                        crate::mir::BodyAndCache<'tcx>\n                     >> = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n-                promoted.map(|p| &*tcx.arena.alloc(p))\n+                promoted.map(|p| {\n+                    let cache = tcx.arena.alloc(p);\n+                    for body in cache.iter_mut() {\n+                        body.ensure_predecessors();\n+                    }\n+                    &*cache\n+                })\n             }\n         }\n     }\n@@ -502,7 +512,7 @@ rustc_queries! {\n         /// in the case of closures, this will be redirected to the enclosing function.\n         query region_scope_tree(_: DefId) -> &'tcx region::ScopeTree {}\n \n-        query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::Body<'tcx> {\n+        query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::BodyAndCache<'tcx> {\n             no_force\n             desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n         }\n@@ -1130,7 +1140,7 @@ rustc_queries! {\n             desc { |tcx| \"estimating size for `{}`\", tcx.def_path_str(def.def_id()) }\n         }\n \n-        query features_query(_: CrateNum) -> &'tcx feature_gate::Features {\n+        query features_query(_: CrateNum) -> &'tcx rustc_feature::Features {\n             eval_always\n             desc { \"looking up enabled feature gates\" }\n         }"}, {"sha": "a0d9f52d28ad5eaca6dc146234a84a9a67137a06", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -461,7 +461,7 @@ impl AutoTraitFinder<'tcx> {\n                                     // The old predicate has a region variable where the new\n                                     // predicate has some other kind of region. An region\n                                     // variable isn't something we can actually display to a user,\n-                                    // so we choose ther new predicate (which doesn't have a region\n+                                    // so we choose their new predicate (which doesn't have a region\n                                     // varaible).\n                                     //\n                                     // In both cases, we want to remove the old predicate,\n@@ -703,7 +703,7 @@ impl AutoTraitFinder<'tcx> {\n                     // that we could add to our ParamEnv that would 'fix' this kind\n                     // of error, as it's not caused by an unimplemented type.\n                     //\n-                    // 2. We succesfully project the predicate (Ok(Some(_))), generating\n+                    // 2. We successfully project the predicate (Ok(Some(_))), generating\n                     //  some subobligations. We then process these subobligations\n                     //  like any other generated sub-obligations.\n                     //\n@@ -770,7 +770,7 @@ impl AutoTraitFinder<'tcx> {\n                         Ok(None) => {\n                             // It's ok not to make progress when hvave no inference variables -\n                             // in that case, we were only performing unifcation to check if an\n-                            // error occured (which would indicate that it's impossible for our\n+                            // error occurred (which would indicate that it's impossible for our\n                             // type to implement the auto trait).\n                             // However, we should always make progress (either by generating\n                             // subobligations or getting an error) when we started off with"}, {"sha": "933bc06c21efedfd2086cd052a0c119c65815acf", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -382,7 +382,7 @@ fn orphan_check_trait_ref<'tcx>(\n         ty: Ty<'tcx>,\n         in_crate: InCrate,\n     ) -> Vec<Ty<'tcx>> {\n-        if fundamental_ty(ty) && ty_is_non_local(tcx, ty, in_crate).is_some() {\n+        if fundamental_ty(ty) && ty_is_non_local(ty, in_crate).is_some() {\n             ty.walk_shallow().flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate)).collect()\n         } else {\n             vec![ty]\n@@ -396,7 +396,7 @@ fn orphan_check_trait_ref<'tcx>(\n         .enumerate()\n     {\n         debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n-        let non_local_tys = ty_is_non_local(tcx, input_ty, in_crate);\n+        let non_local_tys = ty_is_non_local(input_ty, in_crate);\n         if non_local_tys.is_none() {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n             return Ok(());\n@@ -405,7 +405,7 @@ fn orphan_check_trait_ref<'tcx>(\n             let local_type = trait_ref\n                 .input_types()\n                 .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                .filter(|ty| ty_is_non_local_constructor(tcx, ty, in_crate).is_none())\n+                .filter(|ty| ty_is_non_local_constructor(ty, in_crate).is_none())\n                 .next();\n \n             debug!(\"orphan_check_trait_ref: uncovered ty local_type: `{:?}`\", local_type);\n@@ -423,13 +423,13 @@ fn orphan_check_trait_ref<'tcx>(\n     Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n }\n \n-fn ty_is_non_local<'t>(tcx: TyCtxt<'t>, ty: Ty<'t>, in_crate: InCrate) -> Option<Vec<Ty<'t>>> {\n-    match ty_is_non_local_constructor(tcx, ty, in_crate) {\n+fn ty_is_non_local<'t>(ty: Ty<'t>, in_crate: InCrate) -> Option<Vec<Ty<'t>>> {\n+    match ty_is_non_local_constructor(ty, in_crate) {\n         Some(ty) => if !fundamental_ty(ty) {\n             Some(vec![ty])\n         } else {\n             let tys: Vec<_> = ty.walk_shallow()\n-                .filter_map(|t| ty_is_non_local(tcx, t, in_crate))\n+                .filter_map(|t| ty_is_non_local(t, in_crate))\n                 .flat_map(|i| i)\n                 .collect();\n             if tys.is_empty() {\n@@ -460,7 +460,6 @@ fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n }\n \n fn ty_is_non_local_constructor<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     in_crate: InCrate,\n ) -> Option<Ty<'tcx>> {\n@@ -503,14 +502,33 @@ fn ty_is_non_local_constructor<'tcx>(\n         } else {\n             Some(ty)\n         },\n-        ty::Opaque(did, _) => {\n-            // Check the underlying type that this opaque\n-            // type resolves to.\n-            // This recursion will eventually terminate,\n-            // since we've already managed to successfully\n-            // resolve all opaque types by this point\n-            let real_ty = tcx.type_of(did);\n-            ty_is_non_local_constructor(tcx, real_ty, in_crate)\n+        ty::Opaque(..) => {\n+            // This merits some explanation.\n+            // Normally, opaque types are not involed when performing\n+            // coherence checking, since it is illegal to directly\n+            // implement a trait on an opaque type. However, we might\n+            // end up looking at an opaque type during coherence checking\n+            // if an opaque type gets used within another type (e.g. as\n+            // a type parameter). This requires us to decide whether or\n+            // not an opaque type should be considered 'local' or not.\n+            //\n+            // We choose to treat all opaque types as non-local, even\n+            // those that appear within the same crate. This seems\n+            // somewhat suprising at first, but makes sense when\n+            // you consider that opaque types are supposed to hide\n+            // the underlying type *within the same crate*. When an\n+            // opaque type is used from outside the module\n+            // where it is declared, it should be impossible to observe\n+            // anyything about it other than the traits that it implements.\n+            //\n+            // The alternative would be to look at the underlying type\n+            // to determine whether or not the opaque type itself should\n+            // be considered local. However, this could make it a breaking change\n+            // to switch the underlying ('defining') type from a local type\n+            // to a remote type. This would violate the rule that opaque\n+            // types should be completely opaque apart from the traits\n+            // that they implement, so we don't use this behavior.\n+            Some(ty)\n         }\n \n         ty::Dynamic(ref tt, ..) => {"}, {"sha": "35017d6330da31555805556276b32139d5099d16", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 122, "deletions": 79, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -39,6 +39,7 @@ use syntax::ast;\n use syntax::symbol::{sym, kw};\n use syntax_pos::{DUMMY_SP, Span, ExpnKind, MultiSpan};\n use rustc::hir::def_id::LOCAL_CRATE;\n+use syntax_pos::source_map::SourceMap;\n \n use rustc_error_codes::*;\n \n@@ -166,7 +167,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         body_id: Option<hir::BodyId>,\n         fallback_has_occurred: bool,\n     ) {\n-        debug!(\"report_fulfillment_errors({:?})\", error);\n+        debug!(\"report_fulfillment_error({:?})\", error);\n         match error.code {\n             FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n                 self.report_selection_error(\n@@ -362,11 +363,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             return None\n         };\n \n-        if tcx.has_attr(impl_def_id, sym::rustc_on_unimplemented) {\n-            Some(impl_def_id)\n-        } else {\n-            None\n-        }\n+        tcx.has_attr(impl_def_id, sym::rustc_on_unimplemented).then_some(impl_def_id)\n     }\n \n     fn describe_generator(&self, body_id: hir::BodyId) -> Option<&'static str> {\n@@ -520,7 +517,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ) {\n             command.evaluate(self.tcx, trait_ref, &flags[..])\n         } else {\n-            OnUnimplementedNote::empty()\n+            OnUnimplementedNote::default()\n         }\n     }\n \n@@ -696,6 +693,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         fallback_has_occurred: bool,\n         points_at_arg: bool,\n     ) {\n+        let tcx = self.tcx;\n         let span = obligation.cause.span;\n \n         let mut err = match *error {\n@@ -731,12 +729,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             message,\n                             label,\n                             note,\n+                            enclosing_scope,\n                         } = self.on_unimplemented_note(trait_ref, obligation);\n                         let have_alt_message = message.is_some() || label.is_some();\n                         let is_try = self.tcx.sess.source_map().span_to_snippet(span)\n                             .map(|s| &s == \"?\")\n                             .unwrap_or(false);\n-                        let is_from = format!(\"{}\", trait_ref).starts_with(\"std::convert::From<\");\n+                        let is_from =\n+                            format!(\"{}\", trait_ref.print_only_trait_path())\n+                            .starts_with(\"std::convert::From<\");\n                         let (message, note) = if is_try && is_from {\n                             (Some(format!(\n                                 \"`?` couldn't convert the error to `{}`\",\n@@ -767,7 +768,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 format!(\n                                     \"{}the trait `{}` is not implemented for `{}`\",\n                                     pre_message,\n-                                    trait_ref,\n+                                    trait_ref.print_only_trait_path(),\n                                     trait_ref.self_ty(),\n                                 )\n                             };\n@@ -795,6 +796,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n                             err.note(s.as_str());\n                         }\n+                        if let Some(ref s) = enclosing_scope {\n+                            let enclosing_scope_span = tcx.def_span(\n+                                tcx.hir()\n+                                    .opt_local_def_id(obligation.cause.body_id)\n+                                    .unwrap_or_else(|| {\n+                                        tcx.hir().body_owner_def_id(hir::BodyId {\n+                                            hir_id: obligation.cause.body_id,\n+                                        })\n+                                    }),\n+                            );\n+\n+                            err.span_label(enclosing_scope_span, s.as_str());\n+                        }\n \n                         self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n                         self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n@@ -1091,7 +1105,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n     fn suggest_restricting_param_bound(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        mut err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::PolyTraitRef<'_>,\n         body_id: hir::HirId,\n     ) {\n@@ -1102,7 +1116,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => return,\n         };\n \n-        let mut suggest_restriction = |generics: &hir::Generics, msg| {\n+        let suggest_restriction = |\n+            generics: &hir::Generics,\n+            msg,\n+            err: &mut DiagnosticBuilder<'_>,\n+        | {\n             let span = generics.where_clause.span_for_predicates_or_empty_place();\n             if !span.from_expansion() && span.desugaring_kind().is_none() {\n                 err.span_suggestion(\n@@ -1132,7 +1150,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     kind: hir::TraitItemKind::Method(..), ..\n                 }) if param_ty && self_ty == self.tcx.types.self_param => {\n                     // Restricting `Self` for a single method.\n-                    suggest_restriction(&generics, \"`Self`\");\n+                    suggest_restriction(&generics, \"`Self`\", err);\n                     return;\n                 }\n \n@@ -1154,7 +1172,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     kind: hir::ItemKind::Impl(_, _, _, generics, ..), ..\n                 }) if projection.is_some() => {\n                     // Missing associated type bound.\n-                    suggest_restriction(&generics, \"the associated type\");\n+                    suggest_restriction(&generics, \"the associated type\", err);\n                     return;\n                 }\n \n@@ -1183,68 +1201,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 hir::Node::ImplItem(hir::ImplItem { generics, span, .. })\n                 if param_ty => {\n                     // Missing generic type parameter bound.\n-                    let restrict_msg = \"consider further restricting this bound\";\n                     let param_name = self_ty.to_string();\n-                    for param in generics.params.iter().filter(|p| {\n-                        p.name.ident().as_str() == param_name\n-                    }) {\n-                        if param_name.starts_with(\"impl \") {\n-                            // `impl Trait` in argument:\n-                            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n-                            err.span_suggestion(\n-                                param.span,\n-                                restrict_msg,\n-                                // `impl CurrentTrait + MissingTrait`\n-                                format!(\"{} + {}\", param.name.ident(), trait_ref),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else if generics.where_clause.predicates.is_empty() &&\n-                                param.bounds.is_empty()\n-                        {\n-                            // If there are no bounds whatsoever, suggest adding a constraint\n-                            // to the type parameter:\n-                            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n-                            err.span_suggestion(\n-                                param.span,\n-                                \"consider restricting this bound\",\n-                                format!(\"{}\", trait_ref.to_predicate()),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else if !generics.where_clause.predicates.is_empty() {\n-                            // There is a `where` clause, so suggest expanding it:\n-                            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n-                            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n-                            err.span_suggestion(\n-                                generics.where_clause.span().unwrap().shrink_to_hi(),\n-                                &format!(\n-                                    \"consider further restricting type parameter `{}`\",\n-                                    param_name,\n-                                ),\n-                                format!(\", {}\", trait_ref.to_predicate()),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            // If there is no `where` clause lean towards constraining to the\n-                            // type parameter:\n-                            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n-                            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n-                            let sp = param.span.with_hi(span.hi());\n-                            let span = self.tcx.sess.source_map()\n-                                .span_through_char(sp, ':');\n-                            if sp != param.span && sp != span {\n-                                // Only suggest if we have high certainty that the span\n-                                // covers the colon in `foo<T: Trait>`.\n-                                err.span_suggestion(span, restrict_msg, format!(\n-                                    \"{} + \",\n-                                    trait_ref.to_predicate(),\n-                                ), Applicability::MachineApplicable);\n-                            } else {\n-                                err.span_label(param.span, &format!(\n-                                    \"consider adding a `where {}` bound\",\n-                                    trait_ref.to_predicate(),\n-                                ));\n-                            }\n-                        }\n+                    let constraint = trait_ref.print_only_trait_path().to_string();\n+                    if suggest_constraining_type_param(\n+                        generics,\n+                        &mut err,\n+                        &param_name,\n+                        &constraint,\n+                        self.tcx.sess.source_map(),\n+                        *span,\n+                    ) {\n                         return;\n                     }\n                 }\n@@ -1463,7 +1429,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let msg = format!(\n                         \"the trait bound `{}: {}` is not satisfied\",\n                         found,\n-                        obligation.parent_trait_ref.skip_binder(),\n+                        obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n                     );\n                     if has_custom_message {\n                         err.note(&msg);\n@@ -1477,7 +1443,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                     err.span_label(span, &format!(\n                         \"expected an implementor of trait `{}`\",\n-                        obligation.parent_trait_ref.skip_binder(),\n+                        obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n                     ));\n                     err.span_suggestion(\n                         span,\n@@ -1609,7 +1575,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     } else {\n                         err.note(&format!(\n                             \"`{}` is implemented for `{:?}`, but not for `{:?}`\",\n-                            trait_ref,\n+                            trait_ref.print_only_trait_path(),\n                             trait_type,\n                             trait_ref.skip_binder().self_ty(),\n                         ));\n@@ -2244,6 +2210,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         let span = self.tcx.def_span(generator_did);\n+        // Do not ICE on closure typeck (#66868).\n+        if let None = self.tcx.hir().as_local_hir_id(generator_did) {\n+            return false;\n+        }\n         let tables = self.tcx.typeck_tables_of(generator_did);\n         debug!(\"note_obligation_cause_for_async_await: generator_did={:?} span={:?} \",\n                generator_did, span);\n@@ -2273,7 +2243,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             err.span_note(span, &format!(\n                 \"future does not implement `{}` as this value is used across an await\",\n-                trait_ref,\n+                trait_ref.print_only_trait_path(),\n             ));\n \n             // Add a note for the item obligation that remains - normally a note pointing to the\n@@ -2456,7 +2426,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n                 err.note(\n                     &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n-                             parent_trait_ref,\n+                             parent_trait_ref.print_only_trait_path(),\n                              parent_trait_ref.skip_binder().self_ty()));\n                 let parent_predicate = parent_trait_ref.to_predicate();\n                 self.note_obligation_cause_code(err,\n@@ -2546,3 +2516,76 @@ impl ArgKind {\n         }\n     }\n }\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    generics: &hir::Generics,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    source_map: &SourceMap,\n+    span: Span,\n+) -> bool {\n+    let restrict_msg = \"consider further restricting this bound\";\n+    if let Some(param) = generics.params.iter().filter(|p| {\n+        p.name.ident().as_str() == param_name\n+    }).next() {\n+        if param_name.starts_with(\"impl \") {\n+            // `impl Trait` in argument:\n+            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+            err.span_suggestion(\n+                param.span,\n+                restrict_msg,\n+                // `impl CurrentTrait + MissingTrait`\n+                format!(\"{} + {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if generics.where_clause.predicates.is_empty() &&\n+                param.bounds.is_empty()\n+        {\n+            // If there are no bounds whatsoever, suggest adding a constraint\n+            // to the type parameter:\n+            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            err.span_suggestion(\n+                param.span,\n+                \"consider restricting this bound\",\n+                format!(\"{}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if !generics.where_clause.predicates.is_empty() {\n+            // There is a `where` clause, so suggest expanding it:\n+            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+            err.span_suggestion(\n+                generics.where_clause.span().unwrap().shrink_to_hi(),\n+                &format!(\"consider further restricting type parameter `{}`\", param_name),\n+                format!(\", {}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            // If there is no `where` clause lean towards constraining to the\n+            // type parameter:\n+            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+            let sp = param.span.with_hi(span.hi());\n+            let span = source_map.span_through_char(sp, ':');\n+            if sp != param.span && sp != span {\n+                // Only suggest if we have high certainty that the span\n+                // covers the colon in `foo<T: Trait>`.\n+                err.span_suggestion(\n+                    span,\n+                    restrict_msg,\n+                    format!(\"{}: {} + \", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    param.span,\n+                    &format!(\"consider adding a `where {}: {}` bound\", param_name, constraint),\n+                );\n+            }\n+        }\n+        return true;\n+    }\n+    false\n+}"}, {"sha": "604f39dcf293b3503a82355461208a10251be27b", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -22,18 +22,15 @@ pub struct OnUnimplementedDirective {\n     pub message: Option<OnUnimplementedFormatString>,\n     pub label: Option<OnUnimplementedFormatString>,\n     pub note: Option<OnUnimplementedFormatString>,\n+    pub enclosing_scope: Option<OnUnimplementedFormatString>,\n }\n \n+#[derive(Default)]\n pub struct OnUnimplementedNote {\n     pub message: Option<String>,\n     pub label: Option<String>,\n     pub note: Option<String>,\n-}\n-\n-impl OnUnimplementedNote {\n-    pub fn empty() -> Self {\n-        OnUnimplementedNote { message: None, label: None, note: None }\n-    }\n+    pub enclosing_scope: Option<String>,\n }\n \n fn parse_error(\n@@ -85,24 +82,33 @@ impl<'tcx> OnUnimplementedDirective {\n         let mut message = None;\n         let mut label = None;\n         let mut note = None;\n+        let mut enclosing_scope = None;\n         let mut subcommands = vec![];\n+\n+        let parse_value = |value_str| {\n+                OnUnimplementedFormatString::try_parse(tcx, trait_def_id, value_str, span)\n+                    .map(Some)\n+            };\n+\n         for item in item_iter {\n             if item.check_name(sym::message) && message.is_none() {\n                 if let Some(message_) = item.value_str() {\n-                    message = Some(OnUnimplementedFormatString::try_parse(\n-                        tcx, trait_def_id, message_, span)?);\n+                    message = parse_value(message_)?;\n                     continue;\n                 }\n             } else if item.check_name(sym::label) && label.is_none() {\n                 if let Some(label_) = item.value_str() {\n-                    label = Some(OnUnimplementedFormatString::try_parse(\n-                        tcx, trait_def_id, label_, span)?);\n+                    label = parse_value(label_)?;\n                     continue;\n                 }\n             } else if item.check_name(sym::note) && note.is_none() {\n                 if let Some(note_) = item.value_str() {\n-                    note = Some(OnUnimplementedFormatString::try_parse(\n-                        tcx, trait_def_id, note_, span)?);\n+                    note = parse_value(note_)?;\n+                    continue;\n+                }\n+            } else if item.check_name(sym::enclosing_scope) && enclosing_scope.is_none() {\n+                if let Some(enclosing_scope_) = item.value_str() {\n+                    enclosing_scope = parse_value(enclosing_scope_)?;\n                     continue;\n                 }\n             } else if item.check_name(sym::on) && is_root &&\n@@ -130,7 +136,14 @@ impl<'tcx> OnUnimplementedDirective {\n         if errored {\n             Err(ErrorReported)\n         } else {\n-            Ok(OnUnimplementedDirective { condition, message, label, subcommands, note })\n+            Ok(OnUnimplementedDirective {\n+                condition,\n+                subcommands,\n+                message,\n+                label,\n+                note,\n+                enclosing_scope\n+            })\n         }\n     }\n \n@@ -157,6 +170,7 @@ impl<'tcx> OnUnimplementedDirective {\n                 label: Some(OnUnimplementedFormatString::try_parse(\n                     tcx, trait_def_id, value, attr.span)?),\n                 note: None,\n+                enclosing_scope: None,\n             }))\n         } else {\n             return Err(ErrorReported);\n@@ -174,6 +188,7 @@ impl<'tcx> OnUnimplementedDirective {\n         let mut message = None;\n         let mut label = None;\n         let mut note = None;\n+        let mut enclosing_scope = None;\n         info!(\"evaluate({:?}, trait_ref={:?}, options={:?})\", self, trait_ref, options);\n \n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n@@ -202,6 +217,10 @@ impl<'tcx> OnUnimplementedDirective {\n             if let Some(ref note_) = command.note {\n                 note = Some(note_.clone());\n             }\n+\n+            if let Some(ref enclosing_scope_) = command.enclosing_scope {\n+                enclosing_scope = Some(enclosing_scope_.clone());\n+            }\n         }\n \n         let options: FxHashMap<Symbol, String> = options.into_iter()\n@@ -211,6 +230,7 @@ impl<'tcx> OnUnimplementedDirective {\n             label: label.map(|l| l.format(tcx, trait_ref, &options)),\n             message: message.map(|m| m.format(tcx, trait_ref, &options)),\n             note: note.map(|n| n.format(tcx, trait_ref, &options)),\n+            enclosing_scope: enclosing_scope.map(|e_s| e_s.format(tcx, trait_ref, &options)),\n         }\n     }\n }"}, {"sha": "5f324527a2725b3d1aa65b095c9128cf7b1b106e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1044,7 +1044,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n                         let self_ty = trait_ref.self_ty();\n                         let cause = IntercrateAmbiguityCause::DownstreamCrate {\n-                            trait_desc: trait_ref.to_string(),\n+                            trait_desc: trait_ref.print_only_trait_path().to_string(),\n                             self_desc: if self_ty.has_concrete_skeleton() {\n                                 Some(self_ty.to_string())\n                             } else {\n@@ -1386,7 +1386,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     if !candidate_set.ambiguous && no_candidates_apply {\n                         let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n                         let self_ty = trait_ref.self_ty();\n-                        let trait_desc = trait_ref.to_string();\n+                        let trait_desc = trait_ref.print_only_trait_path().to_string();\n                         let self_desc = if self_ty.has_concrete_skeleton() {\n                             Some(self_ty.to_string())\n                         } else {"}, {"sha": "88a2db3dc622399516848966b5790bf316ea6bb4", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -417,7 +417,7 @@ fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String>\n         w.push('>');\n     }\n \n-    write!(w, \" {} for {}\", trait_ref, tcx.type_of(impl_def_id)).unwrap();\n+    write!(w, \" {} for {}\", trait_ref.print_only_trait_path(), tcx.type_of(impl_def_id)).unwrap();\n \n     // The predicates will contain default bounds like `T: Sized`. We need to\n     // remove these bounds, and add `T: ?Sized` to any untouched type parameters."}, {"sha": "b8ddf6078bda6e1d20aabb978a6529afeadeed96", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -146,7 +146,7 @@ impl<'tcx> Children {\n                 let self_ty = trait_ref.self_ty();\n                 OverlapError {\n                     with_impl: possible_sibling,\n-                    trait_desc: trait_ref.to_string(),\n+                    trait_desc: trait_ref.print_only_trait_path().to_string(),\n                     // Only report the `Self` type if it has at least\n                     // some outer concrete shell; otherwise, it's\n                     // not adding much information."}, {"sha": "268015a56240e52290ecd360be42220da92a5108", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 112, "deletions": 3, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -2,7 +2,8 @@ use crate::ty::query::Providers;\n use crate::hir::def_id::DefId;\n use crate::hir;\n use crate::ty::TyCtxt;\n-use syntax_pos::symbol::Symbol;\n+use syntax_pos::symbol::{sym, Symbol};\n+use rustc_target::spec::abi::Abi;\n use crate::hir::map::blocks::FnLikeNode;\n use syntax::attr;\n \n@@ -35,12 +36,51 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Returns `true` if the `def_id` refers to an intrisic which we've whitelisted\n+    /// for being called from stable `const fn`s (`min_const_fn`).\n+    ///\n+    /// Adding more intrinsics requires sign-off from @rust-lang/lang.\n+    ///\n+    /// This list differs from the list in `is_const_intrinsic` in the sense that any item on this\n+    /// list must be on the `is_const_intrinsic` list, too, because if an intrinsic is callable from\n+    /// stable, it must be callable at all.\n+    fn is_intrinsic_min_const_fn(self, def_id: DefId) -> bool {\n+        match self.item_name(def_id) {\n+            | sym::size_of\n+            | sym::min_align_of\n+            | sym::needs_drop\n+            // Arithmetic:\n+            | sym::add_with_overflow // ~> .overflowing_add\n+            | sym::sub_with_overflow // ~> .overflowing_sub\n+            | sym::mul_with_overflow // ~> .overflowing_mul\n+            | sym::wrapping_add // ~> .wrapping_add\n+            | sym::wrapping_sub // ~> .wrapping_sub\n+            | sym::wrapping_mul // ~> .wrapping_mul\n+            | sym::saturating_add // ~> .saturating_add\n+            | sym::saturating_sub // ~> .saturating_sub\n+            | sym::unchecked_shl // ~> .wrapping_shl\n+            | sym::unchecked_shr // ~> .wrapping_shr\n+            | sym::rotate_left // ~> .rotate_left\n+            | sym::rotate_right // ~> .rotate_right\n+            | sym::ctpop // ~> .count_ones\n+            | sym::ctlz // ~> .leading_zeros\n+            | sym::cttz // ~> .trailing_zeros\n+            | sym::bswap // ~> .swap_bytes\n+            | sym::bitreverse // ~> .reverse_bits\n+            => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// Returns `true` if this function must conform to `min_const_fn`\n     pub fn is_min_const_fn(self, def_id: DefId) -> bool {\n         // Bail out if the signature doesn't contain `const`\n         if !self.is_const_fn_raw(def_id) {\n             return false;\n         }\n+        if let Abi::RustIntrinsic = self.fn_sig(def_id).abi() {\n+            return self.is_intrinsic_min_const_fn(def_id);\n+        }\n \n         if self.features().staged_api {\n             // in order for a libstd function to be considered min_const_fn\n@@ -63,13 +103,82 @@ impl<'tcx> TyCtxt<'tcx> {\n \n \n pub fn provide(providers: &mut Providers<'_>) {\n-    /// only checks whether the function has a `const` modifier\n+    /// Const evaluability whitelist is here to check evaluability at the\n+    /// top level beforehand.\n+    fn is_const_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> Option<bool> {\n+        match tcx.fn_sig(def_id).abi() {\n+            Abi::RustIntrinsic |\n+            Abi::PlatformIntrinsic => {\n+                // FIXME: deduplicate these two lists as much as possible\n+                match tcx.item_name(def_id) {\n+                    // Keep this list in the same order as the match patterns in\n+                    // `librustc_mir/interpret/intrinsics.rs`\n+\n+                    // This whitelist is a list of intrinsics that have a miri-engine implementation\n+                    // and can thus be called when enabling enough feature gates. The similar\n+                    // whitelist in `is_intrinsic_min_const_fn` (in this file), exists for allowing\n+                    // the intrinsics to be called by stable const fns.\n+                    | sym::caller_location\n+\n+                    | sym::min_align_of\n+                    | sym::pref_align_of\n+                    | sym::needs_drop\n+                    | sym::size_of\n+                    | sym::type_id\n+                    | sym::type_name\n+\n+                    | sym::ctpop\n+                    | sym::cttz\n+                    | sym::cttz_nonzero\n+                    | sym::ctlz\n+                    | sym::ctlz_nonzero\n+                    | sym::bswap\n+                    | sym::bitreverse\n+\n+                    | sym::wrapping_add\n+                    | sym::wrapping_sub\n+                    | sym::wrapping_mul\n+                    | sym::add_with_overflow\n+                    | sym::sub_with_overflow\n+                    | sym::mul_with_overflow\n+\n+                    | sym::saturating_add\n+                    | sym::saturating_sub\n+\n+                    | sym::unchecked_shl\n+                    | sym::unchecked_shr\n+\n+                    | sym::rotate_left\n+                    | sym::rotate_right\n+\n+                    | sym::ptr_offset_from\n+\n+                    | sym::transmute\n+\n+                    | sym::simd_insert\n+\n+                    | sym::simd_extract\n+\n+                    => Some(true),\n+\n+                    _ => Some(false)\n+                }\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n+    /// said intrinsic is on the whitelist for being const callable.\n     fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n         let hir_id = tcx.hir().as_local_hir_id(def_id)\n                               .expect(\"Non-local call to local provider is_const_fn\");\n \n         let node = tcx.hir().get(hir_id);\n-        if let Some(fn_like) = FnLikeNode::from_node(node) {\n+\n+        if let Some(whitelisted) = is_const_intrinsic(tcx, def_id) {\n+            whitelisted\n+        } else if let Some(fn_like) = FnLikeNode::from_node(node) {\n             fn_like.constness() == hir::Constness::Const\n         } else if let hir::Node::Ctor(_) = node {\n             true"}, {"sha": "f7e422b0403dcf88dd59a63a89e98fb69498001a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -8,6 +8,7 @@ use crate::session::Session;\n use crate::session::config::{BorrowckMode, OutputFilenames};\n use crate::session::config::CrateType;\n use crate::middle;\n+use crate::middle::lang_items::PanicLocationLangItem;\n use crate::hir::{self, TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n use crate::hir::def::{Res, DefKind, Export};\n use crate::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n@@ -22,7 +23,7 @@ use crate::middle::cstore::EncodedMetadata;\n use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::{Body, Field, interpret, Local, Place, PlaceElem, ProjectionKind, Promoted};\n+use crate::mir::{BodyAndCache, Field, interpret, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n@@ -72,7 +73,6 @@ use rustc_macros::HashStable;\n use syntax::ast;\n use syntax::attr;\n use syntax::source_map::MultiSpan;\n-use syntax::feature_gate;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::Span;\n use syntax::expand::allocator::AllocatorKind;\n@@ -995,7 +995,7 @@ impl<'tcx> Deref for TyCtxt<'tcx> {\n }\n \n pub struct GlobalCtxt<'tcx> {\n-    pub arena: WorkerLocal<Arena<'tcx>>,\n+    pub arena: &'tcx WorkerLocal<Arena<'tcx>>,\n \n     interners: CtxtInterners<'tcx>,\n \n@@ -1084,17 +1084,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         &self.hir_map\n     }\n \n-    pub fn alloc_steal_mir(self, mir: Body<'tcx>) -> &'tcx Steal<Body<'tcx>> {\n+    pub fn alloc_steal_mir(self, mir: BodyAndCache<'tcx>) -> &'tcx Steal<BodyAndCache<'tcx>> {\n         self.arena.alloc(Steal::new(mir))\n     }\n \n-    pub fn alloc_steal_promoted(self, promoted: IndexVec<Promoted, Body<'tcx>>) ->\n-        &'tcx Steal<IndexVec<Promoted, Body<'tcx>>> {\n+    pub fn alloc_steal_promoted(self, promoted: IndexVec<Promoted, BodyAndCache<'tcx>>) ->\n+        &'tcx Steal<IndexVec<Promoted, BodyAndCache<'tcx>>> {\n         self.arena.alloc(Steal::new(promoted))\n     }\n \n-    pub fn intern_promoted(self, promoted: IndexVec<Promoted, Body<'tcx>>) ->\n-        &'tcx IndexVec<Promoted, Body<'tcx>> {\n+    pub fn intern_promoted(self, promoted: IndexVec<Promoted, BodyAndCache<'tcx>>) ->\n+        &'tcx IndexVec<Promoted, BodyAndCache<'tcx>> {\n         self.arena.alloc(promoted)\n     }\n \n@@ -1170,6 +1170,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         local_providers: ty::query::Providers<'tcx>,\n         extern_providers: ty::query::Providers<'tcx>,\n         arenas: &'tcx AllArenas,\n+        arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         resolutions: ty::ResolverOutputs,\n         hir: hir_map::Map<'tcx>,\n         on_disk_query_result_cache: query::OnDiskCache<'tcx>,\n@@ -1225,7 +1226,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             sess: s,\n             lint_store,\n             cstore,\n-            arena: WorkerLocal::new(|_| Arena::default()),\n+            arena,\n             interners,\n             dep_graph,\n             prof: s.prof.clone(),\n@@ -1307,15 +1308,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.all_crate_nums(LOCAL_CRATE)\n     }\n \n-    pub fn injected_panic_runtime(self) -> Option<CrateNum> {\n-        self.cstore.injected_panic_runtime()\n-    }\n-\n     pub fn allocator_kind(self) -> Option<AllocatorKind> {\n         self.cstore.allocator_kind()\n     }\n \n-    pub fn features(self) -> &'tcx feature_gate::Features {\n+    pub fn features(self) -> &'tcx rustc_feature::Features {\n         self.features_query(LOCAL_CRATE)\n     }\n \n@@ -1391,8 +1388,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     // Note that this is *untracked* and should only be used within the query\n     // system if the result is otherwise tracked through queries\n-    pub fn crate_data_as_any(self, cnum: CrateNum) -> &'tcx dyn Any {\n-        self.cstore.crate_data_as_any(cnum)\n+    pub fn cstore_as_any(self) -> &'tcx dyn Any {\n+        self.cstore.as_any()\n     }\n \n     #[inline(always)]\n@@ -1592,6 +1589,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn has_strict_asm_symbol_naming(&self) -> bool {\n         self.sess.target.target.arch.contains(\"nvptx\")\n     }\n+\n+    /// Returns `&'static core::panic::Location<'static>`.\n+    pub fn caller_location_ty(&self) -> Ty<'tcx> {\n+        self.mk_imm_ref(\n+            self.lifetimes.re_static,\n+            self.type_of(self.require_lang_item(PanicLocationLangItem, None))\n+                .subst(*self, self.mk_substs([self.lifetimes.re_static.into()].iter())),\n+        )\n+    }\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n@@ -2999,14 +3005,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(cnum, LOCAL_CRATE);\n         tcx.arena.alloc_slice(&tcx.cstore.crates_untracked())\n     };\n-    providers.crate_host_hash = |tcx, cnum| {\n-        assert_ne!(cnum, LOCAL_CRATE);\n-        tcx.cstore.crate_host_hash_untracked(cnum)\n-    };\n-    providers.postorder_cnums = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.arena.alloc_slice(&tcx.cstore.postorder_cnums_untracked())\n-    };\n     providers.output_filenames = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         tcx.output_filenames.clone()"}, {"sha": "3a55aefe85d3d48b072c56112bb0758988ef88f1", "filename": "src/librustc/ty/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fdiagnostics.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -15,7 +15,7 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Whether the type is succinctly representable as a type instead of just refered to with a\n+    /// Whether the type is succinctly representable as a type instead of just referred to with a\n     /// description in error messages. This is used in the main error message.\n     pub fn is_simple_ty(&self) -> bool {\n         match self.kind {\n@@ -28,7 +28,7 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Whether the type is succinctly representable as a type instead of just refered to with a\n+    /// Whether the type is succinctly representable as a type instead of just referred to with a\n     /// description in error messages. This is used in the primary span label. Beyond what\n     /// `is_simple_ty` includes, it also accepts ADTs with no type arguments and references to\n     /// ADTs with no type arguments."}, {"sha": "366951bc9f494d325ab0cd4cc0ac7718825c62f2", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 31, "deletions": 84, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,16 +1,14 @@\n use crate::hir::CodegenFnAttrFlags;\n-use crate::hir::Unsafety;\n use crate::hir::def::Namespace;\n use crate::hir::def_id::DefId;\n-use crate::ty::{self, Ty, PolyFnSig, TypeFoldable, SubstsRef, TyCtxt};\n+use crate::ty::{self, Ty, TypeFoldable, SubstsRef, TyCtxt};\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::traits;\n use crate::middle::lang_items::DropInPlaceFnLangItem;\n use rustc_target::spec::abi::Abi;\n use rustc_macros::HashStable;\n \n use std::fmt;\n-use std::iter;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, Lift)]\n@@ -29,17 +27,26 @@ pub enum InstanceDef<'tcx> {\n \n     /// `fn()` pointer where the function itself cannot be turned into a pointer.\n     ///\n-    /// One example in the compiler today is functions annotated with `#[track_caller]`, which\n-    /// must have their implicit caller location argument populated for a call. Because this is a\n-    /// required part of the function's ABI but can't be tracked as a property of the function\n-    /// pointer, we create a single \"caller location\" at the site where the function is reified.\n+    /// One example is `<dyn Trait as Trait>::fn`, where the shim contains\n+    /// a virtual call, which codegen supports only via a direct call to the\n+    /// `<dyn Trait as Trait>::fn` instance (an `InstanceDef::Virtual`).\n+    ///\n+    /// Another example is functions annotated with `#[track_caller]`, which\n+    /// must have their implicit caller location argument populated for a call.\n+    /// Because this is a required part of the function's ABI but can't be tracked\n+    /// as a property of the function pointer, we use a single \"caller location\"\n+    /// (the definition of the function itself).\n     ReifyShim(DefId),\n \n     /// `<fn() as FnTrait>::call_*`\n     /// `DefId` is `FnTrait::call_*`.\n     FnPtrShim(DefId, Ty<'tcx>),\n \n-    /// `<dyn Trait as Trait>::fn`\n+    /// `<dyn Trait as Trait>::fn`, \"direct calls\" of which are implicitly\n+    /// codegen'd as virtual calls.\n+    ///\n+    /// NB: if this is reified to a `fn` pointer, a `ReifyShim` is used\n+    /// (see `ReifyShim` above for more details on that).\n     Virtual(DefId, usize),\n \n     /// `<[mut closure] as FnOnce>::call_once`\n@@ -61,70 +68,6 @@ impl<'tcx> Instance<'tcx> {\n             &ty,\n         )\n     }\n-\n-    fn fn_sig_noadjust(&self, tcx: TyCtxt<'tcx>) -> PolyFnSig<'tcx> {\n-        let ty = self.ty(tcx);\n-        match ty.kind {\n-            ty::FnDef(..) |\n-            // Shims currently have type FnPtr. Not sure this should remain.\n-            ty::FnPtr(_) => ty.fn_sig(tcx),\n-            ty::Closure(def_id, substs) => {\n-                let sig = substs.as_closure().sig(def_id, tcx);\n-\n-                let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n-                sig.map_bound(|sig| tcx.mk_fn_sig(\n-                    iter::once(*env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n-                    sig.output(),\n-                    sig.c_variadic,\n-                    sig.unsafety,\n-                    sig.abi\n-                ))\n-            }\n-            ty::Generator(def_id, substs, _) => {\n-                let sig = substs.as_generator().poly_sig(def_id, tcx);\n-\n-                let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n-                let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n-\n-                let pin_did = tcx.lang_items().pin_type().unwrap();\n-                let pin_adt_ref = tcx.adt_def(pin_did);\n-                let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n-                let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n-\n-                sig.map_bound(|sig| {\n-                    let state_did = tcx.lang_items().gen_state().unwrap();\n-                    let state_adt_ref = tcx.adt_def(state_did);\n-                    let state_substs = tcx.intern_substs(&[\n-                        sig.yield_ty.into(),\n-                        sig.return_ty.into(),\n-                    ]);\n-                    let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n-\n-                    tcx.mk_fn_sig(iter::once(env_ty),\n-                        ret_ty,\n-                        false,\n-                        Unsafety::Normal,\n-                        Abi::Rust\n-                    )\n-                })\n-            }\n-            _ => bug!(\"unexpected type {:?} in Instance::fn_sig_noadjust\", ty)\n-        }\n-    }\n-\n-    pub fn fn_sig(&self, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        let mut fn_sig = self.fn_sig_noadjust(tcx);\n-        if let InstanceDef::VtableShim(..) = self.def {\n-            // Modify `fn(self, ...)` to `fn(self: *mut Self, ...)`.\n-            fn_sig = fn_sig.map_bound(|mut fn_sig| {\n-                let mut inputs_and_output = fn_sig.inputs_and_output.to_vec();\n-                inputs_and_output[0] = tcx.mk_mut_ptr(inputs_and_output[0]);\n-                fn_sig.inputs_and_output = tcx.intern_type_list(&inputs_and_output);\n-                fn_sig\n-            });\n-        }\n-        fn_sig\n-    }\n }\n \n impl<'tcx> InstanceDef<'tcx> {\n@@ -173,6 +116,10 @@ impl<'tcx> InstanceDef<'tcx> {\n         }\n         tcx.codegen_fn_attrs(self.def_id()).requests_inline()\n     }\n+\n+    pub fn requires_caller_location(&self, tcx: TyCtxt<'_>) -> bool {\n+        tcx.codegen_fn_attrs(self.def_id()).flags.contains(CodegenFnAttrFlags::TRACK_CALLER)\n+    }\n }\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n@@ -196,7 +143,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n                 write!(f, \" - intrinsic\")\n             }\n             InstanceDef::Virtual(_, num) => {\n-                write!(f, \" - shim(#{})\", num)\n+                write!(f, \" - virtual#{}\", num)\n             }\n             InstanceDef::FnPtrShim(_, ty) => {\n                 write!(f, \" - shim({:?})\", ty)\n@@ -311,20 +258,20 @@ impl<'tcx> Instance<'tcx> {\n         substs: SubstsRef<'tcx>,\n     ) -> Option<Instance<'tcx>> {\n         debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n-        Instance::resolve(tcx, param_env, def_id, substs).map(|resolved| {\n-            let has_track_caller = |def| tcx.codegen_fn_attrs(def).flags\n-                .contains(CodegenFnAttrFlags::TRACK_CALLER);\n-\n+        Instance::resolve(tcx, param_env, def_id, substs).map(|mut resolved| {\n             match resolved.def {\n-                InstanceDef::Item(def_id) if has_track_caller(def_id) => {\n+                InstanceDef::Item(def_id) if resolved.def.requires_caller_location(tcx) => {\n                     debug!(\" => fn pointer created for function with #[track_caller]\");\n-                    Instance {\n-                        def: InstanceDef::ReifyShim(def_id),\n-                        substs,\n-                    }\n-                },\n-                _ => resolved,\n+                    resolved.def = InstanceDef::ReifyShim(def_id);\n+                }\n+                InstanceDef::Virtual(def_id, _) => {\n+                    debug!(\" => fn pointer created for virtual call\");\n+                    resolved.def = InstanceDef::ReifyShim(def_id);\n+                }\n+                _ => {}\n             }\n+\n+            resolved\n         })\n     }\n "}, {"sha": "c7278dc4fac706fce3ad0907e374ff63d234e539", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 114, "deletions": 20, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -2339,6 +2339,76 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for LayoutError<'tcx> {\n     }\n }\n \n+\n+impl<'tcx> ty::Instance<'tcx> {\n+    // NOTE(eddyb) this is private to avoid using it from outside of\n+    // `FnAbi::of_instance` - any other uses are either too high-level\n+    // for `Instance` (e.g. typeck would use `Ty::fn_sig` instead),\n+    // or should go through `FnAbi` instead, to avoid losing any\n+    // adjustments `FnAbi::of_instance` might be performing.\n+    fn fn_sig_for_fn_abi(&self, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n+        let ty = self.ty(tcx);\n+        match ty.kind {\n+            ty::FnDef(..) |\n+            // Shims currently have type FnPtr. Not sure this should remain.\n+            ty::FnPtr(_) => {\n+                let mut sig = ty.fn_sig(tcx);\n+                if let ty::InstanceDef::VtableShim(..) = self.def {\n+                    // Modify `fn(self, ...)` to `fn(self: *mut Self, ...)`.\n+                    sig = sig.map_bound(|mut sig| {\n+                        let mut inputs_and_output = sig.inputs_and_output.to_vec();\n+                        inputs_and_output[0] = tcx.mk_mut_ptr(inputs_and_output[0]);\n+                        sig.inputs_and_output = tcx.intern_type_list(&inputs_and_output);\n+                        sig\n+                    });\n+                }\n+                sig\n+            }\n+            ty::Closure(def_id, substs) => {\n+                let sig = substs.as_closure().sig(def_id, tcx);\n+\n+                let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n+                sig.map_bound(|sig| tcx.mk_fn_sig(\n+                    iter::once(*env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n+                    sig.output(),\n+                    sig.c_variadic,\n+                    sig.unsafety,\n+                    sig.abi\n+                ))\n+            }\n+            ty::Generator(def_id, substs, _) => {\n+                let sig = substs.as_generator().poly_sig(def_id, tcx);\n+\n+                let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n+                let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n+\n+                let pin_did = tcx.lang_items().pin_type().unwrap();\n+                let pin_adt_ref = tcx.adt_def(pin_did);\n+                let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n+                let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n+\n+                sig.map_bound(|sig| {\n+                    let state_did = tcx.lang_items().gen_state().unwrap();\n+                    let state_adt_ref = tcx.adt_def(state_did);\n+                    let state_substs = tcx.intern_substs(&[\n+                        sig.yield_ty.into(),\n+                        sig.return_ty.into(),\n+                    ]);\n+                    let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+\n+                    tcx.mk_fn_sig(iter::once(env_ty),\n+                        ret_ty,\n+                        false,\n+                        hir::Unsafety::Normal,\n+                        rustc_target::spec::abi::Abi::Rust\n+                    )\n+                })\n+            }\n+            _ => bug!(\"unexpected type {:?} in Instance::fn_sig\", ty)\n+        }\n+    }\n+}\n+\n pub trait FnAbiExt<'tcx, C>\n where\n     C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n@@ -2347,13 +2417,24 @@ where\n         + HasTyCtxt<'tcx>\n         + HasParamEnv<'tcx>,\n {\n-    fn of_instance(cx: &C, instance: ty::Instance<'tcx>) -> Self;\n-    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n-    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n+    /// Compute a `FnAbi` suitable for indirect calls, i.e. to `fn` pointers.\n+    ///\n+    /// NB: this doesn't handle virtual calls - those should use `FnAbi::of_instance`\n+    /// instead, where the instance is a `InstanceDef::Virtual`.\n+    fn of_fn_ptr(cx: &C, sig: ty::PolyFnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n+\n+    /// Compute a `FnAbi` suitable for declaring/defining an `fn` instance, and for\n+    /// direct calls to an `fn`.\n+    ///\n+    /// NB: that includes virtual calls, which are represented by \"direct calls\"\n+    /// to a `InstanceDef::Virtual` instance (of `<dyn Trait as Trait>::fn`).\n+    fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n+\n     fn new_internal(\n         cx: &C,\n-        sig: ty::FnSig<'tcx>,\n+        sig: ty::PolyFnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n+        caller_location: Option<Ty<'tcx>>,\n         mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgAbi<'tcx, Ty<'tcx>>,\n     ) -> Self;\n     fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi);\n@@ -2367,25 +2448,25 @@ where\n         + HasTyCtxt<'tcx>\n         + HasParamEnv<'tcx>,\n {\n-    fn of_instance(cx: &C, instance: ty::Instance<'tcx>) -> Self {\n-        let sig = instance.fn_sig(cx.tcx());\n-        let sig = cx\n-            .tcx()\n-            .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        call::FnAbi::new(cx, sig, &[])\n+    fn of_fn_ptr(cx: &C, sig: ty::PolyFnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n+        call::FnAbi::new_internal(cx, sig, extra_args, None, |ty, _| ArgAbi::new(cx.layout_of(ty)))\n     }\n \n-    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        call::FnAbi::new_internal(cx, sig, extra_args, |ty, _| ArgAbi::new(cx.layout_of(ty)))\n-    }\n+    fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n+        let sig = instance.fn_sig_for_fn_abi(cx.tcx());\n+\n+        let caller_location = if instance.def.requires_caller_location(cx.tcx()) {\n+            Some(cx.tcx().caller_location_ty())\n+        } else {\n+            None\n+        };\n \n-    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        FnAbiExt::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n+        call::FnAbi::new_internal(cx, sig, extra_args, caller_location, |ty, arg_idx| {\n             let mut layout = cx.layout_of(ty);\n             // Don't pass the vtable, it's not an argument of the virtual fn.\n             // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n             // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n-            if arg_idx == Some(0) {\n+            if let (ty::InstanceDef::Virtual(..), Some(0)) = (&instance.def, arg_idx) {\n                 let fat_pointer_ty = if layout.is_unsized() {\n                     // unsized `self` is passed as a pointer to `self`\n                     // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n@@ -2405,7 +2486,7 @@ where\n                     'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n                         && !fat_pointer_layout.ty.is_region_ptr()\n                     {\n-                        'iter_fields: for i in 0..fat_pointer_layout.fields.count() {\n+                        for i in 0..fat_pointer_layout.fields.count() {\n                             let field_layout = fat_pointer_layout.field(cx, i);\n \n                             if !field_layout.is_zst() {\n@@ -2436,15 +2517,20 @@ where\n \n     fn new_internal(\n         cx: &C,\n-        sig: ty::FnSig<'tcx>,\n+        sig: ty::PolyFnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n+        caller_location: Option<Ty<'tcx>>,\n         mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgAbi<'tcx, Ty<'tcx>>,\n     ) -> Self {\n         debug!(\"FnAbi::new_internal({:?}, {:?})\", sig, extra_args);\n \n+        let sig = cx\n+            .tcx()\n+            .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+\n         use rustc_target::spec::abi::Abi::*;\n         let conv = match cx.tcx().sess.target.target.adjust_abi(sig.abi) {\n-            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::C,\n+            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::Rust,\n \n             // It's the ABI's job to select this, not ours.\n             System => bug!(\"system abi should be selected elsewhere\"),\n@@ -2526,9 +2612,16 @@ where\n \n             if let Some(pointee) = layout.pointee_info_at(cx, offset) {\n                 if let Some(kind) = pointee.safe {\n-                    attrs.pointee_size = pointee.size;\n                     attrs.pointee_align = Some(pointee.align);\n \n+                    // `Box` (`UniqueBorrowed`) are not necessarily dereferencable\n+                    // for the entire duration of the function as they can be deallocated\n+                    // any time. Set their valid size to 0.\n+                    attrs.pointee_size = match kind {\n+                        PointerKind::UniqueOwned => Size::ZERO,\n+                        _ => pointee.size\n+                    };\n+\n                     // `Box` pointer parameters never alias because ownership is transferred\n                     // `&mut` pointer parameters never alias other parameters,\n                     // or mutable global data\n@@ -2599,6 +2692,7 @@ where\n                 .iter()\n                 .cloned()\n                 .chain(extra_args)\n+                .chain(caller_location)\n                 .enumerate()\n                 .map(|(i, ty)| arg_of(ty, Some(i)))\n                 .collect(),"}, {"sha": "78a31f4e544661f6708057f083bf3a2f85559046", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -18,7 +18,7 @@ use crate::infer::canonical::Canonical;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n-use crate::mir::Body;\n+use crate::mir::ReadOnlyBodyAndCache;\n use crate::mir::interpret::{GlobalId, ErrorHandled};\n use crate::mir::GeneratorLayout;\n use crate::session::CrateDisambiguator;\n@@ -2784,11 +2784,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         };\n \n-        if is_associated_item {\n-            Some(self.associated_item(def_id))\n-        } else {\n-            None\n-        }\n+        is_associated_item.then(|| self.associated_item(def_id))\n     }\n \n     fn associated_item_from_trait_item_ref(self,\n@@ -2985,10 +2981,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns the possibly-auto-generated MIR of a `(DefId, Subst)` pair.\n-    pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n+    pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> ReadOnlyBodyAndCache<'tcx, 'tcx> {\n         match instance {\n             ty::InstanceDef::Item(did) => {\n-                self.optimized_mir(did)\n+                self.optimized_mir(did).unwrap_read_only()\n             }\n             ty::InstanceDef::VtableShim(..) |\n             ty::InstanceDef::ReifyShim(..) |\n@@ -2998,7 +2994,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             ty::InstanceDef::ClosureOnceShim { .. } |\n             ty::InstanceDef::DropGlue(..) |\n             ty::InstanceDef::CloneShim(..) => {\n-                self.mir_shims(instance)\n+                self.mir_shims(instance).unwrap_read_only()\n             }\n         }\n     }\n@@ -3253,7 +3249,7 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ParamEnv<'_> {\n     let unnormalized_env = ty::ParamEnv::new(\n         tcx.intern_predicates(&predicates),\n         traits::Reveal::UserFacing,\n-        if tcx.sess.opts.debugging_opts.chalk { Some(def_id) } else { None }\n+        tcx.sess.opts.debugging_opts.chalk.then_some(def_id),\n     );\n \n     let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::DUMMY_HIR_ID, |id| {"}, {"sha": "745f7d0276d809b28df9739c6e67ef5cbbeba1e1", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -54,7 +54,7 @@ thread_local! {\n }\n \n /// Avoids running any queries during any prints that occur\n-/// during the closure. This may alter the apperance of some\n+/// during the closure. This may alter the appearance of some\n /// types (e.g. forcing verbose printing for opaque types).\n /// This method is used during some queries (e.g. `predicates_of`\n /// for opaque types), to ensure that any debug printing that\n@@ -449,7 +449,7 @@ pub trait PrettyPrinter<'tcx>:\n \n             p!(print(self_ty));\n             if let Some(trait_ref) = trait_ref {\n-                p!(write(\" as \"), print(trait_ref));\n+                p!(write(\" as \"), print(trait_ref.print_only_trait_path()));\n             }\n             Ok(cx)\n         })\n@@ -468,7 +468,7 @@ pub trait PrettyPrinter<'tcx>:\n \n             p!(write(\"impl \"));\n             if let Some(trait_ref) = trait_ref {\n-                p!(print(trait_ref), write(\" for \"));\n+                p!(print(trait_ref.print_only_trait_path()), write(\" for \"));\n             }\n             p!(print(self_ty));\n \n@@ -619,7 +619,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                             p!(\n                                     write(\"{}\", if first { \" \" } else { \"+\" }),\n-                                    print(trait_ref));\n+                                    print(trait_ref.print_only_trait_path()));\n                             first = false;\n                         }\n                     }\n@@ -682,7 +682,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // FIXME(eddyb) should use `def_span`.\n                 if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n                     if self.tcx().sess.opts.debugging_opts.span_free_formats {\n-                        p!(write(\"@{:?}\", hir_id));\n+                        p!(write(\"@\"), print_def_path(did, substs));\n                     } else {\n                         p!(write(\"@{:?}\", self.tcx().hir().span(hir_id)));\n                     }\n@@ -1282,6 +1282,9 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n             if !self.empty_path {\n                 write!(self, \"::\")?;\n             }\n+            if ast::Ident::from_str(&name).is_raw_guess() {\n+                write!(self, \"r#\")?;\n+            }\n             write!(self, \"{}\", name)?;\n \n             // FIXME(eddyb) this will print e.g. `{{closure}}#3`, but it\n@@ -1696,6 +1699,30 @@ impl fmt::Display for ty::RegionKind {\n     }\n }\n \n+/// Wrapper type for `ty::TraitRef` which opts-in to pretty printing only\n+/// the trait path. That is, it will print `Trait<U>` instead of\n+/// `<T as Trait<U>>`.\n+#[derive(Copy, Clone, TypeFoldable, Lift)]\n+pub struct TraitRefPrintOnlyTraitPath<'tcx>(ty::TraitRef<'tcx>);\n+\n+impl fmt::Debug for TraitRefPrintOnlyTraitPath<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl ty::TraitRef<'tcx> {\n+    pub fn print_only_trait_path(self) -> TraitRefPrintOnlyTraitPath<'tcx> {\n+        TraitRefPrintOnlyTraitPath(self)\n+    }\n+}\n+\n+impl ty::Binder<ty::TraitRef<'tcx>> {\n+    pub fn print_only_trait_path(self) -> ty::Binder<TraitRefPrintOnlyTraitPath<'tcx>> {\n+        self.map_bound(|tr| tr.print_only_trait_path())\n+    }\n+}\n+\n forward_display_to_print! {\n     Ty<'tcx>,\n     &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n@@ -1705,6 +1732,7 @@ forward_display_to_print! {\n     // because `for<'tcx>` isn't possible yet.\n     ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n     ty::Binder<ty::TraitRef<'tcx>>,\n+    ty::Binder<TraitRefPrintOnlyTraitPath<'tcx>>,\n     ty::Binder<ty::FnSig<'tcx>>,\n     ty::Binder<ty::TraitPredicate<'tcx>>,\n     ty::Binder<ty::SubtypePredicate<'tcx>>,\n@@ -1739,7 +1767,7 @@ define_print_and_forward_display! {\n         // Use a type that can't appear in defaults of type parameters.\n         let dummy_self = cx.tcx().mk_ty_infer(ty::FreshTy(0));\n         let trait_ref = self.with_self_ty(cx.tcx(), dummy_self);\n-        p!(print(trait_ref))\n+        p!(print(trait_ref.print_only_trait_path()))\n     }\n \n     ty::ExistentialProjection<'tcx> {\n@@ -1783,7 +1811,11 @@ define_print_and_forward_display! {\n     }\n \n     ty::TraitRef<'tcx> {\n-        p!(print_def_path(self.def_id, self.substs));\n+        p!(write(\"<{} as {}>\", self.self_ty(), self.print_only_trait_path()))\n+    }\n+\n+    TraitRefPrintOnlyTraitPath<'tcx> {\n+        p!(print_def_path(self.0.def_id, self.0.substs));\n     }\n \n     ty::ParamTy {\n@@ -1799,7 +1831,8 @@ define_print_and_forward_display! {\n     }\n \n     ty::TraitPredicate<'tcx> {\n-        p!(print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n+        p!(print(self.trait_ref.self_ty()), write(\": \"),\n+           print(self.trait_ref.print_only_trait_path()))\n     }\n \n     ty::ProjectionPredicate<'tcx> {"}, {"sha": "2f30b797fb1516d11c4ecd31bd1398e9802a3655", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -303,13 +303,8 @@ fn connected_to_root<'tcx>(\n         return true;\n     }\n \n-    visit_waiters(query, |_, successor| {\n-        if connected_to_root(successor, visited) {\n-            Some(None)\n-        } else {\n-            None\n-        }\n-    }).is_some()\n+    visit_waiters(query, |_, successor| connected_to_root(successor, visited).then_some(None))\n+        .is_some()\n }\n \n // Deterministically pick an query from a list"}, {"sha": "5b4a6ac8a2d3cbac65ea5bc2c35792babac277c1", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -56,7 +56,6 @@ use std::any::type_name;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::attr;\n use syntax::ast;\n-use syntax::feature_gate;\n use syntax::symbol::Symbol;\n \n #[macro_use]"}, {"sha": "ce76a4c831b58772c79b37683a3d17051d855033", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -3,6 +3,7 @@\n //! hand, though we've recently added some macros and proc-macros to help with the tedium.\n \n use crate::hir::def::Namespace;\n+use crate::hir::def_id::CRATE_DEF_INDEX;\n use crate::mir::ProjectionKind;\n use crate::mir::interpret;\n use crate::ty::{self, Lift, Ty, TyCtxt, InferConst};\n@@ -95,8 +96,11 @@ impl fmt::Debug for ty::BoundRegion {\n         match *self {\n             ty::BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n             ty::BrNamed(did, name) => {\n-                write!(f, \"BrNamed({:?}:{:?}, {})\",\n-                        did.krate, did.index, name)\n+                if did.index == CRATE_DEF_INDEX {\n+                    write!(f, \"BrNamed({})\", name)\n+                } else {\n+                    write!(f, \"BrNamed({:?}, {})\", did, name)\n+                }\n             }\n             ty::BrEnv => write!(f, \"BrEnv\"),\n         }\n@@ -223,10 +227,7 @@ impl fmt::Debug for ty::FloatVarValue {\n \n impl fmt::Debug for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // FIXME(#59188) this is used across the compiler to print\n-        // a `TraitRef` qualified (with the Self type explicit),\n-        // instead of having a different way to make that choice.\n-        write!(f, \"<{} as {}>\", self.self_ty(), self)\n+        fmt::Display::fmt(self, f)\n     }\n }\n "}, {"sha": "6cb0d1e9946b597ce41724b53c6ca9d3f5fe96b6", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -69,7 +69,7 @@ pub enum BoundRegion {\n impl BoundRegion {\n     pub fn is_named(&self) -> bool {\n         match *self {\n-            BoundRegion::BrNamed(..) => true,\n+            BoundRegion::BrNamed(_, name) => name != kw::UnderscoreLifetime,\n             _ => false,\n         }\n     }\n@@ -2330,22 +2330,43 @@ impl<'tcx> Const<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env: ParamEnv<'tcx>,\n     ) -> &Const<'tcx> {\n-        // FIXME(const_generics): this doesn't work right now,\n-        // because it tries to relate an `Infer` to a `Param`.\n+        let try_const_eval = |did, param_env: ParamEnv<'tcx>, substs| {\n+            let param_env_and_substs = param_env.with_reveal_all().and(substs);\n+\n+            // Avoid querying `tcx.const_eval(...)` with any e.g. inference vars.\n+            if param_env_and_substs.has_local_value() {\n+                return None;\n+            }\n+\n+            let (param_env, substs) = param_env_and_substs.into_parts();\n+\n+            // try to resolve e.g. associated constants to their definition on an impl\n+            let instance = ty::Instance::resolve(tcx, param_env, did, substs)?;\n+            let gid = GlobalId {\n+                instance,\n+                promoted: None,\n+            };\n+            tcx.const_eval(param_env.and(gid)).ok()\n+        };\n+\n         match self.val {\n             ConstKind::Unevaluated(did, substs) => {\n-                // if `substs` has no unresolved components, use and empty param_env\n-                let (param_env, substs) = param_env.with_reveal_all().and(substs).into_parts();\n-                // try to resolve e.g. associated constants to their definition on an impl\n-                let instance = match ty::Instance::resolve(tcx, param_env, did, substs) {\n-                    Some(instance) => instance,\n-                    None => return self,\n-                };\n-                let gid = GlobalId {\n-                    instance,\n-                    promoted: None,\n-                };\n-                tcx.const_eval(param_env.and(gid)).unwrap_or(self)\n+                // HACK(eddyb) when substs contain e.g. inference variables,\n+                // attempt using identity substs instead, that will succeed\n+                // when the expression doesn't depend on any parameters.\n+                // FIXME(eddyb) make `const_eval` a canonical query instead,\n+                // that would properly handle inference variables in `substs`.\n+                if substs.has_local_value() {\n+                    let identity_substs = InternalSubsts::identity_for_item(tcx, did);\n+                    // The `ParamEnv` needs to match the `identity_substs`.\n+                    let identity_param_env = tcx.param_env(did);\n+                    match try_const_eval(did, identity_param_env, identity_substs) {\n+                        Some(ct) => ct.subst(tcx, substs),\n+                        None => self,\n+                    }\n+                } else {\n+                    try_const_eval(did, param_env, substs).unwrap_or(self)\n+                }\n             },\n             _ => self,\n         }"}, {"sha": "0b11a9efd81d7a5a387c9fae1b58edb9c60ff431", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -682,6 +682,23 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.static_mutability(def_id) == Some(hir::Mutability::Mutable)\n     }\n \n+    /// Get the type of the pointer to the static that we use in MIR.\n+    pub fn static_ptr_ty(&self, def_id: DefId) -> Ty<'tcx> {\n+        // Make sure that any constants in the static's type are evaluated.\n+        let static_ty = self.normalize_erasing_regions(\n+            ty::ParamEnv::empty(),\n+            self.type_of(def_id),\n+        );\n+\n+        if self.is_mutable_static(def_id) {\n+            self.mk_mut_ptr(static_ty)\n+        } else if self.is_foreign_item(def_id) {\n+            self.mk_imm_ptr(static_ty)\n+        } else {\n+            self.mk_imm_ref(self.lifetimes.re_erased, static_ty)\n+        }\n+    }\n+\n     /// Expands the given impl trait type, stopping if the type is recursive.\n     pub fn try_expand_impl_trait_type(\n         self,"}, {"sha": "7515d30e469945fa9005812ef86fadddefd6fa71", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -7,7 +7,6 @@ use std::fmt::Debug;\n use std::time::{Duration, Instant};\n \n use syntax::symbol::{Symbol, sym};\n-use rustc_macros::HashStable;\n use crate::session::Session;\n \n #[cfg(test)]\n@@ -16,10 +15,7 @@ mod tests;\n // The name of the associated type for `Fn` return types.\n pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n \n-// Useful type to use with `Result<>` indicate that an error has already\n-// been reported to the user, so no need to continue checking.\n-#[derive(Clone, Copy, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct ErrorReported;\n+pub use errors::ErrorReported;\n \n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));\n \n@@ -92,15 +88,7 @@ pub fn print_time_passes_entry(do_it: bool, what: &str, dur: Duration) {\n              what);\n }\n \n-// Hack up our own formatting for the duration to make it easier for scripts\n-// to parse (always use the same number of decimal places and the same unit).\n-pub fn duration_to_secs_str(dur: Duration) -> String {\n-    const NANOS_PER_SEC: f64 = 1_000_000_000.0;\n-    let secs = dur.as_secs() as f64 +\n-               dur.subsec_nanos() as f64 / NANOS_PER_SEC;\n-\n-    format!(\"{:.3}\", secs)\n-}\n+pub use rustc_session::utils::duration_to_secs_str;\n \n pub fn to_readable_str(mut val: usize) -> String {\n     let mut groups = vec![];"}, {"sha": "1f3c8e1953e4f1709f2df3771f626ef37fae38f1", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -372,7 +372,7 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n \n     fn llvm_cconv(&self) -> llvm::CallConv {\n         match self.conv {\n-            Conv::C => llvm::CCallConv,\n+            Conv::C | Conv::Rust => llvm::CCallConv,\n             Conv::AmdGpuKernel => llvm::AmdGpuKernel,\n             Conv::ArmAapcs => llvm::ArmAapcsCallConv,\n             Conv::Msp430Intr => llvm::Msp430Intr,\n@@ -388,6 +388,11 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     }\n \n     fn apply_attrs_llfn(&self, cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value) {\n+        // FIXME(eddyb) can this also be applied to callsites?\n+        if self.ret.layout.abi.is_uninhabited() {\n+            llvm::Attribute::NoReturn.apply_llfn(llvm::AttributePlace::Function, llfn);\n+        }\n+\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes, ty: Option<&Type>| {\n             attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn, ty);"}, {"sha": "1ea9362dc4260ea16c52a90cac5518903533a1ba", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -2,19 +2,20 @@\n \n use std::ffi::CString;\n \n-use rustc::hir::{CodegenFnAttrFlags, CodegenFnAttrs};\n+use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::session::Session;\n use rustc::session::config::{Sanitizer, OptLevel};\n-use rustc::ty::{self, TyCtxt, PolyFnSig};\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::ty::layout::HasTyCtxt;\n use rustc::ty::query::Providers;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_target::abi::call::Conv;\n use rustc_target::spec::PanicStrategy;\n use rustc_codegen_ssa::traits::*;\n \n-use crate::abi::Abi;\n+use crate::abi::FnAbi;\n use crate::attributes;\n use crate::llvm::{self, Attribute};\n use crate::llvm::AttributePlace::Function;\n@@ -26,7 +27,7 @@ use crate::value::Value;\n \n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n-pub fn inline(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n+fn inline(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n         Hint   => Attribute::InlineHint.apply_llfn(Function, val),\n@@ -58,7 +59,7 @@ fn unwind(val: &'ll Value, can_unwind: bool) {\n \n /// Tell LLVM if this function should be 'naked', i.e., skip the epilogue and prologue.\n #[inline]\n-pub fn naked(val: &'ll Value, is_naked: bool) {\n+fn naked(val: &'ll Value, is_naked: bool) {\n     Attribute::Naked.toggle_llfn(Function, val, is_naked);\n }\n \n@@ -72,7 +73,7 @@ pub fn set_frame_pointer_elimination(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value)\n \n /// Tell LLVM what instrument function to insert.\n #[inline]\n-pub fn set_instrument_function(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+fn set_instrument_function(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     if cx.sess().instrument_mcount() {\n         // Similar to `clang -pg` behavior. Handled by the\n         // `post-inline-ee-instrument` LLVM pass.\n@@ -88,7 +89,7 @@ pub fn set_instrument_function(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     }\n }\n \n-pub fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     // Only use stack probes if the target specification indicates that we\n     // should be using stack probes\n     if !cx.sess().target.target.options.stack_probes {\n@@ -202,11 +203,10 @@ pub(crate) fn default_optimisation_attrs(sess: &Session, llfn: &'ll Value) {\n pub fn from_fn_attrs(\n     cx: &CodegenCx<'ll, 'tcx>,\n     llfn: &'ll Value,\n-    id: Option<DefId>,\n-    sig: PolyFnSig<'tcx>,\n+    instance: ty::Instance<'tcx>,\n+    fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n ) {\n-    let codegen_fn_attrs = id.map(|id| cx.tcx.codegen_fn_attrs(id))\n-        .unwrap_or_else(|| CodegenFnAttrs::new());\n+    let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n \n     match codegen_fn_attrs.optimize {\n         OptimizeAttr::None => {\n@@ -224,6 +224,11 @@ pub fn from_fn_attrs(\n         }\n     }\n \n+    // FIXME(eddyb) consolidate these two `inline` calls (and avoid overwrites).\n+    if instance.def.is_inline(cx.tcx) {\n+        inline(cx, llfn, attributes::InlineAttr::Hint);\n+    }\n+\n     inline(cx, llfn, codegen_fn_attrs.inline);\n \n     // The `uwtable` attribute according to LLVM is:\n@@ -276,8 +281,7 @@ pub fn from_fn_attrs(\n         // Special attribute for allocator functions, which can't unwind.\n         false\n     } else {\n-        let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        if sig.abi == Abi::Rust || sig.abi == Abi::RustCall {\n+        if fn_abi.conv == Conv::Rust {\n             // Any Rust method (or `extern \"Rust\" fn` or `extern\n             // \"rust-call\" fn`) is explicitly allowed to unwind\n             // (unless it has no-unwind attribute, handled above).\n@@ -331,16 +335,14 @@ pub fn from_fn_attrs(\n     // Note that currently the `wasm-import-module` doesn't do anything, but\n     // eventually LLVM 7 should read this and ferry the appropriate import\n     // module to the output file.\n-    if let Some(id) = id {\n-        if cx.tcx.sess.target.target.arch == \"wasm32\" {\n-            if let Some(module) = wasm_import_module(cx.tcx, id) {\n-                llvm::AddFunctionAttrStringValue(\n-                    llfn,\n-                    llvm::AttributePlace::Function,\n-                    const_cstr!(\"wasm-import-module\"),\n-                    &module,\n-                );\n-            }\n+    if cx.tcx.sess.target.target.arch == \"wasm32\" {\n+        if let Some(module) = wasm_import_module(cx.tcx, instance.def_id()) {\n+            llvm::AddFunctionAttrStringValue(\n+                llfn,\n+                llvm::AttributePlace::Function,\n+                const_cstr!(\"wasm-import-module\"),\n+                &module,\n+            );\n         }\n     }\n }\n@@ -373,11 +375,7 @@ pub fn provide_extern(providers: &mut Providers<'_>) {\n         let native_libs = tcx.native_libraries(cnum);\n \n         let def_id_to_native_lib = native_libs.iter().filter_map(|lib|\n-            if let Some(id) = lib.foreign_module {\n-                Some((id, lib))\n-            } else {\n-                None\n-            }\n+            lib.foreign_module.map(|id| (id, lib))\n         ).collect::<FxHashMap<_, _>>();\n \n         let mut ret = FxHashMap::default();"}, {"sha": "858dd59b26148f57159d59e90ca865b623872122", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -10,7 +10,7 @@ use rustc_codegen_ssa::back::lto::{SerializedModule, LtoModuleCodegen, ThinShare\n use rustc_codegen_ssa::traits::*;\n use errors::{FatalError, Handler};\n use rustc::dep_graph::WorkProduct;\n-use rustc::dep_graph::cgu_reuse_tracker::CguReuse;\n+use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{self, Lto};\n@@ -541,7 +541,7 @@ pub(crate) fn run_pass_manager(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     debug!(\"running the pass manager\");\n     unsafe {\n         let pm = llvm::LLVMCreatePassManager();\n-        llvm::LLVMRustAddAnalysisPasses(module.module_llvm.tm, pm, module.module_llvm.llmod());\n+        llvm::LLVMAddAnalysisPasses(module.module_llvm.tm, pm);\n \n         if config.verify_llvm_ir {\n             let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr().cast());"}, {"sha": "ada29c350ad04b7ac2254d1a2dc604fe2c01bae1", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -22,7 +22,7 @@ use rustc_fs_util::{path_to_c_string, link_or_copy};\n use rustc_data_structures::small_c_str::SmallCStr;\n use errors::{Handler, FatalError};\n \n-use std::ffi::{CString, CStr};\n+use std::ffi::CString;\n use std::fs;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n@@ -167,7 +167,7 @@ pub fn target_machine_factory(sess: &Session, optlvl: config::OptLevel, find_fea\n     let emit_stack_size_section = sess.opts.debugging_opts.emit_stack_sizes;\n \n     let asm_comments = sess.asm_comments();\n-\n+    let relax_elf_relocations = sess.target.target.options.relax_elf_relocations;\n     Arc::new(move || {\n         let tm = unsafe {\n             llvm::LLVMRustCreateTargetMachine(\n@@ -183,6 +183,7 @@ pub fn target_machine_factory(sess: &Session, optlvl: config::OptLevel, find_fea\n                 singlethread,\n                 asm_comments,\n                 emit_stack_size_section,\n+                relax_elf_relocations,\n             )\n         };\n \n@@ -365,27 +366,13 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n \n             add_sanitizer_passes(config, &mut extra_passes);\n \n-            for pass_name in &cgcx.plugin_passes {\n-                if let Some(pass) = find_pass(pass_name) {\n-                    extra_passes.push(pass);\n-                } else {\n-                    diag_handler.err(&format!(\"a plugin asked for LLVM pass \\\n-                                               `{}` but LLVM does not \\\n-                                               recognize it\", pass_name));\n-                }\n-\n-                if pass_name == \"name-anon-globals\" {\n-                    have_name_anon_globals_pass = true;\n-                }\n-            }\n-\n             // Some options cause LLVM bitcode to be emitted, which uses ThinLTOBuffers, so we need\n             // to make sure we run LLVM's NameAnonGlobals pass when emitting bitcode; otherwise\n             // we'll get errors in LLVM.\n             let using_thin_buffers = config.bitcode_needed();\n             if !config.no_prepopulate_passes {\n-                llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n-                llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n+                llvm::LLVMAddAnalysisPasses(tm, fpm);\n+                llvm::LLVMAddAnalysisPasses(tm, mpm);\n                 let opt_level = to_llvm_opt_settings(opt_level).0;\n                 let prepare_for_thin_lto = cgcx.lto == Lto::Thin || cgcx.lto == Lto::ThinLocal ||\n                     (cgcx.lto != Lto::Fat && cgcx.opts.cg.linker_plugin_lto.enabled());\n@@ -509,7 +496,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             where F: FnOnce(&'ll mut PassManager<'ll>) -> R,\n         {\n             let cpm = llvm::LLVMCreatePassManager();\n-            llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n+            llvm::LLVMAddAnalysisPasses(tm, cpm);\n             llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n             f(cpm)\n         }\n@@ -601,14 +588,11 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                     cursor.position() as size_t\n                 }\n \n-                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                    let result =\n-                        llvm::LLVMRustPrintModule(cpm, llmod, out_c.as_ptr(), demangle_callback);\n-                    llvm::LLVMDisposePassManager(cpm);\n-                    result.into_result().map_err(|()| {\n-                        let msg = format!(\"failed to write LLVM IR to {}\", out.display());\n-                        llvm_err(diag_handler, &msg)\n-                    })\n+                let result =\n+                    llvm::LLVMRustPrintModule(llmod, out_c.as_ptr(), demangle_callback);\n+                result.into_result().map_err(|()| {\n+                    let msg = format!(\"failed to write LLVM IR to {}\", out.display());\n+                    llvm_err(diag_handler, &msg)\n                 })?;\n             }\n \n@@ -849,16 +833,16 @@ fn create_msvc_imps(\n             })\n             .filter_map(|val| {\n                 // Exclude some symbols that we know are not Rust symbols.\n-                let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                if ignored(name.to_bytes()) {\n+                let name = llvm::get_value_name(val);\n+                if ignored(name) {\n                     None\n                 } else {\n                     Some((val, name))\n                 }\n             })\n             .map(move |(val, name)| {\n                 let mut imp_name = prefix.as_bytes().to_vec();\n-                imp_name.extend(name.to_bytes());\n+                imp_name.extend(name);\n                 let imp_name = CString::new(imp_name).unwrap();\n                 (imp_name, val)\n             })"}, {"sha": "6f72466c559dc82484a318b71b087474fb51e233", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -325,8 +325,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         use rustc::ty::{Int, Uint};\n \n         let new_kind = match ty.kind {\n-            Int(Isize) => Int(self.tcx.sess.target.isize_ty),\n-            Uint(Usize) => Uint(self.tcx.sess.target.usize_ty),\n+            Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.ptr_width)),\n+            Uint(t @ Usize) => Uint(t.normalize(self.tcx.sess.target.ptr_width)),\n             ref t @ Uint(_) | ref t @ Int(_) => t.clone(),\n             _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\")\n         };"}, {"sha": "e0db7cae99e1ae8ed2a9756f513baa13268e0215", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -4,14 +4,15 @@\n //! and methods are represented as just a fn ptr and not a full\n //! closure.\n \n+use crate::abi::{FnAbi, FnAbiLlvmExt};\n use crate::attributes;\n use crate::llvm;\n use crate::context::CodegenCx;\n use crate::value::Value;\n use rustc_codegen_ssa::traits::*;\n \n use rustc::ty::{TypeFoldable, Instance};\n-use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n+use rustc::ty::layout::{FnAbiExt, HasTyCtxt};\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n@@ -32,19 +33,19 @@ pub fn get_fn(\n     assert!(!instance.substs.has_escaping_bound_vars());\n     assert!(!instance.substs.has_param_types());\n \n-    let sig = instance.fn_sig(cx.tcx());\n     if let Some(&llfn) = cx.instances.borrow().get(&instance) {\n         return llfn;\n     }\n \n     let sym = tcx.symbol_name(instance).name.as_str();\n-    debug!(\"get_fn({:?}: {:?}) => {}\", instance, sig, sym);\n+    debug!(\"get_fn({:?}: {:?}) => {}\", instance, instance.ty(cx.tcx()), sym);\n \n-    // Create a fn pointer with the substituted signature.\n-    let fn_ptr_ty = tcx.mk_fn_ptr(sig);\n-    let llptrty = cx.backend_type(cx.layout_of(fn_ptr_ty));\n+    let fn_abi = FnAbi::of_instance(cx, instance, &[]);\n \n     let llfn = if let Some(llfn) = cx.get_declared_value(&sym) {\n+        // Create a fn pointer with the new signature.\n+        let llptrty = fn_abi.ptr_to_llvm_type(cx);\n+\n         // This is subtle and surprising, but sometimes we have to bitcast\n         // the resulting fn pointer.  The reason has to do with external\n         // functions.  If you have two crates that both bind the same C\n@@ -76,14 +77,10 @@ pub fn get_fn(\n             llfn\n         }\n     } else {\n-        let llfn = cx.declare_fn(&sym, sig);\n-        assert_eq!(cx.val_ty(llfn), llptrty);\n+        let llfn = cx.declare_fn(&sym, &fn_abi);\n         debug!(\"get_fn: not casting pointer!\");\n \n-        if instance.def.is_inline(tcx) {\n-            attributes::inline(cx, llfn, attributes::InlineAttr::Hint);\n-        }\n-        attributes::from_fn_attrs(cx, llfn, Some(instance.def.def_id()), sig);\n+        attributes::from_fn_attrs(cx, llfn, instance, &fn_abi);\n \n         let instance_def_id = instance.def_id();\n "}, {"sha": "419e99d55d72d703d8895fa97422f8df6fb622b9", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -245,11 +245,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             let (mut lo, mut hi) = (0u64, 0u64);\n             let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n                                                         &mut hi, &mut lo);\n-            if success {\n-                Some(hi_lo_to_u128(lo, hi))\n-            } else {\n-                None\n-            }\n+            success.then_some(hi_lo_to_u128(lo, hi))\n         })\n     }\n "}, {"sha": "297aff93a9d28d2a67fb2febfe7e50a3cb3ad425", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -21,7 +21,7 @@ use rustc::ty::layout::{self, Size, Align, LayoutOf};\n \n use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n \n-use std::ffi::{CStr, CString};\n+use std::ffi::CStr;\n \n pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n     let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n@@ -233,11 +233,13 @@ impl CodegenCx<'ll, 'tcx> {\n                     ref attrs, span, kind: hir::ItemKind::Static(..), ..\n                 }) => {\n                     let sym_str = sym.as_str();\n-                    if self.get_declared_value(&sym_str).is_some() {\n-                        span_bug!(span, \"Conflicting symbol names for static?\");\n+                    if let Some(g) = self.get_declared_value(&sym_str) {\n+                        if self.val_ty(g) != self.type_ptr_to(llty) {\n+                            span_bug!(span, \"Conflicting types for static\");\n+                        }\n                     }\n \n-                    let g = self.define_global(&sym_str, llty).unwrap();\n+                    let g = self.declare_global(&sym_str, llty);\n \n                     if !self.tcx.is_reachable_non_generic(def_id) {\n                         unsafe {\n@@ -390,16 +392,14 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n             } else {\n                 // If we created the global with the wrong type,\n                 // correct the type.\n-                let empty_string = const_cstr!(\"\");\n-                let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(g));\n-                let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n-                llvm::LLVMSetValueName(g, empty_string.as_ptr());\n+                let name = llvm::get_value_name(g).to_vec();\n+                llvm::set_value_name(g, b\"\");\n \n                 let linkage = llvm::LLVMRustGetLinkage(g);\n                 let visibility = llvm::LLVMRustGetVisibility(g);\n \n                 let new_g = llvm::LLVMRustGetOrInsertGlobal(\n-                    self.llmod, name_string.as_ptr(), val_llty);\n+                    self.llmod, name.as_ptr().cast(), name.len(), val_llty);\n \n                 llvm::LLVMRustSetLinkage(new_g, linkage);\n                 llvm::LLVMRustSetVisibility(new_g, visibility);"}, {"sha": "39ea1f6f5dccf0be55a8dc59f7064befd9fcb99e", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,3 +1,4 @@\n+use crate::abi::FnAbi;\n use crate::attributes;\n use crate::llvm;\n use crate::llvm_util;\n@@ -15,7 +16,7 @@ use rustc::mir::mono::CodegenUnit;\n use rustc::session::config::{self, DebugInfo};\n use rustc::session::Session;\n use rustc::ty::layout::{\n-    LayoutError, LayoutOf, PointeeInfo, Size, TyLayout, VariantIdx, HasParamEnv\n+    FnAbiExt, LayoutError, LayoutOf, PointeeInfo, Size, TyLayout, VariantIdx, HasParamEnv\n };\n use rustc::ty::{self, Ty, TyCtxt, Instance};\n use rustc::util::nodemap::FxHashMap;\n@@ -420,7 +421,8 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             Abi::C\n         ));\n \n-        let llfn = self.declare_fn(\"rust_eh_unwind_resume\", sig);\n+        let fn_abi = FnAbi::of_fn_ptr(self, sig, &[]);\n+        let llfn = self.declare_fn(\"rust_eh_unwind_resume\", &fn_abi);\n         attributes::apply_target_cpu_attr(self, llfn);\n         unwresume.set(Some(llfn));\n         llfn"}, {"sha": "91d5a22b0228d4bcc184a1ba336b814683f2784d", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -23,12 +23,10 @@ pub fn compute_mir_scopes(\n ) {\n     // Find all the scopes with variables defined in them.\n     let mut has_variables = BitSet::new_empty(mir.source_scopes.len());\n-    // FIXME(eddyb) base this on `decl.name`, or even better, on debuginfo.\n     // FIXME(eddyb) take into account that arguments always have debuginfo,\n     // irrespective of their name (assuming full debuginfo is enabled).\n-    for var in mir.vars_iter() {\n-        let decl = &mir.local_decls[var];\n-        has_variables.insert(decl.visibility_scope);\n+    for var_debug_info in &mir.var_debug_info {\n+        has_variables.insert(var_debug_info.source_info.scope);\n     }\n \n     // Instantiate all scopes."}, {"sha": "1847e4e9fa951963091cc616ae2d98b1477e44ff", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 80, "deletions": 20, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -17,13 +17,13 @@ use crate::llvm_util;\n use crate::value::Value;\n \n use rustc_codegen_ssa::traits::*;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ich::NodeIdHashingMode;\n-use rustc::mir::Field;\n-use rustc::mir::GeneratorLayout;\n+use rustc::mir::{self, Field, GeneratorLayout};\n use rustc::mir::interpret::truncate;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::ty::Instance;\n@@ -1316,6 +1316,45 @@ fn use_enum_fallback(cx: &CodegenCx<'_, '_>) -> bool {\n         || llvm_util::get_major_version() < 8;\n }\n \n+// FIXME(eddyb) maybe precompute this? Right now it's computed once\n+// per generator monomorphization, but it doesn't depend on substs.\n+fn generator_layout_and_saved_local_names(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+) -> (&'tcx GeneratorLayout<'tcx>, IndexVec<mir::GeneratorSavedLocal, Option<ast::Name>>) {\n+    let body = tcx.optimized_mir(def_id);\n+    let generator_layout = body.generator_layout.as_ref().unwrap();\n+    let mut generator_saved_local_names =\n+        IndexVec::from_elem(None, &generator_layout.field_tys);\n+\n+    let state_arg = mir::PlaceBase::Local(mir::Local::new(1));\n+    for var in &body.var_debug_info {\n+        if var.place.base != state_arg {\n+            continue;\n+        }\n+        match var.place.projection[..] {\n+            [\n+                // Deref of the `Pin<&mut Self>` state argument.\n+                mir::ProjectionElem::Field(..),\n+                mir::ProjectionElem::Deref,\n+\n+                // Field of a variant of the state.\n+                mir::ProjectionElem::Downcast(_, variant),\n+                mir::ProjectionElem::Field(field, _),\n+            ] => {\n+                let name = &mut generator_saved_local_names[\n+                    generator_layout.variant_fields[variant][field]\n+                ];\n+                if name.is_none() {\n+                    name.replace(var.name);\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    (generator_layout, generator_saved_local_names)\n+}\n+\n /// Describes the members of an enum value; an enum is described as a union of\n /// structs in DWARF. This `MemberDescriptionFactory` provides the description for\n /// the members of this union; so for every variant of the given enum, this\n@@ -1332,12 +1371,25 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n                                   -> Vec<MemberDescription<'ll>> {\n+        let generator_variant_info_data = match self.enum_type.kind {\n+            ty::Generator(def_id, ..) => {\n+                Some(generator_layout_and_saved_local_names(cx.tcx, def_id))\n+            }\n+            _ => None,\n+        };\n+\n         let variant_info_for = |index: VariantIdx| {\n-            match &self.enum_type.kind {\n+            match self.enum_type.kind {\n                 ty::Adt(adt, _) => VariantInfo::Adt(&adt.variants[index]),\n-                ty::Generator(def_id, substs, _) => {\n-                    let generator_layout = cx.tcx.generator_layout(*def_id);\n-                    VariantInfo::Generator(substs, generator_layout, index)\n+                ty::Generator(_, substs, _) => {\n+                    let (generator_layout, generator_saved_local_names) =\n+                        generator_variant_info_data.as_ref().unwrap();\n+                    VariantInfo::Generator {\n+                        substs,\n+                        generator_layout: *generator_layout,\n+                        generator_saved_local_names,\n+                        variant_index: index,\n+                    }\n                 }\n                 _ => bug!(),\n             }\n@@ -1608,24 +1660,29 @@ enum EnumDiscriminantInfo<'ll> {\n }\n \n #[derive(Copy, Clone)]\n-enum VariantInfo<'tcx> {\n+enum VariantInfo<'a, 'tcx> {\n     Adt(&'tcx ty::VariantDef),\n-    Generator(SubstsRef<'tcx>, &'tcx GeneratorLayout<'tcx>, VariantIdx),\n+    Generator {\n+        substs: SubstsRef<'tcx>,\n+        generator_layout: &'tcx GeneratorLayout<'tcx>,\n+        generator_saved_local_names: &'a IndexVec<mir::GeneratorSavedLocal, Option<ast::Name>>,\n+        variant_index: VariantIdx,\n+    },\n }\n \n-impl<'tcx> VariantInfo<'tcx> {\n+impl<'tcx> VariantInfo<'_, 'tcx> {\n     fn map_struct_name<R>(&self, f: impl FnOnce(&str) -> R) -> R {\n         match self {\n             VariantInfo::Adt(variant) => f(&variant.ident.as_str()),\n-            VariantInfo::Generator(substs, _, variant_index) =>\n+            VariantInfo::Generator { substs, variant_index, .. } =>\n                 f(&substs.as_generator().variant_name(*variant_index)),\n         }\n     }\n \n     fn variant_name(&self) -> String {\n         match self {\n             VariantInfo::Adt(variant) => variant.ident.to_string(),\n-            VariantInfo::Generator(_, _, variant_index) => {\n+            VariantInfo::Generator { variant_index, .. } => {\n                 // Since GDB currently prints out the raw discriminant along\n                 // with every variant, make each variant name be just the value\n                 // of the discriminant. The struct name for the variant includes\n@@ -1636,17 +1693,20 @@ impl<'tcx> VariantInfo<'tcx> {\n     }\n \n     fn field_name(&self, i: usize) -> String {\n-        let field_name = match self {\n+        let field_name = match *self {\n             VariantInfo::Adt(variant) if variant.ctor_kind != CtorKind::Fn =>\n-                Some(variant.fields[i].ident.to_string()),\n-            VariantInfo::Generator(_, generator_layout, variant_index) => {\n-                let field = generator_layout.variant_fields[*variant_index][i.into()];\n-                let decl = &generator_layout.__local_debuginfo_codegen_only_do_not_use[field];\n-                decl.name.map(|name| name.to_string())\n-            }\n+                Some(variant.fields[i].ident.name),\n+            VariantInfo::Generator {\n+                generator_layout,\n+                generator_saved_local_names,\n+                variant_index,\n+                ..\n+            } => generator_saved_local_names[\n+                generator_layout.variant_fields[variant_index][i.into()]\n+            ],\n             _ => None,\n         };\n-        field_name.unwrap_or_else(|| format!(\"__{}\", i))\n+        field_name.map(|name| name.to_string()).unwrap_or_else(|| format!(\"__{}\", i))\n     }\n }\n \n@@ -1657,7 +1717,7 @@ impl<'tcx> VariantInfo<'tcx> {\n fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n     layout: layout::TyLayout<'tcx>,\n-    variant: VariantInfo<'tcx>,\n+    variant: VariantInfo<'_, 'tcx>,\n     discriminant_info: EnumDiscriminantInfo<'ll>,\n     containing_scope: &'ll DIScope,\n     span: Span,"}, {"sha": "a3782ecd92dcd0c4635244dddf6c0916240d40ab", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 20, "deletions": 46, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -16,7 +16,7 @@ use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ty::subst::{SubstsRef, GenericArgKind};\n \n-use crate::abi::Abi;\n+use crate::abi::FnAbi;\n use crate::common::CodegenCx;\n use crate::builder::Builder;\n use crate::value::Value;\n@@ -32,7 +32,7 @@ use rustc_codegen_ssa::mir::debuginfo::{FunctionDebugContext, DebugScope,\n \n use libc::c_uint;\n use std::cell::RefCell;\n-use std::ffi::{CStr, CString};\n+use std::ffi::CString;\n \n use smallvec::SmallVec;\n use syntax_pos::{self, BytePos, Span, Pos};\n@@ -255,23 +255,11 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             return;\n         }\n \n-        let old_name = unsafe {\n-            CStr::from_ptr(llvm::LLVMGetValueName(value))\n-        };\n-        match old_name.to_str() {\n-            Ok(\"\") => {}\n-            Ok(_) => {\n-                // Avoid replacing the name if it already exists.\n-                // While we could combine the names somehow, it'd\n-                // get noisy quick, and the usefulness is dubious.\n-                return;\n-            }\n-            Err(_) => return,\n-        }\n-\n-        let cname = SmallCStr::new(name);\n-        unsafe {\n-            llvm::LLVMSetValueName(value, cname.as_ptr());\n+        // Avoid replacing the name if it already exists.\n+        // While we could combine the names somehow, it'd\n+        // get noisy quick, and the usefulness is dubious.\n+        if llvm::get_value_name(value).is_empty() {\n+            llvm::set_value_name(value, name.as_bytes());\n         }\n     }\n }\n@@ -280,7 +268,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn create_function_debug_context(\n         &self,\n         instance: Instance<'tcx>,\n-        sig: ty::FnSig<'tcx>,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         llfn: &'ll Value,\n         mir: &mir::Body<'_>,\n     ) -> Option<FunctionDebugContext<&'ll DIScope>> {\n@@ -308,7 +296,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let file_metadata = file_metadata(self, &loc.file.name, def_id.krate);\n \n         let function_type_metadata = unsafe {\n-            let fn_signature = get_function_signature(self, sig);\n+            let fn_signature = get_function_signature(self, fn_abi);\n             llvm::LLVMRustDIBuilderCreateSubroutineType(DIB(self), file_metadata, fn_signature)\n         };\n \n@@ -338,7 +326,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         let mut flags = DIFlags::FlagPrototyped;\n \n-        if self.layout_of(sig.output()).abi.is_uninhabited() {\n+        if fn_abi.ret.layout.abi.is_uninhabited() {\n             flags |= DIFlags::FlagNoReturn;\n         }\n \n@@ -392,25 +380,20 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         fn get_function_signature<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n-            sig: ty::FnSig<'tcx>,\n+            fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         ) -> &'ll DIArray {\n             if cx.sess().opts.debuginfo == DebugInfo::Limited {\n                 return create_DIArray(DIB(cx), &[]);\n             }\n \n-            let mut signature = Vec::with_capacity(sig.inputs().len() + 1);\n+            let mut signature = Vec::with_capacity(fn_abi.args.len() + 1);\n \n             // Return type -- llvm::DIBuilder wants this at index 0\n-            signature.push(match sig.output().kind {\n-                ty::Tuple(ref tys) if tys.is_empty() => None,\n-                _ => Some(type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP))\n-            });\n-\n-            let inputs = if sig.abi == Abi::RustCall {\n-                &sig.inputs()[..sig.inputs().len() - 1]\n+            signature.push(if fn_abi.ret.is_ignore() {\n+                None\n             } else {\n-                sig.inputs()\n-            };\n+                Some(type_metadata(cx, fn_abi.ret.layout.ty, syntax_pos::DUMMY_SP))\n+            });\n \n             // Arguments types\n             if cx.sess().target.target.options.is_like_msvc {\n@@ -424,7 +407,8 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 // and a function `fn bar(x: [(); 7])` as `fn bar(x: *const ())`.\n                 // This transformed type is wrong, but these function types are\n                 // already inaccurate due to ABI adjustments (see #42800).\n-                signature.extend(inputs.iter().map(|&t| {\n+                signature.extend(fn_abi.args.iter().map(|arg| {\n+                    let t = arg.layout.ty;\n                     let t = match t.kind {\n                         ty::Array(ct, _)\n                             if (ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() => {\n@@ -435,21 +419,11 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n                 }));\n             } else {\n-                signature.extend(inputs.iter().map(|t| {\n-                    Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n+                signature.extend(fn_abi.args.iter().map(|arg| {\n+                    Some(type_metadata(cx, arg.layout.ty, syntax_pos::DUMMY_SP))\n                 }));\n             }\n \n-            if sig.abi == Abi::RustCall && !sig.inputs().is_empty() {\n-                if let ty::Tuple(args) = sig.inputs()[sig.inputs().len() - 1].kind {\n-                    signature.extend(\n-                        args.iter().map(|argument_type| {\n-                            Some(type_metadata(cx, argument_type.expect_ty(), syntax_pos::DUMMY_SP))\n-                        })\n-                    );\n-                }\n-            }\n-\n             create_DIArray(DIB(cx), &signature[..])\n         }\n "}, {"sha": "fa9fc4653680166e229627366107a9f47b8f16bb", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 4, "deletions": 37, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -18,8 +18,7 @@ use crate::attributes;\n use crate::context::CodegenCx;\n use crate::type_::Type;\n use crate::value::Value;\n-use rustc::ty::{self, PolyFnSig};\n-use rustc::ty::layout::{FnAbiExt, LayoutOf};\n+use rustc::ty::Ty;\n use rustc::session::config::Sanitizer;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_codegen_ssa::traits::*;\n@@ -77,9 +76,8 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         name: &str, ty: &'ll Type\n     ) -> &'ll Value {\n         debug!(\"declare_global(name={:?})\", name);\n-        let namebuf = SmallCStr::new(name);\n         unsafe {\n-            llvm::LLVMRustGetOrInsertGlobal(self.llmod, namebuf.as_ptr(), ty)\n+            llvm::LLVMRustGetOrInsertGlobal(self.llmod, name.as_ptr().cast(), name.len(), ty)\n         }\n     }\n \n@@ -94,21 +92,12 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn declare_fn(\n         &self,\n         name: &str,\n-        sig: PolyFnSig<'tcx>,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n     ) -> &'ll Value {\n-        debug!(\"declare_rust_fn(name={:?}, sig={:?})\", name, sig);\n-        let sig = self.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n+        debug!(\"declare_rust_fn(name={:?}, fn_abi={:?})\", name, fn_abi);\n \n-        let fn_abi = FnAbi::new(self, sig, &[]);\n         let llfn = declare_raw_fn(self, name, fn_abi.llvm_cconv(), fn_abi.llvm_type(self));\n-\n-        if self.layout_of(sig.output()).abi.is_uninhabited() {\n-            llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n-        }\n-\n         fn_abi.apply_attrs_llfn(self, llfn);\n-\n         llfn\n     }\n \n@@ -130,28 +119,6 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn define_fn(\n-        &self,\n-        name: &str,\n-        fn_sig: PolyFnSig<'tcx>,\n-    ) -> &'ll Value {\n-        if self.get_defined_value(name).is_some() {\n-            self.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n-        } else {\n-            self.declare_fn(name, fn_sig)\n-        }\n-    }\n-\n-    fn define_internal_fn(\n-        &self,\n-        name: &str,\n-        fn_sig: PolyFnSig<'tcx>,\n-    ) -> &'ll Value {\n-        let llfn = self.define_fn(name, fn_sig);\n-        unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n-        llfn\n-    }\n-\n     fn get_declared_value(&self, name: &str) -> Option<&'ll Value> {\n         debug!(\"get_declared_value(name={:?})\", name);\n         let namebuf = SmallCStr::new(name);"}, {"sha": "1767ad118e7c0912bd706b9527caabbbdbdaaeee", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -1,4 +1,3 @@\n-use crate::attributes;\n use crate::llvm;\n use crate::llvm_util;\n use crate::abi::{Abi, FnAbi, LlvmType, PassMode};\n@@ -14,7 +13,7 @@ use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::base::{to_immediate, wants_msvc_seh, compare_simd_types};\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, Primitive};\n+use rustc::ty::layout::{self, FnAbiExt, LayoutOf, HasTyCtxt, Primitive};\n use rustc::mir::interpret::GlobalId;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc::hir;\n@@ -442,32 +441,11 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                                 let is_left = name == \"rotate_left\";\n                                 let val = args[0].immediate();\n                                 let raw_shift = args[1].immediate();\n-                                if llvm_util::get_major_version() >= 7 {\n-                                    // rotate = funnel shift with first two args the same\n-                                    let llvm_name = &format!(\"llvm.fsh{}.i{}\",\n-                                                            if is_left { 'l' } else { 'r' }, width);\n-                                    let llfn = self.get_intrinsic(llvm_name);\n-                                    self.call(llfn, &[val, val, raw_shift], None)\n-                                } else {\n-                                    // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n-                                    // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n-                                    let width = self.const_uint(\n-                                        self.type_ix(width),\n-                                        width,\n-                                    );\n-                                    let shift = self.urem(raw_shift, width);\n-                                    let width_minus_raw_shift = self.sub(width, raw_shift);\n-                                    let inv_shift = self.urem(width_minus_raw_shift, width);\n-                                    let shift1 = self.shl(\n-                                        val,\n-                                        if is_left { shift } else { inv_shift },\n-                                    );\n-                                    let shift2 = self.lshr(\n-                                        val,\n-                                        if !is_left { shift } else { inv_shift },\n-                                    );\n-                                    self.or(shift1, shift2)\n-                                }\n+                                // rotate = funnel shift with first two args the same\n+                                let llvm_name = &format!(\"llvm.fsh{}.i{}\",\n+                                                        if is_left { 'l' } else { 'r' }, width);\n+                                let llfn = self.get_intrinsic(llvm_name);\n+                                self.call(llfn, &[val, val, raw_shift], None)\n                             },\n                             \"saturating_add\" | \"saturating_sub\" => {\n                                 let is_add = name == \"saturating_add\";\n@@ -538,9 +516,36 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         return;\n                     }\n                 }\n-\n             },\n \n+            \"float_to_int_approx_unchecked\" => {\n+                if float_type_width(arg_tys[0]).is_none() {\n+                    span_invalid_monomorphization_error(\n+                        tcx.sess, span,\n+                        &format!(\"invalid monomorphization of `float_to_int_approx_unchecked` \\\n+                                  intrinsic: expected basic float type, \\\n+                                  found `{}`\", arg_tys[0]));\n+                    return;\n+                }\n+                match int_type_width_signed(ret_ty, self.cx) {\n+                    Some((width, signed)) => {\n+                        if signed {\n+                            self.fptosi(args[0].immediate(), self.cx.type_ix(width))\n+                        } else {\n+                            self.fptoui(args[0].immediate(), self.cx.type_ix(width))\n+                        }\n+                    }\n+                    None => {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess, span,\n+                            &format!(\"invalid monomorphization of `float_to_int_approx_unchecked` \\\n+                                      intrinsic:  expected basic integer type, \\\n+                                      found `{}`\", ret_ty));\n+                        return;\n+                    }\n+                }\n+            }\n+\n             \"discriminant_value\" => {\n                 args[0].deref(self.cx()).codegen_get_discr(self, ret_ty)\n             }\n@@ -1013,8 +1018,10 @@ fn gen_fn<'ll, 'tcx>(\n         hir::Unsafety::Unsafe,\n         Abi::Rust\n     ));\n-    let llfn = cx.define_internal_fn(name, rust_fn_sig);\n-    attributes::from_fn_attrs(cx, llfn, None, rust_fn_sig);\n+    let fn_abi = FnAbi::of_fn_ptr(cx, rust_fn_sig, &[]);\n+    let llfn = cx.declare_fn(name, &fn_abi);\n+    // FIXME(eddyb) find a nicer way to do this.\n+    unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n     let bx = Builder::new_block(cx, llfn, \"entry-block\");\n     codegen(bx);\n     llfn\n@@ -1926,15 +1933,15 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, bool)> {\n     match ty.kind {\n         ty::Int(t) => Some((match t {\n-            ast::IntTy::Isize => cx.tcx.sess.target.isize_ty.bit_width().unwrap() as u64,\n+            ast::IntTy::Isize => cx.tcx.sess.target.ptr_width as u64,\n             ast::IntTy::I8 => 8,\n             ast::IntTy::I16 => 16,\n             ast::IntTy::I32 => 32,\n             ast::IntTy::I64 => 64,\n             ast::IntTy::I128 => 128,\n         }, true)),\n         ty::Uint(t) => Some((match t {\n-            ast::UintTy::Usize => cx.tcx.sess.target.usize_ty.bit_width().unwrap() as u64,\n+            ast::UintTy::Usize => cx.tcx.sess.target.ptr_width as u64,\n             ast::UintTy::U8 => 8,\n             ast::UintTy::U16 => 16,\n             ast::UintTy::U32 => 32,"}, {"sha": "00a84f8d80f36467f52fbfd4b1abeb815750e8c0", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "patch": "@@ -6,6 +6,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(const_cstr_unchecked)]\n@@ -30,6 +31,7 @@ extern crate libc;\n #[macro_use] extern crate rustc;\n extern crate rustc_target;\n #[macro_use] extern crate rustc_data_structures;\n+extern crate rustc_feature;\n extern crate rustc_index;\n extern crate rustc_incremental;\n extern crate rustc_codegen_utils;\n@@ -42,6 +44,7 @@ extern crate smallvec;\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n+extern crate rustc_session;\n \n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::back::write::{CodegenContext, ModuleConfig, FatLTOInput};"}, {"sha": "5da3275e28e8b3fc8fdb593a623cca46b3bb0065", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "d2d418762398101dccafe400353c85fc0e7cbaf9", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "72612c4704e667b4cfb3c4634b0289ccfa2eca13", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "cbc8af4fd27109ed6e1672a9020f463dacba4228", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "d77bbb279216a79e77b8905cea153cc020b75c54", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "53d3c51b5f8c096c17e943c98a429176ff349582", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "4278852123bea86f786d40a1fb10de5e4f2d38a8", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "cd3d99951e2b1054330c477b528239edcc636755", "filename": "src/librustc_codegen_ssa/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "cea5dc18c136296391e6dd89e2b460150123065a", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "283295cadfcc54bd6edc1fe0d0b95af48590d12b", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "f6725e66f03e6dd3552a3954970eb100359137b5", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "9919666027a2116c101fac344efc1dbccd44da06", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "6c627085b2ed8734c4b868d022f0764e7d38015f", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 85, "deletions": 33, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "dabd097b000b51b81952b24f316379d7d8c52cc9", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 105, "deletions": 91, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "bb2679e214db47c1192f530b416d891d9c9d1da8", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 126, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "e535aecd633da04f0f27bc9db48c31c31637b402", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "a6dec81274915057d93c22c36195494c63899095", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "e60b8861faf85ebc31d69dafbe94c031ddc813fe", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "488ae8dbf9036c91701a4f3038564679b558851b", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "e67201b710698ac1cc64f083a32423a8c33bbf61", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "1dd2c74dd4fa2c919e8eaa65684c8b0484aee28b", "filename": "src/librustc_codegen_ssa/traits/declare.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "5fb58eea3819d84ffaa720043e17d9125a5944ce", "filename": "src/librustc_data_structures/graph/dominators/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "a811c88839d704e5eac6bbbcc2d4f1ed42f867c6", "filename": "src/librustc_data_structures/jobserver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_data_structures%2Fjobserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_data_structures%2Fjobserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fjobserver.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "8a5badd0afc69ee37897ac14d64dad307be96a8e", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "995c99bfec307f9f55380ba581cca24c8437224f", "filename": "src/librustc_data_structures/obligation_forest/tests.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "70492d499222fe89f547ede56f948f4dfd012369", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "d1cb4cbeb9b31269354c49b025c63e9cad3b638a", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "05945504db237eb81fce0b3e8e0da55a337b7aad", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 125, "deletions": 112, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "9c1bec39b29e2834533163c00bab032c12003b7f", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "021a0219d13e2b60b8e79b49f3fb37132dc6789b", "filename": "src/librustc_error_codes/error_codes/E0015.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0015.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0015.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0015.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "d5e6857b4d6f893c2418f0962d15dcabef21fa83", "filename": "src/librustc_error_codes/error_codes/E0017.md", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/969926fcfe68787595d384f53d19cf6b8c9df3e3/src%2Flibrustc_error_codes%2Ferror_codes%2FE0017.md", "raw_url": "https://github.com/rust-lang/rust/raw/969926fcfe68787595d384f53d19cf6b8c9df3e3/src%2Flibrustc_error_codes%2Ferror_codes%2FE0017.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0017.md?ref=969926fcfe68787595d384f53d19cf6b8c9df3e3"}, {"sha": "64fc027b885b632b4c06debbd9c4f2a2269759b1", "filename": "src/librustc_error_codes/error_codes/E0062.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0062.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0062.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0062.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "0e611deac426fa6d081957d1530ae8149a4c3cd1", "filename": "src/librustc_error_codes/error_codes/E0063.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0063.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0063.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0063.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "11041bb53ee5527c7d154401c79b36709ee94d1b", "filename": "src/librustc_error_codes/error_codes/E0067.md", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0067.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0067.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0067.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "7367a5c0922ea9eae793ce6df00aa69de9519108", "filename": "src/librustc_error_codes/error_codes/E0069.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0069.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0069.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0069.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "97522af3da867573aea68c34f40112e3949e61db", "filename": "src/librustc_error_codes/error_codes/E0070.md", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0070.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0070.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0070.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "bc2c03a0220826f81558b003a18cbd71a891f04e", "filename": "src/librustc_error_codes/error_codes/E0071.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0071.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0071.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0071.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "8f7749abab1e5be25c01e7632f74b2a9a41f4cfe", "filename": "src/librustc_error_codes/error_codes/E0072.md", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0072.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0072.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0072.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "969c1ee71313e8f7f132d33eab18a3e850e81f76", "filename": "src/librustc_error_codes/error_codes/E0075.md", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0075.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0075.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0075.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "f293a2a5772db90a5c62caac983445ee1750bd78", "filename": "src/librustc_error_codes/error_codes/E0076.md", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0076.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0076.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0076.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "b14513c6ccf1fea776b7ce66fbbea2d92d269c8d", "filename": "src/librustc_error_codes/error_codes/E0077.md", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0077.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0077.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0077.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "273238a943b4fc9c9cce248c0a076abbce8ee768", "filename": "src/librustc_error_codes/error_codes/E0080.md", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "fd5eca68e21fd5dc24be35b92c4fa4fccd0b2765", "filename": "src/librustc_error_codes/error_codes/E0081.md", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0081.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0081.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0081.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "03cb32803715e97eebbbfbda92d7ee3e93bed82b", "filename": "src/librustc_error_codes/error_codes/E0091.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0091.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0091.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0091.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "e289534bf7abd777281cf5a1af3d75aeb0db043f", "filename": "src/librustc_error_codes/error_codes/E0092.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0092.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0092.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0092.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "8e7de1a9d37b3101e49fe5bafc24eb4e16d693c6", "filename": "src/librustc_error_codes/error_codes/E0093.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0093.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0093.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0093.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "42baa65bf9faf77782a73dde922f048c23183769", "filename": "src/librustc_error_codes/error_codes/E0094.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0094.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0094.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0094.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "60ca1ddc2830c3958b07f868a01dcbc1a94356dc", "filename": "src/librustc_error_codes/error_codes/E0106.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0106.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0106.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0106.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "4d22b17fe10166ad26c4c216c8be12fd63bfeb75", "filename": "src/librustc_error_codes/error_codes/E0107.md", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0107.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0107.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0107.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "2eab9725a6f596765f2b81823683edb6161cb32c", "filename": "src/librustc_error_codes/error_codes/E0109.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0109.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0109.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0109.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "ca849c2a128f4776526f49542b1f01f9a1011984", "filename": "src/librustc_error_codes/error_codes/E0116.md", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0116.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0116.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0116.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "7fa211d4a27d422390db0be84cf7904026477973", "filename": "src/librustc_error_codes/error_codes/E0117.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0117.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0117.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0117.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "5cb5f506e0a4bc504be5ad836a481b8c6eb729f9", "filename": "src/librustc_error_codes/error_codes/E0118.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0118.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0118.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0118.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "e596349e5e2d1af00451da2054050a358a362c8d", "filename": "src/librustc_error_codes/error_codes/E0119.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0119.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0119.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0119.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "1edb519275f79108d538bbc3a90c87c0e80cd2f8", "filename": "src/librustc_error_codes/error_codes/E0203.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0203.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0203.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0203.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "1779e5dbb30e7dbbb68534a442f94399f2db79a1", "filename": "src/librustc_error_codes/error_codes/E0307.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "397979e564105f51da7f12e5cde05e805ab6c0a9", "filename": "src/librustc_error_codes/error_codes/E0369.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0369.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0369.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0369.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "201107c05a02c32642db633cf4f107bdc29aab3a", "filename": "src/librustc_error_codes/error_codes/E0404.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0404.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0404.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0404.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "385079d403d59be277a285625120c7442b77ce0a", "filename": "src/librustc_error_codes/error_codes/E0458.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0458.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0458.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0458.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "6188d5f61a7f9892d83617af173c1c564ca24e94", "filename": "src/librustc_error_codes/error_codes/E0631.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0631.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0631.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0631.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "65cdf90036adeb044aaf7486539dbad5136e86f7", "filename": "src/librustc_error_codes/error_codes/E0633.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0633.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0633.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0633.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "a39d2be4f8f86bc61bf797d87a5d3f7ae673b1f6", "filename": "src/librustc_error_codes/error_codes/E0635.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0635.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0635.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0635.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "57cf72db5568928dd43d4f5b5cc6e149dfd0c495", "filename": "src/librustc_error_codes/error_codes/E0636.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0636.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0636.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0636.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "e2110042c7e8dd99288aafd36c06643379e03d0f", "filename": "src/librustc_error_codes/error_codes/E0641.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0641.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0641.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0641.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "7a653bd2264fd4eb07145aa27ad8cb018fb123f2", "filename": "src/librustc_error_codes/error_codes/E0644.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0644.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0644.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0644.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "d379b8a2384c675ece632d056a724438c3a5dc47", "filename": "src/librustc_error_codes/error_codes/E0706.md", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0706.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0706.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0706.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "39bebdcd3750e1f324c8e822a7c8290cda61a72a", "filename": "src/librustc_error_codes/error_codes/E0745.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "ae5876848185bc89c8588563813450c3644724ac", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "40ce922947bcb7368145bee8b37ee4ce35905247", "filename": "src/librustc_feature/Cargo.toml", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_feature%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_feature%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2FCargo.toml?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "fec5a7f1a4501b9c5a385522229655ff0e5ee498", "filename": "src/librustc_feature/accepted.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_feature%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_feature%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Faccepted.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "previous_filename": "src/libsyntax/feature_gate/accepted.rs"}, {"sha": "363621b3ca43616959979d3550fb77e10bd7b035", "filename": "src/librustc_feature/active.rs", "status": "renamed", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "previous_filename": "src/libsyntax/feature_gate/active.rs"}, {"sha": "4fa0198d8716d2463d49f9e1ca56f2cd58418040", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "renamed", "additions": 31, "deletions": 43, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "previous_filename": "src/libsyntax/feature_gate/builtin_attrs.rs"}, {"sha": "c38bb3740af3a6e664dc686243b4e745c469d945", "filename": "src/librustc_feature/lib.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_feature%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_feature%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Flib.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "340bd32fb8a460b8bac668bfcbd8324ccf1bf64b", "filename": "src/librustc_feature/removed.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_feature%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_feature%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fremoved.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "previous_filename": "src/libsyntax/feature_gate/removed.rs"}, {"sha": "8dac7263f4d2c1c2a8f7cb7d690d5773886915b5", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "c2e3fa8f28d2f6449aa4e2b9acebe35ec3356b1b", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "beb2465bd4a1a2ac5182667b2c8bdd9520f39dde", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "9bb18788171b4a51851e054984664a6446dc05f9", "filename": "src/librustc_interface/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_interface%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_interface%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Flib.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "2a4bc41f85072192bda1c0c202451dcbf9b83514", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 63, "deletions": 99, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "e429b4d101a904b524bd5d3d61e88d67c30c2978", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 147, "deletions": 76, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "4c630b56cb4ce36a1b02bac73b31b57b673b1a4f", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "8c225b83f40e8234b0f0f55506150cb6cdca5411", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "e834b87896ddf8fcb010634d2198e48e1a94a2cb", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "10b00d35d9bcaa9d0e12bf19ef2eee101d311770", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 57, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "b77f2cb8d6e35b580e357ce0c6511e918948eb6c", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "34241b845be04882c8c9e1415831a4299eac3702", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "f7de7ec7e18f44a8bb565dce7efa40106634d736", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "25bd2c45da5f5b05bacf24355a8a666448ac5ae4", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 173, "deletions": 136, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "48cf0b982f2902192775ab755f8aff95d852c59c", "filename": "src/librustc_metadata/cstore.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/969926fcfe68787595d384f53d19cf6b8c9df3e3/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969926fcfe68787595d384f53d19cf6b8c9df3e3/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=969926fcfe68787595d384f53d19cf6b8c9df3e3"}, {"sha": "d6d722c47b3a7e39f56b9eb87765c7fefd64c769", "filename": "src/librustc_metadata/dependency_format.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "aaaff7e3b0a4a9eef42da430219e455ecdbebeeb", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "c6fb80eca055ad98cce36d9faa0cbc2028b4c4ff", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "425e5d1d821bf971b72de83bb6eff492d943bbba", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "0107a22772fd225adb9c65290c792fda151547c3", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 127, "deletions": 23, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "13db9a6fef9ca83b1cf5a6c808726f61c4a4517a", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "fb70e10c84f3dcef07b0976941aab4bd6bdf83c1", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 17, "deletions": 59, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "5abae4293731d9c4f58dc9944e37c8a00da89856", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 61, "deletions": 40, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "10122fbba1fd47f79f5b7ac56cc28d910c9603cb", "filename": "src/librustc_metadata/rmeta/table.rs", "status": "modified", "additions": 29, "deletions": 67, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "2980483bfa4c7b17f88772819cbf319c7007ab88", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "d14957b9017daf487428a5dfba0938d8ec76e74c", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "renamed", "additions": 129, "deletions": 73, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf053d238e051390d5a1cfb62269a5853e77437/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=abf053d238e051390d5a1cfb62269a5853e77437", "previous_filename": "src/librustc_mir/borrow_check/conflict_errors.rs"}]}