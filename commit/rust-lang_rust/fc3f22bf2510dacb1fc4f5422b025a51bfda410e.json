{"sha": "fc3f22bf2510dacb1fc4f5422b025a51bfda410e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjM2YyMmJmMjUxMGRhY2IxZmM0ZjU0MjJiMDI1YTUxYmZkYTQxMGU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-21T09:28:18Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-27T21:55:14Z"}, "message": "syntax: change format_args! to produce fmt::Arguments instead of calling a function with them.", "tree": {"sha": "58911b0d0bb06a58e776eefbdf8b6e6fafb2e67f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58911b0d0bb06a58e776eefbdf8b6e6fafb2e67f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc3f22bf2510dacb1fc4f5422b025a51bfda410e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc3f22bf2510dacb1fc4f5422b025a51bfda410e", "html_url": "https://github.com/rust-lang/rust/commit/fc3f22bf2510dacb1fc4f5422b025a51bfda410e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc3f22bf2510dacb1fc4f5422b025a51bfda410e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3961adcaf0fbf5739c5e83f0e322692e5c69e58d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3961adcaf0fbf5739c5e83f0e322692e5c69e58d", "html_url": "https://github.com/rust-lang/rust/commit/3961adcaf0fbf5739c5e83f0e322692e5c69e58d"}], "stats": {"total": 95, "additions": 29, "deletions": 66}, "files": [{"sha": "2788c89676a3a1b83302b8ff3947a3e574a19ac4", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc3f22bf2510dacb1fc4f5422b025a51bfda410e/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc3f22bf2510dacb1fc4f5422b025a51bfda410e/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=fc3f22bf2510dacb1fc4f5422b025a51bfda410e", "patch": "@@ -131,8 +131,10 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     let format_string = cx.expr_str(span, s);\n \n     // phew, not our responsibility any more!\n-    format::expand_preparsed_format_args(cx, span,\n-                                         format::MethodCall(formatter, meth),\n-                                         format_string, exprs, Vec::new(),\n-                                         HashMap::new())\n+\n+    let args = vec![\n+        format::expand_preparsed_format_args(cx, span, format_string,\n+                                             exprs, vec![], HashMap::new())\n+    ];\n+    cx.expr_method_call(span, formatter, meth, args)\n }"}, {"sha": "6474d92953fd115f569b8d6c7177e384fc6a0c88", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 23, "deletions": 62, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fc3f22bf2510dacb1fc4f5422b025a51bfda410e/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc3f22bf2510dacb1fc4f5422b025a51bfda410e/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=fc3f22bf2510dacb1fc4f5422b025a51bfda410e", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::Invocation::*;\n use self::ArgumentType::*;\n use self::Position::*;\n \n@@ -68,54 +67,33 @@ struct Context<'a, 'b:'a> {\n     next_arg: uint,\n }\n \n-pub enum Invocation {\n-    Call(P<ast::Expr>),\n-    MethodCall(P<ast::Expr>, ast::Ident),\n-}\n-\n /// Parses the arguments from the given list of tokens, returning None\n /// if there's a parse error so we can continue parsing other format!\n /// expressions.\n ///\n-/// If parsing succeeds, the second return value is:\n+/// If parsing succeeds, the return value is:\n ///\n ///     Some((fmtstr, unnamed arguments, ordering of named arguments,\n ///           named arguments))\n-fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n-              tts: &[ast::TokenTree])\n-    -> (Invocation, Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<String>,\n-                            HashMap<String, P<ast::Expr>>)>) {\n+fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+              -> Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<String>,\n+                         HashMap<String, P<ast::Expr>>)> {\n     let mut args = Vec::new();\n     let mut names = HashMap::<String, P<ast::Expr>>::new();\n     let mut order = Vec::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n-    // Parse the leading function expression (maybe a block, maybe a path)\n-    let invocation = if allow_method {\n-        let e = p.parse_expr();\n-        if !p.eat(&token::Comma) {\n-            ecx.span_err(sp, \"expected token: `,`\");\n-            return (Call(e), None);\n-        }\n-        MethodCall(e, p.parse_ident())\n-    } else {\n-        Call(p.parse_expr())\n-    };\n-    if !p.eat(&token::Comma) {\n-        ecx.span_err(sp, \"expected token: `,`\");\n-        return (invocation, None);\n-    }\n \n     if p.token == token::Eof {\n         ecx.span_err(sp, \"requires at least a format string argument\");\n-        return (invocation, None);\n+        return None;\n     }\n     let fmtstr = p.parse_expr();\n     let mut named = false;\n     while p.token != token::Eof {\n         if !p.eat(&token::Comma) {\n             ecx.span_err(sp, \"expected token: `,`\");\n-            return (invocation, None);\n+            return None;\n         }\n         if p.token == token::Eof { break } // accept trailing commas\n         if named || (p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq)) {\n@@ -129,13 +107,13 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n                     ecx.span_err(p.span,\n                                  \"expected ident, positional arguments \\\n                                  cannot follow named arguments\");\n-                    return (invocation, None);\n+                    return None;\n                 }\n                 _ => {\n                     ecx.span_err(p.span,\n                                  format!(\"expected ident for named argument, found `{}`\",\n                                          p.this_token_to_string())[]);\n-                    return (invocation, None);\n+                    return None;\n                 }\n             };\n             let interned_name = token::get_ident(ident);\n@@ -158,7 +136,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n             args.push(p.parse_expr());\n         }\n     }\n-    return (invocation, Some((fmtstr, args, order, names)));\n+    Some((fmtstr, args, order, names))\n }\n \n impl<'a, 'b> Context<'a, 'b> {\n@@ -497,7 +475,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Actually builds the expression which the iformat! block will be expanded\n     /// to\n-    fn to_expr(mut self, invocation: Invocation) -> P<ast::Expr> {\n+    fn into_expr(mut self) -> P<ast::Expr> {\n         let mut locals = Vec::new();\n         let mut names = Vec::from_fn(self.name_positions.len(), |_| None);\n         let mut pats = Vec::new();\n@@ -615,26 +593,11 @@ impl<'a, 'b> Context<'a, 'b> {\n             (\"with_placeholders\", vec![pieces, fmt, args_slice])\n         };\n \n-        let body = self.ecx.expr_call_global(self.fmtsp, vec!(\n+        self.ecx.expr_call_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n                 self.ecx.ident_of(\"Arguments\"),\n-                self.ecx.ident_of(fn_name)), fn_args);\n-\n-        match invocation {\n-            Call(e) => {\n-                let span = e.span;\n-                self.ecx.expr_call(span, e, vec![\n-                    self.ecx.expr_addr_of(span, body)\n-                ])\n-            }\n-            MethodCall(e, m) => {\n-                let span = e.span;\n-                self.ecx.expr_method_call(span, e, m, vec![\n-                    self.ecx.expr_addr_of(span, body)\n-                ])\n-            }\n-        }\n+                self.ecx.ident_of(fn_name)), fn_args)\n     }\n \n     fn format_arg(ecx: &ExtCtxt, sp: Span,\n@@ -684,24 +647,22 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n                                tts: &[ast::TokenTree])\n                                -> Box<base::MacResult+'cx> {\n \n-    match parse_args(ecx, sp, false, tts) {\n-        (invocation, Some((efmt, args, order, names))) => {\n-            MacExpr::new(expand_preparsed_format_args(ecx, sp, invocation, efmt,\n+    match parse_args(ecx, sp, tts) {\n+        Some((efmt, args, order, names)) => {\n+            MacExpr::new(expand_preparsed_format_args(ecx, sp, efmt,\n                                                       args, order, names))\n         }\n-        (_, None) => MacExpr::new(ecx.expr_uint(sp, 2))\n+        None => DummyResult::expr(sp)\n     }\n }\n \n-/// Take the various parts of `format_args!(extra, efmt, args...,\n-/// name=names...)` and construct the appropriate formatting\n-/// expression.\n+/// Take the various parts of `format_args!(efmt, args..., name=names...)`\n+/// and construct the appropriate formatting expression.\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n-                                    invocation: Invocation,\n                                     efmt: P<ast::Expr>,\n                                     args: Vec<P<ast::Expr>>,\n-                                    name_ordering: Vec<string::String>,\n-                                    names: HashMap<string::String, P<ast::Expr>>)\n+                                    name_ordering: Vec<String>,\n+                                    names: HashMap<String, P<ast::Expr>>)\n                                     -> P<ast::Expr> {\n     let arg_types = Vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n@@ -722,8 +683,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     };\n     cx.fmtsp = efmt.span;\n     let fmt = match expr_to_string(cx.ecx,\n-                                efmt,\n-                                \"format argument must be a string literal.\") {\n+                                   efmt,\n+                                   \"format argument must be a string literal.\") {\n         Some((fmt, _)) => fmt,\n         None => return DummyResult::raw_expr(sp)\n     };\n@@ -771,5 +732,5 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         }\n     }\n \n-    cx.to_expr(invocation)\n+    cx.into_expr()\n }"}]}