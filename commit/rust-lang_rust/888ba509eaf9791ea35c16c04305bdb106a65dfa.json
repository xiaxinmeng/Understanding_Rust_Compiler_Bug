{"sha": "888ba509eaf9791ea35c16c04305bdb106a65dfa", "node_id": "C_kwDOAAsO6NoAKDg4OGJhNTA5ZWFmOTc5MWVhMzVjMTZjMDQzMDViZGIxMDZhNjVkZmE", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2021-10-05T13:32:03Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2021-10-13T10:53:44Z"}, "message": "Re-use logic for adding a suggestion when a lifetime bound is missing on an impl trait", "tree": {"sha": "708c61ce1848eb2995de97b02615519d6ef97a2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/708c61ce1848eb2995de97b02615519d6ef97a2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/888ba509eaf9791ea35c16c04305bdb106a65dfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/888ba509eaf9791ea35c16c04305bdb106a65dfa", "html_url": "https://github.com/rust-lang/rust/commit/888ba509eaf9791ea35c16c04305bdb106a65dfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/888ba509eaf9791ea35c16c04305bdb106a65dfa/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be399635a2618660d62fa7ce207d747ac56eae95", "url": "https://api.github.com/repos/rust-lang/rust/commits/be399635a2618660d62fa7ce207d747ac56eae95", "html_url": "https://github.com/rust-lang/rust/commit/be399635a2618660d62fa7ce207d747ac56eae95"}], "stats": {"total": 241, "additions": 150, "deletions": 91}, "files": [{"sha": "11d0178e93ba447b7b17722bb5b78245566b8755", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/888ba509eaf9791ea35c16c04305bdb106a65dfa/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888ba509eaf9791ea35c16c04305bdb106a65dfa/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=888ba509eaf9791ea35c16c04305bdb106a65dfa", "patch": "@@ -2235,8 +2235,7 @@ pub enum TyKind<'hir> {\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n     Path(QPath<'hir>),\n-    /// An opaque type definition itself. This is currently only used for the\n-    /// `opaque type Foo: Trait` item that `impl Trait` in desugars to.\n+    /// An opaque type definition itself. This is only used for `impl Trait`.\n     ///\n     /// The generic argument list contains the lifetimes (and in the future\n     /// possibly parameters) that are actually bound on the `impl Trait`."}, {"sha": "126c25f0c38c7819164eebe6f65ac658f11ef73a", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/888ba509eaf9791ea35c16c04305bdb106a65dfa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888ba509eaf9791ea35c16c04305bdb106a65dfa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=888ba509eaf9791ea35c16c04305bdb106a65dfa", "patch": "@@ -267,6 +267,18 @@ pub fn unexpected_hidden_region_diagnostic(\n                 hidden_region,\n                 \"\",\n             );\n+            if let Some(reg_info) = tcx.is_suitable_region(hidden_region) {\n+                let fn_returns = tcx.return_type_impl_or_dyn_traits(reg_info.def_id);\n+                nice_region_error::suggest_new_region_bound(\n+                    tcx,\n+                    &mut err,\n+                    fn_returns,\n+                    hidden_region.to_string(),\n+                    None,\n+                    format!(\"captures {}\", hidden_region),\n+                    None,\n+                )\n+            }\n         }\n         _ => {\n             // Ugh. This is a painful case: the hidden region is not one"}, {"sha": "6a3309770028f6cbef5ecb6060f925c1d8958b5c", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/888ba509eaf9791ea35c16c04305bdb106a65dfa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888ba509eaf9791ea35c16c04305bdb106a65dfa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=888ba509eaf9791ea35c16c04305bdb106a65dfa", "patch": "@@ -14,6 +14,8 @@ mod static_impl_trait;\n mod trait_impl_difference;\n mod util;\n \n+pub use static_impl_trait::suggest_new_region_bound;\n+\n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     pub fn try_report_nice_region_error(&self, error: &RegionResolutionError<'tcx>) -> bool {\n         NiceRegionError::new(self, error.clone()).try_report().is_some()"}, {"sha": "7fba6a823d75ee4e40a62365a655dee1aed4c99e", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 120, "deletions": 89, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/888ba509eaf9791ea35c16c04305bdb106a65dfa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888ba509eaf9791ea35c16c04305bdb106a65dfa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=888ba509eaf9791ea35c16c04305bdb106a65dfa", "patch": "@@ -217,128 +217,159 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             ));\n         }\n \n-        debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n-        // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n-        let consider = \"consider changing the\";\n-        let declare = \"to declare that the\";\n         let arg = match param.param.pat.simple_ident() {\n             Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n             None => \"the argument\".to_string(),\n         };\n-        let explicit = format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n-        let explicit_static = format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n         let captures = format!(\"captures data from {}\", arg);\n-        let add_static_bound = \"alternatively, add an explicit `'static` bound to this reference\";\n-        let plus_lt = format!(\" + {}\", lifetime_name);\n-        for fn_return in fn_returns {\n-            if fn_return.span.desugaring_kind().is_some() {\n-                // Skip `async` desugaring `impl Future`.\n-                continue;\n-            }\n-            match fn_return.kind {\n-                TyKind::OpaqueDef(item_id, _) => {\n-                    let item = tcx.hir().item(item_id);\n-                    let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n-                        opaque\n-                    } else {\n-                        err.emit();\n-                        return Some(ErrorReported);\n-                    };\n+        suggest_new_region_bound(\n+            tcx,\n+            &mut err,\n+            fn_returns,\n+            lifetime_name,\n+            Some(arg),\n+            captures,\n+            Some((param.param_ty_span, param.param_ty.to_string())),\n+        );\n \n-                    if let Some(span) = opaque\n-                        .bounds\n-                        .iter()\n-                        .filter_map(|arg| match arg {\n-                            GenericBound::Outlives(Lifetime {\n-                                name: LifetimeName::Static,\n-                                span,\n-                                ..\n-                            }) => Some(*span),\n-                            _ => None,\n-                        })\n-                        .next()\n-                    {\n+        err.emit();\n+        Some(ErrorReported)\n+    }\n+}\n+\n+pub fn suggest_new_region_bound(\n+    tcx: TyCtxt<'tcx>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    fn_returns: Vec<&rustc_hir::Ty<'_>>,\n+    lifetime_name: String,\n+    arg: Option<String>,\n+    captures: String,\n+    param: Option<(Span, String)>,\n+) {\n+    debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n+    // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n+    let consider = \"consider changing the\";\n+    let declare = \"to declare that the\";\n+    let explicit = format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n+    let explicit_static =\n+        arg.map(|arg| format!(\"explicit `'static` bound to the lifetime of {}\", arg));\n+    let add_static_bound = \"alternatively, add an explicit `'static` bound to this reference\";\n+    let plus_lt = format!(\" + {}\", lifetime_name);\n+    for fn_return in fn_returns {\n+        if fn_return.span.desugaring_kind().is_some() {\n+            // Skip `async` desugaring `impl Future`.\n+            continue;\n+        }\n+        match fn_return.kind {\n+            TyKind::OpaqueDef(item_id, _) => {\n+                let item = tcx.hir().item(item_id);\n+                let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n+                    opaque\n+                } else {\n+                    return;\n+                };\n+\n+                if let Some(span) = opaque\n+                    .bounds\n+                    .iter()\n+                    .filter_map(|arg| match arg {\n+                        GenericBound::Outlives(Lifetime {\n+                            name: LifetimeName::Static,\n+                            span,\n+                            ..\n+                        }) => Some(*span),\n+                        _ => None,\n+                    })\n+                    .next()\n+                {\n+                    if let Some(explicit_static) = &explicit_static {\n                         err.span_suggestion_verbose(\n                             span,\n                             &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n                             lifetime_name.clone(),\n                             Applicability::MaybeIncorrect,\n                         );\n+                    }\n+                    if let Some((param_span, param_ty)) = param.clone() {\n                         err.span_suggestion_verbose(\n-                            param.param_ty_span,\n+                            param_span,\n                             add_static_bound,\n-                            param.param_ty.to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else if opaque\n-                        .bounds\n-                        .iter()\n-                        .filter_map(|arg| match arg {\n-                            GenericBound::Outlives(Lifetime { name, span, .. })\n-                                if name.ident().to_string() == lifetime_name =>\n-                            {\n-                                Some(*span)\n-                            }\n-                            _ => None,\n-                        })\n-                        .next()\n-                        .is_some()\n-                    {\n-                    } else {\n-                        err.span_suggestion_verbose(\n-                            fn_return.span.shrink_to_hi(),\n-                            &format!(\n-                                \"{declare} `impl Trait` {captures}, {explicit}\",\n-                                declare = declare,\n-                                captures = captures,\n-                                explicit = explicit,\n-                            ),\n-                            plus_lt.clone(),\n+                            param_ty,\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n+                } else if opaque\n+                    .bounds\n+                    .iter()\n+                    .filter_map(|arg| match arg {\n+                        GenericBound::Outlives(Lifetime { name, span, .. })\n+                            if name.ident().to_string() == lifetime_name =>\n+                        {\n+                            Some(*span)\n+                        }\n+                        _ => None,\n+                    })\n+                    .next()\n+                    .is_some()\n+                {\n+                } else {\n+                    err.span_suggestion_verbose(\n+                        fn_return.span.shrink_to_hi(),\n+                        &format!(\n+                            \"{declare} `impl Trait` {captures}, {explicit}\",\n+                            declare = declare,\n+                            captures = captures,\n+                            explicit = explicit,\n+                        ),\n+                        plus_lt.clone(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n-                TyKind::TraitObject(_, lt, _) => match lt.name {\n-                    LifetimeName::ImplicitObjectLifetimeDefault => {\n-                        err.span_suggestion_verbose(\n-                            fn_return.span.shrink_to_hi(),\n-                            &format!(\n-                                \"{declare} trait object {captures}, {explicit}\",\n-                                declare = declare,\n-                                captures = captures,\n-                                explicit = explicit,\n-                            ),\n-                            plus_lt.clone(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    name if name.ident().to_string() != lifetime_name => {\n-                        // With this check we avoid suggesting redundant bounds. This\n-                        // would happen if there are nested impl/dyn traits and only\n-                        // one of them has the bound we'd suggest already there, like\n-                        // in `impl Foo<X = dyn Bar> + '_`.\n+            }\n+            TyKind::TraitObject(_, lt, _) => match lt.name {\n+                LifetimeName::ImplicitObjectLifetimeDefault => {\n+                    err.span_suggestion_verbose(\n+                        fn_return.span.shrink_to_hi(),\n+                        &format!(\n+                            \"{declare} trait object {captures}, {explicit}\",\n+                            declare = declare,\n+                            captures = captures,\n+                            explicit = explicit,\n+                        ),\n+                        plus_lt.clone(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                name if name.ident().to_string() != lifetime_name => {\n+                    // With this check we avoid suggesting redundant bounds. This\n+                    // would happen if there are nested impl/dyn traits and only\n+                    // one of them has the bound we'd suggest already there, like\n+                    // in `impl Foo<X = dyn Bar> + '_`.\n+                    if let Some(explicit_static) = &explicit_static {\n                         err.span_suggestion_verbose(\n                             lt.span,\n                             &format!(\"{} trait object's {}\", consider, explicit_static),\n                             lifetime_name.clone(),\n                             Applicability::MaybeIncorrect,\n                         );\n+                    }\n+                    if let Some((param_span, param_ty)) = param.clone() {\n                         err.span_suggestion_verbose(\n-                            param.param_ty_span,\n+                            param_span,\n                             add_static_bound,\n-                            param.param_ty.to_string(),\n+                            param_ty,\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n-                    _ => {}\n-                },\n+                }\n                 _ => {}\n-            }\n+            },\n+            _ => {}\n         }\n-        err.emit();\n-        Some(ErrorReported)\n     }\n+}\n \n+impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     fn get_impl_ident_and_self_ty_from_trait(\n         &self,\n         def_id: DefId,"}, {"sha": "60d3409a8accf14989cdca1a5cfe5971c2eac7b9", "filename": "src/test/ui/impl-trait/hidden-lifetimes.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/888ba509eaf9791ea35c16c04305bdb106a65dfa/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/888ba509eaf9791ea35c16c04305bdb106a65dfa/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr?ref=888ba509eaf9791ea35c16c04305bdb106a65dfa", "patch": "@@ -5,6 +5,11 @@ LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n    |                 --                                   ^^^^^^^^^^^^^^\n    |                 |\n    |                 hidden type `&'a mut &'b T` captures the lifetime `'b` as defined here\n+   |\n+help: to declare that the `impl Trait` captures 'b, you can add an explicit `'b` lifetime bound\n+   |\n+LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a + 'b {\n+   |                                                                     ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/hidden-lifetimes.rs:45:70\n@@ -13,6 +18,11 @@ LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl S\n    |                        --                                            ^^^^^^^^^^^^^^\n    |                        |\n    |                        hidden type `Rc<RefCell<&'b T>>` captures the lifetime `'b` as defined here\n+   |\n+help: to declare that the `impl Trait` captures 'b, you can add an explicit `'b` lifetime bound\n+   |\n+LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a + 'b {\n+   |                                                                                     ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9dc2ea5bc82a1cc0b8ffec2db20e2da58c8bd138", "filename": "src/test/ui/impl-trait/region-escape-via-bound.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/888ba509eaf9791ea35c16c04305bdb106a65dfa/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/888ba509eaf9791ea35c16c04305bdb106a65dfa/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr?ref=888ba509eaf9791ea35c16c04305bdb106a65dfa", "patch": "@@ -6,6 +6,11 @@ LL | fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n LL |\n LL | where 'x: 'y\n    |       -- hidden type `Cell<&'x u32>` captures the lifetime `'x` as defined here\n+   |\n+help: to declare that the `impl Trait` captures 'x, you can add an explicit `'x` lifetime bound\n+   |\n+LL | fn foo(x: Cell<&'x u32>) -> impl Trait<'y> + 'x\n+   |                                            ++++\n \n error: aborting due to previous error\n "}]}