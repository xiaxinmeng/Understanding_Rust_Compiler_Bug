{"sha": "03a724bd486da1d2691df3d8709c688a0704f1e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYTcyNGJkNDg2ZGExZDI2OTFkZjNkODcwOWM2ODhhMDcwNGYxZTA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-11T15:52:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-11T15:52:11Z"}, "message": "Rollup merge of #70996 - ChaiTRex:master, r=Amanieu\n\nAdd or_insert_with_key to Entry of HashMap/BTreeMap\n\nGoing along with `or_insert_with`, `or_insert_with_key` provides the `Entry`'s key to the lambda, avoiding the need to either clone the key or the need to reimplement this body of this method from scratch each time.\n\nThis is useful when the initial value for a map entry is derived from the key. For example, the introductory Rust book has an example Cacher struct that takes an expensive-to-compute lambda and then can, given an argument to the lambda, produce either the cached result or execute the lambda.\n\n---\n\nI'm fairly new to Rust, so any optimizations, corrections to types, better names, better documentation, or whatever else would be appreciated. I'd like to thank Arnavion on freenode for helping me to implement a very similar method when I found that `or_insert_with_key` was unavailable.\n\nAs a somewhat-related note, this implements https://github.com/rust-lang/rfcs/issues/1202 from 2015, so if this pull request is accepted, that should be closed.", "tree": {"sha": "5938040505931f21859fcd4226d284e9b0a6bcd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5938040505931f21859fcd4226d284e9b0a6bcd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03a724bd486da1d2691df3d8709c688a0704f1e0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJekeesCRBK7hj4Ov3rIwAAdHIIAGPMBW43BV9KanhUfFELeswe\nc9YpBedYRj7QlfGVNSgW0ARESKdph+CASTLhsdyXhhPWK7otvcI1GK+oijYA0rU2\nzrB/vVwaKFQ8T1e3YA4avhlOXbCklZ4Vw0bp8zTc7J+kmRmEMDZ0gg3TSx7rLZRe\nAAO65ZDFmc7i30O5y/LhL5V+tjLFFHFj7PIJ+OWnt5FMZRlgPNzrd5TYH0iDn1zJ\n0QHFQTcoMFUW1eER5bmOGl5fKYPrwGK2cg+LRM7JUzJ3KFuV4LyF0IkWD8hn6cuP\n5Mj1x3j/Kji7EpIyCsxSNU4Hihlp06lFB6teNRbzw4U7eV+DxAZ3j5iZD+hkfBM=\n=nPXW\n-----END PGP SIGNATURE-----\n", "payload": "tree 5938040505931f21859fcd4226d284e9b0a6bcd0\nparent 5ecc18f3ece1124a56ff76a74c3eb4153be5b3b8\nparent db0c39fba5d596e286238c21b11b9aa9e1701b5b\nauthor Dylan DPC <dylan.dpc@gmail.com> 1586620331 +0200\ncommitter GitHub <noreply@github.com> 1586620331 +0200\n\nRollup merge of #70996 - ChaiTRex:master, r=Amanieu\n\nAdd or_insert_with_key to Entry of HashMap/BTreeMap\n\nGoing along with `or_insert_with`, `or_insert_with_key` provides the `Entry`'s key to the lambda, avoiding the need to either clone the key or the need to reimplement this body of this method from scratch each time.\n\nThis is useful when the initial value for a map entry is derived from the key. For example, the introductory Rust book has an example Cacher struct that takes an expensive-to-compute lambda and then can, given an argument to the lambda, produce either the cached result or execute the lambda.\n\n---\n\nI'm fairly new to Rust, so any optimizations, corrections to types, better names, better documentation, or whatever else would be appreciated. I'd like to thank Arnavion on freenode for helping me to implement a very similar method when I found that `or_insert_with_key` was unavailable.\n\nAs a somewhat-related note, this implements https://github.com/rust-lang/rfcs/issues/1202 from 2015, so if this pull request is accepted, that should be closed.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03a724bd486da1d2691df3d8709c688a0704f1e0", "html_url": "https://github.com/rust-lang/rust/commit/03a724bd486da1d2691df3d8709c688a0704f1e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03a724bd486da1d2691df3d8709c688a0704f1e0/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ecc18f3ece1124a56ff76a74c3eb4153be5b3b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ecc18f3ece1124a56ff76a74c3eb4153be5b3b8", "html_url": "https://github.com/rust-lang/rust/commit/5ecc18f3ece1124a56ff76a74c3eb4153be5b3b8"}, {"sha": "db0c39fba5d596e286238c21b11b9aa9e1701b5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/db0c39fba5d596e286238c21b11b9aa9e1701b5b", "html_url": "https://github.com/rust-lang/rust/commit/db0c39fba5d596e286238c21b11b9aa9e1701b5b"}], "stats": {"total": 56, "additions": 56, "deletions": 0}, "files": [{"sha": "3fc1b5e16b37280de93745c45283262fe05f261d", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/03a724bd486da1d2691df3d8709c688a0704f1e0/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a724bd486da1d2691df3d8709c688a0704f1e0/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=03a724bd486da1d2691df3d8709c688a0704f1e0", "patch": "@@ -2361,6 +2361,34 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n         }\n     }\n \n+    #[unstable(feature = \"or_insert_with_key\", issue = \"71024\")]\n+    /// Ensures a value is in the entry by inserting, if empty, the result of the default function,\n+    /// which takes the key as its argument, and returns a mutable reference to the value in the\n+    /// entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(or_insert_with_key)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 9);\n+    /// ```\n+    #[inline]\n+    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => {\n+                let value = default(entry.key());\n+                entry.insert(value)\n+            }\n+        }\n+    }\n+\n     /// Returns a reference to this entry's key.\n     ///\n     /// # Examples"}, {"sha": "706b388f7832331c3cf86813ad474dedf2fa3ad8", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/03a724bd486da1d2691df3d8709c688a0704f1e0/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a724bd486da1d2691df3d8709c688a0704f1e0/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=03a724bd486da1d2691df3d8709c688a0704f1e0", "patch": "@@ -1943,6 +1943,34 @@ impl<'a, K, V> Entry<'a, K, V> {\n         }\n     }\n \n+    #[unstable(feature = \"or_insert_with_key\", issue = \"71024\")]\n+    /// Ensures a value is in the entry by inserting, if empty, the result of the default function,\n+    /// which takes the key as its argument, and returns a mutable reference to the value in the\n+    /// entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(or_insert_with_key)]\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, usize> = HashMap::new();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 9);\n+    /// ```\n+    #[inline]\n+    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => {\n+                let value = default(entry.key());\n+                entry.insert(value)\n+            }\n+        }\n+    }\n+\n     /// Returns a reference to this entry's key.\n     ///\n     /// # Examples"}]}