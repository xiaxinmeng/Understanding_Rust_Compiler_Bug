{"sha": "ab45ab83ac0c9b19b6d692ca5d2e9b7b98c3565a", "node_id": "C_kwDOAAsO6NoAKGFiNDVhYjgzYWMwYzliMTliNmQ2OTJjYTVkMmU5YjdiOThjMzU2NWE", "commit": {"author": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-10-12T08:56:24Z"}, "committer": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-12-10T03:08:22Z"}, "message": "review comments\n\n* take diagnostic logic out of happy-path\n* sort/dedup once\n* add more comments", "tree": {"sha": "ed39cc87dd948b29cba7529359671ffe38e04319", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed39cc87dd948b29cba7529359671ffe38e04319"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab45ab83ac0c9b19b6d692ca5d2e9b7b98c3565a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab45ab83ac0c9b19b6d692ca5d2e9b7b98c3565a", "html_url": "https://github.com/rust-lang/rust/commit/ab45ab83ac0c9b19b6d692ca5d2e9b7b98c3565a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab45ab83ac0c9b19b6d692ca5d2e9b7b98c3565a/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd81e984660bf4273470d336eaed27f9e062ce1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd81e984660bf4273470d336eaed27f9e062ce1c", "html_url": "https://github.com/rust-lang/rust/commit/dd81e984660bf4273470d336eaed27f9e062ce1c"}], "stats": {"total": 50, "additions": 29, "deletions": 21}, "files": [{"sha": "e1f2ec4443182cf624c7d17c66442d063b0f4f82", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab45ab83ac0c9b19b6d692ca5d2e9b7b98c3565a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab45ab83ac0c9b19b6d692ca5d2e9b7b98c3565a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=ab45ab83ac0c9b19b6d692ca5d2e9b7b98c3565a", "patch": "@@ -150,8 +150,10 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         if mention_capture {\n             spans.push(sup_origin.span());\n         }\n-        spans.sort();\n-        spans.dedup();\n+        // We sort the spans *ignoring* expansion context. Below, the closure logic is repeated\n+        // because one method expects a closure taking `&Span` and the other `&mut Span`.\n+        spans.sort_by_key(|span| (span.lo(), span.hi()));\n+        spans.dedup_by_key(|span| (span.lo(), span.hi()));\n \n         // We try to make the output have fewer overlapping spans if possible.\n         let (require_msg, require_span) = if sup_origin.span().overlaps(return_sp) {\n@@ -165,8 +167,12 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n \n         if spans.iter().any(|sp| sp.overlaps(return_sp) || *sp > return_sp) {\n+            // If any of the \"captured here\" labels appears on the same line or after\n+            // `require_span`, we put it on a note to ensure the text flows by appearing\n+            // always at the end.\n             err.span_note(require_span, require_msg);\n         } else {\n+            // We don't need a note, it's already at the end, it can be shown as a `span_label`.\n             err.span_label(require_span, require_msg);\n         }\n "}, {"sha": "3d4e96fa0f269ec5b2d3604e9166ec561e2c7799", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ab45ab83ac0c9b19b6d692ca5d2e9b7b98c3565a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab45ab83ac0c9b19b6d692ca5d2e9b7b98c3565a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=ab45ab83ac0c9b19b6d692ca5d2e9b7b98c3565a", "patch": "@@ -146,8 +146,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n         self.expansion(&mut var_data);\n-        let captures = self.collect_errors(&mut var_data, errors);\n-        self.collect_var_errors(&var_data, &graph, errors, captures);\n+        self.collect_errors(&mut var_data, errors);\n+        self.collect_var_errors(&var_data, &graph, errors);\n         var_data\n     }\n \n@@ -445,16 +445,9 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         &self,\n         var_data: &mut LexicalRegionResolutions<'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n-    ) -> Vec<Span> {\n-        let mut captures = vec![];\n-\n+    ) {\n         for (constraint, origin) in &self.data.constraints {\n             debug!(?constraint, ?origin);\n-            if let (Constraint::VarSubVar(_, _), SubregionOrigin::DataBorrowed(_, sp)) =\n-                (constraint, origin)\n-            {\n-                captures.push(*sp);\n-            }\n             match *constraint {\n                 Constraint::RegSubVar(..) | Constraint::VarSubVar(..) => {\n                     // Expansion will ensure that these constraints hold. Ignore.\n@@ -524,7 +517,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 sub,\n             ));\n         }\n-        captures\n     }\n \n     /// Go over the variables that were declared to be error variables\n@@ -534,7 +526,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         var_data: &LexicalRegionResolutions<'tcx>,\n         graph: &RegionGraph<'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n-        captures: Vec<Span>,\n     ) {\n         debug!(\"collect_var_errors, var_data = {:#?}\", var_data.values);\n \n@@ -578,12 +569,27 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     // if this rule starts to create problems we'll\n                     // have to revisit this portion of the code and\n                     // think hard about it. =) -- nikomatsakis\n+\n+                    // Obtain the spans for all the capture points for\n+                    // richer diagnostics in `static_impl_trait`.\n+                    let captures: Vec<Span> = self\n+                        .data\n+                        .constraints\n+                        .iter()\n+                        .filter_map(|(constraint, origin)| match (constraint, origin) {\n+                            (Constraint::VarSubVar(_, _), SubregionOrigin::DataBorrowed(_, sp)) => {\n+                                Some(*sp)\n+                            }\n+                            _ => None,\n+                        })\n+                        .collect();\n+\n                     self.collect_error_for_expanding_node(\n                         graph,\n                         &mut dup_vec,\n                         node_vid,\n                         errors,\n-                        &captures,\n+                        captures,\n                     );\n                 }\n             }\n@@ -638,7 +644,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         dup_vec: &mut IndexVec<RegionVid, Option<RegionVid>>,\n         node_idx: RegionVid,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n-        captures: &[Span],\n+        captures: Vec<Span>,\n     ) {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n@@ -686,18 +692,14 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                         origin, node_idx, lower_bound.region, upper_bound.region\n                     );\n \n-                    let mut capture_spans: Vec<Span> = captures.iter().cloned().collect();\n-                    // Below, one span expects `&Span` and the other `&mut Span`, hence the dupes.\n-                    capture_spans.sort_by_key(|span| (span.lo(), span.hi()));\n-                    capture_spans.dedup_by_key(|span| (span.lo(), span.hi()));\n                     errors.push(RegionResolutionError::SubSupConflict(\n                         node_idx,\n                         origin,\n                         lower_bound.origin.clone(),\n                         lower_bound.region,\n                         upper_bound.origin.clone(),\n                         upper_bound.region,\n-                        capture_spans,\n+                        captures,\n                     ));\n                     return;\n                 }"}]}