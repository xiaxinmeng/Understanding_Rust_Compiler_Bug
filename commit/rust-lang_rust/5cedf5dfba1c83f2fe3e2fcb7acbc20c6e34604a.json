{"sha": "5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZWRmNWRmYmExYzgzZjJmZTNlMmZjYjdhY2JjMjBjNmUzNDYwNGE=", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2020-06-15T20:59:09Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2020-06-15T21:09:12Z"}, "message": "Refactor usage of Needs in typeck", "tree": {"sha": "9b1f1026ef4d5c1f3d685913a378eb84c06e5629", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b1f1026ef4d5c1f3d685913a378eb84c06e5629"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a", "html_url": "https://github.com/rust-lang/rust/commit/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e390acdfccdc5297e8fbb186bbb890cb6a3d0e57", "url": "https://api.github.com/repos/rust-lang/rust/commits/e390acdfccdc5297e8fbb186bbb890cb6a3d0e57", "html_url": "https://github.com/rust-lang/rust/commit/e390acdfccdc5297e8fbb186bbb890cb6a3d0e57"}], "stats": {"total": 759, "additions": 382, "deletions": 377}, "files": [{"sha": "2570025959cb4f7320010f63837a7444209bd402", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a", "patch": "@@ -1,5 +1,5 @@\n use super::method::MethodCallee;\n-use super::{FnCtxt, Needs, PlaceOp};\n+use super::{FnCtxt, PlaceOp};\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -170,14 +170,13 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n     }\n \n     /// Returns the adjustment steps.\n-    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>, needs: Needs) -> Vec<Adjustment<'tcx>> {\n-        fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx, needs))\n+    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>) -> Vec<Adjustment<'tcx>> {\n+        fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx))\n     }\n \n     pub fn adjust_steps_as_infer_ok(\n         &self,\n         fcx: &FnCtxt<'a, 'tcx>,\n-        needs: Needs,\n     ) -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n         let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty).chain(iter::once(self.cur_ty));\n@@ -186,7 +185,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n             .iter()\n             .map(|&(source, kind)| {\n                 if let AutoderefKind::Overloaded = kind {\n-                    fcx.try_overloaded_deref(self.span, source, needs).and_then(\n+                    fcx.try_overloaded_deref(self.span, source).and_then(\n                         |InferOk { value: method, obligations: o }| {\n                             obligations.extend(o);\n                             if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n@@ -266,8 +265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         base_ty: Ty<'tcx>,\n-        needs: Needs,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        self.try_overloaded_place_op(span, base_ty, &[], needs, PlaceOp::Deref)\n+        self.try_overloaded_place_op(span, base_ty, &[], PlaceOp::Deref)\n     }\n }"}, {"sha": "916fe9afc876a76ac75192e6d212345c78464289", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a", "patch": "@@ -1,6 +1,6 @@\n use super::autoderef::Autoderef;\n use super::method::MethodCallee;\n-use super::{Expectation, FnCtxt, Needs, TupleArgumentsFlag};\n+use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n use crate::type_error_struct;\n \n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.kind {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n-                let adjustments = autoderef.adjust_steps(self, Needs::None);\n+                let adjustments = autoderef.adjust_steps(self);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             &closure_sig,\n                         )\n                         .0;\n-                    let adjustments = autoderef.adjust_steps(self, Needs::None);\n+                    let adjustments = autoderef.adjust_steps(self);\n                     self.record_deferred_call_resolution(\n                         def_id,\n                         DeferredCallResolution {\n@@ -176,7 +176,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.try_overloaded_call_traits(call_expr, adjusted_ty, Some(arg_exprs))\n             .or_else(|| self.try_overloaded_call_traits(call_expr, adjusted_ty, None))\n             .map(|(autoref, method)| {\n-                let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n+                let mut adjustments = autoderef.adjust_steps(self);\n                 adjustments.extend(autoref);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 CallStep::Overloaded(method)"}, {"sha": "085bb384e124ba69abf9656ee43391acf7ef5eb6", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a", "patch": "@@ -51,7 +51,7 @@\n //! we may want to adjust precisely when coercions occur.\n \n use crate::astconv::AstConv;\n-use crate::check::{FnCtxt, Needs};\n+use crate::check::FnCtxt;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -421,9 +421,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             return success(vec![], ty, obligations);\n         }\n \n-        let needs = Needs::maybe_mut_place(mutbl_b);\n         let InferOk { value: mut adjustments, obligations: o } =\n-            autoderef.adjust_steps_as_infer_ok(self, needs);\n+            autoderef.adjust_steps_as_infer_ok(self);\n         obligations.extend(o);\n         obligations.extend(autoderef.into_obligations());\n "}, {"sha": "c15d747be52998d1b6e9b8b43fb3eaca7382addf", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 30, "deletions": 57, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a", "patch": "@@ -29,9 +29,7 @@ use rustc_hir::{ExprKind, QPath};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty;\n-use rustc_middle::ty::adjustment::{\n-    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n-};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n use rustc_middle::ty::Ty;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{AdtKind, Visibility};\n@@ -113,12 +111,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.check_expr_with_expectation(expr, ExpectHasType(expected))\n     }\n \n-    pub(super) fn check_expr_with_expectation(\n+    fn check_expr_with_expectation_and_needs(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n+        needs: Needs,\n     ) -> Ty<'tcx> {\n-        self.check_expr_with_expectation_and_needs(expr, expected, Needs::None)\n+        let ty = self.check_expr_with_expectation(expr, expected);\n+\n+        // If the expression is used in a place whether mutable place is required\n+        // e.g. LHS of assignment, perform the conversion.\n+        if let Needs::MutPlace = needs {\n+            self.convert_place_derefs_to_mutable(expr);\n+        }\n+\n+        ty\n     }\n \n     pub(super) fn check_expr(&self, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n@@ -143,11 +150,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Note that inspecting a type's structure *directly* may expose the fact\n     /// that there are actually multiple representations for `Error`, so avoid\n     /// that when err needs to be handled differently.\n-    fn check_expr_with_expectation_and_needs(\n+    pub(super) fn check_expr_with_expectation(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n     ) -> Ty<'tcx> {\n         debug!(\">> type-checking: expr={:?} expected={:?}\", expr, expected);\n \n@@ -171,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let old_diverges = self.diverges.replace(Diverges::Maybe);\n         let old_has_errors = self.has_errors.replace(false);\n \n-        let ty = self.check_expr_kind(expr, expected, needs);\n+        let ty = self.check_expr_kind(expr, expected);\n \n         // Warn for non-block expressions with diverging children.\n         match expr.kind {\n@@ -213,9 +219,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n     ) -> Ty<'tcx> {\n-        debug!(\"check_expr_kind(expr={:?}, expected={:?}, needs={:?})\", expr, expected, needs,);\n+        debug!(\"check_expr_kind(expr={:?}, expected={:?})\", expr, expected);\n \n         let tcx = self.tcx;\n         match expr.kind {\n@@ -226,9 +231,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_assign(expr, expected, lhs, rhs, span)\n             }\n             ExprKind::AssignOp(op, ref lhs, ref rhs) => self.check_binop_assign(expr, op, lhs, rhs),\n-            ExprKind::Unary(unop, ref oprnd) => {\n-                self.check_expr_unary(unop, oprnd, expected, needs, expr)\n-            }\n+            ExprKind::Unary(unop, ref oprnd) => self.check_expr_unary(unop, oprnd, expected, expr),\n             ExprKind::AddrOf(kind, mutbl, ref oprnd) => {\n                 self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n             }\n@@ -264,7 +267,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Block(ref body, _) => self.check_block_with_expected(&body, expected),\n             ExprKind::Call(ref callee, ref args) => self.check_call(expr, &callee, args, expected),\n             ExprKind::MethodCall(ref segment, span, ref args, _) => {\n-                self.check_method_call(expr, segment, span, args, expected, needs)\n+                self.check_method_call(expr, segment, span, args, expected)\n             }\n             ExprKind::Cast(ref e, ref t) => self.check_expr_cast(e, t, expr),\n             ExprKind::Type(ref e, ref t) => {\n@@ -281,8 +284,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Struct(ref qpath, fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            ExprKind::Field(ref base, field) => self.check_field(expr, needs, &base, field),\n-            ExprKind::Index(ref base, ref idx) => self.check_expr_index(base, idx, needs, expr),\n+            ExprKind::Field(ref base, field) => self.check_field(expr, &base, field),\n+            ExprKind::Index(ref base, ref idx) => self.check_expr_index(base, idx, expr),\n             ExprKind::Yield(ref value, ref src) => self.check_expr_yield(value, expr, src),\n             hir::ExprKind::Err => tcx.types.err,\n         }\n@@ -302,48 +305,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         unop: hir::UnOp,\n         oprnd: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected_inner = match unop {\n             hir::UnOp::UnNot | hir::UnOp::UnNeg => expected,\n             hir::UnOp::UnDeref => NoExpectation,\n         };\n-        let needs = match unop {\n-            hir::UnOp::UnDeref => needs,\n-            _ => Needs::None,\n-        };\n-        let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd, expected_inner, needs);\n+        let mut oprnd_t = self.check_expr_with_expectation(&oprnd, expected_inner);\n \n         if !oprnd_t.references_error() {\n             oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n             match unop {\n                 hir::UnOp::UnDeref => {\n-                    if let Some(mt) = oprnd_t.builtin_deref(true) {\n-                        oprnd_t = mt.ty;\n-                    } else if let Some(ok) = self.try_overloaded_deref(expr.span, oprnd_t, needs) {\n-                        let method = self.register_infer_ok_obligations(ok);\n-                        if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n-                            let mutbl = match mutbl {\n-                                hir::Mutability::Not => AutoBorrowMutability::Not,\n-                                hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                                    // (It shouldn't actually matter for unary ops whether\n-                                    // we enable two-phase borrows or not, since a unary\n-                                    // op has no additional operands.)\n-                                    allow_two_phase_borrow: AllowTwoPhase::No,\n-                                },\n-                            };\n-                            self.apply_adjustments(\n-                                oprnd,\n-                                vec![Adjustment {\n-                                    kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                                    target: method.sig.inputs()[0],\n-                                }],\n-                            );\n-                        }\n-                        oprnd_t = self.make_overloaded_place_return_type(method).ty;\n-                        self.write_method_call(expr.hir_id, method);\n+                    if let Some(ty) = self.lookup_derefing(expr, oprnd, oprnd_t) {\n+                        oprnd_t = ty;\n                     } else {\n                         let mut err = type_error_struct!(\n                             tcx.sess,\n@@ -405,8 +381,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => NoExpectation,\n             }\n         });\n-        let needs = Needs::maybe_mut_place(mutbl);\n-        let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n+        let ty =\n+            self.check_expr_with_expectation_and_needs(&oprnd, hint, Needs::maybe_mut_place(mutbl));\n \n         let tm = ty::TypeAndMut { ty, mutbl };\n         match kind {\n@@ -861,10 +837,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n     ) -> Ty<'tcx> {\n         let rcvr = &args[0];\n-        let rcvr_t = self.check_expr_with_needs(&rcvr, needs);\n+        let rcvr_t = self.check_expr(&rcvr);\n         // no need to check for bot/err -- callee does that\n         let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n \n@@ -1443,11 +1418,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_field(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n-        needs: Needs,\n         base: &'tcx hir::Expr<'tcx>,\n         field: Ident,\n     ) -> Ty<'tcx> {\n-        let expr_t = self.check_expr_with_needs(base, needs);\n+        let expr_t = self.check_expr(base);\n         let expr_t = self.structurally_resolved_type(base.span, expr_t);\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n@@ -1467,7 +1441,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // of error recovery.\n                         self.write_field_index(expr.hir_id, index);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let adjustments = autoderef.adjust_steps(self, needs);\n+                            let adjustments = autoderef.adjust_steps(self);\n                             self.apply_adjustments(base, adjustments);\n                             autoderef.finalize(self);\n \n@@ -1482,7 +1456,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {\n                             if let Some(field_ty) = tys.get(index) {\n-                                let adjustments = autoderef.adjust_steps(self, needs);\n+                                let adjustments = autoderef.adjust_steps(self);\n                                 self.apply_adjustments(base, adjustments);\n                                 autoderef.finalize(self);\n \n@@ -1721,10 +1695,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         base: &'tcx hir::Expr<'tcx>,\n         idx: &'tcx hir::Expr<'tcx>,\n-        needs: Needs,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n-        let base_t = self.check_expr_with_needs(&base, needs);\n+        let base_t = self.check_expr(&base);\n         let idx_t = self.check_expr(&idx);\n \n         if base_t.references_error() {\n@@ -1733,7 +1706,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             idx_t\n         } else {\n             let base_t = self.structurally_resolved_type(base.span, base_t);\n-            match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n+            match self.lookup_indexing(expr, base, base_t, idx_t) {\n                 Some((index_ty, element_ty)) => {\n                     // two-phase not needed because index_ty is never mutable\n                     self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);"}, {"sha": "21c359abf0b082cae60710b748d00eb4f2889f46", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a", "patch": "@@ -1,7 +1,7 @@\n use super::{probe, MethodCallee};\n \n use crate::astconv::AstConv;\n-use crate::check::{callee, FnCtxt, Needs};\n+use crate::check::{callee, FnCtxt};\n use crate::hir::def_id::DefId;\n use crate::hir::GenericArg;\n use rustc_hir as hir;\n@@ -145,7 +145,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         };\n         assert_eq!(n, pick.autoderefs);\n \n-        let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n+        let mut adjustments = autoderef.adjust_steps(self);\n \n         let mut target = autoderef.unambiguous_final_ty(self);\n "}, {"sha": "b1d32213b729e3a70fa5bee71d311a7da5d23293", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 151, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a", "patch": "@@ -79,7 +79,7 @@ pub mod intrinsic;\n pub mod method;\n mod op;\n mod pat;\n-mod reconciliation;\n+mod place_op;\n mod regionck;\n mod upvar;\n mod wfcheck;\n@@ -115,7 +115,7 @@ use rustc_infer::infer::{InferCtxt, InferOk, InferResult, RegionVariableOrigin,\n use rustc_middle::hir::map::blocks::FnLikeNode;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::adjustment::{\n-    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n+    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::query::Providers;\n@@ -156,7 +156,6 @@ use std::slice;\n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n \n-use self::autoderef::Autoderef;\n use self::callee::DeferredCallResolution;\n use self::coercion::{CoerceMany, DynamicCoerceMany};\n use self::compare_method::{compare_const_impl, compare_impl_method, compare_ty_impl};\n@@ -3618,154 +3617,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ret_ty.builtin_deref(true).unwrap()\n     }\n \n-    fn lookup_indexing(\n-        &self,\n-        expr: &hir::Expr<'_>,\n-        base_expr: &'tcx hir::Expr<'tcx>,\n-        base_ty: Ty<'tcx>,\n-        idx_ty: Ty<'tcx>,\n-        needs: Needs,\n-    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n-        // FIXME(#18741) -- this is almost but not quite the same as the\n-        // autoderef that normal method probing does. They could likely be\n-        // consolidated.\n-\n-        let mut autoderef = self.autoderef(base_expr.span, base_ty);\n-        let mut result = None;\n-        while result.is_none() && autoderef.next().is_some() {\n-            result = self.try_index_step(expr, base_expr, &autoderef, needs, idx_ty);\n-        }\n-        autoderef.finalize(self);\n-        result\n-    }\n-\n-    /// To type-check `base_expr[index_expr]`, we progressively autoderef\n-    /// (and otherwise adjust) `base_expr`, looking for a type which either\n-    /// supports builtin indexing or overloaded indexing.\n-    /// This loop implements one step in that search; the autoderef loop\n-    /// is implemented by `lookup_indexing`.\n-    fn try_index_step(\n-        &self,\n-        expr: &hir::Expr<'_>,\n-        base_expr: &hir::Expr<'_>,\n-        autoderef: &Autoderef<'a, 'tcx>,\n-        needs: Needs,\n-        index_ty: Ty<'tcx>,\n-    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n-        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n-        debug!(\n-            \"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n-             index_ty={:?})\",\n-            expr, base_expr, adjusted_ty, index_ty\n-        );\n-\n-        for &unsize in &[false, true] {\n-            let mut self_ty = adjusted_ty;\n-            if unsize {\n-                // We only unsize arrays here.\n-                if let ty::Array(element_ty, _) = adjusted_ty.kind {\n-                    self_ty = self.tcx.mk_slice(element_ty);\n-                } else {\n-                    continue;\n-                }\n-            }\n-\n-            // If some lookup succeeds, write callee into table and extract index/element\n-            // type from the method signature.\n-            // If some lookup succeeded, install method in table\n-            let input_ty = self.next_ty_var(TypeVariableOrigin {\n-                kind: TypeVariableOriginKind::AutoDeref,\n-                span: base_expr.span,\n-            });\n-            let method = self.try_overloaded_place_op(\n-                expr.span,\n-                self_ty,\n-                &[input_ty],\n-                needs,\n-                PlaceOp::Index,\n-            );\n-\n-            let result = method.map(|ok| {\n-                debug!(\"try_index_step: success, using overloaded indexing\");\n-                let method = self.register_infer_ok_obligations(ok);\n-\n-                let mut adjustments = autoderef.adjust_steps(self, needs);\n-                if let ty::Ref(region, _, r_mutbl) = method.sig.inputs()[0].kind {\n-                    let mutbl = match r_mutbl {\n-                        hir::Mutability::Not => AutoBorrowMutability::Not,\n-                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                            // Indexing can be desugared to a method call,\n-                            // so maybe we could use two-phase here.\n-                            // See the documentation of AllowTwoPhase for why that's\n-                            // not the case today.\n-                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                        },\n-                    };\n-                    adjustments.push(Adjustment {\n-                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                        target: self\n-                            .tcx\n-                            .mk_ref(region, ty::TypeAndMut { mutbl: r_mutbl, ty: adjusted_ty }),\n-                    });\n-                }\n-                if unsize {\n-                    adjustments.push(Adjustment {\n-                        kind: Adjust::Pointer(PointerCast::Unsize),\n-                        target: method.sig.inputs()[0],\n-                    });\n-                }\n-                self.apply_adjustments(base_expr, adjustments);\n-\n-                self.write_method_call(expr.hir_id, method);\n-                (input_ty, self.make_overloaded_place_return_type(method).ty)\n-            });\n-            if result.is_some() {\n-                return result;\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn resolve_place_op(&self, op: PlaceOp, is_mut: bool) -> (Option<DefId>, Ident) {\n-        let (tr, name) = match (op, is_mut) {\n-            (PlaceOp::Deref, false) => (self.tcx.lang_items().deref_trait(), sym::deref),\n-            (PlaceOp::Deref, true) => (self.tcx.lang_items().deref_mut_trait(), sym::deref_mut),\n-            (PlaceOp::Index, false) => (self.tcx.lang_items().index_trait(), sym::index),\n-            (PlaceOp::Index, true) => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n-        };\n-        (tr, Ident::with_dummy_span(name))\n-    }\n-\n-    fn try_overloaded_place_op(\n-        &self,\n-        span: Span,\n-        base_ty: Ty<'tcx>,\n-        arg_tys: &[Ty<'tcx>],\n-        needs: Needs,\n-        op: PlaceOp,\n-    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        debug!(\"try_overloaded_place_op({:?},{:?},{:?},{:?})\", span, base_ty, needs, op);\n-\n-        // Try Mut first, if needed.\n-        let (mut_tr, mut_op) = self.resolve_place_op(op, true);\n-        let method = match (needs, mut_tr) {\n-            (Needs::MutPlace, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, mut_op, trait_did, base_ty, Some(arg_tys))\n-            }\n-            _ => None,\n-        };\n-\n-        // Otherwise, fall back to the immutable version.\n-        let (imm_tr, imm_op) = self.resolve_place_op(op, false);\n-        match (method, imm_tr) {\n-            (None, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, imm_op, trait_did, base_ty, Some(arg_tys))\n-            }\n-            (method, _) => method,\n-        }\n-    }\n-\n     fn check_method_argument_types(\n         &self,\n         sp: Span,"}, {"sha": "41088b0790813e8a45bbfc8b53b395f77d5dc50c", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a", "patch": "@@ -1,7 +1,7 @@\n //! Code related to processing overloaded binary and unary operators.\n \n use super::method::MethodCallee;\n-use super::{FnCtxt, Needs};\n+use super::FnCtxt;\n use rustc_errors::{self, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -165,7 +165,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // trait matching creating lifetime constraints that are too strict.\n                 // e.g., adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n                 // in `&'a T <: &'x T` and `&'b T <: &'x T`, instead of `'a = 'b = 'x`.\n-                let lhs_ty = self.check_expr_with_needs(lhs_expr, Needs::None);\n+                let lhs_ty = self.check_expr(lhs_expr);\n                 let fresh_var = self.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: lhs_expr.span,\n@@ -177,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // equivalence on the LHS of an assign-op like `+=`;\n                 // overwritten or mutably-borrowed places cannot be\n                 // coerced to a supertype.\n-                self.check_expr_with_needs(lhs_expr, Needs::MutPlace)\n+                self.check_expr(lhs_expr)\n             }\n         };\n         let lhs_ty = self.resolve_vars_with_obligations(lhs_ty);"}, {"sha": "ce4b6f8baf917116710b4f3c5505deaef1a32dac", "filename": "src/librustc_typeck/check/place_op.rs", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs?ref=5cedf5dfba1c83f2fe3e2fcb7acbc20c6e34604a", "patch": "@@ -0,0 +1,334 @@\n+use crate::check::autoderef::Autoderef;\n+use crate::check::method::MethodCallee;\n+use crate::check::{FnCtxt, PlaceOp};\n+use rustc_hir as hir;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::InferOk;\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref, PointerCast};\n+use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::Span;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub(super) fn lookup_derefing(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        oprnd: &'tcx hir::Expr<'tcx>,\n+        oprnd_ty: Ty<'tcx>,\n+    ) -> Option<Ty<'tcx>> {\n+        if let Some(mt) = oprnd_ty.builtin_deref(true) {\n+            return Some(mt.ty);\n+        }\n+\n+        let ok = self.try_overloaded_deref(expr.span, oprnd_ty)?;\n+        let method = self.register_infer_ok_obligations(ok);\n+        if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind {\n+            self.apply_adjustments(\n+                oprnd,\n+                vec![Adjustment {\n+                    kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),\n+                    target: method.sig.inputs()[0],\n+                }],\n+            );\n+        } else {\n+            span_bug!(expr.span, \"input to deref is not a ref?\");\n+        }\n+        let ty = self.make_overloaded_place_return_type(method).ty;\n+        self.write_method_call(expr.hir_id, method);\n+        Some(ty)\n+    }\n+\n+    pub(super) fn lookup_indexing(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &'tcx hir::Expr<'tcx>,\n+        base_ty: Ty<'tcx>,\n+        idx_ty: Ty<'tcx>,\n+    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n+        // FIXME(#18741) -- this is almost but not quite the same as the\n+        // autoderef that normal method probing does. They could likely be\n+        // consolidated.\n+\n+        let mut autoderef = self.autoderef(base_expr.span, base_ty);\n+        let mut result = None;\n+        while result.is_none() && autoderef.next().is_some() {\n+            result = self.try_index_step(expr, base_expr, &autoderef, idx_ty);\n+        }\n+        autoderef.finalize(self);\n+        result\n+    }\n+\n+    /// To type-check `base_expr[index_expr]`, we progressively autoderef\n+    /// (and otherwise adjust) `base_expr`, looking for a type which either\n+    /// supports builtin indexing or overloaded indexing.\n+    /// This loop implements one step in that search; the autoderef loop\n+    /// is implemented by `lookup_indexing`.\n+    fn try_index_step(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &hir::Expr<'_>,\n+        autoderef: &Autoderef<'a, 'tcx>,\n+        index_ty: Ty<'tcx>,\n+    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n+        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n+        debug!(\n+            \"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n+             index_ty={:?})\",\n+            expr, base_expr, adjusted_ty, index_ty\n+        );\n+\n+        for &unsize in &[false, true] {\n+            let mut self_ty = adjusted_ty;\n+            if unsize {\n+                // We only unsize arrays here.\n+                if let ty::Array(element_ty, _) = adjusted_ty.kind {\n+                    self_ty = self.tcx.mk_slice(element_ty);\n+                } else {\n+                    continue;\n+                }\n+            }\n+\n+            // If some lookup succeeds, write callee into table and extract index/element\n+            // type from the method signature.\n+            // If some lookup succeeded, install method in table\n+            let input_ty = self.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::AutoDeref,\n+                span: base_expr.span,\n+            });\n+            let method =\n+                self.try_overloaded_place_op(expr.span, self_ty, &[input_ty], PlaceOp::Index);\n+\n+            let result = method.map(|ok| {\n+                debug!(\"try_index_step: success, using overloaded indexing\");\n+                let method = self.register_infer_ok_obligations(ok);\n+\n+                let mut adjustments = autoderef.adjust_steps(self);\n+                if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind {\n+                    adjustments.push(Adjustment {\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),\n+                        target: self.tcx.mk_ref(\n+                            region,\n+                            ty::TypeAndMut { mutbl: hir::Mutability::Not, ty: adjusted_ty },\n+                        ),\n+                    });\n+                } else {\n+                    span_bug!(expr.span, \"input to index is not a ref?\");\n+                }\n+                if unsize {\n+                    adjustments.push(Adjustment {\n+                        kind: Adjust::Pointer(PointerCast::Unsize),\n+                        target: method.sig.inputs()[0],\n+                    });\n+                }\n+                self.apply_adjustments(base_expr, adjustments);\n+\n+                self.write_method_call(expr.hir_id, method);\n+                (input_ty, self.make_overloaded_place_return_type(method).ty)\n+            });\n+            if result.is_some() {\n+                return result;\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Try to resolve an overloaded place op. We only deal with the immutable\n+    /// variant here (Deref/Index). In some contexts we would need the mutable\n+    /// variant (DerefMut/IndexMut); those would be later converted by\n+    /// `convert_place_derefs_to_mutable`.\n+    pub(super) fn try_overloaded_place_op(\n+        &self,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+        arg_tys: &[Ty<'tcx>],\n+        op: PlaceOp,\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        debug!(\"try_overloaded_place_op({:?},{:?},{:?})\", span, base_ty, op);\n+\n+        let (imm_tr, imm_op) = match op {\n+            PlaceOp::Deref => (self.tcx.lang_items().deref_trait(), sym::deref),\n+            PlaceOp::Index => (self.tcx.lang_items().index_trait(), sym::index),\n+        };\n+        imm_tr.and_then(|trait_did| {\n+            self.lookup_method_in_trait(\n+                span,\n+                Ident::with_dummy_span(imm_op),\n+                trait_did,\n+                base_ty,\n+                Some(arg_tys),\n+            )\n+        })\n+    }\n+\n+    fn try_mutable_overloaded_place_op(\n+        &self,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+        arg_tys: &[Ty<'tcx>],\n+        op: PlaceOp,\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        debug!(\"try_mutable_overloaded_place_op({:?},{:?},{:?})\", span, base_ty, op);\n+\n+        let (mut_tr, mut_op) = match op {\n+            PlaceOp::Deref => (self.tcx.lang_items().deref_mut_trait(), sym::deref_mut),\n+            PlaceOp::Index => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n+        };\n+        mut_tr.and_then(|trait_did| {\n+            self.lookup_method_in_trait(\n+                span,\n+                Ident::with_dummy_span(mut_op),\n+                trait_did,\n+                base_ty,\n+                Some(arg_tys),\n+            )\n+        })\n+    }\n+\n+    /// Convert auto-derefs, indices, etc of an expression from `Deref` and `Index`\n+    /// into `DerefMut` and `IndexMut` respectively.\n+    ///\n+    /// This is a second pass of typechecking derefs/indices. We need this we do not\n+    /// always know whether a place needs to be mutable or not in the first pass.\n+    /// This happens whether there is an implicit mutable reborrow, e.g. when the type\n+    /// is used as the receiver of a method call.\n+    pub fn convert_place_derefs_to_mutable(&self, expr: &hir::Expr<'_>) {\n+        // Gather up expressions we want to munge.\n+        let mut exprs = vec![expr];\n+\n+        loop {\n+            match exprs.last().unwrap().kind {\n+                hir::ExprKind::Field(ref expr, _)\n+                | hir::ExprKind::Index(ref expr, _)\n+                | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) => exprs.push(&expr),\n+                _ => break,\n+            }\n+        }\n+\n+        debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n+\n+        // Fix up autoderefs and derefs.\n+        for (i, &expr) in exprs.iter().rev().enumerate() {\n+            debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n+\n+            // Fix up the autoderefs. Autorefs can only occur immediately preceding\n+            // overloaded place ops, and will be fixed by them in order to get\n+            // the correct region.\n+            let mut source = self.node_ty(expr.hir_id);\n+            // Do not mutate adjustments in place, but rather take them,\n+            // and replace them after mutating them, to avoid having the\n+            // tables borrowed during (`deref_mut`) method resolution.\n+            let previous_adjustments =\n+                self.tables.borrow_mut().adjustments_mut().remove(expr.hir_id);\n+            if let Some(mut adjustments) = previous_adjustments {\n+                for adjustment in &mut adjustments {\n+                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n+                        if let Some(ok) = self.try_mutable_overloaded_place_op(\n+                            expr.span,\n+                            source,\n+                            &[],\n+                            PlaceOp::Deref,\n+                        ) {\n+                            let method = self.register_infer_ok_obligations(ok);\n+                            if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n+                                *deref = OverloadedDeref { region, mutbl };\n+                            }\n+                        }\n+                    }\n+                    source = adjustment.target;\n+                }\n+                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n+            }\n+\n+            match expr.kind {\n+                hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n+                    // We need to get the final type in case dereferences were needed for the trait\n+                    // to apply (#72002).\n+                    let index_expr_ty = self.tables.borrow().expr_ty_adjusted(index_expr);\n+                    self.convert_place_op_to_mutable(\n+                        PlaceOp::Index,\n+                        expr,\n+                        base_expr,\n+                        &[index_expr_ty],\n+                    );\n+                }\n+                hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base_expr) => {\n+                    self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr, &[]);\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    fn convert_place_op_to_mutable(\n+        &self,\n+        op: PlaceOp,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &hir::Expr<'_>,\n+        arg_tys: &[Ty<'tcx>],\n+    ) {\n+        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);\n+        if !self.tables.borrow().is_method_call(expr) {\n+            debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n+            return;\n+        }\n+\n+        // Need to deref because overloaded place ops take self by-reference.\n+        let base_ty = self\n+            .tables\n+            .borrow()\n+            .expr_ty_adjusted(base_expr)\n+            .builtin_deref(false)\n+            .expect(\"place op takes something that is not a ref\")\n+            .ty;\n+\n+        let method = self.try_mutable_overloaded_place_op(expr.span, base_ty, arg_tys, op);\n+        let method = match method {\n+            Some(ok) => self.register_infer_ok_obligations(ok),\n+            // Couldn't find the mutable variant of the place op, keep the\n+            // current, immutable version.\n+            None => return,\n+        };\n+        debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n+        self.write_method_call(expr.hir_id, method);\n+\n+        let region = if let ty::Ref(r, _, hir::Mutability::Mut) = method.sig.inputs()[0].kind {\n+            r\n+        } else {\n+            span_bug!(expr.span, \"input to mutable place op is not a mut ref?\");\n+        };\n+\n+        // Convert the autoref in the base expr to mutable with the correct\n+        // region and mutability.\n+        let base_expr_ty = self.node_ty(base_expr.hir_id);\n+        if let Some(adjustments) =\n+            self.tables.borrow_mut().adjustments_mut().get_mut(base_expr.hir_id)\n+        {\n+            let mut source = base_expr_ty;\n+            for adjustment in &mut adjustments[..] {\n+                if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n+                    debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n+                    let mutbl = AutoBorrowMutability::Mut {\n+                        // Deref/indexing can be desugared to a method call,\n+                        // so maybe we could use two-phase here.\n+                        // See the documentation of AllowTwoPhase for why that's\n+                        // not the case today.\n+                        allow_two_phase_borrow: AllowTwoPhase::No,\n+                    };\n+                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n+                    adjustment.target =\n+                        self.tcx.mk_ref(region, ty::TypeAndMut { ty: source, mutbl: mutbl.into() });\n+                }\n+                source = adjustment.target;\n+            }\n+\n+            // If we have an autoref followed by unsizing at the end, fix the unsize target.\n+            if let [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. }, Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), ref mut target }] =\n+                adjustments[..]\n+            {\n+                *target = method.sig.inputs()[0];\n+            }\n+        }\n+    }\n+}"}, {"sha": "0a4293140a82af250f28be3ffce27d70eed116c9", "filename": "src/librustc_typeck/check/reconciliation.rs", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/e390acdfccdc5297e8fbb186bbb890cb6a3d0e57/src%2Flibrustc_typeck%2Fcheck%2Freconciliation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e390acdfccdc5297e8fbb186bbb890cb6a3d0e57/src%2Flibrustc_typeck%2Fcheck%2Freconciliation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Freconciliation.rs?ref=e390acdfccdc5297e8fbb186bbb890cb6a3d0e57", "patch": "@@ -1,150 +0,0 @@\n-use crate::check::{FnCtxt, Needs, PlaceOp};\n-use rustc_hir as hir;\n-use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref, PointerCast};\n-use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n-use rustc_middle::ty::{self, Ty};\n-\n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    /// Convert auto-derefs, indices, etc of an expression from `Deref` and `Index`\n-    /// into `DerefMut` and `IndexMut` respectively.\n-    ///\n-    /// This is a second pass of typechecking derefs/indices. We need this we do not\n-    /// always know whether a place needs to be mutable or not in the first pass.\n-    /// This happens whether there is an implicit mutable reborrow, e.g. when the type\n-    /// is used as the receiver of a method call.\n-    pub fn convert_place_derefs_to_mutable(&self, expr: &hir::Expr<'_>) {\n-        // Gather up expressions we want to munge.\n-        let mut exprs = vec![expr];\n-\n-        loop {\n-            match exprs.last().unwrap().kind {\n-                hir::ExprKind::Field(ref expr, _)\n-                | hir::ExprKind::Index(ref expr, _)\n-                | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) => exprs.push(&expr),\n-                _ => break,\n-            }\n-        }\n-\n-        debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n-\n-        // Fix up autoderefs and derefs.\n-        for (i, &expr) in exprs.iter().rev().enumerate() {\n-            debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n-\n-            // Fix up the autoderefs. Autorefs can only occur immediately preceding\n-            // overloaded place ops, and will be fixed by them in order to get\n-            // the correct region.\n-            let mut source = self.node_ty(expr.hir_id);\n-            // Do not mutate adjustments in place, but rather take them,\n-            // and replace them after mutating them, to avoid having the\n-            // tables borrowed during (`deref_mut`) method resolution.\n-            let previous_adjustments =\n-                self.tables.borrow_mut().adjustments_mut().remove(expr.hir_id);\n-            if let Some(mut adjustments) = previous_adjustments {\n-                let needs = Needs::MutPlace;\n-                for adjustment in &mut adjustments {\n-                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n-                        if let Some(ok) = self.try_overloaded_deref(expr.span, source, needs) {\n-                            let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n-                                *deref = OverloadedDeref { region, mutbl };\n-                            }\n-                        }\n-                    }\n-                    source = adjustment.target;\n-                }\n-                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n-            }\n-\n-            match expr.kind {\n-                hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n-                    // We need to get the final type in case dereferences were needed for the trait\n-                    // to apply (#72002).\n-                    let index_expr_ty = self.tables.borrow().expr_ty_adjusted(index_expr);\n-                    self.convert_place_op_to_mutable(\n-                        PlaceOp::Index,\n-                        expr,\n-                        base_expr,\n-                        &[index_expr_ty],\n-                    );\n-                }\n-                hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base_expr) => {\n-                    self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr, &[]);\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    fn convert_place_op_to_mutable(\n-        &self,\n-        op: PlaceOp,\n-        expr: &hir::Expr<'_>,\n-        base_expr: &hir::Expr<'_>,\n-        arg_tys: &[Ty<'tcx>],\n-    ) {\n-        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);\n-        if !self.tables.borrow().is_method_call(expr) {\n-            debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n-            return;\n-        }\n-\n-        // Need to deref because overloaded place ops take self by-reference.\n-        let base_ty = self\n-            .tables\n-            .borrow()\n-            .expr_ty_adjusted(base_expr)\n-            .builtin_deref(false)\n-            .expect(\"place op takes something that is not a ref\")\n-            .ty;\n-\n-        let method = self.try_overloaded_place_op(expr.span, base_ty, arg_tys, Needs::MutPlace, op);\n-        let method = match method {\n-            Some(ok) => self.register_infer_ok_obligations(ok),\n-            None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\"),\n-        };\n-        debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n-        self.write_method_call(expr.hir_id, method);\n-\n-        let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].kind {\n-            (r, mutbl)\n-        } else {\n-            span_bug!(expr.span, \"input to place op is not a ref?\");\n-        };\n-\n-        // Convert the autoref in the base expr to mutable with the correct\n-        // region and mutability.\n-        let base_expr_ty = self.node_ty(base_expr.hir_id);\n-        if let Some(adjustments) =\n-            self.tables.borrow_mut().adjustments_mut().get_mut(base_expr.hir_id)\n-        {\n-            let mut source = base_expr_ty;\n-            for adjustment in &mut adjustments[..] {\n-                if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n-                    debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n-                    let mutbl = match mutbl {\n-                        hir::Mutability::Not => AutoBorrowMutability::Not,\n-                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                            // For initial two-phase borrow\n-                            // deployment, conservatively omit\n-                            // overloaded operators.\n-                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                        },\n-                    };\n-                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n-                    adjustment.target =\n-                        self.tcx.mk_ref(region, ty::TypeAndMut { ty: source, mutbl: mutbl.into() });\n-                }\n-                source = adjustment.target;\n-            }\n-\n-            // If we have an autoref followed by unsizing at the end, fix the unsize target.\n-\n-            if let [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. }, Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), ref mut target }] =\n-                adjustments[..]\n-            {\n-                *target = method.sig.inputs()[0];\n-            }\n-        }\n-    }\n-}"}]}