{"sha": "458555dbf6e4847e8b4f19d31f37f45baf7fd128", "node_id": "C_kwDOAAsO6NoAKDQ1ODU1NWRiZjZlNDg0N2U4YjRmMTlkMzFmMzdmNDViYWY3ZmQxMjg", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-09-16T05:47:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-16T05:47:02Z"}, "message": "Rollup merge of #101809 - aDotInTheVoid:jsondoclint, r=GuillaumeGomez\n\nReplace `check_missing_items.py` with `jsondoclint`\n\n[zulip discussion](https://rust-lang.zulipchat.com/#narrow/stream/266220-rustdoc/topic/check_missing_items.2Epy.20Replacement.2E)\n\ncheck_missing_items.py was a python script that checked rustdoc json output to make sure all the Id's referenced existed in the JSON index. This PR replaces that with a rust binary (`jsondoclint`) that does the same thing.\n\n### Motivation\n\n1. Easier to change when `rustdoc-json-types` changes, as `jsondoclint` uses the types directly.\n2. Better Errors:\n    - Multiple Errors can be emited for a single crate\n    - Errors can say where in JSON they occored\n        ```\n        2:2889:408 not in index or paths, but refered to at '.index.\"2:2888:104\".inner.items[0]'\n        2:2890:410 not in index or paths, but refered to at '.index.\"2:2888:104\".inner.items[1]'\n        ```\n3. Catches more bugs.\n    - Because matches are exaustive, all posible variants considered for enums\n    - All Id's checked\n    - Has already found #101770, #101199 and #100973\n    - Id type is also checked, so the Id's in a structs fields can only be field items.\n4. Allows the possibility of running from `rustdoc::json`, which we should do in a crator run at some point.\n\ncc ``@CraftSpider``\n\nr? ``@GuillaumeGomez``", "tree": {"sha": "6d6159c935e7b28ae536b5aadf72dad0f5238593", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d6159c935e7b28ae536b5aadf72dad0f5238593"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/458555dbf6e4847e8b4f19d31f37f45baf7fd128", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjJA3WCRBK7hj4Ov3rIwAA7fEIAHDllPrZ/Tsx6Gy/N2B87rQQ\nMOPa0BG6litcETJPvsSPNFaBKhJqclvYYo9o/xZy6aWDlyO4WzUFej2Z7GVJXXXk\nmXuxQ9S6XaJkI1NWLDr7HeeqPnnHOOhNjnW40KVrj4OjWNRhYvypOxd0hrhBBt+X\n8DYiYw9sNZ04hkzKZxtjR+QU3Qv2HVJTMtI2kXkjVLWJ+VelJnTDZY3l5aqeQM5Y\nM9lcoeKDV/42SMhMwFoMZghodO3FQ/D1AN7WFFMc5b5tDB5/yhKNk2ATo4ipxO4n\ntyjxbWMUiD+FW2BGQKMJZeEYeL31oYdqh1um6swy6ND8xSdF5tUnkWQB2LBWtkw=\n=iqto\n-----END PGP SIGNATURE-----\n", "payload": "tree 6d6159c935e7b28ae536b5aadf72dad0f5238593\nparent cfef659d137e0491c3a1356ffd4dbd2968c18404\nparent f69a6c2a8018ac69db62446996e815893b70dfcd\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1663307222 +0530\ncommitter GitHub <noreply@github.com> 1663307222 +0530\n\nRollup merge of #101809 - aDotInTheVoid:jsondoclint, r=GuillaumeGomez\n\nReplace `check_missing_items.py` with `jsondoclint`\n\n[zulip discussion](https://rust-lang.zulipchat.com/#narrow/stream/266220-rustdoc/topic/check_missing_items.2Epy.20Replacement.2E)\n\ncheck_missing_items.py was a python script that checked rustdoc json output to make sure all the Id's referenced existed in the JSON index. This PR replaces that with a rust binary (`jsondoclint`) that does the same thing.\n\n### Motivation\n\n1. Easier to change when `rustdoc-json-types` changes, as `jsondoclint` uses the types directly.\n2. Better Errors:\n    - Multiple Errors can be emited for a single crate\n    - Errors can say where in JSON they occored\n        ```\n        2:2889:408 not in index or paths, but refered to at '.index.\"2:2888:104\".inner.items[0]'\n        2:2890:410 not in index or paths, but refered to at '.index.\"2:2888:104\".inner.items[1]'\n        ```\n3. Catches more bugs.\n    - Because matches are exaustive, all posible variants considered for enums\n    - All Id's checked\n    - Has already found #101770, #101199 and #100973\n    - Id type is also checked, so the Id's in a structs fields can only be field items.\n4. Allows the possibility of running from `rustdoc::json`, which we should do in a crator run at some point.\n\ncc ``@CraftSpider``\n\nr? ``@GuillaumeGomez``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/458555dbf6e4847e8b4f19d31f37f45baf7fd128", "html_url": "https://github.com/rust-lang/rust/commit/458555dbf6e4847e8b4f19d31f37f45baf7fd128", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/458555dbf6e4847e8b4f19d31f37f45baf7fd128/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfef659d137e0491c3a1356ffd4dbd2968c18404", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfef659d137e0491c3a1356ffd4dbd2968c18404", "html_url": "https://github.com/rust-lang/rust/commit/cfef659d137e0491c3a1356ffd4dbd2968c18404"}, {"sha": "f69a6c2a8018ac69db62446996e815893b70dfcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f69a6c2a8018ac69db62446996e815893b70dfcd", "html_url": "https://github.com/rust-lang/rust/commit/f69a6c2a8018ac69db62446996e815893b70dfcd"}], "stats": {"total": 1030, "additions": 816, "deletions": 214}, "files": [{"sha": "69f96bcbe63b43353df462f657f9f01c52b543af", "filename": "Cargo.lock", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -103,9 +103,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.60\"\n+version = \"1.0.65\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c794e162a5eff65c72ef524dfe393eb923c354e350bb78b9c7383df13f3bc142\"\n+checksum = \"98161a4e3e2184da77bb14f02184cdd111e83bbbcc9979dfee3c44b9a85f5602\"\n \n [[package]]\n name = \"array_tool\"\n@@ -1362,9 +1362,9 @@ dependencies = [\n \n [[package]]\n name = \"fs-err\"\n-version = \"2.5.0\"\n+version = \"2.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bcd1163ae48bda72a20ae26d66a04d3094135cadab911cff418ae5e33f253431\"\n+checksum = \"64db3e262960f0662f43a6366788d5f10f7f244b8f7d7d987f560baf5ded5c50\"\n \n [[package]]\n name = \"fs_extra\"\n@@ -1891,6 +1891,16 @@ dependencies = [\n  \"shlex\",\n ]\n \n+[[package]]\n+name = \"jsondoclint\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"fs-err\",\n+ \"rustdoc-json-types\",\n+ \"serde_json\",\n+]\n+\n [[package]]\n name = \"jsonpath_lib\"\n version = \"0.2.6\"\n@@ -4445,9 +4455,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.83\"\n+version = \"1.0.85\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"38dd04e3c8279e75b31ef29dbdceebfe5ad89f4d0937213c53f7d49d01b3d5a7\"\n+checksum = \"e55a28e3aaef9d5ce0506d0a14dbba8054ddc7e499ef522dd8b26859ec9d4a44\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\","}, {"sha": "e49fe5e2f6356b302552384d5b0b7a3d7e8aa8e0", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -33,6 +33,7 @@ members = [\n   \"src/tools/unicode-table-generator\",\n   \"src/tools/expand-yaml-anchors\",\n   \"src/tools/jsondocck\",\n+  \"src/tools/jsondoclint\",\n   \"src/tools/html-checker\",\n   \"src/tools/bump-stage0\",\n   \"src/tools/replace-version-placeholder\","}, {"sha": "9d286ddd6d1646e107643f83c9c19e8af07c96c2", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -1341,6 +1341,8 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             let json_compiler = compiler.with_stage(0);\n             cmd.arg(\"--jsondocck-path\")\n                 .arg(builder.ensure(tool::JsonDocCk { compiler: json_compiler, target }));\n+            cmd.arg(\"--jsondoclint-path\")\n+                .arg(builder.ensure(tool::JsonDocLint { compiler: json_compiler, target }));\n         }\n \n         if mode == \"run-make\" {"}, {"sha": "7d4ed24b64850c6422e9f5566d70b5278ced0c6b", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -376,6 +376,7 @@ bootstrap_tool!(\n     ExpandYamlAnchors, \"src/tools/expand-yaml-anchors\", \"expand-yaml-anchors\";\n     LintDocs, \"src/tools/lint-docs\", \"lint-docs\";\n     JsonDocCk, \"src/tools/jsondocck\", \"jsondocck\";\n+    JsonDocLint, \"src/tools/jsondoclint\", \"jsondoclint\";\n     HtmlChecker, \"src/tools/html-checker\", \"html-checker\";\n     BumpStage0, \"src/tools/bump-stage0\", \"bump-stage0\";\n     ReplaceVersionPlaceholder, \"src/tools/replace-version-placeholder\", \"replace-version-placeholder\";"}, {"sha": "0026c4cbdca2ce609a64d5df04f02c3680bb1d33", "filename": "src/etc/check_missing_items.py", "status": "removed", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/cfef659d137e0491c3a1356ffd4dbd2968c18404/src%2Fetc%2Fcheck_missing_items.py", "raw_url": "https://github.com/rust-lang/rust/raw/cfef659d137e0491c3a1356ffd4dbd2968c18404/src%2Fetc%2Fcheck_missing_items.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck_missing_items.py?ref=cfef659d137e0491c3a1356ffd4dbd2968c18404", "patch": "@@ -1,202 +0,0 @@\n-#!/usr/bin/env python\n-\n-# This test ensures that every ID in the produced json actually resolves to an item either in\n-# `index` or `paths`. It DOES NOT check that the structure of the produced json is actually in\n-# any way correct, for example an empty map would pass.\n-\n-# FIXME: Better error output\n-\n-import sys\n-import json\n-\n-crate = json.load(open(sys.argv[1], encoding=\"utf-8\"))\n-\n-\n-def get_local_item(item_id):\n-    if item_id in crate[\"index\"]:\n-        return crate[\"index\"][item_id]\n-    print(\"Missing local ID:\", item_id)\n-    sys.exit(1)\n-\n-\n-# local IDs have to be in `index`, external ones can sometimes be in `index` but otherwise have\n-# to be in `paths`\n-def valid_id(item_id):\n-    return item_id in crate[\"index\"] or item_id[0] != \"0\" and item_id in crate[\"paths\"]\n-\n-\n-def check_generics(generics):\n-    for param in generics[\"params\"]:\n-        check_generic_param(param)\n-    for where_predicate in generics[\"where_predicates\"]:\n-        if \"bound_predicate\" in where_predicate:\n-            pred = where_predicate[\"bound_predicate\"]\n-            check_type(pred[\"type\"])\n-            for bound in pred[\"bounds\"]:\n-                check_generic_bound(bound)\n-        elif \"region_predicate\" in where_predicate:\n-            pred = where_predicate[\"region_predicate\"]\n-            for bound in pred[\"bounds\"]:\n-                check_generic_bound(bound)\n-        elif \"eq_predicate\" in where_predicate:\n-            pred = where_predicate[\"eq_predicate\"]\n-            check_type(pred[\"rhs\"])\n-            check_type(pred[\"lhs\"])\n-\n-\n-def check_generic_param(param):\n-    if \"type\" in param[\"kind\"]:\n-        ty = param[\"kind\"][\"type\"]\n-        if ty[\"default\"]:\n-            check_type(ty[\"default\"])\n-        for bound in ty[\"bounds\"]:\n-            check_generic_bound(bound)\n-    elif \"const\" in param[\"kind\"]:\n-        check_type(param[\"kind\"][\"const\"])\n-\n-\n-def check_generic_bound(bound):\n-    if \"trait_bound\" in bound:\n-        for param in bound[\"trait_bound\"][\"generic_params\"]:\n-            check_generic_param(param)\n-        check_path(bound[\"trait_bound\"][\"trait\"])\n-\n-\n-def check_decl(decl):\n-    for (_name, ty) in decl[\"inputs\"]:\n-        check_type(ty)\n-    if decl[\"output\"]:\n-        check_type(decl[\"output\"])\n-\n-def check_path(path):\n-    args = path[\"args\"]\n-    if args:\n-        if \"angle_bracketed\" in args:\n-            for arg in args[\"angle_bracketed\"][\"args\"]:\n-                if \"type\" in arg:\n-                    check_type(arg[\"type\"])\n-                elif \"const\" in arg:\n-                    check_type(arg[\"const\"][\"type\"])\n-            for binding in args[\"angle_bracketed\"][\"bindings\"]:\n-                if \"equality\" in binding[\"binding\"]:\n-                    term = binding[\"binding\"][\"equality\"]\n-                    if \"type\" in term: check_type(term[\"type\"])\n-                    elif \"const\" in term: check_type(term[\"const\"])\n-                elif \"constraint\" in binding[\"binding\"]:\n-                    for bound in binding[\"binding\"][\"constraint\"]:\n-                        check_generic_bound(bound)\n-        elif \"parenthesized\" in args:\n-            for input_ty in args[\"parenthesized\"][\"inputs\"]:\n-                check_type(input_ty)\n-            if args[\"parenthesized\"][\"output\"]:\n-                check_type(args[\"parenthesized\"][\"output\"])\n-\n-    if path[\"id\"] in crate[\"index\"]:\n-        work_list.add(path[\"id\"])\n-    elif path[\"id\"] not in crate[\"paths\"]:\n-        print(\"Id not in index or paths:\", path[\"id\"])\n-        sys.exit(1)\n-\n-def check_type(ty):\n-    if ty[\"kind\"] == \"resolved_path\":\n-        check_path(ty[\"inner\"])\n-    elif ty[\"kind\"] == \"tuple\":\n-        for ty in ty[\"inner\"]:\n-            check_type(ty)\n-    elif ty[\"kind\"] == \"slice\":\n-        check_type(ty[\"inner\"])\n-    elif ty[\"kind\"] == \"impl_trait\":\n-        for bound in ty[\"inner\"]:\n-            check_generic_bound(bound)\n-    elif ty[\"kind\"] in (\"raw_pointer\", \"borrowed_ref\", \"array\"):\n-        check_type(ty[\"inner\"][\"type\"])\n-    elif ty[\"kind\"] == \"function_pointer\":\n-        for param in ty[\"inner\"][\"generic_params\"]:\n-            check_generic_param(param)\n-        check_decl(ty[\"inner\"][\"decl\"])\n-    elif ty[\"kind\"] == \"qualified_path\":\n-        check_type(ty[\"inner\"][\"self_type\"])\n-        check_path(ty[\"inner\"][\"trait\"])\n-\n-\n-work_list = set([crate[\"root\"]])\n-visited = work_list.copy()\n-\n-while work_list:\n-    current = work_list.pop()\n-    visited.add(current)\n-    item = get_local_item(current)\n-    # check intradoc links\n-    for (_name, link) in item[\"links\"].items():\n-        if not valid_id(link):\n-            print(\"Intra-doc link contains invalid ID:\", link)\n-\n-    # check all fields that reference types such as generics as well as nested items\n-    # (modules, structs, traits, and enums)\n-    if item[\"kind\"] == \"module\":\n-        work_list |= set(item[\"inner\"][\"items\"]) - visited\n-    elif item[\"kind\"] == \"struct\":\n-        check_generics(item[\"inner\"][\"generics\"])\n-        work_list |= set(item[\"inner\"][\"impls\"]) - visited\n-        if \"tuple\" in item[\"inner\"][\"kind\"]:\n-            work_list |= set(filter(None, item[\"inner\"][\"kind\"][\"tuple\"])) - visited\n-        elif \"plain\" in item[\"inner\"][\"kind\"]:\n-            work_list |= set(item[\"inner\"][\"kind\"][\"plain\"][\"fields\"]) - visited\n-    elif item[\"kind\"] == \"struct_field\":\n-        check_type(item[\"inner\"])\n-    elif item[\"kind\"] == \"enum\":\n-        check_generics(item[\"inner\"][\"generics\"])\n-        work_list |= (\n-            set(item[\"inner\"][\"variants\"]) | set(item[\"inner\"][\"impls\"])\n-        ) - visited\n-    elif item[\"kind\"] == \"variant\":\n-        if item[\"inner\"][\"variant_kind\"] == \"tuple\":\n-            for field_id in filter(None, item[\"inner\"][\"variant_inner\"]):\n-                work_list.add(field_id)\n-        elif item[\"inner\"][\"variant_kind\"] == \"struct\":\n-            work_list |= set(item[\"inner\"][\"variant_inner\"][\"fields\"]) - visited\n-    elif item[\"kind\"] in (\"function\", \"method\"):\n-        check_generics(item[\"inner\"][\"generics\"])\n-        check_decl(item[\"inner\"][\"decl\"])\n-    elif item[\"kind\"] in (\"static\", \"constant\", \"assoc_const\"):\n-        check_type(item[\"inner\"][\"type\"])\n-    elif item[\"kind\"] == \"typedef\":\n-        check_type(item[\"inner\"][\"type\"])\n-        check_generics(item[\"inner\"][\"generics\"])\n-    elif item[\"kind\"] == \"opaque_ty\":\n-        check_generics(item[\"inner\"][\"generics\"])\n-        for bound in item[\"inner\"][\"bounds\"]:\n-            check_generic_bound(bound)\n-    elif item[\"kind\"] == \"trait_alias\":\n-        check_generics(item[\"inner\"][\"params\"])\n-        for bound in item[\"inner\"][\"bounds\"]:\n-            check_generic_bound(bound)\n-    elif item[\"kind\"] == \"trait\":\n-        check_generics(item[\"inner\"][\"generics\"])\n-        for bound in item[\"inner\"][\"bounds\"]:\n-            check_generic_bound(bound)\n-        work_list |= (\n-            set(item[\"inner\"][\"items\"]) | set(item[\"inner\"][\"implementations\"])\n-        ) - visited\n-    elif item[\"kind\"] == \"impl\":\n-        check_generics(item[\"inner\"][\"generics\"])\n-        if item[\"inner\"][\"trait\"]:\n-            check_path(item[\"inner\"][\"trait\"])\n-        if item[\"inner\"][\"blanket_impl\"]:\n-            check_type(item[\"inner\"][\"blanket_impl\"])\n-        check_type(item[\"inner\"][\"for\"])\n-        for assoc_item in item[\"inner\"][\"items\"]:\n-            if not valid_id(assoc_item):\n-                print(\"Impl block referenced a missing ID:\", assoc_item)\n-                sys.exit(1)\n-    elif item[\"kind\"] == \"assoc_type\":\n-        for bound in item[\"inner\"][\"bounds\"]:\n-            check_generic_bound(bound)\n-        if item[\"inner\"][\"default\"]:\n-            check_type(item[\"inner\"][\"default\"])\n-    elif item[\"kind\"] == \"import\":\n-        if item[\"inner\"][\"id\"]:\n-            inner_id = item[\"inner\"][\"id\"]\n-            assert valid_id(inner_id)\n-            if inner_id in crate[\"index\"] and inner_id not in visited:\n-                work_list.add(inner_id)"}, {"sha": "d287d5ebec5436b88e37e3bd3bbeed9cb7374c86", "filename": "src/test/rustdoc-json/type/extern.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftest%2Frustdoc-json%2Ftype%2Fextern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftest%2Frustdoc-json%2Ftype%2Fextern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Ftype%2Fextern.rs?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -0,0 +1,10 @@\n+#![feature(extern_types)]\n+\n+extern {\n+    /// No inner information\n+    pub type Foo;\n+}\n+\n+// @is \"$.index[*][?(@.docs=='No inner information')].name\" '\"Foo\"'\n+// @is \"$.index[*][?(@.docs=='No inner information')].kind\" '\"foreign_type\"'\n+// @!has \"$.index[*][?(@.docs=='No inner information')].inner\""}, {"sha": "64df76e27720d319e2153afd611874d75680d0aa", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -203,6 +203,9 @@ pub struct Config {\n     /// The jsondocck executable.\n     pub jsondocck_path: Option<String>,\n \n+    /// The jsondoclint executable.\n+    pub jsondoclint_path: Option<String>,\n+\n     /// The LLVM `FileCheck` binary path.\n     pub llvm_filecheck: Option<PathBuf>,\n "}, {"sha": "38c7b87fc0d9d85ddd5405b9c57eb3120e5b1bbd", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -64,6 +64,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         .optopt(\"\", \"rust-demangler-path\", \"path to rust-demangler to use in tests\", \"PATH\")\n         .reqopt(\"\", \"python\", \"path to python to use for doc tests\", \"PATH\")\n         .optopt(\"\", \"jsondocck-path\", \"path to jsondocck to use for doc tests\", \"PATH\")\n+        .optopt(\"\", \"jsondoclint-path\", \"path to jsondoclint to use for doc tests\", \"PATH\")\n         .optopt(\"\", \"valgrind-path\", \"path to Valgrind executable for Valgrind tests\", \"PROGRAM\")\n         .optflag(\"\", \"force-valgrind\", \"fail if Valgrind tests cannot be run under Valgrind\")\n         .optopt(\"\", \"run-clang-based-tests-with\", \"path to Clang executable\", \"PATH\")\n@@ -226,6 +227,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         rust_demangler_path: matches.opt_str(\"rust-demangler-path\").map(PathBuf::from),\n         python: matches.opt_str(\"python\").unwrap(),\n         jsondocck_path: matches.opt_str(\"jsondocck-path\"),\n+        jsondoclint_path: matches.opt_str(\"jsondoclint-path\"),\n         valgrind_path: matches.opt_str(\"valgrind-path\"),\n         force_valgrind: matches.opt_present(\"force-valgrind\"),\n         run_clang_based_tests_with: matches.opt_str(\"run-clang-based-tests-with\"),"}, {"sha": "8f289876f7307b391525979598dbbef6a8b8e37a", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -2563,14 +2563,13 @@ impl<'test> TestCx<'test> {\n \n         let mut json_out = out_dir.join(self.testpaths.file.file_stem().unwrap());\n         json_out.set_extension(\"json\");\n+\n         let res = self.cmd2procres(\n-            Command::new(&self.config.python)\n-                .arg(root.join(\"src/etc/check_missing_items.py\"))\n-                .arg(&json_out),\n+            Command::new(self.config.jsondoclint_path.as_ref().unwrap()).arg(&json_out),\n         );\n \n         if !res.status.success() {\n-            self.fatal_proc_rec(\"check_missing_items failed!\", &res);\n+            self.fatal_proc_rec(\"jsondoclint failed!\", &res);\n         }\n     }\n "}, {"sha": "84a6c7f96c4644631e66c51070b9c4720af472f8", "filename": "src/tools/jsondoclint/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fjsondoclint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fjsondoclint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2FCargo.toml?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+name = \"jsondoclint\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+anyhow = \"1.0.62\"\n+fs-err = \"2.8.1\"\n+rustdoc-json-types = { version = \"0.1.0\", path = \"../../rustdoc-json-types\" }\n+serde_json = \"1.0.85\""}, {"sha": "ad8e96a0bd81d850d4d36ae73dc987204a23e8fb", "filename": "src/tools/jsondoclint/src/item_kind.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -0,0 +1,184 @@\n+use rustdoc_json_types::{Item, ItemEnum, ItemKind, ItemSummary};\n+\n+/// A univeral way to represent an [`ItemEnum`] or [`ItemKind`]\n+#[derive(Debug)]\n+pub(crate) enum Kind {\n+    Module,\n+    ExternCrate,\n+    Import,\n+    Struct,\n+    StructField,\n+    Union,\n+    Enum,\n+    Variant,\n+    Function,\n+    Typedef,\n+    OpaqueTy,\n+    Constant,\n+    Trait,\n+    TraitAlias,\n+    Method,\n+    Impl,\n+    Static,\n+    ForeignType,\n+    Macro,\n+    ProcAttribute,\n+    ProcDerive,\n+    AssocConst,\n+    AssocType,\n+    Primitive,\n+    Keyword,\n+    // Not in ItemKind\n+    ProcMacro,\n+}\n+\n+impl Kind {\n+    pub fn can_appear_in_mod(self) -> bool {\n+        use Kind::*;\n+        match self {\n+            Module => true,\n+            ExternCrate => true,\n+            Import => true,\n+            Union => true,\n+            Struct => true,\n+            Enum => true,\n+            Function => true,\n+            Trait => true,\n+            TraitAlias => true,\n+            Impl => true,\n+            Typedef => true,\n+            Constant => true,\n+            Static => true,\n+            Macro => true,\n+            ProcMacro => true,\n+            Primitive => true,\n+            ForeignType => true,\n+\n+            // FIXME(adotinthevoid): I'm not sure if these are corrent\n+            Keyword => false,\n+            OpaqueTy => false,\n+            ProcAttribute => false,\n+            ProcDerive => false,\n+\n+            // Only in traits\n+            AssocConst => false,\n+            AssocType => false,\n+            Method => false,\n+\n+            StructField => false, // Only in structs or variants\n+            Variant => false,     // Only in enums\n+        }\n+    }\n+\n+    pub fn can_appear_in_trait(self) -> bool {\n+        match self {\n+            Kind::AssocConst => true,\n+            Kind::AssocType => true,\n+            Kind::Method => true,\n+\n+            Kind::Module => false,\n+            Kind::ExternCrate => false,\n+            Kind::Import => false,\n+            Kind::Struct => false,\n+            Kind::StructField => false,\n+            Kind::Union => false,\n+            Kind::Enum => false,\n+            Kind::Variant => false,\n+            Kind::Function => false,\n+            Kind::Typedef => false,\n+            Kind::OpaqueTy => false,\n+            Kind::Constant => false,\n+            Kind::Trait => false,\n+            Kind::TraitAlias => false,\n+            Kind::Impl => false,\n+            Kind::Static => false,\n+            Kind::ForeignType => false,\n+            Kind::Macro => false,\n+            Kind::ProcAttribute => false,\n+            Kind::ProcDerive => false,\n+            Kind::Primitive => false,\n+            Kind::Keyword => false,\n+            Kind::ProcMacro => false,\n+        }\n+    }\n+\n+    pub fn is_struct_field(self) -> bool {\n+        matches!(self, Kind::StructField)\n+    }\n+    pub fn is_module(self) -> bool {\n+        matches!(self, Kind::Module)\n+    }\n+    pub fn is_impl(self) -> bool {\n+        matches!(self, Kind::Impl)\n+    }\n+    pub fn is_variant(self) -> bool {\n+        matches!(self, Kind::Variant)\n+    }\n+    pub fn is_trait(self) -> bool {\n+        matches!(self, Kind::Trait)\n+    }\n+    pub fn is_struct_enum_union(self) -> bool {\n+        matches!(self, Kind::Struct | Kind::Enum | Kind::Union)\n+    }\n+\n+    pub fn from_item(i: &Item) -> Self {\n+        use Kind::*;\n+        match i.inner {\n+            ItemEnum::Module(_) => Module,\n+            ItemEnum::Import(_) => Import,\n+            ItemEnum::Union(_) => Union,\n+            ItemEnum::Struct(_) => Struct,\n+            ItemEnum::StructField(_) => StructField,\n+            ItemEnum::Enum(_) => Enum,\n+            ItemEnum::Variant(_) => Variant,\n+            ItemEnum::Function(_) => Function,\n+            ItemEnum::Trait(_) => Trait,\n+            ItemEnum::TraitAlias(_) => TraitAlias,\n+            ItemEnum::Method(_) => Method,\n+            ItemEnum::Impl(_) => Impl,\n+            ItemEnum::Typedef(_) => Typedef,\n+            ItemEnum::OpaqueTy(_) => OpaqueTy,\n+            ItemEnum::Constant(_) => Constant,\n+            ItemEnum::Static(_) => Static,\n+            ItemEnum::Macro(_) => Macro,\n+            ItemEnum::ProcMacro(_) => ProcMacro,\n+            // https://github.com/rust-lang/rust/issues/100961\n+            ItemEnum::PrimitiveType(_) => Primitive,\n+            ItemEnum::ForeignType => ForeignType,\n+            ItemEnum::ExternCrate { .. } => ExternCrate,\n+            ItemEnum::AssocConst { .. } => AssocConst,\n+            ItemEnum::AssocType { .. } => AssocType,\n+        }\n+    }\n+\n+    pub fn from_summary(s: &ItemSummary) -> Self {\n+        use Kind::*;\n+        match s.kind {\n+            ItemKind::AssocConst => AssocConst,\n+            ItemKind::AssocType => AssocType,\n+            ItemKind::Constant => Constant,\n+            ItemKind::Enum => Enum,\n+            ItemKind::ExternCrate => ExternCrate,\n+            ItemKind::ForeignType => ForeignType,\n+            ItemKind::Function => Function,\n+            ItemKind::Impl => Impl,\n+            ItemKind::Import => Import,\n+            ItemKind::Keyword => Keyword,\n+            ItemKind::Macro => Macro,\n+            ItemKind::Method => Method,\n+            ItemKind::Module => Module,\n+            ItemKind::OpaqueTy => OpaqueTy,\n+            ItemKind::Primitive => Primitive,\n+            ItemKind::ProcAttribute => ProcAttribute,\n+            ItemKind::ProcDerive => ProcDerive,\n+            ItemKind::Static => Static,\n+            ItemKind::Struct => Struct,\n+            ItemKind::StructField => StructField,\n+            ItemKind::Trait => Trait,\n+            ItemKind::TraitAlias => TraitAlias,\n+            ItemKind::Typedef => Typedef,\n+            ItemKind::Union => Union,\n+            ItemKind::Variant => Variant,\n+        }\n+    }\n+}"}, {"sha": "95ea8866609d09689e969d33fb47dc3b1245bffb", "filename": "src/tools/jsondoclint/src/json_find.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fjsondoclint%2Fsrc%2Fjson_find.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fjsondoclint%2Fsrc%2Fjson_find.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fjson_find.rs?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -0,0 +1,74 @@\n+use std::fmt::Write;\n+\n+use serde_json::Value;\n+\n+#[derive(Debug, Clone)]\n+pub enum SelectorPart {\n+    Field(String),\n+    Index(usize),\n+}\n+\n+pub type Selector = Vec<SelectorPart>;\n+\n+pub fn to_jsonpath(sel: &Selector) -> String {\n+    let mut s = String::from(\"$\");\n+    for part in sel {\n+        match part {\n+            SelectorPart::Field(name) => {\n+                if is_jsonpath_safe(name) {\n+                    write!(&mut s, \".{}\", name).unwrap();\n+                } else {\n+                    // This is probably wrong in edge cases, but all Id's are\n+                    // just ascii alphanumerics, `-` `_`, and `:`\n+                    write!(&mut s, \"[{name:?}]\").unwrap();\n+                }\n+            }\n+            SelectorPart::Index(idx) => write!(&mut s, \"[{idx}]\").unwrap(),\n+        }\n+    }\n+    s\n+}\n+\n+fn is_jsonpath_safe(s: &str) -> bool {\n+    s.chars().all(|c| c.is_ascii_alphanumeric() || c == '_')\n+}\n+\n+pub fn find_selector(haystack: &Value, needle: &Value) -> Vec<Selector> {\n+    let mut result = Vec::new();\n+    let mut sel = Selector::new();\n+    find_selector_recursive(haystack, needle, &mut result, &mut sel);\n+    result\n+}\n+\n+fn find_selector_recursive(\n+    haystack: &Value,\n+    needle: &Value,\n+    result: &mut Vec<Selector>,\n+    pos: &mut Selector,\n+) {\n+    if needle == haystack {\n+        result.push(pos.clone());\n+        // Haystack cant both contain needle and be needle\n+    } else {\n+        match haystack {\n+            Value::Null => {}\n+            Value::Bool(_) => {}\n+            Value::Number(_) => {}\n+            Value::String(_) => {}\n+            Value::Array(arr) => {\n+                for (idx, subhaystack) in arr.iter().enumerate() {\n+                    pos.push(SelectorPart::Index(idx));\n+                    find_selector_recursive(subhaystack, needle, result, pos);\n+                    pos.pop().unwrap();\n+                }\n+            }\n+            Value::Object(obj) => {\n+                for (key, subhaystack) in obj {\n+                    pos.push(SelectorPart::Field(key.clone()));\n+                    find_selector_recursive(subhaystack, needle, result, pos);\n+                    pos.pop().unwrap();\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "70d7a82a576059e21a0ddac5ba311634b997c21a", "filename": "src/tools/jsondoclint/src/main.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fjsondoclint%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fjsondoclint%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fmain.rs?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -0,0 +1,64 @@\n+use std::env;\n+\n+use anyhow::{anyhow, bail, Result};\n+use fs_err as fs;\n+use rustdoc_json_types::{Crate, Id, FORMAT_VERSION};\n+use serde_json::Value;\n+\n+pub(crate) mod item_kind;\n+mod json_find;\n+mod validator;\n+\n+#[derive(Debug)]\n+struct Error {\n+    kind: ErrorKind,\n+    id: Id,\n+}\n+\n+#[derive(Debug)]\n+enum ErrorKind {\n+    NotFound,\n+    Custom(String),\n+}\n+\n+fn main() -> Result<()> {\n+    let path = env::args().nth(1).ok_or_else(|| anyhow!(\"no path given\"))?;\n+    let contents = fs::read_to_string(&path)?;\n+    let krate: Crate = serde_json::from_str(&contents)?;\n+    assert_eq!(krate.format_version, FORMAT_VERSION);\n+\n+    let mut validator = validator::Validator::new(&krate);\n+    validator.check_crate();\n+\n+    if !validator.errs.is_empty() {\n+        for err in validator.errs {\n+            match err.kind {\n+                ErrorKind::NotFound => {\n+                    let krate_json: Value = serde_json::from_str(&contents)?;\n+\n+                    let sels =\n+                        json_find::find_selector(&krate_json, &Value::String(err.id.0.clone()));\n+                    match &sels[..] {\n+                        [] => unreachable!(\n+                            \"id must be in crate, or it wouldn't be reported as not found\"\n+                        ),\n+                        [sel] => eprintln!(\n+                            \"{} not in index or paths, but refered to at '{}'\",\n+                            err.id.0,\n+                            json_find::to_jsonpath(&sel)\n+                        ),\n+                        [sel, ..] => eprintln!(\n+                            \"{} not in index or paths, but refered to at '{}' and more\",\n+                            err.id.0,\n+                            json_find::to_jsonpath(&sel)\n+                        ),\n+                    }\n+                }\n+                ErrorKind::Custom(msg) => eprintln!(\"{}: {}\", err.id.0, msg),\n+            }\n+        }\n+        bail!(\"Errors validating json {path}\");\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "a0e77127dc2ca15091be88c3b99cb06c23971ff7", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "added", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -0,0 +1,442 @@\n+use std::collections::HashSet;\n+use std::hash::Hash;\n+\n+use rustdoc_json_types::{\n+    Constant, Crate, DynTrait, Enum, FnDecl, Function, FunctionPointer, GenericArg, GenericArgs,\n+    GenericBound, GenericParamDef, Generics, Id, Impl, Import, ItemEnum, Method, Module, OpaqueTy,\n+    Path, ProcMacro, Static, Struct, StructKind, Term, Trait, TraitAlias, Type, TypeBinding,\n+    TypeBindingKind, Typedef, Union, Variant, WherePredicate,\n+};\n+\n+use crate::{item_kind::Kind, Error, ErrorKind};\n+\n+/// The Validator walks over the JSON tree, and ensures it is well formed.\n+/// It is made of several parts.\n+///\n+/// - `check_*`: These take a type from [`rustdoc_json_types`], and check that\n+///              it is well formed. This involves calling `check_*` functions on\n+///              fields of that item, and `add_*` functions on [`Id`]s.\n+/// - `add_*`: These add an [`Id`] to the worklist, after validating it to check if\n+///            the `Id` is a kind expected in this suituation.\n+#[derive(Debug)]\n+pub struct Validator<'a> {\n+    pub(crate) errs: Vec<Error>,\n+    krate: &'a Crate,\n+    /// Worklist of Ids to check.\n+    todo: HashSet<&'a Id>,\n+    /// Ids that have already been visited, so don't need to be checked again.\n+    seen_ids: HashSet<&'a Id>,\n+    /// Ids that have already been reported missing.\n+    missing_ids: HashSet<&'a Id>,\n+}\n+\n+enum PathKind {\n+    Trait,\n+    StructEnumUnion,\n+}\n+\n+impl<'a> Validator<'a> {\n+    pub fn new(krate: &'a Crate) -> Self {\n+        Self {\n+            krate,\n+            errs: Vec::new(),\n+            seen_ids: HashSet::new(),\n+            todo: HashSet::new(),\n+            missing_ids: HashSet::new(),\n+        }\n+    }\n+\n+    pub fn check_crate(&mut self) {\n+        let root = &self.krate.root;\n+        self.add_mod_id(root);\n+        while let Some(id) = set_remove(&mut self.todo) {\n+            self.seen_ids.insert(id);\n+            self.check_item(id);\n+        }\n+    }\n+\n+    fn check_item(&mut self, id: &'a Id) {\n+        if let Some(item) = &self.krate.index.get(id) {\n+            match &item.inner {\n+                ItemEnum::Import(x) => self.check_import(x),\n+                ItemEnum::Union(x) => self.check_union(x),\n+                ItemEnum::Struct(x) => self.check_struct(x),\n+                ItemEnum::StructField(x) => self.check_struct_field(x),\n+                ItemEnum::Enum(x) => self.check_enum(x),\n+                ItemEnum::Variant(x) => self.check_variant(x, id),\n+                ItemEnum::Function(x) => self.check_function(x),\n+                ItemEnum::Trait(x) => self.check_trait(x),\n+                ItemEnum::TraitAlias(x) => self.check_trait_alias(x),\n+                ItemEnum::Method(x) => self.check_method(x),\n+                ItemEnum::Impl(x) => self.check_impl(x),\n+                ItemEnum::Typedef(x) => self.check_typedef(x),\n+                ItemEnum::OpaqueTy(x) => self.check_opaque_ty(x),\n+                ItemEnum::Constant(x) => self.check_constant(x),\n+                ItemEnum::Static(x) => self.check_static(x),\n+                ItemEnum::ForeignType => {} // nop\n+                ItemEnum::Macro(x) => self.check_macro(x),\n+                ItemEnum::ProcMacro(x) => self.check_proc_macro(x),\n+                ItemEnum::PrimitiveType(x) => self.check_primitive_type(x),\n+                ItemEnum::Module(x) => self.check_module(x),\n+                // FIXME: Why don't these have their own structs?\n+                ItemEnum::ExternCrate { .. } => {}\n+                ItemEnum::AssocConst { type_, default: _ } => self.check_type(type_),\n+                ItemEnum::AssocType { generics, bounds, default } => {\n+                    self.check_generics(generics);\n+                    bounds.iter().for_each(|b| self.check_generic_bound(b));\n+                    if let Some(ty) = default {\n+                        self.check_type(ty);\n+                    }\n+                }\n+            }\n+        } else {\n+            assert!(self.krate.paths.contains_key(id));\n+        }\n+    }\n+\n+    // Core checkers\n+    fn check_module(&mut self, module: &'a Module) {\n+        module.items.iter().for_each(|i| self.add_mod_item_id(i));\n+    }\n+\n+    fn check_import(&mut self, x: &'a Import) {\n+        if x.glob {\n+            self.add_mod_id(x.id.as_ref().unwrap());\n+        } else if let Some(id) = &x.id {\n+            self.add_mod_item_id(id);\n+        }\n+    }\n+\n+    fn check_union(&mut self, x: &'a Union) {\n+        self.check_generics(&x.generics);\n+        x.fields.iter().for_each(|i| self.add_field_id(i));\n+        x.impls.iter().for_each(|i| self.add_impl_id(i));\n+    }\n+\n+    fn check_struct(&mut self, x: &'a Struct) {\n+        self.check_generics(&x.generics);\n+        match &x.kind {\n+            StructKind::Unit => {}\n+            StructKind::Tuple(fields) => fields.iter().flatten().for_each(|f| self.add_field_id(f)),\n+            StructKind::Plain { fields, fields_stripped: _ } => {\n+                fields.iter().for_each(|f| self.add_field_id(f))\n+            }\n+        }\n+        x.impls.iter().for_each(|i| self.add_impl_id(i));\n+    }\n+\n+    fn check_struct_field(&mut self, x: &'a Type) {\n+        self.check_type(x);\n+    }\n+\n+    fn check_enum(&mut self, x: &'a Enum) {\n+        self.check_generics(&x.generics);\n+        x.variants.iter().for_each(|i| self.add_variant_id(i));\n+        x.impls.iter().for_each(|i| self.add_impl_id(i));\n+    }\n+\n+    fn check_variant(&mut self, x: &'a Variant, id: &'a Id) {\n+        match x {\n+            Variant::Plain(discr) => {\n+                if let Some(discr) = discr {\n+                    if let (Err(_), Err(_)) =\n+                        (discr.value.parse::<i128>(), discr.value.parse::<u128>())\n+                    {\n+                        self.fail(\n+                            id,\n+                            ErrorKind::Custom(format!(\n+                                \"Failed to parse discriminant value `{}`\",\n+                                discr.value\n+                            )),\n+                        );\n+                    }\n+                }\n+            }\n+            Variant::Tuple(tys) => tys.iter().flatten().for_each(|t| self.add_field_id(t)),\n+            Variant::Struct { fields, fields_stripped: _ } => {\n+                fields.iter().for_each(|f| self.add_field_id(f))\n+            }\n+        }\n+    }\n+\n+    fn check_function(&mut self, x: &'a Function) {\n+        self.check_generics(&x.generics);\n+        self.check_fn_decl(&x.decl);\n+    }\n+\n+    fn check_trait(&mut self, x: &'a Trait) {\n+        self.check_generics(&x.generics);\n+        x.items.iter().for_each(|i| self.add_trait_item_id(i));\n+        x.bounds.iter().for_each(|i| self.check_generic_bound(i));\n+        x.implementations.iter().for_each(|i| self.add_impl_id(i));\n+    }\n+\n+    fn check_trait_alias(&mut self, x: &'a TraitAlias) {\n+        self.check_generics(&x.generics);\n+        x.params.iter().for_each(|i| self.check_generic_bound(i));\n+    }\n+\n+    fn check_method(&mut self, x: &'a Method) {\n+        self.check_fn_decl(&x.decl);\n+        self.check_generics(&x.generics);\n+    }\n+\n+    fn check_impl(&mut self, x: &'a Impl) {\n+        self.check_generics(&x.generics);\n+        if let Some(path) = &x.trait_ {\n+            self.check_path(path, PathKind::Trait);\n+        }\n+        self.check_type(&x.for_);\n+        x.items.iter().for_each(|i| self.add_trait_item_id(i));\n+        if let Some(blanket_impl) = &x.blanket_impl {\n+            self.check_type(blanket_impl)\n+        }\n+    }\n+\n+    fn check_typedef(&mut self, x: &'a Typedef) {\n+        self.check_generics(&x.generics);\n+        self.check_type(&x.type_);\n+    }\n+\n+    fn check_opaque_ty(&mut self, x: &'a OpaqueTy) {\n+        x.bounds.iter().for_each(|b| self.check_generic_bound(b));\n+        self.check_generics(&x.generics);\n+    }\n+\n+    fn check_constant(&mut self, x: &'a Constant) {\n+        self.check_type(&x.type_);\n+    }\n+\n+    fn check_static(&mut self, x: &'a Static) {\n+        self.check_type(&x.type_);\n+    }\n+\n+    fn check_macro(&mut self, _: &'a str) {\n+        // nop\n+    }\n+\n+    fn check_proc_macro(&mut self, _: &'a ProcMacro) {\n+        // nop\n+    }\n+\n+    fn check_primitive_type(&mut self, _: &'a str) {\n+        // nop\n+    }\n+\n+    fn check_generics(&mut self, x: &'a Generics) {\n+        x.params.iter().for_each(|p| self.check_generic_param_def(p));\n+        x.where_predicates.iter().for_each(|w| self.check_where_predicate(w));\n+    }\n+\n+    fn check_type(&mut self, x: &'a Type) {\n+        match x {\n+            Type::ResolvedPath(path) => self.check_path(path, PathKind::StructEnumUnion),\n+            Type::DynTrait(dyn_trait) => self.check_dyn_trait(dyn_trait),\n+            Type::Generic(_) => {}\n+            Type::Primitive(_) => {}\n+            Type::FunctionPointer(fp) => self.check_function_pointer(&**fp),\n+            Type::Tuple(tys) => tys.iter().for_each(|ty| self.check_type(ty)),\n+            Type::Slice(inner) => self.check_type(&**inner),\n+            Type::Array { type_, len: _ } => self.check_type(&**type_),\n+            Type::ImplTrait(bounds) => bounds.iter().for_each(|b| self.check_generic_bound(b)),\n+            Type::Infer => {}\n+            Type::RawPointer { mutable: _, type_ } => self.check_type(&**type_),\n+            Type::BorrowedRef { lifetime: _, mutable: _, type_ } => self.check_type(&**type_),\n+            Type::QualifiedPath { name: _, args, self_type, trait_ } => {\n+                self.check_generic_args(&**args);\n+                self.check_type(&**self_type);\n+                self.check_path(trait_, PathKind::Trait);\n+            }\n+        }\n+    }\n+\n+    fn check_fn_decl(&mut self, x: &'a FnDecl) {\n+        x.inputs.iter().for_each(|(_name, ty)| self.check_type(ty));\n+        if let Some(output) = &x.output {\n+            self.check_type(output);\n+        }\n+    }\n+\n+    fn check_generic_bound(&mut self, x: &'a GenericBound) {\n+        match x {\n+            GenericBound::TraitBound { trait_, generic_params, modifier: _ } => {\n+                self.check_path(trait_, PathKind::Trait);\n+                generic_params.iter().for_each(|gpd| self.check_generic_param_def(gpd));\n+            }\n+            GenericBound::Outlives(_) => {}\n+        }\n+    }\n+\n+    fn check_path(&mut self, x: &'a Path, kind: PathKind) {\n+        match kind {\n+            PathKind::Trait => self.add_trait_id(&x.id),\n+            PathKind::StructEnumUnion => self.add_struct_enum_union_id(&x.id),\n+        }\n+        if let Some(args) = &x.args {\n+            self.check_generic_args(&**args);\n+        }\n+    }\n+\n+    fn check_generic_args(&mut self, x: &'a GenericArgs) {\n+        match x {\n+            GenericArgs::AngleBracketed { args, bindings } => {\n+                args.iter().for_each(|arg| self.check_generic_arg(arg));\n+                bindings.iter().for_each(|bind| self.check_type_binding(bind));\n+            }\n+            GenericArgs::Parenthesized { inputs, output } => {\n+                inputs.iter().for_each(|ty| self.check_type(ty));\n+                if let Some(o) = output {\n+                    self.check_type(o);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_generic_param_def(&mut self, gpd: &'a GenericParamDef) {\n+        match &gpd.kind {\n+            rustdoc_json_types::GenericParamDefKind::Lifetime { outlives: _ } => {}\n+            rustdoc_json_types::GenericParamDefKind::Type { bounds, default, synthetic: _ } => {\n+                bounds.iter().for_each(|b| self.check_generic_bound(b));\n+                if let Some(ty) = default {\n+                    self.check_type(ty);\n+                }\n+            }\n+            rustdoc_json_types::GenericParamDefKind::Const { type_, default: _ } => {\n+                self.check_type(type_)\n+            }\n+        }\n+    }\n+\n+    fn check_generic_arg(&mut self, arg: &'a GenericArg) {\n+        match arg {\n+            GenericArg::Lifetime(_) => {}\n+            GenericArg::Type(ty) => self.check_type(ty),\n+            GenericArg::Const(c) => self.check_constant(c),\n+            GenericArg::Infer => {}\n+        }\n+    }\n+\n+    fn check_type_binding(&mut self, bind: &'a TypeBinding) {\n+        self.check_generic_args(&bind.args);\n+        match &bind.binding {\n+            TypeBindingKind::Equality(term) => self.check_term(term),\n+            TypeBindingKind::Constraint(bounds) => {\n+                bounds.iter().for_each(|b| self.check_generic_bound(b))\n+            }\n+        }\n+    }\n+\n+    fn check_term(&mut self, term: &'a Term) {\n+        match term {\n+            Term::Type(ty) => self.check_type(ty),\n+            Term::Constant(con) => self.check_constant(con),\n+        }\n+    }\n+\n+    fn check_where_predicate(&mut self, w: &'a WherePredicate) {\n+        match w {\n+            WherePredicate::BoundPredicate { type_, bounds, generic_params } => {\n+                self.check_type(type_);\n+                bounds.iter().for_each(|b| self.check_generic_bound(b));\n+                generic_params.iter().for_each(|gpd| self.check_generic_param_def(gpd));\n+            }\n+            WherePredicate::RegionPredicate { lifetime: _, bounds } => {\n+                bounds.iter().for_each(|b| self.check_generic_bound(b));\n+            }\n+            WherePredicate::EqPredicate { lhs, rhs } => {\n+                self.check_type(lhs);\n+                self.check_term(rhs);\n+            }\n+        }\n+    }\n+\n+    fn check_dyn_trait(&mut self, dyn_trait: &'a DynTrait) {\n+        for pt in &dyn_trait.traits {\n+            self.check_path(&pt.trait_, PathKind::Trait);\n+            pt.generic_params.iter().for_each(|gpd| self.check_generic_param_def(gpd));\n+        }\n+    }\n+\n+    fn check_function_pointer(&mut self, fp: &'a FunctionPointer) {\n+        self.check_fn_decl(&fp.decl);\n+        fp.generic_params.iter().for_each(|gpd| self.check_generic_param_def(gpd));\n+    }\n+\n+    fn add_id_checked(&mut self, id: &'a Id, valid: fn(Kind) -> bool, expected: &str) {\n+        if let Some(kind) = self.kind_of(id) {\n+            if valid(kind) {\n+                if !self.seen_ids.contains(id) {\n+                    self.todo.insert(id);\n+                }\n+            } else {\n+                self.fail_expecting(id, expected);\n+            }\n+        } else {\n+            if !self.missing_ids.contains(id) {\n+                self.missing_ids.insert(id);\n+                self.fail(id, ErrorKind::NotFound)\n+            }\n+        }\n+    }\n+\n+    fn add_field_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_struct_field, \"StructField\");\n+    }\n+\n+    fn add_mod_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_module, \"Module\");\n+    }\n+    fn add_impl_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_impl, \"Impl\");\n+    }\n+\n+    fn add_variant_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_variant, \"Variant\");\n+    }\n+\n+    fn add_trait_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_trait, \"Trait\");\n+    }\n+\n+    fn add_struct_enum_union_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_struct_enum_union, \"Struct or Enum or Union\");\n+    }\n+\n+    /// Add an Id that appeared in a trait\n+    fn add_trait_item_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::can_appear_in_trait, \"Trait inner item\");\n+    }\n+\n+    /// Add an Id that appeared in a mod\n+    fn add_mod_item_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::can_appear_in_mod, \"Module inner item\")\n+    }\n+\n+    fn fail_expecting(&mut self, id: &Id, expected: &str) {\n+        let kind = self.kind_of(id).unwrap(); // We know it has a kind, as it's wrong.\n+        self.fail(id, ErrorKind::Custom(format!(\"Expected {expected} but found {kind:?}\")));\n+    }\n+\n+    fn fail(&mut self, id: &Id, kind: ErrorKind) {\n+        self.errs.push(Error { id: id.clone(), kind });\n+    }\n+\n+    fn kind_of(&mut self, id: &Id) -> Option<Kind> {\n+        if let Some(item) = self.krate.index.get(id) {\n+            Some(Kind::from_item(item))\n+        } else if let Some(summary) = self.krate.paths.get(id) {\n+            Some(Kind::from_summary(summary))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+fn set_remove<T: Hash + Eq + Clone>(set: &mut HashSet<T>) -> Option<T> {\n+    if let Some(id) = set.iter().next() {\n+        let id = id.clone();\n+        set.take(&id)\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "12a55fda7ef4d5ed4bf482812a80a27432cf8842", "filename": "triagebot.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/458555dbf6e4847e8b4f19d31f37f45baf7fd128/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/458555dbf6e4847e8b4f19d31f37f45baf7fd128/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=458555dbf6e4847e8b4f19d31f37f45baf7fd128", "patch": "@@ -130,8 +130,8 @@ trigger_files = [\n \n     # Internal tooling\n     \"src/etc/htmldocck.py\",\n-    \"src/etc/check_missing_items.py\",\n     \"src/tools/jsondocck\",\n+    \"src/tools/jsondoclint\",\n     \"src/tools/rustdoc-gui\",\n     \"src/tools/rustdoc-js\",\n     \"src/tools/rustdoc-themes\",\n@@ -142,11 +142,11 @@ exclude_labels = [\n \n [autolabel.\"A-rustdoc-json\"]\n trigger_files = [\n-    \"src/etc/check_missing_items.py\",\n     \"src/librustdoc/json/\",\n     \"src/rustdoc-json-types\",\n     \"src/test/rustdoc-json\",\n     \"src/tools/jsondocck\",\n+    \"src/tools/jsondoclint\",\n ]\n \n [autolabel.\"T-compiler\"]"}]}