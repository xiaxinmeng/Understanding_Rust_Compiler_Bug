{"sha": "ec99b220fe0b0741edd6c9d6e05e4d0d2733a467", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjOTliMjIwZmUwYjA3NDFlZGQ2YzlkNmUwNWU0ZDBkMjczM2E0Njc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-29T23:49:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-29T23:49:11Z"}, "message": "Auto merge of #50772 - nicokoch:fastcopy, r=alexcrichton\n\nfs: copy: use copy_file_range on Linux\n\nLinux 4.5 introduced a new system call [copy_file_range](http://man7.org/linux/man-pages/man2/copy_file_range.2.html) to copy data from one file to another.\n\nThis PR uses the new system call (if available). This has several advantages:\n\n1. No need to constantly copy data from userspace to kernel space, if the buffer is small or the file is large\n2. On some filesystems, like BTRFS, the kernel can leverage internal fs mechanisms for huge performance gains\n3. Filesystems on the network dont need to copy data between the host and the client machine (they have to in the current read/write implementation)\n\nI have created a small library that also implements the new system call for some huge performance gains here: https://github.com/nicokoch/fastcopy\nBenchmark results are in the README", "tree": {"sha": "94c87b32529ef575111261074cd3207f2e0f6cbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94c87b32529ef575111261074cd3207f2e0f6cbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec99b220fe0b0741edd6c9d6e05e4d0d2733a467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec99b220fe0b0741edd6c9d6e05e4d0d2733a467", "html_url": "https://github.com/rust-lang/rust/commit/ec99b220fe0b0741edd6c9d6e05e4d0d2733a467", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec99b220fe0b0741edd6c9d6e05e4d0d2733a467/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "524ad9b9e03656f3fdeb03ed82fe78db3916e566", "url": "https://api.github.com/repos/rust-lang/rust/commits/524ad9b9e03656f3fdeb03ed82fe78db3916e566", "html_url": "https://github.com/rust-lang/rust/commit/524ad9b9e03656f3fdeb03ed82fe78db3916e566"}, {"sha": "c7d6a0130b6b76b65982916198e7de2b348f9718", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7d6a0130b6b76b65982916198e7de2b348f9718", "html_url": "https://github.com/rust-lang/rust/commit/c7d6a0130b6b76b65982916198e7de2b348f9718"}], "stats": {"total": 88, "additions": 88, "deletions": 0}, "files": [{"sha": "889d21cad65aafb6b828b20b8d4b763f7d218cdb", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ec99b220fe0b0741edd6c9d6e05e4d0d2733a467/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec99b220fe0b0741edd6c9d6e05e4d0d2733a467/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=ec99b220fe0b0741edd6c9d6e05e4d0d2733a467", "patch": "@@ -794,6 +794,7 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n+#[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     use fs::{File, set_permissions};\n     if !from.is_file() {\n@@ -809,3 +810,90 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     set_permissions(to, perm)?;\n     Ok(ret)\n }\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n+    use cmp;\n+    use fs::{File, set_permissions};\n+    use sync::atomic::{AtomicBool, Ordering};\n+\n+    // Kernel prior to 4.5 don't have copy_file_range\n+    // We store the availability in a global to avoid unneccessary syscalls\n+    static HAS_COPY_FILE_RANGE: AtomicBool = AtomicBool::new(true);\n+\n+    unsafe fn copy_file_range(\n+        fd_in: libc::c_int,\n+        off_in: *mut libc::loff_t,\n+        fd_out: libc::c_int,\n+        off_out: *mut libc::loff_t,\n+        len: libc::size_t,\n+        flags: libc::c_uint,\n+    ) -> libc::c_long {\n+        libc::syscall(\n+            libc::SYS_copy_file_range,\n+            fd_in,\n+            off_in,\n+            fd_out,\n+            off_out,\n+            len,\n+            flags,\n+        )\n+    }\n+\n+    if !from.is_file() {\n+        return Err(Error::new(ErrorKind::InvalidInput,\n+                              \"the source path is not an existing regular file\"))\n+    }\n+\n+    let mut reader = File::open(from)?;\n+    let mut writer = File::create(to)?;\n+    let (perm, len) = {\n+        let metadata = reader.metadata()?;\n+        (metadata.permissions(), metadata.size())\n+    };\n+\n+    let has_copy_file_range = HAS_COPY_FILE_RANGE.load(Ordering::Relaxed);\n+    let mut written = 0u64;\n+    while written < len {\n+        let copy_result = if has_copy_file_range {\n+            let bytes_to_copy = cmp::min(len - written, usize::max_value() as u64) as usize;\n+            let copy_result = unsafe {\n+                // We actually don't have to adjust the offsets,\n+                // because copy_file_range adjusts the file offset automatically\n+                cvt(copy_file_range(reader.as_raw_fd(),\n+                                    ptr::null_mut(),\n+                                    writer.as_raw_fd(),\n+                                    ptr::null_mut(),\n+                                    bytes_to_copy,\n+                                    0)\n+                    )\n+            };\n+            if let Err(ref copy_err) = copy_result {\n+                if let Some(libc::ENOSYS) = copy_err.raw_os_error() {\n+                    HAS_COPY_FILE_RANGE.store(false, Ordering::Relaxed);\n+                }\n+            }\n+            copy_result\n+        } else {\n+            Err(io::Error::from_raw_os_error(libc::ENOSYS))\n+        };\n+        match copy_result {\n+            Ok(ret) => written += ret as u64,\n+            Err(err) => {\n+                match err.raw_os_error() {\n+                    Some(os_err) if os_err == libc::ENOSYS || os_err == libc::EXDEV => {\n+                        // Either kernel is too old or the files are not mounted on the same fs.\n+                        // Try again with fallback method\n+                        assert_eq!(written, 0);\n+                        let ret = io::copy(&mut reader, &mut writer)?;\n+                        set_permissions(to, perm)?;\n+                        return Ok(ret)\n+                    },\n+                    _ => return Err(err),\n+                }\n+            }\n+        }\n+    }\n+    set_permissions(to, perm)?;\n+    Ok(written)\n+}"}]}