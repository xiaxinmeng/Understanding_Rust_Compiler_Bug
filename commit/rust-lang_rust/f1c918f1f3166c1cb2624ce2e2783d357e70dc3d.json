{"sha": "f1c918f1f3166c1cb2624ce2e2783d357e70dc3d", "node_id": "C_kwDOAAsO6NoAKGYxYzkxOGYxZjMxNjZjMWNiMjYyNGNlMmUyNzgzZDM1N2U3MGRjM2Q", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-18T15:23:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-18T15:23:32Z"}, "message": "Rollup merge of #93613 - crlf0710:rename_to_async_iter, r=yaahc\n\nMove `{core,std}::stream::Stream` to `{core,std}::async_iter::AsyncIterator`\n\nFollowing amendments in https://github.com/rust-lang/rfcs/pull/3208/.\n\ncc #79024\ncc ``@yoshuawuyts`` ``@joshtriplett``", "tree": {"sha": "f3709578093816760ea98b736d4c9b75af870f2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3709578093816760ea98b736d4c9b75af870f2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiD7n0CRBK7hj4Ov3rIwAANOwIAG5k00zgSbIrSm7Nai0XGphe\ng7IIUGFAG1fCnznJCk2Jmi7AE+gJoDtiCuyV7jqyhyvWP5VmYd2migPyoXz28vcb\nzdQwjZaKu9XNwKBg6P+ySLjI06c4QU5vcYapt2PvI0lWGgjmqoCNxEST5Er3OUQU\nTcvs8CJYc+p34LcPhYGhd6/YQjUoic6FfwZ86mA7g8W5nMWUCqLl5P3+K4q4sXa7\nPOM5S8ODf+5Arn7JKV96Ro9fmK15tlPLM48Bj0NFvUC9ohSbCfTzy3GQgGhvhGLM\nppr01TDOpIbLprTlDC8XQHKEWYcL6WLXW4hRNBpECXiu8n4ULctgkrZDSP572Yc=\n=QSQS\n-----END PGP SIGNATURE-----\n", "payload": "tree f3709578093816760ea98b736d4c9b75af870f2a\nparent cf3cd4c48a44ba833253a1f32e09bd6d7b120e13\nparent 18130a21dc8744c9a1f734016e0b399d70e8f968\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645197812 +0100\ncommitter GitHub <noreply@github.com> 1645197812 +0100\n\nRollup merge of #93613 - crlf0710:rename_to_async_iter, r=yaahc\n\nMove `{core,std}::stream::Stream` to `{core,std}::async_iter::AsyncIterator`\n\nFollowing amendments in https://github.com/rust-lang/rfcs/pull/3208/.\n\ncc #79024\ncc ``@yoshuawuyts`` ``@joshtriplett``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d", "html_url": "https://github.com/rust-lang/rust/commit/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf3cd4c48a44ba833253a1f32e09bd6d7b120e13", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf3cd4c48a44ba833253a1f32e09bd6d7b120e13", "html_url": "https://github.com/rust-lang/rust/commit/cf3cd4c48a44ba833253a1f32e09bd6d7b120e13"}, {"sha": "18130a21dc8744c9a1f734016e0b399d70e8f968", "url": "https://api.github.com/repos/rust-lang/rust/commits/18130a21dc8744c9a1f734016e0b399d70e8f968", "html_url": "https://github.com/rust-lang/rust/commit/18130a21dc8744c9a1f734016e0b399d70e8f968"}], "stats": {"total": 167, "additions": 83, "deletions": 84}, "files": [{"sha": "68bf59a01b3dd637efb5ca605d365f49616d7a37", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=f1c918f1f3166c1cb2624ce2e2783d357e70dc3d", "patch": "@@ -133,6 +133,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::any::Any;\n+use core::async_iter::AsyncIterator;\n use core::borrow;\n use core::cmp::Ordering;\n use core::convert::{From, TryFrom};\n@@ -149,7 +150,6 @@ use core::ops::{\n };\n use core::pin::Pin;\n use core::ptr::{self, Unique};\n-use core::stream::Stream;\n use core::task::{Context, Poll};\n \n #[cfg(not(no_global_oom_handling))]\n@@ -1992,8 +1992,8 @@ where\n     }\n }\n \n-#[unstable(feature = \"async_stream\", issue = \"79024\")]\n-impl<S: ?Sized + Stream + Unpin> Stream for Box<S> {\n+#[unstable(feature = \"async_iterator\", issue = \"79024\")]\n+impl<S: ?Sized + AsyncIterator + Unpin> AsyncIterator for Box<S> {\n     type Item = S::Item;\n \n     fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {"}, {"sha": "6da32df57efb761c654afbb068a99b8842de9883", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=f1c918f1f3166c1cb2624ce2e2783d357e70dc3d", "patch": "@@ -91,7 +91,7 @@\n #![feature(array_chunks)]\n #![feature(array_methods)]\n #![feature(array_windows)]\n-#![feature(async_stream)]\n+#![feature(async_iterator)]\n #![feature(coerce_unsized)]\n #![cfg_attr(not(no_global_oom_handling), feature(const_alloc_error))]\n #![feature(const_box)]"}, {"sha": "f29de31171a67446ac456a23eb1408652c3bf054", "filename": "library/core/src/async_iter/async_iter.rs", "status": "renamed", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Fcore%2Fsrc%2Fasync_iter%2Fasync_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Fcore%2Fsrc%2Fasync_iter%2Fasync_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fasync_iter%2Fasync_iter.rs?ref=f1c918f1f3166c1cb2624ce2e2783d357e70dc3d", "patch": "@@ -4,50 +4,50 @@ use crate::task::{Context, Poll};\n \n /// An interface for dealing with asynchronous iterators.\n ///\n-/// This is the main stream trait. For more about the concept of streams\n+/// This is the main async iterator trait. For more about the concept of async iterators\n /// generally, please see the [module-level documentation]. In particular, you\n-/// may want to know how to [implement `Stream`][impl].\n+/// may want to know how to [implement `AsyncIterator`][impl].\n ///\n /// [module-level documentation]: index.html\n-/// [impl]: index.html#implementing-stream\n-#[unstable(feature = \"async_stream\", issue = \"79024\")]\n-#[must_use = \"streams do nothing unless polled\"]\n-pub trait Stream {\n-    /// The type of items yielded by the stream.\n+/// [impl]: index.html#implementing-async-iterator\n+#[unstable(feature = \"async_iterator\", issue = \"79024\")]\n+#[must_use = \"async iterators do nothing unless polled\"]\n+pub trait AsyncIterator {\n+    /// The type of items yielded by the async iterator.\n     type Item;\n \n-    /// Attempt to pull out the next value of this stream, registering the\n+    /// Attempt to pull out the next value of this async iterator, registering the\n     /// current task for wakeup if the value is not yet available, and returning\n-    /// `None` if the stream is exhausted.\n+    /// `None` if the async iterator is exhausted.\n     ///\n     /// # Return value\n     ///\n     /// There are several possible return values, each indicating a distinct\n-    /// stream state:\n+    /// async iterator state:\n     ///\n-    /// - `Poll::Pending` means that this stream's next value is not ready\n+    /// - `Poll::Pending` means that this async iterator's next value is not ready\n     /// yet. Implementations will ensure that the current task will be notified\n     /// when the next value may be ready.\n     ///\n-    /// - `Poll::Ready(Some(val))` means that the stream has successfully\n+    /// - `Poll::Ready(Some(val))` means that the async iterator has successfully\n     /// produced a value, `val`, and may produce further values on subsequent\n     /// `poll_next` calls.\n     ///\n-    /// - `Poll::Ready(None)` means that the stream has terminated, and\n+    /// - `Poll::Ready(None)` means that the async iterator has terminated, and\n     /// `poll_next` should not be invoked again.\n     ///\n     /// # Panics\n     ///\n-    /// Once a stream has finished (returned `Ready(None)` from `poll_next`), calling its\n+    /// Once an async iterator has finished (returned `Ready(None)` from `poll_next`), calling its\n     /// `poll_next` method again may panic, block forever, or cause other kinds of\n-    /// problems; the `Stream` trait places no requirements on the effects of\n+    /// problems; the `AsyncIterator` trait places no requirements on the effects of\n     /// such a call. However, as the `poll_next` method is not marked `unsafe`,\n     /// Rust's usual rules apply: calls must never cause undefined behavior\n     /// (memory corruption, incorrect use of `unsafe` functions, or the like),\n-    /// regardless of the stream's state.\n+    /// regardless of the async iterator's state.\n     fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;\n \n-    /// Returns the bounds on the remaining length of the stream.\n+    /// Returns the bounds on the remaining length of the async iterator.\n     ///\n     /// Specifically, `size_hint()` returns a tuple where the first element\n     /// is the lower bound, and the second element is the upper bound.\n@@ -58,12 +58,12 @@ pub trait Stream {\n     ///\n     /// # Implementation notes\n     ///\n-    /// It is not enforced that a stream implementation yields the declared\n-    /// number of elements. A buggy stream may yield less than the lower bound\n+    /// It is not enforced that an async iterator implementation yields the declared\n+    /// number of elements. A buggy async iterator may yield less than the lower bound\n     /// or more than the upper bound of elements.\n     ///\n     /// `size_hint()` is primarily intended to be used for optimizations such as\n-    /// reserving space for the elements of the stream, but must not be\n+    /// reserving space for the elements of the async iterator, but must not be\n     /// trusted to e.g., omit bounds checks in unsafe code. An incorrect\n     /// implementation of `size_hint()` should not lead to memory safety\n     /// violations.\n@@ -72,15 +72,15 @@ pub trait Stream {\n     /// because otherwise it would be a violation of the trait's protocol.\n     ///\n     /// The default implementation returns <code>(0, [None])</code> which is correct for any\n-    /// stream.\n+    /// async iterator.\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (0, None)\n     }\n }\n \n-#[unstable(feature = \"async_stream\", issue = \"79024\")]\n-impl<S: ?Sized + Stream + Unpin> Stream for &mut S {\n+#[unstable(feature = \"async_iterator\", issue = \"79024\")]\n+impl<S: ?Sized + AsyncIterator + Unpin> AsyncIterator for &mut S {\n     type Item = S::Item;\n \n     fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n@@ -92,16 +92,16 @@ impl<S: ?Sized + Stream + Unpin> Stream for &mut S {\n     }\n }\n \n-#[unstable(feature = \"async_stream\", issue = \"79024\")]\n-impl<P> Stream for Pin<P>\n+#[unstable(feature = \"async_iterator\", issue = \"79024\")]\n+impl<P> AsyncIterator for Pin<P>\n where\n     P: DerefMut,\n-    P::Target: Stream,\n+    P::Target: AsyncIterator,\n {\n-    type Item = <P::Target as Stream>::Item;\n+    type Item = <P::Target as AsyncIterator>::Item;\n \n     fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n-        <P::Target as Stream>::poll_next(self.as_deref_mut(), cx)\n+        <P::Target as AsyncIterator>::poll_next(self.as_deref_mut(), cx)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {", "previous_filename": "library/core/src/stream/stream.rs"}, {"sha": "3180187afc8c94be13f8a4597b6e3fcda197c211", "filename": "library/core/src/async_iter/from_iter.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Fcore%2Fsrc%2Fasync_iter%2Ffrom_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Fcore%2Fsrc%2Fasync_iter%2Ffrom_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fasync_iter%2Ffrom_iter.rs?ref=f1c918f1f3166c1cb2624ce2e2783d357e70dc3d", "patch": "@@ -1,31 +1,31 @@\n use crate::pin::Pin;\n \n-use crate::stream::Stream;\n+use crate::async_iter::AsyncIterator;\n use crate::task::{Context, Poll};\n \n-/// A stream that was created from iterator.\n+/// An async iterator that was created from iterator.\n ///\n-/// This stream is created by the [`from_iter`] function.\n+/// This async iterator is created by the [`from_iter`] function.\n /// See it documentation for more.\n ///\n /// [`from_iter`]: fn.from_iter.html\n-#[unstable(feature = \"stream_from_iter\", issue = \"81798\")]\n+#[unstable(feature = \"async_iter_from_iter\", issue = \"81798\")]\n #[derive(Clone, Debug)]\n pub struct FromIter<I> {\n     iter: I,\n }\n \n-#[unstable(feature = \"stream_from_iter\", issue = \"81798\")]\n+#[unstable(feature = \"async_iter_from_iter\", issue = \"81798\")]\n impl<I> Unpin for FromIter<I> {}\n \n-/// Converts an iterator into a stream.\n-#[unstable(feature = \"stream_from_iter\", issue = \"81798\")]\n+/// Converts an iterator into an async iterator.\n+#[unstable(feature = \"async_iter_from_iter\", issue = \"81798\")]\n pub fn from_iter<I: IntoIterator>(iter: I) -> FromIter<I::IntoIter> {\n     FromIter { iter: iter.into_iter() }\n }\n \n-#[unstable(feature = \"stream_from_iter\", issue = \"81798\")]\n-impl<I: Iterator> Stream for FromIter<I> {\n+#[unstable(feature = \"async_iter_from_iter\", issue = \"81798\")]\n+impl<I: Iterator> AsyncIterator for FromIter<I> {\n     type Item = I::Item;\n \n     fn poll_next(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {", "previous_filename": "library/core/src/stream/from_iter.rs"}, {"sha": "0c6f637711b372a393fb7f4d5db0b108d00fe87f", "filename": "library/core/src/async_iter/mod.rs", "status": "renamed", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Fcore%2Fsrc%2Fasync_iter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Fcore%2Fsrc%2Fasync_iter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fasync_iter%2Fmod.rs?ref=f1c918f1f3166c1cb2624ce2e2783d357e70dc3d", "patch": "@@ -1,82 +1,81 @@\n //! Composable asynchronous iteration.\n //!\n-//! If futures are asynchronous values, then streams are asynchronous\n-//! iterators. If you've found yourself with an asynchronous collection of some kind,\n+//! If you've found yourself with an asynchronous collection of some kind,\n //! and needed to perform an operation on the elements of said collection,\n-//! you'll quickly run into 'streams'. Streams are heavily used in idiomatic\n-//! asynchronous Rust code, so it's worth becoming familiar with them.\n+//! you'll quickly run into 'async iterators'. Async Iterators are heavily used in\n+//! idiomatic asynchronous Rust code, so it's worth becoming familiar with them.\n //!\n //! Before explaining more, let's talk about how this module is structured:\n //!\n //! # Organization\n //!\n //! This module is largely organized by type:\n //!\n-//! * [Traits] are the core portion: these traits define what kind of streams\n+//! * [Traits] are the core portion: these traits define what kind of async iterators\n //!   exist and what you can do with them. The methods of these traits are worth\n //!   putting some extra study time into.\n-//! * Functions provide some helpful ways to create some basic streams.\n+//! * Functions provide some helpful ways to create some basic async iterators.\n //! * Structs are often the return types of the various methods on this\n //!   module's traits. You'll usually want to look at the method that creates\n //!   the `struct`, rather than the `struct` itself. For more detail about why,\n-//!   see '[Implementing Stream](#implementing-stream)'.\n+//!   see '[Implementing Async Iterator](#implementing-async-iterator)'.\n //!\n //! [Traits]: #traits\n //!\n-//! That's it! Let's dig into streams.\n+//! That's it! Let's dig into async iterators.\n //!\n-//! # Stream\n+//! # Async Iterators\n //!\n-//! The heart and soul of this module is the [`Stream`] trait. The core of\n-//! [`Stream`] looks like this:\n+//! The heart and soul of this module is the [`AsyncIterator`] trait. The core of\n+//! [`AsyncIterator`] looks like this:\n //!\n //! ```\n //! # use core::task::{Context, Poll};\n //! # use core::pin::Pin;\n-//! trait Stream {\n+//! trait AsyncIterator {\n //!     type Item;\n //!     fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;\n //! }\n //! ```\n //!\n-//! Unlike `Iterator`, `Stream` makes a distinction between the [`poll_next`]\n-//! method which is used when implementing a `Stream`, and a (to-be-implemented)\n-//! `next` method which is used when consuming a stream. Consumers of `Stream`\n+//! Unlike `Iterator`, `AsyncIterator` makes a distinction between the [`poll_next`]\n+//! method which is used when implementing an `AsyncIterator`, and a (to-be-implemented)\n+//! `next` method which is used when consuming an async iterator. Consumers of `AsyncIterator`\n //! only need to consider `next`, which when called, returns a future which\n-//! yields `Option<Stream::Item>`.\n+//! yields `Option<AsyncIterator::Item>`.\n //!\n //! The future returned by `next` will yield `Some(Item)` as long as there are\n //! elements, and once they've all been exhausted, will yield `None` to indicate\n //! that iteration is finished. If we're waiting on something asynchronous to\n-//! resolve, the future will wait until the stream is ready to yield again.\n+//! resolve, the future will wait until the async iterator is ready to yield again.\n //!\n-//! Individual streams may choose to resume iteration, and so calling `next`\n+//! Individual async iterators may choose to resume iteration, and so calling `next`\n //! again may or may not eventually yield `Some(Item)` again at some point.\n //!\n-//! [`Stream`]'s full definition includes a number of other methods as well,\n+//! [`AsyncIterator`]'s full definition includes a number of other methods as well,\n //! but they are default methods, built on top of [`poll_next`], and so you get\n //! them for free.\n //!\n //! [`Poll`]: super::task::Poll\n-//! [`poll_next`]: Stream::poll_next\n+//! [`poll_next`]: AsyncIterator::poll_next\n //!\n-//! # Implementing Stream\n+//! # Implementing Async Iterator\n //!\n-//! Creating a stream of your own involves two steps: creating a `struct` to\n-//! hold the stream's state, and then implementing [`Stream`] for that\n+//! Creating an async iterator of your own involves two steps: creating a `struct` to\n+//! hold the async iterator's state, and then implementing [`AsyncIterator`] for that\n //! `struct`.\n //!\n-//! Let's make a stream named `Counter` which counts from `1` to `5`:\n+//! Let's make an async iterator named `Counter` which counts from `1` to `5`:\n //!\n //! ```no_run\n-//! #![feature(async_stream)]\n-//! # use core::stream::Stream;\n+//! #![feature(async_iterator)]\n+//! # use core::async_iter::AsyncIterator;\n //! # use core::task::{Context, Poll};\n //! # use core::pin::Pin;\n //!\n //! // First, the struct:\n //!\n-//! /// A stream which counts from one to five\n+//! /// An async iterator which counts from one to five\n //! struct Counter {\n //!     count: usize,\n //! }\n@@ -90,9 +89,9 @@\n //!     }\n //! }\n //!\n-//! // Then, we implement `Stream` for our `Counter`:\n+//! // Then, we implement `AsyncIterator` for our `Counter`:\n //!\n-//! impl Stream for Counter {\n+//! impl AsyncIterator for Counter {\n //!     // we will be counting with usize\n //!     type Item = usize;\n //!\n@@ -113,17 +112,17 @@\n //!\n //! # Laziness\n //!\n-//! Streams are *lazy*. This means that just creating a stream doesn't _do_ a\n-//! whole lot. Nothing really happens until you call `poll_next`. This is\n-//! sometimes a source of confusion when creating a stream solely for its side\n+//! Async iterators are *lazy*. This means that just creating an async iterator doesn't\n+//! _do_ a whole lot. Nothing really happens until you call `poll_next`. This is\n+//! sometimes a source of confusion when creating an async iterator solely for its side\n //! effects. The compiler will warn us about this kind of behavior:\n //!\n //! ```text\n-//! warning: unused result that must be used: streams do nothing unless polled\n+//! warning: unused result that must be used: async iterators do nothing unless polled\n //! ```\n \n+mod async_iter;\n mod from_iter;\n-mod stream;\n \n+pub use async_iter::AsyncIterator;\n pub use from_iter::{from_iter, FromIter};\n-pub use stream::Stream;", "previous_filename": "library/core/src/stream/mod.rs"}, {"sha": "aa1ad9362a90e897b4fee9c84dc74cdcbeb32ff5", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=f1c918f1f3166c1cb2624ce2e2783d357e70dc3d", "patch": "@@ -305,6 +305,8 @@ pub mod ops;\n pub mod any;\n pub mod array;\n pub mod ascii;\n+#[unstable(feature = \"async_iterator\", issue = \"79024\")]\n+pub mod async_iter;\n pub mod cell;\n pub mod char;\n pub mod ffi;\n@@ -316,8 +318,6 @@ pub mod panic;\n pub mod panicking;\n pub mod pin;\n pub mod result;\n-#[unstable(feature = \"async_stream\", issue = \"79024\")]\n-pub mod stream;\n pub mod sync;\n \n pub mod fmt;"}, {"sha": "95be879e319aac0b7b51bf7ca0262e76de7a3715", "filename": "library/core/src/panic/unwind_safe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs?ref=f1c918f1f3166c1cb2624ce2e2783d357e70dc3d", "patch": "@@ -1,10 +1,10 @@\n+use crate::async_iter::AsyncIterator;\n use crate::cell::UnsafeCell;\n use crate::fmt;\n use crate::future::Future;\n use crate::ops::{Deref, DerefMut};\n use crate::pin::Pin;\n use crate::ptr::{NonNull, Unique};\n-use crate::stream::Stream;\n use crate::task::{Context, Poll};\n \n /// A marker trait which represents \"panic safe\" types in Rust.\n@@ -290,8 +290,8 @@ impl<F: Future> Future for AssertUnwindSafe<F> {\n     }\n }\n \n-#[unstable(feature = \"async_stream\", issue = \"79024\")]\n-impl<S: Stream> Stream for AssertUnwindSafe<S> {\n+#[unstable(feature = \"async_iterator\", issue = \"79024\")]\n+impl<S: AsyncIterator> AsyncIterator for AssertUnwindSafe<S> {\n     type Item = S::Item;\n \n     fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<S::Item>> {"}, {"sha": "8c38db9b62cdcecf9c896f248d10dbd2fb3645e2", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1c918f1f3166c1cb2624ce2e2783d357e70dc3d/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=f1c918f1f3166c1cb2624ce2e2783d357e70dc3d", "patch": "@@ -233,7 +233,7 @@\n #![feature(array_error_internals)]\n #![feature(assert_matches)]\n #![feature(associated_type_bounds)]\n-#![feature(async_stream)]\n+#![feature(async_iterator)]\n #![feature(atomic_mut_ptr)]\n #![feature(auto_traits)]\n #![feature(bench_black_box)]\n@@ -404,6 +404,8 @@ pub use alloc_crate::vec;\n pub use core::any;\n #[stable(feature = \"core_array\", since = \"1.36.0\")]\n pub use core::array;\n+#[unstable(feature = \"async_iterator\", issue = \"79024\")]\n+pub use core::async_iter;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::cell;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -458,8 +460,6 @@ pub use core::pin;\n pub use core::ptr;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::result;\n-#[unstable(feature = \"async_stream\", issue = \"79024\")]\n-pub use core::stream;\n #[stable(feature = \"i128\", since = \"1.26.0\")]\n #[allow(deprecated, deprecated_in_future)]\n pub use core::u128;"}]}