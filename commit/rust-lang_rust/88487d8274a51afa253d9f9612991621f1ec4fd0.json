{"sha": "88487d8274a51afa253d9f9612991621f1ec4fd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NDg3ZDgyNzRhNTFhZmEyNTNkOWY5NjEyOTkxNjIxZjFlYzRmZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-07T06:59:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-07T06:59:05Z"}, "message": "auto merge of #7557 : michaelwoerister/rust/enum_structs, r=pcwalton\n\nAfter getting an ICE trying to use the `Repr` enum from middle::trans::adt (see issue #7527), I tried to implement the missing case for struct-like enum variants in `middle::ty::enum_variants()`. It seems to work now (and passes make check) but there are still some uncertainties that bother me:\r\n+ I'm not sure I did everything, right. Especially getting the variant constructor function from the variant node id is just copied from the tuple-variant case. Someone with more experience in the code base should be able to see rather quickly whether this OK so.\r\n+ It is kind of strange that I could not reproduce the ICE with a smaller test case. The unimplemented code path never seems to be hit in most cases, even when using the exact same `Repr` enum, just with `ty::t` replaced by an opaque pointer. Also, within the `adt` module, `Repr` and matching on it is used multiple times, again without running into problems. Can anyone explain why this is the case? That would be much appreciated. \r\n\r\nApart from that, I hope this PR is useful.", "tree": {"sha": "4fe4653c07ec78158432ee4ab922a7e6561c7e47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fe4653c07ec78158432ee4ab922a7e6561c7e47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88487d8274a51afa253d9f9612991621f1ec4fd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88487d8274a51afa253d9f9612991621f1ec4fd0", "html_url": "https://github.com/rust-lang/rust/commit/88487d8274a51afa253d9f9612991621f1ec4fd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88487d8274a51afa253d9f9612991621f1ec4fd0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b16825216e7b4196a88b103cd6921d8cdb0ba7be", "url": "https://api.github.com/repos/rust-lang/rust/commits/b16825216e7b4196a88b103cd6921d8cdb0ba7be", "html_url": "https://github.com/rust-lang/rust/commit/b16825216e7b4196a88b103cd6921d8cdb0ba7be"}, {"sha": "866a5b1c78e52bd5c1c34df4a1a3c363ad6bfe7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/866a5b1c78e52bd5c1c34df4a1a3c363ad6bfe7c", "html_url": "https://github.com/rust-lang/rust/commit/866a5b1c78e52bd5c1c34df4a1a3c363ad6bfe7c"}], "stats": {"total": 57, "additions": 39, "deletions": 18}, "files": [{"sha": "feac8be8efd8b19a86f9dc23892898175a3e6b4a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/88487d8274a51afa253d9f9612991621f1ec4fd0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88487d8274a51afa253d9f9612991621f1ec4fd0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=88487d8274a51afa253d9f9612991621f1ec4fd0", "patch": "@@ -3828,41 +3828,62 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                 }, _) => {\n             let mut disr_val = -1;\n             @enum_definition.variants.iter().transform(|variant| {\n+\n+                let ctor_ty = node_id_to_type(cx, variant.node.id);\n+\n                 match variant.node.kind {\n                     ast::tuple_variant_kind(ref args) => {\n-                        let ctor_ty = node_id_to_type(cx, variant.node.id);\n-                        let arg_tys = {\n-                            if args.len() > 0u {\n-                                ty_fn_args(ctor_ty).map(|a| *a)\n-                            } else {\n+                        let arg_tys = if args.len() > 0u {\n+                                ty_fn_args(ctor_ty).map(|a| *a) }\n+                            else {\n                                 ~[]\n-                            }\n-                        };\n+                            };\n+\n                         match variant.node.disr_expr {\n                           Some (ex) => {\n                             disr_val = match const_eval::eval_const_expr(cx,\n                                                                          ex) {\n                               const_eval::const_int(val) => val as int,\n-                              _ => cx.sess.bug(\"tag_variants: bad disr expr\")\n+                              _ => cx.sess.bug(\"enum_variants: bad disr expr\")\n                             }\n                           }\n                           _ => disr_val += 1\n                         }\n-                        @VariantInfo_{args: arg_tys,\n-                          ctor_ty: ctor_ty,\n-                          name: variant.node.name,\n-                          id: ast_util::local_def(variant.node.id),\n-                          disr_val: disr_val,\n-                          vis: variant.node.vis\n+                        @VariantInfo_{\n+                            args: arg_tys,\n+                            ctor_ty: ctor_ty,\n+                            name: variant.node.name,\n+                            id: ast_util::local_def(variant.node.id),\n+                            disr_val: disr_val,\n+                            vis: variant.node.vis\n                          }\n-                    }\n-                    ast::struct_variant_kind(_) => {\n-                        fail!(\"struct variant kinds unimpl in enum_variants\")\n+                    },\n+                    ast::struct_variant_kind(struct_def) => {\n+                        let arg_tys =\n+                            // Is this check needed for structs too, or are they always guaranteed\n+                            // to have a valid constructor function?\n+                            if struct_def.fields.len() > 0 {\n+                                ty_fn_args(ctor_ty).map(|a| *a)\n+                            } else {\n+                                ~[]\n+                            };\n+\n+                        assert!(variant.node.disr_expr.is_none());\n+                        disr_val += 1;\n+\n+                        @VariantInfo_{\n+                            args: arg_tys,\n+                            ctor_ty: ctor_ty,\n+                            name: variant.node.name,\n+                            id: ast_util::local_def(variant.node.id),\n+                            disr_val: disr_val,\n+                            vis: variant.node.vis\n+                        }\n                     }\n                 }\n             }).collect()\n           }\n-          _ => cx.sess.bug(\"tag_variants: id not bound to an enum\")\n+          _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n         }\n     };\n     cx.enum_var_cache.insert(id, result);"}]}