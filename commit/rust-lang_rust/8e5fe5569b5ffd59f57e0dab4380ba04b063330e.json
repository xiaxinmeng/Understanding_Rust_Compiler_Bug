{"sha": "8e5fe5569b5ffd59f57e0dab4380ba04b063330e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNWZlNTU2OWI1ZmZkNTlmNTdlMGRhYjQzODBiYTA0YjA2MzMzMGU=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-09-02T19:40:19Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-09-03T18:59:37Z"}, "message": "improve comments and naming", "tree": {"sha": "a317c72a339ae79fc8e5a084265021fac7c09bd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a317c72a339ae79fc8e5a084265021fac7c09bd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e5fe5569b5ffd59f57e0dab4380ba04b063330e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e5fe5569b5ffd59f57e0dab4380ba04b063330e", "html_url": "https://github.com/rust-lang/rust/commit/8e5fe5569b5ffd59f57e0dab4380ba04b063330e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e5fe5569b5ffd59f57e0dab4380ba04b063330e/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64645865423990935a74abecc576a91f5b89f2cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/64645865423990935a74abecc576a91f5b89f2cd", "html_url": "https://github.com/rust-lang/rust/commit/64645865423990935a74abecc576a91f5b89f2cd"}], "stats": {"total": 81, "additions": 56, "deletions": 25}, "files": [{"sha": "5c474ab2cde571c542b3bedb070de4fea0c9abcd", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 56, "deletions": 25, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8e5fe5569b5ffd59f57e0dab4380ba04b063330e/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e5fe5569b5ffd59f57e0dab4380ba04b063330e/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=8e5fe5569b5ffd59f57e0dab4380ba04b063330e", "patch": "@@ -2014,7 +2014,7 @@ impl<T, I: SliceIndex<[T]>> IndexMut<I> for Vec<T> {\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Vec<T> {\n-        <Self as SpecFrom<T, I::IntoIter>>::from_iter(iter.into_iter())\n+        <Self as SpecFromIter<T, I::IntoIter>>::from_iter(iter.into_iter())\n     }\n }\n \n@@ -2096,18 +2096,39 @@ impl<T> Extend<T> for Vec<T> {\n     }\n }\n \n-// Specialization trait used for Vec::from_iter\n-trait SpecFrom<T, I> {\n+/// Specialization trait used for Vec::from_iter\n+///\n+/// ## The delegation graph:\n+///\n+/// ```text\n+/// +-------------+\n+/// |FromIterator |\n+/// +-+-----------+\n+///   |\n+///   v\n+/// +-+-------------------------------+  +---------------------+\n+/// |SpecFromIter                  +---->+SpecFromIterNested   |\n+/// |where I:                      |  |  |where I:             |\n+/// |  Iterator (default)----------+  |  |  Iterator (default) |\n+/// |  vec::IntoIter               |  |  |  TrustedLen         |\n+/// |  SourceIterMarker---fallback-+  |  |                     |\n+/// |  slice::Iter                    |  |                     |\n+/// |  Iterator<Item = &Clone>        |  +---------------------+\n+/// +---------------------------------+\n+///\n+/// ```\n+trait SpecFromIter<T, I> {\n     fn from_iter(iter: I) -> Self;\n }\n \n-// Another specialization trait for Vec::from_iter\n-// necessary to manually prioritize overlapping specializations\n-trait SpecFromNested<T, I> {\n+/// Another specialization trait for Vec::from_iter\n+/// necessary to manually prioritize overlapping specializations\n+/// see [`SpecFromIter`] for details.\n+trait SpecFromIterNested<T, I> {\n     fn from_iter(iter: I) -> Self;\n }\n \n-impl<T, I> SpecFromNested<T, I> for Vec<T>\n+impl<T, I> SpecFromIterNested<T, I> for Vec<T>\n where\n     I: Iterator<Item = T>,\n {\n@@ -2136,7 +2157,7 @@ where\n     }\n }\n \n-impl<T, I> SpecFromNested<T, I> for Vec<T>\n+impl<T, I> SpecFromIterNested<T, I> for Vec<T>\n where\n     I: TrustedLen<Item = T>,\n {\n@@ -2149,12 +2170,12 @@ where\n     }\n }\n \n-impl<T, I> SpecFrom<T, I> for Vec<T>\n+impl<T, I> SpecFromIter<T, I> for Vec<T>\n where\n     I: Iterator<Item = T>,\n {\n     default fn from_iter(iterator: I) -> Self {\n-        SpecFromNested::from_iter(iterator)\n+        SpecFromIterNested::from_iter(iterator)\n     }\n }\n \n@@ -2182,18 +2203,21 @@ impl<T> Drop for InPlaceDrop<T> {\n     }\n }\n \n-impl<T> SpecFrom<T, IntoIter<T>> for Vec<T> {\n+impl<T> SpecFromIter<T, IntoIter<T>> for Vec<T> {\n     fn from_iter(iterator: IntoIter<T>) -> Self {\n         // A common case is passing a vector into a function which immediately\n         // re-collects into a vector. We can short circuit this if the IntoIter\n         // has not been advanced at all.\n-        // We can also reuse the memory and move the data to the front if\n-        // allocating a new vector and moving to it would result in the same capacity\n-        let non_zero_offset = iterator.buf.as_ptr() as *const _ != iterator.ptr;\n-        if !non_zero_offset || iterator.len() >= iterator.cap / 2 {\n+        // When it has been advanced We can also reuse the memory and move the data to the front.\n+        // But we only do so when the resulting Vec wouldn't have more unused capacity\n+        // than creating it through the generic FromIterator implementation would. That limitation\n+        // is not strictly necessary as Vec's allocation behavior is intentionally unspecified.\n+        // But it is a conservative choice.\n+        let has_advanced = iterator.buf.as_ptr() as *const _ != iterator.ptr;\n+        if !has_advanced || iterator.len() >= iterator.cap / 2 {\n             unsafe {\n                 let it = ManuallyDrop::new(iterator);\n-                if non_zero_offset {\n+                if has_advanced {\n                     ptr::copy(it.ptr, it.buf.as_ptr(), it.len());\n                 }\n                 return Vec::from_raw_parts(it.buf.as_ptr(), it.len(), it.cap);\n@@ -2224,6 +2248,12 @@ fn write_in_place_with_drop<T>(\n     }\n }\n \n+/// Specialization marker for collecting an iterator pipeline into a Vec while reusing the\n+/// source allocation, i.e. executing the pipeline in place.\n+///\n+/// The SourceIter parent trait is necessary for the specializing function to access the allocation\n+/// which is to be reused. But it is not sufficient for the specialization to be valid. See\n+/// additional bounds on the impl.\n #[rustc_unsafe_specialization_marker]\n trait SourceIterMarker: SourceIter<Source: AsIntoIter> {}\n \n@@ -2235,7 +2265,7 @@ trait SourceIterMarker: SourceIter<Source: AsIntoIter> {}\n // several other specializations already depend on.\n impl<T> SourceIterMarker for T where T: SourceIter<Source: AsIntoIter> + InPlaceIterable {}\n \n-impl<T, I> SpecFrom<T, I> for Vec<T>\n+impl<T, I> SpecFromIter<T, I> for Vec<T>\n where\n     I: Iterator<Item = T> + SourceIterMarker,\n {\n@@ -2251,7 +2281,8 @@ where\n             || mem::align_of::<T>()\n                 != mem::align_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n         {\n-            return SpecFromNested::from_iter(iterator);\n+            // fallback to more generic implementations\n+            return SpecFromIterNested::from_iter(iterator);\n         }\n \n         let (src_buf, dst_buf, dst_end, cap) = unsafe {\n@@ -2277,9 +2308,9 @@ where\n         debug_assert!(dst as *const _ <= src.ptr, \"InPlaceIterable contract violation\");\n \n         // drop any remaining values at the tail of the source\n-        src.drop_in_place();\n+        src.drop_remaining();\n         // but prevent drop of the allocation itself once IntoIter goes out of scope\n-        src.forget_in_place();\n+        src.forget_allocation();\n \n         let vec = unsafe {\n             let len = dst.offset_from(dst_buf) as usize;\n@@ -2290,17 +2321,17 @@ where\n     }\n }\n \n-impl<'a, T: 'a, I> SpecFrom<&'a T, I> for Vec<T>\n+impl<'a, T: 'a, I> SpecFromIter<&'a T, I> for Vec<T>\n where\n     I: Iterator<Item = &'a T>,\n     T: Clone,\n {\n     default fn from_iter(iterator: I) -> Self {\n-        SpecFrom::from_iter(iterator.cloned())\n+        SpecFromIter::from_iter(iterator.cloned())\n     }\n }\n \n-impl<'a, T: 'a> SpecFrom<&'a T, slice::Iter<'a, T>> for Vec<T>\n+impl<'a, T: 'a> SpecFromIter<&'a T, slice::Iter<'a, T>> for Vec<T>\n where\n     T: Copy,\n {\n@@ -2824,7 +2855,7 @@ impl<T> IntoIter<T> {\n         ptr::slice_from_raw_parts_mut(self.ptr as *mut T, self.len())\n     }\n \n-    fn drop_in_place(&mut self) {\n+    fn drop_remaining(&mut self) {\n         if mem::needs_drop::<T>() {\n             unsafe {\n                 ptr::drop_in_place(self.as_mut_slice());\n@@ -2835,7 +2866,7 @@ impl<T> IntoIter<T> {\n \n     /// Relinquishes the backing allocation, equivalent to\n     /// `ptr::write(&mut self, Vec::new().into_iter())`\n-    fn forget_in_place(&mut self) {\n+    fn forget_allocation(&mut self) {\n         self.cap = 0;\n         self.buf = unsafe { NonNull::new_unchecked(RawVec::NEW.ptr()) };\n         self.ptr = self.buf.as_ptr();"}]}