{"sha": "ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZDM4ZGJmYzI1OGY4ZTI1M2FiNjFkMWJjYTA4YjIxZWZhMmJmM2Q=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-07-23T15:14:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-30T07:22:15Z"}, "message": "rustc: Enable LTO and multiple codegen units\n\nThis commit is a refactoring of the LTO backend in Rust to support compilations\nwith multiple codegen units. The immediate result of this PR is to remove the\nartificial error emitted by rustc about `-C lto -C codegen-units-8`, but longer\nterm this is intended to lay the groundwork for LTO with incremental compilation\nand ultimately be the underpinning of ThinLTO support.\n\nThe problem here that needed solving is that when rustc is producing multiple\ncodegen units in one compilation LTO needs to merge them all together.\nPreviously only upstream dependencies were merged and it was inherently relied\non that there was only one local codegen unit. Supporting this involved\nrefactoring the optimization backend architecture for rustc, namely splitting\nthe `optimize_and_codegen` function into `optimize` and `codegen`. After an LLVM\nmodule has been optimized it may be blocked and queued up for LTO, and only\nafter LTO are modules code generated.\n\nNon-LTO compilations should look the same as they do today backend-wise, we'll\nspin up a thread for each codegen unit and optimize/codegen in that thread. LTO\ncompilations will, however, send the LLVM module back to the coordinator thread\nonce optimizations have finished. When all LLVM modules have finished optimizing\nthe coordinator will invoke the LTO backend, producing a further list of LLVM\nmodules. Currently this is always a list of one LLVM module. The coordinator\nthen spawns further work to run LTO and code generation passes over each module.\n\nIn the course of this refactoring a number of other pieces were refactored:\n\n* Management of the bytecode encoding in rlibs was centralized into one module\n  instead of being scattered across LTO and linking.\n* Some internal refactorings on the link stage of the compiler was done to work\n  directly from `CompiledModule` structures instead of lists of paths.\n* The trans time-graph output was tweaked a little to include a name on each\n  bar and inflate the size of the bars a little", "tree": {"sha": "f31d57bdab0db1627e5aa7b2786c3e6e9434809b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f31d57bdab0db1627e5aa7b2786c3e6e9434809b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "html_url": "https://github.com/rust-lang/rust/commit/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d514263ce3b136775f6e8ec4b94cc1073d16c892", "url": "https://api.github.com/repos/rust-lang/rust/commits/d514263ce3b136775f6e8ec4b94cc1073d16c892", "html_url": "https://github.com/rust-lang/rust/commit/d514263ce3b136775f6e8ec4b94cc1073d16c892"}], "stats": {"total": 1233, "additions": 803, "deletions": 430}, "files": [{"sha": "7c1d457a6eeca23abf4147020dbd784b127a6598", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "patch": "@@ -1552,24 +1552,6 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         early_error(error_format, \"Value for codegen units must be a positive nonzero integer\");\n     }\n \n-    // It's possible that we have `codegen_units > 1` but only one item in\n-    // `trans.modules`.  We could theoretically proceed and do LTO in that\n-    // case, but it would be confusing to have the validity of\n-    // `-Z lto -C codegen-units=2` depend on details of the crate being\n-    // compiled, so we complain regardless.\n-    if cg.lto {\n-        if let Some(n) = codegen_units {\n-            if n > 1 {\n-                // This case is impossible to handle because LTO expects to be able\n-                // to combine the entire crate and all its dependencies into a\n-                // single compilation unit, but each codegen unit is in a separate\n-                // LLVM context, so they can't easily be combined.\n-                early_error(error_format, \"can't perform LTO when using multiple codegen units\");\n-            }\n-        }\n-        codegen_units = Some(1);\n-    }\n-\n     if cg.lto && debugging_opts.incremental.is_some() {\n         early_error(error_format, \"can't perform LTO when compiling incrementally\");\n     }"}, {"sha": "fd4a136f50ba4d32d25548e3d5bdba6a1c9e8bcd", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "patch": "@@ -478,6 +478,7 @@ pub mod debuginfo {\n     }\n }\n \n+pub enum ModuleBuffer {}\n \n // Link to our native llvm bindings (things that we need to use the C++ api\n // for) and because llvm is written in C++ we need to link against libstdc++\n@@ -1609,6 +1610,7 @@ extern \"C\" {\n     pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n     pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef, AddLifetimes: bool);\n     pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef, bc: *const c_char, len: size_t) -> bool;\n+    pub fn LLVMRustLinkInParsedExternalBitcode(M: ModuleRef, M: ModuleRef) -> bool;\n     pub fn LLVMRustRunRestrictionPass(M: ModuleRef, syms: *const *const c_char, len: size_t);\n     pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n \n@@ -1678,4 +1680,9 @@ extern \"C\" {\n     pub fn LLVMRustSetComdat(M: ModuleRef, V: ValueRef, Name: *const c_char);\n     pub fn LLVMRustUnsetComdat(V: ValueRef);\n     pub fn LLVMRustSetModulePIELevel(M: ModuleRef);\n+    pub fn LLVMRustModuleBufferCreate(M: ModuleRef) -> *mut ModuleBuffer;\n+    pub fn LLVMRustModuleBufferPtr(p: *const ModuleBuffer) -> *const u8;\n+    pub fn LLVMRustModuleBufferLen(p: *const ModuleBuffer) -> usize;\n+    pub fn LLVMRustModuleBufferFree(p: *mut ModuleBuffer);\n+    pub fn LLVMRustModuleCost(M: ModuleRef) -> u64;\n }"}, {"sha": "179ef20b19f34bf8c747d8242f84e7bed492405c", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "patch": "@@ -17,6 +17,7 @@ use std::path::{Path, PathBuf};\n use std::ptr;\n use std::str;\n \n+use back::bytecode::RLIB_BYTECODE_EXTENSION;\n use libc;\n use llvm::archive_ro::{ArchiveRO, Child};\n use llvm::{self, ArchiveKind};\n@@ -154,12 +155,9 @@ impl<'a> ArchiveBuilder<'a> {\n         // might be also an extra name suffix\n         let obj_start = format!(\"{}\", name);\n \n-        // Ignoring all bytecode files, no matter of\n-        // name\n-        let bc_ext = \".bytecode.deflate\";\n-\n         self.add_archive(rlib, move |fname: &str| {\n-            if fname.ends_with(bc_ext) || fname == METADATA_FILENAME {\n+            // Ignore bytecode/metadata files, no matter the name.\n+            if fname.ends_with(RLIB_BYTECODE_EXTENSION) || fname == METADATA_FILENAME {\n                 return true\n             }\n "}, {"sha": "55c96322a95c00ec91cc0b6f6ea2fb084c042bbe", "filename": "src/librustc_trans/back/bytecode.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fback%2Fbytecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fback%2Fbytecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fbytecode.rs?ref=ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "patch": "@@ -0,0 +1,160 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Management of the encoding of LLVM bytecode into rlibs\n+//!\n+//! This module contains the management of encoding LLVM bytecode into rlibs,\n+//! primarily for the usage in LTO situations. Currently the compiler will\n+//! unconditionally encode LLVM-IR into rlibs regardless of what's happening\n+//! elsewhere, so we currently compress the bytecode via deflate to avoid taking\n+//! up too much space on disk.\n+//!\n+//! After compressing the bytecode we then have the rest of the format to\n+//! basically deal with various bugs in various archive implementations. The\n+//! format currently is:\n+//!\n+//!     RLIB LLVM-BYTECODE OBJECT LAYOUT\n+//!     Version 2\n+//!     Bytes    Data\n+//!     0..10    \"RUST_OBJECT\" encoded in ASCII\n+//!     11..14   format version as little-endian u32\n+//!     15..19   the length of the module identifier string\n+//!     20..n    the module identifier string\n+//!     n..n+8   size in bytes of deflate compressed LLVM bitcode as\n+//!              little-endian u64\n+//!     n+9..    compressed LLVM bitcode\n+//!     ?        maybe a byte to make this whole thing even length\n+\n+use std::io::{Read, Write};\n+use std::ptr;\n+use std::str;\n+\n+use flate2::Compression;\n+use flate2::read::DeflateDecoder;\n+use flate2::write::DeflateEncoder;\n+\n+// This is the \"magic number\" expected at the beginning of a LLVM bytecode\n+// object in an rlib.\n+pub const RLIB_BYTECODE_OBJECT_MAGIC: &'static [u8] = b\"RUST_OBJECT\";\n+\n+// The version number this compiler will write to bytecode objects in rlibs\n+pub const RLIB_BYTECODE_OBJECT_VERSION: u8 = 2;\n+\n+pub const RLIB_BYTECODE_EXTENSION: &str = \"bytecode.encoded\";\n+\n+pub fn encode(identifier: &str, bytecode: &[u8]) -> Vec<u8> {\n+    let mut encoded = Vec::new();\n+\n+    // Start off with the magic string\n+    encoded.extend_from_slice(RLIB_BYTECODE_OBJECT_MAGIC);\n+\n+    // Next up is the version\n+    encoded.extend_from_slice(&[RLIB_BYTECODE_OBJECT_VERSION, 0, 0, 0]);\n+\n+    // Next is the LLVM module identifier length + contents\n+    let identifier_len = identifier.len();\n+    encoded.extend_from_slice(&[\n+        (identifier_len >>  0) as u8,\n+        (identifier_len >>  8) as u8,\n+        (identifier_len >> 16) as u8,\n+        (identifier_len >> 24) as u8,\n+    ]);\n+    encoded.extend_from_slice(identifier.as_bytes());\n+\n+    // Next is the LLVM module deflate compressed, prefixed with its length. We\n+    // don't know its length yet, so fill in 0s\n+    let deflated_size_pos = encoded.len();\n+    encoded.extend_from_slice(&[0, 0, 0, 0, 0, 0, 0, 0]);\n+\n+    let before = encoded.len();\n+    DeflateEncoder::new(&mut encoded, Compression::Fast)\n+        .write_all(bytecode)\n+        .unwrap();\n+    let after = encoded.len();\n+\n+    // Fill in the length we reserved space for before\n+    let bytecode_len = (after - before) as u64;\n+    encoded[deflated_size_pos + 0] = (bytecode_len >>  0) as u8;\n+    encoded[deflated_size_pos + 1] = (bytecode_len >>  8) as u8;\n+    encoded[deflated_size_pos + 2] = (bytecode_len >> 16) as u8;\n+    encoded[deflated_size_pos + 3] = (bytecode_len >> 24) as u8;\n+    encoded[deflated_size_pos + 4] = (bytecode_len >> 32) as u8;\n+    encoded[deflated_size_pos + 5] = (bytecode_len >> 40) as u8;\n+    encoded[deflated_size_pos + 6] = (bytecode_len >> 48) as u8;\n+    encoded[deflated_size_pos + 7] = (bytecode_len >> 56) as u8;\n+\n+    // If the number of bytes written to the object so far is odd, add a\n+    // padding byte to make it even. This works around a crash bug in LLDB\n+    // (see issue #15950)\n+    if encoded.len() % 2 == 1 {\n+        encoded.push(0);\n+    }\n+\n+    return encoded\n+}\n+\n+pub struct DecodedBytecode<'a> {\n+    identifier: &'a str,\n+    encoded_bytecode: &'a [u8],\n+}\n+\n+impl<'a> DecodedBytecode<'a> {\n+    pub fn new(data: &'a [u8]) -> Result<DecodedBytecode<'a>, String> {\n+        if !data.starts_with(RLIB_BYTECODE_OBJECT_MAGIC) {\n+            return Err(format!(\"magic bytecode prefix not found\"))\n+        }\n+        let data = &data[RLIB_BYTECODE_OBJECT_MAGIC.len()..];\n+        if !data.starts_with(&[RLIB_BYTECODE_OBJECT_VERSION, 0, 0, 0]) {\n+            return Err(format!(\"wrong version prefix found in bytecode\"))\n+        }\n+        let data = &data[4..];\n+        if data.len() < 4 {\n+            return Err(format!(\"bytecode corrupted\"))\n+        }\n+        let identifier_len = unsafe {\n+            u32::from_le(ptr::read_unaligned(data.as_ptr() as *const u32)) as usize\n+        };\n+        let data = &data[4..];\n+        if data.len() < identifier_len {\n+            return Err(format!(\"bytecode corrupted\"))\n+        }\n+        let identifier = match str::from_utf8(&data[..identifier_len]) {\n+            Ok(s) => s,\n+            Err(_) => return Err(format!(\"bytecode corrupted\"))\n+        };\n+        let data = &data[identifier_len..];\n+        if data.len() < 8 {\n+            return Err(format!(\"bytecode corrupted\"))\n+        }\n+        let bytecode_len = unsafe {\n+            u64::from_le(ptr::read_unaligned(data.as_ptr() as *const u64)) as usize\n+        };\n+        let data = &data[8..];\n+        if data.len() < bytecode_len {\n+            return Err(format!(\"bytecode corrupted\"))\n+        }\n+        let encoded_bytecode = &data[..bytecode_len];\n+\n+        Ok(DecodedBytecode {\n+            identifier,\n+            encoded_bytecode,\n+        })\n+    }\n+\n+    pub fn bytecode(&self) -> Vec<u8> {\n+        let mut data = Vec::new();\n+        DeflateDecoder::new(self.encoded_bytecode).read_to_end(&mut data).unwrap();\n+        return data\n+    }\n+\n+    pub fn identifier(&self) -> &'a str {\n+        self.identifier\n+    }\n+}"}, {"sha": "3badc1b9a69861feef01d072f583a8ea49c91500", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 23, "deletions": 108, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use super::archive::{ArchiveBuilder, ArchiveConfig};\n+use super::bytecode::{self, RLIB_BYTECODE_EXTENSION};\n use super::linker::Linker;\n use super::command::Command;\n use super::rpath::RPathConfig;\n@@ -36,12 +37,9 @@ use std::ffi::OsString;\n use std::fmt;\n use std::fs::{self, File};\n use std::io::{self, Read, Write, BufWriter};\n-use std::mem;\n use std::path::{Path, PathBuf};\n use std::process::{Output, Stdio};\n use std::str;\n-use flate2::Compression;\n-use flate2::write::DeflateEncoder;\n use syntax::attr;\n \n /// The LLVM module name containing crate-metadata. This includes a `.` on\n@@ -55,35 +53,6 @@ pub const METADATA_OBJ_NAME: &'static str = \"crate.metadata.o\";\n pub const ALLOCATOR_MODULE_NAME: &'static str = \"crate.allocator\";\n pub const ALLOCATOR_OBJ_NAME: &'static str = \"crate.allocator.o\";\n \n-// RLIB LLVM-BYTECODE OBJECT LAYOUT\n-// Version 1\n-// Bytes    Data\n-// 0..10    \"RUST_OBJECT\" encoded in ASCII\n-// 11..14   format version as little-endian u32\n-// 15..22   size in bytes of deflate compressed LLVM bitcode as\n-//          little-endian u64\n-// 23..     compressed LLVM bitcode\n-\n-// This is the \"magic number\" expected at the beginning of a LLVM bytecode\n-// object in an rlib.\n-pub const RLIB_BYTECODE_OBJECT_MAGIC: &'static [u8] = b\"RUST_OBJECT\";\n-\n-// The version number this compiler will write to bytecode objects in rlibs\n-pub const RLIB_BYTECODE_OBJECT_VERSION: u32 = 1;\n-\n-// The offset in bytes the bytecode object format version number can be found at\n-pub const RLIB_BYTECODE_OBJECT_VERSION_OFFSET: usize = 11;\n-\n-// The offset in bytes the size of the compressed bytecode can be found at in\n-// format version 1\n-pub const RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET: usize =\n-    RLIB_BYTECODE_OBJECT_VERSION_OFFSET + 4;\n-\n-// The offset in bytes the compressed LLVM bytecode can be found at in format\n-// version 1\n-pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: usize =\n-    RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n-\n pub use rustc_trans_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n                                   invalid_output_for_target, build_link_meta, out_filename,\n                                   check_file_is_writeable};\n@@ -201,8 +170,8 @@ pub fn link_binary(sess: &Session,\n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n         if sess.opts.output_types.should_trans() {\n-            for obj in object_filenames(trans, outputs) {\n-                remove(sess, &obj);\n+            for obj in trans.modules.iter() {\n+                remove(sess, &obj.object);\n             }\n         }\n         remove(sess, &outputs.with_extension(METADATA_OBJ_NAME));\n@@ -282,10 +251,8 @@ fn link_binary_output(sess: &Session,\n                       crate_type: config::CrateType,\n                       outputs: &OutputFilenames,\n                       crate_name: &str) -> Vec<PathBuf> {\n-    let objects = object_filenames(trans, outputs);\n-\n-    for file in &objects {\n-        check_file_is_writeable(file, sess);\n+    for module in trans.modules.iter() {\n+        check_file_is_writeable(&module.object, sess);\n     }\n \n     let tmpdir = match TempDir::new(\"rustc\") {\n@@ -308,7 +275,6 @@ fn link_binary_output(sess: &Session,\n                 link_rlib(sess,\n                           trans,\n                           RlibFlavor::Normal,\n-                          &objects,\n                           outputs,\n                           &out_filename,\n                           tmpdir.path()).build();\n@@ -317,12 +283,11 @@ fn link_binary_output(sess: &Session,\n                 link_staticlib(sess,\n                                trans,\n                                outputs,\n-                               &objects,\n                                &out_filename,\n                                tmpdir.path());\n             }\n             _ => {\n-                link_natively(sess, crate_type, &objects, &out_filename,\n+                link_natively(sess, crate_type, &out_filename,\n                               trans, outputs, tmpdir.path());\n             }\n         }\n@@ -336,14 +301,6 @@ fn link_binary_output(sess: &Session,\n     out_filenames\n }\n \n-fn object_filenames(trans: &CrateTranslation,\n-                    outputs: &OutputFilenames)\n-                    -> Vec<PathBuf> {\n-    trans.modules.iter().map(|module| {\n-        outputs.temp_path(OutputType::Object, Some(&module.name))\n-    }).collect()\n-}\n-\n fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n     let mut search = Vec::new();\n     sess.target_filesearch(PathKind::Native).for_each_lib_search_path(|path, _| {\n@@ -387,15 +344,14 @@ enum RlibFlavor {\n fn link_rlib<'a>(sess: &'a Session,\n                  trans: &CrateTranslation,\n                  flavor: RlibFlavor,\n-                 objects: &[PathBuf],\n                  outputs: &OutputFilenames,\n                  out_filename: &Path,\n                  tmpdir: &Path) -> ArchiveBuilder<'a> {\n-    info!(\"preparing rlib from {:?} to {:?}\", objects, out_filename);\n+    info!(\"preparing rlib to {:?}\", out_filename);\n     let mut ab = ArchiveBuilder::new(archive_config(sess, out_filename, None));\n \n-    for obj in objects {\n-        ab.add_file(obj);\n+    for module in trans.modules.iter() {\n+        ab.add_file(&module.object);\n     }\n \n     // Note that in this loop we are ignoring the value of `lib.cfg`. That is,\n@@ -462,15 +418,15 @@ fn link_rlib<'a>(sess: &'a Session,\n             // For LTO purposes, the bytecode of this library is also inserted\n             // into the archive.  If codegen_units > 1, we insert each of the\n             // bitcode files.\n-            for obj in objects {\n+            for module in trans.modules.iter() {\n                 // Note that we make sure that the bytecode filename in the\n                 // archive is never exactly 16 bytes long by adding a 16 byte\n                 // extension to it. This is to work around a bug in LLDB that\n                 // would cause it to crash if the name of a file in an archive\n                 // was exactly 16 bytes.\n-                let bc_filename = obj.with_extension(\"bc\");\n-                let bc_deflated_filename = tmpdir.join({\n-                    obj.with_extension(\"bytecode.deflate\").file_name().unwrap()\n+                let bc_filename = module.object.with_extension(\"bc\");\n+                let bc_encoded_filename = tmpdir.join({\n+                    module.object.with_extension(RLIB_BYTECODE_EXTENSION).file_name().unwrap()\n                 });\n \n                 let mut bc_data = Vec::new();\n@@ -482,28 +438,25 @@ fn link_rlib<'a>(sess: &'a Session,\n                                                  e))\n                 }\n \n-                let mut bc_data_deflated = Vec::new();\n-                DeflateEncoder::new(&mut bc_data_deflated, Compression::Fast)\n-                    .write_all(&bc_data).unwrap();\n+                let encoded = bytecode::encode(&module.llmod_id, &bc_data);\n \n-                let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n+                let mut bc_file_deflated = match fs::File::create(&bc_encoded_filename) {\n                     Ok(file) => file,\n                     Err(e) => {\n                         sess.fatal(&format!(\"failed to create compressed \\\n                                              bytecode file: {}\", e))\n                     }\n                 };\n \n-                match write_rlib_bytecode_object_v1(&mut bc_file_deflated,\n-                                                    &bc_data_deflated) {\n+                match bc_file_deflated.write_all(&encoded) {\n                     Ok(()) => {}\n                     Err(e) => {\n                         sess.fatal(&format!(\"failed to write compressed \\\n                                              bytecode: {}\", e));\n                     }\n                 };\n \n-                ab.add_file(&bc_deflated_filename);\n+                ab.add_file(&bc_encoded_filename);\n \n                 // See the bottom of back::write::run_passes for an explanation\n                 // of when we do and don't keep .#module-name#.bc files around.\n@@ -533,40 +486,6 @@ fn link_rlib<'a>(sess: &'a Session,\n     ab\n }\n \n-fn write_rlib_bytecode_object_v1(writer: &mut Write,\n-                                 bc_data_deflated: &[u8]) -> io::Result<()> {\n-    let bc_data_deflated_size: u64 = bc_data_deflated.len() as u64;\n-\n-    writer.write_all(RLIB_BYTECODE_OBJECT_MAGIC)?;\n-    writer.write_all(&[1, 0, 0, 0])?;\n-    writer.write_all(&[\n-        (bc_data_deflated_size >>  0) as u8,\n-        (bc_data_deflated_size >>  8) as u8,\n-        (bc_data_deflated_size >> 16) as u8,\n-        (bc_data_deflated_size >> 24) as u8,\n-        (bc_data_deflated_size >> 32) as u8,\n-        (bc_data_deflated_size >> 40) as u8,\n-        (bc_data_deflated_size >> 48) as u8,\n-        (bc_data_deflated_size >> 56) as u8,\n-    ])?;\n-    writer.write_all(&bc_data_deflated)?;\n-\n-    let number_of_bytes_written_so_far =\n-        RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n-        mem::size_of_val(&RLIB_BYTECODE_OBJECT_VERSION) + // version\n-        mem::size_of_val(&bc_data_deflated_size) +        // data size field\n-        bc_data_deflated_size as usize;                    // actual data\n-\n-    // If the number of bytes written to the object so far is odd, add a\n-    // padding byte to make it even. This works around a crash bug in LLDB\n-    // (see issue #15950)\n-    if number_of_bytes_written_so_far % 2 == 1 {\n-        writer.write_all(&[0])?;\n-    }\n-\n-    return Ok(());\n-}\n-\n // Create a static archive\n //\n // This is essentially the same thing as an rlib, but it also involves adding\n@@ -582,13 +501,11 @@ fn write_rlib_bytecode_object_v1(writer: &mut Write,\n fn link_staticlib(sess: &Session,\n                   trans: &CrateTranslation,\n                   outputs: &OutputFilenames,\n-                  objects: &[PathBuf],\n                   out_filename: &Path,\n                   tempdir: &Path) {\n     let mut ab = link_rlib(sess,\n                            trans,\n                            RlibFlavor::StaticlibBase,\n-                           objects,\n                            outputs,\n                            out_filename,\n                            tempdir);\n@@ -692,12 +609,11 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n // links to all upstream files as well.\n fn link_natively(sess: &Session,\n                  crate_type: config::CrateType,\n-                 objects: &[PathBuf],\n                  out_filename: &Path,\n                  trans: &CrateTranslation,\n                  outputs: &OutputFilenames,\n                  tmpdir: &Path) {\n-    info!(\"preparing {:?} from {:?} to {:?}\", crate_type, objects, out_filename);\n+    info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n     let flavor = sess.linker_flavor();\n \n     // The invocations of cc share some flags across platforms\n@@ -735,7 +651,7 @@ fn link_natively(sess: &Session,\n     {\n         let mut linker = trans.linker_info.to_linker(cmd, &sess);\n         link_args(&mut *linker, sess, crate_type, tmpdir,\n-                  objects, out_filename, outputs, trans);\n+                  out_filename, outputs, trans);\n         cmd = linker.finalize();\n     }\n     if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n@@ -956,7 +872,6 @@ fn link_args(cmd: &mut Linker,\n              sess: &Session,\n              crate_type: config::CrateType,\n              tmpdir: &Path,\n-             objects: &[PathBuf],\n              out_filename: &Path,\n              outputs: &OutputFilenames,\n              trans: &CrateTranslation) {\n@@ -969,8 +884,8 @@ fn link_args(cmd: &mut Linker,\n     let t = &sess.target.target;\n \n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n-    for obj in objects {\n-        cmd.add_object(obj);\n+    for module in trans.modules.iter() {\n+        cmd.add_object(&module.object);\n     }\n     cmd.output_filename(out_filename);\n \n@@ -1264,7 +1179,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n         archive.update_symbols();\n \n         for f in archive.src_files() {\n-            if f.ends_with(\"bytecode.deflate\") || f == METADATA_FILENAME {\n+            if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n                     archive.remove_file(&f);\n                     continue\n                 }\n@@ -1342,7 +1257,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n \n             let mut any_objects = false;\n             for f in archive.src_files() {\n-                if f.ends_with(\"bytecode.deflate\") || f == METADATA_FILENAME {\n+                if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n                     archive.remove_file(&f);\n                     continue\n                 }"}, {"sha": "8651b95b12a5ea85987cee2fa78994ec9816b8e1", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 188, "deletions": 91, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::link;\n+use back::bytecode::{DecodedBytecode, RLIB_BYTECODE_EXTENSION};\n use back::write;\n use back::symbol_export;\n use rustc::session::config;\n@@ -18,17 +18,14 @@ use llvm::archive_ro::ArchiveRO;\n use llvm::{ModuleRef, TargetMachineRef, True, False};\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::util::common::time;\n-use rustc::util::common::path2cstr;\n use rustc::hir::def_id::LOCAL_CRATE;\n use back::write::{ModuleConfig, with_llvm_pmb, CodegenContext};\n+use {ModuleTranslation, ModuleKind};\n \n use libc;\n-use flate2::read::DeflateDecoder;\n \n-use std::io::Read;\n use std::ffi::CString;\n-use std::path::Path;\n-use std::ptr::read_unaligned;\n+use std::slice;\n \n pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     match crate_type {\n@@ -42,12 +39,58 @@ pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     }\n }\n \n-pub fn run(cgcx: &CodegenContext,\n-           diag_handler: &Handler,\n-           llmod: ModuleRef,\n-           tm: TargetMachineRef,\n-           config: &ModuleConfig,\n-           temp_no_opt_bc_filename: &Path) -> Result<(), FatalError> {\n+pub enum LtoModuleTranslation {\n+    Fat {\n+        module: Option<ModuleTranslation>,\n+        _serialized_bitcode: Vec<SerializedModule>,\n+    },\n+\n+    // Note the lack of other entries in this enum! Ideally one day this gap is\n+    // intended to be filled with a \"Thin\" LTO variant.\n+}\n+\n+impl LtoModuleTranslation {\n+    pub fn name(&self) -> &str {\n+        match *self {\n+            LtoModuleTranslation::Fat { .. } => \"everything\",\n+        }\n+    }\n+\n+    /// Optimize this module within the given codegen context.\n+    ///\n+    /// This function is unsafe as it'll return a `ModuleTranslation` still\n+    /// points to LLVM data structures owned by this `LtoModuleTranslation`.\n+    /// It's intended that the module returned is immediately code generated and\n+    /// dropped, and then this LTO module is dropped.\n+    pub unsafe fn optimize(&mut self, cgcx: &CodegenContext)\n+        -> Result<ModuleTranslation, FatalError>\n+    {\n+        match *self {\n+            LtoModuleTranslation::Fat { ref mut module, .. } => {\n+                let trans = module.take().unwrap();\n+                let config = cgcx.config(trans.kind);\n+                let llmod = trans.llvm().unwrap().llmod;\n+                let tm = trans.llvm().unwrap().tm;\n+                run_pass_manager(cgcx, tm, llmod, config);\n+                Ok(trans)\n+            }\n+        }\n+    }\n+\n+    /// A \"guage\" of how costly it is to optimize this module, used to sort\n+    /// biggest modules first.\n+    pub fn cost(&self) -> u64 {\n+        match *self {\n+            // Only one module with fat LTO, so the cost doesn't matter.\n+            LtoModuleTranslation::Fat { .. } => 0,\n+        }\n+    }\n+}\n+\n+pub fn run(cgcx: &CodegenContext, modules: Vec<ModuleTranslation>)\n+    -> Result<Vec<LtoModuleTranslation>, FatalError>\n+{\n+    let diag_handler = cgcx.create_diag_handler();\n     if cgcx.opts.cg.prefer_dynamic {\n         diag_handler.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n                     .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n@@ -82,106 +125,140 @@ pub fn run(cgcx: &CodegenContext,\n         .iter()\n         .filter_map(symbol_filter)\n         .collect();\n+    info!(\"{} symbols in whitelist\", symbol_white_list.len());\n \n     // For each of our upstream dependencies, find the corresponding rlib and\n     // load the bitcode from the archive. Then merge it into the current LLVM\n     // module that we've got.\n+    let mut upstream_modules = Vec::new();\n     for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n         symbol_white_list.extend(\n             cgcx.exported_symbols[&cnum]\n                 .iter()\n                 .filter_map(symbol_filter));\n+        info!(\"{} symbols in whitelist after {}\", symbol_white_list.len(), cnum);\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let bytecodes = archive.iter().filter_map(|child| {\n             child.ok().and_then(|c| c.name().map(|name| (name, c)))\n-        }).filter(|&(name, _)| name.ends_with(\"bytecode.deflate\"));\n+        }).filter(|&(name, _)| name.ends_with(RLIB_BYTECODE_EXTENSION));\n         for (name, data) in bytecodes {\n+            info!(\"adding bytecode {}\", name);\n             let bc_encoded = data.data();\n \n-            let bc_decoded = if is_versioned_bytecode_format(bc_encoded) {\n-                time(cgcx.time_passes, &format!(\"decode {}\", name), || {\n-                    // Read the version\n-                    let version = extract_bytecode_format_version(bc_encoded);\n-\n-                    if version == 1 {\n-                        // The only version existing so far\n-                        let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n-                        let compressed_data = &bc_encoded[\n-                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET..\n-                            (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as usize)];\n-\n-                        let mut inflated = Vec::new();\n-                        let res = DeflateDecoder::new(compressed_data)\n-                            .read_to_end(&mut inflated);\n-                        if res.is_err() {\n-                            let msg = format!(\"failed to decompress bc of `{}`\",\n-                                              name);\n-                            Err(diag_handler.fatal(&msg))\n-                        } else {\n-                            Ok(inflated)\n-                        }\n-                    } else {\n-                        Err(diag_handler.fatal(&format!(\"Unsupported bytecode format version {}\",\n-                                                        version)))\n-                    }\n-                })?\n-            } else {\n-                time(cgcx.time_passes, &format!(\"decode {}\", name), || {\n-                    // the object must be in the old, pre-versioning format, so\n-                    // simply inflate everything and let LLVM decide if it can\n-                    // make sense of it\n-                    let mut inflated = Vec::new();\n-                    let res = DeflateDecoder::new(bc_encoded)\n-                        .read_to_end(&mut inflated);\n-                    if res.is_err() {\n-                        let msg = format!(\"failed to decompress bc of `{}`\",\n-                                          name);\n-                        Err(diag_handler.fatal(&msg))\n-                    } else {\n-                        Ok(inflated)\n-                    }\n-                })?\n-            };\n-\n-            let ptr = bc_decoded.as_ptr();\n-            debug!(\"linking {}\", name);\n-            time(cgcx.time_passes, &format!(\"ll link {}\", name), || unsafe {\n-                if llvm::LLVMRustLinkInExternalBitcode(llmod,\n-                                                       ptr as *const libc::c_char,\n-                                                       bc_decoded.len() as libc::size_t) {\n-                    Ok(())\n-                } else {\n-                    let msg = format!(\"failed to load bc of `{}`\", name);\n-                    Err(write::llvm_err(&diag_handler, msg))\n+            let (bc, id) = time(cgcx.time_passes, &format!(\"decode {}\", name), || {\n+                match DecodedBytecode::new(bc_encoded) {\n+                    Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n+                    Err(e) => Err(diag_handler.fatal(&e)),\n                 }\n             })?;\n+            let bc = SerializedModule::FromRlib(bc);\n+            upstream_modules.push((bc, CString::new(id).unwrap()));\n         }\n     }\n \n     // Internalize everything but the exported symbols of the current module\n     let arr: Vec<*const libc::c_char> = symbol_white_list.iter()\n                                                          .map(|c| c.as_ptr())\n                                                          .collect();\n-    let ptr = arr.as_ptr();\n+\n+    fat_lto(cgcx, &diag_handler, modules, upstream_modules, &arr)\n+}\n+\n+fn fat_lto(cgcx: &CodegenContext,\n+           diag_handler: &Handler,\n+           mut modules: Vec<ModuleTranslation>,\n+           mut serialized_modules: Vec<(SerializedModule, CString)>,\n+           symbol_white_list: &[*const libc::c_char])\n+    -> Result<Vec<LtoModuleTranslation>, FatalError>\n+{\n+    info!(\"going for a fat lto\");\n+\n+    // Find the \"costliest\" module and merge everything into that codegen unit.\n+    // All the other modules will be serialized and reparsed into the new\n+    // context, so this hopefully avoids serializing and parsing the largest\n+    // codegen unit.\n+    //\n+    // Additionally use a regular module as the base here to ensure that various\n+    // file copy operations in the backend work correctly. The only other kind\n+    // of module here should be an allocator one, and if your crate is smaller\n+    // than the allocator module then the size doesn't really matter anyway.\n+    let (_, costliest_module) = modules.iter()\n+        .enumerate()\n+        .filter(|&(_, module)| module.kind == ModuleKind::Regular)\n+        .map(|(i, module)| {\n+            let cost = unsafe {\n+                llvm::LLVMRustModuleCost(module.llvm().unwrap().llmod)\n+            };\n+            (cost, i)\n+        })\n+        .max()\n+        .expect(\"must be trans'ing at least one module\");\n+    let module = modules.remove(costliest_module);\n+    let llmod = module.llvm().expect(\"can't lto pre-translated modules\").llmod;\n+    info!(\"using {:?} as a base module\", module.llmod_id);\n+\n+    // For all other modules we translated we'll need to link them into our own\n+    // bitcode. All modules were translated in their own LLVM context, however,\n+    // and we want to move everything to the same LLVM context. Currently the\n+    // way we know of to do that is to serialize them to a string and them parse\n+    // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n+    for module in modules {\n+        let llvm = module.llvm().expect(\"can't lto pre-translated modules\");\n+        let buffer = ModuleBuffer::new(llvm.llmod);\n+        let llmod_id = CString::new(&module.llmod_id[..]).unwrap();\n+        serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n+    }\n+\n+    // For all serialized bitcode files we parse them and link them in as we did\n+    // above, this is all mostly handled in C++. Like above, though, we don't\n+    // know much about the memory management here so we err on the side of being\n+    // save and persist everything with the original module.\n+    let mut serialized_bitcode = Vec::new();\n+    for (bc_decoded, name) in serialized_modules {\n+        info!(\"linking {:?}\", name);\n+        time(cgcx.time_passes, &format!(\"ll link {:?}\", name), || unsafe {\n+            let data = bc_decoded.data();\n+            if llvm::LLVMRustLinkInExternalBitcode(llmod,\n+                                                   data.as_ptr() as *const libc::c_char,\n+                                                   data.len() as libc::size_t) {\n+                Ok(())\n+            } else {\n+                let msg = format!(\"failed to load bc of {:?}\", name);\n+                Err(write::llvm_err(&diag_handler, msg))\n+            }\n+        })?;\n+        serialized_bitcode.push(bc_decoded);\n+    }\n+    cgcx.save_temp_bitcode(&module, \"lto.input\");\n+\n+    // Internalize everything that *isn't* in our whitelist to help strip out\n+    // more modules and such\n     unsafe {\n+        let ptr = symbol_white_list.as_ptr();\n         llvm::LLVMRustRunRestrictionPass(llmod,\n                                          ptr as *const *const libc::c_char,\n-                                         arr.len() as libc::size_t);\n+                                         symbol_white_list.len() as libc::size_t);\n+        cgcx.save_temp_bitcode(&module, \"lto.after-restriction\");\n     }\n \n     if cgcx.no_landing_pads {\n         unsafe {\n             llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n         }\n+        cgcx.save_temp_bitcode(&module, \"lto.after-nounwind\");\n     }\n \n-    if cgcx.opts.cg.save_temps {\n-        let cstr = path2cstr(temp_no_opt_bc_filename);\n-        unsafe {\n-            llvm::LLVMWriteBitcodeToFile(llmod, cstr.as_ptr());\n-        }\n-    }\n+    Ok(vec![LtoModuleTranslation::Fat {\n+        module: Some(module),\n+        _serialized_bitcode: serialized_bitcode,\n+    }])\n+}\n+\n+fn run_pass_manager(cgcx: &CodegenContext,\n+                    tm: TargetMachineRef,\n+                    llmod: ModuleRef,\n+                    config: &ModuleConfig) {\n \n     // Now we have one massive module inside of llmod. Time to run the\n     // LTO-specific optimization passes that LLVM provides.\n@@ -212,25 +289,45 @@ pub fn run(cgcx: &CodegenContext,\n         llvm::LLVMDisposePassManager(pm);\n     }\n     debug!(\"lto done\");\n-    Ok(())\n }\n \n-fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n-    let magic_id_byte_count = link::RLIB_BYTECODE_OBJECT_MAGIC.len();\n-    return bc.len() > magic_id_byte_count &&\n-           &bc[..magic_id_byte_count] == link::RLIB_BYTECODE_OBJECT_MAGIC;\n+pub enum SerializedModule {\n+    Local(ModuleBuffer),\n+    FromRlib(Vec<u8>),\n }\n \n-fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n-    let pos = link::RLIB_BYTECODE_OBJECT_VERSION_OFFSET;\n-    let byte_data = &bc[pos..pos + 4];\n-    let data = unsafe { read_unaligned(byte_data.as_ptr() as *const u32) };\n-    u32::from_le(data)\n+impl SerializedModule {\n+    fn data(&self) -> &[u8] {\n+        match *self {\n+            SerializedModule::Local(ref m) => m.data(),\n+            SerializedModule::FromRlib(ref m) => m,\n+        }\n+    }\n }\n \n-fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n-    let pos = link::RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET;\n-    let byte_data = &bc[pos..pos + 8];\n-    let data = unsafe { read_unaligned(byte_data.as_ptr() as *const u64) };\n-    u64::from_le(data)\n+pub struct ModuleBuffer(*mut llvm::ModuleBuffer);\n+\n+unsafe impl Send for ModuleBuffer {}\n+unsafe impl Sync for ModuleBuffer {}\n+\n+impl ModuleBuffer {\n+    fn new(m: ModuleRef) -> ModuleBuffer {\n+        ModuleBuffer(unsafe {\n+            llvm::LLVMRustModuleBufferCreate(m)\n+        })\n+    }\n+\n+    fn data(&self) -> &[u8] {\n+        unsafe {\n+            let ptr = llvm::LLVMRustModuleBufferPtr(self.0);\n+            let len = llvm::LLVMRustModuleBufferLen(self.0);\n+            slice::from_raw_parts(ptr, len)\n+        }\n+    }\n+}\n+\n+impl Drop for ModuleBuffer {\n+    fn drop(&mut self) {\n+        unsafe { llvm::LLVMRustModuleBufferFree(self.0); }\n+    }\n }"}, {"sha": "c39bdcf25cd51b528d22749ba9d92ed2bb4a8794", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 258, "deletions": 122, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "patch": "@@ -22,7 +22,7 @@ use rustc::util::nodemap::FxHashMap;\n use time_graph::{self, TimeGraph};\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n-use llvm::SMDiagnosticRef;\n+use llvm::{SMDiagnosticRef, ContextRef};\n use {CrateTranslation, ModuleSource, ModuleTranslation, CompiledModule, ModuleKind};\n use CrateInfo;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n@@ -41,10 +41,10 @@ use rustc_demangle;\n \n use std::any::Any;\n use std::ffi::CString;\n-use std::fmt;\n use std::fs;\n use std::io;\n use std::io::Write;\n+use std::mem;\n use std::path::{Path, PathBuf};\n use std::str;\n use std::sync::Arc;\n@@ -143,6 +143,14 @@ fn get_llvm_opt_size(optimize: config::OptLevel) -> llvm::CodeGenOptSize {\n }\n \n pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n+    target_machine_factory(sess)().unwrap_or_else(|err| {\n+        panic!(llvm_err(sess.diagnostic(), err))\n+    })\n+}\n+\n+pub fn target_machine_factory(sess: &Session)\n+    -> Arc<Fn() -> Result<TargetMachineRef, String> + Send + Sync>\n+{\n     let reloc_model = get_reloc_model(sess);\n \n     let opt_level = get_llvm_opt_level(sess.opts.optimize);\n@@ -171,36 +179,38 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n \n     let triple = &sess.target.target.llvm_target;\n \n-    let tm = unsafe {\n-        let triple = CString::new(triple.as_bytes()).unwrap();\n-        let cpu = match sess.opts.cg.target_cpu {\n-            Some(ref s) => &**s,\n-            None => &*sess.target.target.options.cpu\n-        };\n-        let cpu = CString::new(cpu.as_bytes()).unwrap();\n-        let features = CString::new(target_feature(sess).as_bytes()).unwrap();\n-        llvm::LLVMRustCreateTargetMachine(\n-            triple.as_ptr(), cpu.as_ptr(), features.as_ptr(),\n-            code_model,\n-            reloc_model,\n-            opt_level,\n-            use_softfp,\n-            is_pie_binary(sess),\n-            ffunction_sections,\n-            fdata_sections,\n-        )\n+    let triple = CString::new(triple.as_bytes()).unwrap();\n+    let cpu = match sess.opts.cg.target_cpu {\n+        Some(ref s) => &**s,\n+        None => &*sess.target.target.options.cpu\n     };\n+    let cpu = CString::new(cpu.as_bytes()).unwrap();\n+    let features = CString::new(target_feature(sess).as_bytes()).unwrap();\n+    let is_pie_binary = is_pie_binary(sess);\n+\n+    Arc::new(move || {\n+        let tm = unsafe {\n+            llvm::LLVMRustCreateTargetMachine(\n+                triple.as_ptr(), cpu.as_ptr(), features.as_ptr(),\n+                code_model,\n+                reloc_model,\n+                opt_level,\n+                use_softfp,\n+                is_pie_binary,\n+                ffunction_sections,\n+                fdata_sections,\n+            )\n+        };\n \n-    if tm.is_null() {\n-        let msg = format!(\"Could not create LLVM TargetMachine for triple: {}\",\n-                          triple);\n-        panic!(llvm_err(sess.diagnostic(), msg));\n-    } else {\n-        return tm;\n-    };\n+        if tm.is_null() {\n+            Err(format!(\"Could not create LLVM TargetMachine for triple: {}\",\n+                        triple.to_str().unwrap()))\n+        } else {\n+            Ok(tm)\n+        }\n+    })\n }\n \n-\n /// Module-specific configuration for `optimize_and_codegen`.\n pub struct ModuleConfig {\n     /// Names of additional optimization passes to run.\n@@ -294,6 +304,7 @@ pub struct CodegenContext {\n     pub time_passes: bool,\n     pub lto: bool,\n     pub no_landing_pads: bool,\n+    pub save_temps: bool,\n     pub exported_symbols: Arc<ExportedSymbols>,\n     pub opts: Arc<config::Options>,\n     pub crate_types: Vec<config::CrateType>,\n@@ -302,6 +313,7 @@ pub struct CodegenContext {\n     regular_module_config: Arc<ModuleConfig>,\n     metadata_module_config: Arc<ModuleConfig>,\n     allocator_module_config: Arc<ModuleConfig>,\n+    pub tm_factory: Arc<Fn() -> Result<TargetMachineRef, String> + Send + Sync>,\n \n     // Handler to use for diagnostics produced during codegen.\n     pub diag_emitter: SharedEmitter,\n@@ -322,22 +334,62 @@ pub struct CodegenContext {\n }\n \n impl CodegenContext {\n-    fn create_diag_handler(&self) -> Handler {\n+    pub fn create_diag_handler(&self) -> Handler {\n         Handler::with_emitter(true, false, Box::new(self.diag_emitter.clone()))\n     }\n \n-    fn config(&self, kind: ModuleKind) -> &ModuleConfig {\n+    pub fn config(&self, kind: ModuleKind) -> &ModuleConfig {\n         match kind {\n             ModuleKind::Regular => &self.regular_module_config,\n             ModuleKind::Metadata => &self.metadata_module_config,\n             ModuleKind::Allocator => &self.allocator_module_config,\n         }\n     }\n+\n+    pub fn save_temp_bitcode(&self, trans: &ModuleTranslation, name: &str) {\n+        if !self.save_temps {\n+            return\n+        }\n+        unsafe {\n+            let ext = format!(\"{}.bc\", name);\n+            let cgu = Some(&trans.name[..]);\n+            let path = self.output_filenames.temp_path_ext(&ext, cgu);\n+            let cstr = path2cstr(&path);\n+            let llmod = trans.llvm().unwrap().llmod;\n+            llvm::LLVMWriteBitcodeToFile(llmod, cstr.as_ptr());\n+        }\n+    }\n+}\n+\n+struct DiagnosticHandlers<'a> {\n+    inner: Box<(&'a CodegenContext, &'a Handler)>,\n+    llcx: ContextRef,\n+}\n+\n+impl<'a> DiagnosticHandlers<'a> {\n+    fn new(cgcx: &'a CodegenContext,\n+           handler: &'a Handler,\n+           llcx: ContextRef) -> DiagnosticHandlers<'a> {\n+        let data = Box::new((cgcx, handler));\n+        unsafe {\n+            let arg = &*data as &(_, _) as *const _ as *mut _;\n+            llvm::LLVMRustSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, arg);\n+            llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler, arg);\n+        }\n+        DiagnosticHandlers {\n+            inner: data,\n+            llcx: llcx,\n+        }\n+    }\n }\n \n-struct HandlerFreeVars<'a> {\n-    cgcx: &'a CodegenContext,\n-    diag_handler: &'a Handler,\n+impl<'a> Drop for DiagnosticHandlers<'a> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustSetInlineAsmDiagnosticHandler(self.llcx, inline_asm_handler, 0 as *mut _);\n+            llvm::LLVMContextSetDiagnosticHandler(self.llcx, diagnostic_handler, 0 as *mut _);\n+        }\n+    }\n }\n \n unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext,\n@@ -349,7 +401,10 @@ unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext,\n unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n                                         user: *const c_void,\n                                         cookie: c_uint) {\n-    let HandlerFreeVars { cgcx, .. } = *(user as *const HandlerFreeVars);\n+    if user.is_null() {\n+        return\n+    }\n+    let (cgcx, _) = *(user as *const (&CodegenContext, &Handler));\n \n     let msg = llvm::build_string(|s| llvm::LLVMRustWriteSMDiagnosticToString(diag, s))\n         .expect(\"non-UTF8 SMDiagnostic\");\n@@ -358,7 +413,10 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n }\n \n unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_void) {\n-    let HandlerFreeVars { cgcx, diag_handler, .. } = *(user as *const HandlerFreeVars);\n+    if user.is_null() {\n+        return\n+    }\n+    let (cgcx, diag_handler) = *(user as *const (&CodegenContext, &Handler));\n \n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::InlineAsm(inline) => {\n@@ -389,28 +447,20 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n }\n \n // Unsafe due to LLVM calls.\n-unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n-                               diag_handler: &Handler,\n-                               mtrans: ModuleTranslation,\n-                               tm: TargetMachineRef,\n-                               config: &ModuleConfig)\n-    -> Result<CompiledModule, FatalError>\n+unsafe fn optimize(cgcx: &CodegenContext,\n+                   diag_handler: &Handler,\n+                   mtrans: &ModuleTranslation,\n+                   config: &ModuleConfig)\n+    -> Result<(), FatalError>\n {\n-    let (llmod, llcx) = match mtrans.source {\n-        ModuleSource::Translated(ref llvm) => (llvm.llmod, llvm.llcx),\n+    let (llmod, llcx, tm) = match mtrans.source {\n+        ModuleSource::Translated(ref llvm) => (llvm.llmod, llvm.llcx, llvm.tm),\n         ModuleSource::Preexisting(_) => {\n             bug!(\"optimize_and_codegen: called with ModuleSource::Preexisting\")\n         }\n     };\n \n-    let fv = HandlerFreeVars {\n-        cgcx,\n-        diag_handler,\n-    };\n-    let fv = &fv as *const HandlerFreeVars as *mut c_void;\n-\n-    llvm::LLVMRustSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, fv);\n-    llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler, fv);\n+    let _handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n \n     let module_name = mtrans.name.clone();\n     let module_name = Some(&module_name[..]);\n@@ -485,25 +535,37 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         // Deallocate managers that we're now done with\n         llvm::LLVMDisposePassManager(fpm);\n         llvm::LLVMDisposePassManager(mpm);\n+    }\n+    Ok(())\n+}\n \n-        if cgcx.lto {\n-            time(cgcx.time_passes, \"all lto passes\", || {\n-                let temp_no_opt_bc_filename =\n-                    cgcx.output_filenames.temp_path_ext(\"no-opt.lto.bc\", module_name);\n-                lto::run(cgcx,\n-                         diag_handler,\n-                         llmod,\n-                         tm,\n-                         &config,\n-                         &temp_no_opt_bc_filename)\n-            })?;\n-            if config.emit_lto_bc {\n-                let out = cgcx.output_filenames.temp_path_ext(\"lto.bc\", module_name);\n-                let out = path2cstr(&out);\n-                llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n-            }\n+fn generate_lto_work(cgcx: &CodegenContext,\n+                     modules: Vec<ModuleTranslation>)\n+    -> Vec<(WorkItem, u64)>\n+{\n+    let lto_modules = lto::run(cgcx, modules).unwrap_or_else(|e| panic!(e));\n+\n+    lto_modules.into_iter().map(|module| {\n+        let cost = module.cost();\n+        (WorkItem::LTO(module), cost)\n+    }).collect()\n+}\n+\n+unsafe fn codegen(cgcx: &CodegenContext,\n+                  diag_handler: &Handler,\n+                  mtrans: ModuleTranslation,\n+                  config: &ModuleConfig)\n+    -> Result<CompiledModule, FatalError>\n+{\n+    let (llmod, llcx, tm) = match mtrans.source {\n+        ModuleSource::Translated(ref llvm) => (llvm.llmod, llvm.llcx, llvm.tm),\n+        ModuleSource::Preexisting(_) => {\n+            bug!(\"codegen: called with ModuleSource::Preexisting\")\n         }\n-    }\n+    };\n+    let module_name = mtrans.name.clone();\n+    let module_name = Some(&module_name[..]);\n+    let handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n \n     // A codegen-specific pass manager is used to generate object\n     // files for an LLVM module.\n@@ -629,7 +691,10 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n     }\n \n-    Ok(mtrans.into_compiled_module(config.emit_obj, config.emit_bc))\n+    drop(handlers);\n+    Ok(mtrans.into_compiled_module(config.emit_obj,\n+                                   config.emit_bc,\n+                                   &cgcx.output_filenames))\n }\n \n pub struct CompiledModules {\n@@ -990,37 +1055,50 @@ pub fn dump_incremental_data(trans: &CrateTranslation) {\n     eprintln!(\"incremental: re-using {} out of {} modules\", reuse, trans.modules.len());\n }\n \n-struct WorkItem {\n-    mtrans: ModuleTranslation,\n-    tm: TargetMachine,\n+enum WorkItem {\n+    Optimize(ModuleTranslation),\n+    LTO(lto::LtoModuleTranslation),\n }\n \n-impl fmt::Debug for WorkItem {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"WorkItem({})\", self.mtrans.name)\n+impl WorkItem {\n+    fn kind(&self) -> ModuleKind {\n+        match *self {\n+            WorkItem::Optimize(ref m) => m.kind,\n+            WorkItem::LTO(_) => ModuleKind::Regular,\n+        }\n     }\n-}\n-\n-struct TargetMachine(TargetMachineRef);\n \n-unsafe impl Send for TargetMachine {}\n-\n-impl Drop for TargetMachine {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMRustDisposeTargetMachine(self.0);\n+    fn name(&self) -> String {\n+        match *self {\n+            WorkItem::Optimize(ref m) => format!(\"optimize: {}\", m.name),\n+            WorkItem::LTO(ref m) => format!(\"lto: {}\", m.name()),\n         }\n     }\n }\n \n+enum WorkItemResult {\n+    Compiled(CompiledModule),\n+    NeedsLTO(ModuleTranslation),\n+}\n+\n fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n-    -> Result<CompiledModule, FatalError>\n+    -> Result<WorkItemResult, FatalError>\n {\n     let diag_handler = cgcx.create_diag_handler();\n-    let module_name = work_item.mtrans.name.clone();\n-    let config = cgcx.config(work_item.mtrans.kind);\n+    let config = cgcx.config(work_item.kind());\n+    let mtrans = match work_item {\n+        WorkItem::Optimize(mtrans) => mtrans,\n+        WorkItem::LTO(mut lto) => {\n+            unsafe {\n+                let module = lto.optimize(cgcx)?;\n+                let module = codegen(cgcx, &diag_handler, module, config)?;\n+                return Ok(WorkItemResult::Compiled(module))\n+            }\n+        }\n+    };\n+    let module_name = mtrans.name.clone();\n \n-    let pre_existing = match work_item.mtrans.source {\n+    let pre_existing = match mtrans.source {\n         ModuleSource::Translated(_) => None,\n         ModuleSource::Preexisting(ref wp) => Some(wp.clone()),\n     };\n@@ -1029,13 +1107,13 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n         let incr_comp_session_dir = cgcx.incr_comp_session_dir\n                                         .as_ref()\n                                         .unwrap();\n-        let name = &work_item.mtrans.name;\n+        let name = &mtrans.name;\n         for (kind, saved_file) in wp.saved_files {\n             let obj_out = cgcx.output_filenames.temp_path(kind, Some(name));\n             let source_file = in_incr_comp_dir(&incr_comp_session_dir,\n                                                &saved_file);\n             debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n-                   work_item.mtrans.name,\n+                   mtrans.name,\n                    source_file,\n                    obj_out.display());\n             match link_or_copy(&source_file, &obj_out) {\n@@ -1048,31 +1126,39 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n                 }\n             }\n         }\n+        let object = cgcx.output_filenames.temp_path(OutputType::Object, Some(name));\n \n-        Ok(CompiledModule {\n+        Ok(WorkItemResult::Compiled(CompiledModule {\n+            object,\n+            llmod_id: mtrans.llmod_id.clone(),\n             name: module_name,\n             kind: ModuleKind::Regular,\n             pre_existing: true,\n-            symbol_name_hash: work_item.mtrans.symbol_name_hash,\n+            symbol_name_hash: mtrans.symbol_name_hash,\n             emit_bc: config.emit_bc,\n             emit_obj: config.emit_obj,\n-        })\n+        }))\n     } else {\n         debug!(\"llvm-optimizing {:?}\", module_name);\n \n         unsafe {\n-            optimize_and_codegen(cgcx,\n-                                 &diag_handler,\n-                                 work_item.mtrans,\n-                                 work_item.tm.0,\n-                                 config)\n+            optimize(cgcx, &diag_handler, &mtrans, config)?;\n+            if !cgcx.lto || mtrans.kind == ModuleKind::Metadata {\n+                let module = codegen(cgcx, &diag_handler, mtrans, config)?;\n+                Ok(WorkItemResult::Compiled(module))\n+            } else {\n+                Ok(WorkItemResult::NeedsLTO(mtrans))\n+            }\n         }\n     }\n }\n \n-#[derive(Debug)]\n enum Message {\n     Token(io::Result<Acquired>),\n+    NeedsLTO {\n+        result: ModuleTranslation,\n+        worker_id: usize,\n+    },\n     Done {\n         result: Result<CompiledModule, ()>,\n         worker_id: usize,\n@@ -1146,6 +1232,7 @@ fn start_executing_work(tcx: TyCtxt,\n         each_linked_rlib_for_lto,\n         lto: sess.lto(),\n         no_landing_pads: sess.no_landing_pads(),\n+        save_temps: sess.opts.cg.save_temps,\n         opts: Arc::new(sess.opts.clone()),\n         time_passes: sess.time_passes(),\n         exported_symbols,\n@@ -1160,6 +1247,7 @@ fn start_executing_work(tcx: TyCtxt,\n         regular_module_config: modules_config,\n         metadata_module_config: metadata_config,\n         allocator_module_config: allocator_config,\n+        tm_factory: target_machine_factory(tcx.sess),\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen.\n@@ -1282,6 +1370,21 @@ fn start_executing_work(tcx: TyCtxt,\n     // and whenever we're done with that work we release the semaphore. In this\n     // manner we can ensure that the maximum number of parallel workers is\n     // capped at any one point in time.\n+    //\n+    // LTO and the coordinator thread\n+    // ------------------------------\n+    //\n+    // The final job the coordinator thread is responsible for is managing LTO\n+    // and how that works. When LTO is requested what we'll to is collect all\n+    // optimized LLVM modules into a local vector on the coordinator. Once all\n+    // modules have been translated and optimized we hand this to the `lto`\n+    // module for further optimization. The `lto` module will return back a list\n+    // of more modules to work on, which the coordinator will continue to spawn\n+    // work for.\n+    //\n+    // Each LLVM module is automatically sent back to the coordinator for LTO if\n+    // necessary. There's already optimizations in place to avoid sending work\n+    // back to the coordinator if LTO isn't requested.\n     return thread::spawn(move || {\n         // We pretend to be within the top-level LLVM time-passes task here:\n         set_time_depth(1);\n@@ -1304,6 +1407,8 @@ fn start_executing_work(tcx: TyCtxt,\n         let mut compiled_modules = vec![];\n         let mut compiled_metadata_module = None;\n         let mut compiled_allocator_module = None;\n+        let mut needs_lto = Vec::new();\n+        let mut started_lto = false;\n \n         // This flag tracks whether all items have gone through translations\n         let mut translation_done = false;\n@@ -1325,6 +1430,7 @@ fn start_executing_work(tcx: TyCtxt,\n         while !translation_done ||\n               work_items.len() > 0 ||\n               running > 0 ||\n+              needs_lto.len() > 0 ||\n               main_thread_worker_state != MainThreadWorkerState::Idle {\n \n             // While there are still CGUs to be translated, the coordinator has\n@@ -1348,13 +1454,34 @@ fn start_executing_work(tcx: TyCtxt,\n                             worker: get_worker_id(&mut free_worker_ids),\n                             .. cgcx.clone()\n                         };\n-                        maybe_start_llvm_timer(cgcx.config(item.mtrans.kind),\n+                        maybe_start_llvm_timer(cgcx.config(item.kind()),\n                                                &mut llvm_start_time);\n                         main_thread_worker_state = MainThreadWorkerState::LLVMing;\n                         spawn_work(cgcx, item);\n                     }\n                 }\n             } else {\n+                // If we've finished everything related to normal translation\n+                // then it must be the case that we've got some LTO work to do.\n+                // Perform the serial work here of figuring out what we're\n+                // going to LTO and then push a bunch of work items onto our\n+                // queue to do LTO\n+                if work_items.len() == 0 &&\n+                   running == 0 &&\n+                   main_thread_worker_state == MainThreadWorkerState::Idle {\n+                    assert!(!started_lto);\n+                    assert!(needs_lto.len() > 0);\n+                    started_lto = true;\n+                    let modules = mem::replace(&mut needs_lto, Vec::new());\n+                    for (work, cost) in generate_lto_work(&cgcx, modules) {\n+                        let insertion_index = work_items\n+                            .binary_search_by_key(&cost, |&(_, cost)| cost)\n+                            .unwrap_or_else(|e| e);\n+                        work_items.insert(insertion_index, (work, cost));\n+                        helper.request_token();\n+                    }\n+                }\n+\n                 // In this branch, we know that everything has been translated,\n                 // so it's just a matter of determining whether the implicit\n                 // Token is free to use for LLVM work.\n@@ -1365,7 +1492,7 @@ fn start_executing_work(tcx: TyCtxt,\n                                 worker: get_worker_id(&mut free_worker_ids),\n                                 .. cgcx.clone()\n                             };\n-                            maybe_start_llvm_timer(cgcx.config(item.mtrans.kind),\n+                            maybe_start_llvm_timer(cgcx.config(item.kind()),\n                                                    &mut llvm_start_time);\n                             main_thread_worker_state = MainThreadWorkerState::LLVMing;\n                             spawn_work(cgcx, item);\n@@ -1396,7 +1523,7 @@ fn start_executing_work(tcx: TyCtxt,\n             while work_items.len() > 0 && running < tokens.len() {\n                 let (item, _) = work_items.pop().unwrap();\n \n-                maybe_start_llvm_timer(cgcx.config(item.mtrans.kind),\n+                maybe_start_llvm_timer(cgcx.config(item.kind()),\n                                        &mut llvm_start_time);\n \n                 let cgcx = CodegenContext {\n@@ -1499,6 +1626,17 @@ fn start_executing_work(tcx: TyCtxt,\n                         }\n                     }\n                 }\n+                Message::NeedsLTO { result, worker_id } => {\n+                    assert!(!started_lto);\n+                    if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n+                        main_thread_worker_state = MainThreadWorkerState::Idle;\n+                    } else {\n+                        running -= 1;\n+                    }\n+\n+                    free_worker_ids.push(worker_id);\n+                    needs_lto.push(result);\n+                }\n                 Message::Done { result: Err(()), worker_id: _ } => {\n                     shared_emitter.fatal(\"aborting due to worker thread panic\");\n                     // Exit the coordinator thread\n@@ -1575,20 +1713,22 @@ fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n         // we exit.\n         struct Bomb {\n             coordinator_send: Sender<Box<Any + Send>>,\n-            result: Option<CompiledModule>,\n+            result: Option<WorkItemResult>,\n             worker_id: usize,\n         }\n         impl Drop for Bomb {\n             fn drop(&mut self) {\n-                let result = match self.result.take() {\n-                    Some(compiled_module) => Ok(compiled_module),\n-                    None => Err(())\n+                let worker_id = self.worker_id;\n+                let msg = match self.result.take() {\n+                    Some(WorkItemResult::Compiled(m)) => {\n+                        Message::Done { result: Ok(m), worker_id }\n+                    }\n+                    Some(WorkItemResult::NeedsLTO(m)) => {\n+                        Message::NeedsLTO { result: m, worker_id }\n+                    }\n+                    None => Message::Done { result: Err(()), worker_id }\n                 };\n-\n-                drop(self.coordinator_send.send(Box::new(Message::Done {\n-                    result,\n-                    worker_id: self.worker_id,\n-                })));\n+                drop(self.coordinator_send.send(Box::new(msg)));\n             }\n         }\n \n@@ -1612,10 +1752,11 @@ fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n         // we're done, which if `execute_work_item` failed is unlikely to be\n         // seen by the main thread, but hey we might as well try anyway.\n         bomb.result = {\n-            let _timing_guard = cgcx.time_graph\n-                                .as_ref()\n-                                .map(|tg| tg.start(time_graph::TimelineId(cgcx.worker),\n-                                                   LLVM_WORK_PACKAGE_KIND));\n+            let _timing_guard = cgcx.time_graph.as_ref().map(|tg| {\n+                tg.start(time_graph::TimelineId(cgcx.worker),\n+                         LLVM_WORK_PACKAGE_KIND,\n+                         &work.name())\n+            });\n             Some(execute_work_item(&cgcx, work).unwrap())\n         };\n     });\n@@ -1923,9 +2064,7 @@ impl OngoingCrateTranslation {\n             Ok(Message::TranslateItem) => {\n                 // Nothing to do\n             }\n-            Ok(message) => {\n-                panic!(\"unexpected message: {:?}\", message)\n-            }\n+            Ok(_) => panic!(\"unexpected message\"),\n             Err(_) => {\n                 // One of the LLVM threads must have panicked, fall through so\n                 // error handling can be reached.\n@@ -1937,10 +2076,7 @@ impl OngoingCrateTranslation {\n pub fn submit_translated_module_to_llvm(tcx: TyCtxt,\n                                         mtrans: ModuleTranslation,\n                                         cost: u64) {\n-    let llvm_work_item = WorkItem {\n-        mtrans,\n-        tm: TargetMachine(create_target_machine(tcx.sess)),\n-    };\n+    let llvm_work_item = WorkItem::Optimize(mtrans);\n     drop(tcx.tx_to_llvm_workers.send(Box::new(Message::TranslationDone {\n         llvm_work_item,\n         cost,"}, {"sha": "92119e411cde9207098d7f379784969bf6f77a80", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "patch": "@@ -31,7 +31,7 @@ use super::ModuleKind;\n use assert_module_sources::{self, Disposition};\n use back::link;\n use back::symbol_export;\n-use back::write::{self, OngoingCrateTranslation};\n+use back::write::{self, OngoingCrateTranslation, create_target_machine};\n use llvm::{ContextRef, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n use metadata;\n@@ -732,6 +732,7 @@ fn contains_null(s: &str) -> bool {\n }\n \n fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+                            llmod_id: &str,\n                             link_meta: &LinkMeta,\n                             exported_symbols: &NodeSet)\n                             -> (ContextRef, ModuleRef,\n@@ -741,7 +742,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     use flate2::write::DeflateEncoder;\n \n     let (metadata_llcx, metadata_llmod) = unsafe {\n-        context::create_context_and_module(tcx.sess, \"metadata\")\n+        context::create_context_and_module(tcx.sess, llmod_id)\n     };\n \n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n@@ -886,17 +887,20 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let shared_ccx = SharedCrateContext::new(tcx);\n     // Translate the metadata.\n+    let llmod_id = \"metadata\";\n     let (metadata_llcx, metadata_llmod, metadata, metadata_incr_hashes) =\n         time(tcx.sess.time_passes(), \"write metadata\", || {\n-            write_metadata(tcx, &link_meta, &exported_symbol_node_ids)\n+            write_metadata(tcx, llmod_id, &link_meta, &exported_symbol_node_ids)\n         });\n \n     let metadata_module = ModuleTranslation {\n         name: link::METADATA_MODULE_NAME.to_string(),\n+        llmod_id: llmod_id.to_string(),\n         symbol_name_hash: 0, // we always rebuild metadata, at least for now\n         source: ModuleSource::Translated(ModuleLlvm {\n             llcx: metadata_llcx,\n             llmod: metadata_llmod,\n+            tm: create_target_machine(tcx.sess),\n         }),\n         kind: ModuleKind::Metadata,\n     };\n@@ -935,8 +939,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         shared_ccx.tcx().collect_and_partition_translation_items(LOCAL_CRATE).1;\n     let codegen_units = (*codegen_units).clone();\n \n-    assert!(codegen_units.len() <= 1 || !tcx.sess.lto());\n-\n     let ongoing_translation = write::start_async_translation(\n         tcx,\n         time_graph.clone(),\n@@ -945,31 +947,23 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         rx);\n \n     // Translate an allocator shim, if any\n-    //\n-    // If LTO is enabled and we've got some previous LLVM module we translated\n-    // above, then we can just translate directly into that LLVM module. If not,\n-    // however, we need to create a separate module and trans into that. Note\n-    // that the separate translation is critical for the standard library where\n-    // the rlib's object file doesn't have allocator functions but the dylib\n-    // links in an object file that has allocator functions. When we're\n-    // compiling a final LTO artifact, though, there's no need to worry about\n-    // this as we're not working with this dual \"rlib/dylib\" functionality.\n-    let allocator_module = if tcx.sess.lto() {\n-        None\n-    } else if let Some(kind) = tcx.sess.allocator_kind.get() {\n+    let allocator_module = if let Some(kind) = tcx.sess.allocator_kind.get() {\n         unsafe {\n+            let llmod_id = \"allocator\";\n             let (llcx, llmod) =\n-                context::create_context_and_module(tcx.sess, \"allocator\");\n+                context::create_context_and_module(tcx.sess, llmod_id);\n             let modules = ModuleLlvm {\n                 llmod,\n                 llcx,\n+                tm: create_target_machine(tcx.sess),\n             };\n             time(tcx.sess.time_passes(), \"write allocator module\", || {\n                 allocator::trans(tcx, &modules, kind)\n             });\n \n             Some(ModuleTranslation {\n                 name: link::ALLOCATOR_MODULE_NAME.to_string(),\n+                llmod_id: llmod_id.to_string(),\n                 symbol_name_hash: 0, // we always rebuild allocator shims\n                 source: ModuleSource::Translated(modules),\n                 kind: ModuleKind::Allocator,\n@@ -1002,10 +996,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ongoing_translation.wait_for_signal_to_translate_item();\n         ongoing_translation.check_for_errors(tcx.sess);\n \n-        let _timing_guard = time_graph\n-            .as_ref()\n-            .map(|time_graph| time_graph.start(write::TRANS_WORKER_TIMELINE,\n-                                               write::TRANS_WORK_PACKAGE_KIND));\n+        let _timing_guard = time_graph.as_ref().map(|time_graph| {\n+            time_graph.start(write::TRANS_WORKER_TIMELINE,\n+                             write::TRANS_WORK_PACKAGE_KIND,\n+                             &format!(\"codegen {}\", cgu.name()))\n+        });\n         let start_time = Instant::now();\n         all_stats.extend(tcx.compile_codegen_unit(*cgu.name()));\n         total_trans_time += start_time.elapsed();\n@@ -1336,6 +1331,16 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let cgu_id = cgu.work_product_id();\n         let symbol_name_hash = cgu.compute_symbol_name_hash(tcx);\n \n+        // Append \".rs\" to LLVM module identifier.\n+        //\n+        // LLVM code generator emits a \".file filename\" directive\n+        // for ELF backends. Value of the \"filename\" is set as the\n+        // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n+        // crashes if the module identifier is same as other symbols\n+        // such as a function name in the module.\n+        // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n+        let llmod_id = format!(\"{}.rs\", cgu.name());\n+\n         // Check whether there is a previous work-product we can\n         // re-use.  Not only must the file exist, and the inputs not\n         // be dirty, but the hash of the symbols we will generate must\n@@ -1361,6 +1366,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if let Some(buf) = previous_work_product {\n             // Don't need to translate this module.\n             let module = ModuleTranslation {\n+                llmod_id: llmod_id,\n                 name: cgu_name,\n                 symbol_name_hash,\n                 source: ModuleSource::Preexisting(buf.clone()),\n@@ -1371,7 +1377,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Instantiate translation items without filling out definitions yet...\n         let scx = SharedCrateContext::new(tcx);\n-        let lcx = LocalCrateContext::new(&scx, cgu);\n+        let lcx = LocalCrateContext::new(&scx, cgu, &llmod_id);\n         let module = {\n             let ccx = CrateContext::new(&scx, &lcx);\n             let trans_items = ccx.codegen_unit()\n@@ -1423,20 +1429,9 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let llvm_module = ModuleLlvm {\n                 llcx: ccx.llcx(),\n                 llmod: ccx.llmod(),\n+                tm: create_target_machine(ccx.sess()),\n             };\n \n-            // In LTO mode we inject the allocator shim into the existing\n-            // module.\n-            if ccx.sess().lto() {\n-                if let Some(kind) = ccx.sess().allocator_kind.get() {\n-                    time(ccx.sess().time_passes(), \"write allocator module\", || {\n-                        unsafe {\n-                            allocator::trans(ccx.tcx(), &llvm_module, kind);\n-                        }\n-                    });\n-                }\n-            }\n-\n             // Adjust exported symbols for MSVC dllimport\n             if ccx.sess().target.target.options.is_like_msvc &&\n                ccx.sess().crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n@@ -1448,6 +1443,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 symbol_name_hash,\n                 source: ModuleSource::Translated(llvm_module),\n                 kind: ModuleKind::Regular,\n+                llmod_id,\n             }\n         };\n "}, {"sha": "1722d008a54c2c066a49c7ae193f3a098fc47b2f", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "patch": "@@ -320,19 +320,10 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n \n impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n     pub fn new(shared: &SharedCrateContext<'a, 'tcx>,\n-               codegen_unit: Arc<CodegenUnit<'tcx>>)\n+               codegen_unit: Arc<CodegenUnit<'tcx>>,\n+               llmod_id: &str)\n                -> LocalCrateContext<'a, 'tcx> {\n         unsafe {\n-            // Append \".rs\" to LLVM module identifier.\n-            //\n-            // LLVM code generator emits a \".file filename\" directive\n-            // for ELF backends. Value of the \"filename\" is set as the\n-            // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n-            // crashes if the module identifier is same as other symbols\n-            // such as a function name in the module.\n-            // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-            let llmod_id = format!(\"{}.rs\", codegen_unit.name());\n-\n             let (llcx, llmod) = create_context_and_module(&shared.tcx.sess,\n                                                           &llmod_id[..]);\n "}, {"sha": "c38b90dcf4f62dabbc72e709f7f1b2e100aa19cf", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "patch": "@@ -68,17 +68,26 @@ pub use base::trans_crate;\n pub use metadata::LlvmMetadataLoader;\n pub use llvm_util::{init, target_features, print_version, print_passes, print, enable_llvm_debug};\n \n+use std::any::Any;\n+use std::path::PathBuf;\n use std::rc::Rc;\n+use std::sync::mpsc;\n \n+use rustc::dep_graph::DepGraph;\n use rustc::hir::def_id::CrateNum;\n+use rustc::middle::cstore::MetadataLoader;\n use rustc::middle::cstore::{NativeLibrary, CrateSource, LibSource};\n+use rustc::session::Session;\n+use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::ty::maps::Providers;\n+use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n \n mod diagnostics;\n \n pub mod back {\n     mod archive;\n+    mod bytecode;\n     mod command;\n     pub(crate) mod linker;\n     pub mod link;\n@@ -138,14 +147,6 @@ mod type_;\n mod type_of;\n mod value;\n \n-use std::sync::mpsc;\n-use std::any::Any;\n-use rustc::ty::{self, TyCtxt};\n-use rustc::session::Session;\n-use rustc::session::config::OutputFilenames;\n-use rustc::middle::cstore::MetadataLoader;\n-use rustc::dep_graph::DepGraph;\n-\n pub struct LlvmTransCrate(());\n \n impl LlvmTransCrate {\n@@ -202,63 +203,62 @@ pub struct ModuleTranslation {\n     /// something unique to this crate (e.g., a module path) as well\n     /// as the crate name and disambiguator.\n     name: String,\n+    llmod_id: String,\n     symbol_name_hash: u64,\n     pub source: ModuleSource,\n     pub kind: ModuleKind,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum ModuleKind {\n     Regular,\n     Metadata,\n     Allocator,\n }\n \n impl ModuleTranslation {\n-    pub fn into_compiled_module(self, emit_obj: bool, emit_bc: bool) -> CompiledModule {\n+    pub fn llvm(&self) -> Option<&ModuleLlvm> {\n+        match self.source {\n+            ModuleSource::Translated(ref llvm) => Some(llvm),\n+            ModuleSource::Preexisting(_) => None,\n+        }\n+    }\n+\n+    pub fn into_compiled_module(self,\n+                                emit_obj: bool,\n+                                emit_bc: bool,\n+                                outputs: &OutputFilenames) -> CompiledModule {\n         let pre_existing = match self.source {\n             ModuleSource::Preexisting(_) => true,\n             ModuleSource::Translated(_) => false,\n         };\n+        let object = outputs.temp_path(OutputType::Object, Some(&self.name));\n \n         CompiledModule {\n+            llmod_id: self.llmod_id,\n             name: self.name.clone(),\n             kind: self.kind,\n             symbol_name_hash: self.symbol_name_hash,\n             pre_existing,\n             emit_obj,\n             emit_bc,\n-        }\n-    }\n-}\n-\n-impl Drop for ModuleTranslation {\n-    fn drop(&mut self) {\n-        match self.source {\n-            ModuleSource::Preexisting(_) => {\n-                // Nothing to dispose.\n-            },\n-            ModuleSource::Translated(llvm) => {\n-                unsafe {\n-                    llvm::LLVMDisposeModule(llvm.llmod);\n-                    llvm::LLVMContextDispose(llvm.llcx);\n-                }\n-            },\n+            object,\n         }\n     }\n }\n \n #[derive(Debug)]\n pub struct CompiledModule {\n     pub name: String,\n+    pub llmod_id: String,\n+    pub object: PathBuf,\n     pub kind: ModuleKind,\n     pub symbol_name_hash: u64,\n     pub pre_existing: bool,\n     pub emit_obj: bool,\n     pub emit_bc: bool,\n }\n \n-#[derive(Clone)]\n pub enum ModuleSource {\n     /// Copy the `.o` files or whatever from the incr. comp. directory.\n     Preexisting(WorkProduct),\n@@ -267,14 +267,25 @@ pub enum ModuleSource {\n     Translated(ModuleLlvm),\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Debug)]\n pub struct ModuleLlvm {\n     llcx: llvm::ContextRef,\n     pub llmod: llvm::ModuleRef,\n+    tm: llvm::TargetMachineRef,\n }\n \n-unsafe impl Send for ModuleTranslation { }\n-unsafe impl Sync for ModuleTranslation { }\n+unsafe impl Send for ModuleLlvm { }\n+unsafe impl Sync for ModuleLlvm { }\n+\n+impl Drop for ModuleLlvm {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMDisposeModule(self.llmod);\n+            llvm::LLVMContextDispose(self.llcx);\n+            llvm::LLVMRustDisposeTargetMachine(self.tm);\n+        }\n+    }\n+}\n \n pub struct CrateTranslation {\n     pub crate_name: Symbol,"}, {"sha": "ec57af888e5f2f13ca117f0af01a00ef16831bf4", "filename": "src/librustc_trans/time_graph.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Ftime_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Flibrustc_trans%2Ftime_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftime_graph.rs?ref=ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "patch": "@@ -16,14 +16,15 @@ use std::io::prelude::*;\n use std::fs::File;\n \n const OUTPUT_WIDTH_IN_PX: u64 = 1000;\n-const TIME_LINE_HEIGHT_IN_PX: u64 = 7;\n-const TIME_LINE_HEIGHT_STRIDE_IN_PX: usize = 10;\n+const TIME_LINE_HEIGHT_IN_PX: u64 = 20;\n+const TIME_LINE_HEIGHT_STRIDE_IN_PX: usize = 30;\n \n #[derive(Clone)]\n struct Timing {\n     start: Instant,\n     end: Instant,\n     work_package_kind: WorkPackageKind,\n+    name: String,\n }\n \n #[derive(Clone, Copy, Hash, Eq, PartialEq, Debug)]\n@@ -32,7 +33,7 @@ pub struct TimelineId(pub usize);\n #[derive(Clone)]\n struct PerThread {\n     timings: Vec<Timing>,\n-    open_work_package: Option<(Instant, WorkPackageKind)>,\n+    open_work_package: Option<(Instant, WorkPackageKind, String)>,\n }\n \n #[derive(Clone)]\n@@ -66,7 +67,8 @@ impl TimeGraph {\n \n     pub fn start(&self,\n                  timeline: TimelineId,\n-                 work_package_kind: WorkPackageKind) -> RaiiToken {\n+                 work_package_kind: WorkPackageKind,\n+                 name: &str) -> RaiiToken {\n         {\n             let mut table = self.data.lock().unwrap();\n \n@@ -76,7 +78,7 @@ impl TimeGraph {\n             });\n \n             assert!(data.open_work_package.is_none());\n-            data.open_work_package = Some((Instant::now(), work_package_kind));\n+            data.open_work_package = Some((Instant::now(), work_package_kind, name.to_string()));\n         }\n \n         RaiiToken {\n@@ -92,17 +94,16 @@ impl TimeGraph {\n         let mut table = self.data.lock().unwrap();\n         let data = table.get_mut(&timeline).unwrap();\n \n-        if let Some((start, work_package_kind)) = data.open_work_package {\n+        if let Some((start, work_package_kind, name)) = data.open_work_package.take() {\n             data.timings.push(Timing {\n                 start,\n                 end,\n                 work_package_kind,\n+                name,\n             });\n         } else {\n             bug!(\"end timing without start?\")\n         }\n-\n-        data.open_work_package = None;\n     }\n \n     pub fn dump(&self, output_filename: &str) {\n@@ -148,16 +149,18 @@ impl TimeGraph {\n                 let colors = span.work_package_kind.0;\n \n                 writeln!(file, \"<div style='position:absolute; \\\n+                                            overflow:hidden; \\\n                                             top:{}px; \\\n                                             left:{}px; \\\n                                             width:{}px; \\\n                                             height:{}px; \\\n-                                            background:{};'></div>\",\n+                                            background:{};'>{}</div>\",\n                     line_top,\n                     start,\n                     end - start,\n                     TIME_LINE_HEIGHT_IN_PX,\n-                    colors[color % colors.len()]\n+                    colors[color % colors.len()],\n+                    span.name,\n                     ).unwrap();\n \n                 color += 1;"}, {"sha": "bc616f648815f14ff012840a67faac3288e78019", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "patch": "@@ -15,6 +15,7 @@\n #include \"llvm/IR/Instructions.h\"\n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/ObjectFile.h\"\n+#include \"llvm/Bitcode/BitcodeWriterPass.h\"\n \n #include \"llvm/IR/CallSite.h\"\n \n@@ -891,6 +892,23 @@ extern \"C\" bool LLVMRustLinkInExternalBitcode(LLVMModuleRef DstRef, char *BC,\n   return true;\n }\n \n+extern \"C\" bool LLVMRustLinkInParsedExternalBitcode(\n+    LLVMModuleRef DstRef, LLVMModuleRef SrcRef) {\n+#if LLVM_VERSION_GE(4, 0)\n+  Module *Dst = unwrap(DstRef);\n+  std::unique_ptr<Module> Src(unwrap(SrcRef));\n+\n+  if (Linker::linkModules(*Dst, std::move(Src))) {\n+    LLVMRustSetLastError(\"failed to link modules\");\n+    return false;\n+  }\n+  return true;\n+#else\n+  LLVMRustSetLastError(\"can't link parsed modules on this LLVM\");\n+  return false;\n+#endif\n+}\n+\n // Note that the two following functions look quite similar to the\n // LLVMGetSectionName function. Sadly, it appears that this function only\n // returns a char* pointer, which isn't guaranteed to be null-terminated. The\n@@ -1403,3 +1421,47 @@ extern \"C\" void LLVMRustSetVisibility(LLVMValueRef V,\n                                       LLVMRustVisibility RustVisibility) {\n   LLVMSetVisibility(V, fromRust(RustVisibility));\n }\n+\n+struct LLVMRustModuleBuffer {\n+  std::string data;\n+};\n+\n+extern \"C\" LLVMRustModuleBuffer*\n+LLVMRustModuleBufferCreate(LLVMModuleRef M) {\n+  auto Ret = llvm::make_unique<LLVMRustModuleBuffer>();\n+  {\n+    raw_string_ostream OS(Ret->data);\n+    {\n+      legacy::PassManager PM;\n+      PM.add(createBitcodeWriterPass(OS));\n+      PM.run(*unwrap(M));\n+    }\n+  }\n+  return Ret.release();\n+}\n+\n+extern \"C\" void\n+LLVMRustModuleBufferFree(LLVMRustModuleBuffer *Buffer) {\n+  delete Buffer;\n+}\n+\n+extern \"C\" const void*\n+LLVMRustModuleBufferPtr(const LLVMRustModuleBuffer *Buffer) {\n+  return Buffer->data.data();\n+}\n+\n+extern \"C\" size_t\n+LLVMRustModuleBufferLen(const LLVMRustModuleBuffer *Buffer) {\n+  return Buffer->data.length();\n+}\n+\n+extern \"C\" uint64_t\n+LLVMRustModuleCost(LLVMModuleRef M) {\n+  Module &Mod = *unwrap(M);\n+  uint64_t cost = 0;\n+  for (auto &F : Mod.functions()) {\n+    (void)F;\n+    cost += 1;\n+  }\n+  return cost;\n+}"}, {"sha": "bed675cee5604ed16f4626d91f0ed01829e886af", "filename": "src/test/run-pass/lto-many-codegen-units.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Ftest%2Frun-pass%2Flto-many-codegen-units.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded38dbfc258f8e253ab61d1bca08b21efa2bf3d/src%2Ftest%2Frun-pass%2Flto-many-codegen-units.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flto-many-codegen-units.rs?ref=ded38dbfc258f8e253ab61d1bca08b21efa2bf3d", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C lto -C codegen-units=8\n+// no-prefer-dynamic\n+\n+fn main() {\n+}"}]}