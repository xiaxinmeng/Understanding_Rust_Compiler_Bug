{"sha": "394fa192a94bf6fed793ac3f8ceacc7d35b55319", "node_id": "C_kwDOAAsO6NoAKDM5NGZhMTkyYTk0YmY2ZmVkNzkzYWMzZjhjZWFjYzdkMzViNTUzMTk", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-02-05T02:26:33Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-02-05T02:48:17Z"}, "message": "rustc_parse: remove huge error imports", "tree": {"sha": "9370f09776d4e8cd50050de56434583554d861cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9370f09776d4e8cd50050de56434583554d861cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/394fa192a94bf6fed793ac3f8ceacc7d35b55319", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/394fa192a94bf6fed793ac3f8ceacc7d35b55319", "html_url": "https://github.com/rust-lang/rust/commit/394fa192a94bf6fed793ac3f8ceacc7d35b55319", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/394fa192a94bf6fed793ac3f8ceacc7d35b55319/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4a20abc489f5aa45b3aef17deec8e518d94153d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4a20abc489f5aa45b3aef17deec8e518d94153d", "html_url": "https://github.com/rust-lang/rust/commit/b4a20abc489f5aa45b3aef17deec8e518d94153d"}], "stats": {"total": 232, "additions": 111, "deletions": 121}, "files": [{"sha": "473a5bb8cb8c15fddf8ade2fcd4943f1cdbe495b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 88, "deletions": 98, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/394fa192a94bf6fed793ac3f8ceacc7d35b55319/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/394fa192a94bf6fed793ac3f8ceacc7d35b55319/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=394fa192a94bf6fed793ac3f8ceacc7d35b55319", "patch": "@@ -5,26 +5,7 @@ use super::{\n     AttrWrapper, BlockMode, ClosureSpans, ForceCollect, Parser, PathStyle, Restrictions,\n     SemiColonMode, SeqSep, TokenExpectType, TokenType, TrailingToken,\n };\n-use crate::errors::{\n-    ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, AsyncBlockIn2015,\n-    AsyncMoveOrderIncorrect, BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct,\n-    ComparisonInterpretedAsGeneric, ComparisonOrShiftInterpretedAsGenericSugg,\n-    DoCatchSyntaxRemoved, DotDotDot, EqFieldInit, ExpectedElseBlock, ExpectedEqForLetExpr,\n-    ExpectedExpressionFoundLet, FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart,\n-    FoundExprWouldBeStmt, HelpUseLatestEdition, IfExpressionLetSomeSub,\n-    IfExpressionMissingCondition, IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub,\n-    InvalidBlockMacroSegment, InvalidComparisonOperator, InvalidComparisonOperatorSub,\n-    InvalidInterpolatedExpression, InvalidLiteralSuffixOnTupleIndex, InvalidLogicalOperator,\n-    InvalidLogicalOperatorSub, LabeledLoopInBreak, LeadingPlusNotSupported, LeftArrowOperator,\n-    LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath, MalformedLoopLabel,\n-    MatchArmBodyWithoutBraces, MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm,\n-    MissingDotDot, MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray,\n-    NoFieldsForFnCall, NotAsNegationOperator, NotAsNegationOperatorSub,\n-    OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n-    RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric, StructLiteralNotAllowedHere,\n-    StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator, UnexpectedIfWithIf,\n-    UnexpectedTokenAfterLabel, UnexpectedTokenAfterLabelSugg, WrapExpressionInParentheses,\n-};\n+use crate::errors;\n use crate::maybe_recover_from_interpolated_ty_qpath;\n use core::mem;\n use rustc_ast::ptr::P;\n@@ -244,10 +225,10 @@ impl<'a> Parser<'a> {\n                 }\n                 .into();\n                 let invalid = format!(\"{}=\", &sugg);\n-                self.sess.emit_err(InvalidComparisonOperator {\n+                self.sess.emit_err(errors::InvalidComparisonOperator {\n                     span: sp,\n                     invalid: invalid.clone(),\n-                    sub: InvalidComparisonOperatorSub::Correctable {\n+                    sub: errors::InvalidComparisonOperatorSub::Correctable {\n                         span: sp,\n                         invalid,\n                         correct: sugg,\n@@ -262,10 +243,10 @@ impl<'a> Parser<'a> {\n                 && self.prev_token.span.hi() == self.token.span.lo()\n             {\n                 let sp = op.span.to(self.token.span);\n-                self.sess.emit_err(InvalidComparisonOperator {\n+                self.sess.emit_err(errors::InvalidComparisonOperator {\n                     span: sp,\n                     invalid: \"<>\".into(),\n-                    sub: InvalidComparisonOperatorSub::Correctable {\n+                    sub: errors::InvalidComparisonOperatorSub::Correctable {\n                         span: sp,\n                         invalid: \"<>\".into(),\n                         correct: \"!=\".into(),\n@@ -280,10 +261,10 @@ impl<'a> Parser<'a> {\n                 && self.prev_token.span.hi() == self.token.span.lo()\n             {\n                 let sp = op.span.to(self.token.span);\n-                self.sess.emit_err(InvalidComparisonOperator {\n+                self.sess.emit_err(errors::InvalidComparisonOperator {\n                     span: sp,\n                     invalid: \"<=>\".into(),\n-                    sub: InvalidComparisonOperatorSub::Spaceship(sp),\n+                    sub: errors::InvalidComparisonOperatorSub::Spaceship(sp),\n                 });\n                 self.bump();\n             }\n@@ -420,7 +401,7 @@ impl<'a> Parser<'a> {\n     /// but the next token implies this should be parsed as an expression.\n     /// For example: `if let Some(x) = x { x } else { 0 } / 2`.\n     fn error_found_expr_would_be_stmt(&self, lhs: &Expr) {\n-        self.sess.emit_err(FoundExprWouldBeStmt {\n+        self.sess.emit_err(errors::FoundExprWouldBeStmt {\n             span: self.token.span,\n             token: self.token.clone(),\n             suggestion: ExprParenthesesNeeded::surrounding(lhs.span),\n@@ -447,18 +428,18 @@ impl<'a> Parser<'a> {\n             }\n             (Some(op), _) => (op, self.token.span),\n             (None, Some((Ident { name: sym::and, span }, false))) if self.may_recover() => {\n-                self.sess.emit_err(InvalidLogicalOperator {\n+                self.sess.emit_err(errors::InvalidLogicalOperator {\n                     span: self.token.span,\n                     incorrect: \"and\".into(),\n-                    sub: InvalidLogicalOperatorSub::Conjunction(self.token.span),\n+                    sub: errors::InvalidLogicalOperatorSub::Conjunction(self.token.span),\n                 });\n                 (AssocOp::LAnd, span)\n             }\n             (None, Some((Ident { name: sym::or, span }, false))) if self.may_recover() => {\n-                self.sess.emit_err(InvalidLogicalOperator {\n+                self.sess.emit_err(errors::InvalidLogicalOperator {\n                     span: self.token.span,\n                     incorrect: \"or\".into(),\n-                    sub: InvalidLogicalOperatorSub::Disjunction(self.token.span),\n+                    sub: errors::InvalidLogicalOperatorSub::Disjunction(self.token.span),\n                 });\n                 (AssocOp::LOr, span)\n             }\n@@ -581,8 +562,11 @@ impl<'a> Parser<'a> {\n             }\n             // `+lit`\n             token::BinOp(token::Plus) if this.look_ahead(1, |tok| tok.is_numeric_lit()) => {\n-                let mut err =\n-                    LeadingPlusNotSupported { span: lo, remove_plus: None, add_parentheses: None };\n+                let mut err = errors::LeadingPlusNotSupported {\n+                    span: lo,\n+                    remove_plus: None,\n+                    add_parentheses: None,\n+                };\n \n                 // a block on the LHS might have been intended to be an expression instead\n                 if let Some(sp) = this.sess.ambiguous_block_expr_parse.borrow().get(&lo) {\n@@ -633,7 +617,7 @@ impl<'a> Parser<'a> {\n \n     /// Recover on `~expr` in favor of `!expr`.\n     fn recover_tilde_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n-        self.sess.emit_err(TildeAsUnaryOperator(lo));\n+        self.sess.emit_err(errors::TildeAsUnaryOperator(lo));\n \n         self.parse_unary_expr(lo, UnOp::Not)\n     }\n@@ -661,14 +645,14 @@ impl<'a> Parser<'a> {\n         let negated_token = self.look_ahead(1, |t| t.clone());\n \n         let sub_diag = if negated_token.is_numeric_lit() {\n-            NotAsNegationOperatorSub::SuggestNotBitwise\n+            errors::NotAsNegationOperatorSub::SuggestNotBitwise\n         } else if negated_token.is_bool_lit() {\n-            NotAsNegationOperatorSub::SuggestNotLogical\n+            errors::NotAsNegationOperatorSub::SuggestNotLogical\n         } else {\n-            NotAsNegationOperatorSub::SuggestNotDefault\n+            errors::NotAsNegationOperatorSub::SuggestNotDefault\n         };\n \n-        self.sess.emit_err(NotAsNegationOperator {\n+        self.sess.emit_err(errors::NotAsNegationOperator {\n             negated: negated_token.span,\n             negated_desc: super::token_descr(&negated_token),\n             // Span the `not` plus trailing whitespace to avoid\n@@ -739,7 +723,7 @@ impl<'a> Parser<'a> {\n                         match self.parse_labeled_expr(label, false) {\n                             Ok(expr) => {\n                                 type_err.cancel();\n-                                self.sess.emit_err(MalformedLoopLabel {\n+                                self.sess.emit_err(errors::MalformedLoopLabel {\n                                     span: label.ident.span,\n                                     correct_label: label.ident,\n                                 });\n@@ -764,20 +748,22 @@ impl<'a> Parser<'a> {\n                         );\n \n                         let args_span = self.look_ahead(1, |t| t.span).to(span_after_type);\n-                        let suggestion = ComparisonOrShiftInterpretedAsGenericSugg {\n+                        let suggestion = errors::ComparisonOrShiftInterpretedAsGenericSugg {\n                             left: expr.span.shrink_to_lo(),\n                             right: expr.span.shrink_to_hi(),\n                         };\n \n                         match self.token.kind {\n-                            token::Lt => self.sess.emit_err(ComparisonInterpretedAsGeneric {\n-                                comparison: self.token.span,\n-                                r#type: path,\n-                                args: args_span,\n-                                suggestion,\n-                            }),\n+                            token::Lt => {\n+                                self.sess.emit_err(errors::ComparisonInterpretedAsGeneric {\n+                                    comparison: self.token.span,\n+                                    r#type: path,\n+                                    args: args_span,\n+                                    suggestion,\n+                                })\n+                            }\n                             token::BinOp(token::Shl) => {\n-                                self.sess.emit_err(ShiftInterpretedAsGeneric {\n+                                self.sess.emit_err(errors::ShiftInterpretedAsGeneric {\n                                     shift: self.token.span,\n                                     r#type: path,\n                                     args: args_span,\n@@ -918,7 +904,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_remove_borrow_lifetime(&self, span: Span, lt_span: Span) {\n-        self.sess.emit_err(LifetimeInBorrowExpression { span, lifetime_span: lt_span });\n+        self.sess.emit_err(errors::LifetimeInBorrowExpression { span, lifetime_span: lt_span });\n     }\n \n     /// Parse `mut?` or `raw [ const | mut ]`.\n@@ -1212,14 +1198,14 @@ impl<'a> Parser<'a> {\n                         let close_paren = self.prev_token.span;\n                         let span = lo.to(self.prev_token.span);\n                         if !fields.is_empty() {\n-                            let mut replacement_err = ParenthesesWithStructFields {\n+                            let mut replacement_err = errors::ParenthesesWithStructFields {\n                                 span,\n                                 r#type: path,\n-                                braces_for_struct: BracesForStructLiteral {\n+                                braces_for_struct: errors::BracesForStructLiteral {\n                                     first: open_paren,\n                                     second: close_paren,\n                                 },\n-                                no_fields_for_fn: NoFieldsForFnCall {\n+                                no_fields_for_fn: errors::NoFieldsForFnCall {\n                                     fields: fields\n                                         .into_iter()\n                                         .map(|field| field.span.until(field.expr.span))\n@@ -1286,7 +1272,7 @@ impl<'a> Parser<'a> {\n         } else {\n             // Field access `expr.f`\n             if let Some(args) = seg.args {\n-                self.sess.emit_err(FieldExpressionWithGeneric(args.span()));\n+                self.sess.emit_err(errors::FieldExpressionWithGeneric(args.span()));\n             }\n \n             let span = lo.to(self.prev_token.span);\n@@ -1500,7 +1486,7 @@ impl<'a> Parser<'a> {\n         let (span, kind) = if self.eat(&token::Not) {\n             // MACRO INVOCATION expression\n             if qself.is_some() {\n-                self.sess.emit_err(MacroInvocationWithQualifiedPath(path.span));\n+                self.sess.emit_err(errors::MacroInvocationWithQualifiedPath(path.span));\n             }\n             let lo = path.span;\n             let mac = P(MacCall {\n@@ -1550,7 +1536,7 @@ impl<'a> Parser<'a> {\n         {\n             let (lit, _) =\n                 self.recover_unclosed_char(label_.ident, Parser::mk_token_lit_char, |self_| {\n-                    self_.sess.create_err(UnexpectedTokenAfterLabel {\n+                    self_.sess.create_err(errors::UnexpectedTokenAfterLabel {\n                         span: self_.token.span,\n                         remove_label: None,\n                         enclose_in_block: None,\n@@ -1562,15 +1548,15 @@ impl<'a> Parser<'a> {\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n             // We're probably inside of a `Path<'a>` that needs a turbofish\n-            self.sess.emit_err(UnexpectedTokenAfterLabel {\n+            self.sess.emit_err(errors::UnexpectedTokenAfterLabel {\n                 span: self.token.span,\n                 remove_label: None,\n                 enclose_in_block: None,\n             });\n             consume_colon = false;\n             Ok(self.mk_expr_err(lo))\n         } else {\n-            let mut err = UnexpectedTokenAfterLabel {\n+            let mut err = errors::UnexpectedTokenAfterLabel {\n                 span: self.token.span,\n                 remove_label: None,\n                 enclose_in_block: None,\n@@ -1606,7 +1592,7 @@ impl<'a> Parser<'a> {\n                     return expr;\n                 }\n \n-                err.enclose_in_block = Some(UnexpectedTokenAfterLabelSugg {\n+                err.enclose_in_block = Some(errors::UnexpectedTokenAfterLabelSugg {\n                     left: span.shrink_to_lo(),\n                     right: span.shrink_to_hi(),\n                 });\n@@ -1622,7 +1608,7 @@ impl<'a> Parser<'a> {\n         }?;\n \n         if !ate_colon && consume_colon {\n-            self.sess.emit_err(RequireColonAfterLabeledExpression {\n+            self.sess.emit_err(errors::RequireColonAfterLabeledExpression {\n                 span: expr.span,\n                 label: lo,\n                 label_end: lo.shrink_to_hi(),\n@@ -1671,7 +1657,7 @@ impl<'a> Parser<'a> {\n         self.bump(); // `catch`\n \n         let span = lo.to(self.prev_token.span);\n-        self.sess.emit_err(DoCatchSyntaxRemoved { span });\n+        self.sess.emit_err(errors::DoCatchSyntaxRemoved { span });\n \n         self.parse_try_block(lo)\n     }\n@@ -1719,9 +1705,9 @@ impl<'a> Parser<'a> {\n             // The value expression can be a labeled loop, see issue #86948, e.g.:\n             // `loop { break 'label: loop { break 'label 42; }; }`\n             let lexpr = self.parse_labeled_expr(label, true)?;\n-            self.sess.emit_err(LabeledLoopInBreak {\n+            self.sess.emit_err(errors::LabeledLoopInBreak {\n                 span: lexpr.span,\n-                sub: WrapExpressionInParentheses {\n+                sub: errors::WrapExpressionInParentheses {\n                     left: lexpr.span.shrink_to_lo(),\n                     right: lexpr.span.shrink_to_hi(),\n                 },\n@@ -1841,7 +1827,7 @@ impl<'a> Parser<'a> {\n             };\n             if let Some(expr) = expr {\n                 if matches!(expr.kind, ExprKind::Err) {\n-                    let mut err = InvalidInterpolatedExpression { span: self.token.span }\n+                    let mut err = errors::InvalidInterpolatedExpression { span: self.token.span }\n                         .into_diagnostic(&self.sess.span_diagnostic);\n                     err.downgrade_to_delayed_bug();\n                     return Err(err);\n@@ -1902,7 +1888,7 @@ impl<'a> Parser<'a> {\n             });\n             if let Some(token) = &recovered {\n                 self.bump();\n-                self.sess.emit_err(FloatLiteralRequiresIntegerPart {\n+                self.sess.emit_err(errors::FloatLiteralRequiresIntegerPart {\n                     span: token.span,\n                     correct: pprust::token_to_string(token).into_owned(),\n                 });\n@@ -1963,13 +1949,17 @@ impl<'a> Parser<'a> {\n         if [sym::i32, sym::u32, sym::isize, sym::usize].contains(&suffix) {\n             // #59553: warn instead of reject out of hand to allow the fix to percolate\n             // through the ecosystem when people fix their macros\n-            self.sess.emit_warning(InvalidLiteralSuffixOnTupleIndex {\n+            self.sess.emit_warning(errors::InvalidLiteralSuffixOnTupleIndex {\n                 span,\n                 suffix,\n                 exception: Some(()),\n             });\n         } else {\n-            self.sess.emit_err(InvalidLiteralSuffixOnTupleIndex { span, suffix, exception: None });\n+            self.sess.emit_err(errors::InvalidLiteralSuffixOnTupleIndex {\n+                span,\n+                suffix,\n+                exception: None,\n+            });\n         }\n     }\n \n@@ -2003,9 +1993,9 @@ impl<'a> Parser<'a> {\n         let mut snapshot = self.create_snapshot_for_diagnostic();\n         match snapshot.parse_array_or_repeat_expr(Delimiter::Brace) {\n             Ok(arr) => {\n-                self.sess.emit_err(ArrayBracketsInsteadOfSpaces {\n+                self.sess.emit_err(errors::ArrayBracketsInsteadOfSpaces {\n                     span: arr.span,\n-                    sub: ArrayBracketsInsteadOfSpacesSugg {\n+                    sub: errors::ArrayBracketsInsteadOfSpacesSugg {\n                         left: lo,\n                         right: snapshot.prev_token.span,\n                     },\n@@ -2051,7 +2041,7 @@ impl<'a> Parser<'a> {\n                         .span_to_snippet(snapshot.token.span)\n                         .map_or(false, |snippet| snippet == \"]\") =>\n                 {\n-                    return Err(MissingSemicolonBeforeArray {\n+                    return Err(errors::MissingSemicolonBeforeArray {\n                         open_delim: open_delim_span,\n                         semicolon: prev_span.shrink_to_hi(),\n                     }.into_diagnostic(&self.sess.span_diagnostic));\n@@ -2077,7 +2067,7 @@ impl<'a> Parser<'a> {\n         }\n \n         if self.token.is_whole_block() {\n-            self.sess.emit_err(InvalidBlockMacroSegment {\n+            self.sess.emit_err(errors::InvalidBlockMacroSegment {\n                 span: self.token.span,\n                 context: lo.to(self.token.span),\n             });\n@@ -2181,7 +2171,7 @@ impl<'a> Parser<'a> {\n             // Check for `move async` and recover\n             if self.check_keyword(kw::Async) {\n                 let move_async_span = self.token.span.with_lo(self.prev_token.span.data().lo);\n-                Err(AsyncMoveOrderIncorrect { span: move_async_span }\n+                Err(errors::AsyncMoveOrderIncorrect { span: move_async_span }\n                     .into_diagnostic(&self.sess.span_diagnostic))\n             } else {\n                 Ok(CaptureBy::Value)\n@@ -2259,17 +2249,17 @@ impl<'a> Parser<'a> {\n             let block = match &mut cond.kind {\n                 ExprKind::Binary(Spanned { span: binop_span, .. }, _, right)\n                     if let ExprKind::Block(_, None) = right.kind => {\n-                        self.sess.emit_err(IfExpressionMissingThenBlock {\n+                        self.sess.emit_err(errors::IfExpressionMissingThenBlock {\n                             if_span: lo,\n                             missing_then_block_sub:\n-                                IfExpressionMissingThenBlockSub::UnfinishedCondition(cond_span.shrink_to_lo().to(*binop_span)),\n+                                errors::IfExpressionMissingThenBlockSub::UnfinishedCondition(cond_span.shrink_to_lo().to(*binop_span)),\n                                 let_else_sub: None,\n \n                         });\n                         std::mem::replace(right, this.mk_expr_err(binop_span.shrink_to_hi()))\n                     },\n                 ExprKind::Block(_, None) => {\n-                    self.sess.emit_err(IfExpressionMissingCondition {\n+                    self.sess.emit_err(errors::IfExpressionMissingCondition {\n                         if_span: lo.shrink_to_hi(),\n                         block_span: self.sess.source_map().start_point(cond_span),\n                     });\n@@ -2291,11 +2281,11 @@ impl<'a> Parser<'a> {\n                 block\n             } else {\n                 let let_else_sub = matches!(cond.kind, ExprKind::Let(..))\n-                    .then(|| IfExpressionLetSomeSub { if_span: lo.until(cond_span) });\n+                    .then(|| errors::IfExpressionLetSomeSub { if_span: lo.until(cond_span) });\n \n-                self.sess.emit_err(IfExpressionMissingThenBlock {\n+                self.sess.emit_err(errors::IfExpressionMissingThenBlock {\n                     if_span: lo,\n-                    missing_then_block_sub: IfExpressionMissingThenBlockSub::AddThenBlock(\n+                    missing_then_block_sub: errors::IfExpressionMissingThenBlockSub::AddThenBlock(\n                         cond_span.shrink_to_hi(),\n                     ),\n                     let_else_sub,\n@@ -2351,7 +2341,7 @@ impl<'a> Parser<'a> {\n             TokenKind::AndAnd | TokenKind::Ident(kw::If, _) | TokenKind::Ident(kw::While, _)\n         );\n         if !self.restrictions.contains(Restrictions::ALLOW_LET) || not_in_chain {\n-            self.sess.emit_err(ExpectedExpressionFoundLet { span: self.token.span });\n+            self.sess.emit_err(errors::ExpectedExpressionFoundLet { span: self.token.span });\n         }\n \n         self.bump(); // Eat `let` token\n@@ -2363,7 +2353,7 @@ impl<'a> Parser<'a> {\n             CommaRecoveryMode::LikelyTuple,\n         )?;\n         if self.token == token::EqEq {\n-            self.sess.emit_err(ExpectedEqForLetExpr {\n+            self.sess.emit_err(errors::ExpectedEqForLetExpr {\n                 span: self.token.span,\n                 sugg_span: self.token.span,\n             });\n@@ -2398,7 +2388,7 @@ impl<'a> Parser<'a> {\n                     if self.check(&TokenKind::OpenDelim(Delimiter::Brace))\n                         && classify::expr_requires_semi_to_be_stmt(&cond) =>\n                 {\n-                    self.sess.emit_err(ExpectedElseBlock {\n+                    self.sess.emit_err(errors::ExpectedElseBlock {\n                         first_tok_span,\n                         first_tok,\n                         else_span,\n@@ -2438,7 +2428,7 @@ impl<'a> Parser<'a> {\n             [x0 @ xn] | [x0, .., xn] => (x0.span.to(xn.span), xn.span),\n         };\n         let ctx = if is_ctx_else { \"else\" } else { \"if\" };\n-        self.sess.emit_err(OuterAttributeNotAllowedOnIfElse {\n+        self.sess.emit_err(errors::OuterAttributeNotAllowedOnIfElse {\n             last,\n             branch_span,\n             ctx_span,\n@@ -2451,7 +2441,7 @@ impl<'a> Parser<'a> {\n         if let ExprKind::Binary(Spanned { span: binop_span, node: binop}, _, right) = &cond.kind &&\n             let BinOpKind::And = binop &&\n             let ExprKind::If(cond, ..) = &right.kind {\n-                    Err(self.sess.create_err(UnexpectedIfWithIf(binop_span.shrink_to_hi().to(cond.span.shrink_to_lo()))))\n+                    Err(self.sess.create_err(errors::UnexpectedIfWithIf(binop_span.shrink_to_hi().to(cond.span.shrink_to_lo()))))\n             } else {\n                 Ok(())\n             }\n@@ -2492,12 +2482,12 @@ impl<'a> Parser<'a> {\n             // Possibly using JS syntax (#75311).\n             let span = self.token.span;\n             self.bump();\n-            (span, MissingInInForLoopSub::InNotOf)\n+            (span, errors::MissingInInForLoopSub::InNotOf)\n         } else {\n-            (self.prev_token.span.between(self.token.span), MissingInInForLoopSub::AddIn)\n+            (self.prev_token.span.between(self.token.span), errors::MissingInInForLoopSub::AddIn)\n         };\n \n-        self.sess.emit_err(MissingInInForLoop { span, sub: sub(span) });\n+        self.sess.emit_err(errors::MissingInInForLoop { span, sub: sub(span) });\n     }\n \n     /// Parses a `while` or `while let` expression (`while` token already eaten).\n@@ -2601,17 +2591,17 @@ impl<'a> Parser<'a> {\n         let err = |this: &Parser<'_>, stmts: Vec<ast::Stmt>| {\n             let span = stmts[0].span.to(stmts[stmts.len() - 1].span);\n \n-            this.sess.emit_err(MatchArmBodyWithoutBraces {\n+            this.sess.emit_err(errors::MatchArmBodyWithoutBraces {\n                 statements: span,\n                 arrow: arrow_span,\n                 num_statements: stmts.len(),\n                 sub: if stmts.len() > 1 {\n-                    MatchArmBodyWithoutBracesSugg::AddBraces {\n+                    errors::MatchArmBodyWithoutBracesSugg::AddBraces {\n                         left: span.shrink_to_lo(),\n                         right: span.shrink_to_hi(),\n                     }\n                 } else {\n-                    MatchArmBodyWithoutBracesSugg::UseComma { semicolon: semi_sp }\n+                    errors::MatchArmBodyWithoutBracesSugg::UseComma { semicolon: semi_sp }\n                 },\n             });\n             this.mk_expr_err(span)\n@@ -2802,7 +2792,7 @@ impl<'a> Parser<'a> {\n                                 .is_ok();\n                             if pattern_follows && snapshot.check(&TokenKind::FatArrow) {\n                                 err.cancel();\n-                                this.sess.emit_err(MissingCommaAfterMatchArm {\n+                                this.sess.emit_err(errors::MissingCommaAfterMatchArm {\n                                     span: hi.shrink_to_hi(),\n                                 });\n                                 return Ok(true);\n@@ -2834,7 +2824,7 @@ impl<'a> Parser<'a> {\n     fn parse_try_block(&mut self, span_lo: Span) -> PResult<'a, P<Expr>> {\n         let (attrs, body) = self.parse_inner_attrs_and_block()?;\n         if self.eat_keyword(kw::Catch) {\n-            Err(CatchAfterTry { span: self.prev_token.span }\n+            Err(errors::CatchAfterTry { span: self.prev_token.span }\n                 .into_diagnostic(&self.sess.span_diagnostic))\n         } else {\n             let span = span_lo.to(body.span);\n@@ -2910,9 +2900,9 @@ impl<'a> Parser<'a> {\n             let expr = self.parse_struct_expr(qself.clone(), path.clone(), true);\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n                 // This is a struct literal, but we don't can't accept them here.\n-                self.sess.emit_err(StructLiteralNotAllowedHere {\n+                self.sess.emit_err(errors::StructLiteralNotAllowedHere {\n                     span: expr.span,\n-                    sub: StructLiteralNotAllowedHereSugg {\n+                    sub: errors::StructLiteralNotAllowedHereSugg {\n                         left: path.span.shrink_to_lo(),\n                         right: expr.span.shrink_to_hi(),\n                     },\n@@ -2935,8 +2925,8 @@ impl<'a> Parser<'a> {\n \n         let mut async_block_err = |e: &mut Diagnostic, span: Span| {\n             recover_async = true;\n-            AsyncBlockIn2015 { span }.add_to_diagnostic(e);\n-            HelpUseLatestEdition::new().add_to_diagnostic(e);\n+            errors::AsyncBlockIn2015 { span }.add_to_diagnostic(e);\n+            errors::HelpUseLatestEdition::new().add_to_diagnostic(e);\n         };\n \n         while self.token != token::CloseDelim(close_delim) {\n@@ -3080,7 +3070,7 @@ impl<'a> Parser<'a> {\n         if self.token != token::Comma {\n             return;\n         }\n-        self.sess.emit_err(CommaAfterBaseStruct {\n+        self.sess.emit_err(errors::CommaAfterBaseStruct {\n             span: span.to(self.prev_token.span),\n             comma: self.token.span,\n         });\n@@ -3093,7 +3083,7 @@ impl<'a> Parser<'a> {\n         {\n             // recover from typo of `...`, suggest `..`\n             let span = self.prev_token.span;\n-            self.sess.emit_err(MissingDotDot { token_span: span, sugg_span: span });\n+            self.sess.emit_err(errors::MissingDotDot { token_span: span, sugg_span: span });\n             return true;\n         }\n         false\n@@ -3161,18 +3151,18 @@ impl<'a> Parser<'a> {\n             return;\n         }\n \n-        self.sess.emit_err(EqFieldInit {\n+        self.sess.emit_err(errors::EqFieldInit {\n             span: self.token.span,\n             eq: field_name.span.shrink_to_hi().to(self.token.span),\n         });\n     }\n \n     fn err_dotdotdot_syntax(&self, span: Span) {\n-        self.sess.emit_err(DotDotDot { span });\n+        self.sess.emit_err(errors::DotDotDot { span });\n     }\n \n     fn err_larrow_operator(&self, span: Span) {\n-        self.sess.emit_err(LeftArrowOperator { span });\n+        self.sess.emit_err(errors::LeftArrowOperator { span });\n     }\n \n     fn mk_assign_op(&self, binop: BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ExprKind {"}, {"sha": "3afda5f69f0e1f4eceb99a29858507af08b1071c", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/394fa192a94bf6fed793ac3f8ceacc7d35b55319/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/394fa192a94bf6fed793ac3f8ceacc7d35b55319/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=394fa192a94bf6fed793ac3f8ceacc7d35b55319", "patch": "@@ -7,12 +7,7 @@ use super::TrailingToken;\n use super::{\n     AttrWrapper, BlockMode, FnParseMode, ForceCollect, Parser, Restrictions, SemiColonMode,\n };\n-use crate::errors::{\n-    AssignmentElseNotAllowed, CompoundAssignmentExpressionInLet, ConstLetMutuallyExclusive,\n-    DocCommentDoesNotDocumentAnything, ExpectedStatementAfterOuterAttr, InvalidCurlyInLetElse,\n-    InvalidExpressionInLetElse, InvalidIdentiferStartsWithNumber, InvalidVariableDeclaration,\n-    InvalidVariableDeclarationSub, WrapExpressionInParentheses,\n-};\n+use crate::errors;\n use crate::maybe_whole;\n \n use rustc_ast as ast;\n@@ -64,29 +59,33 @@ impl<'a> Parser<'a> {\n         if self.token.is_keyword(kw::Mut) && self.is_keyword_ahead(1, &[kw::Let]) {\n             self.bump();\n             let mut_let_span = lo.to(self.token.span);\n-            self.sess.emit_err(InvalidVariableDeclaration {\n+            self.sess.emit_err(errors::InvalidVariableDeclaration {\n                 span: mut_let_span,\n-                sub: InvalidVariableDeclarationSub::SwitchMutLetOrder(mut_let_span),\n+                sub: errors::InvalidVariableDeclarationSub::SwitchMutLetOrder(mut_let_span),\n             });\n         }\n \n         Ok(Some(if self.token.is_keyword(kw::Let) {\n             self.parse_local_mk(lo, attrs, capture_semi, force_collect)?\n         } else if self.is_kw_followed_by_ident(kw::Mut) && self.may_recover() {\n-            self.recover_stmt_local_after_let(lo, attrs, InvalidVariableDeclarationSub::MissingLet)?\n+            self.recover_stmt_local_after_let(\n+                lo,\n+                attrs,\n+                errors::InvalidVariableDeclarationSub::MissingLet,\n+            )?\n         } else if self.is_kw_followed_by_ident(kw::Auto) && self.may_recover() {\n             self.bump(); // `auto`\n             self.recover_stmt_local_after_let(\n                 lo,\n                 attrs,\n-                InvalidVariableDeclarationSub::UseLetNotAuto,\n+                errors::InvalidVariableDeclarationSub::UseLetNotAuto,\n             )?\n         } else if self.is_kw_followed_by_ident(sym::var) && self.may_recover() {\n             self.bump(); // `var`\n             self.recover_stmt_local_after_let(\n                 lo,\n                 attrs,\n-                InvalidVariableDeclarationSub::UseLetNotVar,\n+                errors::InvalidVariableDeclarationSub::UseLetNotVar,\n             )?\n         } else if self.check_path() && !self.token.is_qpath_start() && !self.is_path_start_item() {\n             // We have avoided contextual keywords like `union`, items with `crate` visibility,\n@@ -124,7 +123,7 @@ impl<'a> Parser<'a> {\n                 let bl = self.parse_block()?;\n                 // Destructuring assignment ... else.\n                 // This is not allowed, but point it out in a nice way.\n-                self.sess.emit_err(AssignmentElseNotAllowed { span: e.span.to(bl.span) });\n+                self.sess.emit_err(errors::AssignmentElseNotAllowed { span: e.span.to(bl.span) });\n             }\n             self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n         } else {\n@@ -217,12 +216,12 @@ impl<'a> Parser<'a> {\n         && let attrs = attrs.take_for_recovery(self.sess)\n         && let attrs @ [.., last] = &*attrs {\n             if last.is_doc_comment() {\n-                self.sess.emit_err(DocCommentDoesNotDocumentAnything {\n+                self.sess.emit_err(errors::DocCommentDoesNotDocumentAnything {\n                     span: last.span,\n                     missing_comma: None,\n                 });\n             } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n-                self.sess.emit_err(ExpectedStatementAfterOuterAttr { span: last.span });\n+                self.sess.emit_err(errors::ExpectedStatementAfterOuterAttr { span: last.span });\n             }\n         }\n     }\n@@ -231,7 +230,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         attrs: AttrWrapper,\n-        subdiagnostic: fn(Span) -> InvalidVariableDeclarationSub,\n+        subdiagnostic: fn(Span) -> errors::InvalidVariableDeclarationSub,\n     ) -> PResult<'a, Stmt> {\n         let stmt =\n             self.collect_tokens_trailing_token(attrs, ForceCollect::Yes, |this, attrs| {\n@@ -242,7 +241,7 @@ impl<'a> Parser<'a> {\n                     TrailingToken::None,\n                 ))\n             })?;\n-        self.sess.emit_err(InvalidVariableDeclaration { span: lo, sub: subdiagnostic(lo) });\n+        self.sess.emit_err(errors::InvalidVariableDeclaration { span: lo, sub: subdiagnostic(lo) });\n         Ok(stmt)\n     }\n \n@@ -270,7 +269,7 @@ impl<'a> Parser<'a> {\n         let lo = self.prev_token.span;\n \n         if self.token.is_keyword(kw::Const) && self.look_ahead(1, |t| t.is_ident()) {\n-            self.sess.emit_err(ConstLetMutuallyExclusive { span: lo.to(self.token.span) });\n+            self.sess.emit_err(errors::ConstLetMutuallyExclusive { span: lo.to(self.token.span) });\n             self.bump();\n         }\n \n@@ -373,18 +372,18 @@ impl<'a> Parser<'a> {\n             rustc_ast::MetaItemLit::from_token(&self.token).is_none() &&\n             (lit.kind == token::LitKind::Integer || lit.kind == token::LitKind::Float) &&\n             self.look_ahead(1, |t| matches!(t.kind, token::Eq) || matches!(t.kind, token::Colon ) ) {\n-                return Err(self.sess.create_err(InvalidIdentiferStartsWithNumber { span: self.token.span }));\n+                return Err(self.sess.create_err(errors::InvalidIdentiferStartsWithNumber { span: self.token.span }));\n         }\n         Ok(())\n     }\n \n     fn check_let_else_init_bool_expr(&self, init: &ast::Expr) {\n         if let ast::ExprKind::Binary(op, ..) = init.kind {\n             if op.node.lazy() {\n-                self.sess.emit_err(InvalidExpressionInLetElse {\n+                self.sess.emit_err(errors::InvalidExpressionInLetElse {\n                     span: init.span,\n                     operator: op.node.to_string(),\n-                    sugg: WrapExpressionInParentheses {\n+                    sugg: errors::WrapExpressionInParentheses {\n                         left: init.span.shrink_to_lo(),\n                         right: init.span.shrink_to_hi(),\n                     },\n@@ -395,9 +394,9 @@ impl<'a> Parser<'a> {\n \n     fn check_let_else_init_trailing_brace(&self, init: &ast::Expr) {\n         if let Some(trailing) = classify::expr_trailing_brace(init) {\n-            self.sess.emit_err(InvalidCurlyInLetElse {\n+            self.sess.emit_err(errors::InvalidCurlyInLetElse {\n                 span: trailing.span.with_lo(trailing.span.hi() - BytePos(1)),\n-                sugg: WrapExpressionInParentheses {\n+                sugg: errors::WrapExpressionInParentheses {\n                     left: trailing.span.shrink_to_lo(),\n                     right: trailing.span.shrink_to_hi(),\n                 },\n@@ -410,7 +409,8 @@ impl<'a> Parser<'a> {\n         let eq_consumed = match self.token.kind {\n             token::BinOpEq(..) => {\n                 // Recover `let x <op>= 1` as `let x = 1`\n-                self.sess.emit_err(CompoundAssignmentExpressionInLet { span: self.token.span });\n+                self.sess\n+                    .emit_err(errors::CompoundAssignmentExpressionInLet { span: self.token.span });\n                 self.bump();\n                 true\n             }"}]}