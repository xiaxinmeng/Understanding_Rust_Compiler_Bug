{"sha": "32e78ca2e38cdc83a8a18ee38cad43a5df72c1de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZTc4Y2EyZTM4Y2RjODNhOGExOGVlMzhjYWQ0M2E1ZGY3MmMxZGU=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-11-25T00:09:58Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-11-25T00:09:58Z"}, "message": "Respond to CR feedback", "tree": {"sha": "54640f08047937cd0d96c99d53938b04a3b0073b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54640f08047937cd0d96c99d53938b04a3b0073b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32e78ca2e38cdc83a8a18ee38cad43a5df72c1de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32e78ca2e38cdc83a8a18ee38cad43a5df72c1de", "html_url": "https://github.com/rust-lang/rust/commit/32e78ca2e38cdc83a8a18ee38cad43a5df72c1de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32e78ca2e38cdc83a8a18ee38cad43a5df72c1de/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b6815a69e618a96a221d8db24ace87d10ae69f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b6815a69e618a96a221d8db24ace87d10ae69f0", "html_url": "https://github.com/rust-lang/rust/commit/2b6815a69e618a96a221d8db24ace87d10ae69f0"}], "stats": {"total": 93, "additions": 20, "deletions": 73}, "files": [{"sha": "630f3f603449bb0fccd84250324ac0a39a934bc4", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 11, "deletions": 62, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/32e78ca2e38cdc83a8a18ee38cad43a5df72c1de/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e78ca2e38cdc83a8a18ee38cad43a5df72c1de/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=32e78ca2e38cdc83a8a18ee38cad43a5df72c1de", "patch": "@@ -15,9 +15,8 @@ use super::{\n     AllocId, Allocation, InterpCx, Machine, MemoryKind, MPlaceTy, Scalar, ValueVisitor,\n };\n \n-struct InternVisitor<'rt, 'mir, 'tcx, M>\n-where\n-    M: Machine<\n+pub trait CompileTimeMachine<'mir, 'tcx> =\n+    Machine<\n         'mir,\n         'tcx,\n         MemoryKinds = !,\n@@ -27,8 +26,9 @@ where\n         MemoryExtra = (),\n         AllocExtra = (),\n         MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>,\n-    >,\n-{\n+    >;\n+\n+struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> {\n     /// The ectx from which we intern.\n     ecx: &'rt mut InterpCx<'mir, 'tcx, M>,\n     /// Previously encountered safe references.\n@@ -70,27 +70,14 @@ struct IsStaticOrFn;\n /// `immutable` things might become mutable if `ty` is not frozen.\n /// `ty` can be `None` if there is no potential interior mutability\n /// to account for (e.g. for vtables).\n-fn intern_shallow<'rt, 'mir, 'tcx, M>(\n+fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &'rt mut InterpCx<'mir, 'tcx, M>,\n     leftover_allocations: &'rt mut FxHashSet<AllocId>,\n     mode: InternMode,\n     alloc_id: AllocId,\n     mutability: Mutability,\n     ty: Option<Ty<'tcx>>,\n-) -> InterpResult<'tcx, Option<IsStaticOrFn>>\n-where\n-    M: Machine<\n-        'mir,\n-        'tcx,\n-        MemoryKinds = !,\n-        PointerTag = (),\n-        ExtraFnVal = !,\n-        FrameExtra = (),\n-        MemoryExtra = (),\n-        AllocExtra = (),\n-        MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>,\n-    >,\n-{\n+) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n     trace!(\"InternVisitor::intern {:?} with {:?}\", alloc_id, mutability,);\n     // remove allocation\n     let tcx = ecx.tcx;\n@@ -152,20 +139,7 @@ where\n     Ok(None)\n }\n \n-impl<'rt, 'mir, 'tcx, M> InternVisitor<'rt, 'mir, 'tcx, M>\n-where\n-    M: Machine<\n-        'mir,\n-        'tcx,\n-        MemoryKinds = !,\n-        PointerTag = (),\n-        ExtraFnVal = !,\n-        FrameExtra = (),\n-        MemoryExtra = (),\n-        AllocExtra = (),\n-        MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>,\n-    >,\n-{\n+impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> InternVisitor<'rt, 'mir, 'tcx, M> {\n     fn intern_shallow(\n         &mut self,\n         alloc_id: AllocId,\n@@ -183,22 +157,10 @@ where\n     }\n }\n \n-impl<'rt, 'mir, 'tcx, M>\n+impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>\n     ValueVisitor<'mir, 'tcx, M>\n for\n     InternVisitor<'rt, 'mir, 'tcx, M>\n-where\n-    M: Machine<\n-        'mir,\n-        'tcx,\n-        MemoryKinds = !,\n-        PointerTag = (),\n-        ExtraFnVal = !,\n-        FrameExtra = (),\n-        MemoryExtra = (),\n-        AllocExtra = (),\n-        MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>,\n-    >,\n {\n     type V = MPlaceTy<'tcx>;\n \n@@ -312,25 +274,12 @@ where\n     }\n }\n \n-pub fn intern_const_alloc_recursive<M>(\n+pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n     // The `mutability` of the place, ignoring the type.\n     place_mut: Option<hir::Mutability>,\n     ret: MPlaceTy<'tcx>,\n-) -> InterpResult<'tcx>\n-where\n-    M: Machine<\n-        'mir,\n-        'tcx,\n-        MemoryKinds = !,\n-        PointerTag = (),\n-        ExtraFnVal = !,\n-        FrameExtra = (),\n-        MemoryExtra = (),\n-        AllocExtra = (),\n-        MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>,\n-    >,\n-{\n+) -> InterpResult<'tcx> {\n     let tcx = ecx.tcx;\n     let (base_mutability, base_intern_mode) = match place_mut {\n         Some(hir::Mutability::Immutable) => (Mutability::Immutable, InternMode::Static),"}, {"sha": "b5273ea7bc6098b49644d8d15a25db74521bf570", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32e78ca2e38cdc83a8a18ee38cad43a5df72c1de/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e78ca2e38cdc83a8a18ee38cad43a5df72c1de/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=32e78ca2e38cdc83a8a18ee38cad43a5df72c1de", "patch": "@@ -27,6 +27,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(range_is_empty)]\n #![feature(stmt_expr_attributes)]\n #![feature(bool_to_option)]\n+#![feature(trait_alias)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "58d1a8b709797ab3fa18d3af3390de8590e91b25", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/32e78ca2e38cdc83a8a18ee38cad43a5df72c1de/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e78ca2e38cdc83a8a18ee38cad43a5df72c1de/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=32e78ca2e38cdc83a8a18ee38cad43a5df72c1de", "patch": "@@ -649,31 +649,28 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     fn should_const_prop(&mut self, op: OpTy<'tcx>) -> bool {\n-        if self.tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n+        let mir_opt_level = self.tcx.sess.opts.debugging_opts.mir_opt_level;\n+\n+        if mir_opt_level == 0 {\n             return false;\n         }\n \n-        let is_scalar = match *op {\n+        match *op {\n             interpret::Operand::Immediate(Immediate::Scalar(ScalarMaybeUndef::Scalar(s))) =>\n                 s.is_bits(),\n             interpret::Operand::Immediate(Immediate::ScalarPair(ScalarMaybeUndef::Scalar(l),\n                                                                 ScalarMaybeUndef::Scalar(r))) =>\n                 l.is_bits() && r.is_bits(),\n-            _ => false\n-        };\n-\n-        if let interpret::Operand::Indirect(_) = *op {\n-            if self.tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n+            interpret::Operand::Indirect(_) if mir_opt_level >= 2 => {\n                 intern_const_alloc_recursive(\n                     &mut self.ecx,\n                     None,\n                     op.assert_mem_place()\n                 ).expect(\"failed to intern alloc\");\n-                return true;\n-            }\n+                true\n+            },\n+            _ => false\n         }\n-\n-        return is_scalar;\n     }\n }\n "}]}