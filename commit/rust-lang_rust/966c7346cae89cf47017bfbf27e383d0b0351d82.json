{"sha": "966c7346cae89cf47017bfbf27e383d0b0351d82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NmM3MzQ2Y2FlODljZjQ3MDE3YmZiZjI3ZTM4M2QwYjAzNTFkODI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-06-01T23:35:01Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-06-09T19:39:17Z"}, "message": "librustc: Implement overloading for the call operator behind a feature\ngate.\n\nThis is part of unboxed closures.", "tree": {"sha": "c10b7c092c4890c88317e37114c33db84b4bab33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c10b7c092c4890c88317e37114c33db84b4bab33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/966c7346cae89cf47017bfbf27e383d0b0351d82", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/966c7346cae89cf47017bfbf27e383d0b0351d82", "html_url": "https://github.com/rust-lang/rust/commit/966c7346cae89cf47017bfbf27e383d0b0351d82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/966c7346cae89cf47017bfbf27e383d0b0351d82/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e55f64f99726a44283211d91a702081fe4a1855b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e55f64f99726a44283211d91a702081fe4a1855b", "html_url": "https://github.com/rust-lang/rust/commit/e55f64f99726a44283211d91a702081fe4a1855b"}], "stats": {"total": 935, "additions": 701, "deletions": 234}, "files": [{"sha": "af1df973a3e655c2fc61da948e7a48ccc3b5410c", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=966c7346cae89cf47017bfbf27e383d0b0351d82", "patch": "@@ -726,6 +726,27 @@ pub trait DerefMut<Result>: Deref<Result> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut Result;\n }\n \n+/// A version of the call operator that takes an immutable receiver.\n+#[lang=\"fn\"]\n+pub trait Fn<Args,Result> {\n+    /// This is called when the call operator is used.\n+    fn call(&self, args: Args) -> Result;\n+}\n+\n+/// A version of the call operator that takes a mutable receiver.\n+#[lang=\"fn_mut\"]\n+pub trait FnMut<Args,Result> {\n+    /// This is called when the call operator is used.\n+    fn call_mut(&mut self, args: Args) -> Result;\n+}\n+\n+/// A version of the call operator that takes a by-value receiver.\n+#[lang=\"fn_once\"]\n+pub trait FnOnce<Args,Result> {\n+    /// This is called when the call operator is used.\n+    fn call_once(self, args: Args) -> Result;\n+}\n+\n #[cfg(test)]\n mod bench {\n     extern crate test;"}, {"sha": "5edee5ea2ef735bc17ff1828e17f8bc9c74983ee", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=966c7346cae89cf47017bfbf27e383d0b0351d82", "patch": "@@ -56,6 +56,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"quote\", Active),\n     (\"linkage\", Active),\n     (\"struct_inherit\", Active),\n+    (\"overloaded_calls\", Active),\n \n     (\"quad_precision_float\", Active),\n \n@@ -86,6 +87,7 @@ pub struct Features {\n     pub default_type_params: Cell<bool>,\n     pub quad_precision_float: Cell<bool>,\n     pub issue_5723_bootstrap: Cell<bool>,\n+    pub overloaded_calls: Cell<bool>,\n }\n \n impl Features {\n@@ -94,6 +96,7 @@ impl Features {\n             default_type_params: Cell::new(false),\n             quad_precision_float: Cell::new(false),\n             issue_5723_bootstrap: Cell::new(false),\n+            overloaded_calls: Cell::new(false),\n         }\n     }\n }\n@@ -376,4 +379,5 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n     sess.features.default_type_params.set(cx.has_feature(\"default_type_params\"));\n     sess.features.quad_precision_float.set(cx.has_feature(\"quad_precision_float\"));\n     sess.features.issue_5723_bootstrap.set(cx.has_feature(\"issue_5723_bootstrap\"));\n+    sess.features.overloaded_calls.set(cx.has_feature(\"overloaded_calls\"));\n }"}, {"sha": "540dfdab19e990b6362f1926bf4e6e07954ae41f", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=966c7346cae89cf47017bfbf27e383d0b0351d82", "patch": "@@ -19,6 +19,7 @@ use middle::def;\n use middle::freevars;\n use middle::pat_util;\n use middle::ty;\n+use middle::typeck::MethodCall;\n use middle::typeck;\n use syntax::ast;\n use syntax::codemap::{Span};\n@@ -427,10 +428,20 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                 }\n             }\n             _ => {\n-                self.tcx().sess.span_bug(\n-                    callee.span,\n-                    format!(\"unxpected callee type {}\",\n-                            callee_ty.repr(self.tcx())).as_slice());\n+                match self.tcx()\n+                          .method_map\n+                          .borrow()\n+                          .find(&MethodCall::expr(call.id)) {\n+                    Some(_) => {\n+                        // FIXME(#14774, pcwalton): Implement this.\n+                    }\n+                    None => {\n+                        self.tcx().sess.span_bug(\n+                            callee.span,\n+                            format!(\"unxpected callee type {}\",\n+                                    callee_ty.repr(self.tcx())).as_slice());\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "20e4188a8f6c5cf01386610e71d9b435b0b4a968", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=966c7346cae89cf47017bfbf27e383d0b0351d82", "patch": "@@ -240,6 +240,10 @@ lets_do_this! {\n     DerefTraitLangItem,              \"deref\",                   deref_trait;\n     DerefMutTraitLangItem,           \"deref_mut\",               deref_mut_trait;\n \n+    FnTraitLangItem,                 \"fn\",                      fn_trait;\n+    FnMutTraitLangItem,              \"fn_mut\",                  fn_mut_trait;\n+    FnOnceTraitLangItem,             \"fn_once\",                 fn_once_trait;\n+\n     EqTraitLangItem,                 \"eq\",                      eq_trait;\n     OrdTraitLangItem,                \"ord\",                     ord_trait;\n "}, {"sha": "278d5d8187b72440c3dd6c4482737fc81db8a6d9", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=966c7346cae89cf47017bfbf27e383d0b0351d82", "patch": "@@ -105,6 +105,7 @@\n use middle::def::*;\n use middle::freevars;\n use middle::lint::{UnusedVariable, DeadAssignment};\n+use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::ty;\n use util::nodemap::NodeMap;\n@@ -1146,9 +1147,15 @@ impl<'a> Liveness<'a> {\n           ExprCall(f, ref args) => {\n             // calling a fn with bot return type means that the fn\n             // will fail, and hence the successors can be ignored\n-            let t_ret = ty::ty_fn_ret(ty::expr_ty(self.ir.tcx, f));\n-            let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n-                       else {succ};\n+            let is_bot = !self.ir.tcx.is_method_call(expr.id) && {\n+                let t_ret = ty::ty_fn_ret(ty::expr_ty(self.ir.tcx, f));\n+                ty::type_is_bot(t_ret)\n+            };\n+            let succ = if is_bot {\n+                self.s.exit_ln\n+            } else {\n+                succ\n+            };\n             let succ = self.propagate_through_exprs(args.as_slice(), succ);\n             self.propagate_through_expr(f, succ)\n           }"}, {"sha": "b21877e4fa030f56c6348e14d6714da110889c7f", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=966c7346cae89cf47017bfbf27e383d0b0351d82", "patch": "@@ -39,6 +39,7 @@ use lib;\n use metadata::csearch;\n use middle::def;\n use middle::lang_items::MallocFnLangItem;\n+use middle::mem_categorization::Typer;\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::asm;\n@@ -65,6 +66,7 @@ use middle::ty::{AutoBorrowObj, AutoDerefRef, AutoAddEnv, AutoObject, AutoUnsafe\n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef};\n use middle::ty;\n use middle::typeck::MethodCall;\n+use middle::typeck;\n use util::common::indenter;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n@@ -713,7 +715,20 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             closure::trans_expr_fn(bcx, store, decl, body, expr.id, dest)\n         }\n         ast::ExprCall(f, ref args) => {\n-            callee::trans_call(bcx, expr, f, callee::ArgExprs(args.as_slice()), dest)\n+            if bcx.tcx().is_method_call(expr.id) {\n+                let callee_datum = unpack_datum!(bcx, trans(bcx, f));\n+                trans_overloaded_call(bcx,\n+                                      expr,\n+                                      callee_datum,\n+                                      args.as_slice(),\n+                                      Some(dest))\n+            } else {\n+                callee::trans_call(bcx,\n+                                   expr,\n+                                   f,\n+                                   callee::ArgExprs(args.as_slice()),\n+                                   dest)\n+            }\n         }\n         ast::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n@@ -1461,6 +1476,76 @@ fn trans_overloaded_op<'a, 'b>(\n                              dest)\n }\n \n+fn trans_overloaded_call<'a>(\n+                         mut bcx: &'a Block<'a>,\n+                         expr: &ast::Expr,\n+                         callee: Datum<Expr>,\n+                         args: &[@ast::Expr],\n+                         dest: Option<Dest>)\n+                         -> &'a Block<'a> {\n+    // Evaluate and tuple the arguments.\n+    let tuple_type = ty::mk_tup(bcx.tcx(),\n+                                args.iter()\n+                                    .map(|e| expr_ty(bcx, *e))\n+                                    .collect());\n+    let repr = adt::represent_type(bcx.ccx(), tuple_type);\n+    let numbered_fields: Vec<(uint, @ast::Expr)> =\n+        args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n+    let argument_scope = bcx.fcx.push_custom_cleanup_scope();\n+    let tuple_datum =\n+        unpack_datum!(bcx,\n+                      lvalue_scratch_datum(bcx,\n+                                           tuple_type,\n+                                           \"tupled_arguments\",\n+                                           false,\n+                                           cleanup::CustomScope(\n+                                               argument_scope),\n+                                           (),\n+                                           |(), bcx, addr| {\n+            trans_adt(bcx,\n+                      &*repr,\n+                      0,\n+                      numbered_fields.as_slice(),\n+                      None,\n+                      SaveIn(addr))\n+        }));\n+\n+    let method_call = typeck::MethodCall::expr(expr.id);\n+    let method_type = bcx.tcx()\n+                         .method_map\n+                         .borrow()\n+                         .get(&method_call)\n+                         .ty;\n+    let callee_rvalue = unpack_datum!(bcx,\n+                                      callee.to_rvalue_datum(bcx, \"callee\"));\n+    let tuple_datum = tuple_datum.to_expr_datum();\n+    let tuple_rvalue = unpack_datum!(bcx,\n+                                     tuple_datum.to_rvalue_datum(bcx,\n+                                                                 \"tuple\"));\n+    let argument_values = [\n+        callee_rvalue.add_clean(bcx.fcx,\n+                                cleanup::CustomScope(argument_scope)),\n+        tuple_rvalue.add_clean(bcx.fcx, cleanup::CustomScope(argument_scope))\n+    ];\n+    unpack_result!(bcx,\n+                   callee::trans_call_inner(bcx,\n+                                            Some(expr_info(expr)),\n+                                            monomorphize_type(bcx,\n+                                                              method_type),\n+                                            |bcx, arg_cleanup_scope| {\n+                                                meth::trans_method_callee(\n+                                                    bcx,\n+                                                    method_call,\n+                                                    None,\n+                                                    arg_cleanup_scope)\n+                                            },\n+                                            callee::ArgVals(argument_values),\n+                                            dest));\n+\n+    bcx.fcx.pop_custom_cleanup_scope(argument_scope);\n+    bcx\n+}\n+\n fn int_cast(bcx: &Block,\n             lldsttype: Type,\n             llsrctype: Type,"}, {"sha": "1463cf9602dcae137a104a643e90ea67757697b4", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 379, "deletions": 219, "changes": 598, "blob_url": "https://github.com/rust-lang/rust/blob/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=966c7346cae89cf47017bfbf27e383d0b0351d82", "patch": "@@ -1353,6 +1353,61 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n     (ty::mk_err(), 0, None)\n }\n \n+/// Attempts to resolve a call expression as an overloaded call.\n+fn try_overloaded_call(fcx: &FnCtxt,\n+                       call_expression: &ast::Expr,\n+                       callee: @ast::Expr,\n+                       callee_type: ty::t,\n+                       args: &[@ast::Expr])\n+                       -> bool {\n+    // Try `FnOnce`, then `FnMut`, then `Fn`.\n+    for &(maybe_function_trait, method_name) in [\n+        (fcx.tcx().lang_items.fn_once_trait(), token::intern(\"call_once\")),\n+        (fcx.tcx().lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n+        (fcx.tcx().lang_items.fn_trait(), token::intern(\"call\"))\n+    ].iter() {\n+        let function_trait = match maybe_function_trait {\n+            None => continue,\n+            Some(function_trait) => function_trait,\n+        };\n+        let method_callee = match method::lookup_in_trait(\n+                fcx,\n+                call_expression.span,\n+                Some(&*callee),\n+                method_name,\n+                function_trait,\n+                callee_type,\n+                [],\n+                DontAutoderefReceiver,\n+                IgnoreStaticMethods) {\n+            None => continue,\n+            Some(method_callee) => method_callee,\n+        };\n+        let method_call = MethodCall::expr(call_expression.id);\n+        let output_type = check_method_argument_types(fcx,\n+                                                      call_expression.span,\n+                                                      method_callee.ty,\n+                                                      call_expression,\n+                                                      args,\n+                                                      DontDerefArgs,\n+                                                      TupleArguments);\n+        fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n+        write_call(fcx, call_expression, output_type);\n+\n+        if !fcx.tcx().sess.features.overloaded_calls.get() {\n+            fcx.tcx().sess.span_err(call_expression.span,\n+                                    \"overloaded calls are experimental\");\n+            fcx.tcx().sess.span_note(call_expression.span,\n+                                     \"add `#[feature(overloaded_calls)]` to \\\n+                                      the crate attributes to enable\");\n+        }\n+\n+        return true\n+    }\n+\n+    false\n+}\n+\n fn try_overloaded_deref(fcx: &FnCtxt,\n                         span: Span,\n                         method_call: Option<MethodCall>,\n@@ -1395,6 +1450,261 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n     }\n }\n \n+fn check_method_argument_types(fcx: &FnCtxt,\n+                               sp: Span,\n+                               method_fn_ty: ty::t,\n+                               callee_expr: &ast::Expr,\n+                               args: &[@ast::Expr],\n+                               deref_args: DerefArgs,\n+                               tuple_arguments: TupleArgumentsFlag)\n+                               -> ty::t {\n+    // HACK(eddyb) ignore provided self (it has special typeck rules).\n+    let args = if tuple_arguments == DontTupleArguments {\n+        args.slice_from(1)\n+    } else {\n+        args\n+    };\n+    if ty::type_is_error(method_fn_ty) {\n+        let err_inputs = err_args(args.len());\n+        check_argument_types(fcx,\n+                             sp,\n+                             err_inputs.as_slice(),\n+                             callee_expr,\n+                             args,\n+                             deref_args,\n+                             false,\n+                             tuple_arguments);\n+        method_fn_ty\n+    } else {\n+        match ty::get(method_fn_ty).sty {\n+            ty::ty_bare_fn(ref fty) => {\n+                // HACK(eddyb) ignore self in the definition (see above).\n+                check_argument_types(fcx,\n+                                     sp,\n+                                     fty.sig.inputs.slice_from(1),\n+                                     callee_expr,\n+                                     args,\n+                                     deref_args,\n+                                     fty.sig.variadic,\n+                                     tuple_arguments);\n+                fty.sig.output\n+            }\n+            _ => {\n+                fcx.tcx().sess.span_bug(callee_expr.span,\n+                                        \"method without bare fn type\");\n+            }\n+        }\n+    }\n+}\n+\n+fn check_argument_types(fcx: &FnCtxt,\n+                        sp: Span,\n+                        fn_inputs: &[ty::t],\n+                        callee_expr: &ast::Expr,\n+                        args: &[@ast::Expr],\n+                        deref_args: DerefArgs,\n+                        variadic: bool,\n+                        tuple_arguments: TupleArgumentsFlag) {\n+    /*!\n+     *\n+     * Generic function that factors out common logic from\n+     * function calls, method calls and overloaded operators.\n+     */\n+\n+    let tcx = fcx.ccx.tcx;\n+\n+    // Grab the argument types, supplying fresh type variables\n+    // if the wrong number of arguments were supplied\n+    let supplied_arg_count = if tuple_arguments == DontTupleArguments {\n+        args.len()\n+    } else {\n+        1\n+    };\n+\n+    let expected_arg_count = fn_inputs.len();\n+    let formal_tys = if tuple_arguments == TupleArguments {\n+        let tuple_type = structurally_resolved_type(fcx, sp, fn_inputs[0]);\n+        match ty::get(tuple_type).sty {\n+            ty::ty_tup(ref arg_types) => {\n+                if arg_types.len() != args.len() {\n+                    let msg = format!(\n+                        \"this function takes \\\n+                         {nexpected, plural, =1{# parameter} \\\n+                         other{# parameters}} \\\n+                         but {nsupplied, plural, =1{# parameter was} \\\n+                         other{# parameters were}} supplied\",\n+                         nexpected = arg_types.len(),\n+                         nsupplied = args.len());\n+                    tcx.sess.span_err(sp, msg.as_slice());\n+                    err_args(args.len())\n+                } else {\n+                    (*arg_types).clone()\n+                }\n+            }\n+            ty::ty_nil => {\n+                if args.len() != 0 {\n+                    let msg = format!(\n+                        \"this function takes 0 parameters \\\n+                         but {nsupplied, plural, =1{# parameter was} \\\n+                         other{# parameters were}} supplied\",\n+                         nsupplied = args.len());\n+                    tcx.sess.span_err(sp, msg.as_slice());\n+                }\n+                Vec::new()\n+            }\n+            _ => {\n+                tcx.sess\n+                   .span_err(sp,\n+                             \"cannot use call notation; the first type \\\n+                              parameter for the function trait is neither a \\\n+                              tuple nor unit\");\n+                err_args(supplied_arg_count)\n+            }\n+        }\n+    } else if expected_arg_count == supplied_arg_count {\n+        fn_inputs.iter().map(|a| *a).collect()\n+    } else if variadic {\n+        if supplied_arg_count >= expected_arg_count {\n+            fn_inputs.iter().map(|a| *a).collect()\n+        } else {\n+            let msg = format!(\n+                \"this function takes at least {nexpected, plural, =1{# parameter} \\\n+                                                               other{# parameters}} \\\n+                 but {nsupplied, plural, =1{# parameter was} \\\n+                                      other{# parameters were}} supplied\",\n+                 nexpected = expected_arg_count,\n+                 nsupplied = supplied_arg_count);\n+\n+            tcx.sess.span_err(sp, msg.as_slice());\n+\n+            err_args(supplied_arg_count)\n+        }\n+    } else {\n+        let msg = format!(\n+            \"this function takes {nexpected, plural, =1{# parameter} \\\n+                                                  other{# parameters}} \\\n+             but {nsupplied, plural, =1{# parameter was} \\\n+                                  other{# parameters were}} supplied\",\n+             nexpected = expected_arg_count,\n+             nsupplied = supplied_arg_count);\n+\n+        tcx.sess.span_err(sp, msg.as_slice());\n+\n+        err_args(supplied_arg_count)\n+    };\n+\n+    debug!(\"check_argument_types: formal_tys={:?}\",\n+           formal_tys.iter().map(|t| fcx.infcx().ty_to_str(*t)).collect::<Vec<String>>());\n+\n+    // Check the arguments.\n+    // We do this in a pretty awful way: first we typecheck any arguments\n+    // that are not anonymous functions, then we typecheck the anonymous\n+    // functions. This is so that we have more information about the types\n+    // of arguments when we typecheck the functions. This isn't really the\n+    // right way to do this.\n+    let xs = [false, true];\n+    for check_blocks in xs.iter() {\n+        let check_blocks = *check_blocks;\n+        debug!(\"check_blocks={}\", check_blocks);\n+\n+        // More awful hacks: before we check the blocks, try to do\n+        // an \"opportunistic\" vtable resolution of any trait\n+        // bounds on the call.\n+        if check_blocks {\n+            vtable::early_resolve_expr(callee_expr, fcx, true);\n+        }\n+\n+        // For variadic functions, we don't have a declared type for all of\n+        // the arguments hence we only do our usual type checking with\n+        // the arguments who's types we do know.\n+        let t = if variadic {\n+            expected_arg_count\n+        } else if tuple_arguments == TupleArguments {\n+            args.len()\n+        } else {\n+            supplied_arg_count\n+        };\n+        for (i, arg) in args.iter().take(t).enumerate() {\n+            let is_block = match arg.node {\n+                ast::ExprFnBlock(..) |\n+                ast::ExprProc(..) => true,\n+                _ => false\n+            };\n+\n+            if is_block == check_blocks {\n+                debug!(\"checking the argument\");\n+                let mut formal_ty = *formal_tys.get(i);\n+\n+                match deref_args {\n+                    DoDerefArgs => {\n+                        match ty::get(formal_ty).sty {\n+                            ty::ty_rptr(_, mt) => formal_ty = mt.ty,\n+                            ty::ty_err => (),\n+                            _ => {\n+                                // So we hit this case when one implements the\n+                                // operator traits but leaves an argument as\n+                                // just T instead of &T. We'll catch it in the\n+                                // mismatch impl/trait method phase no need to\n+                                // ICE here.\n+                                // See: #11450\n+                                formal_ty = ty::mk_err();\n+                            }\n+                        }\n+                    }\n+                    DontDerefArgs => {}\n+                }\n+\n+                check_expr_coercable_to_type(fcx, *arg, formal_ty);\n+\n+            }\n+        }\n+    }\n+\n+    // We also need to make sure we at least write the ty of the other\n+    // arguments which we skipped above.\n+    if variadic {\n+        for arg in args.iter().skip(expected_arg_count) {\n+            check_expr(fcx, *arg);\n+\n+            // There are a few types which get autopromoted when passed via varargs\n+            // in C but we just error out instead and require explicit casts.\n+            let arg_ty = structurally_resolved_type(fcx, arg.span, fcx.expr_ty(*arg));\n+            match ty::get(arg_ty).sty {\n+                ty::ty_float(ast::TyF32) => {\n+                    fcx.type_error_message(arg.span,\n+                                           |t| {\n+                        format!(\"can't pass an {} to variadic \\\n+                                 function, cast to c_double\", t)\n+                    }, arg_ty, None);\n+                }\n+                ty::ty_int(ast::TyI8) | ty::ty_int(ast::TyI16) | ty::ty_bool => {\n+                    fcx.type_error_message(arg.span, |t| {\n+                        format!(\"can't pass {} to variadic \\\n+                                 function, cast to c_int\",\n+                                       t)\n+                    }, arg_ty, None);\n+                }\n+                ty::ty_uint(ast::TyU8) | ty::ty_uint(ast::TyU16) => {\n+                    fcx.type_error_message(arg.span, |t| {\n+                        format!(\"can't pass {} to variadic \\\n+                                 function, cast to c_uint\",\n+                                       t)\n+                    }, arg_ty, None);\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+}\n+\n+fn err_args(len: uint) -> Vec<ty::t> {\n+    Vec::from_fn(len, |_| ty::mk_err())\n+}\n+\n+fn write_call(fcx: &FnCtxt, call_expr: &ast::Expr, output: ty::t) {\n+    fcx.write_ty(call_expr.id, output);\n+}\n+\n // AST fragment checking\n pub fn check_lit(fcx: &FnCtxt, lit: &ast::Lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n@@ -1521,6 +1831,28 @@ pub enum DerefArgs {\n     DoDerefArgs\n }\n \n+/// Controls whether the arguments are tupled. This is used for the call\n+/// operator.\n+///\n+/// Tupling means that all call-side arguments are packed into a tuple and\n+/// passed as a single parameter. For example, if tupling is enabled, this\n+/// function:\n+///\n+///     fn f(x: (int, int))\n+///\n+/// Can be called as:\n+///\n+///     f(1, 2);\n+///\n+/// Instead of:\n+///\n+///     f((1, 2));\n+#[deriving(Clone, Eq, PartialEq)]\n+enum TupleArgumentsFlag {\n+    DontTupleArguments,\n+    TupleArguments,\n+}\n+\n // Given the provenance of a static method, returns the generics of the static\n // method's container.\n fn generics_of_static_method_container(type_context: &ty::ctxt,\n@@ -1704,207 +2036,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                            unifier: ||) {\n     debug!(\">> typechecking\");\n \n-    fn check_method_argument_types(\n-        fcx: &FnCtxt,\n-        sp: Span,\n-        method_fn_ty: ty::t,\n-        callee_expr: &ast::Expr,\n-        args: &[@ast::Expr],\n-        deref_args: DerefArgs) -> ty::t {\n-        // HACK(eddyb) ignore provided self (it has special typeck rules).\n-        let args = args.slice_from(1);\n-        if ty::type_is_error(method_fn_ty) {\n-            let err_inputs = err_args(args.len());\n-            check_argument_types(fcx, sp, err_inputs.as_slice(), callee_expr,\n-                                 args, deref_args, false);\n-            method_fn_ty\n-        } else {\n-            match ty::get(method_fn_ty).sty {\n-                ty::ty_bare_fn(ref fty) => {\n-                    // HACK(eddyb) ignore self in the definition (see above).\n-                    check_argument_types(fcx, sp, fty.sig.inputs.slice_from(1),\n-                                         callee_expr, args, deref_args,\n-                                         fty.sig.variadic);\n-                    fty.sig.output\n-                }\n-                _ => {\n-                    fcx.tcx().sess.span_bug(callee_expr.span,\n-                                            \"method without bare fn type\");\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_argument_types(fcx: &FnCtxt,\n-                            sp: Span,\n-                            fn_inputs: &[ty::t],\n-                            callee_expr: &ast::Expr,\n-                            args: &[@ast::Expr],\n-                            deref_args: DerefArgs,\n-                            variadic: bool) {\n-        /*!\n-         *\n-         * Generic function that factors out common logic from\n-         * function calls, method calls and overloaded operators.\n-         */\n-\n-        let tcx = fcx.ccx.tcx;\n-\n-        // Grab the argument types, supplying fresh type variables\n-        // if the wrong number of arguments were supplied\n-        let supplied_arg_count = args.len();\n-        let expected_arg_count = fn_inputs.len();\n-        let formal_tys = if expected_arg_count == supplied_arg_count {\n-            fn_inputs.iter().map(|a| *a).collect()\n-        } else if variadic {\n-            if supplied_arg_count >= expected_arg_count {\n-                fn_inputs.iter().map(|a| *a).collect()\n-            } else {\n-                let msg = format!(\n-                    \"this function takes at least {nexpected, plural, =1{# parameter} \\\n-                                                                   other{# parameters}} \\\n-                     but {nsupplied, plural, =1{# parameter was} \\\n-                                          other{# parameters were}} supplied\",\n-                     nexpected = expected_arg_count,\n-                     nsupplied = supplied_arg_count);\n-\n-                tcx.sess.span_err(sp, msg.as_slice());\n-\n-                err_args(supplied_arg_count)\n-            }\n-        } else {\n-            let msg = format!(\n-                \"this function takes {nexpected, plural, =1{# parameter} \\\n-                                                      other{# parameters}} \\\n-                 but {nsupplied, plural, =1{# parameter was} \\\n-                                      other{# parameters were}} supplied\",\n-                 nexpected = expected_arg_count,\n-                 nsupplied = supplied_arg_count);\n-\n-            tcx.sess.span_err(sp, msg.as_slice());\n-\n-            err_args(supplied_arg_count)\n-        };\n-\n-        debug!(\"check_argument_types: formal_tys={:?}\",\n-               formal_tys.iter().map(|t| fcx.infcx().ty_to_str(*t)).collect::<Vec<String>>());\n-\n-        // Check the arguments.\n-        // We do this in a pretty awful way: first we typecheck any arguments\n-        // that are not anonymous functions, then we typecheck the anonymous\n-        // functions. This is so that we have more information about the types\n-        // of arguments when we typecheck the functions. This isn't really the\n-        // right way to do this.\n-        let xs = [false, true];\n-        for check_blocks in xs.iter() {\n-            let check_blocks = *check_blocks;\n-            debug!(\"check_blocks={}\", check_blocks);\n-\n-            // More awful hacks: before we check the blocks, try to do\n-            // an \"opportunistic\" vtable resolution of any trait\n-            // bounds on the call.\n-            if check_blocks {\n-                vtable::early_resolve_expr(callee_expr, fcx, true);\n-            }\n-\n-            // For variadic functions, we don't have a declared type for all of\n-            // the arguments hence we only do our usual type checking with\n-            // the arguments who's types we do know.\n-            let t = if variadic {\n-                expected_arg_count\n-            } else {\n-                supplied_arg_count\n-            };\n-            for (i, arg) in args.iter().take(t).enumerate() {\n-                let is_block = match arg.node {\n-                    ast::ExprFnBlock(..) |\n-                    ast::ExprProc(..) => true,\n-                    _ => false\n-                };\n-\n-                if is_block == check_blocks {\n-                    debug!(\"checking the argument\");\n-                    let mut formal_ty = *formal_tys.get(i);\n-\n-                    match deref_args {\n-                        DoDerefArgs => {\n-                            match ty::get(formal_ty).sty {\n-                                ty::ty_rptr(_, mt) => formal_ty = mt.ty,\n-                                ty::ty_err => (),\n-                                _ => {\n-                                    // So we hit this case when one implements the\n-                                    // operator traits but leaves an argument as\n-                                    // just T instead of &T. We'll catch it in the\n-                                    // mismatch impl/trait method phase no need to\n-                                    // ICE here.\n-                                    // See: #11450\n-                                    formal_ty = ty::mk_err();\n-                                }\n-                            }\n-                        }\n-                        DontDerefArgs => {}\n-                    }\n-\n-                    check_expr_coercable_to_type(fcx, *arg, formal_ty);\n-\n-                }\n-            }\n-        }\n-\n-        // We also need to make sure we at least write the ty of the other\n-        // arguments which we skipped above.\n-        if variadic {\n-            for arg in args.iter().skip(expected_arg_count) {\n-                check_expr(fcx, *arg);\n-\n-                // There are a few types which get autopromoted when passed via varargs\n-                // in C but we just error out instead and require explicit casts.\n-                let arg_ty = structurally_resolved_type(fcx, arg.span, fcx.expr_ty(*arg));\n-                match ty::get(arg_ty).sty {\n-                    ty::ty_float(ast::TyF32) => {\n-                        fcx.type_error_message(arg.span,\n-                                               |t| {\n-                            format!(\"can't pass an {} to variadic \\\n-                                     function, cast to c_double\", t)\n-                        }, arg_ty, None);\n-                    }\n-                    ty::ty_int(ast::TyI8) | ty::ty_int(ast::TyI16) | ty::ty_bool => {\n-                        fcx.type_error_message(arg.span, |t| {\n-                            format!(\"can't pass {} to variadic \\\n-                                     function, cast to c_int\",\n-                                           t)\n-                        }, arg_ty, None);\n-                    }\n-                    ty::ty_uint(ast::TyU8) | ty::ty_uint(ast::TyU16) => {\n-                        fcx.type_error_message(arg.span, |t| {\n-                            format!(\"can't pass {} to variadic \\\n-                                     function, cast to c_uint\",\n-                                           t)\n-                        }, arg_ty, None);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-    }\n-\n-    fn err_args(len: uint) -> Vec<ty::t> {\n-        Vec::from_fn(len, |_| ty::mk_err())\n-    }\n-\n-    fn write_call(fcx: &FnCtxt, call_expr: &ast::Expr, output: ty::t) {\n-        fcx.write_ty(call_expr.id, output);\n-    }\n-\n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: &FnCtxt,\n                   call_expr: &ast::Expr,\n                   f: &ast::Expr,\n                   args: &[@ast::Expr]) {\n-        // Index expressions need to be handled separately, to inform them\n-        // that they appear in call position.\n-        check_expr(fcx, f);\n-\n         // Store the type of `f` as the type of the callee\n         let fn_ty = fcx.expr_ty(f);\n \n@@ -1939,8 +2075,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         });\n \n         // Call the generic checker.\n-        check_argument_types(fcx, call_expr.span, fn_sig.inputs.as_slice(), f,\n-                             args, DontDerefArgs, fn_sig.variadic);\n+        check_argument_types(fcx,\n+                             call_expr.span,\n+                             fn_sig.inputs.as_slice(),\n+                             f,\n+                             args,\n+                             DontDerefArgs,\n+                             fn_sig.variadic,\n+                             DontTupleArguments);\n \n         write_call(fcx, call_expr, fn_sig.output);\n     }\n@@ -2008,9 +2150,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         };\n \n         // Call the generic checker.\n-        let ret_ty = check_method_argument_types(fcx, method_name.span,\n-                                                 fn_ty, expr, args,\n-                                                 DontDerefArgs);\n+        let ret_ty = check_method_argument_types(fcx,\n+                                                 method_name.span,\n+                                                 fn_ty,\n+                                                 expr,\n+                                                 args,\n+                                                 DontDerefArgs,\n+                                                 DontTupleArguments);\n \n         write_call(fcx, expr, ret_ty);\n     }\n@@ -2078,18 +2224,26 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 // HACK(eddyb) Fully qualified path to work around a resolve bug.\n                 let method_call = ::middle::typeck::MethodCall::expr(op_ex.id);\n                 fcx.inh.method_map.borrow_mut().insert(method_call, method);\n-                check_method_argument_types(fcx, op_ex.span,\n-                                            method_ty, op_ex,\n-                                            args, DoDerefArgs)\n+                check_method_argument_types(fcx,\n+                                            op_ex.span,\n+                                            method_ty,\n+                                            op_ex,\n+                                            args,\n+                                            DoDerefArgs,\n+                                            DontTupleArguments)\n             }\n             None => {\n                 unbound_method();\n                 // Check the args anyway\n                 // so we get all the error messages\n                 let expected_ty = ty::mk_err();\n-                check_method_argument_types(fcx, op_ex.span,\n-                                            expected_ty, op_ex,\n-                                            args, DoDerefArgs);\n+                check_method_argument_types(fcx,\n+                                            op_ex.span,\n+                                            expected_ty,\n+                                            op_ex,\n+                                            args,\n+                                            DoDerefArgs,\n+                                            DontTupleArguments);\n                 ty::mk_err()\n             }\n         }\n@@ -3045,19 +3199,25 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n       ast::ExprCall(f, ref args) => {\n-          check_call(fcx, expr, f, args.as_slice());\n+          // Index expressions need to be handled separately, to inform them\n+          // that they appear in call position.\n+          check_expr(fcx, f);\n           let f_ty = fcx.expr_ty(f);\n-          let (args_bot, args_err) = args.iter().fold((false, false),\n-             |(rest_bot, rest_err), a| {\n-                 // is this not working?\n-                 let a_ty = fcx.expr_ty(*a);\n-                 (rest_bot || ty::type_is_bot(a_ty),\n-                  rest_err || ty::type_is_error(a_ty))});\n-          if ty::type_is_error(f_ty) || args_err {\n-              fcx.write_error(id);\n-          }\n-          else if ty::type_is_bot(f_ty) || args_bot {\n-              fcx.write_bot(id);\n+\n+          if !try_overloaded_call(fcx, expr, f, f_ty, args.as_slice()) {\n+              check_call(fcx, expr, f, args.as_slice());\n+              let (args_bot, args_err) = args.iter().fold((false, false),\n+                 |(rest_bot, rest_err), a| {\n+                     // is this not working?\n+                     let a_ty = fcx.expr_ty(*a);\n+                     (rest_bot || ty::type_is_bot(a_ty),\n+                      rest_err || ty::type_is_error(a_ty))});\n+              if ty::type_is_error(f_ty) || args_err {\n+                  fcx.write_error(id);\n+              }\n+              else if ty::type_is_bot(f_ty) || args_bot {\n+                  fcx.write_bot(id);\n+              }\n           }\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {"}, {"sha": "d3ddbcf5b38a412dd01627182cc8cd630be72f1b", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=966c7346cae89cf47017bfbf27e383d0b0351d82", "patch": "@@ -442,13 +442,15 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n     match expr.node {\n         ast::ExprCall(callee, ref args) => {\n-            constrain_callee(rcx, callee.id, expr, callee);\n-            constrain_call(rcx,\n-                           Some(callee.id),\n-                           expr,\n-                           None,\n-                           args.as_slice(),\n-                           false);\n+            if !has_method_map {\n+                constrain_callee(rcx, callee.id, expr, callee);\n+                constrain_call(rcx,\n+                               Some(callee.id),\n+                               expr,\n+                               None,\n+                               args.as_slice(),\n+                               false);\n+            }\n \n             visit::walk_expr(rcx, expr, ());\n         }"}, {"sha": "3c03c8747572005826d6d08c796b648329aad4b3", "filename": "src/test/compile-fail/overloaded-calls-bad.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs?ref=966c7346cae89cf47017bfbf27e383d0b0351d82", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(overloaded_calls)]\n+\n+use std::ops::FnMut;\n+\n+struct S {\n+    x: int,\n+    y: int,\n+}\n+\n+impl FnMut<(int,),int> for S {\n+    fn call_mut(&mut self, (z,): (int,)) -> int {\n+        self.x * self.y * z\n+    }\n+}\n+\n+fn main() {\n+    let mut s = S {\n+        x: 3,\n+        y: 3,\n+    };\n+    let ans = s(\"what\");    //~ ERROR mismatched types\n+    let ans = s();  //~ ERROR this function takes 1 parameter but 0 parameters were supplied\n+    let ans = s(\"burma\", \"shave\");\n+    //~^ ERROR this function takes 1 parameter but 2 parameters were supplied\n+}"}, {"sha": "9bbc4ab3ba3b33a8e665e0a826c6236465e7660f", "filename": "src/test/compile-fail/overloaded-calls-nontuple.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs?ref=966c7346cae89cf47017bfbf27e383d0b0351d82", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(overloaded_calls)]\n+\n+use std::ops::FnMut;\n+\n+struct S {\n+    x: int,\n+    y: int,\n+}\n+\n+impl FnMut<int,int> for S {\n+    fn call_mut(&mut self, z: int) -> int {\n+        self.x + self.y + z\n+    }\n+}\n+\n+fn main() {\n+    let mut s = S {\n+        x: 1,\n+        y: 2,\n+    };\n+    drop(s(3))  //~ ERROR cannot use call notation\n+}\n+"}, {"sha": "33120defedd8d9d67588bd96f38f0461a967b8d0", "filename": "src/test/run-pass/overloaded-calls-simple.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs?ref=966c7346cae89cf47017bfbf27e383d0b0351d82", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(overloaded_calls)]\n+\n+use std::ops::{Fn, FnMut, FnOnce};\n+\n+struct S1 {\n+    x: int,\n+    y: int,\n+}\n+\n+impl FnMut<(int,),int> for S1 {\n+    fn call_mut(&mut self, (z,): (int,)) -> int {\n+        self.x * self.y * z\n+    }\n+}\n+\n+struct S2 {\n+    x: int,\n+    y: int,\n+}\n+\n+impl Fn<(int,),int> for S2 {\n+    fn call(&self, (z,): (int,)) -> int {\n+        self.x * self.y * z\n+    }\n+}\n+\n+struct S3 {\n+    x: int,\n+    y: int,\n+}\n+\n+impl FnOnce<(int,int),int> for S3 {\n+    fn call_once(self, (z,zz): (int,int)) -> int {\n+        self.x * self.y * z * zz\n+    }\n+}\n+\n+fn main() {\n+    let mut s = S1 {\n+        x: 3,\n+        y: 3,\n+    };\n+    let ans = s(3);\n+    assert_eq!(ans, 27);\n+\n+    let s = S2 {\n+        x: 3,\n+        y: 3,\n+    };\n+    let ans = s(3);\n+    assert_eq!(ans, 27);\n+\n+    let s = S3 {\n+        x: 3,\n+        y: 3,\n+    };\n+    let ans = s(3, 1);\n+    assert_eq!(ans, 27);\n+}\n+"}, {"sha": "f8f7df6b49b339ba9ebf3e185d0d131c4f1307a3", "filename": "src/test/run-pass/overloaded-calls-zero-args.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966c7346cae89cf47017bfbf27e383d0b0351d82/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs?ref=966c7346cae89cf47017bfbf27e383d0b0351d82", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(overloaded_calls)]\n+\n+use std::ops::{FnMut};\n+\n+struct S {\n+    x: int,\n+    y: int,\n+}\n+\n+impl FnMut<(),int> for S {\n+    fn call_mut(&mut self, (): ()) -> int {\n+        self.x * self.y\n+    }\n+}\n+\n+fn main() {\n+    let mut s = S {\n+        x: 3,\n+        y: 3,\n+    };\n+    let ans = s();\n+    assert_eq!(ans, 9);\n+}\n+\n+"}]}