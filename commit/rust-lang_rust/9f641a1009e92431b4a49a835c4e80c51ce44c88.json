{"sha": "9f641a1009e92431b4a49a835c4e80c51ce44c88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNjQxYTEwMDllOTI0MzFiNGE0OWE4MzVjNGU4MGM1MWNlNDRjODg=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-13T00:19:27Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-13T00:19:27Z"}, "message": "Add known enums to SINGLE_MATCH", "tree": {"sha": "54332616a1d82943332f6a5574d3e76b56692010", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54332616a1d82943332f6a5574d3e76b56692010"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f641a1009e92431b4a49a835c4e80c51ce44c88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f641a1009e92431b4a49a835c4e80c51ce44c88", "html_url": "https://github.com/rust-lang/rust/commit/9f641a1009e92431b4a49a835c4e80c51ce44c88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f641a1009e92431b4a49a835c4e80c51ce44c88/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5009f8e1505ca4e6b113be3046093127477f14db", "url": "https://api.github.com/repos/rust-lang/rust/commits/5009f8e1505ca4e6b113be3046093127477f14db", "html_url": "https://github.com/rust-lang/rust/commit/5009f8e1505ca4e6b113be3046093127477f14db"}], "stats": {"total": 103, "additions": 94, "deletions": 9}, "files": [{"sha": "217c4abf45b136f878c88c7e030ce572fbb21dd0", "filename": "src/matches.rs", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9f641a1009e92431b4a49a835c4e80c51ce44c88/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f641a1009e92431b4a49a835c4e80c51ce44c88/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=9f641a1009e92431b4a49a835c4e80c51ce44c88", "patch": "@@ -8,7 +8,8 @@ use std::cmp::Ordering;\n use syntax::ast::Lit_::LitBool;\n use syntax::codemap::Span;\n \n-use utils::{snippet, span_lint, span_note_and_lint, span_help_and_lint, in_external_macro, expr_block};\n+use utils::{COW_PATH, OPTION_PATH, RESULT_PATH};\n+use utils::{match_type, snippet, span_lint, span_note_and_lint, span_help_and_lint, in_external_macro, expr_block};\n \n /// **What it does:** This lint checks for matches with a single arm where an `if let` will usually suffice. It is `Warn` by default.\n ///\n@@ -109,9 +110,20 @@ impl LateLintPass for MatchPass {\n }\n \n fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n-    if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none() && arms[1].pats.len() == 1 &&\n-       arms[1].guard.is_none() && arms[1].pats[0].node == PatWild && is_unit_expr(&arms[1].body) &&\n-       (cx.tcx.expr_ty(ex).sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow) {\n+    if arms.len() == 2 &&\n+       arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+       arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n+       is_unit_expr(&arms[1].body) {\n+           let ty = cx.tcx.expr_ty(ex);\n+           if ty.sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow {\n+                check_single_match_single_pattern(cx, ex, arms, expr);\n+                check_single_match_opt_like(cx, ex, arms, expr, ty);\n+           }\n+    }\n+}\n+\n+fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+    if arms[1].pats[0].node == PatWild {\n         span_help_and_lint(cx,\n                            SINGLE_MATCH,\n                            expr.span,\n@@ -124,6 +136,39 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     }\n }\n \n+fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: ty::Ty) {\n+    // list of candidate Enums we know will never get any more membre\n+    let candidates = &[\n+        (&COW_PATH, \"Borrowed\"),\n+        (&COW_PATH, \"Cow::Borrowed\"),\n+        (&COW_PATH, \"Cow::Owned\"),\n+        (&COW_PATH, \"Owned\"),\n+        (&OPTION_PATH, \"None\"),\n+        (&RESULT_PATH, \"Err\"),\n+        (&RESULT_PATH, \"Ok\"),\n+    ];\n+\n+    let path = match arms[1].pats[0].node {\n+        PatEnum(ref path, _) => path.to_string(),\n+        PatIdent(BindByValue(MutImmutable), ident, None) => ident.node.to_string(),\n+        _ => return\n+    };\n+\n+    for &(ty_path, pat_path) in candidates {\n+        if &path == pat_path && match_type(cx, ty, ty_path) {\n+            span_help_and_lint(cx,\n+                               SINGLE_MATCH,\n+                               expr.span,\n+                               \"you seem to be trying to use match for destructuring a single pattern. Consider using \\\n+                                `if let`\",\n+                               &format!(\"try\\nif let {} = {} {}\",\n+                                        snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                        snippet(cx, ex.span, \"..\"),\n+                                        expr_block(cx, &arms[0].body, None, \"..\")));\n+        }\n+    }\n+}\n+\n fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     // type of expression == bool\n     if cx.tcx.expr_ty(ex).sty == ty::TyBool {"}, {"sha": "77e63fe4458a43d385c7812b678fa7d7e621f78a", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f641a1009e92431b4a49a835c4e80c51ce44c88/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f641a1009e92431b4a49a835c4e80c51ce44c88/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=9f641a1009e92431b4a49a835c4e80c51ce44c88", "patch": "@@ -29,6 +29,7 @@ pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const MUTEX_PATH: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n pub const CLONE_PATH: [&'static str; 2] = [\"Clone\", \"clone\"];\n pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n+pub const COW_PATH: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///"}, {"sha": "c58e62419c6b7cd866dbf267efdd890af01db1f5", "filename": "tests/compile-fail/matches.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9f641a1009e92431b4a49a835c4e80c51ce44c88/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f641a1009e92431b4a49a835c4e80c51ce44c88/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=9f641a1009e92431b4a49a835c4e80c51ce44c88", "patch": "@@ -4,20 +4,22 @@\n #![deny(clippy)]\n #![allow(unused)]\n \n+use std::borrow::Cow;\n+\n+enum Foo { Bar, Baz(u8) }\n+use Foo::*;\n+\n fn single_match(){\n     let x = Some(1u8);\n+\n     match x {  //~ ERROR you seem to be trying to use match\n                //~^ HELP try\n         Some(y) => {\n             println!(\"{:?}\", y);\n         }\n         _ => ()\n     }\n-    // Not linted\n-    match x {\n-        Some(y) => println!(\"{:?}\", y),\n-        None => ()\n-    }\n+\n     let z = (1u8,1u8);\n     match z { //~ ERROR you seem to be trying to use match\n               //~^ HELP try\n@@ -38,6 +40,43 @@ fn single_match(){\n     }\n }\n \n+fn single_match_know_enum() {\n+    let x = Some(1u8);\n+    let y : Result<_, i8> = Ok(1i8);\n+\n+    match x { //~ ERROR you seem to be trying to use match\n+              //~^ HELP try\n+        Some(y) => println!(\"{:?}\", y),\n+        None => ()\n+    }\n+\n+    match y { //~ ERROR you seem to be trying to use match\n+              //~^ HELP try\n+        Ok(y) => println!(\"{:?}\", y),\n+        Err(..) => ()\n+    }\n+\n+    let c = Cow::Borrowed(\"\");\n+\n+    match c { //~ ERROR you seem to be trying to use match\n+              //~^ HELP try\n+        Cow::Borrowed(..) => println!(\"42\"),\n+        Cow::Owned(..) => (),\n+    }\n+\n+    let z = Foo::Bar;\n+    // no warning\n+    match z {\n+        Bar => println!(\"42\"),\n+        Baz(_) => (),\n+    }\n+\n+    match z {\n+        Baz(_) => println!(\"42\"),\n+        Bar => (),\n+    }\n+}\n+\n fn match_bool() {\n     let test: bool = true;\n "}]}