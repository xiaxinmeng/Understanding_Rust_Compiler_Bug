{"sha": "c3c5de1b98e1a96289ffd73881e6489805202f4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYzVkZTFiOThlMWE5NjI4OWZmZDczODgxZTY0ODk4MDUyMDJmNGQ=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-10-03T00:38:23Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-10-03T00:38:23Z"}, "message": "Rollup merge of #28812 - steveklabnik:improve_str_from_utf8_docs, r=brson\n\nOur docs were very basic for the various versions of from_utf8, so\r\nthis commit beefs them up.\r\n\r\nIt also improves docs for the &str variant's error, Utf8Error.", "tree": {"sha": "12f393dff773069d6836eae80358df7ffb6aaa2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12f393dff773069d6836eae80358df7ffb6aaa2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3c5de1b98e1a96289ffd73881e6489805202f4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3c5de1b98e1a96289ffd73881e6489805202f4d", "html_url": "https://github.com/rust-lang/rust/commit/c3c5de1b98e1a96289ffd73881e6489805202f4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3c5de1b98e1a96289ffd73881e6489805202f4d/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c5837e0ce44af6e103e169b92457f2a95bf00f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c5837e0ce44af6e103e169b92457f2a95bf00f5", "html_url": "https://github.com/rust-lang/rust/commit/9c5837e0ce44af6e103e169b92457f2a95bf00f5"}, {"sha": "4d73da92f0e6d00025609e42b1e7f59f00b73be9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d73da92f0e6d00025609e42b1e7f59f00b73be9", "html_url": "https://github.com/rust-lang/rust/commit/4d73da92f0e6d00025609e42b1e7f59f00b73be9"}], "stats": {"total": 253, "additions": 230, "deletions": 23}, "files": [{"sha": "271dbffcc2e41217342112f0d12cb6109730a109", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 111, "deletions": 18, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/c3c5de1b98e1a96289ffd73881e6489805202f4d/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3c5de1b98e1a96289ffd73881e6489805202f4d/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=c3c5de1b98e1a96289ffd73881e6489805202f4d", "patch": "@@ -92,26 +92,61 @@ impl String {\n         panic!(\"not available with cfg(test)\");\n     }\n \n-    /// Returns the vector as a string buffer, if possible, taking care not to\n-    /// copy it.\n+    /// Converts a vector of bytes to a `String`.\n+    ///\n+    /// A string slice (`&str`) is made of bytes (`u8`), and a vector of bytes\n+    /// (`Vec<u8>`) is made of bytes, so this function converts between the\n+    /// two. Not all byte slices are valid `String`s, however: `String`\n+    /// requires that it is valid UTF-8. `from_utf8()` checks to ensure that\n+    /// the bytes are valid UTF-8, and then does the conversion.\n+    ///\n+    /// If you are sure that the byte slice is valid UTF-8, and you don't want\n+    /// to incur the overhead of the validity check, there is an unsafe version\n+    /// of this function, [`from_utf8_unchecked()`][fromutf8], which has the\n+    /// same behavior but skips the check.\n+    ///\n+    /// [fromutf8]: struct.String.html#method.from_utf8_unchecked\n+    ///\n+    /// This method will take care to not copy the vector, for efficiency's\n+    /// sake.\n+    ///\n+    /// If you need a `&str` instead of a `String`, consider\n+    /// [`str::from_utf8()`][str].\n+    ///\n+    /// [str]: ../str/fn.from_utf8.html\n     ///\n     /// # Failure\n     ///\n-    /// If the given vector is not valid UTF-8, then the original vector and the\n-    /// corresponding error is returned.\n+    /// Returns `Err` if the slice is not UTF-8 with a description as to why the\n+    /// provided bytes are not UTF-8. The vector you moved in is also included.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let hello_vec = vec![104, 101, 108, 108, 111];\n-    /// let s = String::from_utf8(hello_vec).unwrap();\n-    /// assert_eq!(s, \"hello\");\n-    ///\n-    /// let invalid_vec = vec![240, 144, 128];\n-    /// let s = String::from_utf8(invalid_vec).err().unwrap();\n-    /// let err = s.utf8_error();\n-    /// assert_eq!(s.into_bytes(), [240, 144, 128]);\n+    /// // some bytes, in a vector\n+    /// let sparkle_heart = vec![240, 159, 146, 150];\n+    ///\n+    /// // We know these bytes are valid, so just use `unwrap()`.\n+    /// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n+    ///\n+    /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n     /// ```\n+    ///\n+    /// Incorrect bytes:\n+    ///\n+    /// ```\n+    /// // some invalid bytes, in a vector\n+    /// let sparkle_heart = vec![0, 159, 146, 150];\n+    ///\n+    /// assert!(String::from_utf8(sparkle_heart).is_err());\n+    /// ```\n+    ///\n+    /// See the docs for [`FromUtf8Error`][error] for more details on what you\n+    /// can do with this error.\n+    ///\n+    /// [error]: struct.FromUtf8Error.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n@@ -121,15 +156,49 @@ impl String {\n         }\n     }\n \n-    /// Converts a vector of bytes to a new UTF-8 string.\n-    /// Any invalid UTF-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    /// Converts a slice of bytes to a `String`, including invalid characters.\n+    ///\n+    /// A string slice (`&str`) is made of bytes (`u8`), and a slice of bytes\n+    /// (`&[u8]`) is made of bytes, so this function converts between the two.\n+    /// Not all byte slices are valid string slices, however: `&str` requires\n+    /// that it is valid UTF-8. During this conversion, `from_utf8_lossy()`\n+    /// will replace any invalid UTF-8 sequences with\n+    /// `U+FFFD REPLACEMENT CHARACTER`, which looks like this: \ufffd\n+    ///\n+    /// If you are sure that the byte slice is valid UTF-8, and you don't want\n+    /// to incur the overhead of the conversion, there is an unsafe version\n+    /// of this function, [`from_utf8_unchecked()`][fromutf8], which has the\n+    /// same behavior but skips the checks.\n+    ///\n+    /// [fromutf8]: struct.String.html#method.from_utf8_unchecked\n+    ///\n+    /// If you need a `&str` instead of a `String`, consider\n+    /// [`str::from_utf8()`][str].\n+    ///\n+    /// [str]: ../str/fn.from_utf8.html\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // some bytes, in a vector\n+    /// let sparkle_heart = vec![240, 159, 146, 150];\n+    ///\n+    /// // We know these bytes are valid, so just use `unwrap()`.\n+    /// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n+    ///\n+    /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n     /// ```\n+    ///\n+    /// Incorrect bytes:\n+    ///\n+    /// ```\n+    /// // some invalid bytes\n     /// let input = b\"Hello \\xF0\\x90\\x80World\";\n     /// let output = String::from_utf8_lossy(input);\n-    /// assert_eq!(output, \"Hello \\u{FFFD}World\");\n+    ///\n+    /// assert_eq!(\"Hello \ufffdWorld\", output);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> Cow<'a, str> {\n@@ -309,9 +378,33 @@ impl String {\n         }\n     }\n \n-    /// Converts a vector of bytes to a new `String` without checking if\n-    /// it contains valid UTF-8. This is unsafe because it assumes that\n-    /// the UTF-8-ness of the vector has already been validated.\n+    /// Converts a vector of bytes to a `String` without checking that the\n+    /// string contains valid UTF-8.\n+    ///\n+    /// See the safe version, [`from_utrf8()`][fromutf8], for more.\n+    ///\n+    /// [fromutf8]: struct.String.html#method.from_utf8\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because it does not check that the bytes passed to\n+    /// it are valid UTF-8. If this constraint is violated, undefined behavior\n+    /// results, as the rest of Rust assumes that `String`s are valid UTF-8.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // some bytes, in a vector\n+    /// let sparkle_heart = vec![240, 159, 146, 150];\n+    ///\n+    /// let sparkle_heart = unsafe {\n+    ///     String::from_utf8_unchecked(sparkle_heart)\n+    /// };\n+    ///\n+    /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {"}, {"sha": "9f1439ea3880767d7362a70dffac610db1eae723", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 119, "deletions": 5, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c3c5de1b98e1a96289ffd73881e6489805202f4d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3c5de1b98e1a96289ffd73881e6489805202f4d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c3c5de1b98e1a96289ffd73881e6489805202f4d", "patch": "@@ -119,7 +119,11 @@ impl fmt::Display for ParseBoolError {\n Section: Creating a string\n */\n \n-/// Errors which can occur when attempting to interpret a byte slice as a `str`.\n+/// Errors which can occur when attempting to interpret a sequence of `u8`\n+/// as a string.\n+///\n+/// As such, the `from_utf8` family of functions and methods for both `String`s\n+/// and `&str`s make use of this error, for example.\n #[derive(Copy, Eq, PartialEq, Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Utf8Error {\n@@ -132,21 +136,104 @@ impl Utf8Error {\n     ///\n     /// It is the maximum index such that `from_utf8(input[..index])`\n     /// would return `Some(_)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(utf8_error)]\n+    ///\n+    /// use std::str;\n+    ///\n+    /// // some invalid bytes, in a vector\n+    /// let sparkle_heart = vec![0, 159, 146, 150];\n+    ///\n+    /// // std::str::from_utf8 returns a Utf8Error\n+    /// let error = str::from_utf8(&sparkle_heart).unwrap_err();\n+    ///\n+    /// // the first byte is invalid here\n+    /// assert_eq!(1, error.valid_up_to());\n+    /// ```\n     #[unstable(feature = \"utf8_error\", reason = \"method just added\",\n                issue = \"27734\")]\n     pub fn valid_up_to(&self) -> usize { self.valid_up_to }\n }\n \n-/// Converts a slice of bytes to a string slice without performing any\n-/// allocations.\n+/// Converts a slice of bytes to a string slice.\n ///\n-/// Once the slice has been validated as UTF-8, it is transmuted in-place and\n-/// returned as a '&str' instead of a '&[u8]'\n+/// A string slice (`&str`) is made of bytes (`u8`), and a byte slice (`&[u8]`)\n+/// is made of bytes, so this function converts between the two. Not all byte\n+/// slices are valid string slices, however: `&str` requires that it is valid\n+/// UTF-8. `from_utf8()` checks to ensure that the bytes are valid UTF-8, and\n+/// then does the conversion.\n+///\n+/// If you are sure that the byte slice is valid UTF-8, and you don't want to\n+/// incur the overhead of the validity check, there is an unsafe version of\n+/// this function, [`from_utf8_unchecked()`][fromutf8], which has the same\n+/// behavior but skips the check.\n+///\n+/// [fromutf8]: fn.from_utf8.html\n+///\n+/// If you need a `String` instead of a `&str`, consider\n+/// [`String::from_utf8()`][string].\n+///\n+/// [string]: ../string/struct.String.html#method.from_utf8\n+///\n+/// Because you can stack-allocate a `[u8; N]`, and you can take a `&[u8]` of\n+/// it, this function is one way to have a stack-allocated string. There is\n+/// an example of this in the examples section below.\n ///\n /// # Failure\n ///\n /// Returns `Err` if the slice is not UTF-8 with a description as to why the\n /// provided slice is not UTF-8.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some bytes, in a vector\n+/// let sparkle_heart = vec![240, 159, 146, 150];\n+///\n+/// // We know these bytes are valid, so just use `unwrap()`.\n+/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n+///\n+/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+/// ```\n+///\n+/// Incorrect bytes:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some invalid bytes, in a vector\n+/// let sparkle_heart = vec![0, 159, 146, 150];\n+///\n+/// assert!(str::from_utf8(&sparkle_heart).is_err());\n+/// ```\n+///\n+/// See the docs for [`Utf8Error`][error] for more details on the kinds of\n+/// errors that can be returned.\n+///\n+/// [error]: struct.Utf8Error.html\n+///\n+/// A \"stack allocated string\":\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some bytes, in a stack-allocated array\n+/// let sparkle_heart = [240, 159, 146, 150];\n+///\n+/// // We know these bytes are valid, so just use `unwrap()`.\n+/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n+///\n+/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     try!(run_utf8_validation_iterator(&mut v.iter()));\n@@ -155,6 +242,33 @@ pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n \n /// Converts a slice of bytes to a string slice without checking\n /// that the string contains valid UTF-8.\n+///\n+/// See the safe version, [`from_utrf8()`][fromutf8], for more.\n+///\n+/// [fromutf8]: fn.from_utf8.html\n+///\n+/// # Unsafety\n+///\n+/// This function is unsafe because it does not check that the bytes passed to\n+/// it are valid UTF-8. If this constraint is violated, undefined behavior\n+/// results, as the rest of Rust assumes that `&str`s are valid UTF-8.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some bytes, in a vector\n+/// let sparkle_heart = vec![240, 159, 146, 150];\n+///\n+/// let sparkle_heart = unsafe {\n+///     str::from_utf8_unchecked(&sparkle_heart)\n+/// };\n+///\n+/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+/// ```\n #[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {"}]}