{"sha": "c94d479a90ab4e99926ac218d1b2329056c7e04b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NGQ0NzlhOTBhYjRlOTk5MjZhYzIxOGQxYjIzMjkwNTZjN2UwNGI=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-09-19T21:01:48Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-09-22T21:54:10Z"}, "message": "die 'managed'", "tree": {"sha": "0deb9434188b72ce4d68d112b2e3552dab32f3fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0deb9434188b72ce4d68d112b2e3552dab32f3fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c94d479a90ab4e99926ac218d1b2329056c7e04b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c94d479a90ab4e99926ac218d1b2329056c7e04b", "html_url": "https://github.com/rust-lang/rust/commit/c94d479a90ab4e99926ac218d1b2329056c7e04b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c94d479a90ab4e99926ac218d1b2329056c7e04b/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84bd6bba45997aca9b1bd9f55d3f2b5c949c7b77", "url": "https://api.github.com/repos/rust-lang/rust/commits/84bd6bba45997aca9b1bd9f55d3f2b5c949c7b77", "html_url": "https://github.com/rust-lang/rust/commit/84bd6bba45997aca9b1bd9f55d3f2b5c949c7b77"}], "stats": {"total": 48, "additions": 14, "deletions": 34}, "files": [{"sha": "82d17066aa88cd1df093fcae41cb1b6fb8eba2b3", "filename": "src/doc/reference.md", "status": "modified", "additions": 14, "deletions": 34, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c94d479a90ab4e99926ac218d1b2329056c7e04b/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/c94d479a90ab4e99926ac218d1b2329056c7e04b/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=c94d479a90ab4e99926ac218d1b2329056c7e04b", "patch": "@@ -1144,9 +1144,9 @@ standard library.\n Rust's type system is a conservative approximation of the dynamic safety\n requirements, so in some cases there is a performance cost to using safe code.\n For example, a doubly-linked list is not a tree structure and can only be\n-represented with managed or reference-counted pointers in safe code. By using\n-`unsafe` blocks to represent the reverse links as raw pointers, it can be\n-implemented with only owned pointers.\n+represented with reference-counted pointers in safe code. By using `unsafe`\n+blocks to represent the reverse links as raw pointers, it can be implemented\n+with only boxes.\n \n ##### Behavior considered unsafe\n \n@@ -2216,8 +2216,6 @@ These types help drive the compiler's analysis\n \n * `begin_unwind`\n   : ___Needs filling in___\n-* `managed_bound`\n-  : This type implements \"managed\"\n * `no_copy_bound`\n   : This type does not implement \"copy\", even if eligible\n * `no_send_bound`\n@@ -2242,8 +2240,6 @@ These types help drive the compiler's analysis\n   : ___Needs filling in___\n * `exchange_heap`\n   : ___Needs filling in___\n-* `managed_heap`\n-  : ___Needs filling in___\n * `iterator`\n   : ___Needs filling in___\n * `contravariant_lifetime`\n@@ -2472,13 +2468,6 @@ The currently implemented features of the reference compiler are:\n                   likely to change slightly in the future, so they are\n                   currently hidden behind this feature.\n \n-* `managed_boxes` - Usage of `@` is gated due to many\n-                    planned changes to this feature. In the past, this has\n-                    meant \"a GC pointer\", but the current implementation uses\n-                    reference counting and will likely change drastically over\n-                    time. Additionally, the `@` syntax will no longer be used\n-                    to create GC boxes.\n-\n * `non_ascii_idents` - The compiler supports the use of non-ascii identifiers,\n                        but the implementation is a little rough around the\n                        edges, so this can be seen as an experimental feature\n@@ -3949,33 +3938,24 @@ A task's _stack_ consists of activation frames automatically allocated on entry\n to each function as the task executes. A stack allocation is reclaimed when\n control leaves the frame containing it.\n \n-The _heap_ is a general term that describes two separate sets of boxes: managed\n-boxes &mdash; which may be subject to garbage collection &mdash; and boxes. The\n-lifetime of an allocation in the heap depends on the lifetime of the box values\n-pointing to it. Since box values may themselves be passed in and out of frames,\n-or stored in the heap, heap allocations may outlive the frame they are\n-allocated within.\n+The _heap_ is a general term that describes boxes.  The lifetime of an\n+allocation in the heap depends on the lifetime of the box values pointing to\n+it. Since box values may themselves be passed in and out of frames, or stored\n+in the heap, heap allocations may outlive the frame they are allocated within.\n \n ### Memory ownership\n \n A task owns all memory it can *safely* reach through local variables, as well\n-as managed, boxes and references.\n+as boxes and references.\n \n When a task sends a value that has the `Send` trait to another task, it loses\n ownership of the value sent and can no longer refer to it. This is statically\n guaranteed by the combined use of \"move semantics\", and the compiler-checked\n _meaning_ of the `Send` trait: it is only instantiated for (transitively)\n-sendable kinds of data constructor and pointers, never including managed boxes\n-or references.\n+sendable kinds of data constructor and pointers, never including references.\n \n When a stack frame is exited, its local allocations are all released, and its\n-references to boxes (both managed and owned) are dropped.\n-\n-A managed box may (in the case of a recursive, mutable managed type) be cyclic;\n-in this case the release of memory inside the managed structure may be deferred\n-until task-local garbage collection can reclaim it. Code can ensure no such\n-delayed deallocation occurs by restricting itself to owned boxes and similar\n-unmanaged kinds of data.\n+references to boxes are dropped.\n \n When a task finishes, its stack is necessarily empty and it therefore has no\n references to any boxes; the remainder of its heap is immediately freed.\n@@ -4052,10 +4032,10 @@ races on memory are prohibited by the type system.\n \n When you wish to send data between tasks, the values are restricted to the\n [`Send` type-kind](#type-kinds). Restricting communication interfaces to this\n-kind ensures that no references or managed pointers move between tasks. Thus\n-access to an entire data structure can be mediated through its owning \"root\"\n-value; no further locking or copying is required to avoid data races within the\n-substructure of such a value.\n+kind ensures that no references move between tasks. Thus access to an entire\n+data structure can be mediated through its owning \"root\" value; no further\n+locking or copying is required to avoid data races within the substructure of\n+such a value.\n \n ### Task lifecycle\n "}]}