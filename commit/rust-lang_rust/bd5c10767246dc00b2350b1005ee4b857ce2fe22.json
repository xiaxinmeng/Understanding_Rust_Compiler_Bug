{"sha": "bd5c10767246dc00b2350b1005ee4b857ce2fe22", "node_id": "C_kwDOAAsO6NoAKGJkNWMxMDc2NzI0NmRjMDBiMjM1MGIxMDA1ZWU0Yjg1N2NlMmZlMjI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-16T19:12:34Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-20T16:32:29Z"}, "message": "Build jump table at runtime.", "tree": {"sha": "29881343bf4cafe17a6a5a74b6f678c9f88e4f7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29881343bf4cafe17a6a5a74b6f678c9f88e4f7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd5c10767246dc00b2350b1005ee4b857ce2fe22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd5c10767246dc00b2350b1005ee4b857ce2fe22", "html_url": "https://github.com/rust-lang/rust/commit/bd5c10767246dc00b2350b1005ee4b857ce2fe22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd5c10767246dc00b2350b1005ee4b857ce2fe22/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "url": "https://api.github.com/repos/rust-lang/rust/commits/602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "html_url": "https://github.com/rust-lang/rust/commit/602d3cbce3e6227ad7cd5c009c868c9e405a9f32"}], "stats": {"total": 241, "additions": 111, "deletions": 130}, "files": [{"sha": "eea320835685cd5066039057601fd3a6f7b4fb08", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=bd5c10767246dc00b2350b1005ee4b857ce2fe22", "patch": "@@ -838,7 +838,7 @@ pub fn create_global_ctxt<'tcx>(\n                 dep_graph,\n                 queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),\n                 queries.as_dyn(),\n-                &rustc_query_impl::QUERY_CALLBACKS,\n+                rustc_query_impl::query_callbacks(arena),\n                 crate_name,\n                 outputs,\n             )"}, {"sha": "420c500a7de22e427e34a3eb4f68795ba799c0ec", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=bd5c10767246dc00b2350b1005ee4b857ce2fe22", "patch": "@@ -100,6 +100,8 @@ macro_rules! arena_types {\n             // This is used to decode the &'tcx [Span] for InlineAsm's line_spans.\n             [decode] span: rustc_span::Span,\n             [decode] used_trait_imports: rustc_data_structures::fx::FxHashSet<rustc_hir::def_id::LocalDefId>,\n+\n+            [] dep_kind: rustc_middle::dep_graph::DepKindStruct,\n         ], $tcx);\n     )\n }"}, {"sha": "cd7bd56182dc28b7184718f807eb17af189914a0", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=bd5c10767246dc00b2350b1005ee4b857ce2fe22", "patch": "@@ -87,7 +87,7 @@ pub struct DepKindStruct {\n \n     /// Whether the query key can be recovered from the hashed fingerprint.\n     /// See [DepNodeParams] trait for the behaviour of each key type.\n-    pub fingerprint_style: fn() -> FingerprintStyle,\n+    pub fingerprint_style: FingerprintStyle,\n \n     /// The red/green evaluation system will try to mark a specific DepNode in the\n     /// dependency graph as green by recursively trying to mark the dependencies of\n@@ -131,10 +131,10 @@ pub struct DepKindStruct {\n     /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n     /// add it to the \"We don't have enough information to reconstruct...\" group in\n     /// the match below.\n-    pub force_from_dep_node: fn(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool,\n+    pub force_from_dep_node: Option<fn(tcx: TyCtxt<'_>, dep_node: DepNode) -> bool>,\n \n     /// Invoke a query to put the on-disk cached value in memory.\n-    pub try_load_from_on_disk_cache: fn(TyCtxt<'_>, &DepNode),\n+    pub try_load_from_on_disk_cache: Option<fn(TyCtxt<'_>, DepNode)>,\n }\n \n impl DepKind {\n@@ -145,8 +145,7 @@ impl DepKind {\n         if data.is_anon {\n             return FingerprintStyle::Opaque;\n         }\n-\n-        (data.fingerprint_style)()\n+        data.fingerprint_style\n     }\n }\n \n@@ -159,7 +158,7 @@ macro_rules! define_dep_nodes {\n     ) => (\n         #[macro_export]\n         macro_rules! make_dep_kind_array {\n-            ($mod:ident) => {[ $(($mod::$variant),)* ]};\n+            ($mod:ident) => {[ $($mod::$variant()),* ]};\n         }\n \n         /// This enum serves as an index into arrays built by `make_dep_kind_array`."}, {"sha": "79d7ca32f35553ba9e525404bd5b7f0cdda71e67", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=bd5c10767246dc00b2350b1005ee4b857ce2fe22", "patch": "@@ -100,7 +100,7 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n         self.query_kind(kind).is_eval_always\n     }\n \n-    fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n+    fn try_force_from_dep_node(&self, dep_node: DepNode) -> bool {\n         debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n \n         // We must avoid ever having to call `force_from_dep_node()` for a\n@@ -122,11 +122,18 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n         );\n \n         let cb = self.query_kind(dep_node.kind);\n-        (cb.force_from_dep_node)(*self, dep_node)\n+        if let Some(f) = cb.force_from_dep_node {\n+            f(*self, dep_node);\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n-    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode) {\n+    fn try_load_from_on_disk_cache(&self, dep_node: DepNode) {\n         let cb = self.query_kind(dep_node.kind);\n-        (cb.try_load_from_on_disk_cache)(*self, dep_node)\n+        if let Some(f) = cb.try_load_from_on_disk_cache {\n+            f(*self, dep_node)\n+        }\n     }\n }"}, {"sha": "8240273acad4cd89eb1bcabfff4defc8dbf00cf7", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=bd5c10767246dc00b2350b1005ee4b857ce2fe22", "patch": "@@ -1186,7 +1186,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn query_kind(self, k: DepKind) -> &'tcx DepKindStruct {\n+    crate fn query_kind(self, k: DepKind) -> &'tcx DepKindStruct {\n         &self.query_kinds[k as usize]\n     }\n "}, {"sha": "b216d78da945cd64921bd0f27571c5720b1f0bbf", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=bd5c10767246dc00b2350b1005ee4b857ce2fe22", "patch": "@@ -17,6 +17,7 @@ extern crate rustc_middle;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::DiagnosticBuilder;\n+use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::{self, DepKindStruct};\n use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_values};\n use rustc_middle::ty::query::{Providers, QueryEngine};"}, {"sha": "8c3fbb2071c043e46f2e93e7ccbdb745950ad3a6", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 70, "deletions": 59, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=bd5c10767246dc00b2350b1005ee4b857ce2fe22", "patch": "@@ -331,7 +331,7 @@ macro_rules! define_queries {\n             }\n         })*\n \n-        #[allow(non_upper_case_globals)]\n+        #[allow(nonstandard_style)]\n         pub mod query_callbacks {\n             use super::*;\n             use rustc_middle::dep_graph::DepNode;\n@@ -341,74 +341,83 @@ macro_rules! define_queries {\n             use rustc_query_system::dep_graph::FingerprintStyle;\n \n             // We use this for most things when incr. comp. is turned off.\n-            pub const Null: DepKindStruct = DepKindStruct {\n-                is_anon: false,\n-                is_eval_always: false,\n-\n-                fingerprint_style: || FingerprintStyle::Unit,\n-                force_from_dep_node: |_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node),\n-                try_load_from_on_disk_cache: |_, _| {},\n-            };\n-\n-            pub const TraitSelect: DepKindStruct = DepKindStruct {\n-                is_anon: true,\n-                is_eval_always: false,\n+            pub fn Null() -> DepKindStruct {\n+                DepKindStruct {\n+                    is_anon: false,\n+                    is_eval_always: false,\n+                    fingerprint_style: FingerprintStyle::Unit,\n+                    force_from_dep_node: Some(|_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node)),\n+                    try_load_from_on_disk_cache: None,\n+                }\n+            }\n \n-                fingerprint_style: || FingerprintStyle::Unit,\n-                force_from_dep_node: |_, _| false,\n-                try_load_from_on_disk_cache: |_, _| {},\n-            };\n+            pub fn TraitSelect() -> DepKindStruct {\n+                DepKindStruct {\n+                    is_anon: true,\n+                    is_eval_always: false,\n+                    fingerprint_style: FingerprintStyle::Unit,\n+                    force_from_dep_node: None,\n+                    try_load_from_on_disk_cache: None,\n+                }\n+            }\n \n-            pub const CompileCodegenUnit: DepKindStruct = DepKindStruct {\n-                is_anon: false,\n-                is_eval_always: false,\n+            pub fn CompileCodegenUnit() -> DepKindStruct {\n+                DepKindStruct {\n+                    is_anon: false,\n+                    is_eval_always: false,\n+                    fingerprint_style: FingerprintStyle::Opaque,\n+                    force_from_dep_node: None,\n+                    try_load_from_on_disk_cache: None,\n+                }\n+            }\n \n-                fingerprint_style: || FingerprintStyle::Opaque,\n-                force_from_dep_node: |_, _| false,\n-                try_load_from_on_disk_cache: |_, _| {},\n-            };\n+            pub fn CompileMonoItem() -> DepKindStruct {\n+                DepKindStruct {\n+                    is_anon: false,\n+                    is_eval_always: false,\n+                    fingerprint_style: FingerprintStyle::Opaque,\n+                    force_from_dep_node: None,\n+                    try_load_from_on_disk_cache: None,\n+                }\n+            }\n \n-            pub const CompileMonoItem: DepKindStruct = DepKindStruct {\n-                is_anon: false,\n-                is_eval_always: false,\n+            $(pub fn $name()-> DepKindStruct {\n+                let is_anon = is_anon!([$($modifiers)*]);\n+                let is_eval_always = is_eval_always!([$($modifiers)*]);\n \n-                fingerprint_style: || FingerprintStyle::Opaque,\n-                force_from_dep_node: |_, _| false,\n-                try_load_from_on_disk_cache: |_, _| {},\n-            };\n+                let fingerprint_style =\n+                    <query_keys::$name<'_> as DepNodeParams<TyCtxt<'_>>>::fingerprint_style();\n \n-            $(pub const $name: DepKindStruct = {\n-                const is_anon: bool = is_anon!([$($modifiers)*]);\n-                const is_eval_always: bool = is_eval_always!([$($modifiers)*]);\n+                if is_anon || !fingerprint_style.reconstructible() {\n+                    return DepKindStruct {\n+                        is_anon,\n+                        is_eval_always,\n+                        fingerprint_style,\n+                        force_from_dep_node: None,\n+                        try_load_from_on_disk_cache: None,\n+                    }\n+                }\n \n                 #[inline(always)]\n-                fn fingerprint_style() -> FingerprintStyle {\n-                    <query_keys::$name<'_> as DepNodeParams<TyCtxt<'_>>>\n-                        ::fingerprint_style()\n+                fn recover<'tcx>(tcx: TyCtxt<'tcx>, dep_node: DepNode) -> Option<query_keys::$name<'tcx>> {\n+                    <query_keys::$name<'_> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, &dep_node)\n                 }\n \n-                fn recover<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<query_keys::$name<'tcx>> {\n-                    <query_keys::$name<'_> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node)\n+                fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: DepNode) -> bool {\n+                    if let Some(key) = recover(tcx, dep_node) {\n+                        let tcx = QueryCtxt::from_tcx(tcx);\n+                        force_query::<queries::$name<'_>, _>(tcx, key, dep_node);\n+                        true\n+                    } else {\n+                        false\n+                    }\n                 }\n \n-                fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n-                    let tcx = QueryCtxt::from_tcx(tcx);\n-                    force_query::<queries::$name<'_>, _>(tcx, dep_node)\n-                }\n+                fn try_load_from_on_disk_cache(tcx: TyCtxt<'_>, dep_node: DepNode) {\n+                    debug_assert!(tcx.dep_graph.is_green(&dep_node));\n \n-                fn try_load_from_on_disk_cache(tcx: TyCtxt<'_>, dep_node: &DepNode) {\n+                    let key = recover(tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n                     let tcx = QueryCtxt::from_tcx(tcx);\n-                    if is_anon {\n-                        return\n-                    }\n-\n-                    if !fingerprint_style().reconstructible() {\n-                        return\n-                    }\n-\n-                    debug_assert!(tcx.dep_graph.is_green(dep_node));\n-\n-                    let key = recover(*tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n                     if queries::$name::cache_on_disk(tcx, &key, None) {\n                         let _ = tcx.$name(key);\n                     }\n@@ -418,13 +427,15 @@ macro_rules! define_queries {\n                     is_anon,\n                     is_eval_always,\n                     fingerprint_style,\n-                    force_from_dep_node,\n-                    try_load_from_on_disk_cache,\n+                    force_from_dep_node: Some(force_from_dep_node),\n+                    try_load_from_on_disk_cache: Some(try_load_from_on_disk_cache),\n                 }\n-            };)*\n+            })*\n         }\n \n-        pub static QUERY_CALLBACKS: &[DepKindStruct] = &make_dep_kind_array!(query_callbacks);\n+        pub fn query_callbacks<'tcx>(arena: &'tcx Arena<'tcx>) -> &'tcx [DepKindStruct] {\n+            arena.alloc_from_iter(make_dep_kind_array!(query_callbacks))\n+        }\n     }\n }\n "}, {"sha": "503907e26d269e35e314904e38d0c4b2167f0d83", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=bd5c10767246dc00b2350b1005ee4b857ce2fe22", "patch": "@@ -576,7 +576,7 @@ impl<K: DepKind> DepGraph<K> {\n             \"try_mark_previous_green({:?}) --- trying to force dependency {:?}\",\n             dep_node, dep_dep_node\n         );\n-        if !tcx.dep_context().try_force_from_dep_node(dep_dep_node) {\n+        if !tcx.dep_context().try_force_from_dep_node(*dep_dep_node) {\n             // The DepNode could not be forced.\n             debug!(\n                 \"try_mark_previous_green({:?}) - END - dependency {:?} could not be forced\",\n@@ -749,7 +749,7 @@ impl<K: DepKind> DepGraph<K> {\n             match data.colors.get(prev_index) {\n                 Some(DepNodeColor::Green(_)) => {\n                     let dep_node = data.previous.index_to_node(prev_index);\n-                    tcx.try_load_from_on_disk_cache(&dep_node);\n+                    tcx.try_load_from_on_disk_cache(dep_node);\n                 }\n                 None | Some(DepNodeColor::Red) => {\n                     // We can skip red nodes because a node can only be marked"}, {"sha": "047fc9f10cc2f0e1e7e61e3fa4190400186b6ae0", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=bd5c10767246dc00b2350b1005ee4b857ce2fe22", "patch": "@@ -39,10 +39,10 @@ pub trait DepContext: Copy {\n     fn fingerprint_style(&self, kind: Self::DepKind) -> FingerprintStyle;\n \n     /// Try to force a dep node to execute and see if it's green.\n-    fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n+    fn try_force_from_dep_node(&self, dep_node: DepNode<Self::DepKind>) -> bool;\n \n     /// Load data from the on-disk cache.\n-    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode<Self::DepKind>);\n+    fn try_load_from_on_disk_cache(&self, dep_node: DepNode<Self::DepKind>);\n }\n \n pub trait HasDepContext: Copy {"}, {"sha": "d6fc4a669e75a55adc6dd4346ce314b5a9119aef", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 16, "deletions": 55, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5c10767246dc00b2350b1005ee4b857ce2fe22/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=bd5c10767246dc00b2350b1005ee4b857ce2fe22", "patch": "@@ -665,41 +665,6 @@ where\n     }\n }\n \n-#[inline(never)]\n-fn force_query_impl<CTX, C>(\n-    tcx: CTX,\n-    state: &QueryState<CTX::DepKind, C::Key>,\n-    cache: &QueryCacheStore<C>,\n-    key: C::Key,\n-    dep_node: DepNode<CTX::DepKind>,\n-    query: &QueryVtable<CTX, C::Key, C::Value>,\n-    compute: fn(CTX::DepContext, C::Key) -> C::Value,\n-) -> bool\n-where\n-    C: QueryCache,\n-    C::Key: DepNodeParams<CTX::DepContext>,\n-    CTX: QueryContext,\n-{\n-    debug_assert!(!query.anon);\n-\n-    // We may be concurrently trying both execute and force a query.\n-    // Ensure that only one of them runs the query.\n-    let cached = cache.cache.lookup(cache, &key, |_, index| {\n-        if unlikely!(tcx.dep_context().profiler().enabled()) {\n-            tcx.dep_context().profiler().query_cache_hit(index.into());\n-        }\n-    });\n-\n-    let lookup = match cached {\n-        Ok(()) => return true,\n-        Err(lookup) => lookup,\n-    };\n-\n-    let _ =\n-        try_execute_query(tcx, state, cache, DUMMY_SP, key, lookup, Some(dep_node), query, compute);\n-    true\n-}\n-\n pub enum QueryMode {\n     Get,\n     Ensure,\n@@ -747,34 +712,30 @@ where\n     Some(result)\n }\n \n-pub fn force_query<Q, CTX>(tcx: CTX, dep_node: &DepNode<CTX::DepKind>) -> bool\n+pub fn force_query<Q, CTX>(tcx: CTX, key: Q::Key, dep_node: DepNode<CTX::DepKind>)\n where\n     Q: QueryDescription<CTX>,\n     Q::Key: DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n-    if Q::ANON {\n-        return false;\n-    }\n+    let query = &Q::VTABLE;\n+    debug_assert!(!Q::ANON);\n \n-    if !<Q::Key as DepNodeParams<CTX::DepContext>>::fingerprint_style().reconstructible() {\n-        return false;\n-    }\n+    // We may be concurrently trying both execute and force a query.\n+    // Ensure that only one of them runs the query.\n+    let cache = Q::query_cache(tcx);\n+    let cached = cache.cache.lookup(cache, &key, |_, index| {\n+        if unlikely!(tcx.dep_context().profiler().enabled()) {\n+            tcx.dep_context().profiler().query_cache_hit(index.into());\n+        }\n+    });\n \n-    let Some(key) =\n-        <Q::Key as DepNodeParams<CTX::DepContext>>::recover(*tcx.dep_context(), &dep_node)\n-    else {\n-        return false;\n+    let lookup = match cached {\n+        Ok(()) => return,\n+        Err(lookup) => lookup,\n     };\n \n     let compute = Q::compute_fn(tcx, &key);\n-    force_query_impl(\n-        tcx,\n-        Q::query_state(tcx),\n-        Q::query_cache(tcx),\n-        key,\n-        *dep_node,\n-        &Q::VTABLE,\n-        compute,\n-    )\n+    let state = Q::query_state(tcx);\n+    try_execute_query(tcx, state, cache, DUMMY_SP, key, lookup, Some(dep_node), query, compute);\n }"}]}