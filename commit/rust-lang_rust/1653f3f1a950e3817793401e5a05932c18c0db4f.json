{"sha": "1653f3f1a950e3817793401e5a05932c18c0db4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NTNmM2YxYTk1MGUzODE3NzkzNDAxZTVhMDU5MzJjMThjMGRiNGY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-31T22:33:40Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-02T17:39:13Z"}, "message": "Implement test that pretty-printed code converges. Issue #789", "tree": {"sha": "22dd1bff0f59c74570fb992f921ffa3a068444c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22dd1bff0f59c74570fb992f921ffa3a068444c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1653f3f1a950e3817793401e5a05932c18c0db4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1653f3f1a950e3817793401e5a05932c18c0db4f", "html_url": "https://github.com/rust-lang/rust/commit/1653f3f1a950e3817793401e5a05932c18c0db4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1653f3f1a950e3817793401e5a05932c18c0db4f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4828d8f73f80b6966f460a129b43930c53bc2b38", "url": "https://api.github.com/repos/rust-lang/rust/commits/4828d8f73f80b6966f460a129b43930c53bc2b38", "html_url": "https://github.com/rust-lang/rust/commit/4828d8f73f80b6966f460a129b43930c53bc2b38"}], "stats": {"total": 111, "additions": 101, "deletions": 10}, "files": [{"sha": "582e093e6f13ee0c9d21e0ea3457e6822edb60ed", "filename": "src/test/compiletest/procsrv.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1653f3f1a950e3817793401e5a05932c18c0db4f/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1653f3f1a950e3817793401e5a05932c18c0db4f/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fprocsrv.rs?ref=1653f3f1a950e3817793401e5a05932c18c0db4f", "patch": "@@ -26,9 +26,12 @@ type reqchan = chan[request];\n \n type handle = {task: option::t[task], chan: reqchan};\n \n-tag request { exec(str, str, str[], chan[response]); stop; }\n+tag request {\n+    exec(str, str, str[], chan[response]);\n+    stop;\n+}\n \n-type response = {pid: int, outfd: int, errfd: int};\n+type response = {pid: int, infd: int, outfd: int, errfd: int};\n \n fn mk() -> handle {\n     let setupport = port();\n@@ -50,7 +53,8 @@ fn close(handle: &handle) {\n     task::join(option::get(handle.task));\n }\n \n-fn run(handle: &handle, lib_path: &str, prog: &str, args: &vec[str]) ->\n+fn run(handle: &handle, lib_path: &str,\n+       prog: &str, args: &vec[str], input: &option::t[str]) ->\n {status: int, out: str, err: str} {\n     let p = port[response]();\n     let ch = chan(p);\n@@ -59,12 +63,24 @@ fn run(handle: &handle, lib_path: &str, prog: &str, args: &vec[str]) ->\n                                  clone_ivecstr(ivec::from_vec(args)),\n                                  task::clone_chan(ch)));\n     let resp = task::recv(p);\n+\n+    writeclose(resp.infd, input);\n     let output = readclose(resp.outfd);\n     let errput = readclose(resp.errfd);\n     let status = os::waitpid(resp.pid);\n     ret {status: status, out: output, err: errput};\n }\n \n+fn writeclose(fd: int, s: &option::t[str]) {\n+    if option::is_some(s) {\n+        let writer = io::new_writer(\n+            io::fd_buf_writer(fd, option::none));\n+        writer.write_str(option::get(s));\n+    }\n+\n+    os::libc::close(fd);\n+}\n+\n fn readclose(fd: int) -> str {\n     // Copied from run::program_output\n     let file = os::fd_FILE(fd);\n@@ -128,17 +144,20 @@ fn worker(p: port[request]) {\n                                     pipe_out.out,\n                                     pipe_err.out);\n         let pid = with_lib_path(execparms.lib_path, spawnproc);\n+\n         os::libc::close(pipe_in.in);\n-        os::libc::close(pipe_in.out);\n         os::libc::close(pipe_out.out);\n         os::libc::close(pipe_err.out);\n         if pid == -1 {\n+            os::libc::close(pipe_in.out);\n             os::libc::close(pipe_out.in);\n             os::libc::close(pipe_err.in);\n             fail;\n         }\n+\n         task::send(execparms.respchan,\n                    {pid: pid,\n+                    infd: pipe_in.out,\n                     outfd: pipe_out.in,\n                     errfd: pipe_err.in});\n     }"}, {"sha": "328b1e7f6cbb1e3a97edbe7438f2e5319e4e2a8f", "filename": "src/test/compiletest/runtest.rs", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1653f3f1a950e3817793401e5a05932c18c0db4f/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1653f3f1a950e3817793401e5a05932c18c0db4f/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=1653f3f1a950e3817793401e5a05932c18c0db4f", "patch": "@@ -75,6 +75,74 @@ fn run_rpass_test(cx: &cx, props: &test_props, testfile: &str) {\n }\n \n fn run_pretty_test(cx: &cx, props: &test_props, testfile: &str) {\n+    const rounds: int = 2;\n+\n+    let srcs = ~[str::unsafe_from_bytes(\n+        io::file_reader(testfile).read_whole_stream())];\n+\n+    let round = 0;\n+    while round < rounds {\n+        logv(cx.config, #fmt(\"pretty-printing round %d\", round));\n+        let procres = print_source(cx, testfile, srcs.(round));\n+\n+        if procres.status != 0 {\n+            fatal_procres(#fmt(\"pretty-printing failed in round %d\", round),\n+                          procres);\n+        }\n+\n+        srcs += ~[procres.stdout];\n+        round += 1;\n+    }\n+\n+    let expected = srcs.(ivec::len(srcs) - 2u);\n+    let actual = srcs.(ivec::len(srcs) - 1u);\n+\n+    compare_source(expected, actual);\n+\n+    // Finally, let's make sure it actually appears to remain valid code\n+    let procres = typecheck_source(cx, actual);\n+\n+    if procres.status != 0 {\n+        fatal_procres(\"pretty-printed source does not typecheck\",\n+                      procres);\n+    }\n+\n+    ret;\n+\n+    fn print_source(cx: &cx, testfile: &str, src: &str) -> procres {\n+        compose_and_run(cx, testfile, make_pp_args,\n+                        cx.config.compile_lib_path, option::some(src))\n+    }\n+\n+    fn make_pp_args(config: &config, testfile: &str) -> procargs {\n+        let prog = config.rustc_path;\n+        let args = [\"-\", \"--pretty\", \"normal\"];\n+        ret {prog: prog, args: args};\n+    }\n+\n+    fn compare_source(expected: &str, actual: &str) {\n+        if expected != actual {\n+            error(\"pretty-printed source does not converge\");\n+            let msg = #fmt(\"\\n\\\n+expected:\\n\\\n+------------------------------------------\\n\\\n+%s\\n\\\n+------------------------------------------\\n\\\n+actual:\\n\\\n+------------------------------------------\\n\\\n+%s\\n\\\n+------------------------------------------\\n\\\n+\\n\",\n+                          expected, actual);\n+            io::stdout().write_str(msg);\n+            fail;\n+        }\n+    }\n+\n+    fn typecheck_source(cx: &cx, src: &str) -> procres {\n+        // FIXME\n+        ret {status: 0, stdout: src, stderr: \"\", cmdline: \"\"};\n+    }\n }\n \n fn check_error_patterns(props: &test_props, testfile: &str,\n@@ -117,19 +185,22 @@ type procres = {status: int, stdout: str, stderr: str, cmdline: str};\n \n fn compile_test(cx: &cx, props: &test_props, testfile: &str) -> procres {\n     compose_and_run(cx, testfile, bind make_compile_args(_, props, _),\n-                    cx.config.compile_lib_path)\n+                    cx.config.compile_lib_path, option::none)\n }\n \n fn exec_compiled_test(cx: &cx, testfile: &str) -> procres {\n-    compose_and_run(cx, testfile, make_run_args, cx.config.run_lib_path)\n+    compose_and_run(cx, testfile, make_run_args,\n+                    cx.config.run_lib_path, option::none)\n }\n \n fn compose_and_run(cx: &cx, testfile: &str,\n                    make_args: fn(&config, &str) -> procargs ,\n-                   lib_path: &str) -> procres {\n+                   lib_path: &str,\n+                   input: option::t[str]) -> procres {\n     let procargs = make_args(cx.config, testfile);\n     ret program_output(cx, testfile, lib_path,\n-                       procargs.prog, procargs.args);\n+                       procargs.prog, procargs.args,\n+                       input);\n }\n \n fn make_compile_args(config: &config,\n@@ -182,14 +253,15 @@ fn split_maybe_args(argstr: &option::t[str]) -> vec[str] {\n }\n \n fn program_output(cx: &cx, testfile: &str, lib_path: &str, prog: &str,\n-                  args: &vec[str]) -> procres {\n+                  args: &vec[str], input: option::t[str]) -> procres {\n     let cmdline =\n     {\n         let cmdline = make_cmdline(lib_path, prog, args);\n         logv(cx.config, #fmt(\"executing %s\", cmdline));\n         cmdline\n     };\n-    let res = procsrv::run(cx.procsrv, lib_path, prog, args);\n+    let res = procsrv::run(cx.procsrv, lib_path,\n+                           prog, args, input);\n     dump_output(cx.config, testfile, res.out, res.err);\n     ret {status: res.status, stdout: res.out,\n          stderr: res.err, cmdline: cmdline};"}]}