{"sha": "1c3fce41b67f13121742be7bf1ddceeed0825143", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjM2ZjZTQxYjY3ZjEzMTIxNzQyYmU3YmYxZGRjZWVlZDA4MjUxNDM=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-10-22T13:57:19Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-10-22T13:57:19Z"}, "message": "Rustup to *rustc 1.14.0-nightly (f09420685 2016-10-20)*", "tree": {"sha": "b0d0117a87878e5e1bd8f373514d4e628badbff5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0d0117a87878e5e1bd8f373514d4e628badbff5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c3fce41b67f13121742be7bf1ddceeed0825143", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJYC3BHAAoJEF5CfHlMukXoLCkQAMogDeEx5/MSlcjQQ3IG9Pum\nitvjfI60WCRMVnQFLbrTXoI1/DO5IEY/EhZRRo2hObTn8gekSohhdXRjZFAvccLS\nuyeZcgxq6gjpRhzFceo0A1q7ezzdZ5m4Rc9SmoQTQ8ZXCl1DpoAvuMipNEwbB2BU\nxtf3TSNJzdave09MLyKl4rqMnFZitNWuxO1p+uy2fGo/w/GElNj81MsP3SvWfL+r\nS0VOOA4zCd5fVrHcef76wLBxAjmmX+rzE1K0v22Bre6DmCi1Z4MzKbTPy2+yteRY\nPX5b0ubhVEJozIXbDEOwYsDRahuUTRG8bLtRs9U4uq0F5059DrEso7bs4Gs9SEuW\nFvy2v1twj6cTWHkpz+gBvYZMol1SFAzQAzduS5WrDi91poKlDbLNuS/CPbnfDC0N\nEf9u7lWvF3i/zMfajl6NV1G0Z8r64CGO4psUG5Cr7cAZH72mgEvvk6d0DjCDC4tu\n4993Q5vV2qLGGc3eFOh3Mg62tFP0GLshYt/vbG0H5pZhYfEZIQMbkWOi/qFpIjgA\nWSg1NavFsOlbQHrWoUiZDOoM8GFq38aM9owyI5iOI1RUra+I5CjyHbqmNcXL4KWW\nrTEGOGj5imB+5a23he+MyFEavIw9nxbQZMCToQCehhvwCeA0dNkiIBgQ1lQHQcAk\nACBp2i5Bq+GbjYt8TlIt\n=oVKE\n-----END PGP SIGNATURE-----", "payload": "tree b0d0117a87878e5e1bd8f373514d4e628badbff5\nparent 4cf87a9d494456e20bbc3beb6a9922d4281c6661\nauthor mcarton <cartonmartin+git@gmail.com> 1477144639 +0200\ncommitter mcarton <cartonmartin+git@gmail.com> 1477144639 +0200\n\nRustup to *rustc 1.14.0-nightly (f09420685 2016-10-20)*\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c3fce41b67f13121742be7bf1ddceeed0825143", "html_url": "https://github.com/rust-lang/rust/commit/1c3fce41b67f13121742be7bf1ddceeed0825143", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c3fce41b67f13121742be7bf1ddceeed0825143/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cf87a9d494456e20bbc3beb6a9922d4281c6661", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cf87a9d494456e20bbc3beb6a9922d4281c6661", "html_url": "https://github.com/rust-lang/rust/commit/4cf87a9d494456e20bbc3beb6a9922d4281c6661"}], "stats": {"total": 187, "additions": 101, "deletions": 86}, "files": [{"sha": "fbbbf497d5964bd22c9ec7fa60b6f197e168edfe", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=1c3fce41b67f13121742be7bf1ddceeed0825143", "patch": "@@ -6,8 +6,7 @@ use rustc::hir::*;\n use semver::Version;\n use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use syntax::codemap::Span;\n-use utils::{in_macro, match_path, span_lint, span_lint_and_then, snippet_opt};\n-use utils::paths;\n+use utils::{in_macro, match_def_path, resolve_node, paths, span_lint, span_lint_and_then, snippet_opt};\n \n /// **What it does:** Checks for items annotated with `#[inline(always)]`,\n /// unless the annotated function is empty or simply panics.\n@@ -101,7 +100,7 @@ impl LateLintPass for AttrPass {\n     }\n \n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        if is_relevant_item(item) {\n+        if is_relevant_item(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n         match item.node {\n@@ -140,62 +139,63 @@ impl LateLintPass for AttrPass {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n-        if is_relevant_impl(item) {\n+        if is_relevant_impl(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n-        if is_relevant_trait(item) {\n+        if is_relevant_trait(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n }\n \n-fn is_relevant_item(item: &Item) -> bool {\n+fn is_relevant_item(cx: &LateContext, item: &Item) -> bool {\n     if let ItemFn(_, _, _, _, _, ref block) = item.node {\n-        is_relevant_block(block)\n+        is_relevant_block(cx, block)\n     } else {\n         false\n     }\n }\n \n-fn is_relevant_impl(item: &ImplItem) -> bool {\n+fn is_relevant_impl(cx: &LateContext, item: &ImplItem) -> bool {\n     match item.node {\n-        ImplItemKind::Method(_, ref block) => is_relevant_block(block),\n+        ImplItemKind::Method(_, ref block) => is_relevant_block(cx, block),\n         _ => false,\n     }\n }\n \n-fn is_relevant_trait(item: &TraitItem) -> bool {\n+fn is_relevant_trait(cx: &LateContext, item: &TraitItem) -> bool {\n     match item.node {\n         MethodTraitItem(_, None) => true,\n-        MethodTraitItem(_, Some(ref block)) => is_relevant_block(block),\n+        MethodTraitItem(_, Some(ref block)) => is_relevant_block(cx, block),\n         _ => false,\n     }\n }\n \n-fn is_relevant_block(block: &Block) -> bool {\n+fn is_relevant_block(cx: &LateContext, block: &Block) -> bool {\n     for stmt in &block.stmts {\n         match stmt.node {\n             StmtDecl(_, _) => return true,\n             StmtExpr(ref expr, _) |\n             StmtSemi(ref expr, _) => {\n-                return is_relevant_expr(expr);\n+                return is_relevant_expr(cx, expr);\n             }\n         }\n     }\n-    block.expr.as_ref().map_or(false, |e| is_relevant_expr(e))\n+    block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, e))\n }\n \n-fn is_relevant_expr(expr: &Expr) -> bool {\n+fn is_relevant_expr(cx: &LateContext, expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBlock(ref block) => is_relevant_block(block),\n-        ExprRet(Some(ref e)) => is_relevant_expr(e),\n+        ExprBlock(ref block) => is_relevant_block(cx, block),\n+        ExprRet(Some(ref e)) => is_relevant_expr(cx, e),\n         ExprRet(None) | ExprBreak(_) => false,\n         ExprCall(ref path_expr, _) => {\n-            if let ExprPath(_, ref path) = path_expr.node {\n-                !match_path(path, &paths::BEGIN_PANIC)\n+            if let ExprPath(..) = path_expr.node {\n+                let fun_id = resolve_node(cx, path_expr.id).expect(\"function should be resolved\").def_id();\n+                !match_def_path(cx, fun_id, &paths::BEGIN_PANIC)\n             } else {\n                 true\n             }"}, {"sha": "6ed2d8190813707982e8de6c1f31e1f1b066c3f3", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=1c3fce41b67f13121742be7bf1ddceeed0825143", "patch": "@@ -4,7 +4,7 @@ use rustc::lint::*;\n use rustc::ty::TypeVariants;\n use syntax::ast::LitKind;\n use utils::paths;\n-use utils::{is_expn_of, match_path, match_type, span_lint, walk_ptrs_ty};\n+use utils::{is_expn_of, match_def_path, match_path, match_type, resolve_node, span_lint, walk_ptrs_ty};\n \n /// **What it does:** Checks for the use of `format!(\"string literal with no\n /// argument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n@@ -44,9 +44,10 @@ impl LateLintPass for Pass {\n                 // `format!(\"{}\", foo)` expansion\n                 ExprCall(ref fun, ref args) => {\n                     if_let_chain!{[\n-                        let ExprPath(_, ref path) = fun.node,\n+                        let ExprPath(..) = fun.node,\n                         args.len() == 2,\n-                        match_path(path, &paths::FMT_ARGUMENTS_NEWV1),\n+                        let Some(fun) = resolve_node(cx, fun.id),\n+                        match_def_path(cx, fun.def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n                         // ensure the format string is `\"{..}\"` with only one argument and no text\n                         check_static_str(cx, &args[0]),\n                         // ensure the format argument is `{}` ie. Display with no fancy option\n@@ -127,8 +128,9 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n         exprs.len() == 1,\n         let ExprCall(_, ref args) = exprs[0].node,\n         args.len() == 2,\n-        let ExprPath(None, ref path) = args[1].node,\n-        match_path(path, &paths::DISPLAY_FMT_METHOD)\n+        let ExprPath(None, _) = args[1].node,\n+        let Some(fun) = resolve_node(cx, args[1].id),\n+        match_def_path(cx, fun.def_id(), &paths::DISPLAY_FMT_METHOD),\n     ], {\n         let ty = walk_ptrs_ty(cx.tcx.pat_ty(&pat[0]));\n "}, {"sha": "14fe343d5a8f7e4bf6f046c96f408ab819091f5f", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=1c3fce41b67f13121742be7bf1ddceeed0825143", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n use syntax::ast::LitKind;\n-use utils::{is_direct_expn_of, match_path, paths, span_lint};\n+use utils::{is_direct_expn_of, match_def_path, resolve_node, paths, span_lint};\n \n /// **What it does:** Checks for missing parameters in `panic!`.\n ///\n@@ -39,8 +39,9 @@ impl LateLintPass for Pass {\n             let Some(ref ex) = block.expr,\n             let ExprCall(ref fun, ref params) = ex.node,\n             params.len() == 2,\n-            let ExprPath(None, ref path) = fun.node,\n-            match_path(path, &paths::BEGIN_PANIC),\n+            let ExprPath(None, _) = fun.node,\n+            let Some(fun) = resolve_node(cx, fun.id),\n+            match_def_path(cx, fun.def_id(), &paths::BEGIN_PANIC),\n             let ExprLit(ref lit) = params[0].node,\n             is_direct_expn_of(cx, params[0].span, \"panic\").is_some(),\n             let LitKind::Str(ref string, _) = lit.node,"}, {"sha": "46d38a67a863ca742bd477f4bc6d96ee7f80e992", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 55, "deletions": 49, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=1c3fce41b67f13121742be7bf1ddceeed0825143", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::*;\n use rustc::hir::map::Node::{NodeItem, NodeImplItem};\n use rustc::lint::*;\n use utils::paths;\n-use utils::{is_expn_of, match_path, span_lint};\n+use utils::{is_expn_of, match_path, match_def_path, resolve_node, span_lint};\n use format::get_argument_fmtstr_parts;\n \n /// **What it does:** This lint warns when you using `print!()` with a format string that\n@@ -67,63 +67,69 @@ impl LintPass for Pass {\n \n impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprCall(ref fun, ref args) = expr.node {\n-            if let ExprPath(_, ref path) = fun.node {\n-                // Search for `std::io::_print(..)` which is unique in a\n-                // `print!` expansion.\n-                if match_path(path, &paths::IO_PRINT) {\n-                    if let Some(span) = is_expn_of(cx, expr.span, \"print\") {\n-                        // `println!` uses `print!`.\n-                        let (span, name) = match is_expn_of(cx, span, \"println\") {\n-                            Some(span) => (span, \"println\"),\n-                            None => (span, \"print\"),\n-                        };\n+        if_let_chain! {[\n+            let ExprCall(ref fun, ref args) = expr.node,\n+            let ExprPath(..) = fun.node,\n+            let Some(fun) = resolve_node(cx, fun.id),\n+        ], {\n+            let fun_id = fun.def_id();\n \n-                        span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n+            // Search for `std::io::_print(..)` which is unique in a\n+            // `print!` expansion.\n+            if match_def_path(cx, fun_id, &paths::IO_PRINT) {\n+                if let Some(span) = is_expn_of(cx, expr.span, \"print\") {\n+                    // `println!` uses `print!`.\n+                    let (span, name) = match is_expn_of(cx, span, \"println\") {\n+                        Some(span) => (span, \"println\"),\n+                        None => (span, \"print\"),\n+                    };\n \n-                        // Check print! with format string ending in \"\\n\".\n-                        if_let_chain!{[\n-                            name == \"print\",\n+                    span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n \n-                            // ensure we're calling Arguments::new_v1\n-                            args.len() == 1,\n-                            let ExprCall(ref args_fun, ref args_args) = args[0].node,\n-                            let ExprPath(_, ref args_path) = args_fun.node,\n-                            match_path(args_path, &paths::FMT_ARGUMENTS_NEWV1),\n-                            args_args.len() == 2,\n-                            let ExprAddrOf(_, ref match_expr) = args_args[1].node,\n-                            let ExprMatch(ref args, _, _) = match_expr.node,\n-                            let ExprTup(ref args) = args.node,\n+                    // Check print! with format string ending in \"\\n\".\n+                    if_let_chain!{[\n+                        name == \"print\",\n \n-                            // collect the format string parts and check the last one\n-                            let Some(fmtstrs) = get_argument_fmtstr_parts(cx, &args_args[0]),\n-                            let Some(last_str) = fmtstrs.last(),\n-                            let Some('\\n') = last_str.chars().last(),\n+                        // ensure we're calling Arguments::new_v1\n+                        args.len() == 1,\n+                        let ExprCall(ref args_fun, ref args_args) = args[0].node,\n+                        let ExprPath(..) = args_fun.node,\n+                        let Some(def) = resolve_node(cx, args_fun.id),\n+                        match_def_path(cx, def.def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n+                        args_args.len() == 2,\n+                        let ExprAddrOf(_, ref match_expr) = args_args[1].node,\n+                        let ExprMatch(ref args, _, _) = match_expr.node,\n+                        let ExprTup(ref args) = args.node,\n \n-                            // \"foo{}bar\" is made into two strings + one argument,\n-                            // if the format string starts with `{}` (eg. \"{}foo\"),\n-                            // the string array is prepended an empty string \"\".\n-                            // We only want to check the last string after any `{}`:\n-                            args.len() < fmtstrs.len(),\n-                        ], {\n-                            span_lint(cx, PRINT_WITH_NEWLINE, span,\n-                                      \"using `print!()` with a format string that ends in a \\\n-                                       newline, consider using `println!()` instead\");\n-                        }}\n-                    }\n+                        // collect the format string parts and check the last one\n+                        let Some(fmtstrs) = get_argument_fmtstr_parts(cx, &args_args[0]),\n+                        let Some(last_str) = fmtstrs.last(),\n+                        let Some('\\n') = last_str.chars().last(),\n+\n+                        // \"foo{}bar\" is made into two strings + one argument,\n+                        // if the format string starts with `{}` (eg. \"{}foo\"),\n+                        // the string array is prepended an empty string \"\".\n+                        // We only want to check the last string after any `{}`:\n+                        args.len() < fmtstrs.len(),\n+                    ], {\n+                        span_lint(cx, PRINT_WITH_NEWLINE, span,\n+                                  \"using `print!()` with a format string that ends in a \\\n+                                   newline, consider using `println!()` instead\");\n+                    }}\n                 }\n-                // Search for something like\n-                // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n-                else if args.len() == 2 && match_path(path, &paths::FMT_ARGUMENTV1_NEW) {\n-                    if let ExprPath(None, ref path) = args[1].node {\n-                        if match_path(path, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) &&\n-                           is_expn_of(cx, expr.span, \"panic\").is_none() {\n-                            span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n-                        }\n+            }\n+            // Search for something like\n+            // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n+            else if args.len() == 2 && match_def_path(cx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n+                if let ExprPath(None, _) = args[1].node {\n+                    let def_id = resolve_node(cx, args[1].id).unwrap().def_id();\n+                    if match_def_path(cx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) &&\n+                       is_expn_of(cx, expr.span, \"panic\").is_none() {\n+                        span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n                     }\n                 }\n             }\n-        }\n+        }}\n     }\n }\n "}, {"sha": "d49cb7826aee40fd206b2c55319fdf1cf3a2305a", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=1c3fce41b67f13121742be7bf1ddceeed0825143", "patch": "@@ -6,7 +6,7 @@ use rustc::hir;\n use rustc::lint::LateContext;\n use syntax::ast;\n use syntax::ptr::P;\n-use utils::{is_expn_of, match_path, paths};\n+use utils::{is_expn_of, match_path, match_def_path, resolve_node, paths};\n \n /// Convert a hir binary operator to the corresponding `ast` type.\n pub fn binop(op: hir::BinOp_) -> ast::BinOpKind {\n@@ -170,9 +170,10 @@ pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e\n     if_let_chain!{[\n         let hir::ExprCall(ref fun, ref args) = expr.node,\n         let hir::ExprPath(_, ref path) = fun.node,\n-        is_expn_of(cx, fun.span, \"vec\").is_some()\n+        let Some(fun_def) = resolve_node(cx, fun.id),\n+        is_expn_of(cx, fun.span, \"vec\").is_some(),\n     ], {\n-        return if match_path(path, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n+        return if match_def_path(cx, fun_def.def_id(), &paths::VEC_FROM_ELEM) && args.len() == 2 {\n             // `vec![elem; size]` case\n             Some(VecArgs::Repeat(&args[0], &args[1]))\n         }"}, {"sha": "3e3b0b02ddd34e2ce7526518699ac48c34417bba", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=1c3fce41b67f13121742be7bf1ddceeed0825143", "patch": "@@ -279,6 +279,11 @@ pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>,\n     })\n }\n \n+/// Resolve the definition of a node from its `NodeId`.\n+pub fn resolve_node(cx: &LateContext, id: NodeId) -> Option<def::Def> {\n+    cx.tcx.def_map.borrow().get(&id).map(|d| d.full_def())\n+}\n+\n /// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n ///\n /// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,"}, {"sha": "f182ed161637d12d536a668184df32d7c0708041", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3fce41b67f13121742be7bf1ddceeed0825143/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=1c3fce41b67f13121742be7bf1ddceeed0825143", "patch": "@@ -1,6 +1,6 @@\n //! This module contains paths to types and functions Clippy needs to know about.\n \n-pub const BEGIN_PANIC: [&'static str; 3] = [\"std\", \"rt\", \"begin_panic\"];\n+pub const BEGIN_PANIC: [&'static str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n pub const BINARY_HEAP: [&'static str; 3] = [\"collections\", \"binary_heap\", \"BinaryHeap\"];\n pub const BOX: [&'static str; 3] = [\"std\", \"boxed\", \"Box\"];\n pub const BOX_NEW: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n@@ -13,18 +13,18 @@ pub const CMP_MAX: [&'static str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&'static str; 3] = [\"core\", \"cmp\", \"min\"];\n pub const COW: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n pub const CSTRING_NEW: [&'static str; 4] = [\"std\", \"ffi\", \"CString\", \"new\"];\n-pub const DEBUG_FMT_METHOD: [&'static str; 4] = [\"std\", \"fmt\", \"Debug\", \"fmt\"];\n+pub const DEBUG_FMT_METHOD: [&'static str; 4] = [\"core\", \"fmt\", \"Debug\", \"fmt\"];\n pub const DEFAULT_TRAIT: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n-pub const DISPLAY_FMT_METHOD: [&'static str; 4] = [\"std\", \"fmt\", \"Display\", \"fmt\"];\n+pub const DISPLAY_FMT_METHOD: [&'static str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n pub const DROP: [&'static str; 3] = [\"core\", \"mem\", \"drop\"];\n-pub const FMT_ARGUMENTS_NEWV1: [&'static str; 4] = [\"std\", \"fmt\", \"Arguments\", \"new_v1\"];\n-pub const FMT_ARGUMENTV1_NEW: [&'static str; 4] = [\"std\", \"fmt\", \"ArgumentV1\", \"new\"];\n+pub const FMT_ARGUMENTS_NEWV1: [&'static str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n+pub const FMT_ARGUMENTV1_NEW: [&'static str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const HASH: [&'static str; 2] = [\"hash\", \"Hash\"];\n pub const HASHMAP: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const HASHMAP_ENTRY: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHSET: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"];\n pub const INTO_ITERATOR: [&'static str; 4] = [\"core\", \"iter\", \"traits\", \"IntoIterator\"];\n-pub const IO_PRINT: [&'static str; 3] = [\"std\", \"io\", \"_print\"];\n+pub const IO_PRINT: [&'static str; 4] = [\"std\", \"io\", \"stdio\", \"_print\"];\n pub const ITERATOR: [&'static str; 4] = [\"core\", \"iter\", \"iterator\", \"Iterator\"];\n pub const LINKED_LIST: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n pub const LINT: [&'static str; 3] = [\"rustc\", \"lint\", \"Lint\"];\n@@ -64,4 +64,4 @@ pub const STRING: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const TRANSMUTE: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n pub const VEC: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n pub const VEC_DEQUE: [&'static str; 3] = [\"collections\", \"vec_deque\", \"VecDeque\"];\n-pub const VEC_FROM_ELEM: [&'static str; 3] = [\"std\", \"vec\", \"from_elem\"];\n+pub const VEC_FROM_ELEM: [&'static str; 3] = [\"collections\", \"vec\", \"from_elem\"];"}]}