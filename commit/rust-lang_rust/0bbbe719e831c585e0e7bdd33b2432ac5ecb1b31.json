{"sha": "0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYmJlNzE5ZTgzMWM1ODVlMGU3YmRkMzNiMjQzMmFjNWVjYjFiMzE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-08T20:14:02Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-03-15T13:22:58Z"}, "message": "Implement soundness check for min_specialization", "tree": {"sha": "c064664a25c5b66d470fe9c6b06bd7b2c47d84b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c064664a25c5b66d470fe9c6b06bd7b2c47d84b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "html_url": "https://github.com/rust-lang/rust/commit/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32d330df30c079c8d0bcdeff9049152a65c36b31", "url": "https://api.github.com/repos/rust-lang/rust/commits/32d330df30c079c8d0bcdeff9049152a65c36b31", "html_url": "https://github.com/rust-lang/rust/commit/32d330df30c079c8d0bcdeff9049152a65c36b31"}], "stats": {"total": 801, "additions": 796, "deletions": 5}, "files": [{"sha": "b16aa6ff3b2e4c41bc0473b04e8f452f388dc02d", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -79,10 +79,18 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     }\n \n     fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n-        if let ty::ConstKind::Param(data) = c.val {\n-            self.parameters.push(Parameter::from(data));\n+        match c.val {\n+            ty::ConstKind::Unevaluated(..) if !self.include_nonconstraining => {\n+                // Constant expressions are not injective\n+                return c.ty.visit_with(self);\n+            }\n+            ty::ConstKind::Param(data) => {\n+                self.parameters.push(Parameter::from(data));\n+            }\n+            _ => {}\n         }\n-        false\n+\n+        c.super_visit_with(self)\n     }\n }\n "}, {"sha": "7ee25bbede2c5794f689ed3e4c7e33e249b4bfda", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -9,16 +9,20 @@\n //! fixed, but for the moment it's easier to do these checks early.\n \n use crate::constrained_generic_params as cgp;\n+use min_specialization::check_min_specialization;\n+\n use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_span::Span;\n+\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n-use rustc_span::Span;\n+mod min_specialization;\n \n /// Checks that all the type/lifetime parameters on an impl also\n /// appear in the trait ref or self type (or are constrained by a\n@@ -60,7 +64,9 @@ pub fn impl_wf_check(tcx: TyCtxt<'_>) {\n }\n \n fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: DefId) {\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut ImplWfCheck { tcx });\n+    let min_specialization = tcx.features().min_specialization;\n+    tcx.hir()\n+        .visit_item_likes_in_module(module_def_id, &mut ImplWfCheck { tcx, min_specialization });\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n@@ -69,6 +75,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n \n struct ImplWfCheck<'tcx> {\n     tcx: TyCtxt<'tcx>,\n+    min_specialization: bool,\n }\n \n impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n@@ -77,6 +84,9 @@ impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n             let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             enforce_impl_params_are_constrained(self.tcx, impl_def_id, items);\n             enforce_impl_items_are_distinct(self.tcx, items);\n+            if self.min_specialization {\n+                check_min_specialization(self.tcx, impl_def_id, item.span);\n+            }\n         }\n     }\n "}, {"sha": "cd52dae5f9ca20a6ef38e13bff7674b5b33276bd", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,390 @@\n+//! # Minimal Specialization\n+//!\n+//! This module contains the checks for sound specialization used when the\n+//! `min_specialization` feature is enabled. This requires that the impl is\n+//! *always applicable*.\n+//!\n+//! If `impl1` specializes `impl2` then `impl1` is always applicable if we know\n+//! that all the bounds of `impl2` are satisfied, and all of the bounds of\n+//! `impl1` are satisfied for some choice of lifetimes then we know that\n+//! `impl1` applies for any choice of lifetimes.\n+//!\n+//! ## Basic approach\n+//!\n+//! To enforce this requirement on specializations we take the following\n+//! approach:\n+//!\n+//! 1. Match up the substs for `impl2` so that the implemented trait and\n+//!    self-type match those for `impl1`.\n+//! 2. Check for any direct use of `'static` in the substs of `impl2`.\n+//! 3. Check that all of the generic parameters of `impl1` occur at most once\n+//!    in the *unconstrained* substs for `impl2`. A parameter is constrained if\n+//!    its value is completely determined by an associated type projection\n+//!    predicate.\n+//! 4. Check that all predicates on `impl1` also exist on `impl2` (after\n+//!    matching substs).\n+//!\n+//! ## Example\n+//!\n+//! Suppose we have the following always applicable impl:\n+//!\n+//! ```rust\n+//! impl<T> SpecExtend<T> for std::vec::IntoIter<T> { /* specialized impl */ }\n+//! impl<T, I: Iterator<Item=T>> SpecExtend<T> for I { /* default impl */ }\n+//! ```\n+//!\n+//! We get that the subst for `impl2` are `[T, std::vec::IntoIter<T>]`. `T` is\n+//! constrained to be `<I as Iterator>::Item`, so we check only\n+//! `std::vec::IntoIter<T>` for repeated parameters, which it doesn't have. The\n+//! predicates of `impl1` are only `T: Sized`, which is also a predicate of\n+//! `impl2`. So this specialization is sound.\n+//!\n+//! ## Extensions\n+//!\n+//! Unfortunately not all specializations in the standard library are allowed\n+//! by this. So there are two extensions to these rules that allow specializing\n+//! on some traits: that is, using them as bounds on the specializing impl,\n+//! even when they don't occur in the base impl.\n+//!\n+//! ### rustc_specialization_trait\n+//!\n+//! If a trait is always applicable, then it's sound to specialize on it. We\n+//! check trait is always applicable in the same way as impls, except that step\n+//! 4 is now \"all predicates on `impl1` are always applicable\". We require that\n+//! `specialization` or `min_specialization` is enabled to implement these\n+//! traits.\n+//!\n+//! ### rustc_unsafe_specialization_marker\n+//!\n+//! There are also some specialization on traits with no methods, including the\n+//! stable `FusedIterator` trait. We allow marking marker traits with an\n+//! unstable attribute that means we ignore them in point 3 of the checks\n+//! above. This is unsound, in the sense that the specialized impl may be used\n+//! when it doesn't apply, but we allow it in the short term since it can't\n+//! cause use after frees with purely safe code in the same way as specializing\n+//! on traits with methods can.\n+\n+use crate::constrained_generic_params as cgp;\n+\n+use rustc::middle::region::ScopeTree;\n+use rustc::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n+use rustc::ty::trait_def::TraitSpecializationKind;\n+use rustc::ty::{self, InstantiatedPredicates, TyCtxt, TypeFoldable};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::{InferCtxt, SuppressRegionErrors, TyCtxtInferExt};\n+use rustc_infer::traits::specialization_graph::Node;\n+use rustc_span::Span;\n+use rustc_trait_selection::traits::{self, translate_substs, wf};\n+\n+pub(super) fn check_min_specialization(tcx: TyCtxt<'_>, impl_def_id: DefId, span: Span) {\n+    if let Some(node) = parent_specialization_node(tcx, impl_def_id) {\n+        tcx.infer_ctxt().enter(|infcx| {\n+            check_always_applicable(&infcx, impl_def_id, node, span);\n+        });\n+    }\n+}\n+\n+fn parent_specialization_node(tcx: TyCtxt<'_>, impl1_def_id: DefId) -> Option<Node> {\n+    let trait_ref = tcx.impl_trait_ref(impl1_def_id)?;\n+    let trait_def = tcx.trait_def(trait_ref.def_id);\n+\n+    let impl2_node = trait_def.ancestors(tcx, impl1_def_id).ok()?.nth(1)?;\n+\n+    let always_applicable_trait =\n+        matches!(trait_def.specialization_kind, TraitSpecializationKind::AlwaysApplicable);\n+    if impl2_node.is_from_trait() && !always_applicable_trait {\n+        // Implementing a normal trait isn't a specialization.\n+        return None;\n+    }\n+    Some(impl2_node)\n+}\n+\n+/// Check that `impl1` is a sound specialization\n+fn check_always_applicable(\n+    infcx: &InferCtxt<'_, '_>,\n+    impl1_def_id: DefId,\n+    impl2_node: Node,\n+    span: Span,\n+) {\n+    if let Some((impl1_substs, impl2_substs)) =\n+        get_impl_substs(infcx, impl1_def_id, impl2_node, span)\n+    {\n+        let impl2_def_id = impl2_node.def_id();\n+        debug!(\n+            \"check_always_applicable(\\nimpl1_def_id={:?},\\nimpl2_def_id={:?},\\nimpl2_substs={:?}\\n)\",\n+            impl1_def_id, impl2_def_id, impl2_substs\n+        );\n+\n+        let tcx = infcx.tcx;\n+\n+        let parent_substs = if impl2_node.is_from_trait() {\n+            impl2_substs.to_vec()\n+        } else {\n+            unconstrained_parent_impl_substs(tcx, impl2_def_id, impl2_substs)\n+        };\n+\n+        check_static_lifetimes(tcx, &parent_substs, span);\n+        check_duplicate_params(tcx, impl1_substs, &parent_substs, span);\n+\n+        check_predicates(tcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n+    }\n+}\n+\n+/// Given a specializing impl `impl1`, and the base impl `impl2`, returns two\n+/// substitutions `(S1, S2)` that equate their trait references. The returned\n+/// types are expressed in terms of the generics of `impl1`.\n+///\n+/// Example\n+///\n+/// impl<A, B> Foo<A> for B { /* impl2 */ }\n+/// impl<C> Foo<Vec<C>> for C { /* impl1 */ }\n+///\n+/// Would return `S1 = [C]` and `S2 = [Vec<C>, C]`.\n+fn get_impl_substs<'tcx>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    impl1_def_id: DefId,\n+    impl2_node: Node,\n+    span: Span,\n+) -> Option<(SubstsRef<'tcx>, SubstsRef<'tcx>)> {\n+    let tcx = infcx.tcx;\n+    let param_env = tcx.param_env(impl1_def_id);\n+\n+    let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id);\n+    let impl2_substs = translate_substs(infcx, param_env, impl1_def_id, impl1_substs, impl2_node);\n+\n+    // Conservatively use an empty `ParamEnv`.\n+    let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n+    infcx.resolve_regions_and_report_errors(\n+        impl1_def_id,\n+        &ScopeTree::default(),\n+        &outlives_env,\n+        SuppressRegionErrors::default(),\n+    );\n+    let impl2_substs = match infcx.fully_resolve(&impl2_substs) {\n+        Ok(s) => s,\n+        Err(_) => {\n+            tcx.sess.struct_span_err(span, \"could not resolve substs on overridden impl\").emit();\n+            return None;\n+        }\n+    };\n+    Some((impl1_substs, impl2_substs))\n+}\n+\n+/// Returns a list of all of the unconstrained subst of the given impl.\n+///\n+/// For example given the impl:\n+///\n+/// impl<'a, T, I> ... where &'a I: IntoIterator<Item=&'a T>\n+///\n+/// This would return the substs corresponding to `['a, I]`, because knowing\n+/// `'a` and `I` determines the value of `T`.\n+fn unconstrained_parent_impl_substs<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_def_id: DefId,\n+    impl_substs: SubstsRef<'tcx>,\n+) -> Vec<GenericArg<'tcx>> {\n+    let impl_generic_predicates = tcx.predicates_of(impl_def_id);\n+    let mut unconstrained_parameters = FxHashSet::default();\n+    let mut constrained_params = FxHashSet::default();\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n+\n+    // Unfortunately the functions in `constrained_generic_parameters` don't do\n+    // what we want here. We want only a list of constrained parameters while\n+    // the functions in `cgp` add the constrained parameters to a list of\n+    // unconstrained parameters.\n+    for (predicate, _) in impl_generic_predicates.predicates.iter() {\n+        if let ty::Predicate::Projection(proj) = predicate {\n+            let projection_ty = proj.skip_binder().projection_ty;\n+            let projected_ty = proj.skip_binder().ty;\n+\n+            let unbound_trait_ref = projection_ty.trait_ref(tcx);\n+            if Some(unbound_trait_ref) == impl_trait_ref {\n+                continue;\n+            }\n+\n+            unconstrained_parameters.extend(cgp::parameters_for(&projection_ty, true));\n+\n+            for param in cgp::parameters_for(&projected_ty, false) {\n+                if !unconstrained_parameters.contains(&param) {\n+                    constrained_params.insert(param.0);\n+                }\n+            }\n+\n+            unconstrained_parameters.extend(cgp::parameters_for(&projected_ty, true));\n+        }\n+    }\n+\n+    impl_substs\n+        .iter()\n+        .enumerate()\n+        .filter(|&(idx, _)| !constrained_params.contains(&(idx as u32)))\n+        .map(|(_, arg)| *arg)\n+        .collect()\n+}\n+\n+/// Check that parameters of the derived impl don't occur more than once in the\n+/// equated substs of the base impl.\n+///\n+/// For example forbid the following:\n+///\n+/// impl<A> Tr for A { }\n+/// impl<B> Tr for (B, B) { }\n+///\n+/// Note that only consider the unconstrained parameters of the base impl:\n+///\n+/// impl<S, I: IntoIterator<Item = S>> Tr<S> for I { }\n+/// impl<T> Tr<T> for Vec<T> { }\n+///\n+/// The substs for the parent impl here are `[T, Vec<T>]`, which repeats `T`,\n+/// but `S` is constrained in the parent impl, so `parent_substs` is only\n+/// `[Vec<T>]`. This means we allow this impl.\n+fn check_duplicate_params<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl1_substs: SubstsRef<'tcx>,\n+    parent_substs: &Vec<GenericArg<'tcx>>,\n+    span: Span,\n+) {\n+    let mut base_params = cgp::parameters_for(parent_substs, true);\n+    base_params.sort_by_key(|param| param.0);\n+    if let (_, [duplicate, ..]) = base_params.partition_dedup() {\n+        let param = impl1_substs[duplicate.0 as usize];\n+        tcx.sess\n+            .struct_span_err(span, &format!(\"specializing impl repeats parameter `{}`\", param))\n+            .emit();\n+    }\n+}\n+\n+/// Check that `'static` lifetimes are not introduced by the specializing impl.\n+///\n+/// For example forbid the following:\n+///\n+/// impl<A> Tr for A { }\n+/// impl Tr for &'static i32 { }\n+fn check_static_lifetimes<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    parent_substs: &Vec<GenericArg<'tcx>>,\n+    span: Span,\n+) {\n+    if tcx.any_free_region_meets(parent_substs, |r| *r == ty::ReStatic) {\n+        tcx.sess.struct_span_err(span, &format!(\"cannot specialize on `'static` lifetime\")).emit();\n+    }\n+}\n+\n+/// Check whether predicates on the specializing impl (`impl1`) are allowed.\n+///\n+/// Each predicate `P` must be:\n+///\n+/// * global (not reference any parameters)\n+/// * `T: Tr` predicate where `Tr` is an always-applicable trait\n+/// * on the base `impl impl2`\n+///     * Currently this check is done using syntactic equality, which is\n+///       conservative but generally sufficient.\n+fn check_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl1_def_id: DefId,\n+    impl1_substs: SubstsRef<'tcx>,\n+    impl2_node: Node,\n+    impl2_substs: SubstsRef<'tcx>,\n+    span: Span,\n+) {\n+    let impl1_predicates = tcx.predicates_of(impl1_def_id).instantiate(tcx, impl1_substs);\n+    let mut impl2_predicates = if impl2_node.is_from_trait() {\n+        // Always applicable traits have to be always applicable without any\n+        // assumptions.\n+        InstantiatedPredicates::empty()\n+    } else {\n+        tcx.predicates_of(impl2_node.def_id()).instantiate(tcx, impl2_substs)\n+    };\n+    debug!(\n+        \"check_always_applicable(\\nimpl1_predicates={:?},\\nimpl2_predicates={:?}\\n)\",\n+        impl1_predicates, impl2_predicates,\n+    );\n+\n+    // Since impls of always applicable traits don't get to assume anything, we\n+    // can also assume their supertraits apply.\n+    //\n+    // For example, we allow:\n+    //\n+    // #[rustc_specialization_trait]\n+    // trait AlwaysApplicable: Debug { }\n+    //\n+    // impl<T> Tr for T { }\n+    // impl<T: AlwaysApplicable> Tr for T { }\n+    //\n+    // Specializing on `AlwaysApplicable` allows also specializing on `Debug`\n+    // which is sound because we forbid impls like the following\n+    //\n+    // impl<D: Debug> AlwaysApplicable for D { }\n+    let always_applicable_traits: Vec<_> = impl1_predicates\n+        .predicates\n+        .iter()\n+        .filter(|predicate| {\n+            matches!(\n+                trait_predicate_kind(tcx, predicate),\n+                Some(TraitSpecializationKind::AlwaysApplicable)\n+            )\n+        })\n+        .copied()\n+        .collect();\n+    impl2_predicates.predicates.extend(traits::elaborate_predicates(tcx, always_applicable_traits));\n+\n+    for predicate in impl1_predicates.predicates {\n+        if !impl2_predicates.predicates.contains(&predicate) {\n+            check_specialization_on(tcx, &predicate, span)\n+        }\n+    }\n+}\n+\n+fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: &ty::Predicate<'tcx>, span: Span) {\n+    debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n+    match predicate {\n+        // Global predicates are either always true or always false, so we\n+        // are fine to specialize on.\n+        _ if predicate.is_global() => (),\n+        // We allow specializing on explicitly marked traits with no associated\n+        // items.\n+        ty::Predicate::Trait(pred, hir::Constness::NotConst) => {\n+            if !matches!(\n+                trait_predicate_kind(tcx, predicate),\n+                Some(TraitSpecializationKind::Marker)\n+            ) {\n+                tcx.sess\n+                    .struct_span_err(\n+                        span,\n+                        &format!(\n+                            \"cannot specialize on trait `{}`\",\n+                            tcx.def_path_str(pred.def_id()),\n+                        ),\n+                    )\n+                    .emit()\n+            }\n+        }\n+        _ => tcx\n+            .sess\n+            .struct_span_err(span, &format!(\"cannot specialize on `{:?}`\", predicate))\n+            .emit(),\n+    }\n+}\n+\n+fn trait_predicate_kind<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    predicate: &ty::Predicate<'tcx>,\n+) -> Option<TraitSpecializationKind> {\n+    match predicate {\n+        ty::Predicate::Trait(pred, hir::Constness::NotConst) => {\n+            Some(tcx.trait_def(pred.def_id()).specialization_kind)\n+        }\n+        ty::Predicate::Trait(_, hir::Constness::Const)\n+        | ty::Predicate::RegionOutlives(_)\n+        | ty::Predicate::TypeOutlives(_)\n+        | ty::Predicate::Projection(_)\n+        | ty::Predicate::WellFormed(_)\n+        | ty::Predicate::Subtype(_)\n+        | ty::Predicate::ObjectSafe(_)\n+        | ty::Predicate::ClosureKind(..)\n+        | ty::Predicate::ConstEvaluatable(..) => None,\n+    }\n+}"}, {"sha": "bab354cff7c9c7aa9ef6f37b7663e185f0bfb7b0", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -64,6 +64,7 @@ This API is completely unstable and subject to change.\n #![feature(nll)]\n #![feature(try_blocks)]\n #![feature(never_type)]\n+#![feature(slice_partition_dedup)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "03cab00b0fb965cf2680726b22b590e77d6f46fb", "filename": "src/test/ui/specialization/min_specialization/dyn-trait-assoc-types.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fdyn-trait-assoc-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fdyn-trait-assoc-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fdyn-trait-assoc-types.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,32 @@\n+// Test that associated types in trait objects are not considered to be\n+// constrained.\n+\n+#![feature(min_specialization)]\n+\n+trait Specializable {\n+    fn f();\n+}\n+\n+trait B<T> {\n+    type Y;\n+}\n+\n+trait C {\n+    type Y;\n+}\n+\n+impl<A: ?Sized> Specializable for A {\n+    default fn f() {}\n+}\n+\n+impl<'a, T> Specializable for dyn B<T, Y = T> + 'a {\n+    //~^ ERROR specializing impl repeats parameter `T`\n+    fn f() {}\n+}\n+\n+impl<'a, T> Specializable for dyn C<Y = (T, T)> + 'a {\n+    //~^ ERROR specializing impl repeats parameter `T`\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "6345cee2c3781ee529b387a016071ad2d9aafece", "filename": "src/test/ui/specialization/min_specialization/dyn-trait-assoc-types.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fdyn-trait-assoc-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fdyn-trait-assoc-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fdyn-trait-assoc-types.stderr?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,20 @@\n+error: specializing impl repeats parameter `T`\n+  --> $DIR/dyn-trait-assoc-types.rs:22:1\n+   |\n+LL | / impl<'a, T> Specializable for dyn B<T, Y = T> + 'a {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: specializing impl repeats parameter `T`\n+  --> $DIR/dyn-trait-assoc-types.rs:27:1\n+   |\n+LL | / impl<'a, T> Specializable for dyn C<Y = (T, T)> + 'a {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "f21f39f066981f922833615da1162050ebd36194", "filename": "src/test/ui/specialization/min_specialization/repeated_projection_type.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,24 @@\n+// Test that projection bounds can't be specialized on.\n+\n+#![feature(min_specialization)]\n+\n+trait X {\n+    fn f();\n+}\n+trait Id {\n+    type This;\n+}\n+impl<T> Id for T {\n+    type This = T;\n+}\n+\n+impl<T: Id> X for T {\n+    default fn f() {}\n+}\n+\n+impl<I, V: Id<This = (I,)>> X for V {\n+    //~^ ERROR cannot specialize on\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "7cc4357a704c0feeb51484e89b2cbb404d880235", "filename": "src/test/ui/specialization/min_specialization/repeated_projection_type.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,11 @@\n+error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id[0]::This[0]) }, (I,)))`\n+  --> $DIR/repeated_projection_type.rs:19:1\n+   |\n+LL | / impl<I, V: Id<This = (I,)>> X for V {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "49bfacec0ae12d3c370182b8ae31ffaccfbacd12", "filename": "src/test/ui/specialization/min_specialization/repeating_lifetimes.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_lifetimes.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,19 @@\n+// Test that directly specializing on repeated lifetime parameters is not\n+// allowed.\n+\n+#![feature(min_specialization)]\n+\n+trait X {\n+    fn f();\n+}\n+\n+impl<T> X for T {\n+    default fn f() {}\n+}\n+\n+impl<'a> X for (&'a u8, &'a u8) {\n+    //~^ ERROR specializing impl repeats parameter `'a`\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "ce9309f70122b90b8f0cf9c35abc72b6f55fbb42", "filename": "src/test/ui/specialization/min_specialization/repeating_lifetimes.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_lifetimes.stderr?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,11 @@\n+error: specializing impl repeats parameter `'a`\n+  --> $DIR/repeating_lifetimes.rs:14:1\n+   |\n+LL | / impl<'a> X for (&'a u8, &'a u8) {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "5a1c97fd321a9bd9e8d02e9a3ad4953fba4ab478", "filename": "src/test/ui/specialization/min_specialization/repeating_param.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_param.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,17 @@\n+// Test that specializing on two type parameters being equal is not allowed.\n+\n+#![feature(min_specialization)]\n+\n+trait X {\n+    fn f();\n+}\n+\n+impl<T> X for T {\n+    default fn f() {}\n+}\n+impl<T> X for (T, T) {\n+    //~^ ERROR specializing impl repeats parameter `T`\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "8b4be1c499537b1e2160e51ce778b40e0e29980a", "filename": "src/test/ui/specialization/min_specialization/repeating_param.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_param.stderr?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,11 @@\n+error: specializing impl repeats parameter `T`\n+  --> $DIR/repeating_param.rs:12:1\n+   |\n+LL | / impl<T> X for (T, T) {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "e17e9dd5f133c8bf24b1db557e95697eaea1aff9", "filename": "src/test/ui/specialization/min_specialization/spec-iter.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-iter.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,20 @@\n+// Check that we can specialize on a concrete iterator type. This requires us\n+// to consider which parameters in the parent impl are constrained.\n+\n+// check-pass\n+\n+#![feature(min_specialization)]\n+\n+trait SpecFromIter<T> {\n+    fn f(&self);\n+}\n+\n+impl<'a, T: 'a, I: Iterator<Item = &'a T>> SpecFromIter<T> for I {\n+    default fn f(&self) {}\n+}\n+\n+impl<'a, T> SpecFromIter<T> for std::slice::Iter<'a, T> {\n+    fn f(&self) {}\n+}\n+\n+fn main() {}"}, {"sha": "377889e2ccad28b76b000f19899fea8df7ff98df", "filename": "src/test/ui/specialization/min_specialization/spec-reference.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-reference.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,19 @@\n+// Check that lifetime parameters are allowed in specializing impls.\n+\n+// check-pass\n+\n+#![feature(min_specialization)]\n+\n+trait MySpecTrait {\n+    fn f();\n+}\n+\n+impl<T> MySpecTrait for T {\n+    default fn f() {}\n+}\n+\n+impl<'a, T: ?Sized> MySpecTrait for &'a T {\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "93462d02ea578ede01fc25aae1af8b4255d8a9de", "filename": "src/test/ui/specialization/min_specialization/specialization_marker.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_marker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_marker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_marker.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,17 @@\n+// Test that `rustc_unsafe_specialization_marker` is only allowed on marker traits.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_unsafe_specialization_marker]\n+trait SpecMarker {\n+    fn f();\n+    //~^ ERROR marker traits\n+}\n+\n+#[rustc_unsafe_specialization_marker]\n+trait SpecMarker2 {\n+    type X;\n+    //~^ ERROR marker traits\n+}\n+\n+fn main() {}"}, {"sha": "ffeced198211f0d148aa5ec6f3334be3a7727c74", "filename": "src/test/ui/specialization/min_specialization/specialization_marker.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_marker.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_marker.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_marker.stderr?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,15 @@\n+error[E0714]: marker traits cannot have associated items\n+  --> $DIR/specialization_marker.rs:7:5\n+   |\n+LL |     fn f();\n+   |     ^^^^^^^\n+\n+error[E0714]: marker traits cannot have associated items\n+  --> $DIR/specialization_marker.rs:13:5\n+   |\n+LL |     type X;\n+   |     ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0714`."}, {"sha": "d597278d29693ac5577c5cacaca5a69372341997", "filename": "src/test/ui/specialization/min_specialization/specialization_trait.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,26 @@\n+// Test that `rustc_specialization_trait` requires always applicable impls.\n+\n+#![feature(min_specialization)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_specialization_trait]\n+trait SpecMarker {\n+    fn f();\n+}\n+\n+impl SpecMarker for &'static u8 {\n+    //~^ ERROR cannot specialize\n+    fn f() {}\n+}\n+\n+impl<T> SpecMarker for (T, T) {\n+    //~^ ERROR specializing impl\n+    fn f() {}\n+}\n+\n+impl<T: Clone> SpecMarker for [T] {\n+    //~^ ERROR cannot specialize\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "4357d2318fc5dcce82883468691df3a03fc02533", "filename": "src/test/ui/specialization/min_specialization/specialization_trait.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.stderr?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,29 @@\n+error: cannot specialize on `'static` lifetime\n+  --> $DIR/specialization_trait.rs:11:1\n+   |\n+LL | / impl SpecMarker for &'static u8 {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: specializing impl repeats parameter `T`\n+  --> $DIR/specialization_trait.rs:16:1\n+   |\n+LL | / impl<T> SpecMarker for (T, T) {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: cannot specialize on trait `std::clone::Clone`\n+  --> $DIR/specialization_trait.rs:21:1\n+   |\n+LL | / impl<T: Clone> SpecMarker for [T] {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "4219bd13b1816cdc3331c6b0f65f3521dbf4832f", "filename": "src/test/ui/specialization/min_specialization/specialize_on_marker.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_marker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_marker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_marker.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,24 @@\n+// Test that specializing on a `rustc_unsafe_specialization_marker` trait is\n+// allowed.\n+\n+// check-pass\n+\n+#![feature(min_specialization)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_unsafe_specialization_marker]\n+trait SpecMarker {}\n+\n+trait X {\n+    fn f();\n+}\n+\n+impl<T> X for T {\n+    default fn f() {}\n+}\n+\n+impl<T: SpecMarker> X for T {\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "abbab5c23dbb760cc07f77d0fe7c91655adc3eec", "filename": "src/test/ui/specialization/min_specialization/specialize_on_spec_trait.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_spec_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_spec_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_spec_trait.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,27 @@\n+// Test that specializing on a `rustc_specialization_trait` trait is allowed.\n+\n+// check-pass\n+\n+#![feature(min_specialization)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_specialization_trait]\n+trait SpecTrait {\n+    fn g(&self);\n+}\n+\n+trait X {\n+    fn f(&self);\n+}\n+\n+impl<T> X for T {\n+    default fn f(&self) {}\n+}\n+\n+impl<T: SpecTrait> X for T {\n+    fn f(&self) {\n+        self.g();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "dd1b05401e6e7dc754fd695f896172517517f0e9", "filename": "src/test/ui/specialization/min_specialization/specialize_on_static.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_static.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,18 @@\n+// Test that directly specializing on `'static` is not allowed.\n+\n+#![feature(min_specialization)]\n+\n+trait X {\n+    fn f();\n+}\n+\n+impl<T> X for &'_ T {\n+    default fn f() {}\n+}\n+\n+impl X for &'static u8 {\n+    //~^ ERROR cannot specialize on `'static` lifetime\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "d1809d6dfbb527ef80ed8acd6dc7430f29977f89", "filename": "src/test/ui/specialization/min_specialization/specialize_on_static.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_static.stderr?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,11 @@\n+error: cannot specialize on `'static` lifetime\n+  --> $DIR/specialize_on_static.rs:13:1\n+   |\n+LL | / impl X for &'static u8 {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "0588442c320807e89157339ee0e32c19a55b17a1", "filename": "src/test/ui/specialization/min_specialization/specialize_on_trait.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.rs?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,20 @@\n+// Test that specializing on a trait is not allowed in general.\n+\n+#![feature(min_specialization)]\n+\n+trait SpecMarker {}\n+\n+trait X {\n+    fn f();\n+}\n+\n+impl<T> X for T {\n+    default fn f() {}\n+}\n+\n+impl<T: SpecMarker> X for T {\n+    //~^ ERROR cannot specialize on trait `SpecMarker`\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "35445fd09b949ce606225270583d5bf07be1e620", "filename": "src/test/ui/specialization/min_specialization/specialize_on_trait.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.stderr?ref=0bbbe719e831c585e0e7bdd33b2432ac5ecb1b31", "patch": "@@ -0,0 +1,11 @@\n+error: cannot specialize on trait `SpecMarker`\n+  --> $DIR/specialize_on_trait.rs:15:1\n+   |\n+LL | / impl<T: SpecMarker> X for T {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}]}