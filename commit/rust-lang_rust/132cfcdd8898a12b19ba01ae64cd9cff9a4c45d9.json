{"sha": "132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMmNmY2RkODg5OGExMmIxOWJhMDFhZTY0Y2Q5Y2ZmOWE0YzQ1ZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-29T11:22:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-29T11:22:53Z"}, "message": "auto merge of #7363 : bblum/rust/soundness, r=nikomatsakis\n\nThe commit f9a5453 is meant to be a temporary hold-over. Whether or not there is added a way for the compiler to \"implicitly borrow\" stack closures in this way, there should be a codegen optimization that prevents having to traverse possibly-very-many function pointers to find the function you ultimately wanted to call. I tried to separate out the changes so this particular commit could be straight-up reverted if auto-borrowing happens in the future.\r\n\r\nr? @nikomatsakis", "tree": {"sha": "53a9a390765ba6af5988811ee3f23944cf888af8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53a9a390765ba6af5988811ee3f23944cf888af8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "html_url": "https://github.com/rust-lang/rust/commit/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e", "html_url": "https://github.com/rust-lang/rust/commit/c80e3bac3e676abb106f7ef8ac7da5b153c65c8e"}, {"sha": "d7544fe987104ad0a82b1929b819cfd7e2321bb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7544fe987104ad0a82b1929b819cfd7e2321bb2", "html_url": "https://github.com/rust-lang/rust/commit/d7544fe987104ad0a82b1929b819cfd7e2321bb2"}], "stats": {"total": 1006, "additions": 366, "deletions": 640}, "files": [{"sha": "5906e809c98561dc936d397f7b99248609704f0a", "filename": "src/libextra/fun_treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffun_treemap.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -66,9 +66,9 @@ pub fn traverse<K, V: Copy>(m: Treemap<K, V>, f: &fn(&K, &V)) {\n         // matches to me, so I changed it. but that may be a\n         // de-optimization -- tjc\n         Node(@ref k, @ref v, left, right) => {\n-            traverse(left, f);\n+            traverse(left, |k,v| f(k,v));\n             f(k, v);\n-            traverse(right, f);\n+            traverse(right, |k,v| f(k,v));\n         }\n     }\n }"}, {"sha": "71393ff9fae20116358dec064bb67795b8e38805", "filename": "src/libextra/rope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -1078,7 +1078,7 @@ pub mod node {\n \n     pub fn loop_chars(node: @Node, it: &fn(c: char) -> bool) -> bool {\n         return loop_leaves(node,|leaf| {\n-            leaf.content.slice(leaf.byte_offset, leaf.byte_len).iter().all(it)\n+            leaf.content.slice(leaf.byte_offset, leaf.byte_len).iter().all(|c| it(c))\n         });\n     }\n \n@@ -1101,7 +1101,7 @@ pub mod node {\n         loop {\n             match (*current) {\n               Leaf(x) => return it(x),\n-              Concat(ref x) => if loop_leaves(x.left, it) { //non tail call\n+              Concat(ref x) => if loop_leaves(x.left, |l| it(l)) { //non tail call\n                 current = x.right;       //tail call\n               } else {\n                 return false;"}, {"sha": "10dbe2326d76236441cbca0283884a1627e949e5", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -42,7 +42,8 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n         let mid = v_len / 2 + begin;\n         let a = (begin, mid);\n         let b = (mid, end);\n-        return merge(le, merge_sort_(v, a, le), merge_sort_(v, b, le));\n+        return merge(|x,y| le(x,y), merge_sort_(v, a, |x,y| le(x,y)),\n+                                    merge_sort_(v, b, |x,y| le(x,y)));\n     }\n \n     fn merge<T:Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n@@ -83,10 +84,10 @@ fn qsort<T>(arr: &mut [T], left: uint,\n             right: uint, compare_func: Le<T>) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n-        let new_pivot = part::<T>(arr, left, right, pivot, compare_func);\n+        let new_pivot = part::<T>(arr, left, right, pivot, |x,y| compare_func(x,y));\n         if new_pivot != 0u {\n             // Need to do this check before recursing due to overflow\n-            qsort::<T>(arr, left, new_pivot - 1u, compare_func);\n+            qsort::<T>(arr, left, new_pivot - 1u, |x,y| compare_func(x,y));\n         }\n         qsort::<T>(arr, new_pivot + 1u, right, compare_func);\n     }\n@@ -1202,7 +1203,7 @@ mod big_tests {\n \n     struct LVal<'self> {\n         val: uint,\n-        key: &'self fn(@uint),\n+        key: &'self fn:Copy(@uint),\n     }\n \n     #[unsafe_destructor]"}, {"sha": "9c6be901d980a87e051d52e0d4065f50e2c41b67", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -563,7 +563,9 @@ impl RWlock {\n                 (&self.order_lock).acquire();\n                 do (&self.access_lock).access_waitqueue {\n                     (&self.order_lock).release();\n-                    task::rekillable(blk)\n+                    do task::rekillable {\n+                        blk()\n+                    }\n                 }\n             }\n         }\n@@ -1182,12 +1184,12 @@ mod tests {\n             Write => x.write(blk),\n             Downgrade =>\n                 do x.write_downgrade |mode| {\n-                    (&mode).write(blk);\n+                    do mode.write { blk() };\n                 },\n             DowngradeRead =>\n                 do x.write_downgrade |mode| {\n                     let mode = x.downgrade(mode);\n-                    (&mode).read(blk);\n+                    do mode.read { blk() };\n                 },\n         }\n     }\n@@ -1340,10 +1342,10 @@ mod tests {\n         fn lock_cond(x: &RWlock, downgrade: bool, blk: &fn(c: &Condvar)) {\n             if downgrade {\n                 do x.write_downgrade |mode| {\n-                    (&mode).write_cond(blk)\n+                    do mode.write_cond |c| { blk(c) }\n                 }\n             } else {\n-                x.write_cond(blk)\n+                do x.write_cond |c| { blk(c) }\n             }\n         }\n         let x = ~RWlock();"}, {"sha": "50ca96e6e21df12d77a8b6bd8685b7356d6ee4e1", "filename": "src/libextra/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -678,7 +678,7 @@ impl BenchHarness {\n \n         // Initial bench run to get ballpark figure.\n         let mut n = 1_u64;\n-        self.bench_n(n, f);\n+        self.bench_n(n, |x| f(x));\n \n         while n < 1_000_000_000 &&\n             self.ns_elapsed() < 1_000_000_000 {\n@@ -694,7 +694,7 @@ impl BenchHarness {\n \n             n = u64::max(u64::min(n+n/2, 100*last), last+1);\n             n = round_up(n);\n-            self.bench_n(n, f);\n+            self.bench_n(n, |x| f(x));\n         }\n     }\n \n@@ -714,7 +714,7 @@ impl BenchHarness {\n                                             magnitude * 2);\n \n             let samples = do vec::from_fn(n_samples) |_| {\n-                self.bench_n(n_iter as u64, f);\n+                self.bench_n(n_iter as u64, |x| f(x));\n                 self.ns_per_iter() as f64\n             };\n "}, {"sha": "d546b48f81751de633212096e320690c376d9b8a", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -511,14 +511,14 @@ impl<K: TotalOrd, V> TreeNode<K, V> {\n \n fn each<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                             f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.iter().advance(|x| each(&x.left, f) && f(&x.key, &x.value) &&\n-                            each(&x.right, f))\n+    node.iter().advance(|x| each(&x.left,  |k,v| f(k,v)) && f(&x.key, &x.value) &&\n+                            each(&x.right, |k,v| f(k,v)))\n }\n \n fn each_reverse<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                                     f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.iter().advance(|x| each_reverse(&x.right, f) && f(&x.key, &x.value) &&\n-                            each_reverse(&x.left, f))\n+    node.iter().advance(|x| each_reverse(&x.right, |k,v| f(k,v)) && f(&x.key, &x.value) &&\n+                            each_reverse(&x.left,  |k,v| f(k,v)))\n }\n \n fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n@@ -527,9 +527,9 @@ fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n     match *node {\n       Some(~TreeNode{key: ref key, value: ref mut value, left: ref mut left,\n                      right: ref mut right, _}) => {\n-        if !mutate_values(left, f) { return false }\n+        if !mutate_values(left,  |k,v| f(k,v)) { return false }\n         if !f(key, value) { return false }\n-        if !mutate_values(right, f) { return false }\n+        if !mutate_values(right, |k,v| f(k,v)) { return false }\n       }\n       None => return false\n     }"}, {"sha": "4d4f3c3a49b0141bf6e15b71662be6ffdefa6de7", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -107,7 +107,7 @@ struct WorkKey {\n impl to_bytes::IterBytes for WorkKey {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.kind.iter_bytes(lsb0, f) && self.name.iter_bytes(lsb0, f)\n+        self.kind.iter_bytes(lsb0, |b| f(b)) && self.name.iter_bytes(lsb0, |b| f(b))\n     }\n }\n "}, {"sha": "ba5e592b605c3e774754d7649cdd036d731d85ef", "filename": "src/librust/rust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -57,13 +57,13 @@ impl ValidUsage {\n }\n \n enum Action<'self> {\n-    Call(&'self fn(args: &[~str]) -> ValidUsage),\n-    CallMain(&'static str, &'self fn()),\n+    Call(&'self fn:Copy(args: &[~str]) -> ValidUsage),\n+    CallMain(&'static str, &'self fn:Copy()),\n }\n \n enum UsageSource<'self> {\n     UsgStr(&'self str),\n-    UsgCall(&'self fn()),\n+    UsgCall(&'self fn:Copy()),\n }\n \n struct Command<'self> {"}, {"sha": "abfb5f7d4d4bf5369abf37f88616133bb9997715", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -48,7 +48,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n             debug!(\"filesearch: searching additional lib search paths [%?]\",\n                    self.addl_lib_search_paths.len());\n             // a little weird\n-            self.addl_lib_search_paths.iter().advance(f);\n+            self.addl_lib_search_paths.iter().advance(|path| f(path));\n \n             debug!(\"filesearch: searching target lib path\");\n             if !f(&make_target_lib_path(self.sysroot,"}, {"sha": "22786581073443b1bd7503dd197000a1dd16e861", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -189,11 +189,11 @@ fn parse_trait_store(st: &mut PState) -> ty::TraitStore {\n fn parse_substs(st: &mut PState, conv: conv_did) -> ty::substs {\n     let self_r = parse_opt(st, |st| parse_region(st) );\n \n-    let self_ty = parse_opt(st, |st| parse_ty(st, conv) );\n+    let self_ty = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)) );\n \n     assert_eq!(next(st), '[');\n     let mut params: ~[ty::t] = ~[];\n-    while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n+    while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n     st.pos = st.pos + 1u;\n \n     return ty::substs {\n@@ -270,8 +270,8 @@ fn parse_str(st: &mut PState, term: char) -> ~str {\n }\n \n fn parse_trait_ref(st: &mut PState, conv: conv_did) -> ty::TraitRef {\n-    let def = parse_def(st, NominalType, conv);\n-    let substs = parse_substs(st, conv);\n+    let def = parse_def(st, NominalType, |x,y| conv(x,y));\n+    let substs = parse_substs(st, |x,y| conv(x,y));\n     ty::TraitRef {def_id: def, substs: substs}\n }\n \n@@ -301,18 +301,18 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       'c' => return ty::mk_char(),\n       't' => {\n         assert_eq!(next(st), '[');\n-        let def = parse_def(st, NominalType, conv);\n-        let substs = parse_substs(st, conv);\n+        let def = parse_def(st, NominalType, |x,y| conv(x,y));\n+        let substs = parse_substs(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n         return ty::mk_enum(st.tcx, def, substs);\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n-        let def = parse_def(st, NominalType, conv);\n-        let substs = parse_substs(st, conv);\n+        let def = parse_def(st, NominalType, |x,y| conv(x,y));\n+        let substs = parse_substs(st, |x,y| conv(x,y));\n         let store = parse_trait_store(st);\n         let mt = parse_mutability(st);\n-        let bounds = parse_bounds(st, conv);\n+        let bounds = parse_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n         return ty::mk_trait(st.tcx, def, substs, store, mt, bounds.builtin_bounds);\n       }\n@@ -346,7 +346,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       'T' => {\n         assert_eq!(next(st), '[');\n         let mut params = ~[];\n-        while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n+        while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n         st.pos = st.pos + 1u;\n         return ty::mk_tup(st.tcx, params);\n       }\n@@ -380,15 +380,15 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         }\n       }\n       '\"' => {\n-        let _ = parse_def(st, TypeWithId, conv);\n-        let inner = parse_ty(st, conv);\n+        let _ = parse_def(st, TypeWithId, |x,y| conv(x,y));\n+        let inner = parse_ty(st, |x,y| conv(x,y));\n         inner\n       }\n       'B' => ty::mk_opaque_box(st.tcx),\n       'a' => {\n           assert_eq!(next(st), '[');\n-          let did = parse_def(st, NominalType, conv);\n-          let substs = parse_substs(st, conv);\n+          let did = parse_def(st, NominalType, |x,y| conv(x,y));\n+          let substs = parse_substs(st, |x,y| conv(x,y));\n           assert_eq!(next(st), ']');\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n@@ -473,8 +473,8 @@ fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n     let purity = parse_purity(next(st));\n     let onceness = parse_onceness(next(st));\n     let region = parse_region(st);\n-    let bounds = parse_bounds(st, conv);\n-    let sig = parse_sig(st, conv);\n+    let bounds = parse_bounds(st, |x,y| conv(x,y));\n+    let sig = parse_sig(st, |x,y| conv(x,y));\n     ty::ClosureTy {\n         purity: purity,\n         sigil: sigil,\n@@ -500,7 +500,7 @@ fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n     assert_eq!(next(st), '[');\n     let mut inputs = ~[];\n     while peek(st) != ']' {\n-        inputs.push(parse_ty(st, conv));\n+        inputs.push(parse_ty(st, |x,y| conv(x,y)));\n     }\n     st.pos += 1u; // eat the ']'\n     let ret_ty = parse_ty(st, conv);\n@@ -544,8 +544,8 @@ pub fn parse_type_param_def_data(data: &[u8], start: uint,\n }\n \n fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef {\n-    ty::TypeParameterDef {def_id: parse_def(st, NominalType, conv),\n-                          bounds: @parse_bounds(st, conv)}\n+    ty::TypeParameterDef {def_id: parse_def(st, NominalType, |x,y| conv(x,y)),\n+                          bounds: @parse_bounds(st, |x,y| conv(x,y))}\n }\n \n fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n@@ -571,7 +571,7 @@ fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n                 param_bounds.builtin_bounds.add(ty::BoundSized);\n             }\n             'I' => {\n-                param_bounds.trait_bounds.push(@parse_trait_ref(st, conv));\n+                param_bounds.trait_bounds.push(@parse_trait_ref(st, |x,y| conv(x,y)));\n             }\n             '.' => {\n                 return param_bounds;"}, {"sha": "623dbbd61b244cf1971fa4984fb95e3dca3f3d88", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -411,7 +411,7 @@ impl MoveData {\n \n         let mut p = self.path(index).first_child;\n         while p != InvalidMovePathIndex {\n-            if !self.each_extending_path(p, f) {\n+            if !self.each_extending_path(p, |x| f(x)) {\n                 return false;\n             }\n             p = self.path(p).next_sibling;"}, {"sha": "d4b91ed589d0febf42554b218fb83344373a8ec4", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -171,7 +171,7 @@ fn with_appropriate_checker(cx: Context, id: node_id,\n         // check that only immutable variables are implicitly copied in\n         check_imm_free_var(cx, fv.def, fv.span);\n \n-        check_freevar_bounds(cx, fv.span, var_t, bounds);\n+        check_freevar_bounds(cx, fv.span, var_t, bounds, None);\n     }\n \n     fn check_for_box(cx: Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n@@ -182,13 +182,18 @@ fn with_appropriate_checker(cx: Context, id: node_id,\n         // check that only immutable variables are implicitly copied in\n         check_imm_free_var(cx, fv.def, fv.span);\n \n-        check_freevar_bounds(cx, fv.span, var_t, bounds);\n+        check_freevar_bounds(cx, fv.span, var_t, bounds, None);\n     }\n \n-    fn check_for_block(cx: Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n+    fn check_for_block(cx: Context, fv: &freevar_entry,\n+                       bounds: ty::BuiltinBounds, region: ty::Region) {\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n-        check_freevar_bounds(cx, fv.span, var_t, bounds);\n+        // FIXME(#3569): Figure out whether the implicit borrow is actually\n+        // mutable. Currently we assume all upvars are referenced mutably.\n+        let implicit_borrowed_type = ty::mk_mut_rptr(cx.tcx, region, var_t);\n+        check_freevar_bounds(cx, fv.span, implicit_borrowed_type,\n+                             bounds, Some(var_t));\n     }\n \n     fn check_for_bare(cx: Context, fv: @freevar_entry) {\n@@ -205,8 +210,9 @@ fn with_appropriate_checker(cx: Context, id: node_id,\n         ty::ty_closure(ty::ClosureTy {sigil: ManagedSigil, bounds: bounds, _}) => {\n             b(|cx, fv| check_for_box(cx, fv, bounds))\n         }\n-        ty::ty_closure(ty::ClosureTy {sigil: BorrowedSigil, bounds: bounds, _}) => {\n-            b(|cx, fv| check_for_block(cx, fv, bounds))\n+        ty::ty_closure(ty::ClosureTy {sigil: BorrowedSigil, bounds: bounds,\n+                                      region: region, _}) => {\n+            b(|cx, fv| check_for_block(cx, fv, bounds, region))\n         }\n         ty::ty_bare_fn(_) => {\n             b(check_for_bare)\n@@ -366,14 +372,21 @@ pub fn check_typaram_bounds(cx: Context,\n }\n \n pub fn check_freevar_bounds(cx: Context, sp: span, ty: ty::t,\n-                            bounds: ty::BuiltinBounds)\n+                            bounds: ty::BuiltinBounds, referenced_ty: Option<ty::t>)\n {\n     do check_builtin_bounds(cx, ty, bounds) |missing| {\n-        cx.tcx.sess.span_err(\n-            sp,\n-            fmt!(\"cannot capture variable of type `%s`, which does not fulfill \\\n-                  `%s`, in a bounded closure\",\n-                 ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx)));\n+        // Will be Some if the freevar is implicitly borrowed (stack closure).\n+        // Emit a less mysterious error message in this case.\n+        match referenced_ty {\n+            Some(rty) => cx.tcx.sess.span_err(sp,\n+                fmt!(\"cannot implicitly borrow variable of type `%s` in a bounded \\\n+                      stack closure (implicit reference does not fulfill `%s`)\",\n+                     ty_to_str(cx.tcx, rty), missing.user_string(cx.tcx))),\n+            None => cx.tcx.sess.span_err(sp,\n+                fmt!(\"cannot capture variable of type `%s`, which does \\\n+                      not fulfill `%s`, in a bounded closure\",\n+                     ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx))),\n+        }\n         cx.tcx.sess.span_note(\n             sp,\n             fmt!(\"this closure's environment must satisfy `%s`\","}, {"sha": "ad5951b39766f80e30a7e8aac744157b3b754a07", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -901,7 +901,7 @@ impl mem_categorization_ctxt {\n                                 pat, downcast_cmt, subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        self.cat_pattern(subcmt, subpat, op);\n+                        self.cat_pattern(subcmt, subpat, |x,y| op(x,y));\n                     }\n                 }\n                 Some(&ast::def_fn(*)) |\n@@ -912,12 +912,12 @@ impl mem_categorization_ctxt {\n                             self.cat_imm_interior(\n                                 pat, cmt, subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        self.cat_pattern(cmt_field, subpat, op);\n+                        self.cat_pattern(cmt_field, subpat, |x,y| op(x,y));\n                     }\n                 }\n                 Some(&ast::def_static(*)) => {\n                     for subpats.iter().advance |&subpat| {\n-                        self.cat_pattern(cmt, subpat, op);\n+                        self.cat_pattern(cmt, subpat, |x,y| op(x,y));\n                     }\n                 }\n                 _ => {\n@@ -941,7 +941,7 @@ impl mem_categorization_ctxt {\n             for field_pats.iter().advance |fp| {\n                 let field_ty = self.pat_ty(fp.pat); // see (*)\n                 let cmt_field = self.cat_field(pat, cmt, fp.ident, field_ty);\n-                self.cat_pattern(cmt_field, fp.pat, op);\n+                self.cat_pattern(cmt_field, fp.pat, |x,y| op(x,y));\n             }\n           }\n \n@@ -953,7 +953,7 @@ impl mem_categorization_ctxt {\n                     self.cat_imm_interior(\n                         pat, cmt, subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                self.cat_pattern(subcmt, subpat, op);\n+                self.cat_pattern(subcmt, subpat, |x,y| op(x,y));\n             }\n           }\n \n@@ -967,15 +967,15 @@ impl mem_categorization_ctxt {\n           ast::pat_vec(ref before, slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, cmt, 0);\n               for before.iter().advance |&before_pat| {\n-                  self.cat_pattern(elt_cmt, before_pat, op);\n+                  self.cat_pattern(elt_cmt, before_pat, |x,y| op(x,y));\n               }\n               for slice.iter().advance |&slice_pat| {\n                   let slice_ty = self.pat_ty(slice_pat);\n                   let slice_cmt = self.cat_rvalue(pat, slice_ty);\n-                  self.cat_pattern(slice_cmt, slice_pat, op);\n+                  self.cat_pattern(slice_cmt, slice_pat, |x,y| op(x,y));\n               }\n               for after.iter().advance |&after_pat| {\n-                  self.cat_pattern(elt_cmt, after_pat, op);\n+                  self.cat_pattern(elt_cmt, after_pat, |x,y| op(x,y));\n               }\n           }\n "}, {"sha": "d9fea12134684b98b135cf3b4d0e88c6bde1298d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -674,7 +674,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                                     int::to_str(variant.disr_val));\n                       let variant_cx =\n                           iter_variant(variant_cx, repr, av, *variant,\n-                                       substs.tps, f);\n+                                       substs.tps, |x,y,z| f(x,y,z));\n                       match adt::trans_case(cx, repr, variant.disr_val) {\n                           _match::single_result(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)"}, {"sha": "b255f2ca78c7fd19f32e4069c1dae7c2d0866d03", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -36,6 +36,8 @@ use core::cast;\n use core::hashmap::{HashMap};\n use core::libc::{c_uint, c_longlong, c_ulonglong};\n use core::to_bytes;\n+use core::str;\n+use core::vec::raw::to_ptr;\n use core::vec;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt};\n@@ -860,7 +862,7 @@ pub fn is_null(val: ValueRef) -> bool {\n }\n \n // Used to identify cached monomorphized functions and vtables\n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub enum mono_param_id {\n     mono_precise(ty::t, Option<@~[mono_id]>),\n     mono_any,\n@@ -870,7 +872,7 @@ pub enum mono_param_id {\n               datum::DatumMode),\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub enum MonoDataClass {\n     MonoBits,    // Anything not treated differently from arbitrary integer data\n     MonoNonNull, // Non-null pointers (used for optional-pointer optimization)\n@@ -895,7 +897,7 @@ pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n }\n \n \n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct mono_id_ {\n     def: ast::def_id,\n     params: ~[mono_param_id],\n@@ -904,40 +906,6 @@ pub struct mono_id_ {\n \n pub type mono_id = @mono_id_;\n \n-impl to_bytes::IterBytes for mono_param_id {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            mono_precise(t, ref mids) => {\n-                0u8.iter_bytes(lsb0, f) &&\n-                ty::type_id(t).iter_bytes(lsb0, f) &&\n-                mids.iter_bytes(lsb0, f)\n-            }\n-\n-            mono_any => 1u8.iter_bytes(lsb0, f),\n-\n-            mono_repr(ref a, ref b, ref c, ref d) => {\n-                2u8.iter_bytes(lsb0, f) &&\n-                a.iter_bytes(lsb0, f) &&\n-                b.iter_bytes(lsb0, f) &&\n-                c.iter_bytes(lsb0, f) &&\n-                d.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n-impl to_bytes::IterBytes for MonoDataClass {\n-    fn iter_bytes(&self, lsb0: bool, f:to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for mono_id_ {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.def.iter_bytes(lsb0, f) && self.params.iter_bytes(lsb0, f)\n-    }\n-}\n-\n pub fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     return build::Select(cx, cond, b, a);"}, {"sha": "b8ee1eee26e1c69162dff91b50da41f803875c2a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 40, "deletions": 226, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -52,7 +52,7 @@ use syntax;\n \n // Data types\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct field {\n     ident: ast::ident,\n     mt: mt\n@@ -96,13 +96,13 @@ impl Method {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct mt {\n     ty: t,\n     mutbl: ast::mutability,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable, IterBytes)]\n pub enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n@@ -133,7 +133,7 @@ pub struct field_ty {\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct creader_cache_key {\n     cnum: int,\n     pos: uint,\n@@ -142,14 +142,6 @@ pub struct creader_cache_key {\n \n type creader_cache = @mut HashMap<creader_cache_key, t>;\n \n-impl to_bytes::IterBytes for creader_cache_key {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.cnum.iter_bytes(lsb0, f) &&\n-        self.pos.iter_bytes(lsb0, f) &&\n-        self.len.iter_bytes(lsb0, f)\n-    }\n-}\n-\n struct intern_key {\n     sty: *sty,\n }\n@@ -168,6 +160,8 @@ impl cmp::Eq for intern_key {\n     }\n }\n \n+// NB: Do not replace this with #[deriving(IterBytes)], as above. (Figured\n+// this out the hard way.)\n impl to_bytes::IterBytes for intern_key {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         unsafe {\n@@ -372,14 +366,14 @@ pub fn type_has_regions(t: t) -> bool {\n }\n pub fn type_id(t: t) -> uint { get(t).id }\n \n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct BareFnTy {\n     purity: ast::purity,\n     abis: AbiSet,\n     sig: FnSig\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct ClosureTy {\n     purity: ast::purity,\n     sigil: ast::Sigil,\n@@ -396,32 +390,13 @@ pub struct ClosureTy {\n  * - `lifetimes` is the list of region names bound in this fn.\n  * - `inputs` is the list of arguments and their modes.\n  * - `output` is the return type. */\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct FnSig {\n     bound_lifetime_names: OptVec<ast::ident>,\n     inputs: ~[t],\n     output: t\n }\n \n-impl to_bytes::IterBytes for BareFnTy {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.purity.iter_bytes(lsb0, f) &&\n-        self.abis.iter_bytes(lsb0, f) &&\n-        self.sig.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for ClosureTy {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.purity.iter_bytes(lsb0, f) &&\n-        self.sigil.iter_bytes(lsb0, f) &&\n-        self.onceness.iter_bytes(lsb0, f) &&\n-        self.region.iter_bytes(lsb0, f) &&\n-        self.sig.iter_bytes(lsb0, f) &&\n-        self.bounds.iter_bytes(lsb0, f)\n-    }\n-}\n-\n #[deriving(Eq, IterBytes)]\n pub struct param_ty {\n     idx: uint,\n@@ -526,7 +501,7 @@ type opt_region = Option<Region>;\n  * - `self_ty` is the type to which `self` should be remapped, if any.  The\n  *   `self` type is rather funny in that it can only appear on traits and is\n  *   always substituted away to the implementing type for a trait. */\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct substs {\n     self_r: opt_region,\n     self_ty: Option<ty::t>,\n@@ -582,7 +557,7 @@ mod primitives {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum sty {\n     ty_nil,\n     ty_bot,\n@@ -714,62 +689,33 @@ impl CLike for BuiltinBound {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct TyVid(uint);\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct IntVid(uint);\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct FloatVid(uint);\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable, IterBytes)]\n pub struct RegionVid {\n     id: uint\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n     FloatVar(FloatVid)\n }\n \n-impl to_bytes::IterBytes for InferTy {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            TyVar(ref tv) => {\n-                0u8.iter_bytes(lsb0, f) && tv.iter_bytes(lsb0, f)\n-            }\n-            IntVar(ref iv) => {\n-                1u8.iter_bytes(lsb0, f) && iv.iter_bytes(lsb0, f)\n-            }\n-            FloatVar(ref fv) => {\n-                2u8.iter_bytes(lsb0, f) && fv.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n-#[deriving(Encodable, Decodable)]\n+#[deriving(Encodable, Decodable, IterBytes)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(uint, bound_region)\n }\n \n-impl to_bytes::IterBytes for InferRegion {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            ReVar(ref rv) => {\n-                0u8.iter_bytes(lsb0, f) && rv.iter_bytes(lsb0, f)\n-            }\n-            ReSkolemized(ref v, _) => {\n-                1u8.iter_bytes(lsb0, f) && v.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n impl cmp::Eq for InferRegion {\n     fn eq(&self, other: &InferRegion) -> bool {\n         match ((*self), *other) {\n@@ -849,30 +795,6 @@ impl ToStr for IntVarValue {\n     }\n }\n \n-impl to_bytes::IterBytes for TyVid {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.to_uint().iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for IntVid {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.to_uint().iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for FloatVid {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.to_uint().iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for RegionVid {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.to_uint().iter_bytes(lsb0, f)\n-    }\n-}\n-\n pub struct TypeParameterDef {\n     def_id: ast::def_id,\n     bounds: @ParamBounds\n@@ -1319,15 +1241,15 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n       }\n       ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n       ty_trait(_, ref substs, _, _, _) => {\n-        for (*substs).tps.iter().advance |subty| { maybe_walk_ty(*subty, f); }\n+        for (*substs).tps.iter().advance |subty| { maybe_walk_ty(*subty, |x| f(x)); }\n       }\n-      ty_tup(ref ts) => { for ts.iter().advance |tt| { maybe_walk_ty(*tt, f); } }\n+      ty_tup(ref ts) => { for ts.iter().advance |tt| { maybe_walk_ty(*tt, |x| f(x)); } }\n       ty_bare_fn(ref ft) => {\n-        for ft.sig.inputs.iter().advance |a| { maybe_walk_ty(*a, f); }\n+        for ft.sig.inputs.iter().advance |a| { maybe_walk_ty(*a, |x| f(x)); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n       ty_closure(ref ft) => {\n-        for ft.sig.inputs.iter().advance |a| { maybe_walk_ty(*a, f); }\n+        for ft.sig.inputs.iter().advance |a| { maybe_walk_ty(*a, |x| f(x)); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n     }\n@@ -1409,7 +1331,7 @@ fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n \n // Folds types from the bottom up.\n pub fn fold_ty(cx: ctxt, t0: t, fldop: &fn(t) -> t) -> t {\n-    let sty = fold_sty(&get(t0).sty, |t| fold_ty(cx, fldop(t), fldop));\n+    let sty = fold_sty(&get(t0).sty, |t| fold_ty(cx, fldop(t), |t| fldop(t)));\n     fldop(mk_t(cx, sty))\n }\n \n@@ -1423,8 +1345,8 @@ pub fn walk_regions_and_ty(\n         fold_regions_and_ty(\n             cx, ty,\n             |r| { walkr(r); r },\n-            |t| { walk_regions_and_ty(cx, t, walkr, walkt); t },\n-            |t| { walk_regions_and_ty(cx, t, walkr, walkt); t });\n+            |t| { walk_regions_and_ty(cx, t, |r| walkr(r), |t| walkt(t)); t },\n+            |t| { walk_regions_and_ty(cx, t, |r| walkr(r), |t| walkt(t)); t });\n     }\n }\n \n@@ -1504,8 +1426,8 @@ pub fn fold_regions(\n         fold_regions_and_ty(\n             cx, ty,\n             |r| fldr(r, in_fn),\n-            |t| do_fold(cx, t, true, fldr),\n-            |t| do_fold(cx, t, in_fn, fldr))\n+            |t| do_fold(cx, t, true,  |r,b| fldr(r,b)),\n+            |t| do_fold(cx, t, in_fn, |r,b| fldr(r,b)))\n     }\n     do_fold(cx, ty, false, fldr)\n }\n@@ -1906,7 +1828,9 @@ impl TypeContents {\n             // Currently all noncopyable existentials are 2nd-class types\n             // behind owned pointers. With dynamically-sized types, remove\n             // this assertion.\n-            assert!(self.intersects(TC_OWNED_POINTER));\n+            assert!(self.intersects(TC_OWNED_POINTER) ||\n+                    // (...or stack closures without a copy bound.)\n+                    self.intersects(TC_BORROWED_POINTER));\n         }\n         let tc = TC_MANAGED + TC_DTOR + TypeContents::sendable(cx);\n         self.intersects(tc)\n@@ -2272,7 +2196,14 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             ast::Once => TC_ONCE_CLOSURE,\n             ast::Many => TC_NONE\n         };\n-        st + rt + ot\n+        // Prevent noncopyable types captured in the environment from being copied.\n+        let ct = if cty.bounds.contains_elem(BoundCopy) ||\n+                    cty.sigil == ast::ManagedSigil {\n+            TC_NONE\n+        } else {\n+            TC_NONCOPY_TRAIT\n+        };\n+        st + rt + ot + ct\n     }\n \n     fn trait_contents(store: TraitStore, mutbl: ast::mutability,\n@@ -2452,7 +2383,7 @@ pub fn type_structurally_contains(cx: ctxt,\n         for (*enum_variants(cx, did)).iter().advance |variant| {\n             for variant.args.iter().advance |aty| {\n                 let sty = subst(cx, substs, *aty);\n-                if type_structurally_contains(cx, sty, test) { return true; }\n+                if type_structurally_contains(cx, sty, |x| test(x)) { return true; }\n             }\n         }\n         return false;\n@@ -2461,14 +2392,14 @@ pub fn type_structurally_contains(cx: ctxt,\n         let r = lookup_struct_fields(cx, did);\n         for r.iter().advance |field| {\n             let ft = lookup_field_type(cx, did, field.id, substs);\n-            if type_structurally_contains(cx, ft, test) { return true; }\n+            if type_structurally_contains(cx, ft, |x| test(x)) { return true; }\n         }\n         return false;\n       }\n \n       ty_tup(ref ts) => {\n         for ts.iter().advance |tt| {\n-            if type_structurally_contains(cx, *tt, test) { return true; }\n+            if type_structurally_contains(cx, *tt, |x| test(x)) { return true; }\n         }\n         return false;\n       }\n@@ -2744,123 +2675,6 @@ impl cmp::TotalEq for bound_region {\n     }\n }\n \n-impl to_bytes::IterBytes for vstore {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            vstore_fixed(ref u) => {\n-                0u8.iter_bytes(lsb0, f) && u.iter_bytes(lsb0, f)\n-            }\n-            vstore_uniq => 1u8.iter_bytes(lsb0, f),\n-            vstore_box => 2u8.iter_bytes(lsb0, f),\n-\n-            vstore_slice(ref r) => {\n-                3u8.iter_bytes(lsb0, f) && r.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n-impl to_bytes::IterBytes for substs {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.self_r.iter_bytes(lsb0, f) &&\n-        self.self_ty.iter_bytes(lsb0, f) &&\n-        self.tps.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for mt {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.ty.iter_bytes(lsb0, f) && self.mutbl.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for field {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.ident.iter_bytes(lsb0, f) && self.mt.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for FnSig {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.inputs.iter_bytes(lsb0, f) && self.output.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for sty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            ty_nil => 0u8.iter_bytes(lsb0, f),\n-            ty_bool => 1u8.iter_bytes(lsb0, f),\n-\n-            ty_int(ref t) => 2u8.iter_bytes(lsb0, f) && t.iter_bytes(lsb0, f),\n-\n-            ty_uint(ref t) => 3u8.iter_bytes(lsb0, f) && t.iter_bytes(lsb0, f),\n-\n-            ty_float(ref t) => 4u8.iter_bytes(lsb0, f) && t.iter_bytes(lsb0, f),\n-\n-            ty_estr(ref v) => 5u8.iter_bytes(lsb0, f) && v.iter_bytes(lsb0, f),\n-\n-            ty_enum(ref did, ref substs) => {\n-                6u8.iter_bytes(lsb0, f) &&\n-                did.iter_bytes(lsb0, f) &&\n-                substs.iter_bytes(lsb0, f)\n-            }\n-\n-            ty_box(ref mt) => 7u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n-\n-            ty_evec(ref mt, ref v) => {\n-                8u8.iter_bytes(lsb0, f) &&\n-                mt.iter_bytes(lsb0, f) &&\n-                v.iter_bytes(lsb0, f)\n-            }\n-\n-            ty_unboxed_vec(ref mt) => 9u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n-\n-            ty_tup(ref ts) => 10u8.iter_bytes(lsb0, f) && ts.iter_bytes(lsb0, f),\n-\n-            ty_bare_fn(ref ft) => 12u8.iter_bytes(lsb0, f) && ft.iter_bytes(lsb0, f),\n-\n-            ty_self(ref did) => 13u8.iter_bytes(lsb0, f) && did.iter_bytes(lsb0, f),\n-\n-            ty_infer(ref v) => 14u8.iter_bytes(lsb0, f) && v.iter_bytes(lsb0, f),\n-\n-            ty_param(ref p) => 15u8.iter_bytes(lsb0, f) && p.iter_bytes(lsb0, f),\n-\n-            ty_type => 16u8.iter_bytes(lsb0, f),\n-            ty_bot => 17u8.iter_bytes(lsb0, f),\n-\n-            ty_ptr(ref mt) => 18u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n-\n-            ty_uniq(ref mt) => 19u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n-\n-            ty_trait(ref did, ref substs, ref v, ref mutbl, bounds) => {\n-                20u8.iter_bytes(lsb0, f) &&\n-                did.iter_bytes(lsb0, f) &&\n-                substs.iter_bytes(lsb0, f) &&\n-                v.iter_bytes(lsb0, f) &&\n-                mutbl.iter_bytes(lsb0, f) &&\n-                bounds.iter_bytes(lsb0, f)\n-            }\n-\n-            ty_opaque_closure_ptr(ref ck) => 21u8.iter_bytes(lsb0, f) && ck.iter_bytes(lsb0, f),\n-\n-            ty_opaque_box => 22u8.iter_bytes(lsb0, f),\n-\n-            ty_struct(ref did, ref substs) => {\n-                23u8.iter_bytes(lsb0, f) && did.iter_bytes(lsb0, f) && substs.iter_bytes(lsb0, f)\n-            }\n-\n-            ty_rptr(ref r, ref mt) => {\n-                24u8.iter_bytes(lsb0, f) && r.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f)\n-            }\n-\n-            ty_err => 25u8.iter_bytes(lsb0, f),\n-\n-            ty_closure(ref ct) => 26u8.iter_bytes(lsb0, f) && ct.iter_bytes(lsb0, f),\n-        }\n-    }\n-}\n-\n pub fn node_id_to_trait_ref(cx: ctxt, id: ast::node_id) -> @ty::TraitRef {\n     match cx.trait_refs.find(&id) {\n        Some(&t) => t,"}, {"sha": "fb79a7c3c994e1f978a5596528cad68c65e10214", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -112,7 +112,7 @@ pub fn replace_bound_regions_in_fn_sig(\n             // kinds of types.  This had already caused me several\n             // bugs so I decided to switch over.\n             do ty::fold_regions(tcx, *ty) |r, in_fn| {\n-                if !in_fn { isr = append_isr(isr, to_r, r); }\n+                if !in_fn { isr = append_isr(isr, |br| to_r(br), r); }\n                 r\n             };\n \n@@ -211,18 +211,18 @@ pub fn relate_nested_regions(\n         match ty::get(ty).sty {\n             ty::ty_rptr(r, ref mt) |\n             ty::ty_evec(ref mt, ty::vstore_slice(r)) => {\n-                relate(*the_stack, r, relate_op);\n+                relate(*the_stack, r, |x,y| relate_op(x,y));\n                 the_stack.push(r);\n-                walk_ty(tcx, the_stack, mt.ty, relate_op);\n+                walk_ty(tcx, the_stack, mt.ty, |x,y| relate_op(x,y));\n                 the_stack.pop();\n             }\n             _ => {\n                 ty::fold_regions_and_ty(\n                     tcx,\n                     ty,\n-                    |r| { relate(*the_stack, r, relate_op); r },\n-                    |t| { walk_ty(tcx, the_stack, t, relate_op); t },\n-                    |t| { walk_ty(tcx, the_stack, t, relate_op); t });\n+                    |r| { relate(     *the_stack, r, |x,y| relate_op(x,y)); r },\n+                    |t| { walk_ty(tcx, the_stack, t, |x,y| relate_op(x,y)); t },\n+                    |t| { walk_ty(tcx, the_stack, t, |x,y| relate_op(x,y)); t });\n             }\n         }\n     }"}, {"sha": "3e2d4a71dfbe9a430fd4dd3d57c2a4689025a8dc", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -582,7 +582,7 @@ impl InferCtxt {\n \n         debug!(\"commit()\");\n         do indent {\n-            let r = self.try(f);\n+            let r = self.try(|| f());\n \n             self.ty_var_bindings.bindings.truncate(0);\n             self.int_var_bindings.bindings.truncate(0);\n@@ -836,6 +836,6 @@ pub fn fold_regions_in_sig(\n     fldr: &fn(r: ty::Region, in_fn: bool) -> ty::Region) -> ty::FnSig\n {\n     do ty::fold_sig(fn_sig) |t| {\n-        ty::fold_regions(tcx, t, fldr)\n+        ty::fold_regions(tcx, t, |r, in_fn| fldr(r, in_fn))\n     }\n }"}, {"sha": "4380711b78e88105ca5b5aa77914f8f576f4c67b", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -548,43 +548,18 @@ use util::ppaux::note_and_explain_region;\n \n use core::cell::Cell;\n use core::hashmap::{HashMap, HashSet};\n-use core::to_bytes;\n use core::uint;\n use core::vec;\n use syntax::codemap::span;\n use syntax::ast;\n \n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n enum Constraint {\n     ConstrainVarSubVar(RegionVid, RegionVid),\n     ConstrainRegSubVar(Region, RegionVid),\n     ConstrainVarSubReg(RegionVid, Region)\n }\n \n-impl to_bytes::IterBytes for Constraint {\n-   fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            ConstrainVarSubVar(ref v0, ref v1) => {\n-                0u8.iter_bytes(lsb0, f) &&\n-                v0.iter_bytes(lsb0, f) &&\n-                v1.iter_bytes(lsb0, f)\n-            }\n-\n-            ConstrainRegSubVar(ref ra, ref va) => {\n-                1u8.iter_bytes(lsb0, f) &&\n-                ra.iter_bytes(lsb0, f) &&\n-                va.iter_bytes(lsb0, f)\n-            }\n-\n-            ConstrainVarSubReg(ref va, ref ra) => {\n-                2u8.iter_bytes(lsb0, f) &&\n-                va.iter_bytes(lsb0, f) &&\n-                ra.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n #[deriving(Eq, IterBytes)]\n struct TwoRegions {\n     a: Region,"}, {"sha": "7f9fb6ad9380f71e31ab52e440d48e9041ef1f03", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -671,7 +671,7 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     fn symmetric_difference(&self,\n                             other: &HashSet<T>,\n                             f: &fn(&T) -> bool) -> bool {\n-        self.difference(other, f) && other.difference(self, f)\n+        self.difference(other, |t| f(t)) && other.difference(self, |t| f(t))\n     }\n \n     /// Visit the values representing the intersection\n@@ -681,7 +681,8 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n \n     /// Visit the values representing the union\n     fn union(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n-        self.iter().advance(f) && other.iter().advance(|v| self.contains(v) || f(v))\n+        self.iter().advance(|t| f(t)) &&\n+            other.iter().advance(|v| self.contains(v) || f(v))\n     }\n }\n "}, {"sha": "976ca8bae7a87ca681a897d5cd67a980dc83d6b1", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -964,7 +964,7 @@ impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n                     return Some(x)\n                 }\n             }\n-            match self.iter.next().map_consume(self.f) {\n+            match self.iter.next().map_consume(|x| (self.f)(x)) {\n                 None => return None,\n                 next => self.subiter = next,\n             }"}, {"sha": "c5f2c8ae584d1991b348499e2ee7c75c0628d8fc", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -46,7 +46,7 @@ use task::local_data_priv::{local_get, local_pop, local_modify, local_set, Handl\n  *\n  * These two cases aside, the interface is safe.\n  */\n-pub type LocalDataKey<'self,T> = &'self fn(v: @T);\n+pub type LocalDataKey<'self,T> = &'self fn:Copy(v: @T);\n \n /**\n  * Remove a task-local data value from the table, returning the"}, {"sha": "1fbcda12dce14ba98e47ceaa02b03e8e6288b33f", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -595,7 +595,7 @@ pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n     let r = list_dir(p);\n     r.iter().advance(|q| {\n         let path = &p.push(*q);\n-        f(path) && (!path_is_dir(path) || walk_dir(path, f))\n+        f(path) && (!path_is_dir(path) || walk_dir(path, |p| f(p)))\n     })\n }\n "}, {"sha": "e47800d70c6b56953558dd88662d5d1916802960", "filename": "src/libstd/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -463,7 +463,7 @@ pub fn each_split_within<'a>(ss: &'a str,\n         cont\n     };\n \n-    ss.iter().enumerate().advance(machine);\n+    ss.iter().enumerate().advance(|x| machine(x));\n \n     // Let the automaton 'run out' by supplying trailing whitespace\n     let mut fake_i = ss.len();\n@@ -761,7 +761,7 @@ impl<'self> StrUtil for &'self str {\n             // NB: len includes the trailing null.\n             assert!(len > 0);\n             if unsafe { *(ptr::offset(buf,len-1)) != 0 } {\n-                to_owned(self).as_c_str(f)\n+                to_owned(self).as_c_str(|s| f(s))\n             } else {\n                 f(buf as *libc::c_char)\n             }"}, {"sha": "c932a9660c2fd0f7f36933e79a0820890161851f", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -230,11 +230,15 @@ fn each_ancestor(list:        &mut AncestorList,\n         // 'do_continue'  - Did the forward_blk succeed at this point? (i.e.,\n         //                  should we recurse? or should our callers unwind?)\n \n+        let forward_blk = Cell::new(forward_blk);\n+\n         // The map defaults to None, because if ancestors is None, we're at\n         // the end of the list, which doesn't make sense to coalesce.\n         return do (**ancestors).map_default((None,false)) |ancestor_arc| {\n             // NB: Takes a lock! (this ancestor node)\n             do access_ancestors(ancestor_arc) |nobe| {\n+                // Argh, but we couldn't give it to coalesce() otherwise.\n+                let forward_blk = forward_blk.take();\n                 // Check monotonicity\n                 assert!(last_generation > nobe.generation);\n                 /*##########################################################*"}, {"sha": "d6e92dd679ea17b27f84f095087da72d5b0f8f52", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -232,7 +232,8 @@ impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n   #[inline]\n   fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n     match *self {\n-      (ref a, ref b) => { a.iter_bytes(lsb0, f) && b.iter_bytes(lsb0, f) }\n+      (ref a, ref b) => { a.iter_bytes(lsb0, |b| f(b)) &&\n+                          b.iter_bytes(lsb0, |b| f(b)) }\n     }\n   }\n }\n@@ -242,7 +243,9 @@ impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n   fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n     match *self {\n       (ref a, ref b, ref c) => {\n-        a.iter_bytes(lsb0, f) && b.iter_bytes(lsb0, f) && c.iter_bytes(lsb0, f)\n+        a.iter_bytes(lsb0, |b| f(b)) &&\n+        b.iter_bytes(lsb0, |b| f(b)) &&\n+        c.iter_bytes(lsb0, |b| f(b))\n       }\n     }\n   }\n@@ -296,7 +299,7 @@ impl<A:IterBytes> IterBytes for Option<A> {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         match *self {\n-          Some(ref a) => 0u8.iter_bytes(lsb0, f) && a.iter_bytes(lsb0, f),\n+          Some(ref a) => 0u8.iter_bytes(lsb0, |b| f(b)) && a.iter_bytes(lsb0, |b| f(b)),\n           None => 1u8.iter_bytes(lsb0, f)\n         }\n     }"}, {"sha": "b9b03ea56619e523f4ab49926a24c5c0f75a0be7", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -251,7 +251,7 @@ impl<T> TrieNode<T> {\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         for uint::range(0, self.children.len()) |idx| {\n             match self.children[idx] {\n-                Internal(ref x) => if !x.each(f) { return false },\n+                Internal(ref x) => if !x.each(|i,t| f(i,t)) { return false },\n                 External(k, ref v) => if !f(&k, v) { return false },\n                 Nothing => ()\n             }\n@@ -262,7 +262,7 @@ impl<T> TrieNode<T> {\n     fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         for uint::range_rev(self.children.len(), 0) |idx| {\n             match self.children[idx - 1] {\n-                Internal(ref x) => if !x.each_reverse(f) { return false },\n+                Internal(ref x) => if !x.each_reverse(|i,t| f(i,t)) { return false },\n                 External(k, ref v) => if !f(&k, v) { return false },\n                 Nothing => ()\n             }\n@@ -273,7 +273,7 @@ impl<T> TrieNode<T> {\n     fn mutate_values<'a>(&'a mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n         for self.children.mut_iter().advance |child| {\n             match *child {\n-                Internal(ref mut x) => if !x.mutate_values(f) {\n+                Internal(ref mut x) => if !x.mutate_values(|i,t| f(i,t)) {\n                     return false\n                 },\n                 External(k, ref mut v) => if !f(&k, v) { return false },"}, {"sha": "4e7943f7cfd2b72b9402701b99f7b8cc947c861c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -191,7 +191,7 @@ pub fn split<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let mut start = 0u;\n     let mut result = ~[];\n     while start < ln {\n-        match position_between(v, start, ln, f) {\n+        match position_between(v, start, ln, |t| f(t)) {\n             None => break,\n             Some(i) => {\n                 result.push(v.slice(start, i).to_owned());\n@@ -215,7 +215,7 @@ pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let mut count = n;\n     let mut result = ~[];\n     while start < ln && count > 0u {\n-        match position_between(v, start, ln, f) {\n+        match position_between(v, start, ln, |t| f(t)) {\n             None => break,\n             Some(i) => {\n                 result.push(v.slice(start, i).to_owned());\n@@ -240,7 +240,7 @@ pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let mut end = ln;\n     let mut result = ~[];\n     while end > 0 {\n-        match rposition_between(v, 0, end, f) {\n+        match rposition_between(v, 0, end, |t| f(t)) {\n             None => break,\n             Some(i) => {\n                 result.push(v.slice(i + 1, end).to_owned());\n@@ -265,7 +265,7 @@ pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let mut count = n;\n     let mut result = ~[];\n     while end > 0u && count > 0u {\n-        match rposition_between(v, 0u, end, f) {\n+        match rposition_between(v, 0u, end, |t| f(t)) {\n             None => break,\n             Some(i) => {\n                 result.push(v.slice(i + 1u, end).to_owned());"}, {"sha": "bc432c4c7b0b6c1e44578c1276251eed02d6d1e5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 82, "deletions": 183, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -17,17 +17,14 @@ use parse::token::{interner_get, str_to_ident};\n \n use std::hashmap::HashMap;\n use std::option::Option;\n-use std::to_bytes::IterBytes;\n-use std::to_bytes;\n use std::to_str::ToStr;\n use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-\n // an identifier contains a Name (index into the interner\n // table) and a SyntaxContext to track renaming and\n // macro expansion per Flatt et al., \"Macros\n // That Work Together\"\n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct ident { name: Name, ctxt: SyntaxContext }\n \n /// Construct an identifier with the given name and an empty context:\n@@ -57,7 +54,7 @@ pub struct SCTable {\n pub static empty_ctxt : uint = 0;\n pub static illegal_ctxt : uint = 1;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum SyntaxContext_ {\n     EmptyCtxt,\n     Mark (Mrk,SyntaxContext),\n@@ -86,42 +83,28 @@ impl<S:Encoder> Encodable<S> for ident {\n     }\n }\n \n+#[deriving(IterBytes)]\n impl<D:Decoder> Decodable<D> for ident {\n     fn decode(d: &mut D) -> ident {\n         str_to_ident(d.read_str())\n     }\n }\n \n-impl to_bytes::IterBytes for ident {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.name.iter_bytes(lsb0, f)\n-    }\n-}\n-\n // Functions may or may not have names.\n pub type fn_ident = Option<ident>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct Lifetime {\n     id: node_id,\n     span: span,\n     ident: ident\n }\n \n-impl to_bytes::IterBytes for Lifetime {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.id.iter_bytes(lsb0, f) &&\n-        self.span.iter_bytes(lsb0, f) &&\n-        self.ident.iter_bytes(lsb0, f)\n-    }\n-}\n-\n // a \"Path\" is essentially Rust's notion of a name;\n // for instance: core::cmp::Eq  .  It's represented\n // as a sequence of identifiers, along with a bunch\n // of supporting information.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct Path {\n     span: span,\n     global: bool,\n@@ -134,7 +117,7 @@ pub type crate_num = int;\n \n pub type node_id = int;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct def_id {\n     crate: crate_num,\n     node: node_id,\n@@ -143,7 +126,7 @@ pub struct def_id {\n pub static local_crate: crate_num = 0;\n pub static crate_node_id: node_id = 0;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n // The AST represents all type param bounds as types.\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n@@ -153,14 +136,14 @@ pub enum TyParamBound {\n     RegionTyParamBound\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct TyParam {\n     ident: ident,\n     id: node_id,\n     bounds: @OptVec<TyParamBound>\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct Generics {\n     lifetimes: OptVec<Lifetime>,\n     ty_params: OptVec<TyParam>\n@@ -178,7 +161,7 @@ impl Generics {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum def {\n     def_fn(def_id, purity),\n     def_static_method(/* method */ def_id,\n@@ -216,7 +199,7 @@ pub type crate_cfg = ~[@meta_item];\n \n pub type crate = spanned<crate_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct crate_ {\n     module: _mod,\n     attrs: ~[attribute],\n@@ -225,7 +208,7 @@ pub struct crate_ {\n \n pub type meta_item = spanned<meta_item_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum meta_item_ {\n     meta_word(@str),\n     meta_list(@str, ~[@meta_item]),\n@@ -234,7 +217,7 @@ pub enum meta_item_ {\n \n pub type blk = spanned<blk_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct blk_ {\n     view_items: ~[@view_item],\n     stmts: ~[@stmt],\n@@ -243,40 +226,26 @@ pub struct blk_ {\n     rules: blk_check_mode,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct pat {\n     id: node_id,\n     node: pat_,\n     span: span,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct field_pat {\n     ident: ident,\n     pat: @pat,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum binding_mode {\n     bind_by_ref(mutability),\n     bind_infer\n }\n \n-impl to_bytes::IterBytes for binding_mode {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-          bind_by_ref(ref m) => {\n-              0u8.iter_bytes(lsb0, f) && m.iter_bytes(lsb0, f)\n-          }\n-\n-          bind_infer => {\n-              1u8.iter_bytes(lsb0, f)\n-          }\n-        }\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n@@ -301,28 +270,16 @@ pub enum pat_ {\n     pat_vec(~[@pat], Option<@pat>, ~[@pat])\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n-impl to_bytes::IterBytes for mutability {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum Sigil {\n     BorrowedSigil,\n     OwnedSigil,\n     ManagedSigil\n }\n \n-impl to_bytes::IterBytes for Sigil {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-\n impl ToStr for Sigil {\n     fn to_str(&self) -> ~str {\n         match *self {\n@@ -333,7 +290,7 @@ impl ToStr for Sigil {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n     vstore_fixed(Option<uint>),     // [1,2,3,4]\n@@ -342,7 +299,7 @@ pub enum vstore {\n     vstore_slice(Option<@Lifetime>) // &'foo? [1,2,3,4]\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum expr_vstore {\n     expr_vstore_uniq,                  // ~[1,2,3,4]\n     expr_vstore_box,                   // @[1,2,3,4]\n@@ -351,7 +308,7 @@ pub enum expr_vstore {\n     expr_vstore_mut_slice,             // &mut [1,2,3,4]\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum binop {\n     add,\n     subtract,\n@@ -373,7 +330,7 @@ pub enum binop {\n     gt,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum unop {\n     box(mutability),\n     uniq(mutability),\n@@ -384,7 +341,7 @@ pub enum unop {\n \n pub type stmt = spanned<stmt_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum stmt_ {\n     // could be an item or a local (let) binding:\n     stmt_decl(@decl, node_id),\n@@ -401,7 +358,7 @@ pub enum stmt_ {\n \n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct local_ {\n     is_mutbl: bool,\n     ty: @Ty,\n@@ -414,33 +371,33 @@ pub type local = spanned<local_>;\n \n pub type decl = spanned<decl_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum decl_ {\n     // a local (let) binding:\n     decl_local(@local),\n     // an item binding:\n     decl_item(@item),\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct arm {\n     pats: ~[@pat],\n     guard: Option<@expr>,\n     body: blk,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct field_ {\n     ident: ident,\n     expr: @expr,\n }\n \n pub type field = spanned<field_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum blk_check_mode { default_blk, unsafe_blk, }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct expr {\n     id: node_id,\n     node: expr_,\n@@ -460,14 +417,14 @@ impl expr {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum CallSugar {\n     NoSugar,\n     DoSugar,\n     ForSugar\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n@@ -538,7 +495,7 @@ pub enum expr_ {\n // else knows what to do with them, so you'll probably get a syntax\n // error.\n //\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum token_tree {\n     // a single token\n@@ -611,7 +568,7 @@ pub enum token_tree {\n //\n pub type matcher = spanned<matcher_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum matcher_ {\n     // match one token\n     match_tok(::parse::token::Token),\n@@ -624,14 +581,14 @@ pub enum matcher_ {\n \n pub type mac = spanned<mac_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum mac_ {\n     mac_invoc_tt(@Path,~[token_tree]),   // new macro-invocation\n }\n \n pub type lit = spanned<lit_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum lit_ {\n     lit_str(@str),\n     lit_int(i64, int_ty),\n@@ -645,21 +602,21 @@ pub enum lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct mt {\n     ty: @Ty,\n     mutbl: mutability,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct ty_field_ {\n     ident: ident,\n     mt: mt,\n }\n \n pub type ty_field = spanned<ty_field_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct ty_method {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -671,7 +628,7 @@ pub struct ty_method {\n     span: span,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n@@ -680,7 +637,7 @@ pub enum trait_method {\n     provided(@method),\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n impl ToStr for int_ty {\n@@ -689,13 +646,7 @@ impl ToStr for int_ty {\n     }\n }\n \n-impl to_bytes::IterBytes for int_ty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n impl ToStr for uint_ty {\n@@ -704,13 +655,7 @@ impl ToStr for uint_ty {\n     }\n }\n \n-impl to_bytes::IterBytes for uint_ty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum float_ty { ty_f, ty_f32, ty_f64, }\n \n impl ToStr for float_ty {\n@@ -719,22 +664,16 @@ impl ToStr for float_ty {\n     }\n }\n \n-impl to_bytes::IterBytes for float_ty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n // NB Eq method appears below.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct Ty {\n     id: node_id,\n     node: ty_,\n     span: span,\n }\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n@@ -743,12 +682,13 @@ pub enum prim_ty {\n     ty_bool,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum Onceness {\n     Once,\n     Many\n }\n \n+#[deriving(IterBytes)]\n impl ToStr for Onceness {\n     fn to_str(&self) -> ~str {\n         match *self {\n@@ -758,13 +698,7 @@ impl ToStr for Onceness {\n     }\n }\n \n-impl to_bytes::IterBytes for Onceness {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct TyClosure {\n     sigil: Sigil,\n     region: Option<@Lifetime>,\n@@ -779,15 +713,15 @@ pub struct TyClosure {\n     bounds: Option<OptVec<TyParamBound>>,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct TyBareFn {\n     purity: purity,\n     abis: AbiSet,\n     lifetimes: OptVec<Lifetime>,\n     decl: fn_decl\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n@@ -808,19 +742,13 @@ pub enum ty_ {\n     ty_infer,\n }\n \n-impl to_bytes::IterBytes for Ty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.span.lo.iter_bytes(lsb0, f) && self.span.hi.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum asm_dialect {\n     asm_att,\n     asm_intel\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct inline_asm {\n     asm: @str,\n     clobbers: @str,\n@@ -831,28 +759,29 @@ pub struct inline_asm {\n     dialect: asm_dialect\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct arg {\n     is_mutbl: bool,\n     ty: @Ty,\n     pat: @pat,\n     id: node_id,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct fn_decl {\n     inputs: ~[arg],\n     output: @Ty,\n     cf: ret_style,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum purity {\n     unsafe_fn, // declared with \"unsafe fn\"\n     impure_fn, // declared with \"fn\"\n     extern_fn, // declared with \"extern fn\"\n }\n \n+#[deriving(IterBytes)]\n impl ToStr for purity {\n     fn to_str(&self) -> ~str {\n         match *self {\n@@ -863,26 +792,14 @@ impl ToStr for purity {\n     }\n }\n \n-impl to_bytes::IterBytes for purity {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     return_val, // everything else\n }\n \n-impl to_bytes::IterBytes for ret_style {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum explicit_self_ {\n     sty_static,                                // no self\n     sty_value,                                 // `self`\n@@ -891,27 +808,9 @@ pub enum explicit_self_ {\n     sty_uniq(mutability)                       // `~self`\n }\n \n-impl to_bytes::IterBytes for explicit_self_ {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            sty_static => 0u8.iter_bytes(lsb0, f),\n-            sty_value => 1u8.iter_bytes(lsb0, f),\n-            sty_region(ref lft, ref mutbl) => {\n-                2u8.iter_bytes(lsb0, f) && lft.iter_bytes(lsb0, f) && mutbl.iter_bytes(lsb0, f)\n-            }\n-            sty_box(ref mutbl) => {\n-                3u8.iter_bytes(lsb0, f) && mutbl.iter_bytes(lsb0, f)\n-            }\n-            sty_uniq(ref mutbl) => {\n-                4u8.iter_bytes(lsb0, f) && mutbl.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n pub type explicit_self = spanned<explicit_self_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct method {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -926,42 +825,42 @@ pub struct method {\n     vis: visibility,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct _mod {\n     view_items: ~[@view_item],\n     items: ~[@item],\n }\n \n // Foreign mods can be named or anonymous\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum foreign_mod_sort { named, anonymous }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct foreign_mod {\n     sort: foreign_mod_sort,\n     abis: AbiSet,\n     view_items: ~[@view_item],\n     items: ~[@foreign_item],\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct variant_arg {\n     ty: @Ty,\n     id: node_id,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum variant_kind {\n     tuple_variant_kind(~[variant_arg]),\n     struct_variant_kind(@struct_def),\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct enum_def {\n     variants: ~[variant],\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct variant_ {\n     name: ident,\n     attrs: ~[attribute],\n@@ -973,7 +872,7 @@ pub struct variant_ {\n \n pub type variant = spanned<variant_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct path_list_ident_ {\n     name: ident,\n     id: node_id,\n@@ -983,7 +882,7 @@ pub type path_list_ident = spanned<path_list_ident_>;\n \n pub type view_path = spanned<view_path_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum view_path_ {\n \n     // quux = foo::bar::baz\n@@ -1000,15 +899,15 @@ pub enum view_path_ {\n     view_path_list(@Path, ~[path_list_ident], node_id)\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct view_item {\n     node: view_item_,\n     attrs: ~[attribute],\n     vis: visibility,\n     span: span,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum view_item_ {\n     view_item_extern_mod(ident, ~[@meta_item], node_id),\n     view_item_use(~[@view_path]),\n@@ -1020,11 +919,11 @@ pub type attribute = spanned<attribute_>;\n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum attr_style { attr_outer, attr_inner, }\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct attribute_ {\n     style: attr_style,\n     value: @meta_item,\n@@ -1038,13 +937,13 @@ pub struct attribute_ {\n   If this impl is an item_impl, the impl_id is redundant (it could be the\n   same as the impl's node id).\n  */\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct trait_ref {\n     path: @Path,\n     ref_id: node_id,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum visibility { public, private, inherited }\n \n impl visibility {\n@@ -1056,7 +955,7 @@ impl visibility {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct struct_field_ {\n     kind: struct_field_kind,\n     id: node_id,\n@@ -1066,13 +965,13 @@ pub struct struct_field_ {\n \n pub type struct_field = spanned<struct_field_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum struct_field_kind {\n     named_field(ident, visibility),\n     unnamed_field   // element of a tuple-like struct\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct struct_def {\n     fields: ~[@struct_field], /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n@@ -1084,7 +983,7 @@ pub struct struct_def {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct item {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -1094,7 +993,7 @@ pub struct item {\n     span: span,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum item_ {\n     item_static(@Ty, mutability, @expr),\n     item_fn(fn_decl, purity, AbiSet, Generics, blk),\n@@ -1112,7 +1011,7 @@ pub enum item_ {\n     item_mac(mac),\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct foreign_item {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -1122,7 +1021,7 @@ pub struct foreign_item {\n     vis: visibility,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, Generics),\n     foreign_item_static(@Ty, /* is_mutbl */ bool),\n@@ -1131,7 +1030,7 @@ pub enum foreign_item_ {\n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),"}, {"sha": "9439f45be21bf3d96dad70ec1035d54cc1ae3aa1", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -19,7 +19,6 @@ use visit;\n use std::hashmap::HashMap;\n use std::int;\n use std::option;\n-use std::to_bytes;\n use std::cast;\n use std::local_data;\n \n@@ -194,14 +193,6 @@ pub fn is_call_expr(e: @expr) -> bool {\n     match e.node { expr_call(*) => true, _ => false }\n }\n \n-// This makes def_id hashable\n-impl to_bytes::IterBytes for def_id {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.crate.iter_bytes(lsb0, f) && self.node.iter_bytes(lsb0, f)\n-    }\n-}\n-\n pub fn block_from_expr(e: @expr) -> blk {\n     let blk_ = default_block(~[], option::Some::<@expr>(e), e.id);\n     return spanned {node: blk_, span: e.span};\n@@ -544,18 +535,18 @@ pub fn walk_pat(pat: @pat, it: &fn(@pat) -> bool) -> bool {\n     match pat.node {\n         pat_ident(_, _, Some(p)) => walk_pat(p, it),\n         pat_struct(_, ref fields, _) => {\n-            fields.iter().advance(|f| walk_pat(f.pat, it))\n+            fields.iter().advance(|f| walk_pat(f.pat, |p| it(p)))\n         }\n         pat_enum(_, Some(ref s)) | pat_tup(ref s) => {\n-            s.iter().advance(|&p| walk_pat(p, it))\n+            s.iter().advance(|&p| walk_pat(p, |p| it(p)))\n         }\n         pat_box(s) | pat_uniq(s) | pat_region(s) => {\n             walk_pat(s, it)\n         }\n         pat_vec(ref before, ref slice, ref after) => {\n-            before.iter().advance(|&p| walk_pat(p, it)) &&\n-                slice.iter().advance(|&p| walk_pat(p, it)) &&\n-                after.iter().advance(|&p| walk_pat(p, it))\n+            before.iter().advance(|&p| walk_pat(p, |p| it(p))) &&\n+                slice.iter().advance(|&p| walk_pat(p, |p| it(p))) &&\n+                after.iter().advance(|&p| walk_pat(p, |p| it(p)))\n         }\n         pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _) |\n         pat_enum(_, _) => {\n@@ -704,7 +695,7 @@ pub fn new_sctable_internal() -> SCTable {\n pub fn get_sctable() -> @mut SCTable {\n     unsafe {\n         let sctable_key = (cast::transmute::<(uint, uint),\n-                           &fn(v: @@mut SCTable)>(\n+                           &fn:Copy(v: @@mut SCTable)>(\n                                (-4 as uint, 0u)));\n         match local_data::local_data_get(sctable_key) {\n             None => {"}, {"sha": "bcf617c56ae1eba60aa598eaa0f8f7837a9412fc", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 7, "deletions": 46, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -22,7 +22,6 @@ source code snippets, etc.\n */\n \n use std::cmp;\n-use std::to_bytes;\n use std::uint;\n use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -32,12 +31,12 @@ pub trait Pos {\n }\n \n /// A byte offset\n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct BytePos(uint);\n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct CharPos(uint);\n \n // XXX: Lots of boilerplate in these impls, but so far my attempts to fix\n@@ -67,12 +66,6 @@ impl Sub<BytePos, BytePos> for BytePos {\n     }\n }\n \n-impl to_bytes::IterBytes for BytePos {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (**self).iter_bytes(lsb0, f)\n-    }\n-}\n-\n impl Pos for CharPos {\n     fn from_uint(n: uint) -> CharPos { CharPos(n) }\n     fn to_uint(&self) -> uint { **self }\n@@ -85,12 +78,6 @@ impl cmp::Ord for CharPos {\n     fn gt(&self, other: &CharPos) -> bool { **self > **other }\n }\n \n-impl to_bytes::IterBytes for CharPos {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (**self).iter_bytes(lsb0, f)\n-    }\n-}\n-\n impl Add<CharPos,CharPos> for CharPos {\n     fn add(&self, rhs: &CharPos) -> CharPos {\n         CharPos(**self + **rhs)\n@@ -109,13 +96,14 @@ are *absolute* positions from the beginning of the codemap, not positions\n relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n to the original source.\n */\n+#[deriving(IterBytes)]\n pub struct span {\n     lo: BytePos,\n     hi: BytePos,\n     expn_info: Option<@ExpnInfo>\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct spanned<T> { node: T, span: span }\n \n impl cmp::Eq for span {\n@@ -138,14 +126,6 @@ impl<D:Decoder> Decodable<D> for span {\n     }\n }\n \n-impl to_bytes::IterBytes for span {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.lo.iter_bytes(lsb0, f) &&\n-        self.hi.iter_bytes(lsb0, f) &&\n-        self.expn_info.iter_bytes(lsb0, f)\n-    }\n-}\n-\n pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> spanned<T> {\n     respan(mk_sp(lo, hi), t)\n }\n@@ -191,40 +171,21 @@ pub struct LocWithOpt {\n // used to be structural records. Better names, anyone?\n pub struct FileMapAndLine {fm: @FileMap, line: uint}\n pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n+#[deriving(IterBytes)]\n pub struct NameAndSpan {name: @str, span: Option<span>}\n \n-impl to_bytes::IterBytes for NameAndSpan {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.name.iter_bytes(lsb0, f) && self.span.iter_bytes(lsb0, f)\n-    }\n-}\n-\n+#[deriving(IterBytes)]\n pub struct CallInfo {\n     call_site: span,\n     callee: NameAndSpan\n }\n \n-impl to_bytes::IterBytes for CallInfo {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.call_site.iter_bytes(lsb0, f) && self.callee.iter_bytes(lsb0, f)\n-    }\n-}\n-\n /// Extra information for tracking macro expansion of spans\n+#[deriving(IterBytes)]\n pub enum ExpnInfo {\n     ExpandedFrom(CallInfo)\n }\n \n-impl to_bytes::IterBytes for ExpnInfo {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            ExpandedFrom(ref call_info) => {\n-                0u8.iter_bytes(lsb0, f) && call_info.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n pub type FileName = @str;\n \n pub struct FileLines"}, {"sha": "78fdb99753d40bda9eb801cb24f9db8cf040485b", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -509,7 +509,7 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n                 }\n             },\n             ConsMapChain (~ref mut map, rest) => {\n-                if satisfies_pred(map,&n,pred) {\n+                if satisfies_pred(map,&n,|v|pred(v)) {\n                     map.insert(key,ext);\n                 } else {\n                     rest.insert_into_frame(key,ext,n,pred)"}, {"sha": "15fb6ee9ff77aa5f2ee9513ec968447b027bcfc3", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -43,15 +43,21 @@ pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n }\n \n fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n-    let lsb0_f = match substr.nonself_args {\n-        [l, f] => ~[l, f],\n+    let (lsb0, f)= match substr.nonself_args {\n+        [l, f] => (l, f),\n         _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(IterBytes)`\")\n     };\n+    // Build the \"explicitly borrowed\" stack closure, \"|_buf| f(_buf)\".\n+    let blk_arg = cx.ident_of(\"_buf\");\n+    let borrowed_f =\n+        cx.lambda_expr_1(span, cx.expr_call(span, f, ~[cx.expr_ident(span, blk_arg)]),\n+                         blk_arg);\n+\n     let iter_bytes_ident = substr.method_ident;\n     let call_iterbytes = |thing_expr| {\n         cx.expr_method_call(span,\n                               thing_expr, iter_bytes_ident,\n-                              copy lsb0_f)\n+                              ~[lsb0, borrowed_f])\n     };\n     let mut exprs = ~[];\n     let fields;"}, {"sha": "19aa29a62a9c02510c653d14184e19f52a76a194", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -99,7 +99,7 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n                     (ident, ref summary) => {\n                         cx.arm(span,\n                                ~[ pat ],\n-                               rand_thing(cx, span, ident, summary, rand_call))\n+                               rand_thing(cx, span, ident, summary, || rand_call()))\n                     }\n                 }\n             };"}, {"sha": "bf8c5ae462bf0284d5f42e5682eb9d080150602c", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -18,7 +18,7 @@\n \n use std::vec::VecIterator;\n \n-#[deriving(Encodable, Decodable)]\n+#[deriving(Encodable, Decodable,IterBytes)]\n pub enum OptVec<T> {\n     Empty,\n     Vec(~[T])"}, {"sha": "94147825da49c06df46d2f6de5fb3a97627b6d6d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -22,7 +22,7 @@ use std::local_data;\n use std::rand;\n use std::rand::RngUtil;\n \n-#[deriving(Encodable, Decodable, Eq)]\n+#[deriving(Encodable, Decodable, Eq, IterBytes)]\n pub enum binop {\n     PLUS,\n     MINUS,\n@@ -36,7 +36,7 @@ pub enum binop {\n     SHR,\n }\n \n-#[deriving(Encodable, Decodable, Eq)]\n+#[deriving(Encodable, Decodable, Eq, IterBytes)]\n pub enum Token {\n     /* Expression-operator symbols. */\n     EQ,\n@@ -97,7 +97,7 @@ pub enum Token {\n     EOF,\n }\n \n-#[deriving(Encodable, Decodable, Eq)]\n+#[deriving(Encodable, Decodable, Eq, IterBytes)]\n /// For interpolation during macro expansion.\n pub enum nonterminal {\n     nt_item(@ast::item),\n@@ -484,7 +484,7 @@ pub fn get_ident_interner() -> @ident_interner {\n     unsafe {\n         let key =\n             (cast::transmute::<(uint, uint),\n-             &fn(v: @@::parse::token::ident_interner)>(\n+             &fn:Copy(v: @@::parse::token::ident_interner)>(\n                  (-3 as uint, 0u)));\n         match local_data::local_data_get(key) {\n             Some(interner) => *interner,"}, {"sha": "848fd95a5607a0ddd734896fb7325633bffb88ab", "filename": "src/test/compile-fail/kindck-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -29,6 +29,6 @@ fn main() {\n     copy2(boxed);\n     let owned: ~fn() = || {};\n     copy2(owned);    //~ ERROR does not fulfill `Copy`\n-    let borrowed: &fn() = || {};\n+    let borrowed: &fn:Copy() = || {};\n     copy2(borrowed); //~ ERROR does not fulfill `'static`\n }"}, {"sha": "c2d8427d5eb39fed8fa1b238f745238723039bc5", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -33,8 +33,8 @@ fn map_nums(x: &ast, f: &fn(uint) -> uint) -> &ast {\n         return &num(f(x)); //~ ERROR borrowed value does not live long enough\n       }\n       add(x, y) => {\n-        let m_x = map_nums(x, f);\n-        let m_y = map_nums(y, f);\n+        let m_x = map_nums(x, |z| f(z));\n+        let m_y = map_nums(y, |z| f(z));\n         return &add(m_x, m_y);  //~ ERROR borrowed value does not live long enough\n       }\n     }"}, {"sha": "bfb1e910495dedfa24e90c14fec9589b71131a56", "filename": "src/test/compile-fail/the-case-of-the-recurring-closure-2.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Ftest%2Fcompile-fail%2Fthe-case-of-the-recurring-closure-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Ftest%2Fcompile-fail%2Fthe-case-of-the-recurring-closure-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fthe-case-of-the-recurring-closure-2.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests correct kind-checking of the reason stack closures without the :Copy\n+// bound must be noncopyable. For details see\n+// http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/\n+\n+struct R<'self> {\n+    // This struct is needed to create the\n+    // otherwise infinite type of a fn that\n+    // accepts itself as argument:\n+    c: &'self fn:Copy(&R, bool)\n+}\n+\n+fn innocent_looking_victim() {\n+    let mut x = Some(~\"hello\");\n+    do conspirator |f, writer| {\n+        if writer {\n+            x = None; //~ ERROR cannot implicitly borrow\n+        } else {\n+            match x {\n+                Some(ref msg) => {\n+                    (f.c)(f, true);\n+                    println(fmt!(\"%?\", msg));\n+                },\n+                None => fail!(\"oops\"),\n+            }\n+        }\n+    }\n+}\n+\n+fn conspirator(f: &fn:Copy(&R, bool)) {\n+    let r = R {c: f};\n+    f(&r, false)\n+}\n+\n+fn main() { innocent_looking_victim() }"}, {"sha": "f05c30c3355e0830b57d1425204ad4fd22a1e4fd", "filename": "src/test/compile-fail/the-case-of-the-recurring-closure.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Ftest%2Fcompile-fail%2Fthe-case-of-the-recurring-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9/src%2Ftest%2Fcompile-fail%2Fthe-case-of-the-recurring-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fthe-case-of-the-recurring-closure.rs?ref=132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests correct kind-checking of the reason stack closures without the :Copy\n+// bound must be noncopyable. For details see\n+// http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/\n+\n+struct R<'self> {\n+    // This struct is needed to create the\n+    // otherwise infinite type of a fn that\n+    // accepts itself as argument:\n+    c: &'self fn(&R, bool)\n+}\n+\n+fn innocent_looking_victim() {\n+    let mut x = Some(~\"hello\");\n+    do conspirator |f, writer| {\n+        if writer {\n+            x = None;\n+        } else {\n+            match x {\n+                Some(ref msg) => {\n+                    (f.c)(f, true);\n+                    println(fmt!(\"%?\", msg));\n+                },\n+                None => fail!(\"oops\"),\n+            }\n+        }\n+    }\n+}\n+\n+fn conspirator(f: &fn(&R, bool)) {\n+    let r = R {c: f};\n+    f(&r, false) //~ ERROR use of moved value\n+}\n+\n+fn main() { innocent_looking_victim() }"}]}