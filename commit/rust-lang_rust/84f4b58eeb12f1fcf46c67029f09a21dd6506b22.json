{"sha": "84f4b58eeb12f1fcf46c67029f09a21dd6506b22", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ZjRiNThlZWIxMmYxZmNmNDZjNjcwMjlmMDlhMjFkZDY1MDZiMjI=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-02T10:39:55Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-03T13:20:37Z"}, "message": "Clean up from_str_float and use iterators", "tree": {"sha": "6eb2b472850a060fdccd8edf9b252411c7ae2774", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6eb2b472850a060fdccd8edf9b252411c7ae2774"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84f4b58eeb12f1fcf46c67029f09a21dd6506b22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84f4b58eeb12f1fcf46c67029f09a21dd6506b22", "html_url": "https://github.com/rust-lang/rust/commit/84f4b58eeb12f1fcf46c67029f09a21dd6506b22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84f4b58eeb12f1fcf46c67029f09a21dd6506b22/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "251fdc877c0b2e3fdff61cbe083d1ba513f8e11b", "url": "https://api.github.com/repos/rust-lang/rust/commits/251fdc877c0b2e3fdff61cbe083d1ba513f8e11b", "html_url": "https://github.com/rust-lang/rust/commit/251fdc877c0b2e3fdff61cbe083d1ba513f8e11b"}], "stats": {"total": 281, "additions": 125, "deletions": 156}, "files": [{"sha": "0e8d5bc5ba22e0352159216fa2892772104687d6", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 125, "deletions": 156, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/84f4b58eeb12f1fcf46c67029f09a21dd6506b22/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f4b58eeb12f1fcf46c67029f09a21dd6506b22/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=84f4b58eeb12f1fcf46c67029f09a21dd6506b22", "patch": "@@ -14,15 +14,14 @@\n \n use char;\n use char::Char;\n-use clone::Clone;\n use from_str::from_str;\n use iter::Iterator;\n use num;\n-use num::{Zero, One, cast, Int, Bounded};\n+use num::{Int, Bounded};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use option::{None, Option, Some};\n use slice::{ImmutableSlice, MutableSlice, CloneableVector};\n-use str::{Str, StrSlice};\n+use str::StrSlice;\n use string::String;\n use vec::Vec;\n \n@@ -68,12 +67,6 @@ pub enum SignFormat {\n     SignAll,\n }\n \n-// Special value strings as [u8] consts.\n-static INF_BUF:     [u8, ..3] = [b'i', b'n', b'f'];\n-static POS_INF_BUF: [u8, ..4] = [b'+', b'i', b'n', b'f'];\n-static NEG_INF_BUF: [u8, ..4] = [b'-', b'i', b'n', b'f'];\n-static NAN_BUF:     [u8, ..3] = [b'N', b'a', b'N'];\n-\n /**\n  * Converts an integral number to its string representation as a byte vector.\n  * This is meant to be a common base implementation for all integral string\n@@ -102,10 +95,10 @@ static NAN_BUF:     [u8, ..3] = [b'N', b'a', b'N'];\n fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n     assert!(2 <= radix && radix <= 36);\n \n-    let _0: T = Zero::zero();\n+    let _0: T = num::zero();\n \n     let neg = num < _0;\n-    let radix_gen: T = cast(radix).unwrap();\n+    let radix_gen: T = num::cast(radix).unwrap();\n \n     let mut deccum = num;\n     // This is just for integral types, the largest of which is a u64. The\n@@ -202,8 +195,8 @@ pub fn float_to_str_bytes_common<T: Float>(\n         _ => ()\n     }\n \n-    let _0: T = Zero::zero();\n-    let _1: T = One::one();\n+    let _0: T = num::zero();\n+    let _1: T = num::one();\n \n     match num.classify() {\n         FPNaN => { return (b\"NaN\".to_vec(), true); }\n@@ -224,7 +217,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n \n     let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n     let mut buf = Vec::new();\n-    let radix_gen: T   = cast(radix as int).unwrap();\n+    let radix_gen: T = num::cast(radix as int).unwrap();\n \n     let (num, exp) = match exp_format {\n         ExpNone => (num, 0i32),\n@@ -233,12 +226,12 @@ pub fn float_to_str_bytes_common<T: Float>(\n                 (num, 0i32)\n             } else {\n                 let (exp, exp_base) = match exp_format {\n-                    ExpDec => (num.abs().log10().floor(), cast::<f64, T>(10.0f64).unwrap()),\n-                    ExpBin => (num.abs().log2().floor(), cast::<f64, T>(2.0f64).unwrap()),\n+                    ExpDec => (num.abs().log10().floor(), num::cast::<f64, T>(10.0f64).unwrap()),\n+                    ExpBin => (num.abs().log2().floor(), num::cast::<f64, T>(2.0f64).unwrap()),\n                     ExpNone => unreachable!()\n                 };\n \n-                (num / exp_base.powf(exp), cast::<T, i32>(exp).unwrap())\n+                (num / exp_base.powf(exp), num::cast::<T, i32>(exp).unwrap())\n             }\n         }\n     };\n@@ -490,163 +483,139 @@ pub fn from_str_float<T: Float>(\n         _ => ()\n     }\n \n-    let _0: T = Zero::zero();\n-    let _1: T = One::one();\n-    let radix_gen: T = cast(radix as int).unwrap();\n-    let buf = src.as_bytes();\n-\n-    let len = buf.len();\n-\n-    if len == 0 {\n-        return None;\n-    }\n+    let _0: T = num::zero();\n+    let _1: T = num::one();\n+    let radix_gen: T = num::cast(radix as int).unwrap();\n \n-    if special {\n-        if buf == INF_BUF || buf == POS_INF_BUF {\n-            return Some(Float::infinity());\n-        } else if buf == NEG_INF_BUF {\n-            return Some(Float::neg_infinity());\n-        } else if buf == NAN_BUF {\n-            return Some(Float::nan());\n-        }\n+    match src {\n+        \"inf\"   => return Some(Float::infinity()),\n+        \"-inf\"  => return Some(Float::neg_infinity()),\n+        \"NaN\"   => return Some(Float::nan()),\n+        _       => {},\n     }\n \n-    let (start, accum_positive) = match buf[0] as char {\n-      '-' => (1u, false),\n-      '+' => (1u, true),\n-       _  => (0u, true)\n+    let (is_positive, src) =  match src.slice_shift_char() {\n+        (None, _)        => return None,\n+        (Some('-'), \"\")  => return None,\n+        (Some('-'), src) => (false, src),\n+        (Some(_), _)     => (true,  src),\n     };\n \n     // Initialize accumulator with signed zero for floating point parsing to\n     // work\n-    let mut accum      = if accum_positive { _0.clone() } else { -_1 * _0};\n-    let mut last_accum = accum.clone(); // Necessary to detect overflow\n-    let mut i          = start;\n-    let mut exp_found  = false;\n+    let mut accum      = if is_positive { _0 } else { -_1 };\n+    let mut last_accum = accum; // Necessary to detect overflow\n+    let mut cs         = src.chars().enumerate();\n+    let mut exp        = None::<(char, uint)>;\n \n     // Parse integer part of number\n-    while i < len {\n-        let c = buf[i] as char;\n-\n-        match char::to_digit(c, radix) {\n-            Some(digit) => {\n-                // shift accum one digit left\n-                accum = accum * radix_gen.clone();\n-\n-                // add/subtract current digit depending on sign\n-                if accum_positive {\n-                    accum = accum + cast(digit as int).unwrap();\n-                } else {\n-                    accum = accum - cast(digit as int).unwrap();\n-                }\n-\n-                // Detect overflow by comparing to last value, except\n-                // if we've not seen any non-zero digits.\n-                if last_accum != _0 {\n-                    if accum_positive && accum <= last_accum { return Some(Float::infinity()); }\n-                    if !accum_positive && accum >= last_accum { return Some(Float::neg_infinity()); }\n-\n-                    // Detect overflow by reversing the shift-and-add process\n-                    if accum_positive &&\n-                        (last_accum != ((accum - cast(digit as int).unwrap())/radix_gen.clone())) {\n-                        return Some(Float::infinity());\n-                    }\n-                    if !accum_positive &&\n-                        (last_accum != ((accum + cast(digit as int).unwrap())/radix_gen.clone())) {\n-                        return Some(Float::neg_infinity());\n-                    }\n-                }\n-                last_accum = accum.clone();\n-            }\n-            None => match c {\n-                'e' | 'E' | 'p' | 'P' => {\n-                    exp_found = true;\n-                    break;                       // start of exponent\n-                }\n-                '.' => {\n-                    i += 1u;                     // skip the '.'\n-                    break;                       // start of fractional part\n-                }\n-                _ => return None                 // invalid number\n-            }\n-        }\n-\n-        i += 1u;\n-    }\n-\n-    // Parse fractional part of number\n-    // Skip if already reached start of exponent\n-    if !exp_found {\n-        let mut power = _1.clone();\n-\n-        while i < len {\n-            let c = buf[i] as char;\n-\n-            match char::to_digit(c, radix) {\n+    for (i, c) in cs {\n+        match c {\n+            'e' | 'E' | 'p' | 'P' => {\n+                exp = Some((c, i + 1));\n+                break;  // start of exponent\n+            },\n+            '.' => {\n+                break;  // start of fractional part\n+            },\n+            c => match c.to_digit(radix) {\n                 Some(digit) => {\n-                    // Decrease power one order of magnitude\n-                    power = power / radix_gen;\n-\n-                    let digit_t: T = cast(digit).unwrap();\n+                    // shift accum one digit left\n+                    accum = accum * radix_gen;\n \n                     // add/subtract current digit depending on sign\n-                    if accum_positive {\n-                        accum = accum + digit_t * power;\n+                    if is_positive {\n+                        accum = accum + num::cast(digit as int).unwrap();\n                     } else {\n-                        accum = accum - digit_t * power;\n+                        accum = accum - num::cast(digit as int).unwrap();\n                     }\n \n-                    // Detect overflow by comparing to last value\n-                    if accum_positive && accum < last_accum { return Some(Float::infinity()); }\n-                    if !accum_positive && accum > last_accum { return Some(Float::neg_infinity()); }\n-                    last_accum = accum.clone();\n-                }\n-                None => match c {\n-                    'e' | 'E' | 'p' | 'P' => {\n-                        exp_found = true;\n-                        break;                   // start of exponent\n+                    // Detect overflow by comparing to last value, except\n+                    // if we've not seen any non-zero digits.\n+                    if last_accum != _0 {\n+                        if  is_positive && accum <= last_accum { return Some(Float::infinity());     }\n+                        if !is_positive && accum >= last_accum { return Some(Float::neg_infinity()); }\n+\n+                        // Detect overflow by reversing the shift-and-add process\n+                        if is_positive &&\n+                            (last_accum != ((accum - num::cast(digit as int).unwrap()) / radix_gen)) {\n+                            return Some(Float::infinity());\n+                        }\n+                        if !is_positive &&\n+                            (last_accum != ((accum + num::cast(digit as int).unwrap()) / radix_gen)) {\n+                            return Some(Float::neg_infinity());\n+                        }\n                     }\n-                    _ => return None             // invalid number\n-                }\n-            }\n-\n-            i += 1u;\n+                    last_accum = accum;\n+                },\n+                None => {\n+                    return None; // invalid number\n+                },\n+            },\n         }\n     }\n \n-    // Special case: buf not empty, but does not contain any digit in front\n-    // of the exponent sign -> number is empty string\n-    if i == start {\n-        return None;\n+    // Parse fractional part of number\n+    // Skip if already reached start of exponent\n+    if exp.is_none() {\n+        let mut power = _1;\n+        for (i, c) in cs {\n+            match c {\n+                'e' | 'E' | 'p' | 'P' => {\n+                    exp = Some((c, i + 1));\n+                    break; // start of exponent\n+                },\n+                c => match c.to_digit(radix) {\n+                    Some(digit) => {\n+                        let digit: T = num::cast(digit).unwrap();\n+\n+                        // Decrease power one order of magnitude\n+                        power = power / radix_gen;\n+                        // add/subtract current digit depending on sign\n+                        accum = if is_positive {\n+                            accum + digit * power\n+                        } else {\n+                            accum - digit * power\n+                        };\n+                        // Detect overflow by comparing to last value\n+                        if  is_positive && accum < last_accum { return Some(Float::infinity());     }\n+                        if !is_positive && accum > last_accum { return Some(Float::neg_infinity()); }\n+                        last_accum = accum;\n+                    },\n+                    None => {\n+                        return None; // invalid number\n+                    },\n+                },\n+            }\n+        }\n     }\n \n-    let mut multiplier = _1.clone();\n-\n-    if exp_found {\n-        let c = buf[i] as char;\n-        let base: T = match (c, exponent) {\n-            // c is never _ so don't need to handle specially\n-            ('e', ExpDec) | ('E', ExpDec) => cast(10u).unwrap(),\n-            ('p', ExpBin) | ('P', ExpBin) => cast(2u).unwrap(),\n-            _ => return None // char doesn't fit given exponent format\n-        };\n-\n-        // parse remaining bytes as decimal integer,\n-        // skipping the exponent char\n-        let exp = from_str::<int>(String::from_utf8_lossy(buf[i+1..len]).as_slice());\n-\n-        match exp {\n-            Some(exp_pow) => {\n-                multiplier = if exp_pow < 0 {\n+    let multiplier = match exp {\n+        None => {\n+            _1 // no exponent\n+        },\n+        Some((c, offset)) => {\n+            let base: T = match (c, exponent) {\n+                // c is never _ so don't need to handle specially\n+                ('e', ExpDec) | ('E', ExpDec) => num::cast(10u).unwrap(),\n+                ('p', ExpBin) | ('P', ExpBin) => num::cast(2u).unwrap(),\n+                _ => return None, // char doesn't fit given exponent format\n+            };\n+            // parse remaining string as decimal integer\n+            let exp = from_str::<int>(src[offset..]);\n+            match exp {\n+                Some(exp_pow) if exp_pow < 0 => {\n                     _1 / num::pow(base, (-exp_pow.to_int().unwrap()) as uint)\n-                } else {\n+                },\n+                Some(exp_pow) => {\n                     num::pow(base, exp_pow.to_int().unwrap() as uint)\n-                }\n+                },\n+                None => {\n+                    return None; // invalid exponent\n+                },\n             }\n-            None => return None // invalid exponent -> invalid number\n-        }\n-    }\n-\n+        },\n+    };\n     Some(accum * multiplier)\n }\n \n@@ -659,9 +628,9 @@ pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n     let _1: T = num::one();\n     let is_signed = _0 > Bounded::min_value();\n \n-    let (is_negative, src) =  match src.slice_shift_char() {\n-        (Some('-'), src) if is_signed => (true, src),\n-        (Some(_), _) => (false, src),\n+    let (is_positive, src) =  match src.slice_shift_char() {\n+        (Some('-'), src) if is_signed => (false, src),\n+        (Some(_), _) => (true, src),\n         (None, _) => return None,\n     };\n \n@@ -671,7 +640,7 @@ pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n     let radix = cast(radix);\n     let mut result = _0;\n \n-    if is_negative {\n+    if is_positive {\n         for x in xs {\n             let x = match x {\n                 Some(x) => x,\n@@ -681,7 +650,7 @@ pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n                 Some(result) => result,\n                 None => return None,\n             };\n-            result = match result.checked_sub(&x) {\n+            result = match result.checked_add(&x) {\n                 Some(result) => result,\n                 None => return None,\n             };\n@@ -696,7 +665,7 @@ pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n                 Some(result) => result,\n                 None => return None,\n             };\n-            result = match result.checked_add(&x) {\n+            result = match result.checked_sub(&x) {\n                 Some(result) => result,\n                 None => return None,\n             };"}]}