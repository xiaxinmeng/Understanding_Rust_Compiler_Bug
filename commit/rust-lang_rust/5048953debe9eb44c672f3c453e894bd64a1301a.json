{"sha": "5048953debe9eb44c672f3c453e894bd64a1301a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwNDg5NTNkZWJlOWViNDRjNjcyZjNjNDUzZTg5NGJkNjRhMTMwMWE=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2014-11-29T00:20:14Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2014-11-30T10:50:35Z"}, "message": "Simplify `RefCell` code a bit, make `deref` a no-op.", "tree": {"sha": "e4a5e414c378ed0f07f5a8f4d661481e8cb421bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4a5e414c378ed0f07f5a8f4d661481e8cb421bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5048953debe9eb44c672f3c453e894bd64a1301a", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5048953debe9eb44c672f3c453e894bd64a1301a", "html_url": "https://github.com/rust-lang/rust/commit/5048953debe9eb44c672f3c453e894bd64a1301a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5048953debe9eb44c672f3c453e894bd64a1301a/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb52e69a503fbe1c5f7641655bc45def875584b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb52e69a503fbe1c5f7641655bc45def875584b3", "html_url": "https://github.com/rust-lang/rust/commit/fb52e69a503fbe1c5f7641655bc45def875584b3"}], "stats": {"total": 118, "additions": 75, "deletions": 43}, "files": [{"sha": "ed4df10120272e934d650140a361032726738fab", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 75, "deletions": 43, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/5048953debe9eb44c672f3c453e894bd64a1301a/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5048953debe9eb44c672f3c453e894bd64a1301a/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=5048953debe9eb44c672f3c453e894bd64a1301a", "patch": "@@ -277,12 +277,9 @@ impl<T> RefCell<T> {\n     /// Returns `None` if the value is currently mutably borrowed.\n     #[unstable = \"may be renamed, depending on global conventions\"]\n     pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n-        match self.borrow.get() {\n-            WRITING => None,\n-            borrow => {\n-                self.borrow.set(borrow + 1);\n-                Some(Ref { _parent: self })\n-            }\n+        match BorrowRef::new(&self.borrow) {\n+            Some(b) => Some(Ref { _value: unsafe { &*self.value.get() }, _borrow: b }),\n+            None => None,\n         }\n     }\n \n@@ -310,12 +307,9 @@ impl<T> RefCell<T> {\n     /// Returns `None` if the value is currently borrowed.\n     #[unstable = \"may be renamed, depending on global conventions\"]\n     pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n-        match self.borrow.get() {\n-            UNUSED => {\n-                self.borrow.set(WRITING);\n-                Some(RefMut { _parent: self })\n-            },\n-            _ => None\n+        match BorrowRefMut::new(&self.borrow) {\n+            Some(b) => Some(RefMut { _value: unsafe { &mut *self.value.get() }, _borrow: b }),\n+            None => None,\n         }\n     }\n \n@@ -368,29 +362,56 @@ impl<T: PartialEq> PartialEq for RefCell<T> {\n     }\n }\n \n-/// Wraps a borrowed reference to a value in a `RefCell` box.\n-#[unstable]\n-pub struct Ref<'b, T:'b> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _parent: &'b RefCell<T>\n+struct BorrowRef<'b> {\n+    _borrow: &'b Cell<BorrowFlag>,\n+}\n+\n+impl<'b> BorrowRef<'b> {\n+    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRef<'b>> {\n+        match borrow.get() {\n+            WRITING => None,\n+            b => {\n+                borrow.set(b + 1);\n+                Some(BorrowRef { _borrow: borrow })\n+            },\n+        }\n+    }\n }\n \n #[unsafe_destructor]\n-#[unstable]\n-impl<'b, T> Drop for Ref<'b, T> {\n+impl<'b> Drop for BorrowRef<'b> {\n     fn drop(&mut self) {\n-        let borrow = self._parent.borrow.get();\n+        let borrow = self._borrow.get();\n         debug_assert!(borrow != WRITING && borrow != UNUSED);\n-        self._parent.borrow.set(borrow - 1);\n+        self._borrow.set(borrow - 1);\n     }\n }\n \n+impl<'b> Clone for BorrowRef<'b> {\n+    fn clone(&self) -> BorrowRef<'b> {\n+        // Since this Ref exists, we know the borrow flag\n+        // is not set to WRITING.\n+        let borrow = self._borrow.get();\n+        debug_assert!(borrow != WRITING && borrow != UNUSED);\n+        self._borrow.set(borrow + 1);\n+        BorrowRef { _borrow: self._borrow }\n+    }\n+}\n+\n+/// Wraps a borrowed reference to a value in a `RefCell` box.\n+#[unstable]\n+pub struct Ref<'b, T:'b> {\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _value: &'b T,\n+    _borrow: BorrowRef<'b>,\n+}\n+\n #[unstable = \"waiting for `Deref` to become stable\"]\n impl<'b, T> Deref<T> for Ref<'b, T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n-        unsafe { &*self._parent.value.get() }\n+        self._value\n     }\n }\n \n@@ -401,49 +422,60 @@ impl<'b, T> Deref<T> for Ref<'b, T> {\n /// A `Clone` implementation would interfere with the widespread\n /// use of `r.borrow().clone()` to clone the contents of a `RefCell`.\n #[experimental = \"likely to be moved to a method, pending language changes\"]\n-pub fn clone_ref<'b, T>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n-    // Since this Ref exists, we know the borrow flag\n-    // is not set to WRITING.\n-    let borrow = orig._parent.borrow.get();\n-    debug_assert!(borrow != WRITING && borrow != UNUSED);\n-    orig._parent.borrow.set(borrow + 1);\n-\n+pub fn clone_ref<'b, T:Clone>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n     Ref {\n-        _parent: orig._parent,\n+        _value: orig._value,\n+        _borrow: orig._borrow.clone(),\n     }\n }\n \n-/// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n-#[unstable]\n-pub struct RefMut<'b, T:'b> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _parent: &'b RefCell<T>\n+struct BorrowRefMut<'b> {\n+    _borrow: &'b Cell<BorrowFlag>,\n }\n \n #[unsafe_destructor]\n-#[unstable]\n-impl<'b, T> Drop for RefMut<'b, T> {\n+impl<'b> Drop for BorrowRefMut<'b> {\n     fn drop(&mut self) {\n-        let borrow = self._parent.borrow.get();\n+        let borrow = self._borrow.get();\n         debug_assert!(borrow == WRITING);\n-        self._parent.borrow.set(UNUSED);\n+        self._borrow.set(UNUSED);\n     }\n }\n \n+impl<'b> BorrowRefMut<'b> {\n+    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRefMut<'b>> {\n+        match borrow.get() {\n+            UNUSED => {\n+                borrow.set(WRITING);\n+                Some(BorrowRefMut { _borrow: borrow })\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n+#[unstable]\n+pub struct RefMut<'b, T:'b> {\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _value: &'b mut T,\n+    _borrow: BorrowRefMut<'b>,\n+}\n+\n #[unstable = \"waiting for `Deref` to become stable\"]\n impl<'b, T> Deref<T> for RefMut<'b, T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n-        unsafe { &*self._parent.value.get() }\n+        self._value\n     }\n }\n \n #[unstable = \"waiting for `DerefMut` to become stable\"]\n impl<'b, T> DerefMut<T> for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n-        unsafe { &mut *self._parent.value.get() }\n+        self._value\n     }\n }\n "}]}