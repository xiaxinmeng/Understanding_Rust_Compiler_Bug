{"sha": "1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NTdmYjAzMWIyNzJiNGM1YmZjYzdkZTVkZjdlZGRjN2IzNmE1ODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-23T07:50:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-23T07:50:51Z"}, "message": "Auto merge of #73643 - Manishearth:rollup-68dr8fz, r=Manishearth\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #72271 (Improve compiler error message for wrong generic parameter order)\n - #72493 ( move leak-check to during coherence, candidate eval)\n - #73398 (A way forward for pointer equality in const eval)\n - #73472 (Clean up E0689 explanation)\n - #73496 (Account for multiple impl/dyn Trait in return type when suggesting `'_`)\n - #73515 (Add second message for LiveDrop errors)\n - #73567 (Clarify --extern documentation.)\n - #73572 (Fix typos in doc comments)\n - #73590 (bootstrap: no `config.toml` exists regression)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e12e35940771151a8a1f690705cf557bf5276109", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e12e35940771151a8a1f690705cf557bf5276109"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "html_url": "https://github.com/rust-lang/rust/commit/1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b1c08c68ccc2c222f84384c836b5e167e2bc241", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b1c08c68ccc2c222f84384c836b5e167e2bc241", "html_url": "https://github.com/rust-lang/rust/commit/3b1c08c68ccc2c222f84384c836b5e167e2bc241"}, {"sha": "44900f823696a04a7512be538c4994c148ecbef7", "url": "https://api.github.com/repos/rust-lang/rust/commits/44900f823696a04a7512be538c4994c148ecbef7", "html_url": "https://github.com/rust-lang/rust/commit/44900f823696a04a7512be538c4994c148ecbef7"}], "stats": {"total": 4669, "additions": 3091, "deletions": 1578}, "files": [{"sha": "82a755c7892b13d1652de7c616a298499230a444", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -893,15 +893,18 @@ def bootstrap(help_triggered):\n     build.verbose = args.verbose\n     build.clean = args.clean\n \n-    try:\n-        toml_path = os.getenv('RUST_BOOTSTRAP_CONFIG') or args.config or 'config.toml'\n+    # Read from `RUST_BOOTSTRAP_CONFIG`, then `--config`, then fallback to `config.toml` (if it\n+    # exists).\n+    toml_path = os.getenv('RUST_BOOTSTRAP_CONFIG') or args.config\n+    if not toml_path and os.path.exists('config.toml'):\n+        toml_path = 'config.toml'\n+\n+    if toml_path:\n         if not os.path.exists(toml_path):\n             toml_path = os.path.join(build.rust_root, toml_path)\n \n         with open(toml_path) as config:\n             build.config_toml = config.read()\n-    except (OSError, IOError):\n-        pass\n \n     config_verbose = build.get_toml('verbose', 'build')\n     if config_verbose is not None:\n@@ -947,11 +950,12 @@ def bootstrap(help_triggered):\n     env[\"SRC\"] = build.rust_root\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     env[\"BOOTSTRAP_PYTHON\"] = sys.executable\n-    env[\"BOOTSTRAP_CONFIG\"] = toml_path\n     env[\"BUILD_DIR\"] = build.build_dir\n     env[\"RUSTC_BOOTSTRAP\"] = '1'\n     env[\"CARGO\"] = build.cargo()\n     env[\"RUSTC\"] = build.rustc()\n+    if toml_path:\n+        env[\"BOOTSTRAP_CONFIG\"] = toml_path\n     if build.rustfmt():\n         env[\"RUSTFMT\"] = build.rustfmt()\n     run(args, env=env, verbose=build.verbose)"}, {"sha": "30b18eb56a1256c0d011ce58c7f0a200e8985014", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -273,10 +273,18 @@ This flag, when combined with other flags, makes them produce extra output.\n This flag allows you to pass the name and location for an external crate of a\n direct dependency. Indirect dependencies (dependencies of dependencies) are\n located using the [`-L` flag](#option-l-search-path). The given crate name is\n-added to the [extern prelude], which is the same as specifying `extern crate`\n-within the root module. The given crate name does not need to match the name\n+added to the [extern prelude], similar to specifying `extern crate` within the\n+root module. The given crate name does not need to match the name\n the library was built with.\n \n+Specifying `--extern` has one behavior difference from `extern crate`:\n+`--extern` merely makes the crate a _candidate_ for being linked; it does not\n+actually link it unless it's actively used. In rare occasions you may wish\n+to ensure a crate is linked even if you don't actively use it from your\n+code: for example, if it changes the global allocator or if it contains\n+`#[no_mangle]` symbols for use by other programming languages. In such\n+cases you'll need to use `extern crate`.\n+\n This flag may be specified multiple times. This flag takes an argument with\n either of the following formats:\n "}, {"sha": "67ebdcc9f33b10ed9f4bc1e4b9091f6d90f3824f", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -60,7 +60,7 @@ impl<T> RawVec<T, Global> {\n     /// `#[rustc_force_min_const_fn]` attribute which requires conformance\n     /// with `min_const_fn` but does not necessarily allow calling it in\n     /// `stable(...) const fn` / user code not enabling `foo` when\n-    /// `#[rustc_const_unstable(feature = \"foo\", ..)]` is present.\n+    /// `#[rustc_const_unstable(feature = \"foo\", issue = \"01234\")]` is present.\n     pub const NEW: Self = Self::new();\n \n     /// Creates the biggest possible `RawVec` (on the system heap)"}, {"sha": "50e321f9c7158f2fb2ec0b216d2012550d332b3f", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1012,7 +1012,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`std::any::type_name`](../../std/any/fn.type_name.html)\n-    #[rustc_const_unstable(feature = \"const_type_name\", issue = \"none\")]\n+    #[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n@@ -1021,7 +1021,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`std::any::TypeId::of`](../../std/any/struct.TypeId.html#method.of)\n-    #[rustc_const_unstable(feature = \"const_type_id\", issue = \"none\")]\n+    #[rustc_const_unstable(feature = \"const_type_id\", issue = \"41875\")]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n@@ -1931,7 +1931,7 @@ extern \"rust-intrinsic\" {\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n \n     /// See documentation of `<*const T>::offset_from` for details.\n-    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"none\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"41079\")]\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// Internal hook used by Miri to implement unwinding.\n@@ -1948,6 +1948,16 @@ extern \"rust-intrinsic\" {\n     #[cfg(not(bootstrap))]\n     #[lang = \"count_code_region\"]\n     pub fn count_code_region(index: u32);\n+\n+    /// See documentation of `<*const T>::guaranteed_eq` for details.\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[cfg(not(bootstrap))]\n+    pub fn ptr_guaranteed_eq<T>(ptr: *const T, other: *const T) -> bool;\n+\n+    /// See documentation of `<*const T>::guaranteed_ne` for details.\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[cfg(not(bootstrap))]\n+    pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "4eb2fdbd07868a83352e199925cc4780e046d19b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -87,6 +87,7 @@\n #![feature(const_generics)]\n #![feature(const_ptr_offset)]\n #![feature(const_ptr_offset_from)]\n+#![cfg_attr(not(bootstrap), feature(const_raw_ptr_comparison))]\n #![feature(const_result)]\n #![feature(const_slice_from_raw_parts)]\n #![feature(const_slice_ptr_len)]"}, {"sha": "395b3879cfd0cca6c8853b6b7c72f3359a92a0a1", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -295,6 +295,72 @@ impl<T: ?Sized> *const T {\n         intrinsics::ptr_offset_from(self, origin)\n     }\n \n+    /// Returns whether two pointers are guaranteed to be equal.\n+    ///\n+    /// At runtime this function behaves like `self == other`.\n+    /// However, in some contexts (e.g., compile-time evaluation),\n+    /// it is not always possible to determine equality of two pointers, so this function may\n+    /// spuriously return `false` for pointers that later actually turn out to be equal.\n+    /// But when it returns `true`, the pointers are guaranteed to be equal.\n+    ///\n+    /// This function is the mirror of [`guaranteed_ne`], but not its inverse. There are pointer\n+    /// comparisons for which both functions return `false`.\n+    ///\n+    /// [`guaranteed_ne`]: #method.guaranteed_ne\n+    ///\n+    /// The return value may change depending on the compiler version and unsafe code may not\n+    /// rely on the result of this function for soundness. It is suggested to only use this function\n+    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// affect the outcome, but just the performance.\n+    /// The consequences of using this method to make runtime and compile-time code behave\n+    /// differently have not been explored. This method should not be used to introduce such\n+    /// differences, and it should also not be stabilized before we have a better understanding\n+    /// of this issue.\n+    /// ```\n+    #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[inline]\n+    #[cfg(not(bootstrap))]\n+    pub const fn guaranteed_eq(self, other: *const T) -> bool\n+    where\n+        T: Sized,\n+    {\n+        intrinsics::ptr_guaranteed_eq(self, other)\n+    }\n+\n+    /// Returns whether two pointers are guaranteed to be inequal.\n+    ///\n+    /// At runtime this function behaves like `self != other`.\n+    /// However, in some contexts (e.g., compile-time evaluation),\n+    /// it is not always possible to determine the inequality of two pointers, so this function may\n+    /// spuriously return `false` for pointers that later actually turn out to be inequal.\n+    /// But when it returns `true`, the pointers are guaranteed to be inequal.\n+    ///\n+    /// This function is the mirror of [`guaranteed_eq`], but not its inverse. There are pointer\n+    /// comparisons for which both functions return `false`.\n+    ///\n+    /// [`guaranteed_eq`]: #method.guaranteed_eq\n+    ///\n+    /// The return value may change depending on the compiler version and unsafe code may not\n+    /// rely on the result of this function for soundness. It is suggested to only use this function\n+    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// affect the outcome, but just the performance.\n+    /// The consequences of using this method to make runtime and compile-time code behave\n+    /// differently have not been explored. This method should not be used to introduce such\n+    /// differences, and it should also not be stabilized before we have a better understanding\n+    /// of this issue.\n+    /// ```\n+    #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[inline]\n+    #[cfg(not(bootstrap))]\n+    pub const fn guaranteed_ne(self, other: *const T) -> bool\n+    where\n+        T: Sized,\n+    {\n+        intrinsics::ptr_guaranteed_ne(self, other)\n+    }\n+\n     /// Calculates the distance between two pointers. The returned value is in\n     /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n     ///"}, {"sha": "b86ef5b13b35344e3de6ad599497006b4e140b98", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -273,6 +273,72 @@ impl<T: ?Sized> *mut T {\n         if self.is_null() { None } else { Some(&mut *self) }\n     }\n \n+    /// Returns whether two pointers are guaranteed to be equal.\n+    ///\n+    /// At runtime this function behaves like `self == other`.\n+    /// However, in some contexts (e.g., compile-time evaluation),\n+    /// it is not always possible to determine equality of two pointers, so this function may\n+    /// spuriously return `false` for pointers that later actually turn out to be equal.\n+    /// But when it returns `true`, the pointers are guaranteed to be equal.\n+    ///\n+    /// This function is the mirror of [`guaranteed_ne`], but not its inverse. There are pointer\n+    /// comparisons for which both functions return `false`.\n+    ///\n+    /// [`guaranteed_ne`]: #method.guaranteed_ne\n+    ///\n+    /// The return value may change depending on the compiler version and unsafe code may not\n+    /// rely on the result of this function for soundness. It is suggested to only use this function\n+    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// affect the outcome, but just the performance.\n+    /// The consequences of using this method to make runtime and compile-time code behave\n+    /// differently have not been explored. This method should not be used to introduce such\n+    /// differences, and it should also not be stabilized before we have a better understanding\n+    /// of this issue.\n+    /// ```\n+    #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[inline]\n+    #[cfg(not(bootstrap))]\n+    pub const fn guaranteed_eq(self, other: *mut T) -> bool\n+    where\n+        T: Sized,\n+    {\n+        intrinsics::ptr_guaranteed_eq(self as *const _, other as *const _)\n+    }\n+\n+    /// Returns whether two pointers are guaranteed to be inequal.\n+    ///\n+    /// At runtime this function behaves like `self != other`.\n+    /// However, in some contexts (e.g., compile-time evaluation),\n+    /// it is not always possible to determine the inequality of two pointers, so this function may\n+    /// spuriously return `false` for pointers that later actually turn out to be inequal.\n+    /// But when it returns `true`, the pointers are guaranteed to be inequal.\n+    ///\n+    /// This function is the mirror of [`guaranteed_eq`], but not its inverse. There are pointer\n+    /// comparisons for which both functions return `false`.\n+    ///\n+    /// [`guaranteed_eq`]: #method.guaranteed_eq\n+    ///\n+    /// The return value may change depending on the compiler version and unsafe code may not\n+    /// rely on the result of this function for soundness. It is suggested to only use this function\n+    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// affect the outcome, but just the performance.\n+    /// The consequences of using this method to make runtime and compile-time code behave\n+    /// differently have not been explored. This method should not be used to introduce such\n+    /// differences, and it should also not be stabilized before we have a better understanding\n+    /// of this issue.\n+    /// ```\n+    #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[inline]\n+    #[cfg(not(bootstrap))]\n+    pub const unsafe fn guaranteed_ne(self, other: *mut T) -> bool\n+    where\n+        T: Sized,\n+    {\n+        intrinsics::ptr_guaranteed_ne(self as *const _, other as *const _)\n+    }\n+\n     /// Calculates the distance between two pointers. The returned value is in\n     /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n     ///"}, {"sha": "c69aafe687cf819b47736a615bee8fc6b16597f3", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -5956,10 +5956,18 @@ where\n             return false;\n         }\n \n+        #[cfg(bootstrap)]\n         if self.as_ptr() == other.as_ptr() {\n             return true;\n         }\n \n+        // While performance would suffer if `guaranteed_eq` just returned `false`\n+        // for all arguments, correctness and return value of this function are not affected.\n+        #[cfg(not(bootstrap))]\n+        if self.as_ptr().guaranteed_eq(other.as_ptr()) {\n+            return true;\n+        }\n+\n         self.iter().zip(other.iter()).all(|(x, y)| x == y)\n     }\n }\n@@ -5973,9 +5981,18 @@ where\n         if self.len() != other.len() {\n             return false;\n         }\n+\n+        #[cfg(bootstrap)]\n         if self.as_ptr() == other.as_ptr() {\n             return true;\n         }\n+\n+        // While performance would suffer if `guaranteed_eq` just returned `false`\n+        // for all arguments, correctness and return value of this function are not affected.\n+        #[cfg(not(bootstrap))]\n+        if self.as_ptr().guaranteed_eq(other.as_ptr()) {\n+            return true;\n+        }\n         unsafe {\n             let size = mem::size_of_val(self);\n             memcmp(self.as_ptr() as *const u8, other.as_ptr() as *const u8, size) == 0"}, {"sha": "0a8525f06fa3d7d04d9208188489cd396e00d3c9", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -12,7 +12,7 @@ use log::debug;\n use rustc_ast::ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n-use rustc_codegen_ssa::common::TypeKind;\n+use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n@@ -731,6 +731,16 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 return;\n             }\n \n+            \"ptr_guaranteed_eq\" | \"ptr_guaranteed_ne\" => {\n+                let a = args[0].immediate();\n+                let b = args[1].immediate();\n+                if name == \"ptr_guaranteed_eq\" {\n+                    self.icmp(IntPredicate::IntEQ, a, b)\n+                } else {\n+                    self.icmp(IntPredicate::IntNE, a, b)\n+                }\n+            }\n+\n             \"ptr_offset_from\" => {\n                 let ty = substs.type_at(0);\n                 let pointee_size = self.size_of(ty);"}, {"sha": "a680a204211274212a15939fa4324e8629fd45e3", "filename": "src/librustc_error_codes/error_codes/E0689.md", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_error_codes%2Ferror_codes%2FE0689.md", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_error_codes%2Ferror_codes%2FE0689.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0689.md?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,13 +1,16 @@\n-This error indicates that the numeric value for the method being passed exists\n-but the type of the numeric value or binding could not be identified.\n+A method was called on an ambiguous numeric type.\n \n-The error happens on numeric literals:\n+Erroneous code example:\n \n ```compile_fail,E0689\n-2.0.neg();\n+2.0.neg(); // error!\n ```\n \n-and on numeric bindings without an identified concrete type:\n+This error indicates that the numeric value for the method being passed exists\n+but the type of the numeric value or binding could not be identified.\n+\n+The error happens on numeric literals and on numeric bindings without an\n+identified concrete type:\n \n ```compile_fail,E0689\n let x = 2.0;\n@@ -19,8 +22,8 @@ Because of this, you must give the numeric literal or binding a type:\n ```\n use std::ops::Neg;\n \n-let _ = 2.0_f32.neg();\n+let _ = 2.0_f32.neg(); // ok!\n let x: f32 = 2.0;\n-let _ = x.neg();\n-let _ = (2.0 as f32).neg();\n+let _ = x.neg(); // ok!\n+let _ = (2.0 as f32).neg(); // ok!\n ```"}, {"sha": "e2d497a3adab374a18941c0069884f024fcbd873", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -401,9 +401,6 @@ declare_features! (\n     /// Allows dereferencing raw pointers during const eval.\n     (active, const_raw_ptr_deref, \"1.27.0\", Some(51911), None),\n \n-    /// Allows comparing raw pointers during const eval.\n-    (active, const_compare_raw_pointers, \"1.27.0\", Some(53020), None),\n-\n     /// Allows `#[doc(alias = \"...\")]`.\n     (active, doc_alias, \"1.27.0\", Some(50146), None),\n "}, {"sha": "8d410894e8b190083028dac2ac8acdc394ab1f23", "filename": "src/librustc_feature/removed.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_feature%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_feature%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fremoved.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -113,6 +113,11 @@ declare_features! (\n      Some(\"removed in favor of `#![feature(marker_trait_attr)]`\")),\n     /// Allows `#[no_debug]`.\n     (removed, no_debug, \"1.43.0\", Some(29721), None, Some(\"removed due to lack of demand\")),\n+\n+    /// Allows comparing raw pointers during const eval.\n+    (removed, const_compare_raw_pointers, \"1.46.0\", Some(53020), None,\n+     Some(\"cannot be allowed in const eval in any meaningful way\")),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: removed features\n     // -------------------------------------------------------------------------"}, {"sha": "6677c0e59f63a9e5cd6a0554ed0f212078e6fcde", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -26,7 +26,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         &self,\n         region: Region<'tcx>,\n         br: &ty::BoundRegion,\n-    ) -> Option<(&hir::Ty<'_>, &hir::FnDecl<'_>)> {\n+    ) -> Option<(&hir::Ty<'tcx>, &hir::FnDecl<'tcx>)> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n             if let Some(def_id) = def_id.as_local() {"}, {"sha": "3012928a09854c51253bf6febcf273b148c88093", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -2,7 +2,8 @@\n //! where one region is named and the other is anonymous.\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n-use rustc_hir::{FnRetTy, TyKind};\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::FnRetTy;\n use rustc_middle::ty;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n@@ -80,16 +81,21 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n \n             if let FnRetTy::Return(ty) = &fndecl.output {\n-                let mut v = ty::TraitObjectVisitor(vec![]);\n-                rustc_hir::intravisit::walk_ty(&mut v, ty);\n+                let mut v = ty::TraitObjectVisitor(vec![], self.tcx().hir());\n+                v.visit_ty(ty);\n \n                 debug!(\"try_report_named_anon_conflict: ret ty {:?}\", ty);\n                 if sub == &ty::ReStatic\n-                    && (matches!(ty.kind, TyKind::OpaqueDef(_, _)) || v.0.len() == 1)\n+                    && v.0\n+                        .into_iter()\n+                        .filter(|t| t.span.desugaring_kind().is_none())\n+                        .next()\n+                        .is_some()\n                 {\n+                    // If the failure is due to a `'static` requirement coming from a `dyn` or\n+                    // `impl` Trait that *isn't* caused by `async fn` desugaring, handle this case\n+                    // better in `static_impl_trait`.\n                     debug!(\"try_report_named_anon_conflict: impl Trait + 'static\");\n-                    // This is an `impl Trait` or `dyn Trait` return that evaluates de need of\n-                    // `'static`. We handle this case better in `static_impl_trait`.\n                     return None;\n                 }\n             }"}, {"sha": "46dad81a099bbd0712789c30e538f22a067cc117", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -26,8 +26,11 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 );\n                 let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n                 debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n-                let fn_return = self.tcx().return_type_impl_or_dyn_trait(anon_reg_sup.def_id)?;\n-                debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_return);\n+                let fn_returns = self.tcx().return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n+                if fn_returns.is_empty() {\n+                    return None;\n+                }\n+                debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n                 if **sub_r == RegionKind::ReStatic {\n                     let sp = var_origin.span();\n                     let return_sp = sub_origin.span();\n@@ -98,25 +101,26 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                         );\n                     }\n \n-                    // only apply this suggestion onto functions with\n-                    // explicit non-desugar'able return.\n-                    if fn_return.span.desugaring_kind().is_none() {\n-                        // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n-\n-                        let consider = \"consider changing the\";\n-                        let declare = \"to declare that the\";\n-                        let arg = match param_info.param.pat.simple_ident() {\n-                            Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n-                            None => \"the argument\".to_string(),\n-                        };\n-                        let explicit =\n-                            format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n-                        let explicit_static =\n-                            format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n-                        let captures = format!(\"captures data from {}\", arg);\n-                        let add_static_bound =\n-                            \"alternatively, add an explicit `'static` bound to this reference\";\n-                        let plus_lt = format!(\" + {}\", lifetime_name);\n+                    // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n+                    let consider = \"consider changing the\";\n+                    let declare = \"to declare that the\";\n+                    let arg = match param_info.param.pat.simple_ident() {\n+                        Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n+                        None => \"the argument\".to_string(),\n+                    };\n+                    let explicit =\n+                        format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n+                    let explicit_static =\n+                        format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n+                    let captures = format!(\"captures data from {}\", arg);\n+                    let add_static_bound =\n+                        \"alternatively, add an explicit `'static` bound to this reference\";\n+                    let plus_lt = format!(\" + {}\", lifetime_name);\n+                    for fn_return in fn_returns {\n+                        if fn_return.span.desugaring_kind().is_some() {\n+                            // Skip `async` desugaring `impl Future`.\n+                            continue;\n+                        }\n                         match fn_return.kind {\n                             TyKind::OpaqueDef(item_id, _) => {\n                                 let item = self.tcx().hir().item(item_id.id);\n@@ -143,7 +147,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                     err.span_suggestion_verbose(\n                                         span,\n                                         &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n-                                        lifetime_name,\n+                                        lifetime_name.clone(),\n                                         Applicability::MaybeIncorrect,\n                                     );\n                                     err.span_suggestion_verbose(\n@@ -152,6 +156,19 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                         param_info.param_ty.to_string(),\n                                         Applicability::MaybeIncorrect,\n                                     );\n+                                } else if let Some(_) = opaque\n+                                    .bounds\n+                                    .iter()\n+                                    .filter_map(|arg| match arg {\n+                                        GenericBound::Outlives(Lifetime { name, span, .. })\n+                                            if name.ident().to_string() == lifetime_name =>\n+                                        {\n+                                            Some(*span)\n+                                        }\n+                                        _ => None,\n+                                    })\n+                                    .next()\n+                                {\n                                 } else {\n                                     err.span_suggestion_verbose(\n                                         fn_return.span.shrink_to_hi(),\n@@ -161,10 +178,10 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                             captures = captures,\n                                             explicit = explicit,\n                                         ),\n-                                        plus_lt,\n+                                        plus_lt.clone(),\n                                         Applicability::MaybeIncorrect,\n                                     );\n-                                };\n+                                }\n                             }\n                             TyKind::TraitObject(_, lt) => match lt.name {\n                                 LifetimeName::ImplicitObjectLifetimeDefault => {\n@@ -176,15 +193,19 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                             captures = captures,\n                                             explicit = explicit,\n                                         ),\n-                                        plus_lt,\n+                                        plus_lt.clone(),\n                                         Applicability::MaybeIncorrect,\n                                     );\n                                 }\n-                                _ => {\n+                                name if name.ident().to_string() != lifetime_name => {\n+                                    // With this check we avoid suggesting redundant bounds. This\n+                                    // would happen if there are nested impl/dyn traits and only\n+                                    // one of them has the bound we'd suggest already there, like\n+                                    // in `impl Foo<X = dyn Bar> + '_`.\n                                     err.span_suggestion_verbose(\n                                         lt.span,\n                                         &format!(\"{} trait object's {}\", consider, explicit_static),\n-                                        lifetime_name,\n+                                        lifetime_name.clone(),\n                                         Applicability::MaybeIncorrect,\n                                     );\n                                     err.span_suggestion_verbose(\n@@ -194,6 +215,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                         Applicability::MaybeIncorrect,\n                                     );\n                                 }\n+                                _ => {}\n                             },\n                             _ => {}\n                         }"}, {"sha": "b6251e34008a36fe922e63b9cc4dd87cd9280857", "filename": "src/librustc_infer/infer/higher_ranked/mod.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -30,10 +30,10 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n \n         let span = self.trace.cause.span;\n \n-        self.infcx.commit_if_ok(|snapshot| {\n+        self.infcx.commit_if_ok(|_| {\n             // First, we instantiate each bound region in the supertype with a\n             // fresh placeholder region.\n-            let (b_prime, placeholder_map) = self.infcx.replace_bound_vars_with_placeholders(b);\n+            let (b_prime, _) = self.infcx.replace_bound_vars_with_placeholders(b);\n \n             // Next, we instantiate each bound region in the subtype\n             // with a fresh region variable. These region variables --\n@@ -48,8 +48,6 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n             // Compare types now that bound regions have been replaced.\n             let result = self.sub(a_is_expected).relate(&a_prime, &b_prime)?;\n \n-            self.infcx.leak_check(!a_is_expected, &placeholder_map, snapshot)?;\n-\n             debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n             Ok(ty::Binder::bind(result))\n@@ -75,7 +73,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        let next_universe = self.create_next_universe();\n+        // Figure out what the next universe will be, but don't actually create\n+        // it until after we've done the substitution (in particular there may\n+        // be no bound variables). This is a performance optimization, since the\n+        // leak check for example can be skipped if no new universes are created\n+        // (i.e., if there are no placeholders).\n+        let next_universe = self.universe().next_universe();\n \n         let fld_r = |br| {\n             self.tcx.mk_region(ty::RePlaceholder(ty::PlaceholderRegion {\n@@ -103,6 +106,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         let (result, map) = self.tcx.replace_bound_vars(binder, fld_r, fld_t, fld_c);\n \n+        // If there were higher-ranked regions to replace, then actually create\n+        // the next universe (this avoids needlessly creating universes).\n+        if !map.is_empty() {\n+            let n_u = self.create_next_universe();\n+            assert_eq!(n_u, next_universe);\n+        }\n+\n         debug!(\n             \"replace_bound_vars_with_placeholders(\\\n              next_universe={:?}, \\\n@@ -119,7 +129,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn leak_check(\n         &self,\n         overly_polymorphic: bool,\n-        placeholder_map: &PlaceholderMap<'tcx>,\n         snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> RelateResult<'tcx, ()> {\n         // If the user gave `-Zno-leak-check`, or we have been\n@@ -135,7 +144,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.inner.borrow_mut().unwrap_region_constraints().leak_check(\n             self.tcx,\n             overly_polymorphic,\n-            placeholder_map,\n+            self.universe(),\n             snapshot,\n         )\n     }"}, {"sha": "8f8ce03d638c0ef0ad7b9db46fb82f9ac4c263bb", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -991,14 +991,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             return None;\n         }\n \n-        Some(self.commit_if_ok(|snapshot| {\n-            let (ty::SubtypePredicate { a_is_expected, a, b }, placeholder_map) =\n+        Some(self.commit_if_ok(|_snapshot| {\n+            let (ty::SubtypePredicate { a_is_expected, a, b }, _) =\n                 self.replace_bound_vars_with_placeholders(&predicate);\n \n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n \n-            self.leak_check(false, &placeholder_map, snapshot)?;\n-\n             Ok(ok.unit())\n         }))\n     }\n@@ -1008,14 +1006,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         cause: &traits::ObligationCause<'tcx>,\n         predicate: ty::PolyRegionOutlivesPredicate<'tcx>,\n     ) -> UnitResult<'tcx> {\n-        self.commit_if_ok(|snapshot| {\n-            let (ty::OutlivesPredicate(r_a, r_b), placeholder_map) =\n+        self.commit_if_ok(|_snapshot| {\n+            let (ty::OutlivesPredicate(r_a, r_b), _) =\n                 self.replace_bound_vars_with_placeholders(&predicate);\n             let origin = SubregionOrigin::from_obligation_cause(cause, || {\n                 RelateRegionParamBound(cause.span)\n             });\n             self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(false, &placeholder_map, snapshot)?;\n             Ok(())\n         })\n     }"}, {"sha": "2350c28dfaaff6afc91da2b4c49c2d413e2bcaee", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -522,7 +522,13 @@ where\n         }\n \n         if a == b {\n-            return Ok(a);\n+            // Subtle: if a or b has a bound variable that we are lazilly\n+            // substituting, then even if a == b, it could be that the values we\n+            // will substitute for those bound variables are *not* the same, and\n+            // hence returning `Ok(a)` is incorrect.\n+            if !a.has_escaping_bound_vars() && !b.has_escaping_bound_vars() {\n+                return Ok(a);\n+            }\n         }\n \n         match (&a.kind, &b.kind) {"}, {"sha": "32e708bf52b32fc2568ab8ad3f83e94a314a4878", "filename": "src/librustc_infer/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 405, "deletions": 117, "changes": 522, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,158 +1,446 @@\n use super::*;\n-use crate::infer::{CombinedSnapshot, PlaceholderMap};\n-use rustc_data_structures::undo_log::UndoLogs;\n+use crate::infer::CombinedSnapshot;\n+use rustc_data_structures::{\n+    graph::{scc::Sccs, vec_graph::VecGraph},\n+    undo_log::UndoLogs,\n+};\n+use rustc_index::vec::Idx;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::RelateResult;\n \n impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n-    /// Searches region constraints created since `snapshot` that\n-    /// affect one of the placeholders in `placeholder_map`, returning\n-    /// an error if any of the placeholders are related to another\n-    /// placeholder or would have to escape into some parent universe\n-    /// that cannot name them.\n+    /// Searches new universes created during `snapshot`, looking for\n+    /// placeholders that may \"leak\" out from the universes they are contained\n+    /// in. If any leaking placeholders are found, then an `Err` is returned\n+    /// (typically leading to the snapshot being reversed).\n     ///\n-    /// This is a temporary backwards compatibility measure to try and\n-    /// retain the older (arguably incorrect) behavior of the\n-    /// compiler.\n+    /// The leak check *used* to be the only way we had to handle higher-ranked\n+    /// obligations. Now that we have integrated universes into the region\n+    /// solvers, this is no longer the case, but we retain the leak check for\n+    /// backwards compatibility purposes. In particular, it lets us make \"early\"\n+    /// decisions about whether a region error will be reported that are used in\n+    /// coherence and elsewhere -- see #56105 and #59490 for more details. The\n+    /// eventual fate of the leak checker is not yet settled.\n     ///\n-    /// NB. Although `_snapshot` isn't used, it's passed in to prove\n-    /// that we are in a snapshot, which guarantees that we can just\n-    /// search the \"undo log\" for edges. This is mostly an efficiency\n-    /// thing -- we could search *all* region constraints, but that'd be\n-    /// a bigger set and the data structures are not setup for that. If\n-    /// we wind up keeping some form of this check long term, it would\n-    /// probably be better to remove the snapshot parameter and to\n-    /// refactor the constraint set.\n+    /// The leak checker works by searching for the following error patterns:\n+    ///\n+    /// * P1: P2, where P1 != P2\n+    /// * P1: R, where R is in some universe that cannot name P1\n+    ///\n+    /// The idea here is that each of these patterns represents something that\n+    /// the region solver would eventually report as an error, so we can detect\n+    /// the error early. There is a fly in the ointment, though, in that this is\n+    /// not entirely true. In particular, in the future, we may extend the\n+    /// environment with implied bounds or other info about how placeholders\n+    /// relate to regions in outer universes. In that case, `P1: R` for example\n+    /// might become solveable.\n+    ///\n+    /// # Summary of the implementation\n+    ///\n+    /// The leak checks as follows. First, we construct a graph where `R2: R1`\n+    /// implies `R2 -> R1`, and we compute the SCCs.\n+    ///\n+    /// For each SCC S, we compute:\n+    ///\n+    /// * what placeholder P it must be equal to, if any\n+    ///   * if there are multiple placeholders that must be equal, report an error because `P1: P2`\n+    /// * the minimum universe of its constituents\n+    ///\n+    /// Then we walk the SCCs in dependency order and compute\n+    ///\n+    /// * what placeholder they must outlive transitively\n+    ///   * if they must also be equal to a placeholder, report an error because `P1: P2`\n+    /// * minimum universe U of all SCCs they must outlive\n+    ///   * if they must also be equal to a placeholder P, and U cannot name P, report an error, as that\n+    ///     indicates `P: R` and `R` is in an incompatible universe\n+    ///\n+    /// # Historical note\n+    ///\n+    /// Older variants of the leak check used to report errors for these\n+    /// patterns, but we no longer do:\n+    ///\n+    /// * R: P1, even if R cannot name P1, because R = 'static is a valid sol'n\n+    /// * R: P1, R: P2, as above\n     pub fn leak_check(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n         overly_polymorphic: bool,\n-        placeholder_map: &PlaceholderMap<'tcx>,\n-        _snapshot: &CombinedSnapshot<'_, 'tcx>,\n+        max_universe: ty::UniverseIndex,\n+        snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> RelateResult<'tcx, ()> {\n-        debug!(\"leak_check(placeholders={:?})\", placeholder_map);\n+        debug!(\n+            \"leak_check(max_universe={:?}, snapshot.universe={:?}, overly_polymorphic={:?})\",\n+            max_universe, snapshot.universe, overly_polymorphic\n+        );\n \n         assert!(UndoLogs::<super::UndoLog<'_>>::in_snapshot(&self.undo_log));\n \n-        // Go through each placeholder that we created.\n-        for &placeholder_region in placeholder_map.values() {\n-            // Find the universe this placeholder inhabits.\n-            let placeholder = match placeholder_region {\n-                ty::RePlaceholder(p) => p,\n-                _ => bug!(\"leak_check: expected placeholder found {:?}\", placeholder_region,),\n-            };\n-\n-            // Find all regions that are related to this placeholder\n-            // in some way. This means any region that either outlives\n-            // or is outlived by a placeholder.\n-            let mut taint_set = TaintSet::new(TaintDirections::both(), placeholder_region);\n-            taint_set.fixed_point(\n-                tcx,\n-                self.undo_log.region_constraints(),\n-                &self.storage.data.verifys,\n-            );\n-            let tainted_regions = taint_set.into_set();\n-\n-            // Report an error if two placeholders in the same universe\n-            // are related to one another, or if a placeholder is related\n-            // to something from a parent universe.\n-            for &tainted_region in &tainted_regions {\n-                if let ty::RePlaceholder(_) = tainted_region {\n-                    // Two placeholders cannot be related:\n-                    if tainted_region == placeholder_region {\n-                        continue;\n-                    }\n-                } else if self.universe(tainted_region).can_name(placeholder.universe) {\n-                    continue;\n-                }\n-\n-                return Err(if overly_polymorphic {\n-                    debug!(\"overly polymorphic!\");\n-                    TypeError::RegionsOverlyPolymorphic(placeholder.name, tainted_region)\n-                } else {\n-                    debug!(\"not as polymorphic!\");\n-                    TypeError::RegionsInsufficientlyPolymorphic(placeholder.name, tainted_region)\n-                });\n-            }\n+        let universe_at_start_of_snapshot = snapshot.universe;\n+        if universe_at_start_of_snapshot == max_universe {\n+            return Ok(());\n         }\n \n+        let mini_graph =\n+            &MiniGraph::new(tcx, self.undo_log.region_constraints(), &self.storage.data.verifys);\n+\n+        let mut leak_check = LeakCheck::new(\n+            tcx,\n+            universe_at_start_of_snapshot,\n+            max_universe,\n+            overly_polymorphic,\n+            mini_graph,\n+            self,\n+        );\n+        leak_check.assign_placeholder_values()?;\n+        leak_check.propagate_scc_value()?;\n         Ok(())\n     }\n }\n \n-#[derive(Debug)]\n-struct TaintSet<'tcx> {\n-    directions: TaintDirections,\n-    regions: FxHashSet<ty::Region<'tcx>>,\n+struct LeakCheck<'me, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    universe_at_start_of_snapshot: ty::UniverseIndex,\n+    overly_polymorphic: bool,\n+    mini_graph: &'me MiniGraph<'tcx>,\n+    rcc: &'me RegionConstraintCollector<'me, 'tcx>,\n+\n+    // Initially, for each SCC S, stores a placeholder `P` such that `S = P`\n+    // must hold.\n+    //\n+    // Later, during the [`LeakCheck::propagate_scc_value`] function, this array\n+    // is repurposed to store some placeholder `P` such that the weaker\n+    // condition `S: P` must hold. (This is true if `S: S1` transitively and `S1\n+    // = P`.)\n+    scc_placeholders: IndexVec<LeakCheckScc, Option<ty::PlaceholderRegion>>,\n+\n+    // For each SCC S, track the minimum universe that flows into it. Note that\n+    // this is both the minimum of the universes for every region that is a\n+    // member of the SCC, but also if you have `R1: R2`, then the universe of\n+    // `R2` must be less than the universe of `R1` (i.e., `R1` flows `R2`). To\n+    // see that, imagine that you have `P1: R` -- in that case, `R` must be\n+    // either the placeholder `P1` or the empty region in that same universe.\n+    //\n+    // To detect errors, we look for an SCC S where the values in\n+    // `scc_values[S]` (if any) cannot be stored into `scc_universes[S]`.\n+    scc_universes: IndexVec<LeakCheckScc, SccUniverse<'tcx>>,\n }\n \n-impl<'tcx> TaintSet<'tcx> {\n-    fn new(directions: TaintDirections, initial_region: ty::Region<'tcx>) -> Self {\n-        let mut regions = FxHashSet::default();\n-        regions.insert(initial_region);\n-        TaintSet { directions, regions }\n+impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        universe_at_start_of_snapshot: ty::UniverseIndex,\n+        max_universe: ty::UniverseIndex,\n+        overly_polymorphic: bool,\n+        mini_graph: &'me MiniGraph<'tcx>,\n+        rcc: &'me RegionConstraintCollector<'me, 'tcx>,\n+    ) -> Self {\n+        let dummy_scc_universe = SccUniverse { universe: max_universe, region: None };\n+        Self {\n+            tcx,\n+            universe_at_start_of_snapshot,\n+            overly_polymorphic,\n+            mini_graph,\n+            rcc,\n+            scc_placeholders: IndexVec::from_elem_n(None, mini_graph.sccs.num_sccs()),\n+            scc_universes: IndexVec::from_elem_n(dummy_scc_universe, mini_graph.sccs.num_sccs()),\n+        }\n+    }\n+\n+    /// Compute what placeholders (if any) each SCC must be equal to.\n+    /// Also compute the minimum universe of all the regions in each SCC.\n+    fn assign_placeholder_values(&mut self) -> RelateResult<'tcx, ()> {\n+        // First walk: find each placeholder that is from a newly created universe.\n+        for (region, leak_check_node) in &self.mini_graph.nodes {\n+            let scc = self.mini_graph.sccs.scc(*leak_check_node);\n+\n+            // Set the universe of each SCC to be the minimum of its constituent universes\n+            let universe = self.rcc.universe(region);\n+            debug!(\n+                \"assign_placeholder_values: scc={:?} universe={:?} region={:?}\",\n+                scc, universe, region\n+            );\n+            self.scc_universes[scc].take_min(universe, region);\n+\n+            // Detect those SCCs that directly contain a placeholder\n+            if let ty::RePlaceholder(placeholder) = region {\n+                if self.universe_at_start_of_snapshot.cannot_name(placeholder.universe) {\n+                    self.assign_scc_value(scc, *placeholder)?;\n+                }\n+            }\n+        }\n+\n+        Ok(())\n     }\n \n-    fn fixed_point<'a>(\n+    // assign_scc_value(S, P): Update `scc_values` to account for the fact that `P: S` must hold.\n+    // This may create an error.\n+    fn assign_scc_value(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n-        undo_log: impl IntoIterator<Item = &'a UndoLog<'tcx>> + Clone,\n-        verifys: &[Verify<'tcx>],\n-    ) where\n-        'tcx: 'a,\n-    {\n-        let mut prev_len = 0;\n-        while prev_len < self.len() {\n-            debug!(\"tainted: prev_len = {:?} new_len = {:?}\", prev_len, self.len());\n-\n-            prev_len = self.len();\n-\n-            for undo_entry in undo_log.clone() {\n-                match undo_entry {\n-                    &AddConstraint(Constraint::VarSubVar(a, b)) => {\n-                        self.add_edge(tcx.mk_region(ReVar(a)), tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddConstraint(Constraint::RegSubVar(a, b)) => {\n-                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddConstraint(Constraint::VarSubReg(a, b)) => {\n-                        self.add_edge(tcx.mk_region(ReVar(a)), b);\n-                    }\n-                    &AddConstraint(Constraint::RegSubReg(a, b)) => {\n-                        self.add_edge(a, b);\n-                    }\n-                    &AddGiven(a, b) => {\n-                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddVerify(i) => span_bug!(\n-                        verifys[i].origin.span(),\n-                        \"we never add verifications while doing higher-ranked things\",\n-                    ),\n-                    &AddCombination(..) | &AddVar(..) => {}\n+        scc: LeakCheckScc,\n+        placeholder: ty::PlaceholderRegion,\n+    ) -> RelateResult<'tcx, ()> {\n+        match self.scc_placeholders[scc] {\n+            Some(p) => {\n+                assert_ne!(p, placeholder);\n+                return Err(self.placeholder_error(p, placeholder));\n+            }\n+            None => {\n+                self.scc_placeholders[scc] = Some(placeholder);\n+            }\n+        };\n+\n+        Ok(())\n+    }\n+\n+    /// For each SCC S, iterate over each successor S1 where `S: S1`:\n+    ///\n+    /// * Compute\n+    /// Iterate over each SCC `S` and ensure that, for each `S1` where `S1: S`,\n+    /// `universe(S) <= universe(S1)`. This executes after\n+    /// `assign_placeholder_values`, so `universe(S)` is already the minimum\n+    /// universe of any of its direct constituents.\n+    fn propagate_scc_value(&mut self) -> RelateResult<'tcx, ()> {\n+        // Loop invariants:\n+        //\n+        // On start of the loop iteration for `scc1`:\n+        //\n+        // * `scc_universes[scc1]` contains the minimum universe of the\n+        //   constituents of `scc1`\n+        // * `scc_placeholder[scc1]` stores the placeholder that `scc1` must\n+        //   be equal to (if any)\n+        //\n+        // For each succssor `scc2` where `scc1: scc2`:\n+        //\n+        // * `scc_placeholder[scc2]` stores some placeholder `P` where\n+        //   `scc2: P` (if any)\n+        // * `scc_universes[scc2]` contains the minimum universe of the\n+        //   constituents of `scc2` and any of its successors\n+        for scc1 in self.mini_graph.sccs.all_sccs() {\n+            debug!(\n+                \"propagate_scc_value: scc={:?} with universe {:?}\",\n+                scc1, self.scc_universes[scc1]\n+            );\n+\n+            // Walk over each `scc2` such that `scc1: scc2` and compute:\n+            //\n+            // * `scc1_universe`: the minimum universe of `scc2` and the constituents of `scc1`\n+            // * `succ_bound`: placeholder `P` that the successors must outlive, if any (if there are multiple,\n+            //   we pick one arbitrarily)\n+            let mut scc1_universe = self.scc_universes[scc1];\n+            let mut succ_bound = None;\n+            for &scc2 in self.mini_graph.sccs.successors(scc1) {\n+                let SccUniverse { universe: scc2_universe, region: scc2_region } =\n+                    self.scc_universes[scc2];\n+\n+                scc1_universe.take_min(scc2_universe, scc2_region.unwrap());\n+\n+                if let Some(b) = self.scc_placeholders[scc2] {\n+                    succ_bound = Some(b);\n                 }\n             }\n+\n+            // Update minimum universe of scc1.\n+            self.scc_universes[scc1] = scc1_universe;\n+\n+            // At this point, `scc_placholder[scc1]` stores the placeholder that\n+            // `scc1` must be equal to, if any.\n+            if let Some(scc1_placeholder) = self.scc_placeholders[scc1] {\n+                debug!(\n+                    \"propagate_scc_value: scc1={:?} placeholder={:?} scc1_universe={:?}\",\n+                    scc1, scc1_placeholder, scc1_universe\n+                );\n+\n+                // Check if `P1: R` for some `R` in a universe that cannot name\n+                // P1. That's an error.\n+                if scc1_universe.universe.cannot_name(scc1_placeholder.universe) {\n+                    return Err(self.error(scc1_placeholder, scc1_universe.region.unwrap()));\n+                }\n+\n+                // Check if we have some placeholder where `S: P2`\n+                // (transitively). In that case, since `S = P1`, that implies\n+                // `P1: P2`, which is an error condition.\n+                if let Some(scc2_placeholder) = succ_bound {\n+                    assert_ne!(scc1_placeholder, scc2_placeholder);\n+                    return Err(self.placeholder_error(scc1_placeholder, scc2_placeholder));\n+                }\n+            } else {\n+                // Otherwise, we can reach a placeholder if some successor can.\n+                self.scc_placeholders[scc1] = succ_bound;\n+            }\n+\n+            // At this point, `scc_placeholder[scc1]` stores some placeholder that `scc1` must outlive (if any).\n         }\n+        Ok(())\n     }\n \n-    fn into_set(self) -> FxHashSet<ty::Region<'tcx>> {\n-        self.regions\n+    fn placeholder_error(\n+        &self,\n+        placeholder1: ty::PlaceholderRegion,\n+        placeholder2: ty::PlaceholderRegion,\n+    ) -> TypeError<'tcx> {\n+        self.error(placeholder1, self.tcx.mk_region(ty::RePlaceholder(placeholder2)))\n     }\n \n-    fn len(&self) -> usize {\n-        self.regions.len()\n+    fn error(\n+        &self,\n+        placeholder: ty::PlaceholderRegion,\n+        other_region: ty::Region<'tcx>,\n+    ) -> TypeError<'tcx> {\n+        debug!(\"error: placeholder={:?}, other_region={:?}\", placeholder, other_region);\n+        if self.overly_polymorphic {\n+            return TypeError::RegionsOverlyPolymorphic(placeholder.name, other_region);\n+        } else {\n+            return TypeError::RegionsInsufficientlyPolymorphic(placeholder.name, other_region);\n+        }\n     }\n+}\n \n-    fn add_edge(&mut self, source: ty::Region<'tcx>, target: ty::Region<'tcx>) {\n-        if self.directions.incoming {\n-            if self.regions.contains(&target) {\n-                self.regions.insert(source);\n-            }\n+// States we need to distinguish:\n+//\n+// * must be equal to a placeholder (i.e., a placeholder is in the SCC)\n+//     * it could conflict with some other regions in the SCC in different universes\n+//     * or a different placeholder\n+// * `P1: S` and `S` must be equal to a placeholder\n+// * `P1: S` and `S` is in an incompatible universe\n+//\n+// So if we\n+//\n+// (a) compute which placeholder (if any) each SCC must be equal to\n+// (b) compute its minimum universe\n+// (c) compute *some* placeholder where `S: P1` (any one will do)\n+//\n+// then we get an error if:\n+//\n+// - it must be equal to a placeholder `P1` and minimum universe cannot name `P1`\n+// - `S: P1` and minimum universe cannot name `P1`\n+// - `S: P1` and we must be equal to `P2`\n+//\n+// So we want to track:\n+//\n+// * Equal placeholder (if any)\n+// * Some bounding placeholder (if any)\n+// * Minimum universe\n+//\n+// * We compute equal placeholder + minimum universe of constituents in first pass\n+// * Then we walk in order and compute from our dependencies `S1` where `S: S1` (`S -> S1`)\n+//   * bounding placeholder (if any)\n+//   * minimum universe\n+// * And if we must be equal to a placeholder then we check it against\n+//   * minimum universe\n+//   * no bounding placeholder\n+\n+/// Tracks the \"minimum universe\" for each SCC, along with some region that\n+/// caused it to change.\n+#[derive(Copy, Clone, Debug)]\n+struct SccUniverse<'tcx> {\n+    /// For some SCC S, the minimum universe of:\n+    ///\n+    /// * each region R in S\n+    /// * each SCC S1 such that S: S1\n+    universe: ty::UniverseIndex,\n+\n+    /// Some region that caused `universe` to be what it is.\n+    region: Option<ty::Region<'tcx>>,\n+}\n+\n+impl<'tcx> SccUniverse<'tcx> {\n+    /// If `universe` is less than our current universe, then update\n+    /// `self.universe` and `self.region`.\n+    fn take_min(&mut self, universe: ty::UniverseIndex, region: ty::Region<'tcx>) {\n+        if universe < self.universe || self.region.is_none() {\n+            self.universe = universe;\n+            self.region = Some(region);\n         }\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    struct LeakCheckNode {\n+        DEBUG_FORMAT = \"LeakCheckNode({})\"\n+    }\n+}\n \n-        if self.directions.outgoing {\n-            if self.regions.contains(&source) {\n-                self.regions.insert(target);\n+rustc_index::newtype_index! {\n+    struct LeakCheckScc {\n+        DEBUG_FORMAT = \"LeakCheckScc({})\"\n+    }\n+}\n+\n+/// Represents the graph of constraints. For each `R1: R2` constraint we create\n+/// an edge `R1 -> R2` in the graph.\n+struct MiniGraph<'tcx> {\n+    /// Map from a region to the index of the node in the graph.\n+    nodes: FxHashMap<ty::Region<'tcx>, LeakCheckNode>,\n+\n+    /// Map from node index to SCC, and stores the successors of each SCC. All\n+    /// the regions in the same SCC are equal to one another, and if `S1 -> S2`,\n+    /// then `S1: S2`.\n+    sccs: Sccs<LeakCheckNode, LeakCheckScc>,\n+}\n+\n+impl<'tcx> MiniGraph<'tcx> {\n+    fn new<'a>(\n+        tcx: TyCtxt<'tcx>,\n+        undo_log: impl Iterator<Item = &'a UndoLog<'tcx>>,\n+        verifys: &[Verify<'tcx>],\n+    ) -> Self\n+    where\n+        'tcx: 'a,\n+    {\n+        let mut nodes = FxHashMap::default();\n+        let mut edges = Vec::new();\n+\n+        // Note that if `R2: R1`, we get a callback `r1, r2`, so `target` is first parameter.\n+        Self::iterate_undo_log(tcx, undo_log, verifys, |target, source| {\n+            let source_node = Self::add_node(&mut nodes, source);\n+            let target_node = Self::add_node(&mut nodes, target);\n+            edges.push((source_node, target_node));\n+        });\n+        let graph = VecGraph::new(nodes.len(), edges);\n+        let sccs = Sccs::new(&graph);\n+        Self { nodes, sccs }\n+    }\n+\n+    /// Invokes `each_edge(R1, R2)` for each edge where `R2: R1`\n+    fn iterate_undo_log<'a>(\n+        tcx: TyCtxt<'tcx>,\n+        undo_log: impl Iterator<Item = &'a UndoLog<'tcx>>,\n+        verifys: &[Verify<'tcx>],\n+        mut each_edge: impl FnMut(ty::Region<'tcx>, ty::Region<'tcx>),\n+    ) where\n+        'tcx: 'a,\n+    {\n+        for undo_entry in undo_log {\n+            match undo_entry {\n+                &AddConstraint(Constraint::VarSubVar(a, b)) => {\n+                    each_edge(tcx.mk_region(ReVar(a)), tcx.mk_region(ReVar(b)));\n+                }\n+                &AddConstraint(Constraint::RegSubVar(a, b)) => {\n+                    each_edge(a, tcx.mk_region(ReVar(b)));\n+                }\n+                &AddConstraint(Constraint::VarSubReg(a, b)) => {\n+                    each_edge(tcx.mk_region(ReVar(a)), b);\n+                }\n+                &AddConstraint(Constraint::RegSubReg(a, b)) => {\n+                    each_edge(a, b);\n+                }\n+                &AddGiven(a, b) => {\n+                    each_edge(a, tcx.mk_region(ReVar(b)));\n+                }\n+                &AddVerify(i) => span_bug!(\n+                    verifys[i].origin.span(),\n+                    \"we never add verifications while doing higher-ranked things\",\n+                ),\n+                &AddCombination(..) | &AddVar(..) => {}\n             }\n         }\n     }\n+\n+    fn add_node(\n+        nodes: &mut FxHashMap<ty::Region<'tcx>, LeakCheckNode>,\n+        r: ty::Region<'tcx>,\n+    ) -> LeakCheckNode {\n+        let l = nodes.len();\n+        *nodes.entry(r).or_insert(LeakCheckNode::new(l))\n+    }\n }"}, {"sha": "0f3f3db8679596d1e7ab990c2ccdf6a4fd7fdee2", "filename": "src/librustc_infer/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_infer%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Flib.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -16,6 +16,9 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(const_fn)]\n+#![feature(const_if_match)]\n+#![feature(const_panic)]\n #![feature(extend_one)]\n #![feature(never_type)]\n #![feature(or_patterns)]"}, {"sha": "fb9565e4b9825e352be48f4116baa1ddb3421c5f", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -38,6 +38,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefPathHash, Definitions};\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::{self, PanicLocationLangItem};\n use rustc_hir::{HirId, ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet, Node, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n@@ -1427,10 +1428,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn return_type_impl_or_dyn_trait(\n-        &self,\n-        scope_def_id: DefId,\n-    ) -> Option<&'tcx hir::Ty<'tcx>> {\n+    /// Given a `DefId` for an `fn`, return all the `dyn` and `impl` traits in its return type.\n+    pub fn return_type_impl_or_dyn_traits(&self, scope_def_id: DefId) -> Vec<&'tcx hir::Ty<'tcx>> {\n         let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n         let hir_output = match self.hir().get(hir_id) {\n             Node::Item(hir::Item {\n@@ -1466,30 +1465,12 @@ impl<'tcx> TyCtxt<'tcx> {\n                     ),\n                 ..\n             }) => ty,\n-            _ => return None,\n+            _ => return vec![],\n         };\n \n-        let ret_ty = self.type_of(scope_def_id);\n-        match ret_ty.kind {\n-            ty::FnDef(_, _) => {\n-                let sig = ret_ty.fn_sig(*self);\n-                let output = self.erase_late_bound_regions(&sig.output());\n-                if output.is_impl_trait() {\n-                    let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n-                    if let hir::FnRetTy::Return(ty) = fn_decl.output {\n-                        return Some(ty);\n-                    }\n-                } else {\n-                    let mut v = TraitObjectVisitor(vec![]);\n-                    rustc_hir::intravisit::walk_ty(&mut v, hir_output);\n-                    if v.0.len() == 1 {\n-                        return Some(v.0[0]);\n-                    }\n-                }\n-                None\n-            }\n-            _ => None,\n-        }\n+        let mut v = TraitObjectVisitor(vec![], self.hir());\n+        v.visit_ty(hir_output);\n+        v.0\n     }\n \n     pub fn return_type_impl_trait(&self, scope_def_id: DefId) -> Option<(Ty<'tcx>, Span)> {"}, {"sha": "b22727bdd7587b71848ce692971577f2cf1cdc3c", "filename": "src/librustc_middle/ty/diagnostics.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -236,7 +236,9 @@ pub fn suggest_constraining_type_param(\n     }\n }\n \n-pub struct TraitObjectVisitor<'tcx>(pub Vec<&'tcx hir::Ty<'tcx>>);\n+/// Collect al types that have an implicit `'static` obligation that we could suggest `'_` for.\n+pub struct TraitObjectVisitor<'tcx>(pub Vec<&'tcx hir::Ty<'tcx>>, pub crate::hir::map::Map<'tcx>);\n+\n impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor<'v> {\n     type Map = rustc_hir::intravisit::ErasedMap<'v>;\n \n@@ -245,15 +247,24 @@ impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor<'v> {\n     }\n \n     fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n-        if let hir::TyKind::TraitObject(\n-            _,\n-            hir::Lifetime {\n-                name: hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Static,\n-                ..\n-            },\n-        ) = ty.kind\n-        {\n-            self.0.push(ty);\n+        match ty.kind {\n+            hir::TyKind::TraitObject(\n+                _,\n+                hir::Lifetime {\n+                    name:\n+                        hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Static,\n+                    ..\n+                },\n+            ) => {\n+                self.0.push(ty);\n+            }\n+            hir::TyKind::OpaqueDef(item_id, _) => {\n+                self.0.push(ty);\n+                let item = self.1.expect_item(item_id.id);\n+                hir::intravisit::walk_item(self, item);\n+            }\n+            _ => {}\n         }\n+        hir::intravisit::walk_ty(self, ty);\n     }\n }"}, {"sha": "285d9ed64691a555e190f134a375f2fbf9059bcf", "filename": "src/librustc_mir/borrow_check/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -25,7 +25,7 @@ pub(super) fn relate_types<'tcx>(\n     category: ConstraintCategory,\n     borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n ) -> Fallible<()> {\n-    debug!(\"eq_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n+    debug!(\"relate_types(a={:?}, v={:?}, b={:?}, locations={:?})\", a, v, b, locations);\n     TypeRelating::new(\n         infcx,\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),"}, {"sha": "6ac1e6be03674a9e1cc529ea69548b219c73ba0a", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -296,6 +296,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let offset_ptr = ptr.ptr_wrapping_signed_offset(offset_bytes, self);\n                 self.write_scalar(offset_ptr, dest)?;\n             }\n+            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n+                // FIXME: return `true` for at least some comparisons where we can reliably\n+                // determine the result of runtime (in)equality tests at compile-time.\n+                self.write_scalar(Scalar::from_bool(false), dest)?;\n+            }\n             sym::ptr_offset_from => {\n                 let a = self.read_immediate(args[0])?.to_scalar()?;\n                 let b = self.read_immediate(args[1])?.to_scalar()?;"}, {"sha": "e51d9ba9c021ded81b5bc038034302922eff8571", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,7 +1,7 @@\n //! Mono Item Collection\n //! ====================\n //!\n-//! This module is responsible for discovering all items that will contribute to\n+//! This module is responsible for discovering all items that will contribute\n //! to code generation of the crate. The important part here is that it not only\n //! needs to find syntax-level items (functions, structs, etc) but also all\n //! their monomorphized instantiations. Every non-generic, non-const function\n@@ -79,7 +79,7 @@\n //! function or method call (represented by a CALL terminator in MIR). But\n //! calls are not the only thing that might introduce a reference between two\n //! function mono items, and as we will see below, they are just a\n-//! specialized of the form described next, and consequently will don't get any\n+//! specialization of the form described next, and consequently will not get any\n //! special treatment in the algorithm.\n //!\n //! #### Taking a reference to a function or method\n@@ -158,7 +158,7 @@\n //! - Eager mode is meant to be used in conjunction with incremental compilation\n //!   where a stable set of mono items is more important than a minimal\n //!   one. Thus, eager mode will instantiate drop-glue for every drop-able type\n-//!   in the crate, even of no drop call for that type exists (yet). It will\n+//!   in the crate, even if no drop call for that type exists (yet). It will\n //!   also instantiate default implementations of trait methods, something that\n //!   otherwise is only done on demand.\n //!"}, {"sha": "676688daf1c6d0ec44c38543c2a21c8391f6643c", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -160,17 +160,20 @@ pub struct InlineAsm;\n impl NonConstOp for InlineAsm {}\n \n #[derive(Debug)]\n-pub struct LiveDrop;\n+pub struct LiveDrop(pub Option<Span>);\n impl NonConstOp for LiveDrop {\n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n-        struct_span_err!(\n+        let mut diagnostic = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n             E0493,\n             \"destructors cannot be evaluated at compile-time\"\n-        )\n-        .span_label(span, format!(\"{}s cannot evaluate destructors\", ccx.const_kind()))\n-        .emit();\n+        );\n+        diagnostic.span_label(span, format!(\"{}s cannot evaluate destructors\", ccx.const_kind()));\n+        if let Some(span) = self.0 {\n+            diagnostic.span_label(span, \"value is dropped here\");\n+        }\n+        diagnostic.emit();\n     }\n }\n \n@@ -296,18 +299,16 @@ impl NonConstOp for Panic {\n #[derive(Debug)]\n pub struct RawPtrComparison;\n impl NonConstOp for RawPtrComparison {\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_compare_raw_pointers)\n-    }\n-\n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n-        feature_err(\n-            &ccx.tcx.sess.parse_sess,\n-            sym::const_compare_raw_pointers,\n-            span,\n-            &format!(\"comparing raw pointers inside {}\", ccx.const_kind()),\n-        )\n-        .emit();\n+        let mut err = ccx\n+            .tcx\n+            .sess\n+            .struct_span_err(span, \"pointers cannot be reliably compared during const eval.\");\n+        err.note(\n+            \"see issue #53020 <https://github.com/rust-lang/rust/issues/53020> \\\n+            for more information\",\n+        );\n+        err.emit();\n     }\n }\n "}, {"sha": "1fd907f89fe1819ef77e4ea1fab1368d48f17d0b", "filename": "src/librustc_mir/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -58,7 +58,7 @@ impl std::ops::Deref for CheckLiveDrops<'mir, 'tcx> {\n \n impl CheckLiveDrops<'mir, 'tcx> {\n     fn check_live_drop(&self, span: Span) {\n-        ops::non_const(self.ccx, ops::LiveDrop, span);\n+        ops::non_const(self.ccx, ops::LiveDrop(None), span);\n     }\n }\n "}, {"sha": "d263bf12e8868c20e8599614205d926dd00fe37b", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -588,7 +588,10 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 };\n \n                 if needs_drop {\n-                    self.check_op_spanned(ops::LiveDrop, err_span);\n+                    self.check_op_spanned(\n+                        ops::LiveDrop(Some(terminator.source_info.span)),\n+                        err_span,\n+                    );\n                 }\n             }\n "}, {"sha": "b8f725e967ddb4239af9fed9fbda64129ce13be8", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -171,21 +171,6 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     _ => {}\n                 }\n             }\n-            // raw pointer and fn pointer operations are unsafe as it is not clear whether one\n-            // pointer would be \"less\" or \"equal\" to another, because we cannot know where llvm\n-            // or the linker will place various statics in memory. Without this information the\n-            // result of a comparison of addresses would differ between runtime and compile-time.\n-            Rvalue::BinaryOp(_, ref lhs, _)\n-                if self.const_context && self.tcx.features().const_compare_raw_pointers =>\n-            {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n-                    self.require_unsafe(\n-                        \"pointer operation\",\n-                        \"operations on pointers in constants\",\n-                        UnsafetyViolationKind::General,\n-                    );\n-                }\n-            }\n             _ => {}\n         }\n         self.super_rvalue(rvalue, location);"}, {"sha": "06d1f36622b94ef101b913a73f293c9c5793b1b7", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -588,6 +588,8 @@ symbols! {\n         proc_macro_non_items,\n         proc_macro_path_invoc,\n         profiler_runtime,\n+        ptr_guaranteed_eq,\n+        ptr_guaranteed_ne,\n         ptr_offset_from,\n         pub_restricted,\n         pure,"}, {"sha": "3ec7fe2bf25c68f2635fb64f117a8487ee374bde", "filename": "src/librustc_trait_selection/traits/coherence.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -120,12 +120,13 @@ fn overlap<'cx, 'tcx>(\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\", a_def_id, b_def_id);\n \n     selcx.infcx().probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n-        overlap_within_probe(selcx, a_def_id, b_def_id, snapshot)\n+        overlap_within_probe(selcx, skip_leak_check, a_def_id, b_def_id, snapshot)\n     })\n }\n \n fn overlap_within_probe(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n+    skip_leak_check: SkipLeakCheck,\n     a_def_id: DefId,\n     b_def_id: DefId,\n     snapshot: &CombinedSnapshot<'_, 'tcx>,\n@@ -180,6 +181,13 @@ fn overlap_within_probe(\n         return None;\n     }\n \n+    if !skip_leak_check.is_yes() {\n+        if let Err(_) = infcx.leak_check(true, snapshot) {\n+            debug!(\"overlap: leak check failed\");\n+            return None;\n+        }\n+    }\n+\n     let impl_header = selcx.infcx().resolve_vars_if_possible(&a_impl_header);\n     let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n     debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);"}, {"sha": "bc696214cbc66a82b532026b13562fec715ffd2c", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -149,15 +149,12 @@ pub fn poly_project_and_unify_type<'cx, 'tcx>(\n     debug!(\"poly_project_and_unify_type(obligation={:?})\", obligation);\n \n     let infcx = selcx.infcx();\n-    infcx.commit_if_ok(|snapshot| {\n-        let (placeholder_predicate, placeholder_map) =\n+    infcx.commit_if_ok(|_snapshot| {\n+        let (placeholder_predicate, _) =\n             infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n \n         let placeholder_obligation = obligation.with(placeholder_predicate);\n         let result = project_and_unify_type(selcx, &placeholder_obligation)?;\n-        infcx\n-            .leak_check(false, &placeholder_map, snapshot)\n-            .map_err(|err| MismatchedProjectionTypes { err })?;\n         Ok(result)\n     })\n }"}, {"sha": "4dab5814f7b7ea8d6d0c177a71703a250fdafe7c", "filename": "src/librustc_trait_selection/traits/select/candidate_assembly.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -163,9 +163,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => return,\n         }\n \n-        let result = self.infcx.probe(|snapshot| {\n-            self.match_projection_obligation_against_definition_bounds(obligation, snapshot)\n-        });\n+        let result = self\n+            .infcx\n+            .probe(|_| self.match_projection_obligation_against_definition_bounds(obligation));\n \n         if result {\n             candidates.vec.push(ProjectionCandidate);\n@@ -345,8 +345,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligation.predicate.def_id(),\n             obligation.predicate.skip_binder().trait_ref.self_ty(),\n             |impl_def_id| {\n-                self.infcx.probe(|snapshot| {\n-                    if let Ok(_substs) = self.match_impl(impl_def_id, obligation, snapshot) {\n+                self.infcx.probe(|_| {\n+                    if let Ok(_substs) = self.match_impl(impl_def_id, obligation) {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n                     }\n                 });"}, {"sha": "834bf17227d2ebe05bfb34cb6a784818ec26ee0a", "filename": "src/librustc_trait_selection/traits/select/confirmation.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -121,9 +121,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_projection_candidate(&mut self, obligation: &TraitObligation<'tcx>) {\n-        self.infcx.commit_unconditionally(|snapshot| {\n-            let result =\n-                self.match_projection_obligation_against_definition_bounds(obligation, snapshot);\n+        self.infcx.commit_unconditionally(|_| {\n+            let result = self.match_projection_obligation_against_definition_bounds(obligation);\n             assert!(result);\n         })\n     }\n@@ -265,8 +264,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.commit_unconditionally(|snapshot| {\n-            let substs = self.rematch_impl(impl_def_id, obligation, snapshot);\n+        self.infcx.commit_unconditionally(|_| {\n+            let substs = self.rematch_impl(impl_def_id, obligation);\n             debug!(\"confirm_impl_candidate: substs={:?}\", substs);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n             ensure_sufficient_stack(|| {\n@@ -612,24 +611,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // Require that the traits involved in this upcast are **equal**;\n                 // only the **lifetime bound** is changed.\n-                //\n-                // FIXME: This condition is arguably too strong -- it would\n-                // suffice for the source trait to be a *subtype* of the target\n-                // trait. In particular, changing from something like\n-                // `for<'a, 'b> Foo<'a, 'b>` to `for<'a> Foo<'a, 'a>` should be\n-                // permitted. And, indeed, in the in commit\n-                // 904a0bde93f0348f69914ee90b1f8b6e4e0d7cbc, this\n-                // condition was loosened. However, when the leak check was\n-                // added back, using subtype here actually guides the coercion\n-                // code in such a way that it accepts `old-lub-glb-object.rs`.\n-                // This is probably a good thing, but I've modified this to `.eq`\n-                // because I want to continue rejecting that test (as we have\n-                // done for quite some time) before we are firmly comfortable\n-                // with what our behavior should be there. -nikomatsakis\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, source_trait) // FIXME -- see below\n+                    .sup(target, source_trait)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n "}, {"sha": "cff5efbfd0fd169ec6e9c1e514b2df761681a6dd", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 13, "deletions": 29, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -21,7 +21,7 @@ use super::{Normalized, ProjectionCacheKey};\n use super::{ObligationCause, PredicateObligation, TraitObligation};\n use super::{Overflow, SelectionError, Unimplemented};\n \n-use crate::infer::{CombinedSnapshot, InferCtxt, InferOk, PlaceholderMap, TypeFreshener};\n+use crate::infer::{InferCtxt, InferOk, TypeFreshener};\n use crate::traits::error_reporting::InferCtxtExt;\n use crate::traits::project::ProjectionCacheKeyExt;\n use rustc_ast::attr;\n@@ -347,6 +347,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<EvaluationResult, OverflowError> {\n         self.infcx.probe(|snapshot| -> Result<EvaluationResult, OverflowError> {\n             let result = op(self)?;\n+\n+            match self.infcx.leak_check(true, snapshot) {\n+                Ok(()) => {}\n+                Err(_) => return Ok(EvaluatedToErr),\n+            }\n+\n             match self.infcx.region_constraints_added_in_snapshot(snapshot) {\n                 None => Ok(result),\n                 Some(_) => Ok(result.max(EvaluatedToOkModuloRegions)),\n@@ -1262,10 +1268,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-        snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> bool {\n         let poly_trait_predicate = self.infcx().resolve_vars_if_possible(&obligation.predicate);\n-        let (placeholder_trait_predicate, placeholder_map) =\n+        let (placeholder_trait_predicate, _) =\n             self.infcx().replace_bound_vars_with_placeholders(&poly_trait_predicate);\n         debug!(\n             \"match_projection_obligation_against_definition_bounds: \\\n@@ -1293,13 +1298,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             if let ty::PredicateKind::Trait(bound, _) = bound.kind() {\n                 let bound = bound.to_poly_trait_ref();\n                 if self.infcx.probe(|_| {\n-                    self.match_projection(\n-                        obligation,\n-                        bound,\n-                        placeholder_trait_predicate.trait_ref,\n-                        &placeholder_map,\n-                        snapshot,\n-                    )\n+                    self.match_projection(obligation, bound, placeholder_trait_predicate.trait_ref)\n                 }) {\n                     return Some(bound);\n                 }\n@@ -1316,13 +1315,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => false,\n             Some(bound) => {\n                 // Repeat the successful match, if any, this time outside of a probe.\n-                let result = self.match_projection(\n-                    obligation,\n-                    bound,\n-                    placeholder_trait_predicate.trait_ref,\n-                    &placeholder_map,\n-                    snapshot,\n-                );\n+                let result =\n+                    self.match_projection(obligation, bound, placeholder_trait_predicate.trait_ref);\n \n                 assert!(result);\n                 true\n@@ -1335,15 +1329,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         trait_bound: ty::PolyTraitRef<'tcx>,\n         placeholder_trait_ref: ty::TraitRef<'tcx>,\n-        placeholder_map: &PlaceholderMap<'tcx>,\n-        snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> bool {\n         debug_assert!(!placeholder_trait_ref.has_escaping_bound_vars());\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n             .is_ok()\n-            && self.infcx.leak_check(false, placeholder_map, snapshot).is_ok()\n     }\n \n     fn evaluate_where_clause<'o>(\n@@ -1808,9 +1799,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         impl_def_id: DefId,\n         obligation: &TraitObligation<'tcx>,\n-        snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> Normalized<'tcx, SubstsRef<'tcx>> {\n-        match self.match_impl(impl_def_id, obligation, snapshot) {\n+        match self.match_impl(impl_def_id, obligation) {\n             Ok(substs) => substs,\n             Err(()) => {\n                 bug!(\n@@ -1826,7 +1816,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         impl_def_id: DefId,\n         obligation: &TraitObligation<'tcx>,\n-        snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> Result<Normalized<'tcx, SubstsRef<'tcx>>, ()> {\n         let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n \n@@ -1837,7 +1826,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(());\n         }\n \n-        let (placeholder_obligation, placeholder_map) =\n+        let (placeholder_obligation, _) =\n             self.infcx().replace_bound_vars_with_placeholders(&obligation.predicate);\n         let placeholder_obligation_trait_ref = placeholder_obligation.trait_ref;\n \n@@ -1869,11 +1858,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .map_err(|e| debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e))?;\n         nested_obligations.extend(obligations);\n \n-        if let Err(e) = self.infcx.leak_check(false, &placeholder_map, snapshot) {\n-            debug!(\"match_impl: failed leak check due to `{}`\", e);\n-            return Err(());\n-        }\n-\n         if !self.intercrate\n             && self.tcx().impl_polarity(impl_def_id) == ty::ImplPolarity::Reservation\n         {"}, {"sha": "1b08bf2fc7710c4c6d00518972b524ec4fe53e57", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 67, "deletions": 6, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -8,8 +8,7 @@\n use crate::collect::PlaceholderHirTyCollector;\n use crate::middle::resolve_lifetime as rl;\n use crate::require_c_abi_if_c_variadic;\n-use rustc_ast::ast::ParamKindOrd;\n-use rustc_ast::util::lev_distance::find_best_match_for_name;\n+use rustc_ast::{ast::ParamKindOrd, util::lev_distance::find_best_match_for_name};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::ErrorReported;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, FatalError};\n@@ -27,7 +26,7 @@ use rustc_middle::ty::{GenericParamDef, GenericParamDefKind};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, LATE_BOUND_LIFETIME_ARGUMENTS};\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n-use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n@@ -475,7 +474,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     /// Report an error that a generic argument did not match the generic parameter that was\n     /// expected.\n-    fn generic_arg_mismatch_err(sess: &Session, arg: &GenericArg<'_>, kind: &'static str) {\n+    fn generic_arg_mismatch_err(\n+        sess: &Session,\n+        arg: &GenericArg<'_>,\n+        kind: &'static str,\n+        help: Option<&str>,\n+    ) {\n         let mut err = struct_span_err!(\n             sess,\n             arg.span(),\n@@ -503,6 +507,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let (first, last) =\n             if kind_ord < arg_ord { (kind, arg.descr()) } else { (arg.descr(), kind) };\n         err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n+\n+        if let Some(help) = help {\n+            err.help(help);\n+        }\n         err.emit();\n     }\n \n@@ -648,7 +656,60 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 if arg_count.correct.is_ok()\n                                     && arg_count.explicit_late_bound == ExplicitLateBound::No\n                                 {\n-                                    Self::generic_arg_mismatch_err(tcx.sess, arg, kind.descr());\n+                                    // We're going to iterate over the parameters to sort them out, and\n+                                    // show that order to the user as a possible order for the parameters\n+                                    let mut param_types_present = defs\n+                                        .params\n+                                        .clone()\n+                                        .into_iter()\n+                                        .map(|param| {\n+                                            (\n+                                                match param.kind {\n+                                                    GenericParamDefKind::Lifetime => {\n+                                                        ParamKindOrd::Lifetime\n+                                                    }\n+                                                    GenericParamDefKind::Type { .. } => {\n+                                                        ParamKindOrd::Type\n+                                                    }\n+                                                    GenericParamDefKind::Const => {\n+                                                        ParamKindOrd::Const\n+                                                    }\n+                                                },\n+                                                param,\n+                                            )\n+                                        })\n+                                        .collect::<Vec<(ParamKindOrd, GenericParamDef)>>();\n+                                    param_types_present.sort_by_key(|(ord, _)| *ord);\n+                                    let (mut param_types_present, ordered_params): (\n+                                        Vec<ParamKindOrd>,\n+                                        Vec<GenericParamDef>,\n+                                    ) = param_types_present.into_iter().unzip();\n+                                    param_types_present.dedup();\n+\n+                                    Self::generic_arg_mismatch_err(\n+                                        tcx.sess,\n+                                        arg,\n+                                        kind.descr(),\n+                                        Some(&format!(\n+                                            \"reorder the arguments: {}: `<{}>`\",\n+                                            param_types_present\n+                                                .into_iter()\n+                                                .map(|ord| format!(\"{}s\", ord.to_string()))\n+                                                .collect::<Vec<String>>()\n+                                                .join(\", then \"),\n+                                            ordered_params\n+                                                .into_iter()\n+                                                .filter_map(|param| {\n+                                                    if param.name == kw::SelfUpper {\n+                                                        None\n+                                                    } else {\n+                                                        Some(param.name.to_string())\n+                                                    }\n+                                                })\n+                                                .collect::<Vec<String>>()\n+                                                .join(\", \")\n+                                        )),\n+                                    );\n                                 }\n \n                                 // We've reported the error, but we want to make sure that this\n@@ -680,7 +741,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             assert_eq!(kind, \"lifetime\");\n                             let provided =\n                                 force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n-                            Self::generic_arg_mismatch_err(tcx.sess, provided, kind);\n+                            Self::generic_arg_mismatch_err(tcx.sess, provided, kind, None);\n                         }\n \n                         break;"}, {"sha": "b6cd8da236260f9e06fc34b30cfbd3f61642230c", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -895,7 +895,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         let prev_ty = self.resolve_vars_with_obligations(prev_ty);\n         let new_ty = self.resolve_vars_with_obligations(new_ty);\n-        debug!(\"coercion::try_find_coercion_lub({:?}, {:?})\", prev_ty, new_ty);\n+        debug!(\n+            \"coercion::try_find_coercion_lub({:?}, {:?}, exprs={:?} exprs)\",\n+            prev_ty,\n+            new_ty,\n+            exprs.len()\n+        );\n \n         // Special-case that coercion alone cannot handle:\n         // Function items or non-capturing closures of differing IDs or InternalSubsts.\n@@ -1001,6 +1006,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Ok(ok) => {\n                     let (adjustments, target) = self.register_infer_ok_obligations(ok);\n                     self.apply_adjustments(new, adjustments);\n+                    debug!(\n+                        \"coercion::try_find_coercion_lub: was able to coerce from previous type {:?} to new type {:?}\",\n+                        prev_ty, new_ty,\n+                    );\n                     return Ok(target);\n                 }\n                 Err(e) => first_error = Some(e),\n@@ -1031,6 +1040,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n \n             if !noop {\n+                debug!(\n+                    \"coercion::try_find_coercion_lub: older expression {:?} had adjustments, requiring LUB\",\n+                    expr,\n+                );\n+\n                 return self\n                     .commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n                     .map(|ok| self.register_infer_ok_obligations(ok));\n@@ -1048,6 +1062,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             Ok(ok) => {\n+                debug!(\n+                    \"coercion::try_find_coercion_lub: was able to coerce previous type {:?} to new type {:?}\",\n+                    prev_ty, new_ty,\n+                );\n                 let (adjustments, target) = self.register_infer_ok_obligations(ok);\n                 for expr in exprs {\n                     let expr = expr.as_coercion_site();"}, {"sha": "ef6c7c14404a7239b9bf5b840e7f37f67ed5c66d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -74,9 +74,8 @@ pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n         | \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" | \"saturating_add\"\n         | \"saturating_sub\" | \"rotate_left\" | \"rotate_right\" | \"ctpop\" | \"ctlz\" | \"cttz\"\n         | \"bswap\" | \"bitreverse\" | \"discriminant_value\" | \"type_id\" | \"likely\" | \"unlikely\"\n-        | \"minnumf32\" | \"minnumf64\" | \"maxnumf32\" | \"maxnumf64\" | \"type_name\" => {\n-            hir::Unsafety::Normal\n-        }\n+        | \"ptr_guaranteed_eq\" | \"ptr_guaranteed_ne\" | \"minnumf32\" | \"minnumf64\" | \"maxnumf32\"\n+        | \"maxnumf64\" | \"type_name\" => hir::Unsafety::Normal,\n         _ => hir::Unsafety::Unsafe,\n     }\n }\n@@ -258,6 +257,10 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 (1, vec![param(0), param(0)], tcx.intern_tup(&[param(0), tcx.types.bool]))\n             }\n \n+            \"ptr_guaranteed_eq\" | \"ptr_guaranteed_ne\" => {\n+                (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.bool)\n+            }\n+\n             \"ptr_offset_from\" => {\n                 (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.isize)\n             }"}, {"sha": "3dd9c9c5c39dbc4781a60c55d671057248371d4c", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -10,8 +10,7 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n-use rustc_session::parse::feature_err;\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::traits;\n \n@@ -303,25 +302,22 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             GenericParamKind::Type { default: Some(ref ty), .. } => icx.to_ty(ty),\n             GenericParamKind::Const { ty: ref hir_ty, .. } => {\n                 let ty = icx.to_ty(hir_ty);\n-                if !tcx.features().const_compare_raw_pointers {\n-                    let err = match ty.peel_refs().kind {\n-                        ty::FnPtr(_) => Some(\"function pointers\"),\n-                        ty::RawPtr(_) => Some(\"raw pointers\"),\n-                        _ => None,\n-                    };\n-                    if let Some(unsupported_type) = err {\n-                        feature_err(\n-                            &tcx.sess.parse_sess,\n-                            sym::const_compare_raw_pointers,\n+                let err = match ty.peel_refs().kind {\n+                    ty::FnPtr(_) => Some(\"function pointers\"),\n+                    ty::RawPtr(_) => Some(\"raw pointers\"),\n+                    _ => None,\n+                };\n+                if let Some(unsupported_type) = err {\n+                    tcx.sess\n+                        .struct_span_err(\n                             hir_ty.span,\n                             &format!(\n-                                \"using {} as const generic parameters is unstable\",\n+                                \"using {} as const generic parameters is forbidden\",\n                                 unsupported_type\n                             ),\n                         )\n                         .emit();\n-                    };\n-                }\n+                };\n                 if traits::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n                     .is_some()\n                 {"}, {"sha": "aeb38f3f91068b9d0dc119ac3f4d24c3fb63ec11", "filename": "src/test/mir-opt/address-of/rustc.address_of_reborrow.SimplifyCfg-initial.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fmir-opt%2Faddress-of%2Frustc.address_of_reborrow.SimplifyCfg-initial.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fmir-opt%2Faddress-of%2Frustc.address_of_reborrow.SimplifyCfg-initial.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Faddress-of%2Frustc.address_of_reborrow.SimplifyCfg-initial.after.mir?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -12,7 +12,7 @@\n | 8: Canonical { max_universe: U0, variables: [], value: Ty(*const [i32]) } at $DIR/address-of.rs:16:12: 16:24\n | 9: Canonical { max_universe: U0, variables: [], value: Ty(*const [i32]) } at $DIR/address-of.rs:16:12: 16:24\n | 10: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }], value: Ty(*const ^0) } at $DIR/address-of.rs:18:5: 18:18\n-| 11: Canonical { max_universe: U3, variables: [CanonicalVarInfo { kind: Region(U3) }], value: Ty(*const dyn std::marker::Send) } at $DIR/address-of.rs:20:5: 20:25\n+| 11: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Region(U0) }], value: Ty(*const dyn std::marker::Send) } at $DIR/address-of.rs:20:5: 20:25\n | 12: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }], value: Ty(*const ^0) } at $DIR/address-of.rs:23:12: 23:20\n | 13: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }], value: Ty(*const ^0) } at $DIR/address-of.rs:23:12: 23:20\n | 14: Canonical { max_universe: U0, variables: [], value: Ty(*const [i32; 10]) } at $DIR/address-of.rs:24:12: 24:28\n@@ -22,7 +22,7 @@\n | 18: Canonical { max_universe: U0, variables: [], value: Ty(*const [i32]) } at $DIR/address-of.rs:26:12: 26:24\n | 19: Canonical { max_universe: U0, variables: [], value: Ty(*const [i32]) } at $DIR/address-of.rs:26:12: 26:24\n | 20: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }], value: Ty(*mut ^0) } at $DIR/address-of.rs:28:5: 28:16\n-| 21: Canonical { max_universe: U6, variables: [CanonicalVarInfo { kind: Region(U6) }], value: Ty(*mut dyn std::marker::Send) } at $DIR/address-of.rs:30:5: 30:23\n+| 21: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Region(U0) }], value: Ty(*mut dyn std::marker::Send) } at $DIR/address-of.rs:30:5: 30:23\n | 22: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }], value: Ty(*mut ^0) } at $DIR/address-of.rs:33:12: 33:18\n | 23: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }], value: Ty(*mut ^0) } at $DIR/address-of.rs:33:12: 33:18\n | 24: Canonical { max_universe: U0, variables: [], value: Ty(*mut [i32; 10]) } at $DIR/address-of.rs:34:12: 34:26"}, {"sha": "25e9f726ba53a866cb3d42c0799da27b7edd5592", "filename": "src/test/ui/associated-types/associated-types-eq-hr.nll.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,33 @@\n+error[E0271]: type mismatch resolving `for<'x> <UintStruct as TheTrait<&'x isize>>::A == &'x isize`\n+  --> $DIR/associated-types-eq-hr.rs:87:5\n+   |\n+LL | fn foo<T>()\n+   |    --- required by a bound in this\n+LL | where\n+LL |     T: for<'x> TheTrait<&'x isize, A = &'x isize>,\n+   |                                    ------------- required by this bound in `foo`\n+...\n+LL |     foo::<UintStruct>();\n+   |     ^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n+   |\n+   = note: expected reference `&isize`\n+              found reference `&usize`\n+\n+error[E0271]: type mismatch resolving `for<'x> <IntStruct as TheTrait<&'x isize>>::A == &'x usize`\n+  --> $DIR/associated-types-eq-hr.rs:91:5\n+   |\n+LL | fn bar<T>()\n+   |    --- required by a bound in this\n+LL | where\n+LL |     T: for<'x> TheTrait<&'x isize, A = &'x usize>,\n+   |                                    ------------- required by this bound in `bar`\n+...\n+LL |     bar::<IntStruct>();\n+   |     ^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n+   |\n+   = note: expected reference `&usize`\n+              found reference `&isize`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "fb391913c321ecd0c71384ed633e308f76cabaa7", "filename": "src/test/ui/associated-types/associated-types-eq-hr.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -7,7 +7,7 @@ pub trait TheTrait<T> {\n }\n \n struct IntStruct {\n-    x: isize\n+    x: isize,\n }\n \n impl<'a> TheTrait<&'a isize> for IntStruct {\n@@ -19,7 +19,7 @@ impl<'a> TheTrait<&'a isize> for IntStruct {\n }\n \n struct UintStruct {\n-    x: isize\n+    x: isize,\n }\n \n impl<'a> TheTrait<&'a isize> for UintStruct {\n@@ -30,8 +30,7 @@ impl<'a> TheTrait<&'a isize> for UintStruct {\n     }\n }\n \n-struct Tuple {\n-}\n+struct Tuple {}\n \n impl<'a> TheTrait<(&'a isize, &'a isize)> for Tuple {\n     type A = &'a isize;\n@@ -42,37 +41,43 @@ impl<'a> TheTrait<(&'a isize, &'a isize)> for Tuple {\n }\n \n fn foo<T>()\n-    where T : for<'x> TheTrait<&'x isize, A = &'x isize>\n+where\n+    T: for<'x> TheTrait<&'x isize, A = &'x isize>,\n {\n     // ok for IntStruct, but not UintStruct\n }\n \n fn bar<T>()\n-    where T : for<'x> TheTrait<&'x isize, A = &'x usize>\n+where\n+    T: for<'x> TheTrait<&'x isize, A = &'x usize>,\n {\n     // ok for UintStruct, but not IntStruct\n }\n \n fn tuple_one<T>()\n-    where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'x isize>\n+where\n+    T: for<'x, 'y> TheTrait<(&'x isize, &'y isize), A = &'x isize>,\n {\n     // not ok for tuple, two lifetimes and we pick first\n }\n \n fn tuple_two<T>()\n-    where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'y isize>\n+where\n+    T: for<'x, 'y> TheTrait<(&'x isize, &'y isize), A = &'y isize>,\n {\n     // not ok for tuple, two lifetimes and we pick second\n }\n \n fn tuple_three<T>()\n-    where T : for<'x> TheTrait<(&'x isize, &'x isize), A = &'x isize>\n+where\n+    T: for<'x> TheTrait<(&'x isize, &'x isize), A = &'x isize>,\n {\n     // ok for tuple\n }\n \n fn tuple_four<T>()\n-    where T : for<'x,'y> TheTrait<(&'x isize, &'y isize)>\n+where\n+    T: for<'x, 'y> TheTrait<(&'x isize, &'y isize)>,\n {\n     // not ok for tuple, two lifetimes, and lifetime matching is invariant\n }\n@@ -89,14 +94,14 @@ pub fn call_bar() {\n \n pub fn call_tuple_one() {\n     tuple_one::<Tuple>();\n-    //~^ ERROR not satisfied\n-    //~| ERROR type mismatch\n+    //~^ ERROR implementation of `TheTrait` is not general enough\n+    //~| ERROR implementation of `TheTrait` is not general enough\n }\n \n pub fn call_tuple_two() {\n     tuple_two::<Tuple>();\n-    //~^ ERROR not satisfied\n-    //~| ERROR type mismatch\n+    //~^ ERROR implementation of `TheTrait` is not general enough\n+    //~| ERROR implementation of `TheTrait` is not general enough\n }\n \n pub fn call_tuple_three() {\n@@ -105,7 +110,7 @@ pub fn call_tuple_three() {\n \n pub fn call_tuple_four() {\n     tuple_four::<Tuple>();\n-    //~^ ERROR not satisfied\n+    //~^ ERROR implementation of `TheTrait` is not general enough\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "127ab8673556d5bf1554ae11d92027176b84fff6", "filename": "src/test/ui/associated-types/associated-types-eq-hr.stderr", "status": "modified", "additions": 71, "deletions": 54, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,10 +1,11 @@\n error[E0271]: type mismatch resolving `for<'x> <UintStruct as TheTrait<&'x isize>>::A == &'x isize`\n-  --> $DIR/associated-types-eq-hr.rs:82:5\n+  --> $DIR/associated-types-eq-hr.rs:87:5\n    |\n LL | fn foo<T>()\n    |    --- required by a bound in this\n-LL |     where T : for<'x> TheTrait<&'x isize, A = &'x isize>\n-   |                                           ------------- required by this bound in `foo`\n+LL | where\n+LL |     T: for<'x> TheTrait<&'x isize, A = &'x isize>,\n+   |                                    ------------- required by this bound in `foo`\n ...\n LL |     foo::<UintStruct>();\n    |     ^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n@@ -13,84 +14,100 @@ LL |     foo::<UintStruct>();\n               found reference `&usize`\n \n error[E0271]: type mismatch resolving `for<'x> <IntStruct as TheTrait<&'x isize>>::A == &'x usize`\n-  --> $DIR/associated-types-eq-hr.rs:86:5\n+  --> $DIR/associated-types-eq-hr.rs:91:5\n    |\n LL | fn bar<T>()\n    |    --- required by a bound in this\n-LL |     where T : for<'x> TheTrait<&'x isize, A = &'x usize>\n-   |                                           ------------- required by this bound in `bar`\n+LL | where\n+LL |     T: for<'x> TheTrait<&'x isize, A = &'x usize>,\n+   |                                    ------------- required by this bound in `bar`\n ...\n LL |     bar::<IntStruct>();\n    |     ^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n    |\n    = note: expected reference `&usize`\n               found reference `&isize`\n \n-error[E0277]: the trait bound `for<'x, 'y> Tuple: TheTrait<(&'x isize, &'y isize)>` is not satisfied\n-  --> $DIR/associated-types-eq-hr.rs:91:17\n+error: implementation of `TheTrait` is not general enough\n+  --> $DIR/associated-types-eq-hr.rs:96:5\n    |\n-LL | fn tuple_one<T>()\n-   |    --------- required by a bound in this\n-LL |     where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'x isize>\n-   |               ---------------------------------------------------------- required by this bound in `tuple_one`\n+LL | / pub trait TheTrait<T> {\n+LL | |     type A;\n+LL | |\n+LL | |     fn get(&self, t: T) -> Self::A;\n+LL | | }\n+   | |_- trait `TheTrait` defined here\n ...\n-LL |     tuple_one::<Tuple>();\n-   |                 ^^^^^ the trait `for<'x, 'y> TheTrait<(&'x isize, &'y isize)>` is not implemented for `Tuple`\n+LL |       tuple_one::<Tuple>();\n+   |       ^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n    |\n-   = help: the following implementations were found:\n-             <Tuple as TheTrait<(&'a isize, &'a isize)>>\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but `Tuple` actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n-error[E0271]: type mismatch resolving `for<'x, 'y> <Tuple as TheTrait<(&'x isize, &'y isize)>>::A == &'x isize`\n-  --> $DIR/associated-types-eq-hr.rs:91:5\n+error: implementation of `TheTrait` is not general enough\n+  --> $DIR/associated-types-eq-hr.rs:96:5\n    |\n-LL | fn tuple_one<T>()\n-   |    --------- required by a bound in this\n-LL |     where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'x isize>\n-   |                                                           ------------- required by this bound in `tuple_one`\n+LL | / pub trait TheTrait<T> {\n+LL | |     type A;\n+LL | |\n+LL | |     fn get(&self, t: T) -> Self::A;\n+LL | | }\n+   | |_- trait `TheTrait` defined here\n ...\n-LL |     tuple_one::<Tuple>();\n-   |     ^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'x, found concrete lifetime\n+LL |       tuple_one::<Tuple>();\n+   |       ^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n+   |\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but `Tuple` actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n-error[E0277]: the trait bound `for<'x, 'y> Tuple: TheTrait<(&'x isize, &'y isize)>` is not satisfied\n-  --> $DIR/associated-types-eq-hr.rs:97:17\n+error: implementation of `TheTrait` is not general enough\n+  --> $DIR/associated-types-eq-hr.rs:102:5\n    |\n-LL | fn tuple_two<T>()\n-   |    --------- required by a bound in this\n-LL |     where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'y isize>\n-   |               ---------------------------------------------------------- required by this bound in `tuple_two`\n+LL | / pub trait TheTrait<T> {\n+LL | |     type A;\n+LL | |\n+LL | |     fn get(&self, t: T) -> Self::A;\n+LL | | }\n+   | |_- trait `TheTrait` defined here\n ...\n-LL |     tuple_two::<Tuple>();\n-   |                 ^^^^^ the trait `for<'x, 'y> TheTrait<(&'x isize, &'y isize)>` is not implemented for `Tuple`\n+LL |       tuple_two::<Tuple>();\n+   |       ^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n    |\n-   = help: the following implementations were found:\n-             <Tuple as TheTrait<(&'a isize, &'a isize)>>\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but `Tuple` actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n-error[E0271]: type mismatch resolving `for<'x, 'y> <Tuple as TheTrait<(&'x isize, &'y isize)>>::A == &'y isize`\n-  --> $DIR/associated-types-eq-hr.rs:97:5\n+error: implementation of `TheTrait` is not general enough\n+  --> $DIR/associated-types-eq-hr.rs:102:5\n    |\n-LL | fn tuple_two<T>()\n-   |    --------- required by a bound in this\n-LL |     where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'y isize>\n-   |                                                           ------------- required by this bound in `tuple_two`\n+LL | / pub trait TheTrait<T> {\n+LL | |     type A;\n+LL | |\n+LL | |     fn get(&self, t: T) -> Self::A;\n+LL | | }\n+   | |_- trait `TheTrait` defined here\n ...\n-LL |     tuple_two::<Tuple>();\n-   |     ^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'x, found concrete lifetime\n+LL |       tuple_two::<Tuple>();\n+   |       ^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n+   |\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but `Tuple` actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n-error[E0277]: the trait bound `for<'x, 'y> Tuple: TheTrait<(&'x isize, &'y isize)>` is not satisfied\n-  --> $DIR/associated-types-eq-hr.rs:107:18\n+error: implementation of `TheTrait` is not general enough\n+  --> $DIR/associated-types-eq-hr.rs:112:5\n    |\n-LL | fn tuple_four<T>()\n-   |    ---------- required by a bound in this\n-LL |     where T : for<'x,'y> TheTrait<(&'x isize, &'y isize)>\n-   |               ------------------------------------------- required by this bound in `tuple_four`\n+LL | / pub trait TheTrait<T> {\n+LL | |     type A;\n+LL | |\n+LL | |     fn get(&self, t: T) -> Self::A;\n+LL | | }\n+   | |_- trait `TheTrait` defined here\n ...\n-LL |     tuple_four::<Tuple>();\n-   |                  ^^^^^ the trait `for<'x, 'y> TheTrait<(&'x isize, &'y isize)>` is not implemented for `Tuple`\n+LL |       tuple_four::<Tuple>();\n+   |       ^^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n    |\n-   = help: the following implementations were found:\n-             <Tuple as TheTrait<(&'a isize, &'a isize)>>\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but `Tuple` actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n error: aborting due to 7 previous errors\n \n-Some errors have detailed explanations: E0271, E0277.\n-For more information about an error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "4fc336122fa9dd5c2530cc2bdadc1f4c7efc5963", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.krisskross.nll.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.krisskross.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.krisskross.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.krisskross.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,26 +1,26 @@\n error: lifetime may not live long enough\n-  --> $DIR/project-fn-ret-invariant.rs:55:4\n+  --> $DIR/project-fn-ret-invariant.rs:56:5\n    |\n-LL | fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-   |              -- -- lifetime `'b` defined here\n+LL | fn transmute<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+   |              --  -- lifetime `'b` defined here\n    |              |\n    |              lifetime `'a` defined here\n ...\n-LL |    (a, b)\n-   |    ^^^^^^ function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n+LL |     (a, b)\n+   |     ^^^^^^ function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n \n error: lifetime may not live long enough\n-  --> $DIR/project-fn-ret-invariant.rs:55:4\n+  --> $DIR/project-fn-ret-invariant.rs:56:5\n    |\n-LL | fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-   |              -- -- lifetime `'b` defined here\n+LL | fn transmute<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+   |              --  -- lifetime `'b` defined here\n    |              |\n    |              lifetime `'a` defined here\n ...\n-LL |    (a, b)\n-   |    ^^^^^^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'b`\n+LL |     (a, b)\n+   |     ^^^^^^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'b`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n "}, {"sha": "9462121bdf203d44c984ba4b13158a9a3869ca9c", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.krisskross.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.krisskross.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.krisskross.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.krisskross.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,23 +1,23 @@\n error[E0623]: lifetime mismatch\n-  --> $DIR/project-fn-ret-invariant.rs:53:21\n+  --> $DIR/project-fn-ret-invariant.rs:54:22\n    |\n-LL | fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-   |                                     --------     --------------------\n-   |                                     |\n-   |                                     this parameter and the return type are declared with different lifetimes...\n-LL |    let a = bar(foo, y);\n-   |                     ^ ...but data from `x` is returned here\n+LL | fn transmute<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+   |                                      --------     --------------------\n+   |                                      |\n+   |                                      this parameter and the return type are declared with different lifetimes...\n+LL |     let a = bar(foo, y);\n+   |                      ^ ...but data from `x` is returned here\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/project-fn-ret-invariant.rs:54:21\n+  --> $DIR/project-fn-ret-invariant.rs:56:9\n    |\n-LL | fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-   |                        --------                  --------------------\n-   |                        |\n-   |                        this parameter and the return type are declared with different lifetimes...\n-LL |    let a = bar(foo, y);\n-LL |    let b = bar(foo, x);\n-   |                     ^ ...but data from `y` is returned here\n+LL | fn transmute<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+   |                                      --------     --------------------\n+   |                                      |\n+   |                                      this parameter and the return type are declared with different lifetimes...\n+...\n+LL |     (a, b)\n+   |         ^ ...but data from `x` is returned here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2156ecb17393f2e96bb850086d7ea8552665cb66", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.ok.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.ok.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,8 +1,8 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/project-fn-ret-invariant.rs:59:1\n+  --> $DIR/project-fn-ret-invariant.rs:60:1\n    |\n-LL | fn main() { }\n-   | ^^^^^^^^^^^^^\n+LL | fn main() {}\n+   | ^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "44850df7b2f42ce9e0d8c0d011f032a915648453", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.oneuse.nll.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.oneuse.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.oneuse.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.oneuse.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,26 +1,26 @@\n error: lifetime may not live long enough\n-  --> $DIR/project-fn-ret-invariant.rs:38:12\n+  --> $DIR/project-fn-ret-invariant.rs:39:13\n    |\n-LL | fn baz<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-   |        -- -- lifetime `'b` defined here\n+LL | fn baz<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+   |        --  -- lifetime `'b` defined here\n    |        |\n    |        lifetime `'a` defined here\n-LL |    let f = foo; // <-- No consistent type can be inferred for `f` here.\n-LL |    let a = bar(f, x);\n-   |            ^^^^^^^^^ argument requires that `'a` must outlive `'b`\n+LL |     let f = foo; // <-- No consistent type can be inferred for `f` here.\n+LL |     let a = bar(f, x);\n+   |             ^^^^^^^^^ argument requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n \n error: lifetime may not live long enough\n-  --> $DIR/project-fn-ret-invariant.rs:39:12\n+  --> $DIR/project-fn-ret-invariant.rs:40:13\n    |\n-LL | fn baz<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-   |        -- -- lifetime `'b` defined here\n+LL | fn baz<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+   |        --  -- lifetime `'b` defined here\n    |        |\n    |        lifetime `'a` defined here\n ...\n-LL |    let b = bar(f, y);\n-   |            ^^^^^^^^^ argument requires that `'b` must outlive `'a`\n+LL |     let b = bar(f, y);\n+   |             ^^^^^^^^^ argument requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n "}, {"sha": "64b5722390858600908dc9444c69a6953c0d3af2", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.oneuse.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.oneuse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.oneuse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.oneuse.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,13 +1,13 @@\n error[E0623]: lifetime mismatch\n-  --> $DIR/project-fn-ret-invariant.rs:39:19\n+  --> $DIR/project-fn-ret-invariant.rs:40:20\n    |\n-LL | fn baz<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-   |                               --------     --------------------\n-   |                               |\n-   |                               this parameter and the return type are declared with different lifetimes...\n+LL | fn baz<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+   |                                --------     --------------------\n+   |                                |\n+   |                                this parameter and the return type are declared with different lifetimes...\n ...\n-LL |    let b = bar(f, y);\n-   |                   ^ ...but data from `x` is returned here\n+LL |     let b = bar(f, y);\n+   |                    ^ ...but data from `x` is returned here\n \n error: aborting due to previous error\n "}, {"sha": "0034d796826de662b16e8aec226e8e3bfcaf8ada", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,60 +1,61 @@\n #![feature(unboxed_closures)]\n #![feature(rustc_attrs)]\n-\n // Test for projection cache. We should be able to project distinct\n // lifetimes from `foo` as we reinstantiate it multiple times, but not\n // if we do it just once. In this variant, the region `'a` is used in\n // an invariant position, which affects the results.\n \n // revisions: ok oneuse transmute krisskross\n-\n #![allow(dead_code, unused_variables)]\n \n use std::marker::PhantomData;\n \n struct Type<'a> {\n     // Invariant\n-    data: PhantomData<fn(&'a u32) -> &'a u32>\n+    data: PhantomData<fn(&'a u32) -> &'a u32>,\n }\n \n-fn foo<'a>() -> Type<'a> { loop { } }\n+fn foo<'a>() -> Type<'a> {\n+    loop {}\n+}\n \n fn bar<T>(t: T, x: T::Output) -> T::Output\n-    where T: FnOnce<()>\n+where\n+    T: FnOnce<()>,\n {\n     t()\n }\n \n #[cfg(ok)] // two instantiations: OK\n-fn baz<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+fn baz<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n     let a = bar(foo, x);\n     let b = bar(foo, y);\n     (a, b)\n }\n \n #[cfg(oneuse)] // one instantiation: BAD\n-fn baz<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-   let f = foo; // <-- No consistent type can be inferred for `f` here.\n-   let a = bar(f, x);\n-   let b = bar(f, y); //[oneuse]~ ERROR lifetime mismatch [E0623]\n-   (a, b)\n+fn baz<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+    let f = foo; // <-- No consistent type can be inferred for `f` here.\n+    let a = bar(f, x);\n+    let b = bar(f, y); //[oneuse]~ ERROR lifetime mismatch [E0623]\n+    (a, b)\n }\n \n #[cfg(transmute)] // one instantiations: BAD\n-fn baz<'a,'b>(x: Type<'a>) -> Type<'static> {\n-   // Cannot instantiate `foo` with any lifetime other than `'a`,\n-   // since it is provided as input.\n+fn baz<'a, 'b>(x: Type<'a>) -> Type<'static> {\n+    // Cannot instantiate `foo` with any lifetime other than `'a`,\n+    // since it is provided as input.\n \n-   bar(foo, x) //[transmute]~ ERROR E0495\n+    bar(foo, x) //[transmute]~ ERROR E0495\n }\n \n #[cfg(krisskross)] // two instantiations, mixing and matching: BAD\n-fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-   let a = bar(foo, y); //[krisskross]~ ERROR E0623\n-   let b = bar(foo, x); //[krisskross]~ ERROR E0623\n-   (a, b)\n+fn transmute<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+    let a = bar(foo, y); //[krisskross]~ ERROR E0623\n+    let b = bar(foo, x);\n+    (a, b) //[krisskross]~ ERROR E0623\n }\n \n #[rustc_error]\n-fn main() { }\n+fn main() {}\n //[ok]~^ ERROR fatal error triggered by #[rustc_error]"}, {"sha": "db82c9fd43794e359691bcbbf81b7a99aec684f5", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.transmute.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,11 +1,11 @@\n error: lifetime may not live long enough\n-  --> $DIR/project-fn-ret-invariant.rs:48:4\n+  --> $DIR/project-fn-ret-invariant.rs:49:5\n    |\n-LL | fn baz<'a,'b>(x: Type<'a>) -> Type<'static> {\n+LL | fn baz<'a, 'b>(x: Type<'a>) -> Type<'static> {\n    |        -- lifetime `'a` defined here\n ...\n-LL |    bar(foo, x)\n-   |    ^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n+LL |     bar(foo, x)\n+   |     ^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n    |\n    = help: consider replacing `'a` with `'static`\n "}, {"sha": "ef57f9e0bc480049ba6ed9bfab821693693f1e1f", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.transmute.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,27 +1,27 @@\n-error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n-  --> $DIR/project-fn-ret-invariant.rs:48:4\n+error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+  --> $DIR/project-fn-ret-invariant.rs:49:9\n    |\n-LL |    bar(foo, x)\n-   |    ^^^^^^^^^^^\n+LL |     bar(foo, x)\n+   |         ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 44:8...\n-  --> $DIR/project-fn-ret-invariant.rs:44:8\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 45:8...\n+  --> $DIR/project-fn-ret-invariant.rs:45:8\n    |\n-LL | fn baz<'a,'b>(x: Type<'a>) -> Type<'static> {\n+LL | fn baz<'a, 'b>(x: Type<'a>) -> Type<'static> {\n    |        ^^\n note: ...so that the expression is assignable\n-  --> $DIR/project-fn-ret-invariant.rs:48:13\n+  --> $DIR/project-fn-ret-invariant.rs:49:14\n    |\n-LL |    bar(foo, x)\n-   |             ^\n+LL |     bar(foo, x)\n+   |              ^\n    = note: expected `Type<'_>`\n               found `Type<'a>`\n    = note: but, the lifetime must be valid for the static lifetime...\n note: ...so that the expression is assignable\n-  --> $DIR/project-fn-ret-invariant.rs:48:4\n+  --> $DIR/project-fn-ret-invariant.rs:49:5\n    |\n-LL |    bar(foo, x)\n-   |    ^^^^^^^^^^^\n+LL |     bar(foo, x)\n+   |     ^^^^^^^^^^^\n    = note: expected `Type<'static>`\n               found `Type<'_>`\n "}, {"sha": "2e03986a9ed8fa675263993f17ea82cd8c803fae", "filename": "src/test/ui/associated-types/higher-ranked-projection.bad.nll.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/higher-ranked-projection.rs:25:5\n+   |\n+LL |     foo(());\n+   |     ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "811c9a8f5e12ba776e6ba237251155550f306c66", "filename": "src/test/ui/associated-types/higher-ranked-projection.bad.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,14 +1,12 @@\n-error[E0271]: type mismatch resolving `for<'a> <&'a _ as Mirror>::Image == _`\n+error[E0308]: mismatched types\n   --> $DIR/higher-ranked-projection.rs:25:5\n    |\n-LL | fn foo<U, T>(_t: T)\n-   |    --- required by a bound in this\n-LL |     where for<'a> &'a T: Mirror<Image=U>\n-   |                                 ------- required by this bound in `foo`\n-...\n LL |     foo(());\n-   |     ^^^ expected bound lifetime parameter 'a, found concrete lifetime\n+   |     ^^^ one type is more general than the other\n+   |\n+   = note: expected type `&'a ()`\n+              found type `&()`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "1b5476d4c364ffcefc7612718741509047cdb59b", "filename": "src/test/ui/associated-types/higher-ranked-projection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -23,5 +23,5 @@ fn foo<U, T>(_t: T)\n #[rustc_error]\n fn main() { //[good]~ ERROR fatal error triggered by #[rustc_error]\n     foo(());\n-    //[bad]~^ ERROR type mismatch\n+    //[bad]~^ ERROR mismatched types\n }"}, {"sha": "b00affdca850ae1d0c7b83b392cfe4a75da94c96", "filename": "src/test/ui/check-static-values-constraints.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -5,7 +5,9 @@ LL |                                           ..SafeStruct{field1: SafeEnum::Va\n    |  ___________________________________________^\n LL | |\n LL | |                                                      field2: SafeEnum::Variant1}};\n-   | |________________________________________________________________________________^ statics cannot evaluate destructors\n+   | |                                                                                ^- value is dropped here\n+   | |________________________________________________________________________________|\n+   |                                                                                  statics cannot evaluate destructors\n \n error[E0010]: allocations are not allowed in statics\n   --> $DIR/check-static-values-constraints.rs:79:33"}, {"sha": "64a0b52a1fac5c9090717ce98a7f53268e30cf94", "filename": "src/test/ui/closure-expected-type/expect-fn-supply-fn.nll.stderr", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,42 +1,43 @@\n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/expect-fn-supply-fn.rs:30:5\n+error: lifetime may not live long enough\n+  --> $DIR/expect-fn-supply-fn.rs:16:49\n    |\n-LL | fn with_closure_expecting_fn_with_free_region<F>(_: F)\n-   |    ------------------------------------------ required by a bound in this\n-LL |     where F: for<'a> FnOnce(fn(&'a u32), &i32)\n-   |                      ------------------------- required by this bound in `with_closure_expecting_fn_with_free_region`\n+LL | fn expect_free_supply_free_from_fn<'x>(x: &'x u32) {\n+   |                                    -- lifetime `'x` defined here\n ...\n-LL |     with_closure_expecting_fn_with_free_region(|x: fn(&u32), y| {});\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ---------------- found signature of `fn(for<'r> fn(&'r u32), _) -> _`\n-   |     |\n-   |     expected signature of `fn(fn(&'a u32), &i32) -> _`\n+LL |     with_closure_expecting_fn_with_free_region(|x: fn(&'x u32), y| {});\n+   |                                                 ^\n+   |                                                 |\n+   |                                                 has type `fn(&'1 u32)`\n+   |                                                 requires that `'1` must outlive `'x`\n \n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/expect-fn-supply-fn.rs:37:5\n+error: lifetime may not live long enough\n+  --> $DIR/expect-fn-supply-fn.rs:16:49\n    |\n-LL | fn with_closure_expecting_fn_with_bound_region<F>(_: F)\n-   |    ------------------------------------------- required by a bound in this\n-LL |     where F: FnOnce(fn(&u32), &i32)\n-   |              ---------------------- required by this bound in `with_closure_expecting_fn_with_bound_region`\n+LL | fn expect_free_supply_free_from_fn<'x>(x: &'x u32) {\n+   |                                    -- lifetime `'x` defined here\n ...\n+LL |     with_closure_expecting_fn_with_free_region(|x: fn(&'x u32), y| {});\n+   |                                                 ^ requires that `'x` must outlive `'static`\n+   |\n+   = help: consider replacing `'x` with `'static`\n+\n+error: higher-ranked subtype error\n+  --> $DIR/expect-fn-supply-fn.rs:32:49\n+   |\n+LL |     with_closure_expecting_fn_with_free_region(|x: fn(&u32), y| {});\n+   |                                                 ^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/expect-fn-supply-fn.rs:39:50\n+   |\n LL |     with_closure_expecting_fn_with_bound_region(|x: fn(&'x u32), y| {});\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ------------------- found signature of `fn(fn(&'x u32), _) -> _`\n-   |     |\n-   |     expected signature of `fn(for<'r> fn(&'r u32), &i32) -> _`\n+   |                                                  ^\n \n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/expect-fn-supply-fn.rs:46:5\n+error: higher-ranked subtype error\n+  --> $DIR/expect-fn-supply-fn.rs:48:50\n    |\n-LL | fn with_closure_expecting_fn_with_bound_region<F>(_: F)\n-   |    ------------------------------------------- required by a bound in this\n-LL |     where F: FnOnce(fn(&u32), &i32)\n-   |              ---------------------- required by this bound in `with_closure_expecting_fn_with_bound_region`\n-...\n LL |     with_closure_expecting_fn_with_bound_region(|x: Foo<'_>, y| {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ --------------- found signature of `for<'r> fn(fn(&'r u32), _) -> _`\n-   |     |\n-   |     expected signature of `fn(for<'r> fn(&'r u32), &i32) -> _`\n+   |                                                  ^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0631`."}, {"sha": "c81c40c18b45b2f4f8ac9322a50a55536de567a8", "filename": "src/test/ui/closure-expected-type/expect-fn-supply-fn.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,10 +1,12 @@\n fn with_closure_expecting_fn_with_free_region<F>(_: F)\n-    where F: for<'a> FnOnce(fn(&'a u32), &i32)\n+where\n+    F: for<'a> FnOnce(fn(&'a u32), &i32),\n {\n }\n \n fn with_closure_expecting_fn_with_bound_region<F>(_: F)\n-    where F: FnOnce(fn(&u32), &i32)\n+where\n+    F: FnOnce(fn(&u32), &i32),\n {\n }\n \n@@ -28,14 +30,14 @@ fn expect_free_supply_bound() {\n     // Here, we are given a function whose region is bound at closure level,\n     // but we expect one bound in the argument. Error results.\n     with_closure_expecting_fn_with_free_region(|x: fn(&u32), y| {});\n-    //~^ ERROR type mismatch\n+    //~^ ERROR mismatched types\n }\n \n fn expect_bound_supply_free_from_fn<'x>(x: &'x u32) {\n     // Here, we are given a `fn(&u32)` but we expect a `fn(&'x\n     // u32)`. In principle, this could be ok, but we demand equality.\n     with_closure_expecting_fn_with_bound_region(|x: fn(&'x u32), y| {});\n-    //~^ ERROR type mismatch\n+    //~^ ERROR mismatched types\n }\n \n fn expect_bound_supply_free_from_closure() {\n@@ -44,16 +46,15 @@ fn expect_bound_supply_free_from_closure() {\n     // the argument level.\n     type Foo<'a> = fn(&'a u32);\n     with_closure_expecting_fn_with_bound_region(|x: Foo<'_>, y| {\n-    //~^ ERROR type mismatch\n+        //~^ ERROR mismatched types\n     });\n }\n \n fn expect_bound_supply_bound<'x>(x: &'x u32) {\n     // No error in this case. The supplied type supplies the bound\n     // regions, and hence we are able to figure out the type of `y`\n     // from the expected type\n-    with_closure_expecting_fn_with_bound_region(|x: for<'z> fn(&'z u32), y| {\n-    });\n+    with_closure_expecting_fn_with_bound_region(|x: for<'z> fn(&'z u32), y| {});\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "0de15dfa7357d349a99dcc340cc9db6c8548e1e4", "filename": "src/test/ui/closure-expected-type/expect-fn-supply-fn.stderr", "status": "modified", "additions": 29, "deletions": 42, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,81 +1,68 @@\n error[E0308]: mismatched types\n-  --> $DIR/expect-fn-supply-fn.rs:14:52\n+  --> $DIR/expect-fn-supply-fn.rs:16:52\n    |\n LL |     with_closure_expecting_fn_with_free_region(|x: fn(&'x u32), y| {});\n    |                                                    ^^^^^^^^^^^ lifetime mismatch\n    |\n    = note: expected fn pointer `fn(&u32)`\n               found fn pointer `fn(&'x u32)`\n-note: the anonymous lifetime #2 defined on the body at 14:48...\n-  --> $DIR/expect-fn-supply-fn.rs:14:48\n+note: the anonymous lifetime #2 defined on the body at 16:48...\n+  --> $DIR/expect-fn-supply-fn.rs:16:48\n    |\n LL |     with_closure_expecting_fn_with_free_region(|x: fn(&'x u32), y| {});\n    |                                                ^^^^^^^^^^^^^^^^^^^^^^\n-note: ...does not necessarily outlive the lifetime `'x` as defined on the function body at 11:36\n-  --> $DIR/expect-fn-supply-fn.rs:11:36\n+note: ...does not necessarily outlive the lifetime `'x` as defined on the function body at 13:36\n+  --> $DIR/expect-fn-supply-fn.rs:13:36\n    |\n LL | fn expect_free_supply_free_from_fn<'x>(x: &'x u32) {\n    |                                    ^^\n \n error[E0308]: mismatched types\n-  --> $DIR/expect-fn-supply-fn.rs:14:52\n+  --> $DIR/expect-fn-supply-fn.rs:16:52\n    |\n LL |     with_closure_expecting_fn_with_free_region(|x: fn(&'x u32), y| {});\n    |                                                    ^^^^^^^^^^^ lifetime mismatch\n    |\n    = note: expected fn pointer `fn(&u32)`\n               found fn pointer `fn(&'x u32)`\n-note: the lifetime `'x` as defined on the function body at 11:36...\n-  --> $DIR/expect-fn-supply-fn.rs:11:36\n+note: the lifetime `'x` as defined on the function body at 13:36...\n+  --> $DIR/expect-fn-supply-fn.rs:13:36\n    |\n LL | fn expect_free_supply_free_from_fn<'x>(x: &'x u32) {\n    |                                    ^^\n-note: ...does not necessarily outlive the anonymous lifetime #2 defined on the body at 14:48\n-  --> $DIR/expect-fn-supply-fn.rs:14:48\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the body at 16:48\n+  --> $DIR/expect-fn-supply-fn.rs:16:48\n    |\n LL |     with_closure_expecting_fn_with_free_region(|x: fn(&'x u32), y| {});\n    |                                                ^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/expect-fn-supply-fn.rs:30:5\n+error[E0308]: mismatched types\n+  --> $DIR/expect-fn-supply-fn.rs:32:52\n    |\n-LL | fn with_closure_expecting_fn_with_free_region<F>(_: F)\n-   |    ------------------------------------------ required by a bound in this\n-LL |     where F: for<'a> FnOnce(fn(&'a u32), &i32)\n-   |                      ------------------------- required by this bound in `with_closure_expecting_fn_with_free_region`\n-...\n LL |     with_closure_expecting_fn_with_free_region(|x: fn(&u32), y| {});\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ---------------- found signature of `fn(for<'r> fn(&'r u32), _) -> _`\n-   |     |\n-   |     expected signature of `fn(fn(&'a u32), &i32) -> _`\n+   |                                                    ^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `fn(&u32)`\n+              found fn pointer `for<'r> fn(&'r u32)`\n \n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/expect-fn-supply-fn.rs:37:5\n+error[E0308]: mismatched types\n+  --> $DIR/expect-fn-supply-fn.rs:39:53\n    |\n-LL | fn with_closure_expecting_fn_with_bound_region<F>(_: F)\n-   |    ------------------------------------------- required by a bound in this\n-LL |     where F: FnOnce(fn(&u32), &i32)\n-   |              ---------------------- required by this bound in `with_closure_expecting_fn_with_bound_region`\n-...\n LL |     with_closure_expecting_fn_with_bound_region(|x: fn(&'x u32), y| {});\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ------------------- found signature of `fn(fn(&'x u32), _) -> _`\n-   |     |\n-   |     expected signature of `fn(for<'r> fn(&'r u32), &i32) -> _`\n+   |                                                     ^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r> fn(&'r u32)`\n+              found fn pointer `fn(&'x u32)`\n \n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/expect-fn-supply-fn.rs:46:5\n+error[E0308]: mismatched types\n+  --> $DIR/expect-fn-supply-fn.rs:48:53\n    |\n-LL | fn with_closure_expecting_fn_with_bound_region<F>(_: F)\n-   |    ------------------------------------------- required by a bound in this\n-LL |     where F: FnOnce(fn(&u32), &i32)\n-   |              ---------------------- required by this bound in `with_closure_expecting_fn_with_bound_region`\n-...\n LL |     with_closure_expecting_fn_with_bound_region(|x: Foo<'_>, y| {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ --------------- found signature of `for<'r> fn(fn(&'r u32), _) -> _`\n-   |     |\n-   |     expected signature of `fn(for<'r> fn(&'r u32), &i32) -> _`\n+   |                                                     ^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'r> fn(&'r u32)`\n+              found fn pointer `fn(&u32)`\n \n error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0308, E0631.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "af1e37ba867dee0327622dc1aec9f4c891e7d462", "filename": "src/test/ui/closures/issue-41366.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -7,7 +7,6 @@ impl<'g> T<'g> for u32 {\n }\n \n fn main() {\n-    (&|_|()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n+    (&|_| ()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n     //~^ ERROR: type mismatch in closure arguments\n-    //~| ERROR: type mismatch resolving\n }"}, {"sha": "9c4b7d529ef4dff52555b5edd6b045cda1ae6f00", "filename": "src/test/ui/closures/issue-41366.stderr", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,23 +1,14 @@\n error[E0631]: type mismatch in closure arguments\n   --> $DIR/issue-41366.rs:10:5\n    |\n-LL |     (&|_|()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n-   |     ^^-----^\n+LL |     (&|_| ()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n+   |     ^^------^\n    |     | |\n-   |     | found signature of `fn(_) -> _`\n-   |     expected signature of `for<'x> fn(<u32 as T<'x>>::V) -> _`\n+   |     | found signature of `fn(u16) -> _`\n+   |     expected signature of `fn(<u32 as T<'x>>::V) -> _`\n    |\n    = note: required for the cast to the object type `dyn for<'x> std::ops::Fn(<u32 as T<'x>>::V)`\n \n-error[E0271]: type mismatch resolving `for<'x> <[closure@$DIR/issue-41366.rs:10:7: 10:12] as std::ops::FnOnce<(<u32 as T<'x>>::V,)>>::Output == ()`\n-  --> $DIR/issue-41366.rs:10:5\n-   |\n-LL |     (&|_|()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n-   |     ^^^^^^^^ expected bound lifetime parameter 'x, found concrete lifetime\n-   |\n-   = note: required for the cast to the object type `dyn for<'x> std::ops::Fn(<u32 as T<'x>>::V)`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0271, E0631.\n-For more information about an error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0631`."}, {"sha": "99f805f7f0f6320db244f8ee133087b9fa5c8dba", "filename": "src/test/ui/coherence/coherence-fn-covariant-bound-vs-static.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-covariant-bound-vs-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-covariant-bound-vs-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-covariant-bound-vs-static.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,26 @@\n+// Test that impls for these two types are considered ovelapping:\n+//\n+// * `for<'r> fn(fn(&'r u32))`\n+// * `fn(fn(&'a u32)` where `'a` is free\n+//\n+// This is because, for `'a = 'static`, the two types overlap.\n+// Effectively for them to be equal to you get:\n+//\n+// * `for<'r> fn(fn(&'r u32)) <: fn(fn(&'static u32))`\n+//   * true if `exists<'r> { 'r: 'static }` (obviously true)\n+// * `fn(fn(&'static u32)) <: for<'r> fn(fn(&'r u32))`\n+//   * true if `forall<'r> { 'static: 'r }` (also true)\n+\n+trait Trait {}\n+\n+impl Trait for for<'r> fn(fn(&'r ())) {}\n+impl<'a> Trait for fn(fn(&'a ())) {}\n+//~^ ERROR conflicting implementations\n+//\n+// Note in particular that we do NOT get a future-compatibility warning\n+// here. This is because the new leak-check proposed in [MCP 295] does not\n+// \"error\" when these two types are equated.\n+//\n+// [MCP 295]: https://github.com/rust-lang/compiler-team/issues/295\n+\n+fn main() {}"}, {"sha": "49271edf8e5e4bd42cd24663d613716ee55e1a73", "filename": "src/test/ui/coherence/coherence-fn-covariant-bound-vs-static.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-covariant-bound-vs-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-covariant-bound-vs-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-covariant-bound-vs-static.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,13 @@\n+error[E0119]: conflicting implementations of trait `Trait` for type `for<'r> fn(fn(&'r ()))`:\n+  --> $DIR/coherence-fn-covariant-bound-vs-static.rs:17:1\n+   |\n+LL | impl Trait for for<'r> fn(fn(&'r ())) {}\n+   | ------------------------------------- first implementation here\n+LL | impl<'a> Trait for fn(fn(&'a ())) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for<'r> fn(fn(&'r ()))`\n+   |\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "4539af9a32e387a70048b4849c57cc7156272b4d", "filename": "src/test/ui/coherence/coherence-fn-implied-bounds.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-implied-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-implied-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-implied-bounds.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,26 @@\n+// Test that our leak-check is not smart enough to take implied bounds\n+// into account (yet). Here we have two types that look like they\n+// should not be equivalent, but because of the rules on implied\n+// bounds we ought to know that, in fact, `'a = 'b` must always hold,\n+// and hence they are.\n+//\n+// Rustc can't figure this out and hence it accepts the impls but\n+// gives a future-compatibility warning (because we'd like to make\n+// this an error someday).\n+//\n+// Note that while we would like to make this a hard error, we also\n+// give the same warning for `coherence-wasm-bindgen.rs`, which ought\n+// to be accepted.\n+\n+#![deny(coherence_leak_check)]\n+\n+trait Trait {}\n+\n+impl Trait for for<'a, 'b> fn(&'a &'b u32, &'b &'a u32) -> &'b u32 {}\n+\n+impl Trait for for<'c> fn(&'c &'c u32, &'c &'c u32) -> &'c u32 {\n+    //~^ ERROR conflicting implementations\n+    //~| WARNING this was previously accepted by the compiler\n+}\n+\n+fn main() {}"}, {"sha": "a3e7f0bcde376f7af6153cd8b2e0e84d27f0dd7d", "filename": "src/test/ui/coherence/coherence-fn-implied-bounds.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-implied-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-implied-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-implied-bounds.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,20 @@\n+error: conflicting implementations of trait `Trait` for type `for<'a, 'b> fn(&'a &'b u32, &'b &'a u32) -> &'b u32`:\n+  --> $DIR/coherence-fn-implied-bounds.rs:21:1\n+   |\n+LL | impl Trait for for<'a, 'b> fn(&'a &'b u32, &'b &'a u32) -> &'b u32 {}\n+   | ------------------------------------------------------------------ first implementation here\n+LL | \n+LL | impl Trait for for<'c> fn(&'c &'c u32, &'c &'c u32) -> &'c u32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for<'a, 'b> fn(&'a &'b u32, &'b &'a u32) -> &'b u32`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/coherence-fn-implied-bounds.rs:15:9\n+   |\n+LL | #![deny(coherence_leak_check)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56105 <https://github.com/rust-lang/rust/issues/56105>\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+\n+error: aborting due to previous error\n+"}, {"sha": "3afec5c5459afeebe5ead6a4e26e098b80840deb", "filename": "src/test/ui/coherence/coherence-fn-inputs.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-inputs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-inputs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-inputs.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,25 @@\n+// Test that we consider these two types completely equal:\n+//\n+// * `for<'a, 'b> fn(&'a u32, &'b u32)`\n+// * `for<'c> fn(&'c u32, &'c u32)`\n+//\n+// For a long time we considered these to be distinct types. But in fact they\n+// are equivalent, if you work through the implications of subtyping -- this is\n+// because:\n+//\n+// * `'c` can be the intersection of `'a` and `'b` (and there is always an intersection)\n+// * `'a` and `'b` can both be equal to `'c`\n+\n+trait Trait {}\n+impl Trait for for<'a, 'b> fn(&'a u32, &'b u32) {}\n+impl Trait for for<'c> fn(&'c u32, &'c u32) {\n+    //~^ ERROR conflicting implementations\n+    //\n+    // Note in particular that we do NOT get a future-compatibility warning\n+    // here. This is because the new leak-check proposed in [MCP 295] does not\n+    // \"error\" when these two types are equated.\n+    //\n+    // [MCP 295]: https://github.com/rust-lang/compiler-team/issues/295\n+}\n+\n+fn main() {}"}, {"sha": "56ab873a393201ff2434056271b4662a8da6682a", "filename": "src/test/ui/coherence/coherence-fn-inputs.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-inputs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-inputs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-fn-inputs.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,13 @@\n+error[E0119]: conflicting implementations of trait `Trait` for type `for<'a, 'b> fn(&'a u32, &'b u32)`:\n+  --> $DIR/coherence-fn-inputs.rs:15:1\n+   |\n+LL | impl Trait for for<'a, 'b> fn(&'a u32, &'b u32) {}\n+   | ----------------------------------------------- first implementation here\n+LL | impl Trait for for<'c> fn(&'c u32, &'c u32) {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for<'a, 'b> fn(&'a u32, &'b u32)`\n+   |\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "2f5c49d293d5d579ac1c3a6c71699ce5ff24ce5b", "filename": "src/test/ui/coherence/coherence-free-vs-bound-region.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-free-vs-bound-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-free-vs-bound-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-free-vs-bound-region.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,21 @@\n+// Capture a coherence pattern from wasm-bindgen that we discovered as part of\n+// future-compatibility warning #56105. This pattern currently receives a lint\n+// warning but we probably want to support it long term.\n+//\n+// Key distinction: we are implementing once for `A` (take ownership) and one\n+// for `&A` (borrow).\n+//\n+// c.f. #56105\n+\n+#![deny(coherence_leak_check)]\n+\n+trait TheTrait {}\n+\n+impl<'a> TheTrait for fn(&'a u8) {}\n+\n+impl TheTrait for fn(&u8) {\n+    //~^ ERROR conflicting implementations of trait\n+    //~| WARNING this was previously accepted by the compiler\n+}\n+\n+fn main() {}"}, {"sha": "97aa4912721434631a773a8226973c7100179aa6", "filename": "src/test/ui/coherence/coherence-free-vs-bound-region.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-free-vs-bound-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-free-vs-bound-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-free-vs-bound-region.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,20 @@\n+error: conflicting implementations of trait `TheTrait` for type `fn(&u8)`:\n+  --> $DIR/coherence-free-vs-bound-region.rs:16:1\n+   |\n+LL | impl<'a> TheTrait for fn(&'a u8) {}\n+   | -------------------------------- first implementation here\n+LL | \n+LL | impl TheTrait for fn(&u8) {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `fn(&u8)`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/coherence-free-vs-bound-region.rs:10:9\n+   |\n+LL | #![deny(coherence_leak_check)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56105 <https://github.com/rust-lang/rust/issues/56105>\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+\n+error: aborting due to previous error\n+"}, {"sha": "ee09a72449be13fd06c71d037af955dba2dbcb48", "filename": "src/test/ui/coherence/coherence-wasm-bindgen.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-wasm-bindgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-wasm-bindgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-wasm-bindgen.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,37 @@\n+// Capture a coherence pattern from wasm-bindgen that we discovered as part of\n+// future-compatibility warning #56105. This pattern currently receives a lint\n+// warning but we probably want to support it long term.\n+//\n+// Key distinction: we are implementing once for `A` (take ownership) and one\n+// for `&A` (borrow).\n+//\n+// c.f. #56105\n+\n+#![deny(coherence_leak_check)]\n+\n+trait IntoWasmAbi {\n+    fn some_method(&self) {}\n+}\n+\n+trait FromWasmAbi {}\n+trait RefFromWasmAbi {}\n+trait ReturnWasmAbi {}\n+\n+impl<'a, 'b, A, R> IntoWasmAbi for &'a (dyn Fn(A) -> R + 'b)\n+where\n+    A: FromWasmAbi,\n+    R: ReturnWasmAbi,\n+{\n+}\n+\n+// Explicitly writing the bound lifetime.\n+impl<'a, 'b, A, R> IntoWasmAbi for &'a (dyn for<'x> Fn(&'x A) -> R + 'b)\n+where\n+    A: RefFromWasmAbi,\n+    R: ReturnWasmAbi,\n+{\n+    //~^^^^^ ERROR conflicting implementation\n+    //~| WARNING this was previously accepted\n+}\n+\n+fn main() {}"}, {"sha": "c77483bb847f5b5df4b395da95ad5574e172a2d7", "filename": "src/test/ui/coherence/coherence-wasm-bindgen.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-wasm-bindgen.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-wasm-bindgen.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-wasm-bindgen.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,32 @@\n+error: conflicting implementations of trait `IntoWasmAbi` for type `&dyn std::ops::Fn(&_) -> _`:\n+  --> $DIR/coherence-wasm-bindgen.rs:28:1\n+   |\n+LL | / impl<'a, 'b, A, R> IntoWasmAbi for &'a (dyn Fn(A) -> R + 'b)\n+LL | | where\n+LL | |     A: FromWasmAbi,\n+LL | |     R: ReturnWasmAbi,\n+LL | | {\n+LL | | }\n+   | |_- first implementation here\n+...\n+LL | / impl<'a, 'b, A, R> IntoWasmAbi for &'a (dyn for<'x> Fn(&'x A) -> R + 'b)\n+LL | | where\n+LL | |     A: RefFromWasmAbi,\n+LL | |     R: ReturnWasmAbi,\n+...  |\n+LL | |\n+LL | | }\n+   | |_^ conflicting implementation for `&dyn std::ops::Fn(&_) -> _`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/coherence-wasm-bindgen.rs:10:9\n+   |\n+LL | #![deny(coherence_leak_check)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56105 <https://github.com/rust-lang/rust/issues/56105>\n+   = note: downstream crates may implement trait `FromWasmAbi` for type `&_`\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+\n+error: aborting due to previous error\n+"}, {"sha": "4a6241de1b453658e2e5768ef6043b062f7f496e", "filename": "src/test/ui/const-generics/const-arg-type-arg-misordered.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-type-arg-misordered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-type-arg-misordered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-type-arg-misordered.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -14,6 +14,7 @@ LL | fn foo<const N: usize>() -> Array<N, ()> {\n    |                                   ^\n    |\n    = note: type arguments must be provided before constant arguments\n+   = help: reorder the arguments: types, then consts: `<T, N>`\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "90c438b05cb816459e5e4a1b9190e11559ea0a1c", "filename": "src/test/ui/const-generics/fn-const-param-call.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,15 +1,14 @@\n-// run-pass\n-\n-#![feature(const_generics, const_compare_raw_pointers)]\n+#![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete\n \n fn function() -> u32 {\n     17\n }\n \n-struct Wrapper<const F: fn() -> u32>;\n+struct Wrapper<const F: fn() -> u32>; //~ ERROR: using function pointers as const generic parameters\n \n impl<const F: fn() -> u32> Wrapper<F> {\n+//~^ ERROR: using function pointers as const generic parameters\n     fn call() -> u32 {\n         F()\n     }"}, {"sha": "b5811243caa8a31b1b3bd97804b832c0ef9c4326", "filename": "src/test/ui/const-generics/fn-const-param-call.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,11 +1,23 @@\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/fn-const-param-call.rs:3:12\n+  --> $DIR/fn-const-param-call.rs:1:12\n    |\n-LL | #![feature(const_generics, const_compare_raw_pointers)]\n+LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n \n-warning: 1 warning emitted\n+error: using function pointers as const generic parameters is forbidden\n+  --> $DIR/fn-const-param-call.rs:8:25\n+   |\n+LL | struct Wrapper<const F: fn() -> u32>;\n+   |                         ^^^^^^^^^^^\n+\n+error: using function pointers as const generic parameters is forbidden\n+  --> $DIR/fn-const-param-call.rs:10:15\n+   |\n+LL | impl<const F: fn() -> u32> Wrapper<F> {\n+   |               ^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n "}, {"sha": "14fa3b494b3fcef1dade36b2d5f66352b3d65945", "filename": "src/test/ui/const-generics/fn-const-param-infer.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,7 +1,8 @@\n-#![feature(const_generics, const_compare_raw_pointers)]\n+#![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete\n \n struct Checked<const F: fn(usize) -> bool>;\n+//~^ ERROR: using function pointers as const generic parameters\n \n fn not_one(val: usize) -> bool { val != 1 }\n fn not_two(val: usize) -> bool { val != 2 }\n@@ -13,14 +14,14 @@ fn generic<T>(val: usize) -> bool { val != 1 }\n fn main() {\n     let _: Option<Checked<not_one>> = None;\n     let _: Checked<not_one> = Checked::<not_one>;\n-    let _: Checked<not_one> = Checked::<not_two>; //~ mismatched types\n+    let _: Checked<not_one> = Checked::<not_two>;\n \n     let _ = Checked::<generic_arg>;\n     let _ = Checked::<{generic_arg::<usize>}>;\n-    let _ = Checked::<{generic_arg::<u32>}>;  //~ mismatched types\n+    let _ = Checked::<{generic_arg::<u32>}>;\n \n-    let _ = Checked::<generic>; //~ type annotations needed\n+    let _ = Checked::<generic>;\n     let _ = Checked::<{generic::<u16>}>;\n     let _: Checked<{generic::<u16>}> = Checked::<{generic::<u16>}>;\n-    let _: Checked<{generic::<u32>}> = Checked::<{generic::<u16>}>; //~ mismatched types\n+    let _: Checked<{generic::<u32>}> = Checked::<{generic::<u16>}>;\n }"}, {"sha": "7aaa41eb7d7b157f462a9af0a4f450b8cd1c7d47", "filename": "src/test/ui/const-generics/fn-const-param-infer.stderr", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,46 +1,17 @@\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n   --> $DIR/fn-const-param-infer.rs:1:12\n    |\n-LL | #![feature(const_generics, const_compare_raw_pointers)]\n+LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n \n-error[E0308]: mismatched types\n-  --> $DIR/fn-const-param-infer.rs:16:31\n+error: using function pointers as const generic parameters is forbidden\n+  --> $DIR/fn-const-param-infer.rs:4:25\n    |\n-LL |     let _: Checked<not_one> = Checked::<not_two>;\n-   |                               ^^^^^^^^^^^^^^^^^^ expected `{not_one as fn(usize) -> bool}`, found `{not_two as fn(usize) -> bool}`\n-   |\n-   = note: expected type `{not_one as fn(usize) -> bool}`\n-              found type `{not_two as fn(usize) -> bool}`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/fn-const-param-infer.rs:20:24\n-   |\n-LL |     let _ = Checked::<{generic_arg::<u32>}>;\n-   |                        ^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n-   |\n-   = note: expected fn pointer `fn(usize) -> _`\n-                 found fn item `fn(u32) -> _ {generic_arg::<u32>}`\n-\n-error[E0282]: type annotations needed\n-  --> $DIR/fn-const-param-infer.rs:22:23\n-   |\n-LL |     let _ = Checked::<generic>;\n-   |                       ^^^^^^^ cannot infer type for type parameter `T` declared on the function `generic`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/fn-const-param-infer.rs:25:40\n-   |\n-LL |     let _: Checked<{generic::<u32>}> = Checked::<{generic::<u16>}>;\n-   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{generic::<u32> as fn(usize) -> bool}`, found `{generic::<u16> as fn(usize) -> bool}`\n-   |\n-   = note: expected type `{generic::<u32> as fn(usize) -> bool}`\n-              found type `{generic::<u16> as fn(usize) -> bool}`\n+LL | struct Checked<const F: fn(usize) -> bool>;\n+   |                         ^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors; 1 warning emitted\n+error: aborting due to previous error; 1 warning emitted\n \n-Some errors have detailed explanations: E0282, E0308.\n-For more information about an error, try `rustc --explain E0282`."}, {"sha": "97ca9d6a44c9e8f38d0527697ad0d3b0a63ea97d", "filename": "src/test/ui/const-generics/raw-ptr-const-param-deref.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,12 +1,11 @@\n-// run-pass\n-#![feature(const_generics, const_compare_raw_pointers)]\n+#![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete\n \n const A: u32 = 3;\n \n-struct Const<const P: *const u32>;\n+struct Const<const P: *const u32>; //~ ERROR: using raw pointers as const generic parameters\n \n-impl<const P: *const u32> Const<P> {\n+impl<const P: *const u32> Const<P> { //~ ERROR: using raw pointers as const generic parameters\n     fn get() -> u32 {\n         unsafe {\n             *P"}, {"sha": "1ce8bb9c05423a1a421c0da34280e3b032e638a9", "filename": "src/test/ui/const-generics/raw-ptr-const-param-deref.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,11 +1,23 @@\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/raw-ptr-const-param-deref.rs:2:12\n+  --> $DIR/raw-ptr-const-param-deref.rs:1:12\n    |\n-LL | #![feature(const_generics, const_compare_raw_pointers)]\n+LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n \n-warning: 1 warning emitted\n+error: using raw pointers as const generic parameters is forbidden\n+  --> $DIR/raw-ptr-const-param-deref.rs:6:23\n+   |\n+LL | struct Const<const P: *const u32>;\n+   |                       ^^^^^^^^^^\n+\n+error: using raw pointers as const generic parameters is forbidden\n+  --> $DIR/raw-ptr-const-param-deref.rs:8:15\n+   |\n+LL | impl<const P: *const u32> Const<P> {\n+   |               ^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n "}, {"sha": "237b410e073d6f886b617bfc40f30434b16c7cd7", "filename": "src/test/ui/const-generics/raw-ptr-const-param.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,9 +1,9 @@\n-#![feature(const_generics, const_compare_raw_pointers)]\n+#![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete\n \n-struct Const<const P: *const u32>;\n+struct Const<const P: *const u32>; //~ ERROR: using raw pointers as const generic parameters\n \n fn main() {\n-    let _: Const<{ 15 as *const _ }> = Const::<{ 10 as *const _ }>; //~ mismatched types\n+    let _: Const<{ 15 as *const _ }> = Const::<{ 10 as *const _ }>;\n     let _: Const<{ 10 as *const _ }> = Const::<{ 10 as *const _ }>;\n }"}, {"sha": "6e64f8a327fd508241b479fe5f4859eb0a12f1b8", "filename": "src/test/ui/const-generics/raw-ptr-const-param.stderr", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,21 +1,17 @@\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n   --> $DIR/raw-ptr-const-param.rs:1:12\n    |\n-LL | #![feature(const_generics, const_compare_raw_pointers)]\n+LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n \n-error[E0308]: mismatched types\n-  --> $DIR/raw-ptr-const-param.rs:7:40\n+error: using raw pointers as const generic parameters is forbidden\n+  --> $DIR/raw-ptr-const-param.rs:4:23\n    |\n-LL |     let _: Const<{ 15 as *const _ }> = Const::<{ 10 as *const _ }>;\n-   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{0xf as *const u32}`, found `{0xa as *const u32}`\n-   |\n-   = note: expected type `{0xf as *const u32}`\n-              found type `{0xa as *const u32}`\n+LL | struct Const<const P: *const u32>;\n+   |                       ^^^^^^^^^^\n \n error: aborting due to previous error; 1 warning emitted\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "47f39b703e46095b28e8de9672dbc117a829c144", "filename": "src/test/ui/consts/const-eval/const_let.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_let.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -2,25 +2,33 @@ error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/const_let.rs:16:32\n    |\n LL | const Y: FakeNeedsDrop = { let mut x = FakeNeedsDrop; x = FakeNeedsDrop; x };\n-   |                                ^^^^^ constants cannot evaluate destructors\n+   |                                ^^^^^                  - value is dropped here\n+   |                                |\n+   |                                constants cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/const_let.rs:20:33\n    |\n LL | const Y2: FakeNeedsDrop = { let mut x; x = FakeNeedsDrop; x = FakeNeedsDrop; x };\n-   |                                 ^^^^^ constants cannot evaluate destructors\n+   |                                 ^^^^^                     - value is dropped here\n+   |                                 |\n+   |                                 constants cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/const_let.rs:24:21\n    |\n LL | const Z: () = { let mut x = None; x = Some(FakeNeedsDrop); };\n-   |                     ^^^^^ constants cannot evaluate destructors\n+   |                     ^^^^^                                  - value is dropped here\n+   |                     |\n+   |                     constants cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/const_let.rs:28:22\n    |\n LL | const Z2: () = { let mut x; x = None; x = Some(FakeNeedsDrop); };\n-   |                      ^^^^^ constants cannot evaluate destructors\n+   |                      ^^^^^                                     - value is dropped here\n+   |                      |\n+   |                      constants cannot evaluate destructors\n \n error: aborting due to 4 previous errors\n "}, {"sha": "e238e13b8e2da46fff8542ce21a634f011144655", "filename": "src/test/ui/consts/const-eval/const_raw_ptr_ops.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,17 +1,6 @@\n-#![feature(const_raw_ptr_to_usize_cast, const_compare_raw_pointers, const_raw_ptr_deref)]\n-\n fn main() {}\n \n // unconst and bad, will thus error in miri\n-const X: bool = unsafe { &1 as *const i32 == &2 as *const i32 }; //~ ERROR any use of this\n-// unconst and bad, will thus error in miri\n-const X2: bool = unsafe { 42 as *const i32 == 43 as *const i32 }; //~ ERROR any use of this\n-// unconst and fine\n-const Y: usize = unsafe { 42usize as *const i32 as usize + 1 };\n-// unconst and bad, will thus error in miri\n-const Y2: usize = unsafe { &1 as *const i32 as usize + 1 }; //~ ERROR any use of this\n-// unconst and fine\n-const Z: i32 = unsafe { *(&1 as *const i32) };\n+const X: bool = unsafe { &1 as *const i32 == &2 as *const i32 }; //~ ERROR cannot be reliably\n // unconst and bad, will thus error in miri\n-const Z2: i32 = unsafe { *(42 as *const i32) }; //~ ERROR any use of this value will cause\n-const Z3: i32 = unsafe { *(44 as *const i32) }; //~ ERROR any use of this value will cause\n+const X2: bool = unsafe { 42 as *const i32 == 43 as *const i32 }; //~ ERROR cannot be reliably"}, {"sha": "21d3f5e7e853651c48fdb33b532c68d8e6543288", "filename": "src/test/ui/consts/const-eval/const_raw_ptr_ops.stderr", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,44 +1,18 @@\n-error: any use of this value will cause an error\n-  --> $DIR/const_raw_ptr_ops.rs:6:26\n+error: pointers cannot be reliably compared during const eval.\n+  --> $DIR/const_raw_ptr_ops.rs:4:26\n    |\n LL | const X: bool = unsafe { &1 as *const i32 == &2 as *const i32 };\n-   | -------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n-   |                          |\n-   |                          \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `#[deny(const_err)]` on by default\n+   = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n \n-error: any use of this value will cause an error\n-  --> $DIR/const_raw_ptr_ops.rs:8:27\n+error: pointers cannot be reliably compared during const eval.\n+  --> $DIR/const_raw_ptr_ops.rs:6:27\n    |\n LL | const X2: bool = unsafe { 42 as *const i32 == 43 as *const i32 };\n-   | --------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n-   |                           |\n-   |                           \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n-\n-error: any use of this value will cause an error\n-  --> $DIR/const_raw_ptr_ops.rs:12:28\n-   |\n-LL | const Y2: usize = unsafe { &1 as *const i32 as usize + 1 };\n-   | ---------------------------^^^^^^^^^^^^^^^^^^^^^^^^^-------\n-   |                            |\n-   |                            \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n-\n-error: any use of this value will cause an error\n-  --> $DIR/const_raw_ptr_ops.rs:16:26\n-   |\n-LL | const Z2: i32 = unsafe { *(42 as *const i32) };\n-   | -------------------------^^^^^^^^^^^^^^^^^^^---\n-   |                          |\n-   |                          unable to turn bytes into a pointer\n-\n-error: any use of this value will cause an error\n-  --> $DIR/const_raw_ptr_ops.rs:17:26\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-LL | const Z3: i32 = unsafe { *(44 as *const i32) };\n-   | -------------------------^^^^^^^^^^^^^^^^^^^---\n-   |                          |\n-   |                          unable to turn bytes into a pointer\n+   = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "d2a7623837a23ee612a17f4e491f4cc3db8d0e9d", "filename": "src/test/ui/consts/const-eval/const_raw_ptr_ops2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops2.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,13 @@\n+#![feature(const_raw_ptr_to_usize_cast, const_raw_ptr_deref)]\n+\n+fn main() {}\n+\n+// unconst and fine\n+const Y: usize = unsafe { 42usize as *const i32 as usize + 1 };\n+// unconst and bad, will thus error in miri\n+const Y2: usize = unsafe { &1 as *const i32 as usize + 1 }; //~ ERROR any use of this\n+// unconst and fine\n+const Z: i32 = unsafe { *(&1 as *const i32) };\n+// unconst and bad, will thus error in miri\n+const Z2: i32 = unsafe { *(42 as *const i32) }; //~ ERROR any use of this value will cause\n+const Z3: i32 = unsafe { *(44 as *const i32) }; //~ ERROR any use of this value will cause"}, {"sha": "93f2261745d6f2fca2431861eb4e65c509b2626a", "filename": "src/test/ui/consts/const-eval/const_raw_ptr_ops2.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops2.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,28 @@\n+error: any use of this value will cause an error\n+  --> $DIR/const_raw_ptr_ops2.rs:8:28\n+   |\n+LL | const Y2: usize = unsafe { &1 as *const i32 as usize + 1 };\n+   | ---------------------------^^^^^^^^^^^^^^^^^^^^^^^^^-------\n+   |                            |\n+   |                            \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const_raw_ptr_ops2.rs:12:26\n+   |\n+LL | const Z2: i32 = unsafe { *(42 as *const i32) };\n+   | -------------------------^^^^^^^^^^^^^^^^^^^---\n+   |                          |\n+   |                          unable to turn bytes into a pointer\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const_raw_ptr_ops2.rs:13:26\n+   |\n+LL | const Z3: i32 = unsafe { *(44 as *const i32) };\n+   | -------------------------^^^^^^^^^^^^^^^^^^^---\n+   |                          |\n+   |                          unable to turn bytes into a pointer\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "771d368d7839104de25363732e5248515a75ab38", "filename": "src/test/ui/consts/const-eval/issue-65394.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -9,6 +9,9 @@ error[E0493]: destructors cannot be evaluated at compile-time\n    |\n LL |     let mut x = Vec::<i32>::new();\n    |         ^^^^^ constants cannot evaluate destructors\n+...\n+LL | };\n+   | - value is dropped here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f00d1c70659fd909a3aa790eb6a43af61314f770", "filename": "src/test/ui/consts/const-eval/livedrop.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Flivedrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Flivedrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Flivedrop.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,20 @@\n+#![feature(const_if_match)]\n+#![feature(const_loop)]\n+\n+const _: Option<Vec<i32>> = {\n+    let mut never_returned = Some(Vec::new());\n+    let mut always_returned = None; //~ ERROR destructors cannot be evaluated at compile-time\n+\n+    let mut i = 0;\n+    loop {\n+        always_returned = never_returned;\n+        never_returned = None;\n+\n+        i += 1;\n+        if i == 10 {\n+            break always_returned;\n+        }\n+    }\n+};\n+\n+fn main() {}"}, {"sha": "b802d23d9a89c742bb246b545bb4a15e638830ac", "filename": "src/test/ui/consts/const-eval/livedrop.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Flivedrop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Flivedrop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Flivedrop.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,12 @@\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/livedrop.rs:6:9\n+   |\n+LL |     let mut always_returned = None;\n+   |         ^^^^^^^^^^^^^^^^^^^ constants cannot evaluate destructors\n+...\n+LL |         always_returned = never_returned;\n+   |         --------------- value is dropped here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0493`."}, {"sha": "d724fe3060b21b748998189dd2e68a9c14f30d75", "filename": "src/test/ui/consts/const-eval/promoted_raw_ptr_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_raw_ptr_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_raw_ptr_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_raw_ptr_ops.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,4 +1,4 @@\n-#![feature(const_raw_ptr_to_usize_cast, const_compare_raw_pointers, const_raw_ptr_deref)]\n+#![feature(const_raw_ptr_to_usize_cast, const_raw_ptr_deref)]\n \n fn main() {\n     let x: &'static bool = &(42 as *const i32 == 43 as *const i32);"}, {"sha": "6a9ea91d20e1fae5a18beff409f0823aadbe207a", "filename": "src/test/ui/consts/control-flow/drop-fail.stock.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.stock.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -3,24 +3,36 @@ error[E0493]: destructors cannot be evaluated at compile-time\n    |\n LL |     let x = Some(Vec::new());\n    |         ^ constants cannot evaluate destructors\n+...\n+LL | };\n+   | - value is dropped here\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/drop-fail.rs:23:9\n    |\n LL |     let vec_tuple = (Vec::new(),);\n    |         ^^^^^^^^^ constants cannot evaluate destructors\n+...\n+LL | };\n+   | - value is dropped here\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/drop-fail.rs:31:9\n    |\n LL |     let x: Result<_, Vec<i32>> = Ok(Vec::new());\n    |         ^ constants cannot evaluate destructors\n+...\n+LL | };\n+   | - value is dropped here\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/drop-fail.rs:41:9\n    |\n LL |     let mut tmp = None;\n    |         ^^^^^^^ constants cannot evaluate destructors\n+...\n+LL | };\n+   | - value is dropped here\n \n error: aborting due to 4 previous errors\n "}, {"sha": "4b0401ebf9dbae572902d75df1d0fad9618127fb", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -2,7 +2,9 @@ error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:37:25\n    |\n LL |     const fn into_inner(self) -> T { self.0 }\n-   |                         ^^^^ constant functions cannot evaluate destructors\n+   |                         ^^^^                - value is dropped here\n+   |                         |\n+   |                         constant functions cannot evaluate destructors\n \n error[E0723]: mutable references in const fn are unstable\n   --> $DIR/min_const_fn.rs:39:36\n@@ -17,7 +19,9 @@ error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:44:28\n    |\n LL |     const fn into_inner_lt(self) -> T { self.0 }\n-   |                            ^^^^ constant functions cannot evaluate destructors\n+   |                            ^^^^                - value is dropped here\n+   |                            |\n+   |                            constant functions cannot evaluate destructors\n \n error[E0723]: mutable references in const fn are unstable\n   --> $DIR/min_const_fn.rs:46:42\n@@ -32,7 +36,9 @@ error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:51:27\n    |\n LL |     const fn into_inner_s(self) -> T { self.0 }\n-   |                           ^^^^ constant functions cannot evaluate destructors\n+   |                           ^^^^                - value is dropped here\n+   |                           |\n+   |                           constant functions cannot evaluate destructors\n \n error[E0723]: mutable references in const fn are unstable\n   --> $DIR/min_const_fn.rs:53:38"}, {"sha": "0b6cb2fab46f1cb06462205c3dabac2bb7688019", "filename": "src/test/ui/consts/miri_unleashed/feature-gate-unleash_the_miri_inside_of_you.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -2,7 +2,9 @@ error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/feature-gate-unleash_the_miri_inside_of_you.rs:11:20\n    |\n LL |     const F: u32 = (U::X, 42).1;\n-   |                    ^^^^^^^^^^ constants cannot evaluate destructors\n+   |                    ^^^^^^^^^^ - value is dropped here\n+   |                    |\n+   |                    constants cannot evaluate destructors\n \n error: aborting due to previous error\n "}, {"sha": "21f11dda5a66729a3339ae446018454657f52417", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -12,7 +12,7 @@ LL |     let _v = x + 0;\n \n warning: skipping const checks\n    |\n-help: skipping check for `const_compare_raw_pointers` feature\n+help: skipping check that does not even have a feature gate\n   --> $DIR/ptr_arith.rs:9:14\n    |\n LL |     let _v = x == x;"}, {"sha": "fd843105daf2a8a3a819a905e49354446536d7ba", "filename": "src/test/ui/consts/miri_unleashed/slice_eq.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fslice_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fslice_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fslice_eq.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+// run-pass\n+\n+#![feature(const_raw_ptr_comparison)]\n+\n+const EMPTY_SLICE: &[i32] = &[];\n+const EMPTY_EQ: bool = EMPTY_SLICE.as_ptr().guaranteed_eq(&[] as *const _);\n+const EMPTY_EQ2: bool = EMPTY_SLICE.as_ptr().guaranteed_ne(&[] as *const _);\n+const EMPTY_NE: bool = EMPTY_SLICE.as_ptr().guaranteed_ne(&[1] as *const _);\n+const EMPTY_NE2: bool = EMPTY_SLICE.as_ptr().guaranteed_eq(&[1] as *const _);\n+\n+fn main() {\n+    assert!(!EMPTY_EQ);\n+    assert!(!EMPTY_EQ2);\n+    assert!(!EMPTY_NE);\n+    assert!(!EMPTY_NE2);\n+}"}, {"sha": "928605356a16e3d94f07d1215c509599b1ece247", "filename": "src/test/ui/consts/unstable-const-fn-in-libcore.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -9,12 +9,18 @@ error[E0493]: destructors cannot be evaluated at compile-time\n    |\n LL |     const fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n    |                                                     ^ constant functions cannot evaluate destructors\n+...\n+LL |     }\n+   |     - value is dropped here\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/unstable-const-fn-in-libcore.rs:19:47\n    |\n LL |     const fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n    |                                               ^^^^ constant functions cannot evaluate destructors\n+...\n+LL |     }\n+   |     - value is dropped here\n \n error: aborting due to 3 previous errors\n "}, {"sha": "d2edd97efb232e6bd2a34d6053ea5a79f5a4672b", "filename": "src/test/ui/error-codes/E0395.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ferror-codes%2FE0395.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ferror-codes%2FE0395.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0395.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,10 +1,8 @@\n-// gate-test-const_compare_raw_pointers\n-\n static FOO: i32 = 42;\n static BAR: i32 = 42;\n \n static BAZ: bool = unsafe { (&FOO as *const i32) == (&BAR as *const i32) };\n-//~^ ERROR comparing raw pointers inside static\n+//~^ ERROR pointers cannot be reliably compared during const eval\n \n fn main() {\n }"}, {"sha": "674cc696450290625d5366140775b41f698da39e", "filename": "src/test/ui/error-codes/E0395.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ferror-codes%2FE0395.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ferror-codes%2FE0395.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0395.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,12 +1,10 @@\n-error[E0658]: comparing raw pointers inside static\n-  --> $DIR/E0395.rs:6:29\n+error: pointers cannot be reliably compared during const eval.\n+  --> $DIR/E0395.rs:4:29\n    |\n LL | static BAZ: bool = unsafe { (&FOO as *const i32) == (&BAR as *const i32) };\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n-   = help: add `#![feature(const_compare_raw_pointers)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "dc602ba7e6f2138d5e3d0321a80dd0eb384d63ba", "filename": "src/test/ui/feature-gates/feature-gate-const_generics-ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,9 +1,9 @@\n struct ConstFn<const F: fn()>;\n //~^ ERROR const generics are unstable\n-//~^^ ERROR using function pointers as const generic parameters is unstable\n+//~^^ ERROR using function pointers as const generic parameters is forbidden\n \n struct ConstPtr<const P: *const u32>;\n //~^ ERROR const generics are unstable\n-//~^^ ERROR using raw pointers as const generic parameters is unstable\n+//~^^ ERROR using raw pointers as const generic parameters is forbidden\n \n fn main() {}"}, {"sha": "b2c96d3810f980fae1e4543247b354ebfc5bc33e", "filename": "src/test/ui/feature-gates/feature-gate-const_generics-ptr.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -16,23 +16,17 @@ LL | struct ConstPtr<const P: *const u32>;\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n    = help: add `#![feature(const_generics)]` to the crate attributes to enable\n \n-error[E0658]: using function pointers as const generic parameters is unstable\n+error: using function pointers as const generic parameters is forbidden\n   --> $DIR/feature-gate-const_generics-ptr.rs:1:25\n    |\n LL | struct ConstFn<const F: fn()>;\n    |                         ^^^^\n-   |\n-   = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n-   = help: add `#![feature(const_compare_raw_pointers)]` to the crate attributes to enable\n \n-error[E0658]: using raw pointers as const generic parameters is unstable\n+error: using raw pointers as const generic parameters is forbidden\n   --> $DIR/feature-gate-const_generics-ptr.rs:5:26\n    |\n LL | struct ConstPtr<const P: *const u32>;\n    |                          ^^^^^^^^^^\n-   |\n-   = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n-   = help: add `#![feature(const_compare_raw_pointers)]` to the crate attributes to enable\n \n error: aborting due to 4 previous errors\n "}, {"sha": "7d7121919240722d5fa5c8fb964f7d5d3c6b4f3b", "filename": "src/test/ui/generator/resume-arg-late-bound.nll.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/resume-arg-late-bound.rs:15:5\n+   |\n+LL |     test(gen);\n+   |     ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "a8f657eaabe47b8ba69ffeaea6f4cb5b70becdcd", "filename": "src/test/ui/generator/resume-arg-late-bound.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -13,5 +13,6 @@ fn main() {\n         *arg = true;\n     };\n     test(gen);\n-    //~^ ERROR type mismatch in function arguments\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n }"}, {"sha": "c379d9eae8ecdc375dba5d70bd3e247eb0b7140a", "filename": "src/test/ui/generator/resume-arg-late-bound.stderr", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,15 +1,21 @@\n-error[E0631]: type mismatch in function arguments\n-  --> $DIR/resume-arg-late-bound.rs:15:10\n+error[E0308]: mismatched types\n+  --> $DIR/resume-arg-late-bound.rs:15:5\n    |\n-LL | fn test(a: impl for<'a> Generator<&'a mut bool>) {}\n-   |                 ------------------------------- required by this bound in `test`\n-...\n LL |     test(gen);\n-   |          ^^^\n-   |          |\n-   |          expected signature of `for<'a> fn(&'a mut bool) -> _`\n-   |          found signature of `fn(&mut bool) -> _`\n+   |     ^^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'a> std::ops::Generator<&'a mut bool>`\n+              found type `std::ops::Generator<&mut bool>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/resume-arg-late-bound.rs:15:5\n+   |\n+LL |     test(gen);\n+   |     ^^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'a> std::ops::Generator<&'a mut bool>`\n+              found type `std::ops::Generator<&mut bool>`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0631`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "d5343566633d56f75ce1b3b60fdb9dee0992395f", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,14 @@\n+error: higher-ranked subtype error\n+  --> $DIR/hr-subtype.rs:45:13\n+   |\n+LL |               gimme::<$t1>(None::<$t2>);\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | / check! { bound_a_b_ret_a_vs_bound_a_ret_a: (for<'a,'b> fn(&'a u32, &'b u32) -> &'a u32,\n+LL | | for<'a>    fn(&'a u32, &'a u32) -> &'a u32) }\n+   | |_____________________________________________- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "92a85825030c27bf80e890c9b4ce3125c777f2bf", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,12 +1,12 @@\n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+  --> $DIR/hr-subtype.rs:45:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n+   |                            ^^^^^^^^^^^ one type is more general than the other\n ...\n LL | / check! { bound_a_b_ret_a_vs_bound_a_ret_a: (for<'a,'b> fn(&'a u32, &'b u32) -> &'a u32,\n-LL | |                                             for<'a>    fn(&'a u32, &'a u32) -> &'a u32) }\n-   | |_________________________________________________________________________________________- in this macro invocation\n+LL | | for<'a>    fn(&'a u32, &'a u32) -> &'a u32) }\n+   | |_____________________________________________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32>`\n               found enum `std::option::Option<for<'a> fn(&'a u32, &'a u32) -> &'a u32>`"}, {"sha": "948375566104becb71af12379dc710934c685e3c", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_b_vs_bound_a.stderr", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_vs_bound_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_vs_bound_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_vs_bound_a.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,17 +1,14 @@\n-error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+error: fatal error triggered by #[rustc_error]\n+  --> $DIR/hr-subtype.rs:102:1\n    |\n-LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n-...\n-LL | / check! { bound_a_b_vs_bound_a: (for<'a,'b> fn(&'a u32, &'b u32),\n-LL | |                                 for<'a>    fn(&'a u32, &'a u32)) }\n-   | |__________________________________________________________________- in this macro invocation\n-   |\n-   = note: expected enum `std::option::Option<for<'a, 'b> fn(&'a u32, &'b u32)>`\n-              found enum `std::option::Option<for<'a> fn(&'a u32, &'a u32)>`\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL | / fn main() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "948375566104becb71af12379dc710934c685e3c", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_bound_a.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_a.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,11 +1,11 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:102:1\n    |\n LL | / fn main() {\n LL | |\n LL | |\n LL | |\n-LL | |\n+...  |\n LL | |\n LL | | }\n    | |_^"}, {"sha": "948375566104becb71af12379dc710934c685e3c", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_bound_b.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_b.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,11 +1,11 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:102:1\n    |\n LL | / fn main() {\n LL | |\n LL | |\n LL | |\n-LL | |\n+...  |\n LL | |\n LL | | }\n    | |_^"}, {"sha": "f11560939675603db95ea999a65a2aa2d2e30476", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_free_x.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,14 @@\n+error: higher-ranked subtype error\n+  --> $DIR/hr-subtype.rs:45:13\n+   |\n+LL |               gimme::<$t1>(None::<$t2>);\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | / check! { bound_a_vs_free_x: (for<'a> fn(&'a u32),\n+LL | | fn(&'x u32)) }\n+   | |______________- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "98f5bff732762e808b1b6f20bd0e82d67ab286cf", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_free_x.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,12 +1,12 @@\n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+  --> $DIR/hr-subtype.rs:45:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n+   |                            ^^^^^^^^^^^ one type is more general than the other\n ...\n LL | / check! { bound_a_vs_free_x: (for<'a> fn(&'a u32),\n-LL | |                              fn(&'x u32)) }\n-   | |___________________________________________- in this macro invocation\n+LL | | fn(&'x u32)) }\n+   | |______________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<for<'a> fn(&'a u32)>`\n               found enum `std::option::Option<fn(&'x u32)>`"}, {"sha": "948375566104becb71af12379dc710934c685e3c", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_co_a_b_vs_bound_co_a.stderr", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_b_vs_bound_co_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_b_vs_bound_co_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_b_vs_bound_co_a.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,17 +1,14 @@\n-error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+error: fatal error triggered by #[rustc_error]\n+  --> $DIR/hr-subtype.rs:102:1\n    |\n-LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n-...\n-LL | / check! { bound_co_a_b_vs_bound_co_a: (for<'a,'b> fn(Co<'a>, Co<'b>),\n-LL | |                                       for<'a>    fn(Co<'a>, Co<'a>)) }\n-   | |______________________________________________________________________- in this macro invocation\n-   |\n-   = note: expected enum `std::option::Option<for<'a, 'b> fn(Co<'a>, Co<'b>)>`\n-              found enum `std::option::Option<for<'a> fn(Co<'a>, Co<'a>)>`\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL | / fn main() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "948375566104becb71af12379dc710934c685e3c", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_co_a_co_b_ret_contra_a.stderr", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_co_b_ret_contra_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_co_b_ret_contra_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_co_b_ret_contra_a.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,17 +1,14 @@\n-error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+error: fatal error triggered by #[rustc_error]\n+  --> $DIR/hr-subtype.rs:102:1\n    |\n-LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n-...\n-LL | / check! { bound_co_a_co_b_ret_contra_a: (for<'a,'b> fn(Co<'a>, Co<'b>) -> Contra<'a>,\n-LL | |                                         for<'a>    fn(Co<'a>, Co<'a>) -> Contra<'a>) }\n-   | |______________________________________________________________________________________- in this macro invocation\n-   |\n-   = note: expected enum `std::option::Option<for<'a, 'b> fn(Co<'a>, Co<'b>) -> Contra<'a>>`\n-              found enum `std::option::Option<for<'a> fn(Co<'a>, Co<'a>) -> Contra<'a>>`\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL | / fn main() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "948375566104becb71af12379dc710934c685e3c", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_co_a_vs_bound_co_b.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_vs_bound_co_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_vs_bound_co_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_vs_bound_co_b.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,11 +1,11 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:102:1\n    |\n LL | / fn main() {\n LL | |\n LL | |\n LL | |\n-LL | |\n+...  |\n LL | |\n LL | | }\n    | |_^"}, {"sha": "948375566104becb71af12379dc710934c685e3c", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_contra_a_contra_b_ret_co_a.stderr", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_contra_a_contra_b_ret_co_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_contra_a_contra_b_ret_co_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_contra_a_contra_b_ret_co_a.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,17 +1,14 @@\n-error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+error: fatal error triggered by #[rustc_error]\n+  --> $DIR/hr-subtype.rs:102:1\n    |\n-LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n-...\n-LL | / check! { bound_contra_a_contra_b_ret_co_a: (for<'a,'b> fn(Contra<'a>, Contra<'b>) -> Co<'a>,\n-LL | |                                             for<'a>    fn(Contra<'a>, Contra<'a>) -> Co<'a>) }\n-   | |______________________________________________________________________________________________- in this macro invocation\n-   |\n-   = note: expected enum `std::option::Option<for<'a, 'b> fn(Contra<'a>, Contra<'b>) -> Co<'a>>`\n-              found enum `std::option::Option<for<'a> fn(Contra<'a>, Contra<'a>) -> Co<'a>>`\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL | / fn main() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "4541c462ee0565c8bebcceb8ecc3bd2d4e2cea95", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_inv_a_b_vs_bound_inv_a.nll.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,26 @@\n+error: higher-ranked subtype error\n+  --> $DIR/hr-subtype.rs:45:13\n+   |\n+LL |               gimme::<$t1>(None::<$t2>);\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | / check! { bound_inv_a_b_vs_bound_inv_a: (for<'a,'b> fn(Inv<'a>, Inv<'b>),\n+LL | | for<'a>    fn(Inv<'a>, Inv<'a>)) }\n+   | |__________________________________- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: higher-ranked subtype error\n+  --> $DIR/hr-subtype.rs:45:13\n+   |\n+LL |               gimme::<$t1>(None::<$t2>);\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | / check! { bound_inv_a_b_vs_bound_inv_a: (for<'a,'b> fn(Inv<'a>, Inv<'b>),\n+LL | | for<'a>    fn(Inv<'a>, Inv<'a>)) }\n+   | |__________________________________- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "100ba6ac27e2530f11ce2d8c3e1e192852b1efef", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,12 +1,12 @@\n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+  --> $DIR/hr-subtype.rs:45:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n+   |                            ^^^^^^^^^^^ one type is more general than the other\n ...\n LL | / check! { bound_inv_a_b_vs_bound_inv_a: (for<'a,'b> fn(Inv<'a>, Inv<'b>),\n-LL | |                                         for<'a>    fn(Inv<'a>, Inv<'a>)) }\n-   | |__________________________________________________________________________- in this macro invocation\n+LL | | for<'a>    fn(Inv<'a>, Inv<'a>)) }\n+   | |__________________________________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<for<'a, 'b> fn(Inv<'a>, Inv<'b>)>`\n               found enum `std::option::Option<for<'a> fn(Inv<'a>, Inv<'a>)>`"}, {"sha": "948375566104becb71af12379dc710934c685e3c", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_inv_a_vs_bound_inv_b.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_vs_bound_inv_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_vs_bound_inv_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_vs_bound_inv_b.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,11 +1,11 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:102:1\n    |\n LL | / fn main() {\n LL | |\n LL | |\n LL | |\n-LL | |\n+...  |\n LL | |\n LL | | }\n    | |_^"}, {"sha": "af5cf41be0a48f279b49f81e9961cd5cbf91785c", "filename": "src/test/ui/hr-subtype/hr-subtype.free_inv_x_vs_free_inv_y.nll.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,33 +1,33 @@\n error: lifetime may not live long enough\n-  --> $DIR/hr-subtype.rs:33:13\n+  --> $DIR/hr-subtype.rs:39:13\n    |\n-LL |           fn subtype<'x,'y:'x,'z:'y>() {\n-   |                      -- -- lifetime `'y` defined here\n+LL |           fn subtype<'x, 'y: 'x, 'z: 'y>() {\n+   |                      --  -- lifetime `'y` defined here\n    |                      |\n    |                      lifetime `'x` defined here\n LL |               gimme::<$t2>(None::<$t1>);\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'x` must outlive `'y`\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n    |\n    = help: consider adding the following bound: `'x: 'y`\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: lifetime may not live long enough\n-  --> $DIR/hr-subtype.rs:39:13\n+  --> $DIR/hr-subtype.rs:45:13\n    |\n-LL |           fn supertype<'x,'y:'x,'z:'y>() {\n-   |                        -- -- lifetime `'y` defined here\n+LL |           fn supertype<'x, 'y: 'x, 'z: 'y>() {\n+   |                        --  -- lifetime `'y` defined here\n    |                        |\n    |                        lifetime `'x` defined here\n LL |               gimme::<$t1>(None::<$t2>);\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'x` must outlive `'y`\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n    |\n    = help: consider adding the following bound: `'x: 'y`\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)"}, {"sha": "3c8af20e50cef383296b4663c454839320917791", "filename": "src/test/ui/hr-subtype/hr-subtype.free_inv_x_vs_free_inv_y.stderr", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,65 +1,65 @@\n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:33:26\n+  --> $DIR/hr-subtype.rs:39:26\n    |\n LL |               gimme::<$t2>(None::<$t1>);\n    |                            ^^^^^^^^^^^ lifetime mismatch\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<fn(Inv<'y>)>`\n               found enum `std::option::Option<fn(Inv<'x>)>`\n-note: the lifetime `'x` as defined on the function body at 32:20...\n-  --> $DIR/hr-subtype.rs:32:20\n+note: the lifetime `'x` as defined on the function body at 38:20...\n+  --> $DIR/hr-subtype.rs:38:20\n    |\n-LL |           fn subtype<'x,'y:'x,'z:'y>() {\n+LL |           fn subtype<'x, 'y: 'x, 'z: 'y>() {\n    |                      ^^\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n-note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 32:23\n-  --> $DIR/hr-subtype.rs:32:23\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n+note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 38:24\n+  --> $DIR/hr-subtype.rs:38:24\n    |\n-LL |           fn subtype<'x,'y:'x,'z:'y>() {\n-   |                         ^^\n+LL |           fn subtype<'x, 'y: 'x, 'z: 'y>() {\n+   |                          ^^\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+  --> $DIR/hr-subtype.rs:45:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n    |                            ^^^^^^^^^^^ lifetime mismatch\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<fn(Inv<'x>)>`\n               found enum `std::option::Option<fn(Inv<'y>)>`\n-note: the lifetime `'x` as defined on the function body at 38:22...\n-  --> $DIR/hr-subtype.rs:38:22\n+note: the lifetime `'x` as defined on the function body at 44:22...\n+  --> $DIR/hr-subtype.rs:44:22\n    |\n-LL |           fn supertype<'x,'y:'x,'z:'y>() {\n+LL |           fn supertype<'x, 'y: 'x, 'z: 'y>() {\n    |                        ^^\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n-note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 38:25\n-  --> $DIR/hr-subtype.rs:38:25\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n+note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 44:26\n+  --> $DIR/hr-subtype.rs:44:26\n    |\n-LL |           fn supertype<'x,'y:'x,'z:'y>() {\n-   |                           ^^\n+LL |           fn supertype<'x, 'y: 'x, 'z: 'y>() {\n+   |                            ^^\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors"}, {"sha": "948375566104becb71af12379dc710934c685e3c", "filename": "src/test/ui/hr-subtype/hr-subtype.free_x_vs_free_x.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_x.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_x.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_x.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,11 +1,11 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:102:1\n    |\n LL | / fn main() {\n LL | |\n LL | |\n LL | |\n-LL | |\n+...  |\n LL | |\n LL | | }\n    | |_^"}, {"sha": "75d7e0e46b72a75d25055944a0af69b368d81a7f", "filename": "src/test/ui/hr-subtype/hr-subtype.free_x_vs_free_y.nll.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,16 +1,16 @@\n error: lifetime may not live long enough\n-  --> $DIR/hr-subtype.rs:39:13\n+  --> $DIR/hr-subtype.rs:45:13\n    |\n-LL |           fn supertype<'x,'y:'x,'z:'y>() {\n-   |                        -- -- lifetime `'y` defined here\n+LL |           fn supertype<'x, 'y: 'x, 'z: 'y>() {\n+   |                        --  -- lifetime `'y` defined here\n    |                        |\n    |                        lifetime `'x` defined here\n LL |               gimme::<$t1>(None::<$t2>);\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'x` must outlive `'y`\n ...\n LL | / check! { free_x_vs_free_y: (fn(&'x u32),\n-LL | |                             fn(&'y u32)) }\n-   | |__________________________________________- in this macro invocation\n+LL | | fn(&'y u32)) }\n+   | |______________- in this macro invocation\n    |\n    = help: consider adding the following bound: `'x: 'y`\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)"}, {"sha": "7b4cdd4a419b4f4856e7f7409f71e5f5766a5af8", "filename": "src/test/ui/hr-subtype/hr-subtype.free_x_vs_free_y.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,33 +1,33 @@\n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+  --> $DIR/hr-subtype.rs:45:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n    |                            ^^^^^^^^^^^ lifetime mismatch\n ...\n LL | / check! { free_x_vs_free_y: (fn(&'x u32),\n-LL | |                             fn(&'y u32)) }\n-   | |__________________________________________- in this macro invocation\n+LL | | fn(&'y u32)) }\n+   | |______________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<fn(&'x u32)>`\n               found enum `std::option::Option<fn(&'y u32)>`\n-note: the lifetime `'x` as defined on the function body at 38:22...\n-  --> $DIR/hr-subtype.rs:38:22\n+note: the lifetime `'x` as defined on the function body at 44:22...\n+  --> $DIR/hr-subtype.rs:44:22\n    |\n-LL |           fn supertype<'x,'y:'x,'z:'y>() {\n+LL |           fn supertype<'x, 'y: 'x, 'z: 'y>() {\n    |                        ^^\n ...\n LL | / check! { free_x_vs_free_y: (fn(&'x u32),\n-LL | |                             fn(&'y u32)) }\n-   | |__________________________________________- in this macro invocation\n-note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 38:25\n-  --> $DIR/hr-subtype.rs:38:25\n+LL | | fn(&'y u32)) }\n+   | |______________- in this macro invocation\n+note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 44:26\n+  --> $DIR/hr-subtype.rs:44:26\n    |\n-LL |           fn supertype<'x,'y:'x,'z:'y>() {\n-   |                           ^^\n+LL |           fn supertype<'x, 'y: 'x, 'z: 'y>() {\n+   |                            ^^\n ...\n LL | / check! { free_x_vs_free_y: (fn(&'x u32),\n-LL | |                             fn(&'y u32)) }\n-   | |__________________________________________- in this macro invocation\n+LL | | fn(&'y u32)) }\n+   | |______________- in this macro invocation\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "ad9500eedca935efa09aa76beb3ba29d6b30897b", "filename": "src/test/ui/hr-subtype/hr-subtype.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -18,60 +18,62 @@\n // revisions: bound_inv_a_b_vs_bound_inv_a\n // revisions: bound_a_b_ret_a_vs_bound_a_ret_a\n \n-fn gimme<T>(_: Option<T>) { }\n+fn gimme<T>(_: Option<T>) {}\n \n-struct Inv<'a> { x: *mut &'a u32 }\n+struct Inv<'a> {\n+    x: *mut &'a u32,\n+}\n \n-struct Co<'a> { x: fn(&'a u32) }\n+struct Co<'a> {\n+    x: fn(&'a u32),\n+}\n \n-struct Contra<'a> { x: &'a u32 }\n+struct Contra<'a> {\n+    x: &'a u32,\n+}\n \n macro_rules! check {\n     ($rev:ident: ($t1:ty, $t2:ty)) => {\n         #[cfg($rev)]\n-        fn subtype<'x,'y:'x,'z:'y>() {\n+        fn subtype<'x, 'y: 'x, 'z: 'y>() {\n             gimme::<$t2>(None::<$t1>);\n             //[free_inv_x_vs_free_inv_y]~^ ERROR\n         }\n \n         #[cfg($rev)]\n-        fn supertype<'x,'y:'x,'z:'y>() {\n+        fn supertype<'x, 'y: 'x, 'z: 'y>() {\n             gimme::<$t1>(None::<$t2>);\n             //[bound_a_vs_free_x]~^ ERROR\n             //[free_x_vs_free_y]~^^ ERROR\n             //[bound_inv_a_b_vs_bound_inv_a]~^^^ ERROR\n             //[bound_a_b_ret_a_vs_bound_a_ret_a]~^^^^ ERROR\n             //[free_inv_x_vs_free_inv_y]~^^^^^ ERROR\n-            //[bound_a_b_vs_bound_a]~^^^^^^ ERROR mismatched types\n-            //[bound_co_a_co_b_ret_contra_a]~^^^^^^^ ERROR\n-            //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^ ERROR\n-            //[bound_co_a_b_vs_bound_co_a]~^^^^^^^^^ ERROR\n         }\n-    }\n+    };\n }\n \n // If both have bound regions, they are equivalent, regardless of\n // variant.\n check! { bound_a_vs_bound_a: (for<'a> fn(&'a u32),\n-                              for<'a> fn(&'a u32)) }\n+for<'a> fn(&'a u32)) }\n check! { bound_a_vs_bound_b: (for<'a> fn(&'a u32),\n-                              for<'b> fn(&'b u32)) }\n+for<'b> fn(&'b u32)) }\n check! { bound_inv_a_vs_bound_inv_b: (for<'a> fn(Inv<'a>),\n-                                      for<'b> fn(Inv<'b>)) }\n+for<'b> fn(Inv<'b>)) }\n check! { bound_co_a_vs_bound_co_b: (for<'a> fn(Co<'a>),\n-                                    for<'b> fn(Co<'b>)) }\n+for<'b> fn(Co<'b>)) }\n \n // Bound is a subtype of free.\n check! { bound_a_vs_free_x: (for<'a> fn(&'a u32),\n-                             fn(&'x u32)) }\n+fn(&'x u32)) }\n \n // Two free regions are relatable if subtyping holds.\n check! { free_x_vs_free_x: (fn(&'x u32),\n-                            fn(&'x u32)) }\n+fn(&'x u32)) }\n check! { free_x_vs_free_y: (fn(&'x u32),\n-                            fn(&'y u32)) }\n+fn(&'y u32)) }\n check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-                                    fn(Inv<'y>)) }\n+fn(Inv<'y>)) }\n \n // Somewhat surprisingly, a fn taking two distinct bound lifetimes and\n // a fn taking one bound lifetime can be interchangeable, but only if\n@@ -82,25 +84,29 @@ check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n //   intersection;\n // - if we are contravariant, then 'a can be inferred to 'static.\n check! { bound_a_b_vs_bound_a: (for<'a,'b> fn(&'a u32, &'b u32),\n-                                for<'a>    fn(&'a u32, &'a u32)) }\n+for<'a>    fn(&'a u32, &'a u32)) }\n check! { bound_co_a_b_vs_bound_co_a: (for<'a,'b> fn(Co<'a>, Co<'b>),\n-                                      for<'a>    fn(Co<'a>, Co<'a>)) }\n+for<'a>    fn(Co<'a>, Co<'a>)) }\n check! { bound_contra_a_contra_b_ret_co_a: (for<'a,'b> fn(Contra<'a>, Contra<'b>) -> Co<'a>,\n-                                            for<'a>    fn(Contra<'a>, Contra<'a>) -> Co<'a>) }\n+for<'a>    fn(Contra<'a>, Contra<'a>) -> Co<'a>) }\n check! { bound_co_a_co_b_ret_contra_a: (for<'a,'b> fn(Co<'a>, Co<'b>) -> Contra<'a>,\n-                                        for<'a>    fn(Co<'a>, Co<'a>) -> Contra<'a>) }\n+for<'a>    fn(Co<'a>, Co<'a>) -> Contra<'a>) }\n \n // If we make those lifetimes invariant, then the two types are not interchangeable.\n check! { bound_inv_a_b_vs_bound_inv_a: (for<'a,'b> fn(Inv<'a>, Inv<'b>),\n-                                        for<'a>    fn(Inv<'a>, Inv<'a>)) }\n+for<'a>    fn(Inv<'a>, Inv<'a>)) }\n check! { bound_a_b_ret_a_vs_bound_a_ret_a: (for<'a,'b> fn(&'a u32, &'b u32) -> &'a u32,\n-                                            for<'a>    fn(&'a u32, &'a u32) -> &'a u32) }\n+for<'a>    fn(&'a u32, &'a u32) -> &'a u32) }\n \n #[rustc_error]\n fn main() {\n-//[bound_a_vs_bound_a]~^ ERROR fatal error triggered by #[rustc_error]\n-//[bound_a_vs_bound_b]~^^ ERROR fatal error triggered by #[rustc_error]\n-//[bound_inv_a_vs_bound_inv_b]~^^^ ERROR fatal error triggered by #[rustc_error]\n-//[bound_co_a_vs_bound_co_b]~^^^^ ERROR fatal error triggered by #[rustc_error]\n-//[free_x_vs_free_x]~^^^^^ ERROR fatal error triggered by #[rustc_error]\n+    //[bound_a_vs_bound_a]~^ ERROR fatal error triggered by #[rustc_error]\n+    //[bound_a_vs_bound_b]~^^ ERROR fatal error triggered by #[rustc_error]\n+    //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR fatal error triggered by #[rustc_error]\n+    //[bound_co_a_vs_bound_co_b]~^^^^ ERROR fatal error triggered by #[rustc_error]\n+    //[free_x_vs_free_x]~^^^^^ ERROR fatal error triggered by #[rustc_error]\n+    //[bound_co_a_b_vs_bound_co_a]~^^^^^^ ERROR\n+    //[bound_co_a_co_b_ret_contra_a]~^^^^^^^ ERROR\n+    //[bound_a_b_vs_bound_a]~^^^^^^^^ ERROR\n+    //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^^ ERROR\n }"}, {"sha": "6455854f34db89cc8a7bd0e112733a2f4bd0e3de", "filename": "src/test/ui/hr-subtype/return-static.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Freturn-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhr-subtype%2Freturn-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Freturn-static.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+fn make<T>() -> T {\n+    panic!()\n+}\n+\n+fn take<T>(x: T) {}\n+\n+fn main() {\n+    let x: for<'a> fn(&'a u32) -> _ = make();\n+    let y: &'static u32 = x(&22);\n+    take::<for<'b> fn(&'b u32) -> &'b u32>(x);\n+}"}, {"sha": "f290a93326f3700c58e009174c85f8744acaa04c", "filename": "src/test/ui/hrtb/hrtb-conflate-regions.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,14 @@\n+error: higher-ranked subtype error\n+  --> $DIR/hrtb-conflate-regions.rs:27:10\n+   |\n+LL | fn b() { want_foo2::<SomeStruct>(); }\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/hrtb-conflate-regions.rs:27:10\n+   |\n+LL | fn b() { want_foo2::<SomeStruct>(); }\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "45573814d13c0945f2577dd3843a8e13da15fb06", "filename": "src/test/ui/hrtb/hrtb-conflate-regions.stderr", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,17 +1,16 @@\n-error[E0277]: the trait bound `for<'a, 'b> SomeStruct: Foo<(&'a isize, &'b isize)>` is not satisfied\n-  --> $DIR/hrtb-conflate-regions.rs:27:22\n+error: implementation of `Foo` is not general enough\n+  --> $DIR/hrtb-conflate-regions.rs:27:10\n    |\n-LL | fn want_foo2<T>()\n-   |    --------- required by a bound in this\n-LL |     where T : for<'a,'b> Foo<(&'a isize, &'b isize)>\n-   |               -------------------------------------- required by this bound in `want_foo2`\n+LL | / trait Foo<X> {\n+LL | |     fn foo(&self, x: X) { }\n+LL | | }\n+   | |_- trait `Foo` defined here\n ...\n-LL | fn b() { want_foo2::<SomeStruct>(); }\n-   |                      ^^^^^^^^^^ the trait `for<'a, 'b> Foo<(&'a isize, &'b isize)>` is not implemented for `SomeStruct`\n+LL |   fn b() { want_foo2::<SomeStruct>(); }\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n-   = help: the following implementations were found:\n-             <SomeStruct as Foo<(&'a isize, &'a isize)>>\n+   = note: `SomeStruct` must implement `Foo<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but `SomeStruct` actually implements `Foo<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "11390d9e2d265d5e867152b60b661e34386f72bd", "filename": "src/test/ui/hrtb/hrtb-exists-forall-fn.nll.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/hrtb-exists-forall-fn.rs:17:12\n+   |\n+LL |     let _: for<'b> fn(&'b u32) = foo();\n+   |            ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "9914783d9767d5d99ecd0790eae8597cc1714265", "filename": "src/test/ui/hrtb/hrtb-exists-forall-fn.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -2,9 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/hrtb-exists-forall-fn.rs:17:34\n    |\n LL |     let _: for<'b> fn(&'b u32) = foo();\n-   |            -------------------   ^^^^^ expected concrete lifetime, found bound lifetime parameter 'b\n-   |            |\n-   |            expected due to this\n+   |                                  ^^^^^ one type is more general than the other\n    |\n    = note: expected fn pointer `for<'b> fn(&'b u32)`\n               found fn pointer `fn(&u32)`"}, {"sha": "a4c3ffd1f6c08aa44f969883285e7ed1d741ca39", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-contravariant.nll.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/hrtb-exists-forall-trait-contravariant.rs:34:5\n+   |\n+LL |     foo::<()>();\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "921061916fc95b7d46c891db83d39cfae29499a5", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-contravariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -32,5 +32,5 @@ fn main() {\n     // NB. *However*, the reinstated leak-check gives an error here.\n \n     foo::<()>();\n-    //~^ ERROR not satisfied\n+    //~^ ERROR implementation of `Trait` is not general enough\n }"}, {"sha": "fe8209d054c8ad641044ddda3eda030241b2ec80", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-contravariant.stderr", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,18 +1,14 @@\n-error[E0277]: the trait bound `(): Trait<for<'b> fn(&'b u32)>` is not satisfied\n-  --> $DIR/hrtb-exists-forall-trait-contravariant.rs:34:11\n+error: implementation of `Trait` is not general enough\n+  --> $DIR/hrtb-exists-forall-trait-contravariant.rs:34:5\n    |\n-LL | fn foo<T>()\n-   |    --- required by a bound in this\n-LL | where\n-LL |     T: Trait<for<'b> fn(&'b u32)>,\n-   |        -------------------------- required by this bound in `foo`\n+LL | trait Trait<T> {}\n+   | ----------------- trait `Trait` defined here\n ...\n LL |     foo::<()>();\n-   |           ^^ the trait `Trait<for<'b> fn(&'b u32)>` is not implemented for `()`\n+   |     ^^^^^^^^^ implementation of `Trait` is not general enough\n    |\n-   = help: the following implementations were found:\n-             <() as Trait<fn(&'a u32)>>\n+   = note: `()` must implement `Trait<for<'b> fn(&'b u32)>`\n+   = note: ...but `()` actually implements `Trait<fn(&'0 u32)>`, for some specific lifetime `'0`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "f95496a6c3cc0dc5845f83dfede498241dd2632f", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-covariant.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -2,6 +2,8 @@\n //\n // In particular, we test this pattern in trait solving, where it is not connected\n // to any part of the source code.\n+//\n+// check-pass\n \n trait Trait<T> {}\n \n@@ -30,9 +32,6 @@ fn main() {\n     //         - `?b: ?a` -- solveable if `?b` is inferred to `'static`\n     // - So the subtyping check succeeds, somewhat surprisingly.\n     //   This is because we can use `'static`.\n-    //\n-    // NB. *However*, the reinstated leak-check gives an error here.\n \n     foo::<()>();\n-    //~^ ERROR not satisfied\n }"}, {"sha": "1e335f9ee96106d4a8df6b0f1a36f12ca6df4077", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-covariant.stderr", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b1c08c68ccc2c222f84384c836b5e167e2bc241/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b1c08c68ccc2c222f84384c836b5e167e2bc241/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.stderr?ref=3b1c08c68ccc2c222f84384c836b5e167e2bc241", "patch": "@@ -1,18 +0,0 @@\n-error[E0277]: the trait bound `(): Trait<for<'b> fn(fn(&'b u32))>` is not satisfied\n-  --> $DIR/hrtb-exists-forall-trait-covariant.rs:36:11\n-   |\n-LL | fn foo<T>()\n-   |    --- required by a bound in this\n-LL | where\n-LL |     T: Trait<for<'b> fn(fn(&'b u32))>,\n-   |        ------------------------------ required by this bound in `foo`\n-...\n-LL |     foo::<()>();\n-   |           ^^ the trait `Trait<for<'b> fn(fn(&'b u32))>` is not implemented for `()`\n-   |\n-   = help: the following implementations were found:\n-             <() as Trait<fn(fn(&'a u32))>>\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "e2a399b2faa9d8887084e879fe4e81b6a10ac304", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-invariant.nll.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/hrtb-exists-forall-trait-invariant.rs:28:5\n+   |\n+LL |     foo::<()>();\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "b1b7ec6bcf1a5803b80ee3f6b0a8bc1225d90f30", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-invariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -25,5 +25,5 @@ fn main() {\n     //     yielding `fn(&!b u32)`, in a fresh universe U1\n     //   - So we get `?a = !b` but the universe U0 assigned to `?a` cannot name `!b`.\n \n-    foo::<()>(); //~ ERROR not satisfied\n+    foo::<()>(); //~ ERROR implementation of `Trait` is not general enough\n }"}, {"sha": "720e2276d5343705292569e851f3dc6815dad7f3", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-invariant.stderr", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,18 +1,14 @@\n-error[E0277]: the trait bound `(): Trait<for<'b> fn(std::cell::Cell<&'b u32>)>` is not satisfied\n-  --> $DIR/hrtb-exists-forall-trait-invariant.rs:28:11\n+error: implementation of `Trait` is not general enough\n+  --> $DIR/hrtb-exists-forall-trait-invariant.rs:28:5\n    |\n-LL | fn foo<T>()\n-   |    --- required by a bound in this\n-LL | where\n-LL |     T: Trait<for<'b> fn(Cell<&'b u32>)>,\n-   |        -------------------------------- required by this bound in `foo`\n+LL | trait Trait<T> {}\n+   | ----------------- trait `Trait` defined here\n ...\n LL |     foo::<()>();\n-   |           ^^ the trait `Trait<for<'b> fn(std::cell::Cell<&'b u32>)>` is not implemented for `()`\n+   |     ^^^^^^^^^ implementation of `Trait` is not general enough\n    |\n-   = help: the following implementations were found:\n-             <() as Trait<fn(std::cell::Cell<&'a u32>)>>\n+   = note: `()` must implement `Trait<for<'b> fn(std::cell::Cell<&'b u32>)>`\n+   = note: ...but `()` actually implements `Trait<fn(std::cell::Cell<&'0 u32>)>`, for some specific lifetime `'0`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "8901a1b46817d6b4b77435d7675377fb05e1cd34", "filename": "src/test/ui/hrtb/hrtb-just-for-static.nll.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,24 @@\n+error: higher-ranked subtype error\n+  --> $DIR/hrtb-just-for-static.rs:24:5\n+   |\n+LL |     want_hrtb::<StaticInt>()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: lifetime may not live long enough\n+  --> $DIR/hrtb-just-for-static.rs:30:5\n+   |\n+LL | fn give_some<'a>() {\n+   |              -- lifetime `'a` defined here\n+LL |     want_hrtb::<&'a u32>()\n+   |     ^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error: higher-ranked subtype error\n+  --> $DIR/hrtb-just-for-static.rs:30:5\n+   |\n+LL |     want_hrtb::<&'a u32>()\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "5e3014317f5bc7025c8eddaeee4a217aee17639f", "filename": "src/test/ui/hrtb/hrtb-just-for-static.stderr", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,31 +1,30 @@\n-error[E0277]: the trait bound `for<'a> StaticInt: Foo<&'a isize>` is not satisfied\n-  --> $DIR/hrtb-just-for-static.rs:24:17\n+error: implementation of `Foo` is not general enough\n+  --> $DIR/hrtb-just-for-static.rs:24:5\n    |\n-LL | fn want_hrtb<T>()\n-   |    --------- required by a bound in this\n-LL |     where T : for<'a> Foo<&'a isize>\n-   |               ---------------------- required by this bound in `want_hrtb`\n+LL | / trait Foo<X> {\n+LL | |     fn foo(&self, x: X) { }\n+LL | | }\n+   | |_- trait `Foo` defined here\n ...\n-LL |     want_hrtb::<StaticInt>()\n-   |                 ^^^^^^^^^ the trait `for<'a> Foo<&'a isize>` is not implemented for `StaticInt`\n+LL |       want_hrtb::<StaticInt>()\n+   |       ^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n-   = help: the following implementations were found:\n-             <StaticInt as Foo<&'static isize>>\n+   = note: `StaticInt` must implement `Foo<&'0 isize>`, for any lifetime `'0`...\n+   = note: ...but `StaticInt` actually implements `Foo<&'1 isize>`, for some specific lifetime `'1`\n \n-error[E0277]: the trait bound `for<'a> &'a u32: Foo<&'a isize>` is not satisfied\n-  --> $DIR/hrtb-just-for-static.rs:30:17\n+error: implementation of `Foo` is not general enough\n+  --> $DIR/hrtb-just-for-static.rs:30:5\n    |\n-LL | fn want_hrtb<T>()\n-   |    --------- required by a bound in this\n-LL |     where T : for<'a> Foo<&'a isize>\n-   |               ---------------------- required by this bound in `want_hrtb`\n+LL | / trait Foo<X> {\n+LL | |     fn foo(&self, x: X) { }\n+LL | | }\n+   | |_- trait `Foo` defined here\n ...\n-LL |     want_hrtb::<&'a u32>()\n-   |                 ^^^^^^^ the trait `for<'a> Foo<&'a isize>` is not implemented for `&'a u32`\n+LL |       want_hrtb::<&'a u32>()\n+   |       ^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n-   = help: the following implementations were found:\n-             <&'a u32 as Foo<&'a isize>>\n+   = note: `Foo<&'0 isize>` would have to be implemented for the type `&'a u32`, for any lifetime `'0`...\n+   = note: ...but `Foo<&'1 isize>` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "90a7cadca41b7e43336a55b4674122aa0313e725", "filename": "src/test/ui/hrtb/issue-30786.migrate.stderr", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,17 +1,43 @@\n-error: implementation of `Stream` is not general enough\n-  --> $DIR/issue-30786.rs:108:22\n+error[E0599]: no method named `filterx` found for struct `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>` in the current scope\n+  --> $DIR/issue-30786.rs:128:22\n    |\n-LL | / pub trait Stream {\n-LL | |     type Item;\n-LL | |     fn next(self) -> Option<Self::Item>;\n-LL | | }\n-   | |_- trait `Stream` defined here\n+LL | pub struct Map<S, F> {\n+   | --------------------\n+   | |\n+   | method `filterx` not found for this\n+   | doesn't satisfy `_: StreamExt`\n ...\n-LL |       let map = source.map(|x: &_| x);\n-   |                        ^^^ implementation of `Stream` is not general enough\n+LL |     let filter = map.filterx(|x: &_| true);\n+   |                      ^^^^^^^ method not found in `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>`\n    |\n-   = note: `Stream` would have to be implemented for the type `&'0 mut Map<Repeat, [closure@$DIR/issue-30786.rs:108:26: 108:35]>`, for any lifetime `'0`...\n-   = note: ...but `Stream` is actually implemented for the type `&'1 mut Map<Repeat, [closure@$DIR/issue-30786.rs:108:26: 108:35]>`, for some specific lifetime `'1`\n+   = note: the method `filterx` exists but the following trait bounds were not satisfied:\n+           `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n+           which is required by `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: StreamExt`\n+           `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n+           which is required by `&Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: StreamExt`\n+           `&'a mut &mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n+           which is required by `&mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: StreamExt`\n \n-error: aborting due to previous error\n+error[E0599]: no method named `countx` found for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>` in the current scope\n+  --> $DIR/issue-30786.rs:141:24\n+   |\n+LL | pub struct Filter<S, F> {\n+   | -----------------------\n+   | |\n+   | method `countx` not found for this\n+   | doesn't satisfy `_: StreamExt`\n+...\n+LL |     let count = filter.countx();\n+   |                        ^^^^^^ method not found in `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>`\n+   |\n+   = note: the method `countx` exists but the following trait bounds were not satisfied:\n+           `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n+           which is required by `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: StreamExt`\n+           `&'a mut &Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n+           which is required by `&Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: StreamExt`\n+           `&'a mut &mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n+           which is required by `&mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: StreamExt`\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "90a7cadca41b7e43336a55b4674122aa0313e725", "filename": "src/test/ui/hrtb/issue-30786.nll.stderr", "status": "modified", "additions": 43, "deletions": 56, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,56 +1,43 @@\n-error: higher-ranked subtype error\n-  --> $DIR/issue-30786.rs:108:15\n-   |\n-LL |     let map = source.map(|x: &_| x);\n-   |               ^^^^^^^^^^^^^^^^^^^^^\n-\n-error: higher-ranked subtype error\n-  --> $DIR/issue-30786.rs:114:18\n-   |\n-LL |     let filter = map.filter(|x: &_| true);\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: higher-ranked subtype error\n-  --> $DIR/issue-30786.rs:114:18\n-   |\n-LL |     let filter = map.filter(|x: &_| true);\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: higher-ranked subtype error\n-  --> $DIR/issue-30786.rs:114:18\n-   |\n-LL |     let filter = map.filter(|x: &_| true);\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: higher-ranked subtype error\n-  --> $DIR/issue-30786.rs:114:18\n-   |\n-LL |     let filter = map.filter(|x: &_| true);\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: higher-ranked subtype error\n-  --> $DIR/issue-30786.rs:119:17\n-   |\n-LL |     let count = filter.count(); // Assert that we still have a valid stream.\n-   |                 ^^^^^^^^^^^^^^\n-\n-error: higher-ranked subtype error\n-  --> $DIR/issue-30786.rs:119:17\n-   |\n-LL |     let count = filter.count(); // Assert that we still have a valid stream.\n-   |                 ^^^^^^^^^^^^^^\n-\n-error: higher-ranked subtype error\n-  --> $DIR/issue-30786.rs:119:17\n-   |\n-LL |     let count = filter.count(); // Assert that we still have a valid stream.\n-   |                 ^^^^^^^^^^^^^^\n-\n-error: higher-ranked subtype error\n-  --> $DIR/issue-30786.rs:119:17\n-   |\n-LL |     let count = filter.count(); // Assert that we still have a valid stream.\n-   |                 ^^^^^^^^^^^^^^\n-\n-error: aborting due to 9 previous errors\n-\n+error[E0599]: no method named `filterx` found for struct `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>` in the current scope\n+  --> $DIR/issue-30786.rs:128:22\n+   |\n+LL | pub struct Map<S, F> {\n+   | --------------------\n+   | |\n+   | method `filterx` not found for this\n+   | doesn't satisfy `_: StreamExt`\n+...\n+LL |     let filter = map.filterx(|x: &_| true);\n+   |                      ^^^^^^^ method not found in `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>`\n+   |\n+   = note: the method `filterx` exists but the following trait bounds were not satisfied:\n+           `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n+           which is required by `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: StreamExt`\n+           `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n+           which is required by `&Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: StreamExt`\n+           `&'a mut &mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n+           which is required by `&mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: StreamExt`\n+\n+error[E0599]: no method named `countx` found for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>` in the current scope\n+  --> $DIR/issue-30786.rs:141:24\n+   |\n+LL | pub struct Filter<S, F> {\n+   | -----------------------\n+   | |\n+   | method `countx` not found for this\n+   | doesn't satisfy `_: StreamExt`\n+...\n+LL |     let count = filter.countx();\n+   |                        ^^^^^^ method not found in `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>`\n+   |\n+   = note: the method `countx` exists but the following trait bounds were not satisfied:\n+           `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n+           which is required by `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: StreamExt`\n+           `&'a mut &Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n+           which is required by `&Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: StreamExt`\n+           `&'a mut &mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n+           which is required by `&mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: StreamExt`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "8ce5c090b543edcd646a7c3d65809e8323ab9b53", "filename": "src/test/ui/hrtb/issue-30786.rs", "status": "modified", "additions": 62, "deletions": 40, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -16,7 +16,7 @@\n \n //[nll]compile-flags: -Z borrowck=mir\n \n-pub trait Stream { //[migrate]~ NOTE trait `Stream` defined here\n+pub trait Stream {\n     type Item;\n     fn next(self) -> Option<Self::Item>;\n }\n@@ -37,8 +37,9 @@ pub struct Map<S, F> {\n }\n \n impl<'a, A, F, T> Stream for &'a mut Map<A, F>\n-where &'a mut A: Stream,\n-      F: FnMut(<&'a mut A as Stream>::Item) -> T,\n+where\n+    &'a mut A: Stream,\n+    F: FnMut(<&'a mut A as Stream>::Item) -> T,\n {\n     type Item = T;\n     fn next(self) -> Option<T> {\n@@ -55,8 +56,9 @@ pub struct Filter<S, F> {\n }\n \n impl<'a, A, F, T> Stream for &'a mut Filter<A, F>\n-where for<'b> &'b mut A: Stream<Item=T>, // <---- BAD\n-      F: FnMut(&T) -> bool,\n+where\n+    for<'b> &'b mut A: Stream<Item = T>, // <---- BAD\n+    F: FnMut(&T) -> bool,\n {\n     type Item = <&'a mut A as Stream>::Item;\n     fn next(self) -> Option<Self::Item> {\n@@ -69,29 +71,29 @@ where for<'b> &'b mut A: Stream<Item=T>, // <---- BAD\n     }\n }\n \n-pub trait StreamExt where for<'b> &'b mut Self: Stream {\n-    fn map<F>(self, func: F) -> Map<Self, F>\n-    where Self: Sized,\n-    for<'a> &'a mut Map<Self, F>: Stream,\n+pub trait StreamExt\n+where\n+    for<'b> &'b mut Self: Stream,\n+{\n+    fn mapx<F>(self, func: F) -> Map<Self, F>\n+    where\n+        Self: Sized,\n+        for<'a> &'a mut Map<Self, F>: Stream,\n     {\n-        Map {\n-            func: func,\n-            stream: self,\n-        }\n+        Map { func: func, stream: self }\n     }\n \n-    fn filter<F>(self, func: F) -> Filter<Self, F>\n-    where Self: Sized,\n-    for<'a> &'a mut Filter<Self, F>: Stream,\n+    fn filterx<F>(self, func: F) -> Filter<Self, F>\n+    where\n+        Self: Sized,\n+        for<'a> &'a mut Filter<Self, F>: Stream,\n     {\n-        Filter {\n-            func: func,\n-            stream: self,\n-        }\n+        Filter { func: func, stream: self }\n     }\n \n-    fn count(mut self) -> usize\n-    where Self: Sized,\n+    fn countx(mut self) -> usize\n+    where\n+        Self: Sized,\n     {\n         let mut count = 0;\n         while let Some(_) = self.next() {\n@@ -101,24 +103,44 @@ pub trait StreamExt where for<'b> &'b mut Self: Stream {\n     }\n }\n \n-impl<T> StreamExt for T where for<'a> &'a mut T: Stream { }\n+impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n \n-fn main() {\n+fn identity<T>(x: &T) -> &T {\n+    x\n+}\n+\n+fn variant1() {\n     let source = Repeat(10);\n-    let map = source.map(|x: &_| x);\n-    //[nll]~^ ERROR higher-ranked subtype error\n-    //[migrate]~^^ ERROR implementation of `Stream` is not general enough\n-    //[migrate]~| NOTE  `Stream` would have to be implemented for the type `&'0 mut Map\n-    //[migrate]~| NOTE  but `Stream` is actually implemented for the type `&'1\n-    //[migrate]~| NOTE  implementation of `Stream` is not general enough\n-    let filter = map.filter(|x: &_| true);\n-    //[nll]~^ ERROR higher-ranked subtype error\n-    //[nll]~| ERROR higher-ranked subtype error\n-    //[nll]~| ERROR higher-ranked subtype error\n-    //[nll]~| ERROR higher-ranked subtype error\n-    let count = filter.count(); // Assert that we still have a valid stream.\n-    //[nll]~^ ERROR higher-ranked subtype error\n-    //[nll]~| ERROR higher-ranked subtype error\n-    //[nll]~| ERROR higher-ranked subtype error\n-    //[nll]~| ERROR higher-ranked subtype error\n+\n+    // Here, the call to `mapx` returns a type `T` to which `StreamExt`\n+    // is not applicable, because `for<'b> &'b mut T: Stream`) doesn't hold.\n+    //\n+    // More concretely, the type `T` is `Map<Repeat, Closure>`, and\n+    // the where clause doesn't hold because the signature of the\n+    // closure gets inferred to a signature like `|&'_ Stream| -> &'_`\n+    // for some specific `'_`, rather than a more generic\n+    // signature.\n+    //\n+    // Why *exactly* we opt for this signature is a bit unclear to me,\n+    // we deduce it somehow from a reuqirement that `Map: Stream` I\n+    // guess.\n+    let map = source.mapx(|x: &_| x);\n+    let filter = map.filterx(|x: &_| true);\n+    //[migrate]~^ ERROR no method named `filterx`\n+    //[nll]~^^ ERROR no method named `filterx`\n }\n+\n+fn variant2() {\n+    let source = Repeat(10);\n+\n+    // Here, we use a function, which is not subject to the vagaries\n+    // of closure signature inference. In this case, we get the error\n+    // on `countx` as, I think, the test originally expected.\n+    let map = source.mapx(identity);\n+    let filter = map.filterx(|x: &_| true);\n+    let count = filter.countx();\n+    //[migrate]~^ ERROR no method named `countx`\n+    //[nll]~^^ ERROR no method named `countx`\n+}\n+\n+fn main() {}"}, {"sha": "6c127b92d97d19d7224b066b4130f79d3eb97b3b", "filename": "src/test/ui/hrtb/issue-46989.nll.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/issue-46989.rs:38:5\n+   |\n+LL |     assert_foo::<fn(&i32)>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "4a09f4be156e2bb60a879883cf640004796c28d1", "filename": "src/test/ui/hrtb/issue-46989.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -28,15 +28,13 @@\n //\n // holds because 'a can be instantiated to 'empty.\n \n-trait Foo {\n+trait Foo {}\n \n-}\n-\n-impl<A> Foo for fn(A) { }\n+impl<A> Foo for fn(A) {}\n \n fn assert_foo<T: Foo>() {}\n \n fn main() {\n     assert_foo::<fn(&i32)>();\n-    //~^ ERROR the trait bound `for<'r> fn(&'r i32): Foo` is not satisfied\n+    //~^ ERROR implementation of `Foo` is not general enough\n }"}, {"sha": "c85c37ff9239e3a3a6d78870395c7c0789843cd9", "filename": "src/test/ui/hrtb/issue-46989.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,15 +1,14 @@\n-error[E0277]: the trait bound `for<'r> fn(&'r i32): Foo` is not satisfied\n-  --> $DIR/issue-46989.rs:40:18\n+error: implementation of `Foo` is not general enough\n+  --> $DIR/issue-46989.rs:38:5\n    |\n-LL | fn assert_foo<T: Foo>() {}\n-   |                  --- required by this bound in `assert_foo`\n+LL | trait Foo {}\n+   | ------------ trait `Foo` defined here\n ...\n LL |     assert_foo::<fn(&i32)>();\n-   |                  ^^^^^^^^ the trait `Foo` is not implemented for `for<'r> fn(&'r i32)`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n-   = help: the following implementations were found:\n-             <fn(A) as Foo>\n+   = note: `Foo` would have to be implemented for the type `for<'r> fn(&'r i32)`\n+   = note: ...but `Foo` is actually implemented for the type `fn(&'0 i32)`, for some specific lifetime `'0`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "3b339c5c3d7fc69a75c6a1f00338b8b8a748f2f2", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -53,7 +53,15 @@ LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n    |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:33:69\n+  --> $DIR/must_outlive_least_region_or_bound.rs:30:24\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n+   |               -        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n+   |               |\n+   |               let's call the lifetime of this reference `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/must_outlive_least_region_or_bound.rs:37:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |               -- lifetime `'a` defined here                         ^ returning this value requires that `'a` must outlive `'static`\n@@ -62,7 +70,7 @@ LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    = help: consider replacing `'a` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:38:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:42:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n    |                          --  -- lifetime `'b` defined here  ^^^^^^^^^^^^^^^^ opaque type requires that `'b` must outlive `'a`\n@@ -72,14 +80,14 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n    = help: consider adding the following bound: `'b: 'a`\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:43:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:47:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                                   ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0310, E0621.\n For more information about an error, try `rustc --explain E0310`."}, {"sha": "9bf86fa66cdeda4c7ccd2cd6a55d18a2fbdc570a", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -27,6 +27,10 @@ fn elided4(x: &i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n //~^ ERROR cannot infer an appropriate lifetime\n \n+fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n+//~^ ERROR cannot infer an appropriate lifetime\n+//~| ERROR cannot infer an appropriate lifetime\n+\n trait LifetimeTrait<'a> {}\n impl<'a> LifetimeTrait<'a> for &'a i32 {}\n "}, {"sha": "ffadcaae08e05ed165636b369249098c140a5f37", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -87,13 +87,48 @@ LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n    |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n \n error[E0759]: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:33:69\n+  --> $DIR/must_outlive_least_region_or_bound.rs:30:65\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n+   |               ---- this data with an anonymous lifetime `'_`... ^ ...is captured here, requiring it to live as long as `'static`\n+   |\n+help: to declare that the trait object captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug + '_>, impl Debug) { (Box::new(x), x) }\n+   |                                       ^^^^\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug + '_) { (Box::new(x), x) }\n+   |                                                    ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:30:69\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n+   |               ---- this data with an anonymous lifetime `'_`...     ^ ...is captured here...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:30:41\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n+   |                                         ^^^^^^^^^^\n+help: to declare that the trait object captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug + '_>, impl Debug) { (Box::new(x), x) }\n+   |                                       ^^^^\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug + '_) { (Box::new(x), x) }\n+   |                                                    ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:37:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |                      ------- this data with lifetime `'a`...        ^ ...is captured here...\n    |\n note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:33:34\n+  --> $DIR/must_outlive_least_region_or_bound.rs:37:34\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -107,7 +142,7 @@ LL | fn with_bound<'a>(x: &'static i32) -> impl LifetimeTrait<'a> + 'static { x\n    |                      ^^^^^^^^^^^^\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/must_outlive_least_region_or_bound.rs:38:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:42:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n    |                                                 -------     ^^^^^^^^^^^^^^^^\n@@ -116,7 +151,7 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n    |                                                 this parameter and the return type are declared with different lifetimes...\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:43:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:47:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                 --                ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n@@ -181,7 +216,7 @@ help: alternatively, add an explicit `'static` bound to this reference\n LL | fn explicit4<'a>(x: &'static i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n    |                     ^^^^^^^^^^^^\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 14 previous errors\n \n Some errors have detailed explanations: E0310, E0621, E0623, E0759.\n For more information about an error, try `rustc --explain E0310`."}, {"sha": "d1093c205798a0b8875111e57d65d23625d0e74b", "filename": "src/test/ui/issues/issue-25826.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-25826.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-25826.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25826.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,6 +1,6 @@\n fn id<T>(t: T) -> T { t }\n fn main() {\n     const A: bool = unsafe { id::<u8> as *const () < id::<u16> as *const () };\n-    //~^ ERROR comparing raw pointers inside constant\n+    //~^ ERROR pointers cannot be reliably compared during const eval\n     println!(\"{}\", A);\n }"}, {"sha": "67d1b3ab9bed60589b671ed483f99bf91666f6ff", "filename": "src/test/ui/issues/issue-25826.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-25826.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-25826.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25826.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,12 +1,10 @@\n-error[E0658]: comparing raw pointers inside constant\n+error: pointers cannot be reliably compared during const eval.\n   --> $DIR/issue-25826.rs:3:30\n    |\n LL |     const A: bool = unsafe { id::<u8> as *const () < id::<u16> as *const () };\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n-   = help: add `#![feature(const_compare_raw_pointers)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "f673fbae8b79ce1a70396783e12b079c2a7d7cd5", "filename": "src/test/ui/issues/issue-40000.nll.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-40000.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-40000.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40000.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/issue-40000.rs:6:9\n+   |\n+LL |     foo(bar);\n+   |         ^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "3eb3482ac910ea030b1c72c1ced510d5175160dd", "filename": "src/test/ui/issues/issue-40000.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-40000.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-40000.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40000.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -2,10 +2,10 @@ error[E0308]: mismatched types\n   --> $DIR/issue-40000.rs:6:9\n    |\n LL |     foo(bar);\n-   |         ^^^ expected concrete lifetime, found bound lifetime parameter\n+   |         ^^^ one type is more general than the other\n    |\n-   = note: expected struct `std::boxed::Box<(dyn for<'r> std::ops::Fn(&'r i32) + 'static)>`\n-              found struct `std::boxed::Box<dyn std::ops::Fn(_)>`\n+   = note: expected trait object `dyn for<'r> std::ops::Fn(&'r i32)`\n+              found trait object `dyn std::ops::Fn(&i32)`\n \n error: aborting due to previous error\n "}, {"sha": "99cae46fd9cf2b9c33d7f0704ee44d6b0ba6e43f", "filename": "src/test/ui/issues/issue-43623.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-43623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-43623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43623.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -9,11 +9,12 @@ impl<'a> Trait<'a> for Type {\n }\n \n pub fn break_me<T, F>(f: F)\n-where T: for<'b> Trait<'b>,\n-      F: for<'b> FnMut(<T as Trait<'b>>::Assoc) {\n+where\n+    T: for<'b> Trait<'b>,\n+    F: for<'b> FnMut(<T as Trait<'b>>::Assoc),\n+{\n     break_me::<Type, fn(_)>;\n     //~^ ERROR: type mismatch in function arguments\n-    //~| ERROR: type mismatch resolving\n }\n \n fn main() {}"}, {"sha": "80aca482b3d29b8c8e614353bd7e9f4360d02178", "filename": "src/test/ui/issues/issue-43623.stderr", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-43623.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-43623.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43623.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,29 +1,18 @@\n error[E0631]: type mismatch in function arguments\n-  --> $DIR/issue-43623.rs:14:5\n+  --> $DIR/issue-43623.rs:16:5\n    |\n LL | pub fn break_me<T, F>(f: F)\n    |        -------- required by a bound in this\n-LL | where T: for<'b> Trait<'b>,\n-LL |       F: for<'b> FnMut(<T as Trait<'b>>::Assoc) {\n-   |          -------------------------------------- required by this bound in `break_me`\n+...\n+LL |     F: for<'b> FnMut(<T as Trait<'b>>::Assoc),\n+   |                ------------------------------ required by this bound in `break_me`\n+LL | {\n LL |     break_me::<Type, fn(_)>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n-   |     expected signature of `for<'b> fn(<Type as Trait<'b>>::Assoc) -> _`\n-   |     found signature of `fn(_) -> _`\n+   |     expected signature of `fn(<Type as Trait<'b>>::Assoc) -> _`\n+   |     found signature of `fn(()) -> _`\n \n-error[E0271]: type mismatch resolving `for<'b> <fn(_) as std::ops::FnOnce<(<Type as Trait<'b>>::Assoc,)>>::Output == ()`\n-  --> $DIR/issue-43623.rs:14:5\n-   |\n-LL | pub fn break_me<T, F>(f: F)\n-   |        -------- required by a bound in this\n-LL | where T: for<'b> Trait<'b>,\n-LL |       F: for<'b> FnMut(<T as Trait<'b>>::Assoc) {\n-   |                  ------------------------------ required by this bound in `break_me`\n-LL |     break_me::<Type, fn(_)>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'b, found concrete lifetime\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0271, E0631.\n-For more information about an error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0631`."}, {"sha": "47cc64ec470a5f5b0167c8a2300251bd7bdfbafd", "filename": "src/test/ui/issues/issue-57362-2.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-57362-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-57362-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57362-2.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -4,6 +4,8 @@ error[E0599]: no function or associated item named `make_g` found for fn pointer\n LL |     let x = <fn (&())>::make_g();\n    |                         ^^^^^^ function or associated item not found in `for<'r> fn(&'r ())`\n    |\n+   = note: the method `make_g` exists but the following trait bounds were not satisfied:\n+           `for<'r> fn(&'r ()): X`\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `X` defines an item `make_g`, perhaps you need to implement it\n   --> $DIR/issue-57362-2.rs:8:1"}, {"sha": "9c2b2dc9f4daec0b3fc68c30a25d26694002bdc1", "filename": "src/test/ui/issues/issue-60283.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-60283.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-60283.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60283.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -7,11 +7,13 @@ impl<'a> Trait<'a> for () {\n }\n \n pub fn foo<T, F>(_: T, _: F)\n-where T: for<'a> Trait<'a>,\n-      F: for<'a> FnMut(<T as Trait<'a>>::Item) {}\n+where\n+    T: for<'a> Trait<'a>,\n+    F: for<'a> FnMut(<T as Trait<'a>>::Item),\n+{\n+}\n \n fn main() {\n     foo((), drop)\n     //~^ ERROR type mismatch in function arguments\n-    //~| ERROR type mismatch resolving\n }"}, {"sha": "ad679bfa22063cd39d21f78c34dd65002fba3cf5", "filename": "src/test/ui/issues/issue-60283.stderr", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-60283.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fissues%2Fissue-60283.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60283.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,31 +1,18 @@\n error[E0631]: type mismatch in function arguments\n-  --> $DIR/issue-60283.rs:14:13\n+  --> $DIR/issue-60283.rs:17:13\n    |\n LL | pub fn foo<T, F>(_: T, _: F)\n    |        --- required by a bound in this\n-LL | where T: for<'a> Trait<'a>,\n-LL |       F: for<'a> FnMut(<T as Trait<'a>>::Item) {}\n-   |          ------------------------------------- required by this bound in `foo`\n+...\n+LL |     F: for<'a> FnMut(<T as Trait<'a>>::Item),\n+   |                ----------------------------- required by this bound in `foo`\n ...\n LL |     foo((), drop)\n    |             ^^^^\n    |             |\n-   |             expected signature of `for<'a> fn(<() as Trait<'a>>::Item) -> _`\n-   |             found signature of `fn(_) -> _`\n-\n-error[E0271]: type mismatch resolving `for<'a> <fn(_) {std::mem::drop::<_>} as std::ops::FnOnce<(<() as Trait<'a>>::Item,)>>::Output == ()`\n-  --> $DIR/issue-60283.rs:14:5\n-   |\n-LL | pub fn foo<T, F>(_: T, _: F)\n-   |        --- required by a bound in this\n-LL | where T: for<'a> Trait<'a>,\n-LL |       F: for<'a> FnMut(<T as Trait<'a>>::Item) {}\n-   |                  ----------------------------- required by this bound in `foo`\n-...\n-LL |     foo((), drop)\n-   |     ^^^ expected bound lifetime parameter 'a, found concrete lifetime\n+   |             expected signature of `fn(<() as Trait<'a>>::Item) -> _`\n+   |             found signature of `fn(()) -> _`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0271, E0631.\n-For more information about an error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0631`."}, {"sha": "fbf4aee02045d5d0c442390c0cd1234f31fb74b1", "filename": "src/test/ui/lub-glb/old-lub-glb-hr-eq.rs", "status": "renamed", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-eq.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -4,29 +4,24 @@\n // longer get an error, because we recognize these two types as\n // equivalent!\n //\n-// Whoops -- now that we reinstituted the leak-check, we get an error\n-// again.\n+// check-pass\n \n-fn foo(\n-    x: fn(&u8, &u8),\n-    y: for<'a> fn(&'a u8, &'a u8),\n-) {\n+fn foo(x: fn(&u8, &u8), y: for<'a> fn(&'a u8, &'a u8)) {\n+    // The two types above are actually equivalent. With the older\n+    // leak check, though, we didn't consider them as equivalent, and\n+    // hence we gave errors. But now we've fixed that.\n     let z = match 22 {\n         0 => x,\n-        _ => y, //~ ERROR `match` arms have incompatible types\n+        _ => y,\n     };\n }\n \n-fn bar(\n-    x: fn(&u8, &u8),\n-    y: for<'a> fn(&'a u8, &'a u8),\n-) {\n+fn foo_cast(x: fn(&u8, &u8), y: for<'a> fn(&'a u8, &'a u8)) {\n     let z = match 22 {\n         // No error with an explicit cast:\n         0 => x as for<'a> fn(&'a u8, &'a u8),\n         _ => y,\n     };\n }\n \n-fn main() {\n-}\n+fn main() {}", "previous_filename": "src/test/ui/lub-glb/old-lub-glb-hr.rs"}, {"sha": "b95e247d2a8cf8d737761c5389ddfe08275a2952", "filename": "src/test/ui/lub-glb/old-lub-glb-hr-noteq1.nll.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq1.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/old-lub-glb-hr-noteq1.rs:11:14\n+   |\n+LL |         _ => y,\n+   |              ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "918542d471b58c08b4640afe24156595106d309a", "filename": "src/test/ui/lub-glb/old-lub-glb-hr-noteq1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq1.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,24 @@\n+// Test taking the LUB of two function types that are not equatable but where one is more\n+// general than the other. Test the case where the more general type (`x`) is the first\n+// match arm specifically.\n+\n+fn foo(x: for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8, y: for<'a> fn(&'a u8, &'a u8) -> &'a u8) {\n+    // The two types above are not equivalent. With the older LUB/GLB\n+    // algorithm, this may have worked (I don't remember), but now it\n+    // doesn't because we require equality.\n+    let z = match 22 {\n+        0 => x,\n+        _ => y, //~ ERROR `match` arms have incompatible types\n+    };\n+}\n+\n+fn foo_cast(x: for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8, y: for<'a> fn(&'a u8, &'a u8) -> &'a u8) {\n+    // But we can *upcast* explicitly the type of `x` and figure\n+    // things out:\n+    let z = match 22 {\n+        0 => x as for<'a> fn(&'a u8, &'a u8) -> &'a u8,\n+        _ => y,\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "305e952d6046b55b885f52a793fa4d380c8660a2", "filename": "src/test/ui/lub-glb/old-lub-glb-hr-noteq1.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq1.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/old-lub-glb-hr-noteq1.rs:11:14\n+   |\n+LL |       let z = match 22 {\n+   |  _____________-\n+LL | |         0 => x,\n+   | |              - this is found to be of type `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`\n+LL | |         _ => y,\n+   | |              ^ one type is more general than the other\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected fn pointer `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`\n+              found fn pointer `for<'a> fn(&'a u8, &'a u8) -> &'a u8`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "4bdd05b4f92fabf7a2a1053dc132843e027b2a90", "filename": "src/test/ui/lub-glb/old-lub-glb-hr-noteq2.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq2.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,33 @@\n+// Test taking the LUB of two function types that are not equatable but where\n+// one is more general than the other. Test the case where the more general type\n+// (`x`) is the second match arm specifically.\n+//\n+// FIXME(#73154) Skip for compare-mode because the pure NLL checker accepts this\n+// test. (Note that it still errors in old-lub-glb-hr-noteq1.rs). What happens\n+// is that, due to the ordering of the match arms, we pick the correct \"more\n+// general\" fn type, and we ignore the errors from the non-NLL type checker that\n+// requires equality. The NLL type checker only requires a subtyping\n+// relationship, and that holds.\n+//\n+// ignore-compare-mode-nll\n+\n+fn foo(x: for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8, y: for<'a> fn(&'a u8, &'a u8) -> &'a u8) {\n+    // The two types above are not equivalent. With the older LUB/GLB\n+    // algorithm, this may have worked (I don't remember), but now it\n+    // doesn't because we require equality.\n+    let z = match 22 {\n+        0 => y,\n+        _ => x, //~ ERROR `match` arms have incompatible types\n+    };\n+}\n+\n+fn foo_cast(x: for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8, y: for<'a> fn(&'a u8, &'a u8) -> &'a u8) {\n+    // But we can *upcast* explicitly the type of `x` and figure\n+    // things out:\n+    let z = match 22 {\n+        0 => x as for<'a> fn(&'a u8, &'a u8) -> &'a u8,\n+        _ => y,\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "252e13aada0547cd5b7e0d36baaf498d051a6ff6", "filename": "src/test/ui/lub-glb/old-lub-glb-hr-noteq2.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr-noteq2.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/old-lub-glb-hr-noteq2.rs:20:14\n+   |\n+LL |       let z = match 22 {\n+   |  _____________-\n+LL | |         0 => y,\n+   | |              - this is found to be of type `for<'a> fn(&'a u8, &'a u8) -> &'a u8`\n+LL | |         _ => x,\n+   | |              ^ one type is more general than the other\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected fn pointer `for<'a> fn(&'a u8, &'a u8) -> &'a u8`\n+              found fn pointer `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "6d5d51174699fa17569e33b837610acf441487f0", "filename": "src/test/ui/lub-glb/old-lub-glb-hr.stderr", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b1c08c68ccc2c222f84384c836b5e167e2bc241/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b1c08c68ccc2c222f84384c836b5e167e2bc241/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr?ref=3b1c08c68ccc2c222f84384c836b5e167e2bc241", "patch": "@@ -1,18 +0,0 @@\n-error[E0308]: `match` arms have incompatible types\n-  --> $DIR/old-lub-glb-hr.rs:16:14\n-   |\n-LL |       let z = match 22 {\n-   |  _____________-\n-LL | |         0 => x,\n-   | |              - this is found to be of type `for<'r, 's> fn(&'r u8, &'s u8)`\n-LL | |         _ => y,\n-   | |              ^ expected bound lifetime parameter, found concrete lifetime\n-LL | |     };\n-   | |_____- `match` arms have incompatible types\n-   |\n-   = note:    expected type `for<'r, 's> fn(&'r u8, &'s u8)`\n-           found fn pointer `for<'a> fn(&'a u8, &'a u8)`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "51bf96f32335b8d5e22c6016b762a67b8e4fe811", "filename": "src/test/ui/lub-glb/old-lub-glb-object.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,14 @@\n+error: higher-ranked subtype error\n+  --> $DIR/old-lub-glb-object.rs:10:14\n+   |\n+LL |         _ => y,\n+   |              ^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/old-lub-glb-object.rs:10:14\n+   |\n+LL |         _ => y,\n+   |              ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "39d351c235574e2f86a02cdc63b3bafa4e4ff2e5", "filename": "src/test/ui/lub-glb/old-lub-glb-object.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,28 +1,22 @@\n // Test that we give a note when the old LUB/GLB algorithm would have\n // succeeded but the new code (which is stricter) gives an error.\n \n-trait Foo<T, U> { }\n+trait Foo<T, U> {}\n \n-fn foo(\n-    x: &dyn for<'a, 'b> Foo<&'a u8, &'b u8>,\n-    y: &dyn for<'a> Foo<&'a u8, &'a u8>,\n-) {\n+fn foo(x: &dyn for<'a, 'b> Foo<&'a u8, &'b u8>, y: &dyn for<'a> Foo<&'a u8, &'a u8>) {\n     let z = match 22 {\n+        //~^ ERROR mismatched types\n         0 => x,\n-        _ => y, //~ ERROR `match` arms have incompatible types\n+        _ => y,\n     };\n }\n \n-fn bar(\n-    x: &dyn for<'a, 'b> Foo<&'a u8, &'b u8>,\n-    y: &dyn for<'a> Foo<&'a u8, &'a u8>,\n-) {\n+fn bar(x: &dyn for<'a, 'b> Foo<&'a u8, &'b u8>, y: &dyn for<'a> Foo<&'a u8, &'a u8>) {\n     // Accepted with explicit case:\n     let z = match 22 {\n         0 => x as &dyn for<'a> Foo<&'a u8, &'a u8>,\n         _ => y,\n     };\n }\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "6eabe5eaeeeebcbd2f7f5141dfde79a2faa28846", "filename": "src/test/ui/lub-glb/old-lub-glb-object.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,17 +1,16 @@\n-error[E0308]: `match` arms have incompatible types\n-  --> $DIR/old-lub-glb-object.rs:12:14\n+error[E0308]: mismatched types\n+  --> $DIR/old-lub-glb-object.rs:7:13\n    |\n LL |       let z = match 22 {\n-   |  _____________-\n+   |  _____________^\n+LL | |\n LL | |         0 => x,\n-   | |              - this is found to be of type `&dyn for<'a, 'b> Foo<&'a u8, &'b u8>`\n LL | |         _ => y,\n-   | |              ^ expected bound lifetime parameter 'a, found concrete lifetime\n LL | |     };\n-   | |_____- `match` arms have incompatible types\n+   | |_____^ one type is more general than the other\n    |\n-   = note:   expected type `&dyn for<'a, 'b> Foo<&'a u8, &'b u8>`\n-           found reference `&dyn for<'a> Foo<&'a u8, &'a u8>`\n+   = note: expected trait object `dyn for<'a, 'b> Foo<&'a u8, &'b u8>`\n+              found trait object `dyn for<'a> Foo<&'a u8, &'a u8>`\n \n error: aborting due to previous error\n "}, {"sha": "6ed91b20ab8a6f88815d0f18fd3b8f3cd5918f53", "filename": "src/test/ui/mismatched_types/closure-arg-type-mismatch.nll.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,27 @@\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/closure-arg-type-mismatch.rs:3:14\n+   |\n+LL |     a.iter().map(|_: (u32, u32)| 45);\n+   |              ^^^ ------------------ found signature of `fn((u32, u32)) -> _`\n+   |              |\n+   |              expected signature of `fn(&(u32, u32)) -> _`\n+\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/closure-arg-type-mismatch.rs:4:14\n+   |\n+LL |     a.iter().map(|_: &(u16, u16)| 45);\n+   |              ^^^ ------------------- found signature of `for<'r> fn(&'r (u16, u16)) -> _`\n+   |              |\n+   |              expected signature of `fn(&(u32, u32)) -> _`\n+\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/closure-arg-type-mismatch.rs:5:14\n+   |\n+LL |     a.iter().map(|_: (u16, u16)| 45);\n+   |              ^^^ ------------------ found signature of `fn((u16, u16)) -> _`\n+   |              |\n+   |              expected signature of `fn(&(u32, u32)) -> _`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0631`."}, {"sha": "e278049c8cc42d2e4a2d61ea3f1d83429dd14a18", "filename": "src/test/ui/mismatched_types/closure-arg-type-mismatch.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -7,6 +7,9 @@ fn main() {\n \n fn baz<F: Fn(*mut &u32)>(_: F) {}\n fn _test<'a>(f: fn(*mut &'a u32)) {\n-    baz(f); //~ ERROR type mismatch\n-     //~| ERROR type mismatch\n+    baz(f);\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n }"}, {"sha": "664fa4bcaf3289cbb5562d004f8d76ab4a090804", "filename": "src/test/ui/mismatched_types/closure-arg-type-mismatch.stderr", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -22,28 +22,43 @@ LL |     a.iter().map(|_: (u16, u16)| 45);\n    |              |\n    |              expected signature of `fn(&(u32, u32)) -> _`\n \n-error[E0631]: type mismatch in function arguments\n-  --> $DIR/closure-arg-type-mismatch.rs:10:9\n+error[E0308]: mismatched types\n+  --> $DIR/closure-arg-type-mismatch.rs:10:5\n    |\n-LL | fn baz<F: Fn(*mut &u32)>(_: F) {}\n-   |           ------------- required by this bound in `baz`\n-LL | fn _test<'a>(f: fn(*mut &'a u32)) {\n LL |     baz(f);\n-   |         ^\n-   |         |\n-   |         expected signature of `for<'r> fn(*mut &'r u32) -> _`\n-   |         found signature of `fn(*mut &'a u32) -> _`\n+   |     ^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'r> std::ops::Fn<(*mut &'r u32,)>`\n+              found type `std::ops::Fn<(*mut &'a u32,)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/closure-arg-type-mismatch.rs:10:5\n+   |\n+LL |     baz(f);\n+   |     ^^^ one type is more general than the other\n+   |\n+   = note: expected type `std::ops::FnOnce<(*mut &u32,)>`\n+              found type `std::ops::FnOnce<(*mut &'a u32,)>`\n \n-error[E0271]: type mismatch resolving `for<'r> <fn(*mut &'a u32) as std::ops::FnOnce<(*mut &'r u32,)>>::Output == ()`\n+error[E0308]: mismatched types\n   --> $DIR/closure-arg-type-mismatch.rs:10:5\n    |\n-LL | fn baz<F: Fn(*mut &u32)>(_: F) {}\n-   |           ------------- required by this bound in `baz`\n-LL | fn _test<'a>(f: fn(*mut &'a u32)) {\n LL |     baz(f);\n-   |     ^^^ expected bound lifetime parameter, found concrete lifetime\n+   |     ^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'r> std::ops::Fn<(*mut &'r u32,)>`\n+              found type `std::ops::Fn<(*mut &'a u32,)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/closure-arg-type-mismatch.rs:10:5\n+   |\n+LL |     baz(f);\n+   |     ^^^ one type is more general than the other\n+   |\n+   = note: expected type `std::ops::FnOnce<(*mut &u32,)>`\n+              found type `std::ops::FnOnce<(*mut &'a u32,)>`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 7 previous errors\n \n-Some errors have detailed explanations: E0271, E0631.\n-For more information about an error, try `rustc --explain E0271`.\n+Some errors have detailed explanations: E0308, E0631.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "745a61b866ed2ad2341e1c91f8d56cc517b41375", "filename": "src/test/ui/mismatched_types/closure-mismatch.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,14 @@\n+error: higher-ranked subtype error\n+  --> $DIR/closure-mismatch.rs:8:5\n+   |\n+LL |     baz(|_| ());\n+   |     ^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/closure-mismatch.rs:8:5\n+   |\n+LL |     baz(|_| ());\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "d2b78b4b7dba57e3f2ea0b239ad6fe86e891e693", "filename": "src/test/ui/mismatched_types/closure-mismatch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -5,6 +5,5 @@ impl<T: Fn(&())> Foo for T {}\n fn baz<T: Foo>(_: T) {}\n \n fn main() {\n-    baz(|_| ()); //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n+    baz(|_| ()); //~ ERROR mismatched types\n }"}, {"sha": "d6c17d125cf1ea681fa103714e13f5610b113dc6", "filename": "src/test/ui/mismatched_types/closure-mismatch.stderr", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,28 +1,12 @@\n-error[E0271]: type mismatch resolving `for<'r> <[closure@$DIR/closure-mismatch.rs:8:9: 8:15] as std::ops::FnOnce<(&'r (),)>>::Output == ()`\n+error[E0308]: mismatched types\n   --> $DIR/closure-mismatch.rs:8:5\n    |\n-LL | fn baz<T: Foo>(_: T) {}\n-   |           --- required by this bound in `baz`\n-...\n LL |     baz(|_| ());\n-   |     ^^^ expected bound lifetime parameter, found concrete lifetime\n+   |     ^^^ one type is more general than the other\n    |\n-   = note: required because of the requirements on the impl of `Foo` for `[closure@$DIR/closure-mismatch.rs:8:9: 8:15]`\n+   = note: expected type `for<'r> std::ops::Fn<(&'r (),)>`\n+              found type `std::ops::Fn<(&(),)>`\n \n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/closure-mismatch.rs:8:5\n-   |\n-LL | fn baz<T: Foo>(_: T) {}\n-   |           --- required by this bound in `baz`\n-...\n-LL |     baz(|_| ());\n-   |     ^^^ ------ found signature of `fn(_) -> _`\n-   |     |\n-   |     expected signature of `for<'r> fn(&'r ()) -> _`\n-   |\n-   = note: required because of the requirements on the impl of `Foo` for `[closure@$DIR/closure-mismatch.rs:8:9: 8:15]`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0271, E0631.\n-For more information about an error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "d762f55f9d5f17da08155960cc059c6ed2629786", "filename": "src/test/ui/regions-fn-subtyping-return-static-fail.nll.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/regions-fn-subtyping-return-static-fail.rs:48:5\n+   |\n+LL |     want_G(baz);\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "539221b5a046c20c694430ab05cb46f77305282c", "filename": "src/test/ui/regions-fn-subtyping-return-static-fail.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -13,19 +13,19 @@ struct S;\n \n // Given 'cx, return 'cx\n type F = for<'cx> fn(&'cx S) -> &'cx S;\n-fn want_F(f: F) { }\n+fn want_F(f: F) {}\n \n // Given anything, return 'static\n type G = for<'cx> fn(&'cx S) -> &'static S;\n-fn want_G(f: G) { }\n+fn want_G(f: G) {}\n \n // Should meet both.\n fn foo(x: &S) -> &'static S {\n     panic!()\n }\n \n // Should meet both.\n-fn bar<'a,'b>(x: &'a S) -> &'b S {\n+fn bar<'a, 'b>(x: &'a S) -> &'b S {\n     panic!()\n }\n \n@@ -37,7 +37,7 @@ fn baz(x: &S) -> &S {\n fn supply_F() {\n     want_F(foo);\n \n-    want_F(bar); //~ ERROR mismatched types\n+    want_F(bar);\n \n     want_F(baz);\n }\n@@ -48,5 +48,4 @@ fn supply_G() {\n     want_G(baz); //~ ERROR mismatched types\n }\n \n-pub fn main() {\n-}\n+pub fn main() {}"}, {"sha": "c9ce936c7d43fc06e0691eb6304ae940d71fd50e", "filename": "src/test/ui/regions-fn-subtyping-return-static-fail.stderr", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,21 +1,12 @@\n-error[E0308]: mismatched types\n-  --> $DIR/regions-fn-subtyping-return-static-fail.rs:40:12\n-   |\n-LL |     want_F(bar);\n-   |            ^^^ expected concrete lifetime, found bound lifetime parameter 'cx\n-   |\n-   = note: expected fn pointer `for<'cx> fn(&'cx S) -> &'cx S`\n-                 found fn item `for<'a> fn(&'a S) -> &S {bar::<'_>}`\n-\n error[E0308]: mismatched types\n   --> $DIR/regions-fn-subtyping-return-static-fail.rs:48:12\n    |\n LL |     want_G(baz);\n-   |            ^^^ expected concrete lifetime, found bound lifetime parameter 'cx\n+   |            ^^^ one type is more general than the other\n    |\n    = note: expected fn pointer `for<'cx> fn(&'cx S) -> &'static S`\n-                 found fn item `for<'r> fn(&'r S) -> &'r S {baz}`\n+              found fn pointer `for<'r> fn(&'r S) -> &'r S`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "695f5506d5e38aadb36977a37f8e02c128ef450d", "filename": "src/test/ui/regions/region-lifetime-bounds-on-fns-where-clause.nll.stderr", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,14 +1,40 @@\n-error[E0308]: mismatched types\n-  --> $DIR/region-lifetime-bounds-on-fns-where-clause.rs:20:43\n+error: lifetime may not live long enough\n+  --> $DIR/region-lifetime-bounds-on-fns-where-clause.rs:8:5\n+   |\n+LL | fn b<'a, 'b>(x: &mut &'a isize, y: &mut &'b isize) {\n+   |      --  -- lifetime `'b` defined here\n+   |      |\n+   |      lifetime `'a` defined here\n+LL |     // Illegal now because there is no `'b:'a` declaration.\n+LL |     *x = *y;\n+   |     ^^^^^^^ assignment requires that `'b` must outlive `'a`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/region-lifetime-bounds-on-fns-where-clause.rs:14:5\n+   |\n+LL | fn c<'a,'b>(x: &mut &'a isize, y: &mut &'b isize) {\n+   |      -- -- lifetime `'b` defined here\n+   |      |\n+   |      lifetime `'a` defined here\n+...\n+LL |     a(x, y);\n+   |     ^^^^^^^ argument requires that `'b` must outlive `'a`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+error: higher-ranked subtype error\n+  --> $DIR/region-lifetime-bounds-on-fns-where-clause.rs:20:12\n    |\n LL |     let _: fn(&mut &isize, &mut &isize) = a;\n-   |            ----------------------------   ^ expected concrete lifetime, found bound lifetime parameter\n-   |            |\n-   |            expected due to this\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/region-lifetime-bounds-on-fns-where-clause.rs:20:12\n    |\n-   = note: expected fn pointer `for<'r, 's, 't0, 't1> fn(&'r mut &'s isize, &'t0 mut &'t1 isize)`\n-                 found fn item `for<'r, 's> fn(&'r mut &isize, &'s mut &isize) {a::<'_, '_>}`\n+LL |     let _: fn(&mut &isize, &mut &isize) = a;\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "b83e07663faba54cd662b74a0010c5818830e8dc", "filename": "src/test/ui/regions/region-lifetime-bounds-on-fns-where-clause.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -20,12 +20,10 @@ error[E0308]: mismatched types\n   --> $DIR/region-lifetime-bounds-on-fns-where-clause.rs:20:43\n    |\n LL |     let _: fn(&mut &isize, &mut &isize) = a;\n-   |            ----------------------------   ^ expected concrete lifetime, found bound lifetime parameter\n-   |            |\n-   |            expected due to this\n+   |                                           ^ one type is more general than the other\n    |\n    = note: expected fn pointer `for<'r, 's, 't0, 't1> fn(&'r mut &'s isize, &'t0 mut &'t1 isize)`\n-                 found fn item `for<'r, 's> fn(&'r mut &isize, &'s mut &isize) {a::<'_, '_>}`\n+              found fn pointer `for<'r, 's> fn(&'r mut &isize, &'s mut &isize)`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "a28f7aa3e08ca73b14f95ae8b84d032875f333cd", "filename": "src/test/ui/regions/region-multiple-lifetime-bounds-on-fns-where-clause.nll.stderr", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,14 +1,46 @@\n-error[E0308]: mismatched types\n-  --> $DIR/region-multiple-lifetime-bounds-on-fns-where-clause.rs:22:56\n+error: lifetime may not live long enough\n+  --> $DIR/region-multiple-lifetime-bounds-on-fns-where-clause.rs:9:5\n+   |\n+LL | fn b<'a, 'b, 'c>(x: &mut &'a isize, y: &mut &'b isize, z: &mut &'c isize) {\n+   |      --  -- lifetime `'b` defined here\n+   |      |\n+   |      lifetime `'a` defined here\n+LL |     // Illegal now because there is no `'b:'a` declaration.\n+LL |     *x = *y;\n+   |     ^^^^^^^ assignment requires that `'b` must outlive `'a`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/region-multiple-lifetime-bounds-on-fns-where-clause.rs:16:5\n+   |\n+LL | fn c<'a,'b, 'c>(x: &mut &'a isize, y: &mut &'b isize, z: &mut &'c isize) {\n+   |      -- -- lifetime `'b` defined here\n+   |      |\n+   |      lifetime `'a` defined here\n+...\n+LL |     a(x, y, z);\n+   |     ^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+error: higher-ranked subtype error\n+  --> $DIR/region-multiple-lifetime-bounds-on-fns-where-clause.rs:22:12\n    |\n LL |     let _: fn(&mut &isize, &mut &isize, &mut &isize) = a;\n-   |            -----------------------------------------   ^ expected concrete lifetime, found bound lifetime parameter\n-   |            |\n-   |            expected due to this\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/region-multiple-lifetime-bounds-on-fns-where-clause.rs:22:12\n    |\n-   = note: expected fn pointer `for<'r, 's, 't0, 't1, 't2, 't3> fn(&'r mut &'s isize, &'t0 mut &'t1 isize, &'t2 mut &'t3 isize)`\n-                 found fn item `for<'r, 's, 't0> fn(&'r mut &isize, &'s mut &isize, &'t0 mut &isize) {a::<'_, '_, '_>}`\n+LL |     let _: fn(&mut &isize, &mut &isize, &mut &isize) = a;\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/region-multiple-lifetime-bounds-on-fns-where-clause.rs:22:12\n+   |\n+LL |     let _: fn(&mut &isize, &mut &isize, &mut &isize) = a;\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "c93f2890f1110082975608d909ee967f41d4c44b", "filename": "src/test/ui/regions/region-multiple-lifetime-bounds-on-fns-where-clause.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -31,12 +31,10 @@ error[E0308]: mismatched types\n   --> $DIR/region-multiple-lifetime-bounds-on-fns-where-clause.rs:22:56\n    |\n LL |     let _: fn(&mut &isize, &mut &isize, &mut &isize) = a;\n-   |            -----------------------------------------   ^ expected concrete lifetime, found bound lifetime parameter\n-   |            |\n-   |            expected due to this\n+   |                                                        ^ one type is more general than the other\n    |\n    = note: expected fn pointer `for<'r, 's, 't0, 't1, 't2, 't3> fn(&'r mut &'s isize, &'t0 mut &'t1 isize, &'t2 mut &'t3 isize)`\n-                 found fn item `for<'r, 's, 't0> fn(&'r mut &isize, &'s mut &isize, &'t0 mut &isize) {a::<'_, '_, '_>}`\n+              found fn pointer `for<'r, 's, 't0> fn(&'r mut &isize, &'s mut &isize, &'t0 mut &isize)`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "de14d5ba82a1b7dfc10348ceafbfb012c771034e", "filename": "src/test/ui/regions/regions-fn-subtyping-return-static.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -5,6 +5,8 @@\n // *ANY* lifetime and returns a reference with the 'static lifetime.\n // This can safely be considered to be an instance of `F` because all\n // lifetimes are sublifetimes of 'static.\n+//\n+// check-pass\n \n #![allow(dead_code)]\n #![allow(unused_variables)]\n@@ -14,19 +16,19 @@ struct S;\n \n // Given 'cx, return 'cx\n type F = for<'cx> fn(&'cx S) -> &'cx S;\n-fn want_F(f: F) { }\n+fn want_F(f: F) {}\n \n // Given anything, return 'static\n type G = for<'cx> fn(&'cx S) -> &'static S;\n-fn want_G(f: G) { }\n+fn want_G(f: G) {}\n \n // Should meet both.\n fn foo(x: &S) -> &'static S {\n     panic!()\n }\n \n // Should meet both.\n-fn bar<'a,'b>(x: &'a S) -> &'b S {\n+fn bar<'a, 'b>(x: &'a S) -> &'b S {\n     panic!()\n }\n \n@@ -38,10 +40,9 @@ fn baz(x: &S) -> &S {\n fn supply_F() {\n     want_F(foo);\n \n-    want_F(bar); //~ ERROR mismatched types\n+    want_F(bar);\n \n     want_F(baz);\n }\n \n-pub fn main() {\n-}\n+pub fn main() {}"}, {"sha": "a8a7e97e6acf66a11660662851060962ff03557b", "filename": "src/test/ui/regions/regions-fn-subtyping-return-static.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b1c08c68ccc2c222f84384c836b5e167e2bc241/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b1c08c68ccc2c222f84384c836b5e167e2bc241/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.stderr?ref=3b1c08c68ccc2c222f84384c836b5e167e2bc241", "patch": "@@ -1,12 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/regions-fn-subtyping-return-static.rs:41:12\n-   |\n-LL |     want_F(bar);\n-   |            ^^^ expected concrete lifetime, found bound lifetime parameter 'cx\n-   |\n-   = note: expected fn pointer `for<'cx> fn(&'cx S) -> &'cx S`\n-                 found fn item `for<'a> fn(&'a S) -> &S {bar::<'_>}`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "37f7fcf2e331a882e5a4e2594f7c14a5d1454f50", "filename": "src/test/ui/regions/regions-lifetime-bounds-on-fns.nll.stderr", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,14 +1,40 @@\n-error[E0308]: mismatched types\n-  --> $DIR/regions-lifetime-bounds-on-fns.rs:20:43\n+error: lifetime may not live long enough\n+  --> $DIR/regions-lifetime-bounds-on-fns.rs:8:5\n+   |\n+LL | fn b<'a, 'b>(x: &mut &'a isize, y: &mut &'b isize) {\n+   |      --  -- lifetime `'b` defined here\n+   |      |\n+   |      lifetime `'a` defined here\n+LL |     // Illegal now because there is no `'b:'a` declaration.\n+LL |     *x = *y;\n+   |     ^^^^^^^ assignment requires that `'b` must outlive `'a`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/regions-lifetime-bounds-on-fns.rs:14:5\n+   |\n+LL | fn c<'a,'b>(x: &mut &'a isize, y: &mut &'b isize) {\n+   |      -- -- lifetime `'b` defined here\n+   |      |\n+   |      lifetime `'a` defined here\n+...\n+LL |     a(x, y);\n+   |     ^^^^^^^ argument requires that `'b` must outlive `'a`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+error: higher-ranked subtype error\n+  --> $DIR/regions-lifetime-bounds-on-fns.rs:20:12\n    |\n LL |     let _: fn(&mut &isize, &mut &isize) = a;\n-   |            ----------------------------   ^ expected concrete lifetime, found bound lifetime parameter\n-   |            |\n-   |            expected due to this\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/regions-lifetime-bounds-on-fns.rs:20:12\n    |\n-   = note: expected fn pointer `for<'r, 's, 't0, 't1> fn(&'r mut &'s isize, &'t0 mut &'t1 isize)`\n-                 found fn item `for<'r, 's> fn(&'r mut &isize, &'s mut &isize) {a::<'_, '_>}`\n+LL |     let _: fn(&mut &isize, &mut &isize) = a;\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "2b2dd0dbbf2509ed209d24e1cf3963003fab6aed", "filename": "src/test/ui/regions/regions-lifetime-bounds-on-fns.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -20,12 +20,10 @@ error[E0308]: mismatched types\n   --> $DIR/regions-lifetime-bounds-on-fns.rs:20:43\n    |\n LL |     let _: fn(&mut &isize, &mut &isize) = a;\n-   |            ----------------------------   ^ expected concrete lifetime, found bound lifetime parameter\n-   |            |\n-   |            expected due to this\n+   |                                           ^ one type is more general than the other\n    |\n    = note: expected fn pointer `for<'r, 's, 't0, 't1> fn(&'r mut &'s isize, &'t0 mut &'t1 isize)`\n-                 found fn item `for<'r, 's> fn(&'r mut &isize, &'s mut &isize) {a::<'_, '_>}`\n+              found fn pointer `for<'r, 's> fn(&'r mut &isize, &'s mut &isize)`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "848d4fef1abfc16e0a16fc2ae5f9137d9110b012", "filename": "src/test/ui/rfc1623.nll.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Frfc1623.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Frfc1623.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1623.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,68 @@\n+error[E0277]: `dyn for<'a, 'b> std::ops::Fn(&'a Foo<'b>) -> &'a Foo<'b>` cannot be shared between threads safely\n+  --> $DIR/rfc1623.rs:21:1\n+   |\n+LL | / static SOME_STRUCT: &SomeStruct = &SomeStruct {\n+LL | |     foo: &Foo { bools: &[false, true] },\n+LL | |     bar: &Bar { bools: &[true, true] },\n+LL | |     f: &id,\n+LL | |\n+LL | | };\n+   | |__^ `dyn for<'a, 'b> std::ops::Fn(&'a Foo<'b>) -> &'a Foo<'b>` cannot be shared between threads safely\n+   |\n+   = help: within `&SomeStruct`, the trait `std::marker::Sync` is not implemented for `dyn for<'a, 'b> std::ops::Fn(&'a Foo<'b>) -> &'a Foo<'b>`\n+   = note: required because it appears within the type `&dyn for<'a, 'b> std::ops::Fn(&'a Foo<'b>) -> &'a Foo<'b>`\n+   = note: required because it appears within the type `SomeStruct`\n+   = note: required because it appears within the type `&SomeStruct`\n+   = note: shared static variables must have a type that implements `Sync`\n+\n+error: higher-ranked subtype error\n+  --> $DIR/rfc1623.rs:21:35\n+   |\n+LL |   static SOME_STRUCT: &SomeStruct = &SomeStruct {\n+   |  ___________________________________^\n+LL | |     foo: &Foo { bools: &[false, true] },\n+LL | |     bar: &Bar { bools: &[true, true] },\n+LL | |     f: &id,\n+LL | |\n+LL | | };\n+   | |_^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/rfc1623.rs:21:35\n+   |\n+LL |   static SOME_STRUCT: &SomeStruct = &SomeStruct {\n+   |  ___________________________________^\n+LL | |     foo: &Foo { bools: &[false, true] },\n+LL | |     bar: &Bar { bools: &[true, true] },\n+LL | |     f: &id,\n+LL | |\n+LL | | };\n+   | |_^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/rfc1623.rs:21:35\n+   |\n+LL |   static SOME_STRUCT: &SomeStruct = &SomeStruct {\n+   |  ___________________________________^\n+LL | |     foo: &Foo { bools: &[false, true] },\n+LL | |     bar: &Bar { bools: &[true, true] },\n+LL | |     f: &id,\n+LL | |\n+LL | | };\n+   | |_^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/rfc1623.rs:21:35\n+   |\n+LL |   static SOME_STRUCT: &SomeStruct = &SomeStruct {\n+   |  ___________________________________^\n+LL | |     foo: &Foo { bools: &[false, true] },\n+LL | |     bar: &Bar { bools: &[true, true] },\n+LL | |     f: &id,\n+LL | |\n+LL | | };\n+   | |_^\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "aa6b1c0012c933f6be3931067e83f445a7fde682", "filename": "src/test/ui/rfc1623.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Frfc1623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Frfc1623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1623.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -8,23 +8,21 @@ fn non_elidable<'a, 'b>(a: &'a u8, b: &'b u8) -> &'a u8 {\n static NON_ELIDABLE_FN: &for<'a> fn(&'a u8, &'a u8) -> &'a u8 =\n     &(non_elidable as for<'a> fn(&'a u8, &'a u8) -> &'a u8);\n \n-\n struct SomeStruct<'x, 'y, 'z: 'x> {\n     foo: &'x Foo<'z>,\n     bar: &'x Bar<'z>,\n-    f: &'y dyn for<'a, 'b> Fn(&'a Foo<'b>) -> &'a Bar<'b>,\n+    f: &'y dyn for<'a, 'b> Fn(&'a Foo<'b>) -> &'a Foo<'b>,\n }\n \n fn id<T>(t: T) -> T {\n     t\n }\n \n-static SOME_STRUCT: &SomeStruct = SomeStruct { //~ ERROR mismatched types\n+static SOME_STRUCT: &SomeStruct = &SomeStruct {\n     foo: &Foo { bools: &[false, true] },\n     bar: &Bar { bools: &[true, true] },\n     f: &id,\n-    //~^ ERROR type mismatch in function arguments\n-    //~| ERROR type mismatch resolving\n+    //~^ ERROR mismatched types\n };\n \n // very simple test for a 'static static with default lifetime"}, {"sha": "2efc58ac3819c52010f89a77e2e88f4854e9607b", "filename": "src/test/ui/rfc1623.stderr", "status": "modified", "additions": 6, "deletions": 40, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Frfc1623.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Frfc1623.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1623.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,46 +1,12 @@\n error[E0308]: mismatched types\n-  --> $DIR/rfc1623.rs:22:35\n-   |\n-LL |   static SOME_STRUCT: &SomeStruct = SomeStruct {\n-   |  ___________________________________^\n-LL | |     foo: &Foo { bools: &[false, true] },\n-LL | |     bar: &Bar { bools: &[true, true] },\n-LL | |     f: &id,\n-LL | |\n-LL | |\n-LL | | };\n-   | |_^ expected `&SomeStruct<'static, 'static, 'static>`, found struct `SomeStruct`\n-   |\n-help: consider borrowing here\n-   |\n-LL | static SOME_STRUCT: &SomeStruct = &SomeStruct {\n-LL |     foo: &Foo { bools: &[false, true] },\n-LL |     bar: &Bar { bools: &[true, true] },\n-LL |     f: &id,\n-LL |\n-LL |\n- ...\n-\n-error[E0631]: type mismatch in function arguments\n-  --> $DIR/rfc1623.rs:25:8\n-   |\n-LL | fn id<T>(t: T) -> T {\n-   | ------------------- found signature of `fn(_) -> _`\n-...\n-LL |     f: &id,\n-   |        ^^^ expected signature of `for<'a, 'b> fn(&'a Foo<'b>) -> _`\n-   |\n-   = note: required for the cast to the object type `dyn for<'a, 'b> std::ops::Fn(&'a Foo<'b>) -> &'a Foo<'b>`\n-\n-error[E0271]: type mismatch resolving `for<'a, 'b> <fn(_) -> _ {id::<_>} as std::ops::FnOnce<(&'a Foo<'b>,)>>::Output == &'a Foo<'b>`\n-  --> $DIR/rfc1623.rs:25:8\n+  --> $DIR/rfc1623.rs:24:8\n    |\n LL |     f: &id,\n-   |        ^^^ expected bound lifetime parameter 'a, found concrete lifetime\n+   |        ^^^ one type is more general than the other\n    |\n-   = note: required for the cast to the object type `dyn for<'a, 'b> std::ops::Fn(&'a Foo<'b>) -> &'a Foo<'b>`\n+   = note: expected type `std::ops::FnOnce<(&'a Foo<'b>,)>`\n+              found type `std::ops::FnOnce<(&Foo<'_>,)>`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0271, E0308, E0631.\n-For more information about an error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "f2fbb0ba7d7556738dd6951afe48ea920e2553d7", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -6,6 +6,11 @@ LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n    |                |     |\n    |                |     this data with an anonymous lifetime `'_`...\n    |                ...is captured here...\n+   |\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |\n+LL |     async fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n+   |                                                ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "29d1b000943211902f8973e1aee5c19a4da506da", "filename": "src/test/ui/span/E0493.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fspan%2FE0493.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fspan%2FE0493.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0493.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -2,7 +2,9 @@ error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/E0493.rs:17:17\n    |\n LL | const F : Foo = (Foo { a : 0 }, Foo { a : 1 }).1;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constants cannot evaluate destructors\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ - value is dropped here\n+   |                 |\n+   |                 constants cannot evaluate destructors\n \n error: aborting due to previous error\n "}, {"sha": "ed81734f6ebd7cd981f0d8d968f47044ed3ccab7", "filename": "src/test/ui/static/static-drop-scope.stderr", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -2,7 +2,9 @@ error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/static-drop-scope.rs:9:60\n    |\n LL | static PROMOTION_FAIL_S: Option<&'static WithDtor> = Some(&WithDtor);\n-   |                                                            ^^^^^^^^ statics cannot evaluate destructors\n+   |                                                            ^^^^^^^^- value is dropped here\n+   |                                                            |\n+   |                                                            statics cannot evaluate destructors\n \n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/static-drop-scope.rs:9:60\n@@ -18,7 +20,9 @@ error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/static-drop-scope.rs:13:59\n    |\n LL | const PROMOTION_FAIL_C: Option<&'static WithDtor> = Some(&WithDtor);\n-   |                                                           ^^^^^^^^ constants cannot evaluate destructors\n+   |                                                           ^^^^^^^^- value is dropped here\n+   |                                                           |\n+   |                                                           constants cannot evaluate destructors\n \n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/static-drop-scope.rs:13:59\n@@ -34,37 +38,50 @@ error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/static-drop-scope.rs:17:28\n    |\n LL | static EARLY_DROP_S: i32 = (WithDtor, 0).1;\n-   |                            ^^^^^^^^^^^^^ statics cannot evaluate destructors\n+   |                            ^^^^^^^^^^^^^ - value is dropped here\n+   |                            |\n+   |                            statics cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/static-drop-scope.rs:20:27\n    |\n LL | const EARLY_DROP_C: i32 = (WithDtor, 0).1;\n-   |                           ^^^^^^^^^^^^^ constants cannot evaluate destructors\n+   |                           ^^^^^^^^^^^^^ - value is dropped here\n+   |                           |\n+   |                           constants cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/static-drop-scope.rs:23:24\n    |\n LL | const fn const_drop<T>(_: T) {}\n-   |                        ^ constant functions cannot evaluate destructors\n+   |                        ^      - value is dropped here\n+   |                        |\n+   |                        constant functions cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/static-drop-scope.rs:27:5\n    |\n LL |     (x, ()).1\n    |     ^^^^^^^ constant functions cannot evaluate destructors\n+LL |\n+LL | }\n+   | - value is dropped here\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/static-drop-scope.rs:31:34\n    |\n LL | const EARLY_DROP_C_OPTION: i32 = (Some(WithDtor), 0).1;\n-   |                                  ^^^^^^^^^^^^^^^^^^^ constants cannot evaluate destructors\n+   |                                  ^^^^^^^^^^^^^^^^^^^ - value is dropped here\n+   |                                  |\n+   |                                  constants cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/static-drop-scope.rs:36:43\n    |\n LL | const EARLY_DROP_C_OPTION_CONSTANT: i32 = (HELPER, 0).1;\n-   |                                           ^^^^^^^^^^^ constants cannot evaluate destructors\n+   |                                           ^^^^^^^^^^^ - value is dropped here\n+   |                                           |\n+   |                                           constants cannot evaluate destructors\n \n error: aborting due to 10 previous errors\n "}, {"sha": "2407d13714a2ad555938006713e07684149f71c7", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.nll.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,53 @@\n+error: lifetime may not live long enough\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:27:23\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |             -         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n+   |             |\n+   |             let's call the lifetime of this reference `'1`\n+   |\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a bound\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: lifetime may not live long enough\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:39:9\n+   |\n+LL |       fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+   |               - let's call the lifetime of this reference `'1`\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________^ returning this value requires that `'1` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:50:9\n+   |\n+LL |       fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+   |               -- lifetime `'a` defined here\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________^ returning this value requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:60:30\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |             --               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'a` must outlive `'static`\n+   |             |\n+   |             lifetime `'a` defined here\n+   |\n+   = help: consider replacing `'a` with `'static`\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'a`, add `'a` as a bound\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "f78edb1c83a4c97e549713f99975b073b9b30144", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,68 @@\n+trait Foo {}\n+impl<'a, T: Foo> Foo for &'a T {}\n+impl<T: Foo + ?Sized> Foo for Box<T> {}\n+\n+struct Iter<'a, T> {\n+    current: Option<Box<dyn Foo + 'a>>,\n+    remaining: T,\n+}\n+\n+impl<'a, T> Iterator for Iter<'a, T>\n+where\n+    T: Iterator,\n+    T::Item: Foo + 'a,\n+{\n+    type Item = Box<dyn Foo + 'a>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let result = self.current.take();\n+        self.current = Box::new(self.remaining.next()).map(|f| Box::new(f) as _);\n+        result\n+    }\n+}\n+\n+struct Bar(Vec<Box<dyn Foo>>);\n+\n+impl Bar {\n+    fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n+        Iter {\n+            current: None,\n+            remaining: self.0.iter(), //~ ERROR cannot infer an appropriate lifetime\n+        }\n+    }\n+}\n+\n+struct Baz(Vec<Box<dyn Foo>>);\n+\n+impl Baz {\n+    fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+        Iter {\n+            current: None,\n+            remaining: self.0.iter(), //~ ERROR cannot infer an appropriate lifetime\n+        }\n+    }\n+}\n+\n+struct Bat(Vec<Box<dyn Foo>>);\n+\n+impl Bat {\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+        Iter {\n+            current: None,\n+            remaining: self.0.iter(), //~ ERROR cannot infer an appropriate lifetime\n+        }\n+    }\n+}\n+\n+struct Ban(Vec<Box<dyn Foo>>);\n+\n+impl Ban {\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n+        Iter {\n+            current: None,\n+            remaining: self.0.iter(), //~ ERROR cannot infer an appropriate lifetime\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1257e9b172cf71ac9e4458f81fe212e6eb0d2744", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.stderr", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,95 @@\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:30:31\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |             ----- this data with an anonymous lifetime `'_`...\n+...\n+LL |             remaining: self.0.iter(),\n+   |                        ------ ^^^^\n+   |                        |\n+   |                        ...is captured here...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:27:23\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+   |                                                          ^^^^\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo + '_>> {\n+   |                                                        ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:41:31\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+   |             ----- this data with an anonymous lifetime `'_`...\n+...\n+LL |             remaining: self.0.iter(),\n+   |                        ------ ^^^^\n+   |                        |\n+   |                        ...is captured here...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:38:23\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo + '_>> + '_ {\n+   |                                                        ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:52:31\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+   |                 -------- this data with lifetime `'a`...\n+...\n+LL |             remaining: self.0.iter(),\n+   |                        ------ ^^^^\n+   |                        |\n+   |                        ...is captured here...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:49:30\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'a` lifetime bound\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo + 'a>> + 'a {\n+   |                                                               ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:63:31\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |                 -------- this data with lifetime `'a`...\n+...\n+LL |             remaining: self.0.iter(),\n+   |                        ------ ^^^^\n+   |                        |\n+   |                        ...is captured here...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:60:30\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'a` lifetime bound\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+   |                                                                 ^^^^\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'a` lifetime bound\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo + 'a>> {\n+   |                                                               ^^^^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "3c2226574ee9e7ca42f3c6dbf06caf77d6267e1b", "filename": "src/test/ui/suggestions/suggest-move-types.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -125,6 +125,7 @@ LL | struct Cl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), C=()\n    |                                                        ^^\n    |\n    = note: lifetime arguments must be provided before type arguments\n+   = help: reorder the arguments: lifetimes, then types: `<'a, 'b, 'c, T, U, V>`\n \n error[E0747]: lifetime provided when a type was expected\n   --> $DIR/suggest-move-types.rs:82:56\n@@ -133,6 +134,7 @@ LL | struct Dl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), U, '\n    |                                                        ^^\n    |\n    = note: lifetime arguments must be provided before type arguments\n+   = help: reorder the arguments: lifetimes, then types: `<'a, 'b, 'c, T, U, V>`\n \n error: aborting due to 12 previous errors\n "}, {"sha": "8c9cb742fac91f12814c64af1ed4806180b25a04", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,14 @@\n+error: higher-ranked subtype error\n+  --> $DIR/issue-57611-trait-alias.rs:21:9\n+   |\n+LL |         |x| x\n+   |         ^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/issue-57611-trait-alias.rs:21:9\n+   |\n+LL |         |x| x\n+   |         ^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "41e019247c9426c5edbfcd33cf7ac84390a7da24", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -14,8 +14,8 @@ trait Foo {\n struct X;\n \n impl Foo for X {\n-    type Bar = impl Baz<Self, Self>; //~ ERROR type mismatch in closure arguments\n-    //~^ ERROR type mismatch resolving\n+    type Bar = impl Baz<Self, Self>;\n+    //~^ ERROR mismatched types\n \n     fn bar(&self) -> Self::Bar {\n         |x| x"}, {"sha": "cd637056c94add66003e178a0a50eeb2ac962b44", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.stderr", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,23 +1,12 @@\n-error[E0631]: type mismatch in closure arguments\n+error[E0308]: mismatched types\n   --> $DIR/issue-57611-trait-alias.rs:17:16\n    |\n LL |     type Bar = impl Baz<Self, Self>;\n-   |                ^^^^^^^^^^^^^^^^^^^^ expected signature of `for<'r> fn(&'r X) -> _`\n-...\n-LL |         |x| x\n-   |         ----- found signature of `fn(_) -> _`\n+   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n    |\n-   = note: the return type of a function must have a statically known size\n+   = note: expected type `std::ops::FnOnce<(&X,)>`\n+              found type `std::ops::FnOnce<(&X,)>`\n \n-error[E0271]: type mismatch resolving `for<'r> <[closure@$DIR/issue-57611-trait-alias.rs:21:9: 21:14] as std::ops::FnOnce<(&'r X,)>>::Output == &'r X`\n-  --> $DIR/issue-57611-trait-alias.rs:17:16\n-   |\n-LL |     type Bar = impl Baz<Self, Self>;\n-   |                ^^^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter, found concrete lifetime\n-   |\n-   = note: the return type of a function must have a statically known size\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0271, E0631.\n-For more information about an error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e2082d4f78e7026bac85bd273ee34027880b416b", "filename": "src/test/ui/unboxed-closures/unboxed-closures-unsafe-extern-fn.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-unsafe-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-unsafe-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-unsafe-extern-fn.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,28 +1,34 @@\n // Tests that unsafe extern fn pointers do not implement any Fn traits.\n \n-use std::ops::{Fn,FnMut,FnOnce};\n+use std::ops::{Fn, FnMut, FnOnce};\n \n-unsafe fn square(x: &isize) -> isize { (*x) * (*x) }\n+unsafe fn square(x: &isize) -> isize {\n+    (*x) * (*x)\n+}\n \n-fn call_it<F:Fn(&isize)->isize>(_: &F, _: isize) -> isize { 0 }\n-fn call_it_mut<F:FnMut(&isize)->isize>(_: &mut F, _: isize) -> isize { 0 }\n-fn call_it_once<F:FnOnce(&isize)->isize>(_: F, _: isize) -> isize { 0 }\n+fn call_it<F: Fn(&isize) -> isize>(_: &F, _: isize) -> isize {\n+    0\n+}\n+fn call_it_mut<F: FnMut(&isize) -> isize>(_: &mut F, _: isize) -> isize {\n+    0\n+}\n+fn call_it_once<F: FnOnce(&isize) -> isize>(_: F, _: isize) -> isize {\n+    0\n+}\n \n fn a() {\n     let x = call_it(&square, 22);\n     //~^ ERROR E0277\n-    //~| ERROR expected\n }\n \n fn b() {\n     let y = call_it_mut(&mut square, 22);\n     //~^ ERROR E0277\n-    //~| ERROR expected\n }\n \n fn c() {\n     let z = call_it_once(square, 22);\n     //~^ ERROR E0277\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "b06f745e7c1f184f56a096ddd3272d0cd12e527d", "filename": "src/test/ui/unboxed-closures/unboxed-closures-unsafe-extern-fn.stderr", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-unsafe-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-unsafe-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-unsafe-extern-fn.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,58 +1,36 @@\n error[E0277]: expected a `std::ops::Fn<(&isize,)>` closure, found `for<'r> unsafe fn(&'r isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-unsafe-extern-fn.rs:12:21\n+  --> $DIR/unboxed-closures-unsafe-extern-fn.rs:20:21\n    |\n-LL | fn call_it<F:Fn(&isize)->isize>(_: &F, _: isize) -> isize { 0 }\n-   |              ----------------- required by this bound in `call_it`\n+LL | fn call_it<F: Fn(&isize) -> isize>(_: &F, _: isize) -> isize {\n+   |               ------------------- required by this bound in `call_it`\n ...\n LL |     let x = call_it(&square, 22);\n    |                     ^^^^^^^ expected an `Fn<(&isize,)>` closure, found `for<'r> unsafe fn(&'r isize) -> isize {square}`\n    |\n    = help: the trait `for<'r> std::ops::Fn<(&'r isize,)>` is not implemented for `for<'r> unsafe fn(&'r isize) -> isize {square}`\n \n-error[E0277]: expected a `std::ops::FnOnce<(&isize,)>` closure, found `for<'r> unsafe fn(&'r isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-unsafe-extern-fn.rs:12:21\n-   |\n-LL | fn call_it<F:Fn(&isize)->isize>(_: &F, _: isize) -> isize { 0 }\n-   |                          ----- required by this bound in `call_it`\n-...\n-LL |     let x = call_it(&square, 22);\n-   |                     ^^^^^^^ expected an `FnOnce<(&isize,)>` closure, found `for<'r> unsafe fn(&'r isize) -> isize {square}`\n-   |\n-   = help: the trait `std::ops::FnOnce<(&isize,)>` is not implemented for `for<'r> unsafe fn(&'r isize) -> isize {square}`\n-\n error[E0277]: expected a `std::ops::FnMut<(&isize,)>` closure, found `for<'r> unsafe fn(&'r isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-unsafe-extern-fn.rs:18:25\n+  --> $DIR/unboxed-closures-unsafe-extern-fn.rs:25:25\n    |\n-LL | fn call_it_mut<F:FnMut(&isize)->isize>(_: &mut F, _: isize) -> isize { 0 }\n-   |                  -------------------- required by this bound in `call_it_mut`\n+LL | fn call_it_mut<F: FnMut(&isize) -> isize>(_: &mut F, _: isize) -> isize {\n+   |                   ---------------------- required by this bound in `call_it_mut`\n ...\n LL |     let y = call_it_mut(&mut square, 22);\n    |                         ^^^^^^^^^^^ expected an `FnMut<(&isize,)>` closure, found `for<'r> unsafe fn(&'r isize) -> isize {square}`\n    |\n    = help: the trait `for<'r> std::ops::FnMut<(&'r isize,)>` is not implemented for `for<'r> unsafe fn(&'r isize) -> isize {square}`\n \n error[E0277]: expected a `std::ops::FnOnce<(&isize,)>` closure, found `for<'r> unsafe fn(&'r isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-unsafe-extern-fn.rs:18:25\n-   |\n-LL | fn call_it_mut<F:FnMut(&isize)->isize>(_: &mut F, _: isize) -> isize { 0 }\n-   |                                 ----- required by this bound in `call_it_mut`\n-...\n-LL |     let y = call_it_mut(&mut square, 22);\n-   |                         ^^^^^^^^^^^ expected an `FnOnce<(&isize,)>` closure, found `for<'r> unsafe fn(&'r isize) -> isize {square}`\n-   |\n-   = help: the trait `std::ops::FnOnce<(&isize,)>` is not implemented for `for<'r> unsafe fn(&'r isize) -> isize {square}`\n-\n-error[E0277]: expected a `std::ops::FnOnce<(&isize,)>` closure, found `for<'r> unsafe fn(&'r isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-unsafe-extern-fn.rs:24:26\n+  --> $DIR/unboxed-closures-unsafe-extern-fn.rs:30:26\n    |\n-LL | fn call_it_once<F:FnOnce(&isize)->isize>(_: F, _: isize) -> isize { 0 }\n-   |                                   ----- required by this bound in `call_it_once`\n+LL | fn call_it_once<F: FnOnce(&isize) -> isize>(_: F, _: isize) -> isize {\n+   |                    ----------------------- required by this bound in `call_it_once`\n ...\n LL |     let z = call_it_once(square, 22);\n    |                          ^^^^^^ expected an `FnOnce<(&isize,)>` closure, found `for<'r> unsafe fn(&'r isize) -> isize {square}`\n    |\n-   = help: the trait `std::ops::FnOnce<(&isize,)>` is not implemented for `for<'r> unsafe fn(&'r isize) -> isize {square}`\n+   = help: the trait `for<'r> std::ops::FnOnce<(&'r isize,)>` is not implemented for `for<'r> unsafe fn(&'r isize) -> isize {square}`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "dd76c597d28ad1f461d31858fcdcd66cf5daded3", "filename": "src/test/ui/unboxed-closures/unboxed-closures-wrong-abi.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-wrong-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-wrong-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-wrong-abi.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,28 +1,34 @@\n // Tests that unsafe extern fn pointers do not implement any Fn traits.\n \n-use std::ops::{Fn,FnMut,FnOnce};\n+use std::ops::{Fn, FnMut, FnOnce};\n \n-extern \"C\" fn square(x: &isize) -> isize { (*x) * (*x) }\n+extern \"C\" fn square(x: &isize) -> isize {\n+    (*x) * (*x)\n+}\n \n-fn call_it<F:Fn(&isize)->isize>(_: &F, _: isize) -> isize { 0 }\n-fn call_it_mut<F:FnMut(&isize)->isize>(_: &mut F, _: isize) -> isize { 0 }\n-fn call_it_once<F:FnOnce(&isize)->isize>(_: F, _: isize) -> isize { 0 }\n+fn call_it<F: Fn(&isize) -> isize>(_: &F, _: isize) -> isize {\n+    0\n+}\n+fn call_it_mut<F: FnMut(&isize) -> isize>(_: &mut F, _: isize) -> isize {\n+    0\n+}\n+fn call_it_once<F: FnOnce(&isize) -> isize>(_: F, _: isize) -> isize {\n+    0\n+}\n \n fn a() {\n     let x = call_it(&square, 22);\n     //~^ ERROR E0277\n-    //~| ERROR expected\n }\n \n fn b() {\n     let y = call_it_mut(&mut square, 22);\n     //~^ ERROR E0277\n-    //~| ERROR expected\n }\n \n fn c() {\n     let z = call_it_once(square, 22);\n     //~^ ERROR E0277\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "8f6945cda806c69aa4956039d634ab20f58cd820", "filename": "src/test/ui/unboxed-closures/unboxed-closures-wrong-abi.stderr", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-wrong-abi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-wrong-abi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-wrong-abi.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,58 +1,36 @@\n error[E0277]: expected a `std::ops::Fn<(&isize,)>` closure, found `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-wrong-abi.rs:12:21\n+  --> $DIR/unboxed-closures-wrong-abi.rs:20:21\n    |\n-LL | fn call_it<F:Fn(&isize)->isize>(_: &F, _: isize) -> isize { 0 }\n-   |              ----------------- required by this bound in `call_it`\n+LL | fn call_it<F: Fn(&isize) -> isize>(_: &F, _: isize) -> isize {\n+   |               ------------------- required by this bound in `call_it`\n ...\n LL |     let x = call_it(&square, 22);\n    |                     ^^^^^^^ expected an `Fn<(&isize,)>` closure, found `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n    |\n    = help: the trait `for<'r> std::ops::Fn<(&'r isize,)>` is not implemented for `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n \n-error[E0277]: expected a `std::ops::FnOnce<(&isize,)>` closure, found `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-wrong-abi.rs:12:21\n-   |\n-LL | fn call_it<F:Fn(&isize)->isize>(_: &F, _: isize) -> isize { 0 }\n-   |                          ----- required by this bound in `call_it`\n-...\n-LL |     let x = call_it(&square, 22);\n-   |                     ^^^^^^^ expected an `FnOnce<(&isize,)>` closure, found `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n-   |\n-   = help: the trait `std::ops::FnOnce<(&isize,)>` is not implemented for `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n-\n error[E0277]: expected a `std::ops::FnMut<(&isize,)>` closure, found `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-wrong-abi.rs:18:25\n+  --> $DIR/unboxed-closures-wrong-abi.rs:25:25\n    |\n-LL | fn call_it_mut<F:FnMut(&isize)->isize>(_: &mut F, _: isize) -> isize { 0 }\n-   |                  -------------------- required by this bound in `call_it_mut`\n+LL | fn call_it_mut<F: FnMut(&isize) -> isize>(_: &mut F, _: isize) -> isize {\n+   |                   ---------------------- required by this bound in `call_it_mut`\n ...\n LL |     let y = call_it_mut(&mut square, 22);\n    |                         ^^^^^^^^^^^ expected an `FnMut<(&isize,)>` closure, found `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n    |\n    = help: the trait `for<'r> std::ops::FnMut<(&'r isize,)>` is not implemented for `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n \n error[E0277]: expected a `std::ops::FnOnce<(&isize,)>` closure, found `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-wrong-abi.rs:18:25\n-   |\n-LL | fn call_it_mut<F:FnMut(&isize)->isize>(_: &mut F, _: isize) -> isize { 0 }\n-   |                                 ----- required by this bound in `call_it_mut`\n-...\n-LL |     let y = call_it_mut(&mut square, 22);\n-   |                         ^^^^^^^^^^^ expected an `FnOnce<(&isize,)>` closure, found `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n-   |\n-   = help: the trait `std::ops::FnOnce<(&isize,)>` is not implemented for `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n-\n-error[E0277]: expected a `std::ops::FnOnce<(&isize,)>` closure, found `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-wrong-abi.rs:24:26\n+  --> $DIR/unboxed-closures-wrong-abi.rs:30:26\n    |\n-LL | fn call_it_once<F:FnOnce(&isize)->isize>(_: F, _: isize) -> isize { 0 }\n-   |                                   ----- required by this bound in `call_it_once`\n+LL | fn call_it_once<F: FnOnce(&isize) -> isize>(_: F, _: isize) -> isize {\n+   |                    ----------------------- required by this bound in `call_it_once`\n ...\n LL |     let z = call_it_once(square, 22);\n    |                          ^^^^^^ expected an `FnOnce<(&isize,)>` closure, found `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n    |\n-   = help: the trait `std::ops::FnOnce<(&isize,)>` is not implemented for `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n+   = help: the trait `for<'r> std::ops::FnOnce<(&'r isize,)>` is not implemented for `for<'r> extern \"C\" fn(&'r isize) -> isize {square}`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "02e8b7b47ae19843a9ef1215eeb2aaf578e917f0", "filename": "src/test/ui/unboxed-closures/unboxed-closures-wrong-arg-type-extern-fn.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-wrong-arg-type-extern-fn.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,29 +1,35 @@\n // Tests that unsafe extern fn pointers do not implement any Fn traits.\n \n-use std::ops::{Fn,FnMut,FnOnce};\n+use std::ops::{Fn, FnMut, FnOnce};\n \n-unsafe fn square(x: isize) -> isize { x * x }\n+unsafe fn square(x: isize) -> isize {\n+    x * x\n+}\n // note: argument type here is `isize`, not `&isize`\n \n-fn call_it<F:Fn(&isize)->isize>(_: &F, _: isize) -> isize { 0 }\n-fn call_it_mut<F:FnMut(&isize)->isize>(_: &mut F, _: isize) -> isize { 0 }\n-fn call_it_once<F:FnOnce(&isize)->isize>(_: F, _: isize) -> isize { 0 }\n+fn call_it<F: Fn(&isize) -> isize>(_: &F, _: isize) -> isize {\n+    0\n+}\n+fn call_it_mut<F: FnMut(&isize) -> isize>(_: &mut F, _: isize) -> isize {\n+    0\n+}\n+fn call_it_once<F: FnOnce(&isize) -> isize>(_: F, _: isize) -> isize {\n+    0\n+}\n \n fn a() {\n     let x = call_it(&square, 22);\n     //~^ ERROR E0277\n-    //~| ERROR expected\n }\n \n fn b() {\n     let y = call_it_mut(&mut square, 22);\n     //~^ ERROR E0277\n-    //~| ERROR expected\n }\n \n fn c() {\n     let z = call_it_once(square, 22);\n     //~^ ERROR E0277\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "93a645b485ef0374ea65871ada6bc3a3a8b6b5ea", "filename": "src/test/ui/unboxed-closures/unboxed-closures-wrong-arg-type-extern-fn.stderr", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-wrong-arg-type-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-wrong-arg-type-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-wrong-arg-type-extern-fn.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,58 +1,36 @@\n error[E0277]: expected a `std::ops::Fn<(&isize,)>` closure, found `unsafe fn(isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-wrong-arg-type-extern-fn.rs:13:21\n+  --> $DIR/unboxed-closures-wrong-arg-type-extern-fn.rs:21:21\n    |\n-LL | fn call_it<F:Fn(&isize)->isize>(_: &F, _: isize) -> isize { 0 }\n-   |              ----------------- required by this bound in `call_it`\n+LL | fn call_it<F: Fn(&isize) -> isize>(_: &F, _: isize) -> isize {\n+   |               ------------------- required by this bound in `call_it`\n ...\n LL |     let x = call_it(&square, 22);\n    |                     ^^^^^^^ expected an `Fn<(&isize,)>` closure, found `unsafe fn(isize) -> isize {square}`\n    |\n    = help: the trait `for<'r> std::ops::Fn<(&'r isize,)>` is not implemented for `unsafe fn(isize) -> isize {square}`\n \n-error[E0277]: expected a `std::ops::FnOnce<(&isize,)>` closure, found `unsafe fn(isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-wrong-arg-type-extern-fn.rs:13:21\n-   |\n-LL | fn call_it<F:Fn(&isize)->isize>(_: &F, _: isize) -> isize { 0 }\n-   |                          ----- required by this bound in `call_it`\n-...\n-LL |     let x = call_it(&square, 22);\n-   |                     ^^^^^^^ expected an `FnOnce<(&isize,)>` closure, found `unsafe fn(isize) -> isize {square}`\n-   |\n-   = help: the trait `std::ops::FnOnce<(&isize,)>` is not implemented for `unsafe fn(isize) -> isize {square}`\n-\n error[E0277]: expected a `std::ops::FnMut<(&isize,)>` closure, found `unsafe fn(isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-wrong-arg-type-extern-fn.rs:19:25\n+  --> $DIR/unboxed-closures-wrong-arg-type-extern-fn.rs:26:25\n    |\n-LL | fn call_it_mut<F:FnMut(&isize)->isize>(_: &mut F, _: isize) -> isize { 0 }\n-   |                  -------------------- required by this bound in `call_it_mut`\n+LL | fn call_it_mut<F: FnMut(&isize) -> isize>(_: &mut F, _: isize) -> isize {\n+   |                   ---------------------- required by this bound in `call_it_mut`\n ...\n LL |     let y = call_it_mut(&mut square, 22);\n    |                         ^^^^^^^^^^^ expected an `FnMut<(&isize,)>` closure, found `unsafe fn(isize) -> isize {square}`\n    |\n    = help: the trait `for<'r> std::ops::FnMut<(&'r isize,)>` is not implemented for `unsafe fn(isize) -> isize {square}`\n \n error[E0277]: expected a `std::ops::FnOnce<(&isize,)>` closure, found `unsafe fn(isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-wrong-arg-type-extern-fn.rs:19:25\n-   |\n-LL | fn call_it_mut<F:FnMut(&isize)->isize>(_: &mut F, _: isize) -> isize { 0 }\n-   |                                 ----- required by this bound in `call_it_mut`\n-...\n-LL |     let y = call_it_mut(&mut square, 22);\n-   |                         ^^^^^^^^^^^ expected an `FnOnce<(&isize,)>` closure, found `unsafe fn(isize) -> isize {square}`\n-   |\n-   = help: the trait `std::ops::FnOnce<(&isize,)>` is not implemented for `unsafe fn(isize) -> isize {square}`\n-\n-error[E0277]: expected a `std::ops::FnOnce<(&isize,)>` closure, found `unsafe fn(isize) -> isize {square}`\n-  --> $DIR/unboxed-closures-wrong-arg-type-extern-fn.rs:25:26\n+  --> $DIR/unboxed-closures-wrong-arg-type-extern-fn.rs:31:26\n    |\n-LL | fn call_it_once<F:FnOnce(&isize)->isize>(_: F, _: isize) -> isize { 0 }\n-   |                                   ----- required by this bound in `call_it_once`\n+LL | fn call_it_once<F: FnOnce(&isize) -> isize>(_: F, _: isize) -> isize {\n+   |                    ----------------------- required by this bound in `call_it_once`\n ...\n LL |     let z = call_it_once(square, 22);\n    |                          ^^^^^^ expected an `FnOnce<(&isize,)>` closure, found `unsafe fn(isize) -> isize {square}`\n    |\n-   = help: the trait `std::ops::FnOnce<(&isize,)>` is not implemented for `unsafe fn(isize) -> isize {square}`\n+   = help: the trait `for<'r> std::ops::FnOnce<(&'r isize,)>` is not implemented for `unsafe fn(isize) -> isize {square}`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "963d892931a7503b874cb5f9cf8d373694ffc01d", "filename": "src/test/ui/unsafe/unsafe-unstable-const-fn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funsafe%2Funsafe-unstable-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funsafe%2Funsafe-unstable-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-unstable-const-fn.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,13 +1,13 @@\n #![stable(feature = \"foo\", since = \"1.33.0\")]\n #![feature(staged_api)]\n-#![feature(const_compare_raw_pointers)]\n+#![feature(const_raw_ptr_deref)]\n #![feature(const_fn)]\n \n #[stable(feature = \"foo\", since = \"1.33.0\")]\n #[rustc_const_unstable(feature = \"const_foo\", issue = \"none\")]\n-const fn unstable(a: *const i32, b: *const i32) -> bool {\n-    a == b\n-    //~^ pointer operation is unsafe\n+const fn unstable(a: *const i32, b: i32) -> bool {\n+    *a == b\n+    //~^ dereference of raw pointer is unsafe\n }\n \n fn main() {}"}, {"sha": "4642a7a5fc9f83dd3a98a981dc9d19267844a4f7", "filename": "src/test/ui/unsafe/unsafe-unstable-const-fn.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funsafe%2Funsafe-unstable-const-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Funsafe%2Funsafe-unstable-const-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-unstable-const-fn.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,10 +1,10 @@\n-error[E0133]: pointer operation is unsafe and requires unsafe function or block\n+error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n   --> $DIR/unsafe-unstable-const-fn.rs:9:5\n    |\n-LL |     a == b\n-   |     ^^^^^^ pointer operation\n+LL |     *a == b\n+   |     ^^ dereference of raw pointer\n    |\n-   = note: operations on pointers in constants\n+   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: aborting due to previous error\n "}, {"sha": "d0c476dc6ec05cbd227c6a6fdfde12661af15b3a", "filename": "src/test/ui/where-clauses/where-for-self-2.nll.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.nll.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/where-for-self-2.rs:23:5\n+   |\n+LL |     foo(&X);\n+   |     ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "37c6954fd52ee1d49c4fe7b46d2f934ab2786eb1", "filename": "src/test/ui/where-clauses/where-for-self-2.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -14,9 +14,11 @@ impl Bar for &'static u32 {\n }\n \n fn foo<T>(x: &T)\n-    where for<'a> &'a T: Bar\n-{}\n+where\n+    for<'a> &'a T: Bar,\n+{\n+}\n \n fn main() {\n-    foo(&X); //~ ERROR trait bound\n+    foo(&X); //~ ERROR implementation of `Bar` is not general enough\n }"}, {"sha": "30eb78b2da4f73d1def0a8c41f4d2a81197bb935", "filename": "src/test/ui/where-clauses/where-for-self-2.stderr", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.stderr?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -1,17 +1,16 @@\n-error[E0277]: the trait bound `for<'a> &'a _: Bar` is not satisfied\n-  --> $DIR/where-for-self-2.rs:21:5\n+error: implementation of `Bar` is not general enough\n+  --> $DIR/where-for-self-2.rs:23:5\n    |\n-LL | fn foo<T>(x: &T)\n-   |    --- required by a bound in this\n-LL |     where for<'a> &'a T: Bar\n-   |                          --- required by this bound in `foo`\n+LL | / trait Bar {\n+LL | |     fn bar(&self);\n+LL | | }\n+   | |_- trait `Bar` defined here\n ...\n-LL |     foo(&X);\n-   |     ^^^ the trait `for<'a> Bar` is not implemented for `&'a _`\n+LL |       foo(&X);\n+   |       ^^^ implementation of `Bar` is not general enough\n    |\n-   = help: the following implementations were found:\n-             <&'static u32 as Bar>\n+   = note: `Bar` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n+   = note: ...but `Bar` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "3fa637b5a696f4824b2b42d60d21ebc40eb973ef", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1557fb031b272b4c5bfcc7de5df7eddc7b36a584/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=1557fb031b272b4c5bfcc7de5df7eddc7b36a584", "patch": "@@ -444,10 +444,7 @@ fn map_lib_features(\n                         level: Status::Unstable,\n                         since: None,\n                         has_gate_test: false,\n-                        // FIXME(#57563): #57563 is now used as a common tracking issue,\n-                        // although we would like to have specific tracking issues for each\n-                        // `rustc_const_unstable` in the future.\n-                        tracking_issue: NonZeroU32::new(57563),\n+                        tracking_issue: find_attr_val(line, \"issue\").and_then(handle_issue_none),\n                     };\n                     mf(Ok((feature_name, feature)), file, i + 1);\n                     continue;"}]}