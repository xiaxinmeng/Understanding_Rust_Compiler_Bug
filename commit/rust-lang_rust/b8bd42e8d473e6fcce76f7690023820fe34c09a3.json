{"sha": "b8bd42e8d473e6fcce76f7690023820fe34c09a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YmQ0MmU4ZDQ3M2U2ZmNjZTc2Zjc2OTAwMjM4MjBmZTM0YzA5YTM=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-07-05T17:54:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-05T17:54:54Z"}, "message": "Merge pull request #234 from RalfJung/reallocate\n\nMake Reallocate & Deallocate less permissive", "tree": {"sha": "db752ecef65125ace2c3332ecf46c245ff0416ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db752ecef65125ace2c3332ecf46c245ff0416ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8bd42e8d473e6fcce76f7690023820fe34c09a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8bd42e8d473e6fcce76f7690023820fe34c09a3", "html_url": "https://github.com/rust-lang/rust/commit/b8bd42e8d473e6fcce76f7690023820fe34c09a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8bd42e8d473e6fcce76f7690023820fe34c09a3/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a04be974c359557e05a9eb4cfa40cc821664f3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a04be974c359557e05a9eb4cfa40cc821664f3b", "html_url": "https://github.com/rust-lang/rust/commit/9a04be974c359557e05a9eb4cfa40cc821664f3b"}, {"sha": "4165051073675814f09f4ef2ab5dbbb901cc10f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4165051073675814f09f4ef2ab5dbbb901cc10f4", "html_url": "https://github.com/rust-lang/rust/commit/4165051073675814f09f4ef2ab5dbbb901cc10f4"}], "stats": {"total": 281, "additions": 193, "deletions": 88}, "files": [{"sha": "46a3096930555e92a1746efd840a085b120b46f6", "filename": "src/error.rs", "status": "modified", "additions": 71, "deletions": 60, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/b8bd42e8d473e6fcce76f7690023820fe34c09a3/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bd42e8d473e6fcce76f7690023820fe34c09a3/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=b8bd42e8d473e6fcce76f7690023820fe34c09a3", "patch": "@@ -58,6 +58,9 @@ pub enum EvalError<'tcx> {\n     TypeNotPrimitive(Ty<'tcx>),\n     ReallocatedStaticMemory,\n     DeallocatedStaticMemory,\n+    ReallocateNonBasePtr,\n+    DeallocateNonBasePtr,\n+    IncorrectAllocationInformation,\n     Layout(layout::LayoutError<'tcx>),\n     HeapAllocZeroBytes,\n     HeapAllocNonPowerOfTwoAlignment(u64),\n@@ -72,98 +75,105 @@ pub type EvalResult<'tcx, T = ()> = Result<T, EvalError<'tcx>>;\n \n impl<'tcx> Error for EvalError<'tcx> {\n     fn description(&self) -> &str {\n+        use EvalError::*;\n         match *self {\n-            EvalError::FunctionPointerTyMismatch(..) =>\n+            FunctionPointerTyMismatch(..) =>\n                 \"tried to call a function through a function pointer of a different type\",\n-            EvalError::InvalidMemoryAccess =>\n+            InvalidMemoryAccess =>\n                 \"tried to access memory through an invalid pointer\",\n-            EvalError::DanglingPointerDeref =>\n+            DanglingPointerDeref =>\n                 \"dangling pointer was dereferenced\",\n-            EvalError::InvalidFunctionPointer =>\n+            InvalidFunctionPointer =>\n                 \"tried to use an integer pointer or a dangling pointer as a function pointer\",\n-            EvalError::InvalidBool =>\n+            InvalidBool =>\n                 \"invalid boolean value read\",\n-            EvalError::InvalidDiscriminant =>\n+            InvalidDiscriminant =>\n                 \"invalid enum discriminant value read\",\n-            EvalError::PointerOutOfBounds { .. } =>\n+            PointerOutOfBounds { .. } =>\n                 \"pointer offset outside bounds of allocation\",\n-            EvalError::InvalidNullPointerUsage =>\n+            InvalidNullPointerUsage =>\n                 \"invalid use of NULL pointer\",\n-            EvalError::ReadPointerAsBytes =>\n+            ReadPointerAsBytes =>\n                 \"a raw memory access tried to access part of a pointer value as raw bytes\",\n-            EvalError::ReadBytesAsPointer =>\n+            ReadBytesAsPointer =>\n                 \"a memory access tried to interpret some bytes as a pointer\",\n-            EvalError::InvalidPointerMath =>\n+            InvalidPointerMath =>\n                 \"attempted to do invalid arithmetic on pointers that would leak base addresses, e.g. comparing pointers into different allocations\",\n-            EvalError::ReadUndefBytes =>\n+            ReadUndefBytes =>\n                 \"attempted to read undefined bytes\",\n-            EvalError::DeadLocal =>\n+            DeadLocal =>\n                 \"tried to access a dead local variable\",\n-            EvalError::InvalidBoolOp(_) =>\n+            InvalidBoolOp(_) =>\n                 \"invalid boolean operation\",\n-            EvalError::Unimplemented(ref msg) => msg,\n-            EvalError::DerefFunctionPointer =>\n+            Unimplemented(ref msg) => msg,\n+            DerefFunctionPointer =>\n                 \"tried to dereference a function pointer\",\n-            EvalError::ExecuteMemory =>\n+            ExecuteMemory =>\n                 \"tried to treat a memory pointer as a function pointer\",\n-            EvalError::ArrayIndexOutOfBounds(..) =>\n+            ArrayIndexOutOfBounds(..) =>\n                 \"array index out of bounds\",\n-            EvalError::Math(..) =>\n+            Math(..) =>\n                 \"mathematical operation failed\",\n-            EvalError::Intrinsic(..) =>\n+            Intrinsic(..) =>\n                 \"intrinsic failed\",\n-            EvalError::OverflowingMath =>\n+            OverflowingMath =>\n                 \"attempted to do overflowing math\",\n-            EvalError::NoMirFor(..) =>\n+            NoMirFor(..) =>\n                 \"mir not found\",\n-            EvalError::InvalidChar(..) =>\n+            InvalidChar(..) =>\n                 \"tried to interpret an invalid 32-bit value as a char\",\n-            EvalError::OutOfMemory{..} =>\n+            OutOfMemory{..} =>\n                 \"could not allocate more memory\",\n-            EvalError::ExecutionTimeLimitReached =>\n+            ExecutionTimeLimitReached =>\n                 \"reached the configured maximum execution time\",\n-            EvalError::StackFrameLimitReached =>\n+            StackFrameLimitReached =>\n                 \"reached the configured maximum number of stack frames\",\n-            EvalError::OutOfTls =>\n+            OutOfTls =>\n                 \"reached the maximum number of representable TLS keys\",\n-            EvalError::TlsOutOfBounds =>\n+            TlsOutOfBounds =>\n                 \"accessed an invalid (unallocated) TLS key\",\n-            EvalError::AbiViolation(ref msg) => msg,\n-            EvalError::AlignmentCheckFailed{..} =>\n+            AbiViolation(ref msg) => msg,\n+            AlignmentCheckFailed{..} =>\n                 \"tried to execute a misaligned read or write\",\n-            EvalError::CalledClosureAsFunction =>\n+            CalledClosureAsFunction =>\n                 \"tried to call a closure through a function pointer\",\n-            EvalError::VtableForArgumentlessMethod =>\n+            VtableForArgumentlessMethod =>\n                 \"tried to call a vtable function without arguments\",\n-            EvalError::ModifiedConstantMemory =>\n+            ModifiedConstantMemory =>\n                 \"tried to modify constant memory\",\n-            EvalError::AssumptionNotHeld =>\n+            AssumptionNotHeld =>\n                 \"`assume` argument was false\",\n-            EvalError::InlineAsm =>\n+            InlineAsm =>\n                 \"miri does not support inline assembly\",\n-            EvalError::TypeNotPrimitive(_) =>\n+            TypeNotPrimitive(_) =>\n                 \"expected primitive type, got nonprimitive\",\n-            EvalError::ReallocatedStaticMemory =>\n+            ReallocatedStaticMemory =>\n                 \"tried to reallocate static memory\",\n-            EvalError::DeallocatedStaticMemory =>\n+            DeallocatedStaticMemory =>\n                 \"tried to deallocate static memory\",\n-            EvalError::Layout(_) =>\n+            ReallocateNonBasePtr =>\n+                \"tried to reallocate with a pointer not to the beginning of an existing object\",\n+            DeallocateNonBasePtr =>\n+                \"tried to deallocate with a pointer not to the beginning of an existing object\",\n+            IncorrectAllocationInformation =>\n+                \"tried to deallocate or reallocate using incorrect alignment or size\",\n+            Layout(_) =>\n                 \"rustc layout computation failed\",\n-            EvalError::UnterminatedCString(_) =>\n+            UnterminatedCString(_) =>\n                 \"attempted to get length of a null terminated string, but no null found before end of allocation\",\n-            EvalError::HeapAllocZeroBytes =>\n+            HeapAllocZeroBytes =>\n                 \"tried to re-, de- or allocate zero bytes on the heap\",\n-            EvalError::HeapAllocNonPowerOfTwoAlignment(_) =>\n+            HeapAllocNonPowerOfTwoAlignment(_) =>\n                 \"tried to re-, de-, or allocate heap memory with alignment that is not a power of two\",\n-            EvalError::Unreachable =>\n+            Unreachable =>\n                 \"entered unreachable code\",\n-            EvalError::Panic =>\n+            Panic =>\n                 \"the evaluated program panicked\",\n-            EvalError::NeedsRfc(_) =>\n+            NeedsRfc(_) =>\n                 \"this feature needs an rfc before being allowed inside constants\",\n-            EvalError::NotConst(_) =>\n+            NotConst(_) =>\n                 \"this feature is not compatible with constant evaluation\",\n-            EvalError::ReadFromReturnPointer =>\n+            ReadFromReturnPointer =>\n                 \"tried to read from the return pointer\",\n         }\n     }\n@@ -173,36 +183,37 @@ impl<'tcx> Error for EvalError<'tcx> {\n \n impl<'tcx> fmt::Display for EvalError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        use EvalError::*;\n         match *self {\n-            EvalError::PointerOutOfBounds { ptr, access, allocation_size } => {\n+            PointerOutOfBounds { ptr, access, allocation_size } => {\n                 write!(f, \"{} at offset {}, outside bounds of allocation {} which has size {}\",\n                        if access { \"memory access\" } else { \"pointer computed\" },\n                        ptr.offset, ptr.alloc_id, allocation_size)\n             },\n-            EvalError::NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n-            EvalError::FunctionPointerTyMismatch(sig, got) =>\n+            NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n+            FunctionPointerTyMismatch(sig, got) =>\n                 write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig, got),\n-            EvalError::ArrayIndexOutOfBounds(span, len, index) =>\n+            ArrayIndexOutOfBounds(span, len, index) =>\n                 write!(f, \"index out of bounds: the len is {} but the index is {} at {:?}\", len, index, span),\n-            EvalError::Math(span, ref err) =>\n+            Math(span, ref err) =>\n                 write!(f, \"{:?} at {:?}\", err, span),\n-            EvalError::Intrinsic(ref err) =>\n+            Intrinsic(ref err) =>\n                 write!(f, \"{}\", err),\n-            EvalError::InvalidChar(c) =>\n+            InvalidChar(c) =>\n                 write!(f, \"tried to interpret an invalid 32-bit value as a char: {}\", c),\n-            EvalError::OutOfMemory { allocation_size, memory_size, memory_usage } =>\n+            OutOfMemory { allocation_size, memory_size, memory_usage } =>\n                 write!(f, \"tried to allocate {} more bytes, but only {} bytes are free of the {} byte memory\",\n                        allocation_size, memory_size - memory_usage, memory_size),\n-            EvalError::AlignmentCheckFailed { required, has } =>\n+            AlignmentCheckFailed { required, has } =>\n                write!(f, \"tried to access memory with alignment {}, but alignment {} is required\",\n                       has, required),\n-            EvalError::TypeNotPrimitive(ty) =>\n+            TypeNotPrimitive(ty) =>\n                 write!(f, \"expected primitive type, got {}\", ty),\n-            EvalError::Layout(ref err) =>\n+            Layout(ref err) =>\n                 write!(f, \"rustc layout computation failed: {:?}\", err),\n-            EvalError::NeedsRfc(ref msg) =>\n+            NeedsRfc(ref msg) =>\n                 write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg),\n-            EvalError::NotConst(ref msg) =>\n+            NotConst(ref msg) =>\n                 write!(f, \"Cannot evaluate within constants: \\\"{}\\\"\", msg),\n             _ => write!(f, \"{}\", self.description()),\n         }"}, {"sha": "2ecc4f029e89f0b2aa8ce1772ef143159be296c9", "filename": "src/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8bd42e8d473e6fcce76f7690023820fe34c09a3/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bd42e8d473e6fcce76f7690023820fe34c09a3/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=b8bd42e8d473e6fcce76f7690023820fe34c09a3", "patch": "@@ -412,7 +412,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);\n-            match self.memory.deallocate(ptr) {\n+            match self.memory.deallocate(ptr, None) {\n                 // We could alternatively check whether the alloc_id is static before calling\n                 // deallocate, but this is much simpler and is probably the rare case.\n                 Ok(()) | Err(EvalError::DeallocatedStaticMemory) => {},\n@@ -1714,7 +1714,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n \n         while ecx.step()? {}\n         if let Some(cleanup_ptr) = cleanup_ptr {\n-            ecx.memory.deallocate(cleanup_ptr)?;\n+            ecx.memory.deallocate(cleanup_ptr, None)?;\n         }\n         return Ok(());\n     }"}, {"sha": "c638fabbe631a5c834cfadedff9bc7057530bb08", "filename": "src/memory.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b8bd42e8d473e6fcce76f7690023820fe34c09a3/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bd42e8d473e6fcce76f7690023820fe34c09a3/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=b8bd42e8d473e6fcce76f7690023820fe34c09a3", "patch": "@@ -223,58 +223,74 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n-    pub fn reallocate(&mut self, ptr: Pointer, new_size: u64, align: u64) -> EvalResult<'tcx, Pointer> {\n+    pub fn reallocate(&mut self, ptr: Pointer, old_size: u64, new_size: u64, align: u64) -> EvalResult<'tcx, Pointer> {\n         assert!(align.is_power_of_two());\n         // TODO(solson): Report error about non-__rust_allocate'd pointer.\n-        if ptr.offset != 0 {\n-            return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n+        if ptr.offset != 0 || self.get(ptr.alloc_id).is_err() {\n+            return Err(EvalError::ReallocateNonBasePtr);\n         }\n         if self.get(ptr.alloc_id).ok().map_or(false, |alloc| alloc.static_kind != StaticKind::NotStatic) {\n             return Err(EvalError::ReallocatedStaticMemory);\n         }\n \n         let size = self.get(ptr.alloc_id)?.bytes.len() as u64;\n+        let real_align = self.get(ptr.alloc_id)?.align;\n+        if size != old_size || real_align != align {\n+            return Err(EvalError::IncorrectAllocationInformation);\n+        }\n \n         if new_size > size {\n             let amount = new_size - size;\n             self.memory_usage += amount;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n-            // FIXME: check alignment here\n             assert_eq!(amount as usize as u64, amount);\n             alloc.bytes.extend(iter::repeat(0).take(amount as usize));\n             alloc.undef_mask.grow(amount, false);\n         } else if size > new_size {\n             self.memory_usage -= size - new_size;\n             self.clear_relocations(ptr.offset(new_size, self.layout)?, size - new_size)?;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n-            // FIXME: check alignment here\n             // `as usize` is fine here, since it is smaller than `size`, which came from a usize\n             alloc.bytes.truncate(new_size as usize);\n             alloc.bytes.shrink_to_fit();\n             alloc.undef_mask.truncate(new_size);\n         }\n \n-        Ok(Pointer::new(ptr.alloc_id, 0))\n+        // Change allocation ID.  We do this after the above to be able to re-use methods like `clear_relocations`.\n+        let id = {\n+            let alloc = self.alloc_map.remove(&ptr.alloc_id).expect(\"We already used this pointer above\");\n+            let id = self.next_id;\n+            self.next_id.0 += 1;\n+            self.alloc_map.insert(id, alloc);\n+            id\n+        };\n+\n+        Ok(Pointer::new(id, 0))\n     }\n \n     // TODO(solson): See comment on `reallocate`.\n-    pub fn deallocate(&mut self, ptr: Pointer) -> EvalResult<'tcx> {\n-        if ptr.offset != 0 {\n+    pub fn deallocate(&mut self, ptr: Pointer, size_and_align: Option<(u64, u64)>) -> EvalResult<'tcx> {\n+        if ptr.offset != 0 || self.get(ptr.alloc_id).is_err() {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n-            return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n-        }\n-        if self.get(ptr.alloc_id).ok().map_or(false, |alloc| alloc.static_kind != StaticKind::NotStatic) {\n-            return Err(EvalError::DeallocatedStaticMemory);\n+            return Err(EvalError::DeallocateNonBasePtr);\n         }\n \n-        if let Some(alloc) = self.alloc_map.remove(&ptr.alloc_id) {\n-            self.memory_usage -= alloc.bytes.len() as u64;\n-        } else {\n-            debug!(\"deallocated a pointer twice: {}\", ptr.alloc_id);\n-            // TODO(solson): Report error about erroneous free. This is blocked on properly tracking\n-            // already-dropped state since this if-statement is entered even in safe code without\n-            // it.\n+        {\n+            // deallocate_local in eval_context.rs relies on nothing actually having changed when this error occurs.\n+            // So we do this test in advance.\n+            let alloc = self.get(ptr.alloc_id)?;\n+            if alloc.static_kind != StaticKind::NotStatic {\n+                return Err(EvalError::DeallocatedStaticMemory);\n+            }\n+            if let Some((size, align)) = size_and_align {\n+                if size != alloc.bytes.len() as u64 || align != alloc.align {\n+                    return Err(EvalError::IncorrectAllocationInformation);\n+                }\n+            }\n         }\n+\n+        let alloc = self.alloc_map.remove(&ptr.alloc_id).expect(\"already verified\");\n+        self.memory_usage -= alloc.bytes.len() as u64;\n         debug!(\"deallocated : {}\", ptr.alloc_id);\n \n         Ok(())"}, {"sha": "9b0596d58da03dc44637d7bbf2776c86a661e61c", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8bd42e8d473e6fcce76f7690023820fe34c09a3/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bd42e8d473e6fcce76f7690023820fe34c09a3/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=b8bd42e8d473e6fcce76f7690023820fe34c09a3", "patch": "@@ -589,7 +589,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"free\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?;\n                 if !ptr.is_null()? {\n-                    self.memory.deallocate(ptr.to_ptr()?)?;\n+                    self.memory.deallocate(ptr.to_ptr()?, None)?;\n                 }\n             }\n \n@@ -638,7 +638,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"__rust_deallocate\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n-                // FIXME: insert sanity check for size and align?\n                 let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if old_size == 0 {\n@@ -647,20 +646,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if !align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                self.memory.deallocate(ptr)?;\n+                self.memory.deallocate(ptr, Some((old_size, align)))?;\n             },\n \n             \"__rust_reallocate\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 let size = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[3], usize)?.to_u64()?;\n-                if size == 0 {\n+                if old_size == 0 || size == 0 {\n                     return Err(EvalError::HeapAllocZeroBytes);\n                 }\n                 if !align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let new_ptr = self.memory.reallocate(ptr, size, align)?;\n+                let new_ptr = self.memory.reallocate(ptr, old_size, size, align)?;\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n \n@@ -768,7 +768,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n                 if let Some(old) = success {\n                     if let Some(var) = old {\n-                        self.memory.deallocate(var)?;\n+                        self.memory.deallocate(var, None)?;\n                     }\n                     self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n                 } else {\n@@ -795,7 +795,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     self.memory.write_bytes(PrimVal::Ptr(value_copy), &value)?;\n                     self.memory.write_bytes(PrimVal::Ptr(value_copy.offset(value.len() as u64, self.memory.layout)?), &[0])?;\n                     if let Some(var) = self.env_vars.insert(name.to_owned(), value_copy) {\n-                        self.memory.deallocate(var)?;\n+                        self.memory.deallocate(var, None)?;\n                     }\n                     self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n                 } else {"}, {"sha": "fb3c865fa2508b47ed7d5bffbfeb71631a7c9251", "filename": "tests/compile-fail/deallocate-bad-alignment.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8bd42e8d473e6fcce76f7690023820fe34c09a3/tests%2Fcompile-fail%2Fdeallocate-bad-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bd42e8d473e6fcce76f7690023820fe34c09a3/tests%2Fcompile-fail%2Fdeallocate-bad-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdeallocate-bad-alignment.rs?ref=b8bd42e8d473e6fcce76f7690023820fe34c09a3", "patch": "@@ -0,0 +1,13 @@\n+#![feature(alloc, heap_api)]\n+\n+extern crate alloc;\n+\n+// error-pattern: tried to deallocate or reallocate using incorrect alignment or size\n+\n+use alloc::heap::*;\n+fn main() {\n+    unsafe {\n+        let x = allocate(1, 1);\n+        deallocate(x, 1, 2);\n+    }\n+}"}, {"sha": "fb3c865fa2508b47ed7d5bffbfeb71631a7c9251", "filename": "tests/compile-fail/deallocate-bad-size.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8bd42e8d473e6fcce76f7690023820fe34c09a3/tests%2Fcompile-fail%2Fdeallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bd42e8d473e6fcce76f7690023820fe34c09a3/tests%2Fcompile-fail%2Fdeallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdeallocate-bad-size.rs?ref=b8bd42e8d473e6fcce76f7690023820fe34c09a3", "patch": "@@ -0,0 +1,13 @@\n+#![feature(alloc, heap_api)]\n+\n+extern crate alloc;\n+\n+// error-pattern: tried to deallocate or reallocate using incorrect alignment or size\n+\n+use alloc::heap::*;\n+fn main() {\n+    unsafe {\n+        let x = allocate(1, 1);\n+        deallocate(x, 1, 2);\n+    }\n+}"}, {"sha": "9f0f9369a803efc726b71c04de3ab067085ce384", "filename": "tests/compile-fail/deallocate-twice.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8bd42e8d473e6fcce76f7690023820fe34c09a3/tests%2Fcompile-fail%2Fdeallocate-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bd42e8d473e6fcce76f7690023820fe34c09a3/tests%2Fcompile-fail%2Fdeallocate-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdeallocate-twice.rs?ref=b8bd42e8d473e6fcce76f7690023820fe34c09a3", "patch": "@@ -0,0 +1,14 @@\n+#![feature(alloc, heap_api)]\n+\n+extern crate alloc;\n+\n+// error-pattern: tried to deallocate with a pointer not to the beginning of an existing object\n+\n+use alloc::heap::*;\n+fn main() {\n+    unsafe {\n+        let x = allocate(1, 1);\n+        deallocate(x, 1, 1);\n+        deallocate(x, 1, 1);\n+    }\n+}"}, {"sha": "2edc13ee1a106b08269f9c97166580e899ab2d93", "filename": "tests/compile-fail/reallocate-bad-alignment.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8bd42e8d473e6fcce76f7690023820fe34c09a3/tests%2Fcompile-fail%2Freallocate-bad-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bd42e8d473e6fcce76f7690023820fe34c09a3/tests%2Fcompile-fail%2Freallocate-bad-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-bad-alignment.rs?ref=b8bd42e8d473e6fcce76f7690023820fe34c09a3", "patch": "@@ -0,0 +1,13 @@\n+#![feature(alloc, heap_api)]\n+\n+extern crate alloc;\n+\n+// error-pattern: tried to deallocate or reallocate using incorrect alignment or size\n+\n+use alloc::heap::*;\n+fn main() {\n+    unsafe {\n+        let x = allocate(1, 1);\n+        let _y = reallocate(x, 1, 1, 2);\n+    }\n+}"}, {"sha": "f7f1b48a7f2431c3b0aab9314001c5e5b5683960", "filename": "tests/compile-fail/reallocate-bad-size.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8bd42e8d473e6fcce76f7690023820fe34c09a3/tests%2Fcompile-fail%2Freallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bd42e8d473e6fcce76f7690023820fe34c09a3/tests%2Fcompile-fail%2Freallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-bad-size.rs?ref=b8bd42e8d473e6fcce76f7690023820fe34c09a3", "patch": "@@ -0,0 +1,13 @@\n+#![feature(alloc, heap_api)]\n+\n+extern crate alloc;\n+\n+// error-pattern: tried to deallocate or reallocate using incorrect alignment or size\n+\n+use alloc::heap::*;\n+fn main() {\n+    unsafe {\n+        let x = allocate(1, 1);\n+        let _y = reallocate(x, 2, 1, 1);\n+    }\n+}"}, {"sha": "a63629388e7d600e968a464c6173e9ea69d845cd", "filename": "tests/compile-fail/reallocate-change-alloc.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b8bd42e8d473e6fcce76f7690023820fe34c09a3/tests%2Fcompile-fail%2Freallocate-change-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bd42e8d473e6fcce76f7690023820fe34c09a3/tests%2Fcompile-fail%2Freallocate-change-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-change-alloc.rs?ref=b8bd42e8d473e6fcce76f7690023820fe34c09a3", "patch": "@@ -0,0 +1,12 @@\n+#![feature(alloc, heap_api)]\n+\n+extern crate alloc;\n+\n+use alloc::heap::*;\n+fn main() {\n+    unsafe {\n+        let x = allocate(1, 1);\n+        let _y = reallocate(x, 1, 1, 1);\n+        let _z = *x; //~ ERROR: dangling pointer was dereferenced\n+    }\n+}"}]}