{"sha": "ba013373d8aad473d2b6c6c90bb876cd45f53164", "node_id": "C_kwDOAAsO6NoAKGJhMDEzMzczZDhhYWQ0NzNkMmI2YzZjOTBiYjg3NmNkNDVmNTMxNjQ", "commit": {"author": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2022-01-30T16:37:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-30T16:37:47Z"}, "message": "Rollup merge of #92908 - dtolnay:rustdoc, r=GuillaumeGomez\n\nRender more readable macro matcher tokens in rustdoc\n\nFollow-up to #92334.\n\nThis PR lifts some of the token rendering logic from https://github.com/dtolnay/prettyplease into rustdoc so that even the matchers for which a source code snippet is not available (because they are macro-generated, or any other reason) follow some baseline good assumptions about where the tokens in the macro matcher are appropriate to space.\n\nThe below screenshots show an example of the difference using one of the gnarliest macros I could find. Some things to notice:\n\n- In the **before**, notice how a couple places break in between `$(....)`\u21b5`*`, which is just about the worst possible place that it could break.\n\n- In the **before**, the lines that wrapped are weirdly indented by 1 space of indentation relative to column 0. In the **after**, we use the typical way of block indenting in Rust syntax which is put the open/close delimiters on their own line and indent their contents by 4 spaces relative to the previous line (so 8 spaces relative to column 0, because the matcher itself is indented by 4 relative to the `macro_rules` header).\n\n- In the **after**, macro_rules metavariables like `$tokens:tt` are kept together, which is how just about everybody writing Rust today writes them.\n\n## Before\n\n![Screenshot from 2022-01-14 13-05-53](https://user-images.githubusercontent.com/1940490/149585105-1f182b78-751f-421f-a234-9dbc04fa3bbd.png)\n\n## After\n\n![Screenshot from 2022-01-14 13-06-04](https://user-images.githubusercontent.com/1940490/149585118-d4b52ea7-3e67-4b6e-a12b-31dfb8172f86.png)\n\nr? `@camelid`", "tree": {"sha": "6f271c8cd82df3e3f2eb53c1f9a18f60acf1dcdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f271c8cd82df3e3f2eb53c1f9a18f60acf1dcdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba013373d8aad473d2b6c6c90bb876cd45f53164", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh9r7bCRBK7hj4Ov3rIwAAPEsIAF8ZCZJj6g+HI3Wu9s66M81D\n9+UNmJdUXwKN95GggSSTaTpSyytUHkDr4rORgUUaIu7bQYjlDlksoSMLg9OqRLrB\ndxYTjXRJwHOtJv2WPtMifwhwFHEv+Y5Yocc0yApfhLO2qXZQQU5f9G+macpWogd+\nlBfxjVv3dymDLEtIjYttc8IkMxpC9DpH6B923bTj1jfbcKfAWBCqo8XtEpBtncGu\n+whfzagZONQTg5accZkyP4gDIEjblqhkW1DXFnNRR4KZhUsuCwARMGblUMcmE7Kb\niCnxpis14C+HTNe6pHXaFearBVITSoTHU+ABeuDoOuow2w7WnaCJUyBl8pumm8k=\n=B7Bo\n-----END PGP SIGNATURE-----\n", "payload": "tree 6f271c8cd82df3e3f2eb53c1f9a18f60acf1dcdf\nparent 0610d4fa66f95fa3a4a7af86239976ed668bab0e\nparent 039a058306b04b85a518db317304d1c25d516784\nauthor Eric Huss <eric@huss.org> 1643560667 -0800\ncommitter GitHub <noreply@github.com> 1643560667 -0800\n\nRollup merge of #92908 - dtolnay:rustdoc, r=GuillaumeGomez\n\nRender more readable macro matcher tokens in rustdoc\n\nFollow-up to #92334.\n\nThis PR lifts some of the token rendering logic from https://github.com/dtolnay/prettyplease into rustdoc so that even the matchers for which a source code snippet is not available (because they are macro-generated, or any other reason) follow some baseline good assumptions about where the tokens in the macro matcher are appropriate to space.\n\nThe below screenshots show an example of the difference using one of the gnarliest macros I could find. Some things to notice:\n\n- In the **before**, notice how a couple places break in between `$(....)`\u21b5`*`, which is just about the worst possible place that it could break.\n\n- In the **before**, the lines that wrapped are weirdly indented by 1 space of indentation relative to column 0. In the **after**, we use the typical way of block indenting in Rust syntax which is put the open/close delimiters on their own line and indent their contents by 4 spaces relative to the previous line (so 8 spaces relative to column 0, because the matcher itself is indented by 4 relative to the `macro_rules` header).\n\n- In the **after**, macro_rules metavariables like `$tokens:tt` are kept together, which is how just about everybody writing Rust today writes them.\n\n## Before\n\n![Screenshot from 2022-01-14 13-05-53](https://user-images.githubusercontent.com/1940490/149585105-1f182b78-751f-421f-a234-9dbc04fa3bbd.png)\n\n## After\n\n![Screenshot from 2022-01-14 13-06-04](https://user-images.githubusercontent.com/1940490/149585118-d4b52ea7-3e67-4b6e-a12b-31dfb8172f86.png)\n\nr? `@camelid`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba013373d8aad473d2b6c6c90bb876cd45f53164", "html_url": "https://github.com/rust-lang/rust/commit/ba013373d8aad473d2b6c6c90bb876cd45f53164", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba013373d8aad473d2b6c6c90bb876cd45f53164/comments", "author": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0610d4fa66f95fa3a4a7af86239976ed668bab0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0610d4fa66f95fa3a4a7af86239976ed668bab0e", "html_url": "https://github.com/rust-lang/rust/commit/0610d4fa66f95fa3a4a7af86239976ed668bab0e"}, {"sha": "039a058306b04b85a518db317304d1c25d516784", "url": "https://api.github.com/repos/rust-lang/rust/commits/039a058306b04b85a518db317304d1c25d516784", "html_url": "https://github.com/rust-lang/rust/commit/039a058306b04b85a518db317304d1c25d516784"}], "stats": {"total": 357, "additions": 296, "deletions": 61}, "files": [{"sha": "d41cebc98df3c900083a264978094fae3337fa57", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba013373d8aad473d2b6c6c90bb876cd45f53164/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba013373d8aad473d2b6c6c90bb876cd45f53164/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=ba013373d8aad473d2b6c6c90bb876cd45f53164", "patch": "@@ -457,7 +457,7 @@ impl Printer {\n         self.break_offset(n, 0)\n     }\n \n-    crate fn zerobreak(&mut self) {\n+    pub fn zerobreak(&mut self) {\n         self.spaces(0)\n     }\n "}, {"sha": "7d209accec9b50a24a41ea044baacc588b52ed6e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba013373d8aad473d2b6c6c90bb876cd45f53164/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba013373d8aad473d2b6c6c90bb876cd45f53164/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ba013373d8aad473d2b6c6c90bb876cd45f53164", "patch": "@@ -5,6 +5,7 @@ mod auto_trait;\n mod blanket_impl;\n crate mod cfg;\n crate mod inline;\n+mod render_macro_matchers;\n mod simplify;\n crate mod types;\n crate mod utils;"}, {"sha": "dff370ab75025c3111d2fe653f1a02949e367843", "filename": "src/librustdoc/clean/render_macro_matchers.rs", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/ba013373d8aad473d2b6c6c90bb876cd45f53164/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba013373d8aad473d2b6c6c90bb876cd45f53164/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs?ref=ba013373d8aad473d2b6c6c90bb876cd45f53164", "patch": "@@ -0,0 +1,240 @@\n+use rustc_ast::token::{self, BinOpToken, DelimToken};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast_pretty::pprust::state::State as Printer;\n+use rustc_ast_pretty::pprust::PrintState;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::parse::ParseSess;\n+use rustc_span::source_map::FilePathMapping;\n+use rustc_span::symbol::{kw, Ident, Symbol};\n+use rustc_span::Span;\n+\n+/// Render a macro matcher in a format suitable for displaying to the user\n+/// as part of an item declaration.\n+pub(super) fn render_macro_matcher(tcx: TyCtxt<'_>, matcher: &TokenTree) -> String {\n+    if let Some(snippet) = snippet_equal_to_token(tcx, matcher) {\n+        // If the original source code is known, we display the matcher exactly\n+        // as present in the source code.\n+        return snippet;\n+    }\n+\n+    // If the matcher is macro-generated or some other reason the source code\n+    // snippet is not available, we attempt to nicely render the token tree.\n+    let mut printer = Printer::new();\n+\n+    // If the inner ibox fits on one line, we get:\n+    //\n+    //     macro_rules! macroname {\n+    //         (the matcher) => {...};\n+    //     }\n+    //\n+    // If the inner ibox gets wrapped, the cbox will break and get indented:\n+    //\n+    //     macro_rules! macroname {\n+    //         (\n+    //             the matcher ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+    //             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!\n+    //         ) => {...};\n+    //     }\n+    printer.cbox(8);\n+    printer.word(\"(\");\n+    printer.zerobreak();\n+    printer.ibox(0);\n+    match matcher {\n+        TokenTree::Delimited(_span, _delim, tts) => print_tts(&mut printer, tts),\n+        // Matcher which is not a Delimited is unexpected and should've failed\n+        // to compile, but we render whatever it is wrapped in parens.\n+        TokenTree::Token(_) => print_tt(&mut printer, matcher),\n+    }\n+    printer.end();\n+    printer.break_offset_if_not_bol(0, -4);\n+    printer.word(\")\");\n+    printer.end();\n+    printer.s.eof()\n+}\n+\n+/// Find the source snippet for this token's Span, reparse it, and return the\n+/// snippet if the reparsed TokenTree matches the argument TokenTree.\n+fn snippet_equal_to_token(tcx: TyCtxt<'_>, matcher: &TokenTree) -> Option<String> {\n+    // Find what rustc thinks is the source snippet.\n+    // This may not actually be anything meaningful if this matcher was itself\n+    // generated by a macro.\n+    let source_map = tcx.sess.source_map();\n+    let span = matcher.span();\n+    let snippet = source_map.span_to_snippet(span).ok()?;\n+\n+    // Create a Parser.\n+    let sess = ParseSess::new(FilePathMapping::empty());\n+    let file_name = source_map.span_to_filename(span);\n+    let mut parser =\n+        match rustc_parse::maybe_new_parser_from_source_str(&sess, file_name, snippet.clone()) {\n+            Ok(parser) => parser,\n+            Err(diagnostics) => {\n+                for mut diagnostic in diagnostics {\n+                    diagnostic.cancel();\n+                }\n+                return None;\n+            }\n+        };\n+\n+    // Reparse a single token tree.\n+    let mut reparsed_trees = match parser.parse_all_token_trees() {\n+        Ok(reparsed_trees) => reparsed_trees,\n+        Err(mut diagnostic) => {\n+            diagnostic.cancel();\n+            return None;\n+        }\n+    };\n+    if reparsed_trees.len() != 1 {\n+        return None;\n+    }\n+    let reparsed_tree = reparsed_trees.pop().unwrap();\n+\n+    // Compare against the original tree.\n+    if reparsed_tree.eq_unspanned(matcher) { Some(snippet) } else { None }\n+}\n+\n+fn print_tt(printer: &mut Printer<'_>, tt: &TokenTree) {\n+    match tt {\n+        TokenTree::Token(token) => {\n+            let token_str = printer.token_to_string(token);\n+            printer.word(token_str);\n+            if let token::DocComment(..) = token.kind {\n+                printer.hardbreak()\n+            }\n+        }\n+        TokenTree::Delimited(_span, delim, tts) => {\n+            let open_delim = printer.token_kind_to_string(&token::OpenDelim(*delim));\n+            printer.word(open_delim);\n+            if !tts.is_empty() {\n+                if *delim == DelimToken::Brace {\n+                    printer.space();\n+                }\n+                print_tts(printer, tts);\n+                if *delim == DelimToken::Brace {\n+                    printer.space();\n+                }\n+            }\n+            let close_delim = printer.token_kind_to_string(&token::CloseDelim(*delim));\n+            printer.word(close_delim);\n+        }\n+    }\n+}\n+\n+fn print_tts(printer: &mut Printer<'_>, tts: &TokenStream) {\n+    #[derive(Copy, Clone, PartialEq)]\n+    enum State {\n+        Start,\n+        Dollar,\n+        DollarIdent,\n+        DollarIdentColon,\n+        DollarParen,\n+        DollarParenSep,\n+        Pound,\n+        PoundBang,\n+        Ident,\n+        Other,\n+    }\n+\n+    use State::*;\n+\n+    let mut state = Start;\n+    for tt in tts.trees() {\n+        let (needs_space, next_state) = match &tt {\n+            TokenTree::Token(tt) => match (state, &tt.kind) {\n+                (Dollar, token::Ident(..)) => (false, DollarIdent),\n+                (DollarIdent, token::Colon) => (false, DollarIdentColon),\n+                (DollarIdentColon, token::Ident(..)) => (false, Other),\n+                (\n+                    DollarParen,\n+                    token::BinOp(BinOpToken::Plus | BinOpToken::Star) | token::Question,\n+                ) => (false, Other),\n+                (DollarParen, _) => (false, DollarParenSep),\n+                (DollarParenSep, token::BinOp(BinOpToken::Plus | BinOpToken::Star)) => {\n+                    (false, Other)\n+                }\n+                (Pound, token::Not) => (false, PoundBang),\n+                (_, token::Ident(symbol, /* is_raw */ false))\n+                    if !usually_needs_space_between_keyword_and_open_delim(*symbol, tt.span) =>\n+                {\n+                    (true, Ident)\n+                }\n+                (_, token::Comma | token::Semi) => (false, Other),\n+                (_, token::Dollar) => (true, Dollar),\n+                (_, token::Pound) => (true, Pound),\n+                (_, _) => (true, Other),\n+            },\n+            TokenTree::Delimited(_, delim, _) => match (state, delim) {\n+                (Dollar, DelimToken::Paren) => (false, DollarParen),\n+                (Pound | PoundBang, DelimToken::Bracket) => (false, Other),\n+                (Ident, DelimToken::Paren | DelimToken::Bracket) => (false, Other),\n+                (_, _) => (true, Other),\n+            },\n+        };\n+        if state != Start && needs_space {\n+            printer.space();\n+        }\n+        print_tt(printer, &tt);\n+        state = next_state;\n+    }\n+}\n+\n+fn usually_needs_space_between_keyword_and_open_delim(symbol: Symbol, span: Span) -> bool {\n+    let ident = Ident { name: symbol, span };\n+    let is_keyword = ident.is_used_keyword() || ident.is_unused_keyword();\n+    if !is_keyword {\n+        // An identifier that is not a keyword usually does not need a space\n+        // before an open delim. For example: `f(0)` or `f[0]`.\n+        return false;\n+    }\n+\n+    match symbol {\n+        // No space after keywords that are syntactically an expression. For\n+        // example: a tuple struct created with `let _ = Self(0, 0)`, or if\n+        // someone has `impl Index<MyStruct> for bool` then `true[MyStruct]`.\n+        kw::False | kw::SelfLower | kw::SelfUpper | kw::True => false,\n+\n+        // No space, as in `let _: fn();`\n+        kw::Fn => false,\n+\n+        // No space, as in `pub(crate) type T;`\n+        kw::Pub => false,\n+\n+        // No space for keywords that can end an expression, as in `fut.await()`\n+        // where fut's Output type is `fn()`.\n+        kw::Await => false,\n+\n+        // Otherwise space after keyword. Some examples:\n+        //\n+        // `expr as [T; 2]`\n+        //         ^\n+        // `box (tuple,)`\n+        //     ^\n+        // `break (tuple,)`\n+        //       ^\n+        // `type T = dyn (Fn() -> dyn Trait) + Send;`\n+        //              ^\n+        // `for (tuple,) in iter {}`\n+        //     ^\n+        // `if (tuple,) == v {}`\n+        //    ^\n+        // `impl [T] {}`\n+        //      ^\n+        // `for x in [..] {}`\n+        //          ^\n+        // `let () = unit;`\n+        //     ^\n+        // `match [x, y] {...}`\n+        //       ^\n+        // `&mut (x as T)`\n+        //      ^\n+        // `return [];`\n+        //        ^\n+        // `fn f<T>() where (): Into<T>`\n+        //                 ^\n+        // `while (a + b).what() {}`\n+        //       ^\n+        // `yield [];`\n+        //       ^\n+        _ => true,\n+    }\n+}"}, {"sha": "dabf1e878c9fb38d3f5aaaf04f128a2cd7cd7c30", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 53, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ba013373d8aad473d2b6c6c90bb876cd45f53164/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba013373d8aad473d2b6c6c90bb876cd45f53164/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=ba013373d8aad473d2b6c6c90bb876cd45f53164", "patch": "@@ -1,5 +1,6 @@\n use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n+use crate::clean::render_macro_matchers::render_macro_matcher;\n use crate::clean::{\n     inline, Clean, Crate, ExternalCrate, Generic, GenericArg, GenericArgs, ImportSource, Item,\n     ItemKind, Lifetime, Path, PathSegment, Primitive, PrimitiveType, Type, TypeBinding, Visibility,\n@@ -17,8 +18,6 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n-use rustc_session::parse::ParseSess;\n-use rustc_span::source_map::FilePathMapping;\n use rustc_span::symbol::{kw, sym, Symbol};\n use std::fmt::Write as _;\n use std::mem;\n@@ -500,57 +499,6 @@ pub(super) fn render_macro_arms<'a>(\n     out\n }\n \n-/// Render a macro matcher in a format suitable for displaying to the user\n-/// as part of an item declaration.\n-pub(super) fn render_macro_matcher(tcx: TyCtxt<'_>, matcher: &TokenTree) -> String {\n-    if let Some(snippet) = snippet_equal_to_token(tcx, matcher) {\n-        snippet\n-    } else {\n-        rustc_ast_pretty::pprust::tt_to_string(matcher)\n-    }\n-}\n-\n-/// Find the source snippet for this token's Span, reparse it, and return the\n-/// snippet if the reparsed TokenTree matches the argument TokenTree.\n-fn snippet_equal_to_token(tcx: TyCtxt<'_>, matcher: &TokenTree) -> Option<String> {\n-    // Find what rustc thinks is the source snippet.\n-    // This may not actually be anything meaningful if this matcher was itself\n-    // generated by a macro.\n-    let source_map = tcx.sess.source_map();\n-    let span = matcher.span();\n-    let snippet = source_map.span_to_snippet(span).ok()?;\n-\n-    // Create a Parser.\n-    let sess = ParseSess::new(FilePathMapping::empty());\n-    let file_name = source_map.span_to_filename(span);\n-    let mut parser =\n-        match rustc_parse::maybe_new_parser_from_source_str(&sess, file_name, snippet.clone()) {\n-            Ok(parser) => parser,\n-            Err(diagnostics) => {\n-                for mut diagnostic in diagnostics {\n-                    diagnostic.cancel();\n-                }\n-                return None;\n-            }\n-        };\n-\n-    // Reparse a single token tree.\n-    let mut reparsed_trees = match parser.parse_all_token_trees() {\n-        Ok(reparsed_trees) => reparsed_trees,\n-        Err(mut diagnostic) => {\n-            diagnostic.cancel();\n-            return None;\n-        }\n-    };\n-    if reparsed_trees.len() != 1 {\n-        return None;\n-    }\n-    let reparsed_tree = reparsed_trees.pop().unwrap();\n-\n-    // Compare against the original tree.\n-    if reparsed_tree.eq_unspanned(matcher) { Some(snippet) } else { None }\n-}\n-\n pub(super) fn display_macro_source(\n     cx: &mut DocContext<'_>,\n     name: Symbol,"}, {"sha": "ce5d3a8461b71b82e2c368d104d02d06c1b2e423", "filename": "src/test/rustdoc/macro-generated-macro.macro_linebreak_pre.html", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba013373d8aad473d2b6c6c90bb876cd45f53164/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.macro_linebreak_pre.html", "raw_url": "https://github.com/rust-lang/rust/raw/ba013373d8aad473d2b6c6c90bb876cd45f53164/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.macro_linebreak_pre.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.macro_linebreak_pre.html?ref=ba013373d8aad473d2b6c6c90bb876cd45f53164", "patch": "@@ -0,0 +1,6 @@\n+macro_rules! linebreak {\n+    (\n+        <= 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n+        26 27 28 =>\n+    ) => { ... };\n+}\n\\ No newline at end of file"}, {"sha": "28f15522a82f7caca4acf8c6c0089162ec0ac64b", "filename": "src/test/rustdoc/macro-generated-macro.macro_morestuff_pre.html", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ba013373d8aad473d2b6c6c90bb876cd45f53164/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.macro_morestuff_pre.html", "raw_url": "https://github.com/rust-lang/rust/raw/ba013373d8aad473d2b6c6c90bb876cd45f53164/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.macro_morestuff_pre.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.macro_morestuff_pre.html?ref=ba013373d8aad473d2b6c6c90bb876cd45f53164", "patch": "@@ -0,0 +1,15 @@\n+macro_rules! morestuff {\n+    (\n+        <= \"space between most kinds of tokens\" : 1 $x + @ :: >>= 'static\n+        \"no space inside paren or bracket\" : (2 a) [2 a] $(2 $a:tt)*\n+        \"space inside curly brace\" : { 2 a }\n+        \"no space inside empty delimiters\" : () [] {}\n+        \"no space before comma or semicolon\" : a, (a), { a }, a; [T; 0];\n+        \"the three repetition specifiers\" : $(@)*, $(@)+, $(@)?\n+        \"repetition separators\" : $(@)|*, $(@)|+, $(@)==*, $(@)static*\n+        \"plus or star cannot be a repetition separator\" : $(@)+ * $(@)* +\n+        \"no space between ident and paren\" : let _ = f(0) + f[0] + Struct {};\n+        \"space between keyword and paren\" : return (a,) & for x in (..)\n+        \"some special case keywords\" : pub(crate), fn() -> u8, Self(0, 0) =>\n+    ) => { ... };\n+}\n\\ No newline at end of file"}, {"sha": "1a423cac1b5cacfaec09273972997ced38adc115", "filename": "src/test/rustdoc/macro-generated-macro.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ba013373d8aad473d2b6c6c90bb876cd45f53164/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba013373d8aad473d2b6c6c90bb876cd45f53164/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.rs?ref=ba013373d8aad473d2b6c6c90bb876cd45f53164", "patch": "@@ -1,14 +1,39 @@\n-macro_rules! outer {\n-    ($($matcher:tt)*) => {\n+macro_rules! make_macro {\n+    ($macro_name:ident $($matcher:tt)*) => {\n         #[macro_export]\n-        macro_rules! inner {\n+        macro_rules! $macro_name {\n             (<= $($matcher)* =>) => {};\n         }\n     }\n }\n \n-// @has macro_generated_macro/macro.inner.html //pre 'macro_rules! inner {'\n-// @has - //pre '(<= type $($i : ident) :: * + $e : expr =>) => { ... };'\n-outer!(type $($i:ident)::* + $e:expr);\n+// @has macro_generated_macro/macro.interpolations.html //pre 'macro_rules! interpolations {'\n+// @has - //pre '(<= type $($i:ident)::* + $e:expr =>) => { ... };'\n+make_macro!(interpolations type $($i:ident)::* + $e:expr);\n+interpolations!(<= type foo::bar + x.sort() =>);\n \n-inner!(<= type foo::bar + x.sort() =>);\n+// @has macro_generated_macro/macro.attributes.html //pre 'macro_rules! attributes {'\n+// @has - //pre '(<= #![no_std] #[cfg(feature = \"alloc\")] =>) => { ... };'\n+make_macro!(attributes #![no_std] #[cfg(feature = \"alloc\")]);\n+\n+// @has macro_generated_macro/macro.groups.html //pre 'macro_rules! groups {'\n+// @has - //pre '(<= fn {} () { foo[0] } =>) => { ... };'\n+make_macro!(groups fn {}() {foo[0]});\n+\n+// @snapshot macro_linebreak_pre macro_generated_macro/macro.linebreak.html //pre/text()\n+make_macro!(linebreak 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28);\n+\n+// @snapshot macro_morestuff_pre macro_generated_macro/macro.morestuff.html //pre/text()\n+make_macro!(morestuff\n+    \"space between most kinds of tokens\": 1 $x + @ :: >>= 'static\n+    \"no space inside paren or bracket\": (2 a) [2 a] $(2 $a:tt)*\n+    \"space inside curly brace\": { 2 a }\n+    \"no space inside empty delimiters\": () [] {}\n+    \"no space before comma or semicolon\": a, (a), { a }, a; [T; 0];\n+    \"the three repetition specifiers\": $(@)*, $(@)+, $(@)?\n+    \"repetition separators\": $(@)|*, $(@)|+, $(@)==*, $(@)static*\n+    \"plus or star cannot be a repetition separator\": $(@)+ * $(@)* +\n+    \"no space between ident and paren\": let _ = f(0) + f[0] + Struct {};\n+    \"space between keyword and paren\": return (a,) & for x in (..)\n+    \"some special case keywords\": pub(crate), fn() -> u8, Self(0, 0)\n+);"}]}