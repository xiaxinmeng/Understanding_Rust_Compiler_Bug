{"sha": "08ee3385c0716e0738730979a7fe2277b13ede1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZWUzMzg1YzA3MTZlMDczODczMDk3OWE3ZmUyMjc3YjEzZWRlMWM=", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-01-27T21:20:00Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-02-15T21:43:43Z"}, "message": "Add to glossary: vectorize, scalar, vector register\n\nAlso document the lanewise scalar helpers.", "tree": {"sha": "07639e968c6f5624943b2483d83548accc57a10f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07639e968c6f5624943b2483d83548accc57a10f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08ee3385c0716e0738730979a7fe2277b13ede1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08ee3385c0716e0738730979a7fe2277b13ede1c", "html_url": "https://github.com/rust-lang/rust/commit/08ee3385c0716e0738730979a7fe2277b13ede1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08ee3385c0716e0738730979a7fe2277b13ede1c/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "html_url": "https://github.com/rust-lang/rust/commit/b931c15c0b9fad90b8020ea5a5ad54eef7519edf"}], "stats": {"total": 15, "additions": 15, "deletions": 0}, "files": [{"sha": "dfd357c459200f7b7eb3901d2afd1b8fa74dd98d", "filename": "beginners-guide.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08ee3385c0716e0738730979a7fe2277b13ede1c/beginners-guide.md", "raw_url": "https://github.com/rust-lang/rust/raw/08ee3385c0716e0738730979a7fe2277b13ede1c/beginners-guide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/beginners-guide.md?ref=08ee3385c0716e0738730979a7fe2277b13ede1c", "patch": "@@ -19,10 +19,18 @@ SIMD has a few special vocabulary terms you should know:\n \n * **Vector:** A SIMD value is called a vector. This shouldn't be confused with the `Vec<T>` type. A SIMD vector has a fixed size, known at compile time. All of the elements within the vector are of the same type. This makes vectors *similar to* arrays. One difference is that a vector is generally aligned to its *entire* size (eg: 16 bytes, 32 bytes, etc), not just the size of an individual element. Sometimes vector data is called \"packed\" data.\n \n+* **Vectorize**: An operation that uses SIMD instructions to operate over a vector is often referred to as \"vectorized\".\n+\n+* **Autovectorization**: Also known as _implicit vectorization_. This is when a compiler can automatically recognize a situation where scalar instructions may be replaced with SIMD instructions, and use those instead.\n+\n+* **Scalar:** \"Scalar\" in mathematical contexts refers to values that can be represented as a single element, mostly numbers like 6, 3.14, or -2. It can also be used to describe \"scalar operations\" that use strictly scalar values, like addition. This term is mostly used to differentiate between vectorized operations that use SIMD instructions and scalar operations that don't.\n+\n * **Lane:** A single element position within a vector is called a lane. If you have `N` lanes available then they're numbered from `0` to `N-1` when referring to them, again like an array. The biggest difference between an array element and a vector lane is that in general is *relatively costly* to access an individual lane value. On most architectures, the vector has to be pushed out of the SIMD register onto the stack, then an individual lane is accessed while it's on the stack (and possibly the stack value is read back into a register). For this reason, when working with SIMD you should avoid reading or writing the value of an individual lane during hot loops.\n \n * **Bit Widths:** When talking about SIMD, the bit widths used are the bit size of the vectors involved, *not* the individual elements. So \"128-bit SIMD\" has 128-bit vectors, and that might be `f32x4`, `i32x4`, `i16x8`, or other variations. While 128-bit SIMD is the most common, there's also 64-bit, 256-bit, and even 512-bit on the newest CPUs.\n \n+* **Vector Register:** The extra-wide registers that are used for SIMD operations are commonly called vector registers, though you may also see \"SIMD registers\", vendor names for specific features, or even \"floating-point register\" as it is common for the same registers to be used with both scalar and vectorized floating-point operations.\n+\n * **Vertical:** When an operation is \"vertical\", each lane processes individually without regard to the other lanes in the same vector. For example, a \"vertical add\" between two vectors would add lane 0 in `a` with lane 0 in `b`, with the total in lane 0 of `out`, and then the same thing for lanes 1, 2, etc. Most SIMD operations are vertical operations, so if your problem is a vertical problem then you can probably solve it with SIMD.\n \n * **Horizontal:** When an operation is \"horizontal\", the lanes within a single vector interact in some way. A \"horizontal add\" might add up lane 0 of `a` with lane 1 of `a`, with the total in lane 0 of `out`."}, {"sha": "3a9f479680804151180ec6327f477737e49d19dd", "filename": "crates/core_simd/tests/helpers/lanewise.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08ee3385c0716e0738730979a7fe2277b13ede1c/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ee3385c0716e0738730979a7fe2277b13ede1c/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs?ref=08ee3385c0716e0738730979a7fe2277b13ede1c", "patch": "@@ -1,3 +1,10 @@\n+//! These helpers provide a way to easily emulate a vectorized SIMD op on two SIMD vectors,\n+//! except using scalar ops that iterate through each lane, one at a time, so as to remove\n+//! the vagaries of compilation.\n+//!\n+//! Do note, however, that when testing that vectorized operations #[should_panic], these\n+//! \"scalarized SIMD ops\" will trigger scalar code paths that may also normally panic.\n+\n pub fn apply_unary_lanewise<T1: Copy, T2: Copy, V1: AsRef<[T1]>, V2: AsMut<[T2]> + Default>(\n     x: V1,\n     f: impl Fn(T1) -> T2,"}]}