{"sha": "41a74ace4aeba292ac524dccaa594c2c8aeb19c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxYTc0YWNlNGFlYmEyOTJhYzUyNGRjY2FhNTk0YzJjOGFlYjE5YzA=", "commit": {"author": {"name": "Nadrieril", "email": "Nadrieril@users.noreply.github.com", "date": "2020-10-28T19:03:49Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-28T19:08:01Z"}, "message": "Apply suggestions from code review\n\nCo-authored-by: Who? Me?! <mark-i-m@users.noreply.github.com>\nCo-authored-by: varkor <github@varkor.com>", "tree": {"sha": "c2dd4b0cc434711ad89fd3b231660d9aa853c469", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2dd4b0cc434711ad89fd3b231660d9aa853c469"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41a74ace4aeba292ac524dccaa594c2c8aeb19c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41a74ace4aeba292ac524dccaa594c2c8aeb19c0", "html_url": "https://github.com/rust-lang/rust/commit/41a74ace4aeba292ac524dccaa594c2c8aeb19c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41a74ace4aeba292ac524dccaa594c2c8aeb19c0/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "766ab78a1cb243293eb84efd073186aa28724802", "url": "https://api.github.com/repos/rust-lang/rust/commits/766ab78a1cb243293eb84efd073186aa28724802", "html_url": "https://github.com/rust-lang/rust/commit/766ab78a1cb243293eb84efd073186aa28724802"}], "stats": {"total": 43, "additions": 20, "deletions": 23}, "files": [{"sha": "843a6c0e461f9aef1455ccbb029949a2e9e0191a", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/41a74ace4aeba292ac524dccaa594c2c8aeb19c0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a74ace4aeba292ac524dccaa594c2c8aeb19c0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=41a74ace4aeba292ac524dccaa594c2c8aeb19c0", "patch": "@@ -203,7 +203,7 @@\n //! before.\n //! That's almost correct, but only works if there were no wildcards in those first\n //! components. So we need to check that `p` is useful with respect to the rows that\n-//! start with a wildcard, if there are any. This is where `D` comes in:\n+//! start with a wildcard, if there are any. This is where `S(_, x)` comes in:\n //! `U(P, p) := U(S(_, P), S(_, p))`\n //!\n //! For example, if `P` is:\n@@ -634,8 +634,8 @@ impl Slice {\n     }\n \n     /// The exhaustiveness-checking paper does not include any details on\n-    /// checking variable-length slice patterns. However, they are matched\n-    /// by an infinite collection of fixed-length array patterns.\n+    /// checking variable-length slice patterns. However, they may be\n+    /// matched by an infinite collection of fixed-length array patterns.\n     ///\n     /// Checking the infinite set directly would take an infinite amount\n     /// of time. However, it turns out that for each finite set of\n@@ -646,11 +646,11 @@ impl Slice {\n     /// `s\u2098` for each sufficiently-large length `m` that applies to exactly\n     /// the same subset of `P`.\n     ///\n-    /// Because of that, each witness for reachability-checking from one\n+    /// Because of that, each witness for reachability-checking of one\n     /// of the sufficiently-large lengths can be transformed to an\n-    /// equally-valid witness from any other length, so we only have\n-    /// to check slice lengths from the \"minimal sufficiently-large length\"\n-    /// and below.\n+    /// equally-valid witness of any other length, so we only have\n+    /// to check slices of the \"minimal sufficiently-large length\"\n+    /// and less.\n     ///\n     /// Note that the fact that there is a *single* `s\u2098` for each `m`\n     /// not depending on the specific pattern in `P` is important: if\n@@ -659,8 +659,8 @@ impl Slice {\n     ///     `[.., false]`\n     /// Then any slice of length \u22651 that matches one of these two\n     /// patterns can be trivially turned to a slice of any\n-    /// other length \u22651 that matches them and vice-versa - for\n-    /// but the slice from length 2 `[false, true]` that matches neither\n+    /// other length \u22651 that matches them and vice-versa,\n+    /// but the slice of length 2 `[false, true]` that matches neither\n     /// of these patterns can't be turned to a slice from length 1 that\n     /// matches neither of these patterns, so we have to consider\n     /// slices from length 2 there.\n@@ -787,7 +787,7 @@ enum Constructor<'tcx> {\n     Opaque,\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n     NonExhaustive,\n-    /// Fake constructor for those types for which we can't list constructors explicitely, like\n+    /// Fake constructor for those types for which we can't list constructors explicitly, like\n     /// `f64` and `&str`.\n     Unlistable,\n     /// Wildcard pattern.\n@@ -796,13 +796,10 @@ enum Constructor<'tcx> {\n \n impl<'tcx> Constructor<'tcx> {\n     fn is_wildcard(&self) -> bool {\n-        match self {\n-            Wildcard => true,\n-            _ => false,\n-        }\n+        matches!(self, Wildcard)\n     }\n \n-    fn as_intrange(&self) -> Option<&IntRange<'tcx>> {\n+    fn as_int_range(&self) -> Option<&IntRange<'tcx>> {\n         match self {\n             IntRange(range) => Some(range),\n             _ => None,\n@@ -827,7 +824,7 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n-    /// Some constructors (namely Wildcard, IntRange and Slice) actually stand for a set of actual\n+    /// Some constructors (namely `Wildcard`, `IntRange` and `Slice`) actually stand for a set of actual\n     /// constructors (like variants, integers or fixed-sized slices). When specializing for these\n     /// constructors, we want to be specialising for the actual underlying constructors.\n     /// Naively, we would simply return the list of constructors they correspond to. We instead are\n@@ -863,8 +860,8 @@ impl<'tcx> Constructor<'tcx> {\n \n     /// For wildcards, there are two groups of constructors: there are the constructors actually\n     /// present in the matrix (`head_ctors`), and the constructors not present (`missing_ctors`).\n-    /// Two constructors that are not in the matrix will either both be catched (by a wildcard), or\n-    /// both not be catched. Therefore we can keep the missing constructors grouped together.\n+    /// Two constructors that are not in the matrix will either both be caught (by a wildcard), or\n+    /// both not be caught. Therefore we can keep the missing constructors grouped together.\n     fn split_wildcard<'p>(pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Self; 1]> {\n         // Missing constructors are those that are not matched by any non-wildcard patterns in the\n         // current column. We only fully construct them on-demand, because they're rarely used and\n@@ -882,8 +879,8 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n-    /// Returns whether `self` is covered by `other`, ie whether `self` is a subset of `other`. For\n-    /// the simple cases, this is simply checking for equality. For the \"grouped\" constructors,\n+    /// Returns whether `self` is covered by `other`, i.e. whether `self` is a subset of `other`.\n+    /// For the simple cases, this is simply checking for equality. For the \"grouped\" constructors,\n     /// this checks for inclusion.\n     fn is_covered_by<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>, other: &Self) -> bool {\n         match (self, other) {\n@@ -955,7 +952,7 @@ impl<'tcx> Constructor<'tcx> {\n             Variant(_) => used_ctors.iter().any(|c| c == self),\n             IntRange(range) => used_ctors\n                 .iter()\n-                .filter_map(|c| c.as_intrange())\n+                .filter_map(|c| c.as_int_range())\n                 .any(|other| range.is_covered_by(pcx, other)),\n             Slice(slice) => used_ctors\n                 .iter()\n@@ -1601,7 +1598,7 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n         _ if cx.is_uninhabited(pcx.ty) => vec![],\n         ty::Adt(..) | ty::Tuple(..) => vec![Single],\n         ty::Ref(_, t, _) if !t.is_str() => vec![Single],\n-        // This type is one for which we don't know how to list constructors, like &str of f64.\n+        // This type is one for which we don't know how to list constructors, like `&str` or `f64`.\n         _ => vec![Unlistable],\n     }\n }\n@@ -1851,7 +1848,7 @@ impl<'tcx> IntRange<'tcx> {\n         let row_borders = pcx\n             .matrix\n             .head_ctors(pcx.cx)\n-            .filter_map(|ctor| ctor.as_intrange())\n+            .filter_map(|ctor| ctor.as_int_range())\n             .filter_map(|range| {\n                 let intersection = self.intersection(pcx.cx.tcx, &range);\n                 let should_lint = self.suspicious_intersection(&range);"}]}