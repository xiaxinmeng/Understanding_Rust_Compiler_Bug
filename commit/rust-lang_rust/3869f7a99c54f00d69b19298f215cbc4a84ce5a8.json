{"sha": "3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NjlmN2E5OWM1NGYwMGQ2OWIxOTI5OGYyMTVjYmM0YTg0Y2U1YTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-31T02:04:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-31T02:04:52Z"}, "message": "auto merge of #6818 : nikomatsakis/rust/irrefut-patterns-refactoring, r=graydon\n\nVarious bug fixes and simplifications I did as part of a patch to fix `let` patterns.\r\n\r\nr? @catamorphism", "tree": {"sha": "fca2b9d8c111e40604460dedc696cbe0a47b58c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fca2b9d8c111e40604460dedc696cbe0a47b58c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "html_url": "https://github.com/rust-lang/rust/commit/3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "237dce12c934287abd0bbe5a35309b1dc4f0d2c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/237dce12c934287abd0bbe5a35309b1dc4f0d2c0", "html_url": "https://github.com/rust-lang/rust/commit/237dce12c934287abd0bbe5a35309b1dc4f0d2c0"}, {"sha": "ce5fd302702a76e4b65a94128189b0f2d3a22c32", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce5fd302702a76e4b65a94128189b0f2d3a22c32", "html_url": "https://github.com/rust-lang/rust/commit/ce5fd302702a76e4b65a94128189b0f2d3a22c32"}], "stats": {"total": 858, "additions": 408, "deletions": 450}, "files": [{"sha": "eb8c27e9902b5bb047b247f49e5dc0ab5143236a", "filename": "src/libextra/fun_treemap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffun_treemap.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -35,13 +35,13 @@ enum TreeNode<K, V> {\n pub fn init<K, V>() -> Treemap<K, V> { @Empty }\n \n /// Insert a value into the map\n-pub fn insert<K:Copy + Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K, v: V) -> Treemap<K, V> {\n+pub fn insert<K:Eq + Ord,V>(m: Treemap<K, V>, k: K, v: V) -> Treemap<K, V> {\n     @match m {\n         @Empty => Node(@k, @v, @Empty, @Empty),\n-        @Node(@copy kk, vv, left, right) => cond!(\n-            (k <  kk) { Node(@kk, vv, insert(left, k, v), right) }\n-            (k == kk) { Node(@kk, @v, left, right)               }\n-            _         { Node(@kk, vv, left, insert(right, k, v)) }\n+        @Node(kk, vv, left, right) => cond!(\n+            (k <  *kk) { Node(kk, vv, insert(left, k, v), right) }\n+            (k == *kk) { Node(kk, @v, left, right)               }\n+            _          { Node(kk, vv, left, insert(right, k, v)) }\n         )\n     }\n }\n@@ -50,8 +50,8 @@ pub fn insert<K:Copy + Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K, v: V) -> Treemap\n pub fn find<K:Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n     match *m {\n         Empty => None,\n-        Node(@ref kk, @copy v, left, right) => cond!(\n-            (k == *kk) { Some(v)        }\n+        Node(kk, v, left, right) => cond!(\n+            (k == *kk) { Some(copy *v)  }\n             (k <  *kk) { find(left, k)  }\n             _          { find(right, k) }\n         )"}, {"sha": "eb5699df77f6d0aebbbd181170ddf28488dbdd1a", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -171,7 +171,7 @@ fn is_arg(arg: &str) -> bool {\n fn name_str(nm: &Name) -> ~str {\n     return match *nm {\n       Short(ch) => str::from_char(ch),\n-      Long(copy s) => s\n+      Long(ref s) => copy *s\n     };\n }\n \n@@ -390,7 +390,7 @@ pub fn opts_present(mm: &Matches, names: &[~str]) -> bool {\n  * argument\n  */\n pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n-    return match opt_val(mm, nm) { Val(copy s) => s, _ => fail!() };\n+    return match opt_val(mm, nm) { Val(s) => s, _ => fail!() };\n }\n \n /**\n@@ -402,7 +402,7 @@ pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n     for names.each |nm| {\n         match opt_val(mm, *nm) {\n-          Val(copy s) => return s,\n+          Val(ref s) => return copy *s,\n           _ => ()\n         }\n     }\n@@ -419,7 +419,7 @@ pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n pub fn opt_strs(mm: &Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     for vec::each(opt_vals(mm, nm)) |v| {\n-        match *v { Val(copy s) => acc.push(s), _ => () }\n+        match *v { Val(ref s) => acc.push(copy *s), _ => () }\n     }\n     return acc;\n }\n@@ -429,7 +429,7 @@ pub fn opt_maybe_str(mm: &Matches, nm: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n     if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n     return match vals[0] {\n-        Val(copy s) => Some(s),\n+        Val(ref s) => Some(copy *s),\n         _ => None\n     };\n }\n@@ -445,7 +445,7 @@ pub fn opt_maybe_str(mm: &Matches, nm: &str) -> Option<~str> {\n pub fn opt_default(mm: &Matches, nm: &str, def: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n     if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n-    return match vals[0] { Val(copy s) => Some::<~str>(s),\n+    return match vals[0] { Val(ref s) => Some::<~str>(copy *s),\n                            _      => Some::<~str>(str::to_owned(def)) }\n }\n \n@@ -701,7 +701,7 @@ mod tests {\n         let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionMissing_),\n+          Err(f) => check_fail_type(f, OptionMissing_),\n           _ => fail!()\n         }\n     }\n@@ -712,7 +712,7 @@ mod tests {\n         let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -723,7 +723,7 @@ mod tests {\n         let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -748,7 +748,7 @@ mod tests {\n         let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionMissing_),\n+          Err(f) => check_fail_type(f, OptionMissing_),\n           _ => fail!()\n         }\n     }\n@@ -759,7 +759,7 @@ mod tests {\n         let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -770,7 +770,7 @@ mod tests {\n         let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -808,7 +808,7 @@ mod tests {\n         let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -819,7 +819,7 @@ mod tests {\n         let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -855,7 +855,7 @@ mod tests {\n         let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -866,7 +866,7 @@ mod tests {\n         let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -901,7 +901,7 @@ mod tests {\n         let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => {\n+          Err(f) => {\n             error!(fail_str(copy f));\n             check_fail_type(f, UnexpectedArgument_);\n           }\n@@ -915,7 +915,7 @@ mod tests {\n         let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -963,7 +963,7 @@ mod tests {\n         let opts = ~[optflag(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -1066,7 +1066,7 @@ mod tests {\n         let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -1119,7 +1119,7 @@ mod tests {\n         let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -1147,7 +1147,7 @@ mod tests {\n         let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, UnrecognizedOption_),\n+          Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n     }\n@@ -1158,7 +1158,7 @@ mod tests {\n         let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, UnrecognizedOption_),\n+          Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n     }"}, {"sha": "d69548c6f9d2d2192840660640675f40746105fe", "filename": "src/libextra/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -1384,7 +1384,7 @@ mod tests {\n \n         for items.each |item| {\n             match *item {\n-                (copy key, copy value) => { d.insert(key, value); },\n+                (ref key, ref value) => { d.insert(copy *key, copy *value); },\n             }\n         };\n "}, {"sha": "7a38be8944f974ec4f26dae7a012fefcb116c642", "filename": "src/libextra/list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -104,7 +104,7 @@ pub fn tail<T:Copy>(ls: @List<T>) -> @List<T> {\n /// Returns the first element of a list\n pub fn head<T:Copy>(ls: @List<T>) -> T {\n     match *ls {\n-      Cons(copy hd, _) => hd,\n+      Cons(ref hd, _) => copy *hd,\n       // makes me sad\n       _ => fail!(\"head invoked on empty list\")\n     }\n@@ -114,9 +114,9 @@ pub fn head<T:Copy>(ls: @List<T>) -> T {\n pub fn append<T:Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n     match *l {\n       Nil => return m,\n-      Cons(copy x, xs) => {\n+      Cons(ref x, xs) => {\n         let rest = append(xs, m);\n-        return @Cons(x, rest);\n+        return @Cons(copy *x, rest);\n       }\n     }\n }"}, {"sha": "ddbf09e40eb92a75bee5cb83d0acb8787af9c6f1", "filename": "src/libextra/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_ip.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -278,7 +278,7 @@ pub mod v6 {\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n           result::Ok(addr) => addr,\n-          result::Err(copy err_data) => fail!(copy err_data.err_msg)\n+          result::Err(err_data) => fail!(copy err_data.err_msg)\n         }\n     }\n     pub fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {"}, {"sha": "d658ad6551f241bae06bfa064c349709473df014", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -595,7 +595,7 @@ pub fn accept(new_conn: TcpNewConnection)\n                 }\n                 // UNSAFE LIBUV INTERACTION END\n                 match result_po.recv() {\n-                    Some(copy err_data) => result::Err(err_data),\n+                    Some(err_data) => result::Err(err_data),\n                     None => result::Ok(TcpSocket(client_socket_data))\n                 }\n             }"}, {"sha": "375b4cd5fb551c6ae2496f7f59b6b8072475c054", "filename": "src/libextra/test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -223,7 +223,7 @@ pub fn run_tests_console(opts: &TestOpts,\n           }\n           TeWait(ref test) => st.out.write_str(\n               fmt!(\"test %s ... \", test.name.to_str())),\n-          TeResult(copy test, result) => {\n+          TeResult(test, result) => {\n             match st.log_out {\n                 Some(f) => write_log(f, copy result, &test),\n                 None => ()\n@@ -504,9 +504,8 @@ pub fn filter_tests(\n     filtered = if opts.filter.is_none() {\n         filtered\n     } else {\n-        let filter_str =\n-            match opts.filter {\n-          option::Some(copy f) => f,\n+        let filter_str = match opts.filter {\n+          option::Some(ref f) => copy *f,\n           option::None => ~\"\"\n         };\n \n@@ -866,7 +865,7 @@ mod tests {\n     fn first_free_arg_should_be_a_filter() {\n         let args = ~[~\"progname\", ~\"filter\"];\n         let opts = match parse_opts(args) {\n-          either::Left(copy o) => o,\n+          either::Left(o) => o,\n           _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n         assert!(\"filter\" == (copy opts.filter).get());\n@@ -876,7 +875,7 @@ mod tests {\n     fn parse_ignored_flag() {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n         let opts = match parse_opts(args) {\n-          either::Left(copy o) => o,\n+          either::Left(o) => o,\n           _ => fail!(\"Malformed arg in parse_ignored_flag\")\n         };\n         assert!((opts.run_ignored));"}, {"sha": "1a3a5db66aef9b67c1e75468cedbda4f0bf6a901", "filename": "src/libextra/time.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -275,10 +275,12 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         let mut i = 0u;\n         let len = strs.len();\n         while i < len {\n-            let &(needle, value) = &strs[i];\n-\n-            if match_str(ss, pos, needle) {\n-                return Some((value, pos + str::len(needle)));\n+            match strs[i] { // can't use let due to stage0 bugs\n+                (ref needle, value) => {\n+                    if match_str(ss, pos, *needle) {\n+                        return Some((value, pos + str::len(*needle)));\n+                    }\n+                }\n             }\n             i += 1u;\n         }\n@@ -1007,7 +1009,7 @@ mod tests {\n             == Err(~\"Invalid time\"));\n \n         match strptime(\"Fri Feb 13 15:31:30 2009\", format) {\n-          Err(copy e) => fail!(e),\n+          Err(e) => fail!(e),\n           Ok(ref tm) => {\n             assert!(tm.tm_sec == 30_i32);\n             assert!(tm.tm_min == 31_i32);\n@@ -1027,7 +1029,7 @@ mod tests {\n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n               Ok(ref tm) => tm.strftime(format) == str::to_owned(s),\n-              Err(copy e) => fail!(e)\n+              Err(e) => fail!(e)\n             }\n         }\n "}, {"sha": "472ce5c926e5b25e9a7b15afe9d2078dce2f18c3", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -375,8 +375,8 @@ pub mod write {\n \n     pub fn run_ndk(sess: Session, assembly: &Path, object: &Path) {\n         let cc_prog: ~str = match &sess.opts.android_cross_path {\n-            &Some(copy path) => {\n-                fmt!(\"%s/bin/arm-linux-androideabi-gcc\", path)\n+            &Some(ref path) => {\n+                fmt!(\"%s/bin/arm-linux-androideabi-gcc\", *path)\n             }\n             &None => {\n                 sess.fatal(\"need Android NDK path for building \\\n@@ -763,12 +763,12 @@ pub fn link_binary(sess: Session,\n     // For win32, there is no cc command,\n     // so we add a condition to make it use gcc.\n     let cc_prog: ~str = match sess.opts.linker {\n-        Some(copy linker) => linker,\n+        Some(ref linker) => copy *linker,\n         None => {\n             if sess.targ_cfg.os == session::os_android {\n                 match &sess.opts.android_cross_path {\n-                    &Some(copy path) => {\n-                        fmt!(\"%s/bin/arm-linux-androideabi-gcc\", path)\n+                    &Some(ref path) => {\n+                        fmt!(\"%s/bin/arm-linux-androideabi-gcc\", *path)\n                     }\n                     &None => {\n                         sess.fatal(\"need Android NDK path for linking \\"}, {"sha": "5e33a8f78fea81f0023d9cdf3bd3a2aec662ca76", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -956,8 +956,8 @@ mod test {\n     fn test_switch_implies_cfg_test() {\n         let matches =\n             &match getopts([~\"--test\"], optgroups()) {\n-              Ok(copy m) => m,\n-              Err(copy f) => fail!(\"test_switch_implies_cfg_test: %s\", getopts::fail_str(f))\n+              Ok(m) => m,\n+              Err(f) => fail!(\"test_switch_implies_cfg_test: %s\", getopts::fail_str(f))\n             };\n         let sessopts = build_session_options(\n             @~\"rustc\", matches, diagnostic::emit);\n@@ -972,8 +972,8 @@ mod test {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts([~\"--test\", ~\"--cfg=test\"], optgroups()) {\n-              Ok(copy m) => m,\n-              Err(copy f) => {\n+              Ok(m) => m,\n+              Err(f) => {\n                 fail!(\"test_switch_implies_cfg_test_unless_cfg_test: %s\", getopts::fail_str(f));\n               }\n             };"}, {"sha": "0e263c78bfe22f0c887b3f5d8f429f592a65b12e", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -141,10 +141,10 @@ fn visit_crate(e: @mut Env, c: &ast::crate) {\n \n fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n     match i.node {\n-      ast::view_item_extern_mod(ident, /*bad*/copy meta_items, id) => {\n+      ast::view_item_extern_mod(ident, ref meta_items, id) => {\n         debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n-               ident, meta_items);\n-        let cnum = resolve_crate(e, ident, meta_items, @~\"\", i.span);\n+               ident, *meta_items);\n+        let cnum = resolve_crate(e, ident, copy *meta_items, @~\"\", i.span);\n         cstore::add_extern_mod_stmt_cnum(e.cstore, id, cnum);\n       }\n       _ => ()"}, {"sha": "552476d25d6f4bcff2ea6950036c736ced8e32bc", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -623,7 +623,7 @@ pub impl GatherLoanCtxt {\n                                              cmt, mutbl, scope_r);\n                     }\n                   }\n-                  ast::bind_by_copy | ast::bind_infer => {\n+                  ast::bind_infer => {\n                       // No borrows here, but there may be moves\n                       if self.bccx.is_move(pat.id) {\n                           gather_moves::gather_move_from_pat("}, {"sha": "035d6a5cc459a214cde71471623cbec30af5339d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -827,7 +827,6 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n     for pats.each |pat| {\n         do pat_bindings(def_map, *pat) |bm, id, span, _path| {\n             match bm {\n-                bind_by_copy => {}\n                 bind_by_ref(_) => {\n                     by_ref_span = Some(span);\n                 }"}, {"sha": "8493965049ebf4e3c44d967f68418bcc96f27040", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -71,7 +71,6 @@ pub fn check_crate(tcx: ty::ctxt,\n         current_item: -1\n     };\n     let visit = visit::mk_vt(@visit::Visitor {\n-        visit_arm: check_arm,\n         visit_expr: check_expr,\n         visit_fn: check_fn,\n         visit_ty: check_ty,\n@@ -238,19 +237,6 @@ fn check_fn(\n     visit::visit_fn(fk, decl, body, sp, fn_id, cx, v);\n }\n \n-fn check_arm(a: &arm, cx: Context, v: visit::vt<Context>) {\n-    for a.pats.each |p| {\n-        do pat_util::pat_bindings(cx.tcx.def_map, *p) |mode, id, span, _pth| {\n-            if mode == bind_by_copy {\n-                let t = ty::node_id_to_type(cx.tcx, id);\n-                let reason = \"consider binding with `ref` or `move` instead\";\n-                check_copy(cx, t, span, reason);\n-            }\n-        }\n-    }\n-    visit::visit_arm(a, cx, v);\n-}\n-\n pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n     debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n "}, {"sha": "d2f6d6527738885cda6979fa57520cc6f7efe005", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -576,14 +576,18 @@ pub impl VisitContext {\n \n         do pat_bindings(self.tcx.def_map, pat) |bm, id, _span, _path| {\n             let binding_moves = match bm {\n-                bind_by_copy => false,\n                 bind_by_ref(_) => false,\n                 bind_infer => {\n                     let pat_ty = ty::node_id_to_type(self.tcx, id);\n+                    debug!(\"pattern %? type is %s\",\n+                           id, pat_ty.repr(self.tcx));\n                     ty::type_moves_by_default(self.tcx, pat_ty)\n                 }\n             };\n \n+            debug!(\"pattern binding %?: bm=%?, binding_moves=%b\",\n+                   id, bm, binding_moves);\n+\n             if binding_moves {\n                 self.move_maps.moves_map.insert(id);\n             }"}, {"sha": "23645f7f04a3c10a7fd7ce92d0b282151341aef8", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -520,12 +520,12 @@ pub impl NameBindings {\n                     type_span: Some(sp)\n                 });\n             }\n-            Some(copy type_def) => {\n+            Some(type_def) => {\n                 self.type_def = Some(TypeNsDef {\n                     privacy: privacy,\n                     module_def: Some(module_),\n                     type_span: Some(sp),\n-                    .. type_def\n+                    type_def: type_def.type_def\n                 });\n             }\n         }\n@@ -577,12 +577,12 @@ pub impl NameBindings {\n                     type_span: Some(sp)\n                 });\n             }\n-            Some(copy type_def) => {\n+            Some(type_def) => {\n                 self.type_def = Some(TypeNsDef {\n                     privacy: privacy,\n                     type_def: Some(def),\n                     type_span: Some(sp),\n-                    .. type_def\n+                    module_def: type_def.module_def\n                 });\n             }\n         }\n@@ -1566,7 +1566,7 @@ pub impl Resolver {\n         match def {\n           def_mod(def_id) | def_foreign_mod(def_id) => {\n             match child_name_bindings.type_def {\n-              Some(TypeNsDef { module_def: Some(copy module_def), _ }) => {\n+              Some(TypeNsDef { module_def: Some(module_def), _ }) => {\n                 debug!(\"(building reduced graph for external crate) \\\n                         already created module\");\n                 module_def.def_id = Some(def_id);\n@@ -1745,7 +1745,7 @@ pub impl Resolver {\n                                                           NormalModuleKind,\n                                                           dummy_sp());\n                     }\n-                    Some(copy type_ns_def)\n+                    Some(type_ns_def)\n                             if type_ns_def.module_def.is_none() => {\n                         debug!(\"(building reduced graph for external crate) \\\n                                 autovivifying missing module def %s\",\n@@ -1812,7 +1812,7 @@ pub impl Resolver {\n                                     let type_module;\n                                     match child_name_bindings.type_def {\n                                         Some(TypeNsDef {\n-                                            module_def: Some(copy module_def),\n+                                            module_def: Some(module_def),\n                                             _\n                                         }) => {\n                                             // We already have a module. This\n@@ -2445,7 +2445,7 @@ pub impl Resolver {\n                         None => {\n                             // Continue.\n                         }\n-                        Some(copy value_target) => {\n+                        Some(value_target) => {\n                             dest_import_resolution.value_target =\n                                 Some(value_target);\n                         }\n@@ -2454,7 +2454,7 @@ pub impl Resolver {\n                         None => {\n                             // Continue.\n                         }\n-                        Some(copy type_target) => {\n+                        Some(type_target) => {\n                             dest_import_resolution.type_target =\n                                 Some(type_target);\n                         }\n@@ -2566,7 +2566,7 @@ pub impl Resolver {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n                     match target.bindings.type_def {\n-                        Some(copy type_def) => {\n+                        Some(type_def) => {\n                             match type_def.module_def {\n                                 None => {\n                                     // Not a module.\n@@ -5170,12 +5170,6 @@ pub impl Resolver {\n                                     descr: &str) {\n         match pat_binding_mode {\n             bind_infer => {}\n-            bind_by_copy => {\n-                self.session.span_err(\n-                    pat.span,\n-                    fmt!(\"cannot use `copy` binding mode with %s\",\n-                         descr));\n-            }\n             bind_by_ref(*) => {\n                 self.session.span_err(\n                     pat.span,\n@@ -5316,7 +5310,7 @@ pub fn resolve_crate(session: Session,\n                   -> CrateMap {\n     let resolver = @mut Resolver(session, lang_items, crate);\n     resolver.resolve();\n-    let @Resolver{def_map, export_map2, trait_map, _} = resolver;\n+    let Resolver{def_map, export_map2, trait_map, _} = copy *resolver;\n     CrateMap {\n         def_map: def_map,\n         exp_map2: export_map2,"}, {"sha": "b142dc1ef28d233726ba551bc3a754033308d7fe", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 82, "deletions": 76, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -140,6 +140,11 @@\n  * the various values we copied explicitly.  Note that guards and moves are\n  * just plain incompatible.\n  *\n+ * Some relevant helper functions that manage bindings:\n+ * - `create_bindings_map()`\n+ * - `store_non_ref_bindings()`\n+ * - `insert_lllocals()`\n+ *\n  */\n \n use core::prelude::*;\n@@ -314,7 +319,6 @@ pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n pub enum TransBindingMode {\n     TrByValue(/*ismove:*/ bool, /*llbinding:*/ ValueRef),\n     TrByRef,\n-    TrByImplicitRef\n }\n \n /**\n@@ -670,8 +674,8 @@ pub fn enter_tup<'r>(bcx: block,\n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-            ast::pat_tup(/*bad*/copy elts) => {\n-                Some(elts)\n+            ast::pat_tup(ref elts) => {\n+                Some(copy *elts)\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n@@ -698,7 +702,7 @@ pub fn enter_tuple_struct<'r>(bcx: block,\n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-            ast::pat_enum(_, Some(/*bad*/copy elts)) => Some(elts),\n+            ast::pat_enum(_, Some(ref elts)) => Some(copy *elts),\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n@@ -881,7 +885,7 @@ fn match_datum(bcx: block, val: ValueRef, pat_id: ast::node_id) -> Datum {\n     //! we should just pass around a Datum and be done with it.\n \n     let ty = node_id_type(bcx, pat_id);\n-    Datum {val: val, ty: ty, mode: datum::ByRef, source: RevokeClean}\n+    Datum {val: val, ty: ty, mode: datum::ByRef(RevokeClean)}\n }\n \n \n@@ -988,7 +992,7 @@ pub fn root_pats_as_necessary(mut bcx: block,\n         let pat_id = br.pats[col].id;\n         if pat_id != 0 {\n             let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n-                               mode: ByRef, source: ZeroMem};\n+                               mode: ByRef(ZeroMem)};\n             bcx = datum.root_and_write_guard(bcx, br.pats[col].span, pat_id, 0);\n         }\n     }\n@@ -1125,10 +1129,10 @@ pub fn compare_values(cx: block,\n     }\n }\n \n-pub fn store_non_ref_bindings(bcx: block,\n-                              data: &ArmData,\n-                              opt_temp_cleanups: Option<&mut ~[ValueRef]>)\n-    -> block\n+fn store_non_ref_bindings(bcx: block,\n+                          bindings_map: &BindingsMap,\n+                          mut opt_temp_cleanups: Option<&mut ~[ValueRef]>)\n+                          -> block\n {\n     /*!\n      *\n@@ -1140,13 +1144,12 @@ pub fn store_non_ref_bindings(bcx: block,\n      */\n \n     let mut bcx = bcx;\n-    let mut opt_temp_cleanups = opt_temp_cleanups;\n-    for data.bindings_map.each_value |&binding_info| {\n+    for bindings_map.each_value |&binding_info| {\n         match binding_info.trmode {\n             TrByValue(is_move, lldest) => {\n                 let llval = Load(bcx, binding_info.llmatch); // get a T*\n                 let datum = Datum {val: llval, ty: binding_info.ty,\n-                                   mode: ByRef, source: ZeroMem};\n+                                   mode: ByRef(ZeroMem)};\n                 bcx = {\n                     if is_move {\n                         datum.move_to(bcx, INIT, lldest)\n@@ -1161,22 +1164,28 @@ pub fn store_non_ref_bindings(bcx: block,\n                     temp_cleanups\n                 }\n             }\n-            TrByRef | TrByImplicitRef => {}\n+            TrByRef => {}\n         }\n     }\n     return bcx;\n }\n \n-pub fn insert_lllocals(bcx: block,\n-                       data: &ArmData,\n-                       add_cleans: bool) -> block {\n+fn insert_lllocals(bcx: block,\n+                   bindings_map: &BindingsMap,\n+                   binding_mode: IrrefutablePatternBindingMode,\n+                   add_cleans: bool) -> block {\n     /*!\n-     *\n      * For each binding in `data.bindings_map`, adds an appropriate entry into\n      * the `fcx.lllocals` map.  If add_cleans is true, then adds cleanups for\n-     * the bindings. */\n+     * the bindings.\n+     */\n \n-    for data.bindings_map.each_value |&binding_info| {\n+    let llmap = match binding_mode {\n+        BindLocal => bcx.fcx.lllocals,\n+        BindArgument => bcx.fcx.llargs\n+    };\n+\n+    for bindings_map.each_value |&binding_info| {\n         let llval = match binding_info.trmode {\n             // By value bindings: use the stack slot that we\n             // copied/moved the value into\n@@ -1192,17 +1201,12 @@ pub fn insert_lllocals(bcx: block,\n             TrByRef => {\n                 binding_info.llmatch\n             }\n-\n-            // Ugly: for implicit ref, we actually want a T*, but\n-            // we have a T**, so we had to load.  This will go away\n-            // once implicit refs go away.\n-            TrByImplicitRef => {\n-                Load(bcx, binding_info.llmatch)\n-            }\n         };\n \n-        bcx.fcx.lllocals.insert(binding_info.id,\n-                                local_mem(llval));\n+        debug!(\"binding %? to %s\",\n+               binding_info.id,\n+               val_str(bcx.ccx().tn, llval));\n+        llmap.insert(binding_info.id, llval);\n     }\n     return bcx;\n }\n@@ -1223,8 +1227,8 @@ pub fn compile_guard(bcx: block,\n \n     let mut bcx = bcx;\n     let mut temp_cleanups = ~[];\n-    bcx = store_non_ref_bindings(bcx, data, Some(&mut temp_cleanups));\n-    bcx = insert_lllocals(bcx, data, false);\n+    bcx = store_non_ref_bindings(bcx, &data.bindings_map, Some(&mut temp_cleanups));\n+    bcx = insert_lllocals(bcx, &data.bindings_map, BindLocal, false);\n \n     let val = unpack_result!(bcx, {\n         do with_scope_result(bcx, guard_expr.info(),\n@@ -1254,7 +1258,7 @@ pub fn compile_guard(bcx: block,\n                 TrByValue(_, llval) => {\n                     bcx = glue::drop_ty(bcx, llval, binding_info.ty);\n                 }\n-                TrByRef | TrByImplicitRef => {}\n+                TrByRef => {}\n             }\n             bcx.fcx.lllocals.remove(&binding_info.id);\n         }\n@@ -1621,6 +1625,42 @@ pub fn trans_match(bcx: block,\n     }\n }\n \n+fn create_bindings_map(bcx: block, pat: @ast::pat) -> BindingsMap {\n+    // Create the bindings map, which is a mapping from each binding name\n+    // to an alloca() that will be the value for that local variable.\n+    // Note that we use the names because each binding will have many ids\n+    // from the various alternatives.\n+    let ccx = bcx.ccx();\n+    let tcx = bcx.tcx();\n+    let mut bindings_map = HashMap::new();\n+    do pat_bindings(tcx.def_map, pat) |bm, p_id, _s, path| {\n+        let ident = path_to_ident(path);\n+        let variable_ty = node_id_type(bcx, p_id);\n+        let llvariable_ty = type_of::type_of(ccx, variable_ty);\n+\n+        let llmatch, trmode;\n+        match bm {\n+            ast::bind_infer => {\n+                // in this case, the final type of the variable will be T,\n+                // but during matching we need to store a *T as explained\n+                // above\n+                let is_move = ccx.maps.moves_map.contains(&p_id);\n+                llmatch = alloca(bcx, T_ptr(llvariable_ty));\n+                trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n+            }\n+            ast::bind_by_ref(_) => {\n+                llmatch = alloca(bcx, llvariable_ty);\n+                trmode = TrByRef;\n+            }\n+        };\n+        bindings_map.insert(ident, BindingInfo {\n+            llmatch: llmatch, trmode: trmode,\n+            id: p_id, ty: variable_ty\n+        });\n+    }\n+    return bindings_map;\n+}\n+\n pub fn trans_match_inner(scope_cx: block,\n                          discr_expr: @ast::expr,\n                          arms: &[ast::arm],\n@@ -1637,41 +1677,9 @@ pub fn trans_match_inner(scope_cx: block,\n     }\n \n     let mut arm_datas = ~[], matches = ~[];\n-    for arms.each |arm| {\n+    for vec::each(arms) |arm| {\n         let body = scope_block(bcx, arm.body.info(), \"case_body\");\n-\n-        // Create the bindings map, which is a mapping from each binding name\n-        // to an alloca() that will be the value for that local variable.\n-        // Note that we use the names because each binding will have many ids\n-        // from the various alternatives.\n-        let mut bindings_map = HashMap::new();\n-        do pat_bindings(tcx.def_map, arm.pats[0]) |bm, p_id, _s, path| {\n-            let ident = path_to_ident(path);\n-            let variable_ty = node_id_type(bcx, p_id);\n-            let llvariable_ty = type_of::type_of(bcx.ccx(), variable_ty);\n-\n-            let llmatch, trmode;\n-            match bm {\n-                ast::bind_by_copy | ast::bind_infer => {\n-                    // in this case, the final type of the variable will be T,\n-                    // but during matching we need to store a *T as explained\n-                    // above\n-                    let is_move =\n-                        scope_cx.ccx().maps.moves_map.contains(&p_id);\n-                    llmatch = alloca(bcx, T_ptr(llvariable_ty));\n-                    trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n-                }\n-                ast::bind_by_ref(_) => {\n-                    llmatch = alloca(bcx, llvariable_ty);\n-                    trmode = TrByRef;\n-                }\n-            };\n-            bindings_map.insert(ident, BindingInfo {\n-                llmatch: llmatch, trmode: trmode,\n-                id: p_id, ty: variable_ty\n-            });\n-        }\n-\n+        let bindings_map = create_bindings_map(bcx, arm.pats[0]);\n         let arm_data = @ArmData {bodycx: body,\n                                  arm: arm,\n                                  bindings_map: bindings_map};\n@@ -1693,7 +1701,7 @@ pub fn trans_match_inner(scope_cx: block,\n             None\n         }\n     };\n-    let lldiscr = discr_datum.to_ref_llval(bcx);\n+    let lldiscr = discr_datum.to_zeroable_ref_llval(bcx);\n     compile_submatch(bcx, matches, [lldiscr], chk);\n \n     let mut arm_cxs = ~[];\n@@ -1705,11 +1713,11 @@ pub fn trans_match_inner(scope_cx: block,\n         // is just to reduce code space.  See extensive comment at the start\n         // of the file for more details.\n         if arm_data.arm.guard.is_none() {\n-            bcx = store_non_ref_bindings(bcx, *arm_data, None);\n+            bcx = store_non_ref_bindings(bcx, &arm_data.bindings_map, None);\n         }\n \n         // insert bindings into the lllocals map and add cleanups\n-        bcx = insert_lllocals(bcx, *arm_data, true);\n+        bcx = insert_lllocals(bcx, &arm_data.bindings_map, BindLocal, true);\n \n         bcx = controlflow::trans_block(bcx, &arm_data.arm.body, dest);\n         bcx = trans_block_cleanups(bcx, block_cleanups(arm_data.bodycx));\n@@ -1757,27 +1765,25 @@ pub fn bind_irrefutable_pat(bcx: block,\n             if make_copy {\n                 let binding_ty = node_id_type(bcx, pat.id);\n                 let datum = Datum {val: val, ty: binding_ty,\n-                                   mode: ByRef, source: RevokeClean};\n+                                   mode: ByRef(RevokeClean)};\n                 let scratch = scratch_datum(bcx, binding_ty, false);\n                 datum.copy_to_datum(bcx, INIT, scratch);\n                 match binding_mode {\n                     BindLocal => {\n-                        bcx.fcx.lllocals.insert(pat.id,\n-                                                local_mem(scratch.val));\n+                        bcx.fcx.lllocals.insert(pat.id, scratch.val);\n                     }\n                     BindArgument => {\n-                        bcx.fcx.llargs.insert(pat.id,\n-                                              local_mem(scratch.val));\n+                        bcx.fcx.llargs.insert(pat.id, scratch.val);\n                     }\n                 }\n                 add_clean(bcx, scratch.val, binding_ty);\n             } else {\n                 match binding_mode {\n                     BindLocal => {\n-                        bcx.fcx.lllocals.insert(pat.id, local_mem(val));\n+                        bcx.fcx.lllocals.insert(pat.id, val);\n                     }\n                     BindArgument => {\n-                        bcx.fcx.llargs.insert(pat.id, local_mem(val));\n+                        bcx.fcx.llargs.insert(pat.id, val);\n                     }\n                 }\n             }"}, {"sha": "539dc3e1f00098f3bc505913894a3456fbae1f51", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -1105,8 +1105,8 @@ pub fn init_local(bcx: block, local: @ast::local) -> block {\n         }\n     }\n \n-    let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n-        Some(&local_mem(v)) => v,\n+    let llptr = match bcx.fcx.lllocals.find_copy(&local.node.id) {\n+        Some(v) => v,\n         _ => {\n             bcx.tcx().sess.span_bug(local.span,\n                                     \"init_local: Someone forgot to document why it's\\\n@@ -1432,7 +1432,7 @@ pub fn alloc_local(cx: block, local: @ast::local) -> block {\n             });\n         }\n     }\n-    cx.fcx.lllocals.insert(local.node.id, local_mem(val));\n+    cx.fcx.lllocals.insert(local.node.id, val);\n     cx\n }\n \n@@ -1726,7 +1726,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n     let mut bcx = bcx;\n \n     match fcx.llself {\n-      Some(copy slf) => {\n+      Some(slf) => {\n         // We really should do this regardless of whether self is owned, but\n         // it doesn't work right with default method impls yet. (FIXME: #2794)\n         if slf.is_owned {\n@@ -1768,7 +1768,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n                                           false,\n                                           _match::BindArgument);\n \n-        fcx.llargs.insert(arg_id, local_mem(llarg));\n+        fcx.llargs.insert(arg_id, llarg);\n \n         if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n             debuginfo::create_arg(bcx, args[arg_n], args[arg_n].ty.span);\n@@ -1801,7 +1801,7 @@ pub fn build_return_block(fcx: fn_ctxt) {\n pub fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     let _icx = fcx.insn_ctxt(\"tie_up_header_blocks\");\n     match fcx.llloadenv {\n-        Some(copy ll) => {\n+        Some(ll) => {\n             Br(raw_block(fcx, false, fcx.llstaticallocas), ll);\n             Br(raw_block(fcx, false, ll), lltop);\n         }\n@@ -2004,7 +2004,7 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n         let llarg = match fcx.llargs.find(&va.id) {\n-            Some(&local_mem(x)) => x,\n+            Some(&x) => x,\n             _ => fail!(\"trans_enum_variant: how do we know this works?\"),\n         };\n         let arg_ty = arg_tys[i];\n@@ -2074,12 +2074,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n                                              fcx.llretptr.get(),\n                                              0,\n                                              i);\n-        let llarg = match fcx.llargs.get_copy(&field.node.id) {\n-            local_mem(x) => x,\n-            _ => {\n-                ccx.tcx.sess.bug(\"trans_tuple_struct: llarg wasn't local_mem\")\n-            }\n-        };\n+        let llarg = fcx.llargs.get_copy(&field.node.id);\n         let arg_ty = arg_tys[i];\n         memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n     }"}, {"sha": "557388cf11cce87d1afe7e15357d8e20caa4a696", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -711,8 +711,7 @@ pub fn trans_arg_expr(bcx: block,\n                     DatumBlock {bcx: bcx,\n                                 datum: Datum {val: scratch,\n                                               ty: scratch_ty,\n-                                              mode: ByRef,\n-                                              source: RevokeClean}}\n+                                              mode: ByRef(RevokeClean)}}\n                 }\n                 _ => {\n                     bcx.sess().impossible_case(\n@@ -775,7 +774,7 @@ pub fn trans_arg_expr(bcx: block,\n \n                         match arg_datum.appropriate_mode() {\n                             ByValue => val = Load(bcx, scratch.val),\n-                            ByRef => val = scratch.val,\n+                            ByRef(_) => val = scratch.val,\n                         }\n                     }\n                 }"}, {"sha": "1a78019f289f0f9cfd688b154eea5cda8daab556", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -287,7 +287,7 @@ pub fn build_closure(bcx0: block,\n     for include_ret_handle.each |flagptr| {\n         // Flag indicating we have returned (a by-ref bool):\n         let flag_datum = Datum {val: *flagptr, ty: ty::mk_bool(),\n-                                mode: ByRef, source: ZeroMem};\n+                                mode: ByRef(ZeroMem)};\n         env_vals.push(EnvValue {action: EnvRef,\n                                 datum: flag_datum});\n \n@@ -299,7 +299,7 @@ pub fn build_closure(bcx0: block,\n         };\n         let ret_casted = PointerCast(bcx, ret_true, T_ptr(T_nil()));\n         let ret_datum = Datum {val: ret_casted, ty: ty::mk_nil(),\n-                               mode: ByRef, source: ZeroMem};\n+                               mode: ByRef(ZeroMem)};\n         env_vals.push(EnvValue {action: EnvRef,\n                                 datum: ret_datum});\n     }"}, {"sha": "a2fa840ad79b92180b18098d6d9e7c1a2bb1d86b", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -240,8 +240,6 @@ pub struct ValSelfData {\n     is_owned: bool\n }\n \n-pub enum local_val { local_mem(ValueRef), local_imm(ValueRef), }\n-\n // Here `self_ty` is the real type of the self parameter to this method. It\n // will only be set in the case of default methods.\n pub struct param_substs {\n@@ -328,10 +326,10 @@ pub struct fn_ctxt_ {\n     has_immediate_return_value: bool,\n \n     // Maps arguments to allocas created for them in llallocas.\n-    llargs: @mut HashMap<ast::node_id, local_val>,\n+    llargs: @mut HashMap<ast::node_id, ValueRef>,\n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n-    lllocals: @mut HashMap<ast::node_id, local_val>,\n+    lllocals: @mut HashMap<ast::node_id, ValueRef>,\n     // Same as above, but for closure upvars\n     llupvars: @mut HashMap<ast::node_id, ValueRef>,\n "}, {"sha": "c0403083ce1c964d40d8c5f74b0039f73d0d0351", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 84, "deletions": 70, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -44,15 +44,17 @@\n  * # Datum cleanup styles\n  *\n  * Each datum carries with it an idea of how its value will be cleaned\n- * up.  This is important after a move, because we need to know how to\n- * cancel the cleanup (since the value has been moved and therefore does\n- * not need to be freed).  There are two options:\n- *\n- * 1. `RevokeClean`: To cancel the cleanup, we invoke `revoke_clean()`.\n- *    This is used for temporary rvalues.\n- *\n- * 2. `ZeroMem`: To cancel the cleanup, we zero out the memory where\n- *    the value resides.  This is used for lvalues.\n+ * up.  This is primarily determined by the mode: a `ByValue` datum\n+ * will always be cleaned up by revoking cleanup using\n+ * `revoke_clean()`, because there is no other option. By ref datums\n+ * can sometimes be cleaned up via `revoke_clean` (in particular,\n+ * by-ref datums that originated from rvalues), but sometimes they\n+ * must be zeroed. This is indicated by the `DatumCleanup`\n+ * parameter. Note that zeroing a by-ref datum *always works* to\n+ * cancel the cleanup, but using `revoke_clean` is preferable since\n+ * there is no runtime cost. Some older parts of the code (notably\n+ * `match_`, at least at the time of this writing) rely on this and\n+ * only use zeroing.\n  *\n  * # Copying, moving, and storing\n  *\n@@ -103,7 +105,6 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n-use core::to_bytes;\n use core::uint;\n use syntax::ast;\n use syntax::codemap::span;\n@@ -125,54 +126,44 @@ pub struct Datum {\n \n     /// Indicates whether this is by-ref or by-value.\n     mode: DatumMode,\n-\n-    /// How did this value originate?  This is particularly important\n-    /// if the value is MOVED or prematurely DROPPED, because it\n-    /// describes how to cancel the cleanup that was scheduled before.\n-    /// See the def'n of the `DatumCleanup` type.\n-    source: DatumCleanup\n }\n \n pub struct DatumBlock {\n     bcx: block,\n     datum: Datum,\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum DatumMode {\n-    /// `val` is a pointer to the actual value (and thus has type *T)\n-    ByRef,\n+    /// `val` is a pointer to the actual value (and thus has type *T).\n+    /// The argument indicates how to cancel cleanup of this datum if\n+    /// the value is moved elsewhere, which can either be by zeroing\n+    /// the memory or by canceling a registered cleanup.\n+    ByRef(DatumCleanup),\n \n     /// `val` is the actual value (*only used for immediates* like ints, ptrs)\n     ByValue,\n }\n \n pub impl DatumMode {\n     fn is_by_ref(&self) -> bool {\n-        match *self { ByRef => true, ByValue => false }\n+        match *self { ByRef(_) => true, ByValue => false }\n     }\n \n     fn is_by_value(&self) -> bool {\n-        match *self { ByRef => false, ByValue => true }\n-    }\n-}\n-\n-impl to_bytes::IterBytes for DatumMode {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as uint).iter_bytes(lsb0, f)\n+        match *self { ByRef(_) => false, ByValue => true }\n     }\n }\n \n /// See `Datum cleanup styles` section at the head of this module.\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum DatumCleanup {\n     RevokeClean,\n     ZeroMem\n }\n \n pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum {\n-    return Datum {val: val, ty: ty,\n-                  mode: ByValue, source: RevokeClean};\n+    return Datum {val: val, ty: ty, mode: ByValue};\n }\n \n pub fn immediate_rvalue_bcx(bcx: block,\n@@ -195,7 +186,7 @@ pub fn scratch_datum(bcx: block, ty: ty::t, zero: bool) -> Datum {\n \n     let llty = type_of::type_of(bcx.ccx(), ty);\n     let scratch = alloca_maybe_zeroed(bcx, llty, zero);\n-    Datum { val: scratch, ty: ty, mode: ByRef, source: RevokeClean }\n+    Datum { val: scratch, ty: ty, mode: ByRef(RevokeClean) }\n }\n \n pub fn appropriate_mode(ty: ty::t) -> DatumMode {\n@@ -210,7 +201,7 @@ pub fn appropriate_mode(ty: ty::t) -> DatumMode {\n     } else if ty::type_is_immediate(ty) {\n         ByValue\n     } else {\n-        ByRef\n+        ByRef(RevokeClean)\n     }\n }\n \n@@ -289,7 +280,7 @@ pub impl Datum {\n             ty::type_needs_drop(bcx.tcx(), self.ty)\n         {\n             match self.mode {\n-                ByRef => {\n+                ByRef(_) => {\n                     let cast = PointerCast(bcx, dst, val_ty(self.val));\n                     let cmp = ICmp(bcx, lib::llvm::IntNE, cast, self.val);\n                     do with_cond(bcx, cmp) |bcx| {\n@@ -324,7 +315,7 @@ pub impl Datum {\n             ByValue => {\n                 Store(bcx, self.val, dst);\n             }\n-            ByRef => {\n+            ByRef(_) => {\n                 memcpy_ty(bcx, dst, self.val, self.ty);\n             }\n         }\n@@ -352,7 +343,7 @@ pub impl Datum {\n         }\n \n         match self.mode {\n-            ByRef => {\n+            ByRef(_) => {\n                 memcpy_ty(bcx, dst, self.val, self.ty);\n             }\n             ByValue => {\n@@ -367,28 +358,32 @@ pub impl Datum {\n \n     fn add_clean(&self, bcx: block) {\n         /*!\n-         *\n          * Schedules this datum for cleanup in `bcx`.  The datum\n-         * must be an rvalue. */\n+         * must be an rvalue.\n+         */\n \n-        assert_eq!(self.source, RevokeClean);\n         match self.mode {\n             ByValue => {\n                 add_clean_temp_immediate(bcx, self.val, self.ty);\n             }\n-            ByRef => {\n+            ByRef(RevokeClean) => {\n                 add_clean_temp_mem(bcx, self.val, self.ty);\n             }\n+            ByRef(ZeroMem) => {\n+                bcx.tcx().sess.bug(\n+                    fmt!(\"Cannot add clean to a 'zero-mem' datum\"));\n+            }\n         }\n     }\n \n     fn cancel_clean(&self, bcx: block) {\n         if ty::type_needs_drop(bcx.tcx(), self.ty) {\n-            match self.source {\n-                RevokeClean => {\n+            match self.mode {\n+                ByValue |\n+                ByRef(RevokeClean) => {\n                     revoke_clean(bcx, self.val);\n                 }\n-                ZeroMem => {\n+                ByRef(ZeroMem) => {\n                     // Lvalues which potentially need to be dropped\n                     // must be passed by ref, so that we can zero them\n                     // out.\n@@ -400,11 +395,10 @@ pub impl Datum {\n     }\n \n     fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        fmt!(\"Datum { val=%s, ty=%s, mode=%?, source=%? }\",\n+        fmt!(\"Datum { val=%s, ty=%s, mode=%? }\",\n              val_str(ccx.tn, self.val),\n              ty_to_str(ccx.tcx, self.ty),\n-             self.mode,\n-             self.source)\n+             self.mode)\n     }\n \n     fn to_value_datum(&self, bcx: block) -> Datum {\n@@ -417,9 +411,9 @@ pub impl Datum {\n \n         match self.mode {\n             ByValue => *self,\n-            ByRef => {\n+            ByRef(_) => {\n                 Datum {val: self.to_value_llval(bcx), mode: ByValue,\n-                       ty: self.ty, source: RevokeClean}\n+                       ty: self.ty}\n             }\n         }\n     }\n@@ -434,7 +428,7 @@ pub impl Datum {\n         } else {\n             match self.mode {\n                 ByValue => self.val,\n-                ByRef => {\n+                ByRef(_) => {\n                     if ty::type_is_bool(self.ty) {\n                         LoadRangeAssert(bcx, self.val, 0, 2, lib::llvm::True)\n                     } else {\n@@ -447,24 +441,24 @@ pub impl Datum {\n \n     fn to_ref_datum(&self, bcx: block) -> Datum {\n         /*!\n-         *\n          * Yields a by-ref form of this datum.  This may involve\n          * creation of a temporary stack slot.  The value returned by\n          * this function is not separately rooted from this datum, so\n-         * it will not live longer than the current datum. */\n+         * it will not live longer than the current datum.\n+         */\n \n         match self.mode {\n-            ByRef => *self,\n+            ByRef(_) => *self,\n             ByValue => {\n-                Datum {val: self.to_ref_llval(bcx), mode: ByRef,\n-                       ty: self.ty, source: RevokeClean}\n+                Datum {val: self.to_ref_llval(bcx), mode: ByRef(RevokeClean),\n+                       ty: self.ty}\n             }\n         }\n     }\n \n     fn to_ref_llval(&self, bcx: block) -> ValueRef {\n         match self.mode {\n-            ByRef => self.val,\n+            ByRef(_) => self.val,\n             ByValue => {\n                 if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n                     C_null(T_ptr(type_of::type_of(bcx.ccx(), self.ty)))\n@@ -477,6 +471,31 @@ pub impl Datum {\n         }\n     }\n \n+    fn to_zeroable_ref_llval(&self, bcx: block) -> ValueRef {\n+        /*!\n+         * Returns a by-ref llvalue that can be zeroed in order to\n+         * cancel cleanup. This is a kind of hokey bridge used\n+         * to adapt to the match code. Please don't use it for new code.\n+         */\n+\n+        match self.mode {\n+            // All by-ref datums are zeroable, even if we *could* just\n+            // cancel the cleanup.\n+            ByRef(_) => self.val,\n+\n+            // By value datums can't be zeroed (where would you store\n+            // the zero?) so we have to spill them. Add a temp cleanup\n+            // for this spilled value and cancel the cleanup on this\n+            // current value.\n+            ByValue => {\n+                let slot = self.to_ref_llval(bcx);\n+                self.cancel_clean(bcx);\n+                add_clean_temp_mem(bcx, slot, self.ty);\n+                slot\n+            }\n+        }\n+    }\n+\n     fn appropriate_mode(&self) -> DatumMode {\n         /*! See the `appropriate_mode()` function */\n \n@@ -490,7 +509,7 @@ pub impl Datum {\n \n         match self.appropriate_mode() {\n             ByValue => self.to_value_llval(bcx),\n-            ByRef => self.to_ref_llval(bcx)\n+            ByRef(_) => self.to_ref_llval(bcx)\n         }\n     }\n \n@@ -501,7 +520,7 @@ pub impl Datum {\n \n         match self.appropriate_mode() {\n             ByValue => self.to_value_datum(bcx),\n-            ByRef => self.to_ref_datum(bcx)\n+            ByRef(_) => self.to_ref_datum(bcx)\n         }\n     }\n \n@@ -512,9 +531,8 @@ pub impl Datum {\n         let base_val = self.to_ref_llval(bcx);\n         Datum {\n             val: gep(base_val),\n-            mode: ByRef,\n+            mode: ByRef(source),\n             ty: ty,\n-            source: source\n         }\n     }\n \n@@ -524,7 +542,7 @@ pub impl Datum {\n         }\n \n         return match self.mode {\n-            ByRef => glue::drop_ty(bcx, self.val, self.ty),\n+            ByRef(_) => glue::drop_ty(bcx, self.val, self.ty),\n             ByValue => glue::drop_ty_immediate(bcx, self.val, self.ty)\n         };\n     }\n@@ -546,7 +564,7 @@ pub impl Datum {\n \n         let ptr = self.to_value_llval(bcx);\n         let body = opaque_box_body(bcx, content_ty, ptr);\n-        Datum {val: body, ty: content_ty, mode: ByRef, source: ZeroMem}\n+        Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n     }\n \n     fn to_rptr(&self, bcx: block) -> Datum {\n@@ -561,8 +579,7 @@ pub impl Datum {\n         let llval = self.to_ref_llval(bcx);\n         let rptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::re_static,\n                                       self.ty);\n-        Datum {val: llval, ty: rptr_ty,\n-               mode: ByValue, source: RevokeClean}\n+        Datum {val: llval, ty: rptr_ty, mode: ByValue}\n     }\n \n     fn try_deref(&self,\n@@ -606,16 +623,15 @@ pub impl Datum {\n                 let repr = adt::represent_type(ccx, self.ty);\n                 let ty = ty::subst(ccx.tcx, substs, variants[0].args[0]);\n                 return match self.mode {\n-                    ByRef => {\n+                    ByRef(_) => {\n                         // Recast lv.val as a pointer to the newtype\n                         // rather than a ptr to the enum type.\n                         (\n                             Some(Datum {\n                                 val: adt::trans_field_ptr(bcx, repr, self.val,\n                                                     0, 0),\n                                 ty: ty,\n-                                mode: ByRef,\n-                                source: ZeroMem\n+                                mode: ByRef(ZeroMem)\n                             }),\n                             bcx\n                         )\n@@ -645,7 +661,7 @@ pub impl Datum {\n                 let repr = adt::represent_type(ccx, self.ty);\n                 let ty = fields[0].mt.ty;\n                 return match self.mode {\n-                    ByRef => {\n+                    ByRef(_) => {\n                         // Recast lv.val as a pointer to the newtype rather\n                         // than a pointer to the struct type.\n                         // FIXME #6572: This isn't correct for structs with\n@@ -655,8 +671,7 @@ pub impl Datum {\n                                 val: adt::trans_field_ptr(bcx, repr, self.val,\n                                                     0, 0),\n                                 ty: ty,\n-                                mode: ByRef,\n-                                source: ZeroMem\n+                                mode: ByRef(ZeroMem)\n                             }),\n                             bcx\n                         )\n@@ -683,8 +698,7 @@ pub impl Datum {\n             Datum {\n                 val: lv.to_value_llval(bcx),\n                 ty: ty,\n-                mode: ByRef,\n-                source: ZeroMem // *p is an lvalue\n+                mode: ByRef(ZeroMem)\n             }\n         }\n     }"}, {"sha": "6d78e8e03790445f6a9258e702113847880cbca7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -864,17 +864,14 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n     };\n     update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n \n-    let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n-      option::Some(&local_mem(v)) => v,\n-      option::Some(_) => {\n-        bcx.tcx().sess.span_bug(local.span, \"local is bound to something weird\");\n-      }\n-      option::None => {\n-        match bcx.fcx.lllocals.get_copy(&local.node.pat.id) {\n-          local_imm(v) => v,\n-          _ => bcx.tcx().sess.span_bug(local.span, \"local is bound to something weird\")\n+    // FIXME(#6814) Should use `pat_util::pat_bindings` for pats like (a, b) etc\n+    let llptr = match bcx.fcx.lllocals.find_copy(&local.node.pat.id) {\n+        Some(v) => v,\n+        None => {\n+            bcx.tcx().sess.span_bug(\n+                local.span,\n+                fmt!(\"No entry in lllocals table for %?\", local.node.id));\n         }\n-      }\n     };\n     let declargs = ~[llmdnode([llptr]), mdnode];\n     trans::build::Call(bcx, *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n@@ -922,9 +919,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n             };\n             update_cache(cache, tg, argument_metadata(mdval));\n \n-            let llptr = match fcx.llargs.get_copy(&arg.id) {\n-              local_mem(v) | local_imm(v) => v,\n-            };\n+            let llptr = fcx.llargs.get_copy(&arg.id);\n             let declargs = ~[llmdnode([llptr]), mdnode];\n             trans::build::Call(bcx,\n                                *cx.intrinsics.get(&~\"llvm.dbg.declare\"),"}, {"sha": "42ba06aad764eb9e67fb0f9e2f50f60ddf5c46b2", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -247,7 +247,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         // must patchup the type.\n         DatumBlock {bcx: bcx,\n                     datum: Datum {val: datum.val, ty: adjusted_ty,\n-                                  mode: datum.mode, source: datum.source}}\n+                                  mode: datum.mode}}\n     }\n \n     fn auto_slice(bcx: block,\n@@ -793,8 +793,7 @@ fn trans_def_datum_unadjusted(bcx: block,\n             bcx: bcx,\n             datum: Datum {val: llval,\n                           ty: rust_ty,\n-                          mode: ByValue,\n-                          source: RevokeClean}\n+                          mode: ByValue}\n         };\n     }\n }\n@@ -920,8 +919,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n             bcx: bcx,\n             datum: Datum {val: elt,\n                           ty: vt.unit_ty,\n-                          mode: ByRef,\n-                          source: ZeroMem}\n+                          mode: ByRef(ZeroMem)}\n         };\n     }\n \n@@ -988,8 +986,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                     bcx: bcx,\n                     datum: Datum {val: val,\n                                   ty: const_ty,\n-                                  mode: ByRef,\n-                                  source: ZeroMem}\n+                                  mode: ByRef(ZeroMem)}\n                 }\n             }\n             _ => {\n@@ -1014,8 +1011,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n                     Datum {\n                         val: val,\n                         ty: local_ty,\n-                        mode: ByRef,\n-                        source: ZeroMem\n+                        mode: ByRef(ZeroMem)\n                     }\n                 }\n                 None => {\n@@ -1052,8 +1048,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n             Datum {\n                 val: casted_val,\n                 ty: self_info.t,\n-                mode: ByRef,\n-                source: ZeroMem\n+                mode: ByRef(ZeroMem)\n             }\n         }\n         _ => {\n@@ -1063,26 +1058,22 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n     };\n \n     fn take_local(bcx: block,\n-                  table: &HashMap<ast::node_id, local_val>,\n+                  table: &HashMap<ast::node_id, ValueRef>,\n                   nid: ast::node_id) -> Datum {\n-        let (v, mode) = match table.find(&nid) {\n-            Some(&local_mem(v)) => (v, ByRef),\n-            Some(&local_imm(v)) => (v, ByValue),\n+        let v = match table.find(&nid) {\n+            Some(&v) => v,\n             None => {\n                 bcx.sess().bug(fmt!(\n                     \"trans_local_var: no llval for local/arg %? found\", nid));\n             }\n         };\n         let ty = node_id_type(bcx, nid);\n-\n-        debug!(\"take_local(nid=%?, v=%s, mode=%?, ty=%s)\",\n-               nid, bcx.val_str(v), mode, bcx.ty_to_str(ty));\n-\n+        debug!(\"take_local(nid=%?, v=%s, ty=%s)\",\n+               nid, bcx.val_str(v), bcx.ty_to_str(ty));\n         Datum {\n             val: v,\n             ty: ty,\n-            mode: mode,\n-            source: ZeroMem\n+            mode: ByRef(ZeroMem)\n         }\n     }\n }"}, {"sha": "ae68a28de97df51fd2676061d8ed7fb60a466aa3", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -692,19 +692,15 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                   fcx.llretptr.get());\n         }\n         ~\"move_val\" => {\n-            // Create a datum reflecting the value being moved:\n-            //\n-            // - the datum will be by ref if the value is non-immediate;\n-            //\n-            // - the datum has a RevokeClean source because, that way,\n-            //   the `move_to()` method does not feel compelled to\n-            //   zero out the memory where the datum resides.  Zeroing\n-            //   is not necessary since, for intrinsics, there is no\n-            //   cleanup to concern ourselves with.\n+            // Create a datum reflecting the value being moved.\n+            // Use `appropriate_mode` so that the datum is by ref\n+            // if the value is non-immediate. Note that, with\n+            // intrinsics, there are no argument cleanups to\n+            // concern ourselves with.\n             let tp_ty = substs.tys[0];\n             let mode = appropriate_mode(tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: mode, source: RevokeClean};\n+                             ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, DROP_EXISTING,\n                               get_param(decl, first_real_arg));\n         }\n@@ -713,7 +709,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let tp_ty = substs.tys[0];\n             let mode = appropriate_mode(tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: mode, source: RevokeClean};\n+                             ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n         }\n         ~\"min_align_of\" => {\n@@ -832,7 +828,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 }\n             });\n             let datum = Datum {val: get_param(decl, first_real_arg),\n-                               mode: ByRef, ty: fty, source: ZeroMem};\n+                               mode: ByRef(ZeroMem), ty: fty};\n             let arg_vals = ~[frameaddress_val];\n             bcx = trans_call_inner(\n                 bcx, None, fty, ty::mk_nil(),"}, {"sha": "023d931a60b95e9dad0f0825903ad7184bb53899", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -197,7 +197,7 @@ pub fn trans_method_callee(bcx: block,\n     // Replace method_self with method_static here.\n     let mut origin = mentry.origin;\n     match origin {\n-        typeck::method_self(copy trait_id, copy method_index) => {\n+        typeck::method_self(trait_id, method_index) => {\n             // Get the ID of the impl we're inside.\n             let impl_def_id = bcx.fcx.impl_id.get();\n \n@@ -445,7 +445,7 @@ pub fn method_ty_param_count(ccx: @CrateContext, m_id: ast::def_id,\n                                             _, _)) => {\n                 m.generics.ty_params.len()\n             }\n-            copy e => fail!(\"method_ty_param_count %?\", e)\n+            ref e => fail!(\"method_ty_param_count %?\", *e)\n         }\n     } else {\n         csearch::get_type_param_count(ccx.sess.cstore, m_id) -"}, {"sha": "77b2586781f11fd8b223f5587c639777eb4bff50", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -85,8 +85,8 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n     }\n \n     if fn_id_loc.crate != local_crate {\n-        let Context { uses: @uses, _ } = cx;\n-        let uses = @uses; // mutability\n+        let Context { uses, _ } = cx;\n+        let uses = @copy *uses; // freeze\n         ccx.type_use_cache.insert(fn_id, uses);\n         return uses;\n     }\n@@ -173,8 +173,8 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n                                 ccx.tcx.sess.parse_sess.interner)));\n       }\n     }\n-    let Context { uses: @uses, _ } = cx;\n-    let uses = @uses; // mutability\n+    let Context { uses, _ } = cx;\n+    let uses = @copy *uses; // freeze\n     ccx.type_use_cache.insert(fn_id, uses);\n     uses\n }"}, {"sha": "13102093cd6403ef861c6bc6f58fcfe7b5779777", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -450,7 +450,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             demand::eqtype(fcx, pat.span, region_ty, typ);\n           }\n           // otherwise the type of x is the expected type T\n-          ast::bind_by_copy | ast::bind_infer => {\n+          ast::bind_infer => {\n             demand::eqtype(fcx, pat.span, expected, typ);\n           }\n         }"}, {"sha": "3cb028b811e22d9262adfa5c0362da6cb6c95bb3", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -308,7 +308,7 @@ pub impl CoherenceChecker {\n                             implementation =\n                                 self.create_impl_from_item(item);\n                         }\n-                        Some(copy existing_implementation) => {\n+                        Some(existing_implementation) => {\n                             implementation = existing_implementation;\n                         }\n                     }"}, {"sha": "bfe82a015cd0e16b1f8d5178c9df081b0438ab25", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -1933,7 +1933,7 @@ mod tests {\n     #[test]\n     fn file_reader_not_exist() {\n         match io::file_reader(&Path(\"not a file\")) {\n-          result::Err(copy e) => {\n+          result::Err(e) => {\n             assert_eq!(e, ~\"error opening not a file\");\n           }\n           result::Ok(_) => fail!()\n@@ -1974,7 +1974,7 @@ mod tests {\n     #[test]\n     fn file_writer_bad_name() {\n         match io::file_writer(&Path(\"?/?\"), []) {\n-          result::Err(copy e) => {\n+          result::Err(e) => {\n             assert!(str::starts_with(e, \"error opening\"));\n           }\n           result::Ok(_) => fail!()\n@@ -1984,7 +1984,7 @@ mod tests {\n     #[test]\n     fn buffered_file_writer_bad_name() {\n         match io::buffered_file_writer(&Path(\"?/?\")) {\n-          result::Err(copy e) => {\n+          result::Err(e) => {\n             assert!(str::starts_with(e, \"error opening\"));\n           }\n           result::Ok(_) => fail!()"}, {"sha": "ee6e37aeb783ee13f94972b7e747796bd8f51f86", "filename": "src/libstd/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -341,15 +341,15 @@ pub impl<T:Copy> Option<T> {\n     #[inline(always)]\n     fn get(self) -> T {\n         match self {\n-          Some(copy x) => return x,\n+          Some(x) => return x,\n           None => fail!(\"option::get none\")\n         }\n     }\n \n     /// Returns the contained value or a default\n     #[inline(always)]\n     fn get_or_default(self, def: T) -> T {\n-        match self { Some(copy x) => x, None => def }\n+        match self { Some(x) => x, None => def }\n     }\n \n     /// Applies a function zero or more times until the result is none.\n@@ -366,7 +366,7 @@ pub impl<T:Copy + Zero> Option<T> {\n     /// Returns the contained value or zero (for this type)\n     #[inline(always)]\n     fn get_or_zero(self) -> T {\n-        match self { Some(copy x) => x, None => Zero::zero() }\n+        match self { Some(x) => x, None => Zero::zero() }\n     }\n }\n "}, {"sha": "9eb7b54f009a7d18e7f16d42f26bb55928feae42", "filename": "src/libstd/path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -774,9 +774,9 @@ impl GenericPath for WindowsPath {\n \n         /* if rhs has a host set, then the whole thing wins */\n         match other.host {\n-            Some(copy host) => {\n+            Some(ref host) => {\n                 return WindowsPath {\n-                    host: Some(host),\n+                    host: Some(copy *host),\n                     device: copy other.device,\n                     is_absolute: true,\n                     components: copy other.components,\n@@ -787,10 +787,10 @@ impl GenericPath for WindowsPath {\n \n         /* if rhs has a device set, then a part wins */\n         match other.device {\n-            Some(copy device) => {\n+            Some(ref device) => {\n                 return WindowsPath {\n                     host: None,\n-                    device: Some(device),\n+                    device: Some(copy *device),\n                     is_absolute: true,\n                     components: copy other.components,\n                 };"}, {"sha": "5b40b09e98e84f8c41de73676d4903617c09fd87", "filename": "src/libstd/result.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -40,7 +40,7 @@ pub enum Result<T, U> {\n #[inline(always)]\n pub fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n     match *res {\n-      Ok(copy t) => t,\n+      Ok(ref t) => copy *t,\n       Err(ref the_err) =>\n         fail!(\"get called on error result: %?\", *the_err)\n     }\n@@ -72,7 +72,7 @@ pub fn get_ref<'a, T, U>(res: &'a Result<T, U>) -> &'a T {\n #[inline(always)]\n pub fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n     match *res {\n-      Err(copy u) => u,\n+      Err(ref u) => copy *u,\n       Ok(_) => fail!(\"get_err called on ok result\")\n     }\n }\n@@ -102,8 +102,8 @@ pub fn is_err<T, U>(res: &Result<T, U>) -> bool {\n pub fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n     -> Either<T, U> {\n     match *res {\n-      Ok(copy res) => either::Right(res),\n-      Err(copy fail_) => either::Left(fail_)\n+      Ok(ref res) => either::Right(copy *res),\n+      Err(ref fail_) => either::Left(copy *fail_)\n     }\n }\n \n@@ -206,7 +206,7 @@ pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n   -> Result<U, E> {\n     match *res {\n       Ok(ref t) => Ok(op(t)),\n-      Err(copy e) => Err(e)\n+      Err(ref e) => Err(copy *e)\n     }\n }\n \n@@ -222,7 +222,7 @@ pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n   -> Result<T, F> {\n     match *res {\n-      Ok(copy t) => Ok(t),\n+      Ok(ref t) => Ok(copy *t),\n       Err(ref e) => Err(op(e))\n     }\n }\n@@ -304,8 +304,8 @@ pub fn map_vec<T,U:Copy,V:Copy>(\n     let mut vs: ~[V] = vec::with_capacity(vec::len(ts));\n     for ts.each |t| {\n         match op(t) {\n-          Ok(copy v) => vs.push(v),\n-          Err(copy u) => return Err(u)\n+          Ok(v) => vs.push(v),\n+          Err(u) => return Err(u)\n         }\n     }\n     return Ok(vs);\n@@ -319,8 +319,8 @@ pub fn map_opt<T,U:Copy,V:Copy>(\n     match *o_t {\n       None => Ok(None),\n       Some(ref t) => match op(t) {\n-        Ok(copy v) => Ok(Some(v)),\n-        Err(copy e) => Err(e)\n+        Ok(v) => Ok(Some(v)),\n+        Err(e) => Err(e)\n       }\n     }\n }\n@@ -344,8 +344,8 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n     let mut i = 0u;\n     while i < n {\n         match op(&ss[i],&ts[i]) {\n-          Ok(copy v) => vs.push(v),\n-          Err(copy u) => return Err(u)\n+          Ok(v) => vs.push(v),\n+          Err(u) => return Err(u)\n         }\n         i += 1u;\n     }\n@@ -367,7 +367,7 @@ pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n     while i < n {\n         match op(&ss[i],&ts[i]) {\n           Ok(()) => (),\n-          Err(copy u) => return Err(u)\n+          Err(u) => return Err(u)\n         }\n         i += 1u;\n     }"}, {"sha": "676a57e38daa39080a9f8bc485aca4e3fff1d1f1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -257,21 +257,20 @@ pub struct field_pat {\n \n #[deriving(Eq, Encodable, Decodable)]\n pub enum binding_mode {\n-    bind_by_copy,\n     bind_by_ref(mutability),\n     bind_infer\n }\n \n impl to_bytes::IterBytes for binding_mode {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n-          bind_by_copy => 0u8.iter_bytes(lsb0, f),\n-\n           bind_by_ref(ref m) => {\n-              1u8.iter_bytes(lsb0, f) && m.iter_bytes(lsb0, f)\n+              0u8.iter_bytes(lsb0, f) && m.iter_bytes(lsb0, f)\n           }\n \n-          bind_infer => 2u8.iter_bytes(lsb0, f),\n+          bind_infer => {\n+              1u8.iter_bytes(lsb0, f)\n+          }\n         }\n     }\n }"}, {"sha": "deff6dc5ba9667315549151bbf43346849913124", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -233,7 +233,7 @@ pub fn ident_to_path(s: span, i: ident) -> @Path {\n \n pub fn ident_to_pat(id: node_id, s: span, i: ident) -> @pat {\n     @ast::pat { id: id,\n-                node: pat_ident(bind_by_copy, ident_to_path(s, i), None),\n+                node: pat_ident(bind_infer, ident_to_path(s, i), None),\n                 span: s }\n }\n "}, {"sha": "85bebebf0f63fc724363b7e2c09845b023994ab8", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -560,7 +560,7 @@ impl AstBuilder for @ExtCtxt {\n         self.pat(span, ast::pat_lit(expr))\n     }\n     fn pat_ident(&self, span: span, ident: ast::ident) -> @ast::pat {\n-        self.pat_ident_binding_mode(span, ident, ast::bind_by_copy)\n+        self.pat_ident_binding_mode(span, ident, ast::bind_infer)\n     }\n \n     fn pat_ident_binding_mode(&self,"}, {"sha": "10fb4b8ecd4a2f8800e52574c61a4e6898116e0f", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -62,11 +62,11 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n         Struct(ref fs) => {\n             fields = fs\n         }\n-        EnumMatching(copy index, ref variant, ref fs) => {\n+        EnumMatching(index, ref variant, ref fs) => {\n             // Determine the discriminant. We will feed this value to the byte\n             // iteration function.\n             let discriminant = match variant.node.disr_expr {\n-                Some(copy d)=> d,\n+                Some(d)=> d,\n                 None => cx.expr_uint(span, index)\n             };\n "}, {"sha": "54d31de7c50d4c3f3bb4937dc58fb76cdd7bbbbf", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -119,7 +119,7 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n                   summary: &Either<uint, ~[ident]>,\n                   rand_call: &fn() -> @expr) -> @expr {\n         match *summary {\n-            Left(copy count) => {\n+            Left(count) => {\n                 if count == 0 {\n                     cx.expr_ident(span, ctor_ident)\n                 } else {"}, {"sha": "91fad0c22a676f9c4487245a14fa8ac67e21f54d", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -58,8 +58,8 @@ pub fn expand_file(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().get());\n-    let Loc { file: @FileMap { name: filename, _ }, _ } =\n-        cx.codemap().lookup_char_pos(topmost.call_site.lo);\n+    let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n+    let filename = copy loc.file.name;\n     base::MRExpr(cx.expr_str(topmost.call_site, filename))\n }\n "}, {"sha": "ec63b5a7f74740e2187570815cf9538d3e174edb", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -423,7 +423,7 @@ pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n       },\n       \"block\" => token::nt_block(p.parse_block()),\n       \"stmt\" => token::nt_stmt(p.parse_stmt(~[])),\n-      \"pat\" => token::nt_pat(p.parse_pat(true)),\n+      \"pat\" => token::nt_pat(p.parse_pat()),\n       \"expr\" => token::nt_expr(p.parse_expr()),\n       \"ty\" => token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)),\n       // this could be handled like a token, since it is one"}, {"sha": "4a6a070df50add6188202d63cd4f6c60c6817c99", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -207,8 +207,8 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n         } else { /* repeat */\n             r.stack.idx = 0u;\n             r.repeat_idx[r.repeat_idx.len() - 1u] += 1u;\n-            match r.stack.sep {\n-              Some(copy tk) => {\n+            match copy r.stack.sep {\n+              Some(tk) => {\n                 r.cur_tok = tk; /* repeat same span, I guess */\n                 return ret_val;\n               }\n@@ -218,8 +218,8 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n     }\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n-        match r.stack.forest[r.stack.idx] {\n-          tt_delim(copy tts) => {\n+        match copy r.stack.forest[r.stack.idx] {\n+          tt_delim(tts) => {\n             r.stack = @mut TtFrame {\n                 forest: @mut tts,\n                 idx: 0u,\n@@ -229,13 +229,13 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n             };\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n-          tt_tok(sp, copy tok) => {\n+          tt_tok(sp, tok) => {\n             r.cur_span = sp;\n             r.cur_tok = tok;\n             r.stack.idx += 1u;\n             return ret_val;\n           }\n-          tt_seq(sp, copy tts, copy sep, zerok) => {\n+          tt_seq(sp, tts, sep, zerok) => {\n             let t = tt_seq(sp, copy tts, copy sep, zerok);\n             match lockstep_iter_size(&t, r) {\n               lis_unconstrained => {"}, {"sha": "9d5cb131fec0f8ef20ead039d3fb945fd9a78ad3", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -485,9 +485,9 @@ mod test {\n \n     #[test] fn parse_ident_pat () {\n         let parser = string_to_parser(@~\"b\");\n-        assert_eq!(parser.parse_pat(false),\n+        assert_eq!(parser.parse_pat(),\n                    @ast::pat{id:1, // fixme\n-                             node: ast::pat_ident(ast::bind_by_copy,\n+                             node: ast::pat_ident(ast::bind_infer,\n                                                   @ast::Path{\n                                                       span:sp(0,1),\n                                                       global:false,\n@@ -516,7 +516,7 @@ mod test {\n                                                        2),\n                                     span:sp(4,7)},\n                        pat: @ast::pat{id:1,\n-                                      node: ast::pat_ident(ast::bind_by_copy,\n+                                      node: ast::pat_ident(ast::bind_infer,\n                                                            @ast::Path{\n                                                                span:sp(0,1),\n                                                                global:false,\n@@ -553,7 +553,7 @@ mod test {\n                                                 span:sp(10,13)},\n                                     pat: @ast::pat{id:1, // fixme\n                                                    node: ast::pat_ident(\n-                                                       ast::bind_by_copy,\n+                                                       ast::bind_infer,\n                                                        @ast::Path{\n                                                            span:sp(6,7),\n                                                            global:false,"}, {"sha": "29f565851b41148c69732a4867c225680c4cd27a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 51, "deletions": 56, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -18,7 +18,7 @@ use ast::{TyBareFn, TyClosure};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{provided, public, purity};\n use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n-use ast::{bind_by_copy, bitand, bitor, bitxor, blk};\n+use ast::{bitand, bitor, bitxor, blk};\n use ast::{blk_check_mode, box};\n use ast::{crate, crate_cfg, decl, decl_item};\n use ast::{decl_local, default_blk, deref, div, enum_def, explicit_self};\n@@ -131,11 +131,11 @@ at INTERPOLATED tokens */\n macro_rules! maybe_whole_expr (\n     ($p:expr) => (\n         match *($p).token {\n-            INTERPOLATED(token::nt_expr(copy e)) => {\n+            INTERPOLATED(token::nt_expr(e)) => {\n                 $p.bump();\n                 return e;\n             }\n-            INTERPOLATED(token::nt_path(copy pt)) => {\n+            INTERPOLATED(token::nt_path(pt)) => {\n                 $p.bump();\n                 return $p.mk_expr(\n                     ($p).span.lo,\n@@ -150,44 +150,44 @@ macro_rules! maybe_whole_expr (\n \n macro_rules! maybe_whole (\n     ($p:expr, $constructor:ident) => (\n-        match *($p).token {\n-            INTERPOLATED(token::$constructor(copy x)) => {\n+        match copy *($p).token {\n+            INTERPOLATED(token::$constructor(x)) => {\n                 $p.bump();\n                 return x;\n             }\n             _ => ()\n        }\n     );\n     (deref $p:expr, $constructor:ident) => (\n-        match *($p).token {\n-            INTERPOLATED(token::$constructor(copy x)) => {\n+        match copy *($p).token {\n+            INTERPOLATED(token::$constructor(x)) => {\n                 $p.bump();\n                 return copy *x;\n             }\n             _ => ()\n         }\n     );\n     (Some $p:expr, $constructor:ident) => (\n-        match *($p).token {\n-            INTERPOLATED(token::$constructor(copy x)) => {\n+        match copy *($p).token {\n+            INTERPOLATED(token::$constructor(x)) => {\n                 $p.bump();\n                 return Some(x);\n             }\n             _ => ()\n         }\n     );\n     (iovi $p:expr, $constructor:ident) => (\n-        match *($p).token {\n-            INTERPOLATED(token::$constructor(copy x)) => {\n+        match copy *($p).token {\n+            INTERPOLATED(token::$constructor(x)) => {\n                 $p.bump();\n                 return iovi_item(x);\n             }\n             _ => ()\n         }\n     );\n     (pair_empty $p:expr, $constructor:ident) => (\n-        match *($p).token {\n-            INTERPOLATED(token::$constructor(copy x)) => {\n+        match copy *($p).token {\n+            INTERPOLATED(token::$constructor(x)) => {\n                 $p.bump();\n                 return (~[], x);\n             }\n@@ -825,7 +825,7 @@ pub impl Parser {\n         let pat = if require_name || self.is_named_argument() {\n             self.parse_arg_mode();\n             is_mutbl = self.eat_keyword(keywords::Mut);\n-            let pat = self.parse_pat(false);\n+            let pat = self.parse_pat();\n             self.expect(&token::COLON);\n             pat\n         } else {\n@@ -853,7 +853,7 @@ pub impl Parser {\n     fn parse_fn_block_arg(&self) -> arg_or_capture_item {\n         self.parse_arg_mode();\n         let is_mutbl = self.eat_keyword(keywords::Mut);\n-        let pat = self.parse_pat(false);\n+        let pat = self.parse_pat();\n         let t = if self.eat(&token::COLON) {\n             self.parse_ty(false)\n         } else {\n@@ -1992,28 +1992,29 @@ pub impl Parser {\n         // them as the lambda arguments\n         let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n         match e.node {\n-            expr_call(f, /*bad*/ copy args, NoSugar) => {\n+            expr_call(f, ref args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                let args = vec::append(args, [last_arg]);\n+                let args = vec::append(copy *args, [last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi, expr_call(f, args, sugar))\n             }\n-            expr_method_call(f, i, /*bad*/ copy tps,\n-                             /*bad*/ copy args, NoSugar) => {\n+            expr_method_call(f, i, ref tps, ref args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                let args = vec::append(args, [last_arg]);\n+                let args = vec::append(copy *args, [last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi,\n-                             expr_method_call(f, i, tps, args, sugar))\n+                             expr_method_call(f, i, copy *tps,\n+                                              args, sugar))\n             }\n-            expr_field(f, i, /*bad*/ copy tps) => {\n+            expr_field(f, i, ref tps) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 self.mk_expr(lo.lo, block.span.hi,\n-                             expr_method_call(f, i, tps, ~[last_arg], sugar))\n+                             expr_method_call(f, i,\n+                                              copy *tps, ~[last_arg], sugar))\n             }\n             expr_path(*) | expr_call(*) | expr_method_call(*) |\n                 expr_paren(*) => {\n@@ -2162,15 +2163,14 @@ pub impl Parser {\n     fn parse_pats(&self) -> ~[@pat] {\n         let mut pats = ~[];\n         loop {\n-            pats.push(self.parse_pat(true));\n+            pats.push(self.parse_pat());\n             if *self.token == token::BINOP(token::OR) { self.bump(); }\n             else { return pats; }\n         };\n     }\n \n     fn parse_pat_vec_elements(\n         &self,\n-        refutable: bool\n     ) -> (~[@pat], Option<@pat>, ~[@pat]) {\n         let mut before = ~[];\n         let mut slice = None;\n@@ -2191,7 +2191,7 @@ pub impl Parser {\n                 }\n             }\n \n-            let subpat = self.parse_pat(refutable);\n+            let subpat = self.parse_pat();\n             if is_slice {\n                 match subpat {\n                     @ast::pat { node: pat_wild, _ } => (),\n@@ -2214,7 +2214,7 @@ pub impl Parser {\n     }\n \n     // parse the fields of a struct-like pattern\n-    fn parse_pat_fields(&self, refutable: bool) -> (~[ast::field_pat], bool) {\n+    fn parse_pat_fields(&self) -> (~[ast::field_pat], bool) {\n         let mut fields = ~[];\n         let mut etc = false;\n         let mut first = true;\n@@ -2244,7 +2244,7 @@ pub impl Parser {\n             let subpat;\n             if *self.token == token::COLON {\n                 self.bump();\n-                subpat = self.parse_pat(refutable);\n+                subpat = self.parse_pat();\n             } else {\n                 subpat = @ast::pat {\n                     id: self.get_id(),\n@@ -2257,10 +2257,8 @@ pub impl Parser {\n         return (fields, etc);\n     }\n \n-    // parse a pattern. The 'refutable' argument\n-    // appears to control whether the binding_mode\n-    // 'bind_infer' or 'bind_by_copy' is used.\n-    fn parse_pat(&self, refutable: bool) -> @pat {\n+    // parse a pattern.\n+    fn parse_pat(&self) -> @pat {\n         maybe_whole!(self, nt_pat);\n \n         let lo = self.span.lo;\n@@ -2272,7 +2270,7 @@ pub impl Parser {\n             // parse @pat\n           token::AT => {\n             self.bump();\n-            let sub = self.parse_pat(refutable);\n+            let sub = self.parse_pat();\n             hi = sub.span.hi;\n             // HACK: parse @\"...\" as a literal of a vstore @str\n             pat = match sub.node {\n@@ -2295,7 +2293,7 @@ pub impl Parser {\n           token::TILDE => {\n             // parse ~pat\n             self.bump();\n-            let sub = self.parse_pat(refutable);\n+            let sub = self.parse_pat();\n             hi = sub.span.hi;\n             // HACK: parse ~\"...\" as a literal of a vstore ~str\n             pat = match sub.node {\n@@ -2319,7 +2317,7 @@ pub impl Parser {\n               // parse &pat\n               let lo = self.span.lo;\n               self.bump();\n-              let sub = self.parse_pat(refutable);\n+              let sub = self.parse_pat();\n               hi = sub.span.hi;\n               // HACK: parse &\"...\" as a literal of a borrowed str\n               pat = match sub.node {\n@@ -2340,7 +2338,7 @@ pub impl Parser {\n           }\n           token::LBRACE => {\n             self.bump();\n-            let (_, _) = self.parse_pat_fields(refutable);\n+            let (_, _) = self.parse_pat_fields();\n             hi = self.span.hi;\n             self.bump();\n             self.obsolete(*self.span, ObsoleteRecordPattern);\n@@ -2358,11 +2356,11 @@ pub impl Parser {\n                 let expr = self.mk_expr(lo, hi, expr_lit(lit));\n                 pat = pat_lit(expr);\n             } else {\n-                let mut fields = ~[self.parse_pat(refutable)];\n+                let mut fields = ~[self.parse_pat()];\n                 if self.look_ahead(1) != token::RPAREN {\n                     while *self.token == token::COMMA {\n                         self.bump();\n-                        fields.push(self.parse_pat(refutable));\n+                        fields.push(self.parse_pat());\n                     }\n                 }\n                 if fields.len() == 1 { self.expect(&token::COMMA); }\n@@ -2375,7 +2373,7 @@ pub impl Parser {\n             // parse [pat,pat,...] as vector pattern\n             self.bump();\n             let (before, slice, after) =\n-                self.parse_pat_vec_elements(refutable);\n+                self.parse_pat_vec_elements();\n             hi = self.span.hi;\n             self.expect(&token::RBRACKET);\n             pat = ast::pat_vec(before, slice, after);\n@@ -2405,15 +2403,13 @@ pub impl Parser {\n             } else if self.eat_keyword(keywords::Ref) {\n                 // parse ref pat\n                 let mutbl = self.parse_mutability();\n-                pat = self.parse_pat_ident(refutable, bind_by_ref(mutbl));\n+                pat = self.parse_pat_ident(bind_by_ref(mutbl));\n             } else if self.eat_keyword(keywords::Copy) {\n                 // parse copy pat\n-                pat = self.parse_pat_ident(refutable, bind_by_copy);\n+                self.warn(\"copy keyword in patterns no longer has any effect, \\\n+                           remove it\");\n+                pat = self.parse_pat_ident(bind_infer);\n             } else {\n-                // XXX---refutable match bindings should work same as let\n-                let binding_mode =\n-                    if refutable {bind_infer} else {bind_by_copy};\n-\n                 let can_be_enum_or_struct;\n                 match self.look_ahead(1) {\n                     token::LPAREN | token::LBRACKET | token::LT |\n@@ -2434,20 +2430,20 @@ pub impl Parser {\n                     let sub;\n                     if self.eat(&token::AT) {\n                         // parse foo @ pat\n-                        sub = Some(self.parse_pat(refutable));\n+                        sub = Some(self.parse_pat());\n                     } else {\n                         // or just foo\n                         sub = None;\n                     }\n-                    pat = pat_ident(binding_mode, name, sub);\n+                    pat = pat_ident(bind_infer, name, sub);\n                 } else {\n                     // parse an enum pat\n                     let enum_path = self.parse_path_with_tps(true);\n                     match *self.token {\n                         token::LBRACE => {\n                             self.bump();\n                             let (fields, etc) =\n-                                self.parse_pat_fields(refutable);\n+                                self.parse_pat_fields();\n                             self.bump();\n                             pat = pat_struct(enum_path, fields, etc);\n                         }\n@@ -2468,7 +2464,7 @@ pub impl Parser {\n                                         seq_sep_trailing_disallowed(\n                                             token::COMMA\n                                         ),\n-                                        |p| p.parse_pat(refutable)\n+                                        |p| p.parse_pat()\n                                     );\n                                     pat = pat_enum(enum_path, Some(args));\n                                   }\n@@ -2478,7 +2474,7 @@ pub impl Parser {\n                                       // it could still be either an enum\n                                       // or an identifier pattern, resolve\n                                       // will sort it out:\n-                                      pat = pat_ident(binding_mode,\n+                                      pat = pat_ident(bind_infer,\n                                                       enum_path,\n                                                       None);\n                                   } else {\n@@ -2500,7 +2496,6 @@ pub impl Parser {\n     // used by the copy foo and ref foo patterns to give a good\n     // error message when parsing mistakes like ref foo(a,b)\n     fn parse_pat_ident(&self,\n-                       refutable: bool,\n                        binding_mode: ast::binding_mode)\n                        -> ast::pat_ {\n         if !is_plain_ident(&*self.token) {\n@@ -2510,7 +2505,7 @@ pub impl Parser {\n         // why a path here, and not just an identifier?\n         let name = self.parse_path_without_tps();\n         let sub = if self.eat(&token::AT) {\n-            Some(self.parse_pat(refutable))\n+            Some(self.parse_pat())\n         } else {\n             None\n         };\n@@ -2533,7 +2528,7 @@ pub impl Parser {\n     // parse a local variable declaration\n     fn parse_local(&self, is_mutbl: bool) -> @local {\n         let lo = self.span.lo;\n-        let pat = self.parse_pat(false);\n+        let pat = self.parse_pat();\n         let mut ty = @Ty {\n             id: self.get_id(),\n             node: ty_infer,\n@@ -2760,7 +2755,7 @@ pub impl Parser {\n                     match stmt.node {\n                         stmt_expr(e, stmt_id) => {\n                             // expression without semicolon\n-                            match *self.token {\n+                            match copy *self.token {\n                                 token::SEMI => {\n                                     self.bump();\n                                     stmts.push(@codemap::spanned {\n@@ -2770,7 +2765,7 @@ pub impl Parser {\n                                 token::RBRACE => {\n                                     expr = Some(e);\n                                 }\n-                                copy t => {\n+                                t => {\n                                     if classify::stmt_ends_with_semi(stmt) {\n                                         self.fatal(\n                                             fmt!(\n@@ -2880,7 +2875,7 @@ pub impl Parser {\n                 token::MOD_SEP | token::IDENT(*) => {\n                     let obsolete_bound = match *self.token {\n                         token::MOD_SEP => false,\n-                        token::IDENT(copy sid, _) => {\n+                        token::IDENT(sid, _) => {\n                             match *self.id_to_str(sid) {\n                                 ~\"send\" |\n                                 ~\"copy\" |"}, {"sha": "f29876b87087a8917e3a55b9300cfeace6627866", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -1537,9 +1537,6 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n                       word_nbsp(s, \"ref\");\n                       print_mutability(s, mutbl);\n                   }\n-                  ast::bind_by_copy => {\n-                      word_nbsp(s, \"copy\");\n-                  }\n                   ast::bind_infer => {}\n               }\n           }"}, {"sha": "e77f5245d7d8bb14906e6343d1d918599c2e58e2", "filename": "src/test/compile-fail/borrowck-pat-by-value-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -36,7 +36,7 @@ fn match_const_opt_by_imm_ref(v: &const Option<int>) {\n \n fn match_const_opt_by_value(v: &const Option<int>) {\n     match *v {\n-      Some(copy i) => process(i),\n+      Some(i) => process(i),\n       None => ()\n     }\n }"}, {"sha": "a7c8950486c05ed66556169f3090af43396781ee", "filename": "src/test/compile-fail/noncopyable-match-pattern.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/237dce12c934287abd0bbe5a35309b1dc4f0d2c0/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237dce12c934287abd0bbe5a35309b1dc4f0d2c0/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs?ref=237dce12c934287abd0bbe5a35309b1dc4f0d2c0", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::unstable;\n-\n-fn main() {\n-    unsafe {\n-        let x = Some(unstable::sync::exclusive(false));\n-        match x {\n-            Some(copy z) => { //~ ERROR copying a value of non-copyable type\n-                do z.with |b| { assert!(!*b); }\n-            }\n-            None => fail!()\n-        }\n-    }\n-}"}, {"sha": "65fbbfc6e198582698c20c8084fe73475a2ab936", "filename": "src/test/compile-fail/resolve-inconsistent-binding-mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -14,7 +14,7 @@ enum opts {\n \n fn matcher1(x: opts) {\n     match x {\n-      a(ref i) | b(copy i) => {} //~ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      a(ref i) | b(i) => {} //~ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n       c(_) => {}\n     }\n }"}, {"sha": "59ab5018c1d57f13f7d507112e1bc0c40b59c96b", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -25,9 +25,9 @@ fn lookup(table: ~json::Object, key: ~str, default: ~str) -> ~str\n {\n     match table.find(&key)\n     {\n-        option::Some(&extra::json::String(copy s)) =>\n+        option::Some(&extra::json::String(ref s)) =>\n         {\n-            copy s\n+            copy *s\n         }\n         option::Some(value) =>\n         {\n@@ -45,9 +45,9 @@ fn add_interface(store: int, managed_ip: ~str, data: extra::json::Json) -> (~str\n {\n     match &data\n     {\n-        &extra::json::Object(copy interface) =>\n+        &extra::json::Object(ref interface) =>\n         {\n-            let name = lookup(copy interface, ~\"ifDescr\", ~\"\");\n+            let name = lookup(copy *interface, ~\"ifDescr\", ~\"\");\n             let label = fmt!(\"%s-%s\", managed_ip, name);\n \n             (label, bool_value(false))"}, {"sha": "5f68b0e9a695355359f32d856b623d436c61d673", "filename": "src/test/run-pass/match-vec-rvalue.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Ftest%2Frun-pass%2Fmatch-vec-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3869f7a99c54f00d69b19298f215cbc4a84ce5a8/src%2Ftest%2Frun-pass%2Fmatch-vec-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-vec-rvalue.rs?ref=3869f7a99c54f00d69b19298f215cbc4a84ce5a8", "patch": "@@ -0,0 +1,12 @@\n+// Tests that matching rvalues with drops does not crash.\n+\n+fn main() {\n+    match ~[1, 2, 3] {\n+        x => {\n+            assert_eq!(x.len(), 3);\n+            assert_eq!(x[0], 1);\n+            assert_eq!(x[1], 2);\n+            assert_eq!(x[2], 3);\n+        }\n+    }\n+}"}]}