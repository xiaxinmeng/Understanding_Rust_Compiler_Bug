{"sha": "c01be67ea40266d6a4c3289654a07ddd7ce2a172", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMWJlNjdlYTQwMjY2ZDZhNGMzMjg5NjU0YTA3ZGRkN2NlMmExNzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-12T08:58:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-12T08:58:48Z"}, "message": "Auto merge of #63489 - Centril:rollup-uuf6z1s, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #62108 (Use sharded maps for queries)\n - #63297 (Improve pointer offset method docs)\n - #63406 (Suggest using a qualified path in patterns with inconsistent bindings)\n - #63431 (Revert \"Simplify MIR generation for logical ops\")\n - #63449 (resolve: Remove remaining special cases from built-in macros)\n - #63461 (docs: add stdlib env::var(_os) panic)\n - #63473 (Regression test for #56870)\n - #63474 (Add tests for issue #53598 and #57700)\n - #63480 (Fixes #63477)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "3c06e18f7a033f6c6121d4553f6811b33287cae1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c06e18f7a033f6c6121d4553f6811b33287cae1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c01be67ea40266d6a4c3289654a07ddd7ce2a172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c01be67ea40266d6a4c3289654a07ddd7ce2a172", "html_url": "https://github.com/rust-lang/rust/commit/c01be67ea40266d6a4c3289654a07ddd7ce2a172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c01be67ea40266d6a4c3289654a07ddd7ce2a172/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72f8043d44a8925e469daf5c10e2630c80c2a7d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/72f8043d44a8925e469daf5c10e2630c80c2a7d4", "html_url": "https://github.com/rust-lang/rust/commit/72f8043d44a8925e469daf5c10e2630c80c2a7d4"}, {"sha": "9d297190c853065211c6102bcb46a8b7b9f42898", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d297190c853065211c6102bcb46a8b7b9f42898", "html_url": "https://github.com/rust-lang/rust/commit/9d297190c853065211c6102bcb46a8b7b9f42898"}], "stats": {"total": 678, "additions": 499, "deletions": 179}, "files": [{"sha": "f5fbd1a6b1325c82cee54711876a97f624aa4831", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 128, "deletions": 34, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -1120,7 +1120,8 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object.\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -1140,10 +1141,12 @@ impl<T: ?Sized> *const T {\n     /// Extension. As such, memory acquired directly from allocators or memory\n     /// mapped files *may* be too large to handle with this function.\n     ///\n-    /// Consider using `wrapping_offset` instead if these constraints are\n+    /// Consider using [`wrapping_offset`] instead if these constraints are\n     /// difficult to satisfy. The only advantage of this method is that it\n     /// enables more aggressive compiler optimizations.\n     ///\n+    /// [`wrapping_offset`]: #method.wrapping_offset\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1172,15 +1175,26 @@ impl<T: ?Sized> *const T {\n     ///\n     /// The resulting pointer does not need to be in bounds, but it is\n     /// potentially hazardous to dereference (which requires `unsafe`).\n-    /// In particular, the resulting pointer may *not* be used to access a\n-    /// different allocated object than the one `self` points to. In other\n-    /// words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n+    ///\n+    /// In particular, the resulting pointer remains attached to the same allocated\n+    /// object that `self` points to. It may *not* be used to access a\n+    /// different allocated object. Note that in Rust,\n+    /// every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// In other words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n     /// *not* the same as `y`, and dereferencing it is undefined behavior\n     /// unless `x` and `y` point into the same allocated object.\n     ///\n-    /// Always use `.offset(count)` instead when possible, because `offset`\n-    /// allows the compiler to optimize better. If you need to cross object\n-    /// boundaries, cast the pointer to an integer and do the arithmetic there.\n+    /// Compared to [`offset`], this method basically delays the requirement of staying\n+    /// within the same allocated object: [`offset`] is immediate Undefined Behavior when\n+    /// crossing object boundaries; `wrapping_offset` produces a pointer but still leads\n+    /// to Undefined Behavior if that pointer is dereferenced. [`offset`] can be optimized\n+    /// better and is thus preferrable in performance-sensitive code.\n+    ///\n+    /// If you need to cross object boundaries, cast the pointer to an integer and\n+    /// do the arithmetic there.\n+    ///\n+    /// [`offset`]: #method.offset\n     ///\n     /// # Examples\n     ///\n@@ -1223,7 +1237,8 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and other pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object.\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n     ///\n     /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -1338,7 +1353,8 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object.\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -1358,10 +1374,12 @@ impl<T: ?Sized> *const T {\n     /// Extension. As such, memory acquired directly from allocators or memory\n     /// mapped files *may* be too large to handle with this function.\n     ///\n-    /// Consider using `wrapping_offset` instead if these constraints are\n+    /// Consider using [`wrapping_add`] instead if these constraints are\n     /// difficult to satisfy. The only advantage of this method is that it\n     /// enables more aggressive compiler optimizations.\n     ///\n+    /// [`wrapping_add`]: #method.wrapping_add\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1395,7 +1413,8 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object.\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n     ///\n     /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n     ///\n@@ -1415,10 +1434,12 @@ impl<T: ?Sized> *const T {\n     /// Extension. As such, memory acquired directly from allocators or memory\n     /// mapped files *may* be too large to handle with this function.\n     ///\n-    /// Consider using `wrapping_offset` instead if these constraints are\n+    /// Consider using [`wrapping_sub`] instead if these constraints are\n     /// difficult to satisfy. The only advantage of this method is that it\n     /// enables more aggressive compiler optimizations.\n     ///\n+    /// [`wrapping_sub`]: #method.wrapping_sub\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1451,8 +1472,21 @@ impl<T: ?Sized> *const T {\n     /// The resulting pointer does not need to be in bounds, but it is\n     /// potentially hazardous to dereference (which requires `unsafe`).\n     ///\n-    /// Always use `.add(count)` instead when possible, because `add`\n-    /// allows the compiler to optimize better.\n+    /// In particular, the resulting pointer remains attached to the same allocated\n+    /// object that `self` points to. It may *not* be used to access a\n+    /// different allocated object. Note that in Rust,\n+    /// every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// Compared to [`add`], this method basically delays the requirement of staying\n+    /// within the same allocated object: [`add`] is immediate Undefined Behavior when\n+    /// crossing object boundaries; `wrapping_add` produces a pointer but still leads\n+    /// to Undefined Behavior if that pointer is dereferenced. [`add`] can be optimized\n+    /// better and is thus preferrable in performance-sensitive code.\n+    ///\n+    /// If you need to cross object boundaries, cast the pointer to an integer and\n+    /// do the arithmetic there.\n+    ///\n+    /// [`add`]: #method.add\n     ///\n     /// # Examples\n     ///\n@@ -1492,8 +1526,21 @@ impl<T: ?Sized> *const T {\n     /// The resulting pointer does not need to be in bounds, but it is\n     /// potentially hazardous to dereference (which requires `unsafe`).\n     ///\n-    /// Always use `.sub(count)` instead when possible, because `sub`\n-    /// allows the compiler to optimize better.\n+    /// In particular, the resulting pointer remains attached to the same allocated\n+    /// object that `self` points to. It may *not* be used to access a\n+    /// different allocated object. Note that in Rust,\n+    /// every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// Compared to [`sub`], this method basically delays the requirement of staying\n+    /// within the same allocated object: [`sub`] is immediate Undefined Behavior when\n+    /// crossing object boundaries; `wrapping_sub` produces a pointer but still leads\n+    /// to Undefined Behavior if that pointer is dereferenced. [`sub`] can be optimized\n+    /// better and is thus preferrable in performance-sensitive code.\n+    ///\n+    /// If you need to cross object boundaries, cast the pointer to an integer and\n+    /// do the arithmetic there.\n+    ///\n+    /// [`sub`]: #method.sub\n     ///\n     /// # Examples\n     ///\n@@ -1757,7 +1804,8 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object.\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -1777,10 +1825,12 @@ impl<T: ?Sized> *mut T {\n     /// Extension. As such, memory acquired directly from allocators or memory\n     /// mapped files *may* be too large to handle with this function.\n     ///\n-    /// Consider using `wrapping_offset` instead if these constraints are\n+    /// Consider using [`wrapping_offset`] instead if these constraints are\n     /// difficult to satisfy. The only advantage of this method is that it\n     /// enables more aggressive compiler optimizations.\n     ///\n+    /// [`wrapping_offset`]: #method.wrapping_offset\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1808,15 +1858,26 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// The resulting pointer does not need to be in bounds, but it is\n     /// potentially hazardous to dereference (which requires `unsafe`).\n-    /// In particular, the resulting pointer may *not* be used to access a\n-    /// different allocated object than the one `self` points to. In other\n-    /// words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n+    ///\n+    /// In particular, the resulting pointer remains attached to the same allocated\n+    /// object that `self` points to. It may *not* be used to access a\n+    /// different allocated object. Note that in Rust,\n+    /// every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// In other words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n     /// *not* the same as `y`, and dereferencing it is undefined behavior\n     /// unless `x` and `y` point into the same allocated object.\n     ///\n-    /// Always use `.offset(count)` instead when possible, because `offset`\n-    /// allows the compiler to optimize better. If you need to cross object\n-    /// boundaries, cast the pointer to an integer and do the arithmetic there.\n+    /// Compared to [`offset`], this method basically delays the requirement of staying\n+    /// within the same allocated object: [`offset`] is immediate Undefined Behavior when\n+    /// crossing object boundaries; `wrapping_offset` produces a pointer but still leads\n+    /// to Undefined Behavior if that pointer is dereferenced. [`offset`] can be optimized\n+    /// better and is thus preferrable in performance-sensitive code.\n+    ///\n+    /// If you need to cross object boundaries, cast the pointer to an integer and\n+    /// do the arithmetic there.\n+    ///\n+    /// [`offset`]: #method.offset\n     ///\n     /// # Examples\n     ///\n@@ -1903,7 +1964,8 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and other pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object.\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n     ///\n     /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -2007,7 +2069,8 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object.\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -2027,10 +2090,12 @@ impl<T: ?Sized> *mut T {\n     /// Extension. As such, memory acquired directly from allocators or memory\n     /// mapped files *may* be too large to handle with this function.\n     ///\n-    /// Consider using `wrapping_offset` instead if these constraints are\n+    /// Consider using [`wrapping_add`] instead if these constraints are\n     /// difficult to satisfy. The only advantage of this method is that it\n     /// enables more aggressive compiler optimizations.\n     ///\n+    /// [`wrapping_add`]: #method.wrapping_add\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -2064,7 +2129,8 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object.\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n     ///\n     /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n     ///\n@@ -2084,10 +2150,12 @@ impl<T: ?Sized> *mut T {\n     /// Extension. As such, memory acquired directly from allocators or memory\n     /// mapped files *may* be too large to handle with this function.\n     ///\n-    /// Consider using `wrapping_offset` instead if these constraints are\n+    /// Consider using [`wrapping_sub`] instead if these constraints are\n     /// difficult to satisfy. The only advantage of this method is that it\n     /// enables more aggressive compiler optimizations.\n     ///\n+    /// [`wrapping_sub`]: #method.wrapping_sub\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -2120,8 +2188,21 @@ impl<T: ?Sized> *mut T {\n     /// The resulting pointer does not need to be in bounds, but it is\n     /// potentially hazardous to dereference (which requires `unsafe`).\n     ///\n-    /// Always use `.add(count)` instead when possible, because `add`\n-    /// allows the compiler to optimize better.\n+    /// In particular, the resulting pointer remains attached to the same allocated\n+    /// object that `self` points to. It may *not* be used to access a\n+    /// different allocated object. Note that in Rust,\n+    /// every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// Compared to [`add`], this method basically delays the requirement of staying\n+    /// within the same allocated object: [`add`] is immediate Undefined Behavior when\n+    /// crossing object boundaries; `wrapping_add` produces a pointer but still leads\n+    /// to Undefined Behavior if that pointer is dereferenced. [`add`] can be optimized\n+    /// better and is thus preferrable in performance-sensitive code.\n+    ///\n+    /// If you need to cross object boundaries, cast the pointer to an integer and\n+    /// do the arithmetic there.\n+    ///\n+    /// [`add`]: #method.add\n     ///\n     /// # Examples\n     ///\n@@ -2161,8 +2242,21 @@ impl<T: ?Sized> *mut T {\n     /// The resulting pointer does not need to be in bounds, but it is\n     /// potentially hazardous to dereference (which requires `unsafe`).\n     ///\n-    /// Always use `.sub(count)` instead when possible, because `sub`\n-    /// allows the compiler to optimize better.\n+    /// In particular, the resulting pointer remains attached to the same allocated\n+    /// object that `self` points to. It may *not* be used to access a\n+    /// different allocated object. Note that in Rust,\n+    /// every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// Compared to [`sub`], this method basically delays the requirement of staying\n+    /// within the same allocated object: [`sub`] is immediate Undefined Behavior when\n+    /// crossing object boundaries; `wrapping_sub` produces a pointer but still leads\n+    /// to Undefined Behavior if that pointer is dereferenced. [`sub`] can be optimized\n+    /// better and is thus preferrable in performance-sensitive code.\n+    ///\n+    /// If you need to cross object boundaries, cast the pointer to an integer and\n+    /// do the arithmetic there.\n+    ///\n+    /// [`sub`]: #method.sub\n     ///\n     /// # Examples\n     ///"}, {"sha": "91082c59ba05ae7a23501902fb66c52eccd71ed4", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -11,7 +11,7 @@ use crate::util::profiling::ProfileCategory;\n use std::borrow::Cow;\n use std::hash::Hash;\n use std::fmt::Debug;\n-use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::fingerprint::Fingerprint;\n use crate::ich::StableHashingContext;\n \n@@ -34,7 +34,7 @@ pub(crate) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n     fn query(key: Self::Key) -> Query<'tcx>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_cache<'a>(tcx: TyCtxt<'tcx>) -> &'a Lock<QueryCache<'tcx, Self>>;\n+    fn query_cache<'a>(tcx: TyCtxt<'tcx>) -> &'a Sharded<QueryCache<'tcx, Self>>;\n \n     fn to_dep_node(tcx: TyCtxt<'tcx>, key: &Self::Key) -> DepNode;\n "}, {"sha": "00871a1cbf2a95bf9078d3fcf43d7eccc5845a41", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -1062,9 +1062,9 @@ where\n         ::std::any::type_name::<Q>());\n \n     time_ext(tcx.sess.time_extended(), Some(tcx.sess), desc, || {\n-        let map = Q::query_cache(tcx).borrow();\n-        assert!(map.active.is_empty());\n-        for (key, entry) in map.results.iter() {\n+        let shards = Q::query_cache(tcx).lock_shards();\n+        assert!(shards.iter().all(|shard| shard.active.is_empty()));\n+        for (key, entry) in shards.iter().flat_map(|shard| shard.results.iter()) {\n             if Q::cache_on_disk(tcx, key.clone(), Some(&entry.value)) {\n                 let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n "}, {"sha": "4dce55f5892339cc41255bbe346440de1971535d", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -17,6 +17,7 @@ use errors::Diagnostic;\n use errors::FatalError;\n use rustc_data_structures::fx::{FxHashMap};\n use rustc_data_structures::sync::{Lrc, Lock};\n+use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::thin_vec::ThinVec;\n #[cfg(not(parallel_compiler))]\n use rustc_data_structures::cold_path;\n@@ -90,7 +91,7 @@ macro_rules! profq_query_msg {\n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n pub(super) struct JobOwner<'a, 'tcx, Q: QueryDescription<'tcx>> {\n-    cache: &'a Lock<QueryCache<'tcx, Q>>,\n+    cache: &'a Sharded<QueryCache<'tcx, Q>>,\n     key: Q::Key,\n     job: Lrc<QueryJob<'tcx>>,\n }\n@@ -107,7 +108,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n     pub(super) fn try_get(tcx: TyCtxt<'tcx>, span: Span, key: &Q::Key) -> TryGetJob<'a, 'tcx, Q> {\n         let cache = Q::query_cache(tcx);\n         loop {\n-            let mut lock = cache.borrow_mut();\n+            let mut lock = cache.get_shard_by_value(key).lock();\n             if let Some(value) = lock.results.get(key) {\n                 profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                 tcx.sess.profiler(|p| p.record_query_hit(Q::NAME));\n@@ -191,7 +192,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n \n         let value = QueryValue::new(result.clone(), dep_node_index);\n         {\n-            let mut lock = cache.borrow_mut();\n+            let mut lock = cache.get_shard_by_value(&key).lock();\n             lock.active.remove(&key);\n             lock.results.insert(key, value);\n         }\n@@ -215,7 +216,8 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n     #[cold]\n     fn drop(&mut self) {\n         // Poison the query so jobs waiting on it panic\n-        self.cache.borrow_mut().active.insert(self.key.clone(), QueryResult::Poisoned);\n+        let shard = self.cache.get_shard_by_value(&self.key);\n+        shard.lock().active.insert(self.key.clone(), QueryResult::Poisoned);\n         // Also signal the completion of the job, so waiters\n         // will continue execution\n         self.job.signal_complete();\n@@ -708,7 +710,7 @@ macro_rules! define_queries_inner {\n         use std::mem;\n         #[cfg(parallel_compiler)]\n         use ty::query::job::QueryResult;\n-        use rustc_data_structures::sync::Lock;\n+        use rustc_data_structures::sharded::Sharded;\n         use crate::{\n             rustc_data_structures::stable_hasher::HashStable,\n             rustc_data_structures::stable_hasher::StableHasherResult,\n@@ -740,18 +742,17 @@ macro_rules! define_queries_inner {\n             pub fn collect_active_jobs(&self) -> Vec<Lrc<QueryJob<$tcx>>> {\n                 let mut jobs = Vec::new();\n \n-                // We use try_lock here since we are only called from the\n+                // We use try_lock_shards here since we are only called from the\n                 // deadlock handler, and this shouldn't be locked.\n                 $(\n-                    jobs.extend(\n-                        self.$name.try_lock().unwrap().active.values().filter_map(|v|\n-                            if let QueryResult::Started(ref job) = *v {\n-                                Some(job.clone())\n-                            } else {\n-                                None\n-                            }\n-                        )\n-                    );\n+                    let shards = self.$name.try_lock_shards().unwrap();\n+                    jobs.extend(shards.iter().flat_map(|shard| shard.active.values().filter_map(|v|\n+                        if let QueryResult::Started(ref job) = *v {\n+                            Some(job.clone())\n+                        } else {\n+                            None\n+                        }\n+                    )));\n                 )*\n \n                 jobs\n@@ -773,26 +774,27 @@ macro_rules! define_queries_inner {\n \n                 fn stats<'tcx, Q: QueryConfig<'tcx>>(\n                     name: &'static str,\n-                    map: &QueryCache<'tcx, Q>\n+                    map: &Sharded<QueryCache<'tcx, Q>>,\n                 ) -> QueryStats {\n+                    let map = map.lock_shards();\n                     QueryStats {\n                         name,\n                         #[cfg(debug_assertions)]\n-                        cache_hits: map.cache_hits,\n+                        cache_hits: map.iter().map(|shard| shard.cache_hits).sum(),\n                         #[cfg(not(debug_assertions))]\n                         cache_hits: 0,\n                         key_size: mem::size_of::<Q::Key>(),\n                         key_type: type_name::<Q::Key>(),\n                         value_size: mem::size_of::<Q::Value>(),\n                         value_type: type_name::<Q::Value>(),\n-                        entry_count: map.results.len(),\n+                        entry_count: map.iter().map(|shard| shard.results.len()).sum(),\n                     }\n                 }\n \n                 $(\n                     queries.push(stats::<queries::$name<'_>>(\n                         stringify!($name),\n-                        &*self.$name.lock()\n+                        &self.$name,\n                     ));\n                 )*\n \n@@ -967,7 +969,7 @@ macro_rules! define_queries_inner {\n             }\n \n             #[inline(always)]\n-            fn query_cache<'a>(tcx: TyCtxt<$tcx>) -> &'a Lock<QueryCache<$tcx, Self>> {\n+            fn query_cache<'a>(tcx: TyCtxt<$tcx>) -> &'a Sharded<QueryCache<$tcx, Self>> {\n                 &tcx.queries.$name\n             }\n \n@@ -1099,7 +1101,7 @@ macro_rules! define_queries_struct {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n             fallback_extern_providers: Box<Providers<$tcx>>,\n \n-            $($(#[$attr])*  $name: Lock<QueryCache<$tcx, queries::$name<$tcx>>>,)*\n+            $($(#[$attr])*  $name: Sharded<QueryCache<$tcx, queries::$name<$tcx>>>,)*\n         }\n     };\n }"}, {"sha": "02ab53fe8c1b1f50a3665603ab7e595315e979ff", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -79,59 +79,66 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::LogicalOp { op, lhs, rhs } => {\n                 // And:\n                 //\n-                // [block: If(lhs)] -true-> [else_block: dest = (rhs)]\n-                //        | (false)\n-                //  [shortcurcuit_block: dest = false]\n+                // [block: If(lhs)] -true-> [else_block: If(rhs)] -true-> [true_block]\n+                //        |                          | (false)\n+                //        +----------false-----------+------------------> [false_block]\n                 //\n                 // Or:\n                 //\n-                // [block: If(lhs)] -false-> [else_block: dest = (rhs)]\n-                //        | (true)\n-                //  [shortcurcuit_block: dest = true]\n+                // [block: If(lhs)] -false-> [else_block: If(rhs)] -true-> [true_block]\n+                //        | (true)                   | (false)\n+                //  [true_block]               [false_block]\n \n-                let (shortcircuit_block, mut else_block, join_block) = (\n+                let (true_block, false_block, mut else_block, join_block) = (\n+                    this.cfg.start_new_block(),\n                     this.cfg.start_new_block(),\n                     this.cfg.start_new_block(),\n                     this.cfg.start_new_block(),\n                 );\n \n                 let lhs = unpack!(block = this.as_local_operand(block, lhs));\n                 let blocks = match op {\n-                    LogicalOp::And => (else_block, shortcircuit_block),\n-                    LogicalOp::Or => (shortcircuit_block, else_block),\n+                    LogicalOp::And => (else_block, false_block),\n+                    LogicalOp::Or => (true_block, else_block),\n                 };\n                 let term = TerminatorKind::if_(this.hir.tcx(), lhs, blocks.0, blocks.1);\n                 this.cfg.terminate(block, source_info, term);\n \n+                let rhs = unpack!(else_block = this.as_local_operand(else_block, rhs));\n+                let term = TerminatorKind::if_(this.hir.tcx(), rhs, true_block, false_block);\n+                this.cfg.terminate(else_block, source_info, term);\n+\n                 this.cfg.push_assign_constant(\n-                    shortcircuit_block,\n+                    true_block,\n                     source_info,\n                     destination,\n                     Constant {\n                         span: expr_span,\n                         ty: this.hir.bool_ty(),\n                         user_ty: None,\n-                        literal: match op {\n-                            LogicalOp::And => this.hir.false_literal(),\n-                            LogicalOp::Or => this.hir.true_literal(),\n-                        },\n+                        literal: this.hir.true_literal(),\n                     },\n                 );\n-                this.cfg.terminate(\n-                    shortcircuit_block,\n+\n+                this.cfg.push_assign_constant(\n+                    false_block,\n                     source_info,\n-                    TerminatorKind::Goto { target: join_block },\n+                    destination,\n+                    Constant {\n+                        span: expr_span,\n+                        ty: this.hir.bool_ty(),\n+                        user_ty: None,\n+                        literal: this.hir.false_literal(),\n+                    },\n                 );\n \n-                let rhs = unpack!(else_block = this.as_local_operand(else_block, rhs));\n-                this.cfg.push_assign(\n-                    else_block,\n+                this.cfg.terminate(\n+                    true_block,\n                     source_info,\n-                    destination,\n-                    Rvalue::Use(rhs),\n+                    TerminatorKind::Goto { target: join_block },\n                 );\n                 this.cfg.terminate(\n-                    else_block,\n+                    false_block,\n                     source_info,\n                     TerminatorKind::Goto { target: join_block },\n                 );"}, {"sha": "5dd7bc305482971f5924822b5ac4f26fe4eac15d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -126,8 +126,6 @@ impl<'a> Resolver<'a> {\n         };\n         if let Some(id) = self.definitions.as_local_node_id(def_id) {\n             self.local_macro_def_scopes[&id]\n-        } else if self.is_builtin_macro(Some(def_id)) {\n-            self.injected_crate.unwrap_or(self.graph_root)\n         } else {\n             let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();\n             self.get_module(module_def_id)\n@@ -596,11 +594,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 };\n \n                 self.r.populate_module_if_necessary(module);\n-                if let Some(name) = self.r.session.parse_sess.injected_crate_name.try_get() {\n-                    if name.as_str() == ident.name.as_str() {\n-                        self.r.injected_crate = Some(module);\n-                    }\n-                }\n \n                 let used = self.process_legacy_macro_imports(item, module);\n                 let binding ="}, {"sha": "1de67edb95c087285faea77b3cd1e2e4ceaa6133", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -20,7 +20,7 @@ use syntax_pos::{BytePos, Span, MultiSpan};\n \n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n use crate::{path_names_to_string, KNOWN_TOOLS};\n-use crate::{CrateLint, LegacyScope, Module, ModuleOrUniformRoot};\n+use crate::{BindingError, CrateLint, LegacyScope, Module, ModuleOrUniformRoot};\n use crate::{PathResult, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n@@ -207,21 +207,32 @@ impl<'a> Resolver<'a> {\n                 err\n             }\n             ResolutionError::VariableNotBoundInPattern(binding_error) => {\n-                let target_sp = binding_error.target.iter().cloned().collect::<Vec<_>>();\n+                let BindingError { name, target, origin, could_be_path } = binding_error;\n+\n+                let target_sp = target.iter().copied().collect::<Vec<_>>();\n+                let origin_sp = origin.iter().copied().collect::<Vec<_>>();\n+\n                 let msp = MultiSpan::from_spans(target_sp.clone());\n-                let msg = format!(\"variable `{}` is not bound in all patterns\", binding_error.name);\n+                let msg = format!(\"variable `{}` is not bound in all patterns\", name);\n                 let mut err = self.session.struct_span_err_with_code(\n                     msp,\n                     &msg,\n                     DiagnosticId::Error(\"E0408\".into()),\n                 );\n                 for sp in target_sp {\n-                    err.span_label(sp, format!(\"pattern doesn't bind `{}`\", binding_error.name));\n+                    err.span_label(sp, format!(\"pattern doesn't bind `{}`\", name));\n                 }\n-                let origin_sp = binding_error.origin.iter().cloned();\n                 for sp in origin_sp {\n                     err.span_label(sp, \"variable not in all patterns\");\n                 }\n+                if *could_be_path {\n+                    let help_msg = format!(\n+                        \"if you meant to match on a variant or a `const` item, consider \\\n+                         making the path in the pattern qualified: `?::{}`\",\n+                         name,\n+                     );\n+                    err.span_help(span, &help_msg);\n+                }\n                 err\n             }\n             ResolutionError::VariableBoundWithDifferentMode(variable_name,"}, {"sha": "358eaae11e71275d860bcf74bb46a931f10b9b8d", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 38, "deletions": 48, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -1136,65 +1136,53 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     // Checks that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n     fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n-        if pats.is_empty() {\n-            return;\n-        }\n-\n         let mut missing_vars = FxHashMap::default();\n         let mut inconsistent_vars = FxHashMap::default();\n-        for (i, p) in pats.iter().enumerate() {\n-            let map_i = self.binding_mode_map(&p);\n-\n-            for (j, q) in pats.iter().enumerate() {\n-                if i == j {\n-                    continue;\n-                }\n \n-                let map_j = self.binding_mode_map(&q);\n-                for (&key, &binding_i) in &map_i {\n-                    if map_j.is_empty() {                   // Account for missing bindings when\n-                        let binding_error = missing_vars    // `map_j` has none.\n-                            .entry(key.name)\n-                            .or_insert(BindingError {\n-                                name: key.name,\n-                                origin: BTreeSet::new(),\n-                                target: BTreeSet::new(),\n-                            });\n-                        binding_error.origin.insert(binding_i.span);\n-                        binding_error.target.insert(q.span);\n-                    }\n-                    for (&key_j, &binding_j) in &map_j {\n-                        match map_i.get(&key_j) {\n-                            None => {  // missing binding\n-                                let binding_error = missing_vars\n-                                    .entry(key_j.name)\n-                                    .or_insert(BindingError {\n-                                        name: key_j.name,\n-                                        origin: BTreeSet::new(),\n-                                        target: BTreeSet::new(),\n-                                    });\n-                                binding_error.origin.insert(binding_j.span);\n-                                binding_error.target.insert(p.span);\n-                            }\n-                            Some(binding_i) => {  // check consistent binding\n-                                if binding_i.binding_mode != binding_j.binding_mode {\n-                                    inconsistent_vars\n-                                        .entry(key.name)\n-                                        .or_insert((binding_j.span, binding_i.span));\n-                                }\n+        for pat_outer in pats.iter() {\n+            let map_outer = self.binding_mode_map(&pat_outer);\n+\n+            for pat_inner in pats.iter().filter(|pat| pat.id != pat_outer.id) {\n+                let map_inner = self.binding_mode_map(&pat_inner);\n+\n+                for (&key_inner, &binding_inner) in map_inner.iter() {\n+                    match map_outer.get(&key_inner) {\n+                        None => {  // missing binding\n+                            let binding_error = missing_vars\n+                                .entry(key_inner.name)\n+                                .or_insert(BindingError {\n+                                    name: key_inner.name,\n+                                    origin: BTreeSet::new(),\n+                                    target: BTreeSet::new(),\n+                                    could_be_path:\n+                                        key_inner.name.as_str().starts_with(char::is_uppercase)\n+                                });\n+                            binding_error.origin.insert(binding_inner.span);\n+                            binding_error.target.insert(pat_outer.span);\n+                        }\n+                        Some(binding_outer) => {  // check consistent binding\n+                            if binding_outer.binding_mode != binding_inner.binding_mode {\n+                                inconsistent_vars\n+                                    .entry(key_inner.name)\n+                                    .or_insert((binding_inner.span, binding_outer.span));\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n-        let mut missing_vars = missing_vars.iter().collect::<Vec<_>>();\n+\n+        let mut missing_vars = missing_vars.iter_mut().collect::<Vec<_>>();\n         missing_vars.sort();\n-        for (_, v) in missing_vars {\n+        for (name, mut v) in missing_vars {\n+            if inconsistent_vars.contains_key(name) {\n+                v.could_be_path = false;\n+            }\n             self.r.report_error(\n-                *v.origin.iter().next().unwrap(), ResolutionError::VariableNotBoundInPattern(v)\n-            );\n+                *v.origin.iter().next().unwrap(),\n+                ResolutionError::VariableNotBoundInPattern(v));\n         }\n+\n         let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n         inconsistent_vars.sort();\n         for (name, v) in inconsistent_vars {\n@@ -1222,7 +1210,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             self.resolve_pattern(pat, source, &mut bindings_list);\n         }\n         // This has to happen *after* we determine which pat_idents are variants\n-        self.check_consistent_bindings(pats);\n+        if pats.len() > 1 {\n+            self.check_consistent_bindings(pats);\n+        }\n     }\n \n     fn resolve_block(&mut self, block: &Block) {"}, {"sha": "8a4a60c16b0fe2016a0bc23b04c09d46cef7a4c1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -135,6 +135,7 @@ struct BindingError {\n     name: Name,\n     origin: BTreeSet<Span>,\n     target: BTreeSet<Span>,\n+    could_be_path: bool\n }\n \n impl PartialOrd for BindingError {\n@@ -914,8 +915,6 @@ pub struct Resolver<'a> {\n     /// it's not used during normal resolution, only for better error reporting.\n     struct_constructors: DefIdMap<(Res, ty::Visibility)>,\n \n-    injected_crate: Option<Module<'a>>,\n-\n     /// Features enabled for this crate.\n     active_features: FxHashSet<Symbol>,\n }\n@@ -1153,7 +1152,6 @@ impl<'a> Resolver<'a> {\n             unused_macros: Default::default(),\n             proc_macro_stubs: Default::default(),\n             special_derives: Default::default(),\n-            injected_crate: None,\n             active_features:\n                 features.declared_lib_features.iter().map(|(feat, ..)| *feat)\n                     .chain(features.declared_lang_features.iter().map(|(feat, ..)| *feat))"}, {"sha": "8e9e1380002cf1cc9a47e9e48a0d2c282fb3178d", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -854,8 +854,6 @@ impl<'a> Resolver<'a> {\n                 if ext.is_builtin {\n                     // The macro is a built-in, replace only the expander function.\n                     result.kind = ext.kind;\n-                    // Also reset its edition to the global one for compatibility.\n-                    result.edition = self.session.edition();\n                 } else {\n                     // The macro is from a plugin, the in-source definition is dummy,\n                     // take all the data from the resolver."}, {"sha": "eca93399e5807a3252be40cffb934c30d82d5b8d", "filename": "src/libstd/env.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -182,6 +182,12 @@ impl fmt::Debug for VarsOs {\n /// * Environment variable is not present\n /// * Environment variable is not valid unicode\n ///\n+/// # Panics\n+///\n+/// This function may panic if `key` is empty, contains an ASCII equals sign\n+/// `'='` or the NUL character `'\\0'`, or when the value contains the NUL\n+/// character.\n+///\n /// # Examples\n ///\n /// ```\n@@ -210,6 +216,12 @@ fn _var(key: &OsStr) -> Result<String, VarError> {\n ///\n /// [`None`]: ../option/enum.Option.html#variant.None\n ///\n+/// # Panics\n+///\n+/// This function may panic if `key` is empty, contains an ASCII equals sign\n+/// `'='` or the NUL character `'\\0'`, or when the value contains the NUL\n+/// character.\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "f2000936b9a21fdcffe1886fd282c2b347b0a077", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -119,7 +119,7 @@ macro_rules! print {\n /// Prints to the standard output, with a newline.\n ///\n /// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n-/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n+/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`)).\n ///\n /// Use the [`format!`] syntax to write data to the standard output.\n /// See [`std::fmt`] for more information."}, {"sha": "7f4feff6be670da429a7f58e868414fb9f54a938", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -592,8 +592,8 @@ pub struct SyntaxExtension {\n     pub helper_attrs: Vec<Symbol>,\n     /// Edition of the crate in which this macro is defined.\n     pub edition: Edition,\n-    /// Built-in macros have a couple of special properties (meaning of `$crate`,\n-    /// availability in `#[no_implicit_prelude]` modules), so we have to keep this flag.\n+    /// Built-in macros have a couple of special properties like availability\n+    /// in `#[no_implicit_prelude]` modules, so we have to keep this flag.\n     pub is_builtin: bool,\n     /// We have to identify macros providing a `Copy` impl early for compatibility reasons.\n     pub is_derive_copy: bool,"}, {"sha": "22962499a2b7554b8c344cbb8c0d06db42da7202", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -495,7 +495,7 @@ impl<'a> ExtCtxt<'a> {\n         let expr_loc_ptr = self.expr_addr_of(span, expr_loc_tuple);\n         self.expr_call_global(\n             span,\n-            self.std_path(&[sym::rt, sym::begin_panic]),\n+            [sym::std, sym::rt, sym::begin_panic].iter().map(|s| Ident::new(*s, span)).collect(),\n             vec![\n                 self.expr_str(span, msg),\n                 expr_loc_ptr])"}, {"sha": "131cd0a67c6699ca567c83719b6aa22908136cbb", "filename": "src/test/pretty/dollar-crate.pp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdollar-crate.pp?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -10,9 +10,9 @@\n \n fn main() {\n     {\n-        ::std::io::_print(::std::fmt::Arguments::new_v1(&[\"rust\\n\"],\n-                                                        &match () {\n-                                                             () => [],\n-                                                         }));\n+        ::std::io::_print(::core::fmt::Arguments::new_v1(&[\"rust\\n\"],\n+                                                         &match () {\n+                                                              () => [],\n+                                                          }));\n     };\n }"}, {"sha": "4cf2e90e635fd673895b0184c807ab153599ba17", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -30,7 +30,7 @@\n \n \n                   ((::alloc::fmt::format as\n-                       for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((<::std::fmt::Arguments>::new_v1\n+                       for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((<::core::fmt::Arguments>::new_v1\n                                                                                                            as\n                                                                                                            fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments::<'_>::new_v1})((&([(\"test\"\n                                                                                                                                                                                                                             as"}, {"sha": "29c1b8fb0da97cdeca831929cb290ef1d7b6b68b", "filename": "src/test/ui-fulldeps/deriving-encodable-decodable-box.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -5,11 +5,10 @@\n #![feature(box_syntax)]\n #![feature(rustc_private)]\n \n-extern crate serialize;\n-use serialize as rustc_serialize;\n+extern crate serialize as rustc_serialize;\n \n-use serialize::{Encodable, Decodable};\n-use serialize::json;\n+use rustc_serialize::{Encodable, Decodable};\n+use rustc_serialize::json;\n \n #[derive(RustcEncodable, RustcDecodable)]\n struct A {"}, {"sha": "fe608890bbd4decfdf3e5b931aa75a40515586f2", "filename": "src/test/ui-fulldeps/deriving-encodable-decodable-cell-refcell.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -7,12 +7,11 @@\n \n #![feature(rustc_private)]\n \n-extern crate serialize;\n-use serialize as rustc_serialize;\n+extern crate serialize as rustc_serialize;\n \n use std::cell::{Cell, RefCell};\n-use serialize::{Encodable, Decodable};\n-use serialize::json;\n+use rustc_serialize::{Encodable, Decodable};\n+use rustc_serialize::json;\n \n #[derive(RustcEncodable, RustcDecodable)]\n struct A {"}, {"sha": "d7cc98fed2595cbcb8080e99613d64a7cfb8fae4", "filename": "src/test/ui-fulldeps/deriving-global.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui-fulldeps%2Fderiving-global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui-fulldeps%2Fderiving-global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-global.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -2,8 +2,7 @@\n \n #![feature(rustc_private)]\n \n-extern crate serialize;\n-use serialize as rustc_serialize;\n+extern crate serialize as rustc_serialize;\n \n mod submod {\n     // if any of these are implemented without global calls for any"}, {"sha": "b1bdfaceb887d7bed8c159e51974634ea0b8ed1c", "filename": "src/test/ui-fulldeps/deriving-hygiene.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui-fulldeps%2Fderiving-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui-fulldeps%2Fderiving-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-hygiene.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -2,8 +2,7 @@\n \n #![allow(non_upper_case_globals)]\n #![feature(rustc_private)]\n-extern crate serialize;\n-use serialize as rustc_serialize;\n+extern crate serialize as rustc_serialize;\n \n pub const other: u8 = 1;\n pub const f: u8 = 1;"}, {"sha": "bd046a6cdee5f2d34bdfcc0ef1f231650e97cea6", "filename": "src/test/ui-fulldeps/issue-11881.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui-fulldeps%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui-fulldeps%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-11881.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -6,17 +6,16 @@\n \n #![feature(rustc_private)]\n \n-extern crate serialize;\n-use serialize as rustc_serialize;\n+extern crate serialize as rustc_serialize;\n \n use std::io::Cursor;\n use std::io::prelude::*;\n use std::fmt;\n use std::slice;\n \n-use serialize::{Encodable, Encoder};\n-use serialize::json;\n-use serialize::opaque;\n+use rustc_serialize::{Encodable, Encoder};\n+use rustc_serialize::json;\n+use rustc_serialize::opaque;\n \n #[derive(RustcEncodable)]\n struct Foo {"}, {"sha": "137a0ede0b33c8ea2d41403fe1919c881d3fe0c2", "filename": "src/test/ui/issues/issue-56870.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Fissues%2Fissue-56870.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Fissues%2Fissue-56870.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56870.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -0,0 +1,38 @@\n+// build-pass\n+// Regression test for #56870: Internal compiler error (traits & associated consts)\n+\n+use std::fmt::Debug;\n+\n+pub trait Foo<T> {\n+  const FOO: *const u8;\n+}\n+\n+impl <T: Debug> Foo<T> for dyn Debug {\n+  const FOO: *const u8 = <T as Debug>::fmt as *const u8;\n+}\n+\n+pub trait Bar {\n+  const BAR: *const u8;\n+}\n+\n+pub trait Baz {\n+  type Data: Debug;\n+}\n+\n+pub struct BarStruct<S: Baz>(S);\n+\n+impl<S: Baz> Bar for BarStruct<S> {\n+  const BAR: *const u8 = <dyn Debug as Foo<<S as Baz>::Data>>::FOO;\n+}\n+\n+struct AnotherStruct;\n+#[derive(Debug)]\n+struct SomeStruct;\n+\n+impl Baz for AnotherStruct {\n+  type Data = SomeStruct;\n+}\n+\n+fn main() {\n+  let _x = <BarStruct<AnotherStruct> as Bar>::BAR;\n+}"}, {"sha": "2fb803c4b2ad429dbefb667dbd6f55688c67146b", "filename": "src/test/ui/resolve/resolve-inconsistent-names.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -1,7 +1,36 @@\n+#![allow(non_camel_case_types)]\n+\n+enum E { A, B, c }\n+\n+mod m {\n+    const CONST1: usize = 10;\n+    const Const2: usize = 20;\n+}\n+\n fn main() {\n     let y = 1;\n     match y {\n        a | b => {} //~  ERROR variable `a` is not bound in all patterns\n-                   //~^ ERROR variable `b` is not bound in all patterns\n+                   //~| ERROR variable `b` is not bound in all patterns\n+    }\n+\n+    let x = (E::A, E::B);\n+    match x {\n+        (A, B) | (ref B, c) | (c, A) => ()\n+        //~^ ERROR variable `A` is not bound in all patterns\n+        //~| ERROR variable `B` is not bound in all patterns\n+        //~| ERROR variable `B` is bound in inconsistent ways\n+        //~| ERROR mismatched types\n+        //~| ERROR variable `c` is not bound in all patterns\n+        //~| HELP consider making the path in the pattern qualified: `?::A`\n+    }\n+\n+    let z = (10, 20);\n+    match z {\n+        (CONST1, _) | (_, Const2) => ()\n+        //~^ ERROR variable `CONST1` is not bound in all patterns\n+        //~| HELP consider making the path in the pattern qualified: `?::CONST1`\n+        //~| ERROR variable `Const2` is not bound in all patterns\n+        //~| HELP consider making the path in the pattern qualified: `?::Const2`\n     }\n }"}, {"sha": "f02867a0024b558d78b95be8e9e19235c42f8ca1", "filename": "src/test/ui/resolve/resolve-inconsistent-names.stderr", "status": "modified", "additions": 83, "deletions": 4, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -1,19 +1,98 @@\n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/resolve-inconsistent-names.rs:4:12\n+  --> $DIR/resolve-inconsistent-names.rs:13:12\n    |\n LL |        a | b => {}\n    |        -   ^ pattern doesn't bind `a`\n    |        |\n    |        variable not in all patterns\n \n error[E0408]: variable `b` is not bound in all patterns\n-  --> $DIR/resolve-inconsistent-names.rs:4:8\n+  --> $DIR/resolve-inconsistent-names.rs:13:8\n    |\n LL |        a | b => {}\n    |        ^   - variable not in all patterns\n    |        |\n    |        pattern doesn't bind `b`\n \n-error: aborting due to 2 previous errors\n+error[E0408]: variable `A` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:19:18\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |          -       ^^^^^^^^^^       - variable not in all patterns\n+   |          |       |\n+   |          |       pattern doesn't bind `A`\n+   |          variable not in all patterns\n+   |\n+help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `?::A`\n+  --> $DIR/resolve-inconsistent-names.rs:19:10\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |          ^\n+\n+error[E0408]: variable `B` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:19:31\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |             -         -       ^^^^^^ pattern doesn't bind `B`\n+   |             |         |\n+   |             |         variable not in all patterns\n+   |             variable not in all patterns\n+\n+error[E0408]: variable `c` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:19:9\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |         ^^^^^^           -     - variable not in all patterns\n+   |         |                |\n+   |         |                variable not in all patterns\n+   |         pattern doesn't bind `c`\n+\n+error[E0409]: variable `B` is bound in inconsistent ways within the same match arm\n+  --> $DIR/resolve-inconsistent-names.rs:19:23\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |             -         ^ bound in different ways\n+   |             |\n+   |             first binding\n+\n+error[E0408]: variable `CONST1` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:30:23\n+   |\n+LL |         (CONST1, _) | (_, Const2) => ()\n+   |          ------       ^^^^^^^^^^^ pattern doesn't bind `CONST1`\n+   |          |\n+   |          variable not in all patterns\n+   |\n+help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `?::CONST1`\n+  --> $DIR/resolve-inconsistent-names.rs:30:10\n+   |\n+LL |         (CONST1, _) | (_, Const2) => ()\n+   |          ^^^^^^\n+\n+error[E0408]: variable `Const2` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:30:9\n+   |\n+LL |         (CONST1, _) | (_, Const2) => ()\n+   |         ^^^^^^^^^^^       ------ variable not in all patterns\n+   |         |\n+   |         pattern doesn't bind `Const2`\n+   |\n+help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `?::Const2`\n+  --> $DIR/resolve-inconsistent-names.rs:30:27\n+   |\n+LL |         (CONST1, _) | (_, Const2) => ()\n+   |                           ^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/resolve-inconsistent-names.rs:19:19\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |                   ^^^^^ expected enum `E`, found &E\n+   |\n+   = note: expected type `E`\n+              found type `&E`\n+\n+error: aborting due to 9 previous errors\n \n-For more information about this error, try `rustc --explain E0408`.\n+Some errors have detailed explanations: E0308, E0408, E0409.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "61dff79d07bad2dbb1a5bae15b0eaadcb3ccabd5", "filename": "src/test/ui/type-alias-impl-trait/issue-53598.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -0,0 +1,28 @@\n+// ignore-tidy-linelength\n+#![feature(type_alias_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+pub trait Foo {\n+    type Item: Debug;\n+\n+    fn foo<T: Debug>(_: T) -> Self::Item;\n+}\n+\n+#[derive(Debug)]\n+pub struct S<T>(std::marker::PhantomData<T>);\n+\n+pub struct S2;\n+\n+impl Foo for S2 {\n+    type Item = impl Debug;\n+\n+    fn foo<T: Debug>(_: T) -> Self::Item {\n+    //~^ Error type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+        S::<T>(Default::default())\n+    }\n+}\n+\n+fn main() {\n+    S2::foo(123);\n+}"}, {"sha": "4c8144a2359309a5f19a7724d317b9f0e2c91ec1", "filename": "src/test/ui/type-alias-impl-trait/issue-53598.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -0,0 +1,12 @@\n+error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+  --> $DIR/issue-53598.rs:20:42\n+   |\n+LL |       fn foo<T: Debug>(_: T) -> Self::Item {\n+   |  __________________________________________^\n+LL | |\n+LL | |         S::<T>(Default::default())\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to previous error\n+"}, {"sha": "bfabef54724c8ddad0d8b69f83beeedfdc4f4517", "filename": "src/test/ui/type-alias-impl-trait/issue-57700.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -0,0 +1,22 @@\n+// ignore-tidy-linelength\n+#![feature(arbitrary_self_types)]\n+#![feature(type_alias_impl_trait)]\n+\n+use std::ops::Deref;\n+\n+trait Foo {\n+    type Bar: Foo;\n+\n+    fn foo(self: impl Deref<Target = Self>) -> Self::Bar;\n+}\n+\n+impl<C> Foo for C {\n+    type Bar = impl Foo;\n+\n+    fn foo(self: impl Deref<Target = Self>) -> Self::Bar {\n+    //~^ Error type parameter `impl Deref<Target = Self>` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+        self\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "c701e3e74ef591cecee73607b7c2ca1df6cf8e52", "filename": "src/test/ui/type-alias-impl-trait/issue-57700.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c01be67ea40266d6a4c3289654a07ddd7ce2a172/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr?ref=c01be67ea40266d6a4c3289654a07ddd7ce2a172", "patch": "@@ -0,0 +1,12 @@\n+error: type parameter `impl Deref<Target = Self>` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+  --> $DIR/issue-57700.rs:16:58\n+   |\n+LL |       fn foo(self: impl Deref<Target = Self>) -> Self::Bar {\n+   |  __________________________________________________________^\n+LL | |\n+LL | |         self\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to previous error\n+"}]}