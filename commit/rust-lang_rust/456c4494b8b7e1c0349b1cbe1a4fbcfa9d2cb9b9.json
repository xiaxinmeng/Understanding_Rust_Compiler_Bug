{"sha": "456c4494b8b7e1c0349b1cbe1a4fbcfa9d2cb9b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NmM0NDk0YjhiN2UxYzAzNDliMWNiZTFhNGZiY2ZhOWQyY2I5Yjk=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-07-24T19:00:34Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-07-29T16:50:25Z"}, "message": "New Guide: crates and modules", "tree": {"sha": "8326a75ac2b1c47afb0db93686b00bc21106adde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8326a75ac2b1c47afb0db93686b00bc21106adde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/456c4494b8b7e1c0349b1cbe1a4fbcfa9d2cb9b9", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/456c4494b8b7e1c0349b1cbe1a4fbcfa9d2cb9b9", "html_url": "https://github.com/rust-lang/rust/commit/456c4494b8b7e1c0349b1cbe1a4fbcfa9d2cb9b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/456c4494b8b7e1c0349b1cbe1a4fbcfa9d2cb9b9/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79e9f14abf50eecb7d3c53f10ad900615bb2d397", "url": "https://api.github.com/repos/rust-lang/rust/commits/79e9f14abf50eecb7d3c53f10ad900615bb2d397", "html_url": "https://github.com/rust-lang/rust/commit/79e9f14abf50eecb7d3c53f10ad900615bb2d397"}], "stats": {"total": 360, "additions": 351, "deletions": 9}, "files": [{"sha": "2216d829e4be83a5b0396926daf77d6c4ceb1065", "filename": "src/doc/guide.md", "status": "modified", "additions": 351, "deletions": 9, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/456c4494b8b7e1c0349b1cbe1a4fbcfa9d2cb9b9/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/456c4494b8b7e1c0349b1cbe1a4fbcfa9d2cb9b9/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=456c4494b8b7e1c0349b1cbe1a4fbcfa9d2cb9b9", "patch": "@@ -1770,7 +1770,7 @@ fn main() {\n \n ```{notrust,ignore}\n $ cargo build\n-  Compiling guessing_game v0.1.0 (file:/home/steve/tmp/guessing_game)\n+  Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n $\n ```\n \n@@ -2042,7 +2042,7 @@ Let's try it out!\n \n ```{notrust,ignore}\n $ cargo build\n-   Compiling guessing_game v0.1.0 (file:/home/steve/tmp/guessing_game)\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n src/guessing_game.rs:22:15: 22:24 error: mismatched types: expected `uint` but found `core::option::Option<uint>` (expected uint but found enum core::option::Option)\n src/guessing_game.rs:22     match cmp(input_num, secret_number) {\n                                       ^~~~~~~~~\n@@ -2246,7 +2246,7 @@ that `return`? If we give a non-number answer, we'll `return` and quit. Observe:\n ```{notrust,ignore}\n $ cargo build\n    Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n-steve@computer:~/tmp/guessing_game$ ./target/guessing_game \n+$ ./target/guessing_game \n Guess the number!\n The secret number is: 59\n Please input your guess.\n@@ -2462,19 +2462,361 @@ rest of your Rust education.\n Now that you're an expert at the basics, it's time to learn about some of\n Rust's more unique features.\n \n-# iterators\n+# Crates and Modules\n \n-# Lambdas\n+Rust features a strong module system, but it works a bit differently than in\n+other programming languages. Rust's module system has two main components:\n+**crate**s, and **module**s.\n+\n+A crate is Rust's unit of independent compilation. Rust always compiles one\n+crate at a time, producing either a library or an executable. However, executables\n+usually depend on libraries, and many libraries depend on other libraries as well.\n+To support this, crates can depend on other crates.\n+\n+Each crate contains a hierarchy of modules. This tree starts off with a single\n+module, called the **crate root**. Within the crate root, we can declare other\n+modules, which can contain other modules, as deeply as you'd like.\n+\n+Note that we haven't mentioned anything about files yet. Rust does not impose a\n+particular relationship between your filesystem structure and your module\n+structure. That said, there is a conventional approach to how Rust looks for\n+modules on the file system, but it's also overrideable.\n+\n+Enough talk, let's build something! Let's make a new project called `modules`.\n+\n+```{bash,ignore}\n+$ cd ~/projects\n+$ mkdir modules\n+$ cd modules\n+$ mkdir src\n+```\n+\n+We need to make our two 'hello world' files. In `src/main.rs`:\n+\n+```{rust}\n+fn main() {\n+    println!(\"Hello, world!\");\n+}\n+```\n+\n+And in `Cargo.toml`:\n+\n+```{notrust,ignore}\n+[package]\n+\n+name = \"modules\"\n+version = \"0.1.0\"\n+authors = [ \"someone@example.com\" ]\n+```\n+\n+Let's double check our work by compiling:\n+\n+```{bash,ignore}\n+$ cargo build\n+   Compiling modules v0.1.0 (file:/home/you/projects/modules)\n+$ ./target/modules\n+Hello, world!\n+```\n+\n+Excellent! So, we already have a single crate here: our `src/main.rs` is a crate.\n+Everything in that file is in the crate root. A crate that generates an executable\n+defines a `main` function inside its root, as we've done here.\n+\n+Let's define a new module inside our crate. Edit `src/main.rs` to look\n+like this:\n+\n+```\n+fn main() {\n+    println!(\"Hello, world!\");\n+}\n+\n+mod hello {\n+    fn print_hello() {\n+        println!(\"Hello, world!\");\n+    }\n+}\n+```\n+\n+We now have a module named `hello` inside of our crate root. Modules use\n+`snake_case` naming, like functions and variable bindings.\n+\n+Inside the `hello` module, we've defined a `print_hello` function. This will\n+also print out our hello world message. Modules allow you to split up your\n+program into nice neat boxes of functionality, grouping common things together,\n+and keeping different things apart. It's kinda like having a set of shelves:\n+a place for everything and everything in its place.\n+\n+To call our `print_hello` function, we use the double colon (`::`):\n+\n+```{rust,ignore}\n+hello::print_hello();\n+```\n+\n+You've seen this before, with `io::stdin()` and `rand::random()`. Now you know\n+how to make your own. However, crates and modules have rules about\n+**visibility**, which controls who exactly may use the functions defined in a\n+given module. By default, everything in a module is private, which means that\n+it can only be used by other functions in the same module. This will not\n+compile:\n+\n+```{rust,ignore}\n+fn main() {\n+    hello::print_hello();\n+}\n+\n+mod hello {\n+    fn print_hello() {\n+        println!(\"Hello, world!\");\n+    }\n+}\n+```\n+\n+It gives an error:\n+\n+```{notrust,ignore}\n+   Compiling modules v0.1.0 (file:/home/you/projects/modules)\n+src/modules.rs:2:5: 2:23 error: function `print_hello` is private\n+src/modules.rs:2     hello::print_hello();\n+                     ^~~~~~~~~~~~~~~~~~\n+```\n+\n+To make it public, we use the `pub` keyword:\n+\n+```{rust}\n+fn main() {\n+    hello::print_hello();\n+}\n+\n+mod hello {\n+    pub fn print_hello() {\n+        println!(\"Hello, world!\");\n+    }\n+}\n+```\n+\n+This will work:\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling modules v0.1.0 (file:/home/you/projects/modules)\n+$\n+```\n+\n+Before we move on, let me show you one more Cargo command: `run`. `cargo run`\n+is kind of like `cargo build`, but it also then runs the produced exectuable.\n+Try it out:\n+\n+```{notrust,ignore}\n+$ cargo run\n+   Compiling modules v0.1.0 (file:/home/steve/tmp/modules)\n+     Running `target/modules`\n+Hello, world!\n+$\n+```\n+\n+Nice!\n+\n+There's a common pattern when you're building an executable: you build both an\n+executable and a library, and put most of your logic in the library. That way,\n+other programs can use that library to build their own functionality.\n+\n+Let's do that with our project. If you remember, libraries and executables\n+are both crates, so while our project has one crate now, let's make a second:\n+one for the library, and one for the executable.\n+\n+To make the second crate, open up `src/lib.rs` and put this code in it:\n+\n+```{rust}\n+mod hello {\n+    pub fn print_hello() {\n+        println!(\"Hello, world!\");\n+    }\n+}\n+```\n+\n+And change your `src/main.rs` to look like this:\n+\n+```{rust,ignore}\n+extern crate modules;\n+\n+fn main() {\n+    modules::hello::print_hello();\n+}\n+```\n+\n+There's been a few changes. First, we moved our `hello` module into its own\n+file, `src/lib.rs`. This is the file that Cargo expects a library crate to\n+be named, by convention.\n+\n+Next, we added an `extern crate modules` to the top of our `src/main.rs`. This,\n+as you can guess, lets Rust know that our crate relies on another, external\n+crate. We also had to modify our call to `print_hello`: now that it's in\n+another crate, we need to first specify the crate, then the module inside of it,\n+then the function name.\n+\n+This doesn't _quite_ work yet. Try it:\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling modules v0.1.0 (file:/home/you/projects/modules)\n+/home/you/projects/modules/src/lib.rs:2:5: 4:6 warning: code is never used: `print_hello`, #[warn(dead_code)] on by default\n+/home/you/projects/modules/src/lib.rs:2     pub fn print_hello() {\n+/home/you/projects/modules/src/lib.rs:3         println!(\"Hello, world!\");\n+/home/you/projects/modules/src/lib.rs:4     }\n+/home/you/projects/modules/src/main.rs:4:5: 4:32 error: function `print_hello` is private\n+/home/you/projects/modules/src/main.rs:4     modules::hello::print_hello();\n+                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n+error: aborting due to previous error\n+Could not compile `modules`.\n+```\n+\n+First, we get a warning that some code is never used. Odd. Next, we get an error:\n+`print_hello` is private, so we can't call it. Notice that the first error came\n+from `src/lib.rs`, and the second came from `src/main.rs`: cargo is smart enough\n+to build it all with one command. Also, after seeing the second error, the warning\n+makes sense: we never actually call `hello_world`, because we're not allowed to!\n+\n+Just like modules, crates also have private visibility by default. Any modules\n+inside of a crate can only be used by other modules in the crate, unless they\n+use `pub`. In `src/lib.rs`, change this line:\n+\n+```{rust,ignore}\n+mod hello {\n+```\n+\n+To this:\n+\n+```{rust,ignore}\n+pub mod hello {\n+```\n+\n+And everything should work:\n+\n+```{notrust,ignore}\n+$ cargo run\n+   Compiling modules v0.1.0 (file:/home/you/projects/modules)\n+     Running `target/modules`\n+Hello, world!\n+```\n+\n+Let's do one more thing: add a `goodbye` module as well. Imagine a `src/lib.rs`\n+that looks like this:\n+\n+```{rust,ignore}\n+pub mod hello {\n+    pub fn print_hello() {\n+        println!(\"Hello, world!\");\n+    }\n+}\n+\n+pub mod goodbye {\n+    pub fn print_goodbye() {\n+        println!(\"Goodbye for now!\");\n+    }\n+}\n+```\n+\n+Now, these two modules are pretty small, but imagine we've written a real, large\n+program: they could both be huge. So maybe we want to move them into their own\n+files. We can do that pretty easily, and there are two different conventions\n+for doing it. Let's give each a try. First, make `src/lib.rs` look like this:\n+\n+```{rust,ignore}\n+pub mod hello;\n+pub mod goodbye;\n+```\n+\n+This tells Rust that this crate has two public modules: `hello` and `goodbye`.\n+\n+Next, make a `src/hello.rs` that contains this:\n+\n+```{rust,ignore}\n+pub fn print_hello() {\n+    println!(\"Hello, world!\");\n+}\n+```\n+\n+When we include a module like this, we don't need to make the `mod` declaration,\n+it's just understood. This helps prevent 'rightward drift': when you end up\n+indenting so many times that your code is hard to read.\n+\n+Finally, make a new directory, `src/goodbye`, and make a new file in it,\n+`src/goodbye/mod.rs`:\n+\n+```{rust,ignore}\n+pub fn print_goodbye() {\n+    println!(\"Bye for now!\");\n+}\n+```\n+\n+Same deal, but we can make a folder with a `mod.rs` instead of `mod_name.rs` in\n+the same directory. If you have a lot of modules, nested folders can make\n+sense.  For example, if the `goodbye` module had its _own_ modules inside of\n+it, putting all of that in a folder helps keep our directory structure tidy.\n+And in fact, if you place the modules in separate files, they're required to be\n+in separate folders.\n+\n+This should all compile as usual:\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling modules v0.1.0 (file:/home/you/projects/modules)\n+$\n+```\n+\n+We've seen how the `::` operator can be used to call into modules, but when\n+we have deep nesting like `modules::hello::say_hello`, it can get tedious.\n+That's why we have the `use` keyword.\n+\n+`use` allows us to bring certain names into another scope. For example, here's\n+our main program:\n+\n+```{rust,ignore}\n+extern crate modules;\n+\n+fn main() {\n+    modules::hello::print_hello();\n+}\n+```\n+\n+We could instead write this:\n+\n+```{rust,ignore}\n+extern crate modules;\n+\n+use modules::hello::print_hello;\n+\n+fn main() {\n+    print_hello();\n+}\n+```\n+\n+By bringing `print_hello` into scope, we don't need to qualify it anymore. However,\n+it's considered proper style to do write this code like like this:\n+\n+```{rust,ignore}\n+extern crate modules;\n+\n+use modules::hello;\n+\n+fn main() {\n+    hello::print_hello();\n+}\n+```\n+\n+By just bringing the module into scope, we can keep one level of namespacing.\n \n # Testing\n \n-attributes\n+## Attributes\n \n-stability markers\n+## Stability Markers\n \n-# Crates and Modules\n+# Pointers\n \n-visibility\n+# Lambdas\n+\n+# iterators\n \n \n # Generics"}]}