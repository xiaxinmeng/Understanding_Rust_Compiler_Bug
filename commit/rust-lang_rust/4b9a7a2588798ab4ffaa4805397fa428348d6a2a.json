{"sha": "4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiOWE3YTI1ODg3OThhYjRmZmFhNDgwNTM5N2ZhNDI4MzQ4ZDZhMmE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-05T05:45:42Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-08T23:58:17Z"}, "message": "collections: replace all ~[T] with Vec<T>.", "tree": {"sha": "02eaefa3d93c36fb2571bdbde26c97ab8d28a210", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02eaefa3d93c36fb2571bdbde26c97ab8d28a210"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "comment_count": 41, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "html_url": "https://github.com/rust-lang/rust/commit/4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3c831ba4a4a2284f73e4f9147aa4900cab56815", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c831ba4a4a2284f73e4f9147aa4900cab56815", "html_url": "https://github.com/rust-lang/rust/commit/d3c831ba4a4a2284f73e4f9147aa4900cab56815"}], "stats": {"total": 425, "additions": 212, "deletions": 213}, "files": [{"sha": "cdcc05bf72983a5c64867b63973f10af71ff2c1c", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "patch": "@@ -111,7 +111,7 @@ impl SmallBitv {\n \n #[deriving(Clone)]\n struct BigBitv {\n-    storage: ~[uint]\n+    storage: Vec<uint>\n }\n \n /**\n@@ -131,7 +131,7 @@ fn big_mask(nbits: uint, elem: uint) -> uint {\n }\n \n impl BigBitv {\n-    pub fn new(storage: ~[uint]) -> BigBitv {\n+    pub fn new(storage: Vec<uint>) -> BigBitv {\n         BigBitv {storage: storage}\n     }\n \n@@ -193,7 +193,7 @@ impl BigBitv {\n     pub fn get(&self, i: uint) -> bool {\n         let w = i / uint::BITS;\n         let b = i % uint::BITS;\n-        let x = 1 & self.storage[w] >> b;\n+        let x = 1 & self.storage.get(w) >> b;\n         x == 1\n     }\n \n@@ -202,15 +202,15 @@ impl BigBitv {\n         let w = i / uint::BITS;\n         let b = i % uint::BITS;\n         let flag = 1 << b;\n-        self.storage[w] = if x { self.storage[w] | flag }\n-                          else { self.storage[w] & !flag };\n+        *self.storage.get_mut(w) = if x { *self.storage.get(w) | flag }\n+                          else { *self.storage.get(w) & !flag };\n     }\n \n     #[inline]\n     pub fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         for (i, elt) in b.storage.iter().enumerate() {\n             let mask = big_mask(nbits, i);\n-            if mask & self.storage[i] != mask & *elt {\n+            if mask & *self.storage.get(i) != mask & *elt {\n                 return false;\n             }\n         }\n@@ -278,13 +278,13 @@ impl Bitv {\n             let s =\n                 if init {\n                     if exact {\n-                        slice::from_elem(nelems, !0u)\n+                        Vec::from_elem(nelems, !0u)\n                     } else {\n-                        let mut v = slice::from_elem(nelems-1, !0u);\n+                        let mut v = Vec::from_elem(nelems-1, !0u);\n                         v.push((1<<nbits % uint::BITS)-1);\n                         v\n                     }\n-                } else { slice::from_elem(nelems, 0u)};\n+                } else { Vec::from_elem(nelems, 0u)};\n             Big(BigBitv::new(s))\n         };\n         Bitv {rep: rep, nbits: nbits}\n@@ -451,8 +451,8 @@ impl Bitv {\n      *\n      * Each `uint` in the resulting vector has either value `0u` or `1u`.\n      */\n-    pub fn to_vec(&self) -> ~[uint] {\n-        slice::from_fn(self.nbits, |x| self.init_to_vec(x))\n+    pub fn to_vec(&self) -> Vec<uint> {\n+        Vec::from_fn(self.nbits, |x| self.init_to_vec(x))\n     }\n \n     /**\n@@ -461,7 +461,7 @@ impl Bitv {\n      * size of the `Bitv` is not a multiple of 8 then trailing bits\n      * will be filled-in with false/0\n      */\n-    pub fn to_bytes(&self) -> ~[u8] {\n+    pub fn to_bytes(&self) -> Vec<u8> {\n         fn bit (bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n             let offset = byte * 8 + bit;\n             if offset >= bitv.nbits {\n@@ -473,7 +473,7 @@ impl Bitv {\n \n         let len = self.nbits/8 +\n                   if self.nbits % 8 == 0 { 0 } else { 1 };\n-        slice::from_fn(len, |i|\n+        Vec::from_fn(len, |i|\n             bit(self, i, 0) |\n             bit(self, i, 1) |\n             bit(self, i, 2) |\n@@ -486,10 +486,10 @@ impl Bitv {\n     }\n \n     /**\n-     * Transform `self` into a `[bool]` by turning each bit into a `bool`.\n+     * Transform `self` into a `Vec<bool>` by turning each bit into a `bool`.\n      */\n-    pub fn to_bools(&self) -> ~[bool] {\n-        slice::from_fn(self.nbits, |i| self[i])\n+    pub fn to_bools(&self) -> Vec<bool> {\n+        Vec::from_fn(self.nbits, |i| self[i])\n     }\n \n     /**\n@@ -659,7 +659,7 @@ pub struct BitvSet {\n impl BitvSet {\n     /// Creates a new bit vector set with initially no contents\n     pub fn new() -> BitvSet {\n-        BitvSet{ size: 0, bitv: BigBitv::new(~[0]) }\n+        BitvSet{ size: 0, bitv: BigBitv::new(vec!(0)) }\n     }\n \n     /// Creates a new bit vector set from the given bit vector\n@@ -673,7 +673,7 @@ impl BitvSet {\n         match rep {\n             Big(b) => BitvSet{ size: size, bitv: b },\n             Small(SmallBitv{bits}) =>\n-                BitvSet{ size: size, bitv: BigBitv{ storage: ~[bits] } },\n+                BitvSet{ size: size, bitv: BigBitv{ storage: vec!(bits) } },\n         }\n     }\n \n@@ -705,9 +705,9 @@ impl BitvSet {\n             self.bitv.storage.grow(other.capacity() / uint::BITS, &0);\n         }\n         for (i, &w) in other.bitv.storage.iter().enumerate() {\n-            let old = self.bitv.storage[i];\n+            let old = *self.bitv.storage.get(i);\n             let new = f(old, w);\n-            self.bitv.storage[i] = new;\n+            *self.bitv.storage.get_mut(i) = new;\n             self.size += nbits(new) - nbits(old);\n         }\n     }\n@@ -863,7 +863,7 @@ impl MutableSet<uint> for BitvSet {\n \n         // Attempt to truncate our storage\n         let mut i = self.bitv.storage.len();\n-        while i > 1 && self.bitv.storage[i - 1] == 0 {\n+        while i > 1 && *self.bitv.storage.get(i - 1) == 0 {\n             i -= 1;\n         }\n         self.bitv.storage.truncate(i);\n@@ -878,12 +878,12 @@ impl BitvSet {\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n     fn commons<'a>(&'a self, other: &'a BitvSet)\n-        -> Map<'static, ((uint, &'a uint), &'a ~[uint]), (uint, uint, uint),\n-               Zip<Enumerate<slice::Items<'a, uint>>, Repeat<&'a ~[uint]>>> {\n+        -> Map<'static, ((uint, &'a uint), &'a Vec<uint>), (uint, uint, uint),\n+               Zip<Enumerate<slice::Items<'a, uint>>, Repeat<&'a Vec<uint>>>> {\n         let min = cmp::min(self.bitv.storage.len(), other.bitv.storage.len());\n         self.bitv.storage.slice(0, min).iter().enumerate()\n             .zip(Repeat::new(&other.bitv.storage))\n-            .map(|((i, &w), o_store)| (i * uint::BITS, w, o_store[i]))\n+            .map(|((i, &w), o_store)| (i * uint::BITS, w, *o_store.get(i)))\n     }\n \n     /// Visits each word in `self` or `other` that extends beyond the other. This\n@@ -946,7 +946,6 @@ mod tests {\n     use bitv;\n \n     use std::uint;\n-    use std::slice;\n     use rand;\n     use rand::Rng;\n \n@@ -964,8 +963,8 @@ mod tests {\n     #[test]\n     fn test_0_elements() {\n         let act = Bitv::new(0u, false);\n-        let exp = slice::from_elem::<bool>(0u, false);\n-        assert!(act.eq_vec(exp));\n+        let exp = Vec::from_elem(0u, false);\n+        assert!(act.eq_vec(exp.as_slice()));\n     }\n \n     #[test]\n@@ -1299,12 +1298,12 @@ mod tests {\n     fn test_to_bytes() {\n         let mut bv = Bitv::new(3, true);\n         bv.set(1, false);\n-        assert_eq!(bv.to_bytes(), ~[0b10100000]);\n+        assert_eq!(bv.to_bytes(), vec!(0b10100000));\n \n         let mut bv = Bitv::new(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n-        assert_eq!(bv.to_bytes(), ~[0b00100000, 0b10000000]);\n+        assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n     }\n \n     #[test]\n@@ -1315,7 +1314,7 @@ mod tests {\n \n     #[test]\n     fn test_to_bools() {\n-        let bools = ~[false, false, true, false, false, true, true, false];\n+        let bools = vec!(false, false, true, false, false, true, true, false);\n         assert_eq!(from_bytes([0b00100110]).to_bools(), bools);\n     }\n \n@@ -1334,8 +1333,8 @@ mod tests {\n         let bools = [true, false, true, true];\n         let bitv = BitvSet::from_bitv(from_bools(bools));\n \n-        let idxs: ~[uint] = bitv.iter().collect();\n-        assert_eq!(idxs, ~[0, 2, 3]);\n+        let idxs: Vec<uint> = bitv.iter().collect();\n+        assert_eq!(idxs, vec!(0, 2, 3));\n     }\n \n     #[test]\n@@ -1579,7 +1578,7 @@ mod tests {\n     #[bench]\n     fn bench_big_bitv_small(b: &mut BenchHarness) {\n         let mut r = rng();\n-        let mut bitv = BigBitv::new(~[0]);\n+        let mut bitv = BigBitv::new(vec!(0));\n         b.iter(|| {\n             bitv.set((r.next_u32() as uint) % uint::BITS, true);\n             &bitv\n@@ -1589,7 +1588,7 @@ mod tests {\n     #[bench]\n     fn bench_big_bitv_big(b: &mut BenchHarness) {\n         let mut r = rng();\n-        let mut storage = ~[];\n+        let mut storage = vec!();\n         storage.grow(BENCH_BITS / uint::BITS, &0u);\n         let mut bitv = BigBitv::new(storage);\n         b.iter(|| {"}, {"sha": "c317ed926f668bd8dd6e5717b54f17ba9446fb51", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "patch": "@@ -35,7 +35,7 @@ impl<K: TotalOrd, V> BTree<K, V> {\n     ///The lower bound applies to every node except the root node.\n     pub fn new(k: K, v: V, lb: uint) -> BTree<K, V> {\n         BTree {\n-            root: Node::new_leaf(~[LeafElt::new(k, v)]),\n+            root: Node::new_leaf(vec!(LeafElt::new(k, v))),\n             len: 1,\n             lower_bound: lb,\n             upper_bound: 2 * lb\n@@ -135,12 +135,12 @@ enum Node<K, V> {\n //Node functions/methods\n impl<K: TotalOrd, V> Node<K, V> {\n     ///Creates a new leaf node given a vector of elements.\n-    fn new_leaf(vec: ~[LeafElt<K, V>]) -> Node<K,V> {\n+    fn new_leaf(vec: Vec<LeafElt<K, V>>) -> Node<K,V> {\n         LeafNode(Leaf::new(vec))\n     }\n \n     ///Creates a new branch node given a vector of an elements and a pointer to a rightmost child.\n-    fn new_branch(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Node<K, V> {\n+    fn new_branch(vec: Vec<BranchElt<K, V>>, right: ~Node<K, V>) -> Node<K, V> {\n         BranchNode(Branch::new(vec, right))\n     }\n \n@@ -264,19 +264,19 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Node<K, V> {\n //A leaf is a vector with elements that contain no children.  A leaf also\n //does not contain a rightmost child.\n struct Leaf<K, V> {\n-    elts: ~[LeafElt<K, V>]\n+    elts: Vec<LeafElt<K, V>>\n }\n \n //Vector of values with children, plus a rightmost child (greater than all)\n struct Branch<K, V> {\n-    elts: ~[BranchElt<K,V>],\n+    elts: Vec<BranchElt<K,V>>,\n     rightmost_child: ~Node<K, V>\n }\n \n \n impl<K: TotalOrd, V> Leaf<K, V> {\n     ///Creates a new Leaf from a vector of LeafElts.\n-    fn new(vec: ~[LeafElt<K, V>]) -> Leaf<K, V> {\n+    fn new(vec: Vec<LeafElt<K, V>>) -> Leaf<K, V> {\n         Leaf {\n             elts: vec\n         }\n@@ -292,14 +292,14 @@ impl<K: TotalOrd, V> Leaf<K, V> {\n             midpoint = 0;\n         }\n         loop {\n-            let order = self.elts[midpoint].key.cmp(&k);\n+            let order = self.elts.get(midpoint).key.cmp(&k);\n             match order {\n                 Equal => {\n                     return None;\n                 }\n                 Greater => {\n                     if midpoint > 0 {\n-                        if self.elts[midpoint - 1].key.cmp(&k) == Less {\n+                        if self.elts.get(midpoint - 1).key.cmp(&k) == Less {\n                             return Some(midpoint);\n                         }\n                         else {\n@@ -315,7 +315,7 @@ impl<K: TotalOrd, V> Leaf<K, V> {\n                 }\n                 Less => {\n                     if midpoint + 1 < self.elts.len() {\n-                        if self.elts[midpoint + 1].key.cmp(&k) == Greater {\n+                        if self.elts.get(midpoint + 1).key.cmp(&k) == Greater {\n                             return Some(midpoint);\n                         }\n                         else {\n@@ -375,9 +375,9 @@ impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V> {\n             let (left_leaf, right_leaf) = self.elts.partition(|le|\n                                                               le.key.cmp(&midpoint.key.clone())\n                                                               == Less);\n-            let branch_return = Node::new_branch(~[BranchElt::new(midpoint.key.clone(),\n+            let branch_return = Node::new_branch(vec!(BranchElt::new(midpoint.key.clone(),\n                                                                   midpoint.value.clone(),\n-                                                             ~Node::new_leaf(left_leaf))],\n+                                                             ~Node::new_leaf(left_leaf))),\n                                             ~Node::new_leaf(right_leaf));\n             return (branch_return, true);\n         }\n@@ -415,7 +415,7 @@ impl<K: TotalOrd, V: TotalEq> TotalOrd for Leaf<K, V> {\n         if self.elts.len() < other.elts.len() {\n             return Less;\n         }\n-        self.elts[0].cmp(&other.elts[0])\n+        self.elts.get(0).cmp(other.elts.get(0))\n     }\n }\n \n@@ -434,7 +434,7 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Leaf<K, V> {\n \n impl<K: TotalOrd, V> Branch<K, V> {\n     ///Creates a new Branch from a vector of BranchElts and a rightmost child (a node).\n-    fn new(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Branch<K, V> {\n+    fn new(vec: Vec<BranchElt<K, V>>, right: ~Node<K, V>) -> Branch<K, V> {\n         Branch {\n             elts: vec,\n             rightmost_child: right\n@@ -449,14 +449,14 @@ impl<K: TotalOrd, V> Branch<K, V> {\n             midpoint = 0u;\n         }\n         loop {\n-            let order = self.elts[midpoint].key.cmp(&k);\n+            let order = self.elts.get(midpoint).key.cmp(&k);\n             match order {\n                 Equal => {\n                     return None;\n                 }\n                 Greater => {\n                     if midpoint > 0 {\n-                        if self.elts[midpoint - 1].key.cmp(&k) == Less {\n+                        if self.elts.get(midpoint - 1).key.cmp(&k) == Less {\n                             return Some(midpoint);\n                         }\n                         else {\n@@ -472,7 +472,7 @@ impl<K: TotalOrd, V> Branch<K, V> {\n                 }\n                 Less => {\n                     if midpoint + 1 < self.elts.len() {\n-                        if self.elts[midpoint + 1].key.cmp(&k) == Greater {\n+                        if self.elts.get(midpoint + 1).key.cmp(&k) == Greater {\n                             return Some(midpoint);\n                         }\n                         else {\n@@ -527,7 +527,7 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n                     outcome = new_outcome.val1();\n                 }\n                 else {\n-                    let new_outcome = self.clone().elts[index.unwrap()].left.insert(k.clone(),\n+                    let new_outcome = self.elts.get(index.unwrap()).left.clone().insert(k.clone(),\n                                                                                  v.clone(),\n                                                                                  ub.clone());\n                     new_branch = new_outcome.clone().val0();\n@@ -543,7 +543,7 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n                             self.rightmost_child = ~new_branch.clone();\n                         }\n                         else {\n-                            self.elts[index.unwrap()].left = ~new_branch.clone();\n+                            self.elts.get_mut(index.unwrap()).left = ~new_branch.clone();\n                         }\n                         return (Node::new_branch(self.clone().elts,\n                                                  self.clone().rightmost_child),\n@@ -564,7 +564,7 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n                         self.rightmost_child = ~new_branch;\n                     }\n                     else {\n-                        self.elts[index.unwrap()].left = ~new_branch;\n+                        self.elts.get_mut(index.unwrap()).left = ~new_branch;\n                     }\n                     return (Node::new_branch(self.clone().elts,\n                                              self.clone().rightmost_child),\n@@ -573,7 +573,7 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n                 //If we have a new branch node, attempt to insert it into the tree\n                 //as with the key-value pair, then check to see if the node is overfull.\n                 BranchNode(branch) => {\n-                    let new_elt = branch.clone().elts[0];\n+                    let new_elt = branch.elts.get(0).clone();\n                     let new_elt_index = self.bsearch_branch(new_elt.clone().key);\n                     match new_elt_index {\n                         None => {\n@@ -587,7 +587,7 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n                                 self.rightmost_child = branch.clone().rightmost_child;\n                             }\n                             else {\n-                                self.elts[new_elt_index.unwrap() + 1].left =\n+                                self.elts.get_mut(new_elt_index.unwrap() + 1).left =\n                                     branch.clone().rightmost_child;\n                             }\n                         }\n@@ -602,10 +602,10 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n                                                                 midpoint.key.cmp(&le.key)\n                                                                         == Greater);\n                 new_branch = Node::new_branch(\n-                    ~[BranchElt::new(midpoint.clone().key,\n+                    vec!(BranchElt::new(midpoint.clone().key,\n                                      midpoint.clone().value,\n                                      ~Node::new_branch(new_left,\n-                                                       midpoint.clone().left))],\n+                                                       midpoint.clone().left))),\n                     ~Node::new_branch(new_right, self.clone().rightmost_child));\n                 return (new_branch, true);\n             }\n@@ -644,7 +644,7 @@ impl<K: TotalOrd, V: TotalEq> TotalOrd for Branch<K, V> {\n         if self.elts.len() < other.elts.len() {\n             return Less;\n         }\n-        self.elts[0].cmp(&other.elts[0])\n+        self.elts.get(0).cmp(other.elts.get(0))\n     }\n }\n \n@@ -787,7 +787,7 @@ mod test_btree {\n         let leaf_elt_1 = LeafElt::new(1, ~\"aaa\");\n         let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n         let leaf_elt_3 = LeafElt::new(3, ~\"ccc\");\n-        let n = Node::new_leaf(~[leaf_elt_1, leaf_elt_2, leaf_elt_3]);\n+        let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3));\n         let b = BTree::new_with_node_len(n, 3, 2);\n         //println!(\"{}\", b.clone().insert(4, ~\"ddd\").to_str());\n         assert!(b.insert(4, ~\"ddd\").root.is_leaf());\n@@ -799,7 +799,7 @@ mod test_btree {\n         let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n         let leaf_elt_3 = LeafElt::new(3, ~\"ccc\");\n         let leaf_elt_4 = LeafElt::new(4, ~\"ddd\");\n-        let n = Node::new_leaf(~[leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4]);\n+        let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let b = BTree::new_with_node_len(n, 3, 2);\n         //println!(\"{}\", b.clone().insert(5, ~\"eee\").to_str());\n         assert!(!b.insert(5, ~\"eee\").root.is_leaf());\n@@ -811,7 +811,7 @@ mod test_btree {\n         let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n         let leaf_elt_3 = LeafElt::new(3, ~\"ccc\");\n         let leaf_elt_4 = LeafElt::new(4, ~\"ddd\");\n-        let n = Node::new_leaf(~[leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4]);\n+        let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let mut b = BTree::new_with_node_len(n, 3, 2);\n         b = b.clone().insert(5, ~\"eee\");\n         b = b.clone().insert(6, ~\"fff\");\n@@ -840,7 +840,7 @@ mod test_btree {\n         let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n         let leaf_elt_3 = LeafElt::new(4, ~\"ccc\");\n         let leaf_elt_4 = LeafElt::new(5, ~\"ddd\");\n-        let n = Node::new_leaf(~[leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4]);\n+        let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let b = BTree::new_with_node_len(n, 3, 2);\n         assert_eq!(Some(2), b.root.bsearch_node(3));\n     }\n@@ -851,7 +851,7 @@ mod test_btree {\n         let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n         let leaf_elt_3 = LeafElt::new(4, ~\"ccc\");\n         let leaf_elt_4 = LeafElt::new(5, ~\"ddd\");\n-        let n = Node::new_leaf(~[leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4]);\n+        let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let b = BTree::new_with_node_len(n, 3, 2);\n         assert_eq!(Some(4), b.root.bsearch_node(800));\n     }"}, {"sha": "24d3e2c617ce878cfbef0cde3d00b0db1e6c0ec7", "filename": "src/libcollections/deque.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdeque.rs?ref=4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "patch": "@@ -44,7 +44,6 @@ pub mod bench {\n     extern crate test;\n     use self::test::BenchHarness;\n     use std::container::MutableMap;\n-    use std::slice;\n     use rand;\n     use rand::Rng;\n \n@@ -90,18 +89,18 @@ pub mod bench {\n                                                 bh: &mut BenchHarness) {\n         // setup\n         let mut rng = rand::weak_rng();\n-        let mut keys = slice::from_fn(n, |_| rng.gen::<uint>() % n);\n+        let mut keys = Vec::from_fn(n, |_| rng.gen::<uint>() % n);\n \n         for k in keys.iter() {\n             map.insert(*k, 1);\n         }\n \n-        rng.shuffle(keys);\n+        rng.shuffle(keys.as_mut_slice());\n \n         // measure\n         let mut i = 0;\n         bh.iter(|| {\n-            map.find(&(keys[i]));\n+            map.find(keys.get(i));\n             i = (i + 1) % n;\n         })\n     }"}, {"sha": "3c1c7a3a8864267d8c887226aaf5647b52bbd966", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "patch": "@@ -739,12 +739,12 @@ mod tests {\n             check_links(&m);\n         }\n \n-        let v = ~[1,2,3,4,5];\n-        let u = ~[9,8,1,2,3,4,5];\n-        let mut m = list_from(v);\n-        m.append(list_from(u));\n+        let v = vec![1,2,3,4,5];\n+        let u = vec![9,8,1,2,3,4,5];\n+        let mut m = list_from(v.as_slice());\n+        m.append(list_from(u.as_slice()));\n         check_links(&m);\n-        let sum = v + u;\n+        let sum = v.append(u.as_slice());\n         assert_eq!(sum.len(), m.len());\n         for elt in sum.move_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n@@ -763,12 +763,12 @@ mod tests {\n             check_links(&m);\n         }\n \n-        let v = ~[1,2,3,4,5];\n-        let u = ~[9,8,1,2,3,4,5];\n-        let mut m = list_from(v);\n-        m.prepend(list_from(u));\n+        let v = vec![1,2,3,4,5];\n+        let u = vec![9,8,1,2,3,4,5];\n+        let mut m = list_from(v.as_slice());\n+        m.prepend(list_from(u.as_slice()));\n         check_links(&m);\n-        let sum = u + v;\n+        let sum = u.append(v.as_slice());\n         assert_eq!(sum.len(), m.len());\n         for elt in sum.move_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n@@ -783,19 +783,19 @@ mod tests {\n         n.rotate_forward(); check_links(&n);\n         assert_eq!(n.len(), 0);\n \n-        let v = ~[1,2,3,4,5];\n-        let mut m = list_from(v);\n+        let v = vec![1,2,3,4,5];\n+        let mut m = list_from(v.as_slice());\n         m.rotate_backward(); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n-        assert_eq!(v.iter().collect::<~[&int]>(), m.iter().collect());\n+        assert_eq!(v.iter().collect::<Vec<&int>>(), m.iter().collect());\n         m.rotate_forward(); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n         m.pop_front(); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n         m.rotate_backward(); check_links(&m);\n         m.push_front(9); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n-        assert_eq!(~[3,9,5,1,2], m.move_iter().collect());\n+        assert_eq!(vec![3,9,5,1,2], m.move_iter().collect());\n     }\n \n     #[test]\n@@ -925,7 +925,7 @@ mod tests {\n         }\n         check_links(&m);\n         assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.move_iter().collect::<~[int]>(), ~[-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n+        assert_eq!(m.move_iter().collect::<Vec<int>>(), vec![-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n     }\n \n     #[test]\n@@ -936,8 +936,8 @@ mod tests {\n         m.merge(n, |a, b| a <= b);\n         assert_eq!(m.len(), len);\n         check_links(&m);\n-        let res = m.move_iter().collect::<~[int]>();\n-        assert_eq!(res, ~[-1, 0, 0, 0, 1, 3, 5, 6, 7, 2, 7, 7, 9]);\n+        let res = m.move_iter().collect::<Vec<int>>();\n+        assert_eq!(res, vec![-1, 0, 0, 0, 1, 3, 5, 6, 7, 2, 7, 7, 9]);\n     }\n \n     #[test]\n@@ -952,7 +952,7 @@ mod tests {\n         m.push_back(4);\n         m.insert_ordered(3);\n         check_links(&m);\n-        assert_eq!(~[2,3,4], m.move_iter().collect::<~[int]>());\n+        assert_eq!(vec![2,3,4], m.move_iter().collect::<Vec<int>>());\n     }\n \n     #[test]\n@@ -974,7 +974,7 @@ mod tests {\n         let n = list_from([1,2,3]);\n         spawn(proc() {\n             check_links(&n);\n-            assert_eq!(~[&1,&2,&3], n.iter().collect::<~[&int]>());\n+            assert_eq!(&[&1,&2,&3], n.iter().collect::<Vec<&int>>().as_slice());\n         });\n     }\n \n@@ -1047,7 +1047,7 @@ mod tests {\n     #[cfg(test)]\n     fn fuzz_test(sz: int) {\n         let mut m: DList<int> = DList::new();\n-        let mut v = ~[];\n+        let mut v = vec![];\n         for i in range(0, sz) {\n             check_links(&m);\n             let r: u8 = rand::random();"}, {"sha": "8249faad19a0865624350929cee69c1cd605b25e", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "patch": "@@ -246,24 +246,24 @@ mod test {\n     fn test_iterator() {\n         let mut e1: EnumSet<Foo> = EnumSet::empty();\n \n-        let elems: ~[Foo] = e1.iter().collect();\n-        assert_eq!(~[], elems)\n+        let elems: Vec<Foo> = e1.iter().collect();\n+        assert!(elems.is_empty())\n \n         e1.add(A);\n-        let elems: ~[Foo] = e1.iter().collect();\n-        assert_eq!(~[A], elems)\n+        let elems = e1.iter().collect();\n+        assert_eq!(vec![A], elems)\n \n         e1.add(C);\n-        let elems: ~[Foo] = e1.iter().collect();\n-        assert_eq!(~[A,C], elems)\n+        let elems = e1.iter().collect();\n+        assert_eq!(vec![A,C], elems)\n \n         e1.add(C);\n-        let elems: ~[Foo] = e1.iter().collect();\n-        assert_eq!(~[A,C], elems)\n+        let elems = e1.iter().collect();\n+        assert_eq!(vec![A,C], elems)\n \n         e1.add(B);\n-        let elems: ~[Foo] = e1.iter().collect();\n-        assert_eq!(~[A,B,C], elems)\n+        let elems = e1.iter().collect();\n+        assert_eq!(vec![A,B,C], elems)\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -280,15 +280,15 @@ mod test {\n         e2.add(C);\n \n         let e_union = e1 | e2;\n-        let elems: ~[Foo] = e_union.iter().collect();\n-        assert_eq!(~[A,B,C], elems)\n+        let elems = e_union.iter().collect();\n+        assert_eq!(vec![A,B,C], elems)\n \n         let e_intersection = e1 & e2;\n-        let elems: ~[Foo] = e_intersection.iter().collect();\n-        assert_eq!(~[C], elems)\n+        let elems = e_intersection.iter().collect();\n+        assert_eq!(vec![C], elems)\n \n         let e_subtract = e1 - e2;\n-        let elems: ~[Foo] = e_subtract.iter().collect();\n-        assert_eq!(~[A], elems)\n+        let elems = e_subtract.iter().collect();\n+        assert_eq!(vec![A], elems)\n     }\n }"}, {"sha": "dadf92a58e0290ce8d32e6c721316ffd56868034", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "patch": "@@ -81,7 +81,7 @@ mod table {\n     /// You can kind of think of this module/data structure as a safe wrapper\n     /// around just the \"table\" part of the hashtable. It enforces some\n     /// invariants at the type level and employs some performance trickery,\n-    /// but in general is just a tricked out `~[Option<u64, K, V>]`.\n+    /// but in general is just a tricked out `Vec<Option<u64, K, V>>`.\n     ///\n     /// FIXME(cgaebel):\n     ///\n@@ -1833,8 +1833,8 @@ mod test_map {\n             hm\n         };\n \n-        let v = hm.move_iter().collect::<~[(char, int)]>();\n-        assert!([('a', 1), ('b', 2)] == v || [('b', 2), ('a', 1)] == v);\n+        let v = hm.move_iter().collect::<Vec<(char, int)>>();\n+        assert!([('a', 1), ('b', 2)] == v.as_slice() || [('b', 2), ('a', 1)] == v.as_slice());\n     }\n \n     #[test]\n@@ -1856,9 +1856,9 @@ mod test_map {\n \n     #[test]\n     fn test_keys() {\n-        let vec = ~[(1, 'a'), (2, 'b'), (3, 'c')];\n+        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n         let map = vec.move_iter().collect::<HashMap<int, char>>();\n-        let keys = map.keys().map(|&k| k).collect::<~[int]>();\n+        let keys = map.keys().map(|&k| k).collect::<Vec<int>>();\n         assert_eq!(keys.len(), 3);\n         assert!(keys.contains(&1));\n         assert!(keys.contains(&2));\n@@ -1867,9 +1867,9 @@ mod test_map {\n \n     #[test]\n     fn test_values() {\n-        let vec = ~[(1, 'a'), (2, 'b'), (3, 'c')];\n+        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n         let map = vec.move_iter().collect::<HashMap<int, char>>();\n-        let values = map.values().map(|&v| v).collect::<~[char]>();\n+        let values = map.values().map(|&v| v).collect::<Vec<char>>();\n         assert_eq!(values.len(), 3);\n         assert!(values.contains(&'a'));\n         assert!(values.contains(&'b'));\n@@ -1942,7 +1942,7 @@ mod test_map {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = ~[(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n         let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n@@ -2133,7 +2133,7 @@ mod test_set {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = ~[1, 2, 3, 4, 5, 6, 7, 8, 9];\n+        let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n \n         let set: HashSet<int> = xs.iter().map(|&x| x).collect();\n \n@@ -2153,8 +2153,8 @@ mod test_set {\n             hs\n         };\n \n-        let v = hs.move_iter().collect::<~[char]>();\n-        assert!(['a', 'b'] == v || ['b', 'a'] == v);\n+        let v = hs.move_iter().collect::<Vec<char>>();\n+        assert!(['a', 'b'] == v.as_slice() || ['b', 'a'] == v.as_slice());\n     }\n \n     #[test]"}, {"sha": "2121e129c35235206944d3a99bd024cef4b52549", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "patch": "@@ -22,6 +22,8 @@\n \n #![feature(macro_rules, managed_boxes, default_type_params, phase)]\n \n+#![deny(deprecated_owned_vector)]\n+\n extern crate rand;\n \n #[cfg(test)] extern crate test;"}, {"sha": "87b1fee1d27d9e1d018fc7dc553578a9a4328274", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "patch": "@@ -294,10 +294,10 @@ mod tests {\n \n     #[test]\n     fn test_put_update() {\n-        let mut cache: LruCache<~str, ~[u8]> = LruCache::new(1);\n-        cache.put(~\"1\", ~[10, 10]);\n-        cache.put(~\"1\", ~[10, 19]);\n-        assert_opt_eq(cache.get(&~\"1\"), ~[10, 19]);\n+        let mut cache: LruCache<~str, Vec<u8>> = LruCache::new(1);\n+        cache.put(~\"1\", vec![10, 10]);\n+        cache.put(~\"1\", vec![10, 19]);\n+        assert_opt_eq(cache.get(&~\"1\"), vec![10, 19]);\n         assert_eq!(cache.len(), 1);\n     }\n "}, {"sha": "2ebbf65b9e5d1599e54bec62babad58a8c85b76f", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "patch": "@@ -19,7 +19,7 @@ use std::slice;\n /// A priority queue implemented with a binary heap\n #[deriving(Clone)]\n pub struct PriorityQueue<T> {\n-    data: ~[T],\n+    data: Vec<T>,\n }\n \n impl<T:Ord> Container for PriorityQueue<T> {\n@@ -40,7 +40,7 @@ impl<T:Ord> PriorityQueue<T> {\n     }\n \n     /// Returns the greatest item in the queue - fails if empty\n-    pub fn top<'a>(&'a self) -> &'a T { &self.data[0] }\n+    pub fn top<'a>(&'a self) -> &'a T { self.data.get(0) }\n \n     /// Returns the greatest item in the queue - None if empty\n     pub fn maybe_top<'a>(&'a self) -> Option<&'a T> {\n@@ -64,7 +64,7 @@ impl<T:Ord> PriorityQueue<T> {\n     pub fn pop(&mut self) -> T {\n         let mut item = self.data.pop().unwrap();\n         if !self.is_empty() {\n-            swap(&mut item, &mut self.data[0]);\n+            swap(&mut item, self.data.get_mut(0));\n             self.siftdown(0);\n         }\n         item\n@@ -84,46 +84,46 @@ impl<T:Ord> PriorityQueue<T> {\n \n     /// Optimized version of a push followed by a pop\n     pub fn push_pop(&mut self, mut item: T) -> T {\n-        if !self.is_empty() && self.data[0] > item {\n-            swap(&mut item, &mut self.data[0]);\n+        if !self.is_empty() && *self.top() > item {\n+            swap(&mut item, self.data.get_mut(0));\n             self.siftdown(0);\n         }\n         item\n     }\n \n     /// Optimized version of a pop followed by a push - fails if empty\n     pub fn replace(&mut self, mut item: T) -> T {\n-        swap(&mut item, &mut self.data[0]);\n+        swap(&mut item, self.data.get_mut(0));\n         self.siftdown(0);\n         item\n     }\n \n     /// Consume the PriorityQueue and return the underlying vector\n-    pub fn to_vec(self) -> ~[T] { let PriorityQueue{data: v} = self; v }\n+    pub fn to_vec(self) -> Vec<T> { let PriorityQueue{data: v} = self; v }\n \n     /// Consume the PriorityQueue and return a vector in sorted\n     /// (ascending) order\n-    pub fn to_sorted_vec(self) -> ~[T] {\n+    pub fn to_sorted_vec(self) -> Vec<T> {\n         let mut q = self;\n         let mut end = q.len();\n         while end > 1 {\n             end -= 1;\n-            q.data.swap(0, end);\n+            q.data.as_mut_slice().swap(0, end);\n             q.siftdown_range(0, end)\n         }\n         q.to_vec()\n     }\n \n     /// Create an empty PriorityQueue\n-    pub fn new() -> PriorityQueue<T> { PriorityQueue{data: ~[],} }\n+    pub fn new() -> PriorityQueue<T> { PriorityQueue{data: vec!(),} }\n \n     /// Create an empty PriorityQueue with capacity `capacity`\n     pub fn with_capacity(capacity: uint) -> PriorityQueue<T> {\n-        PriorityQueue { data: slice::with_capacity(capacity) }\n+        PriorityQueue { data: Vec::with_capacity(capacity) }\n     }\n \n     /// Create a PriorityQueue from a vector (heapify)\n-    pub fn from_vec(xs: ~[T]) -> PriorityQueue<T> {\n+    pub fn from_vec(xs: Vec<T>) -> PriorityQueue<T> {\n         let mut q = PriorityQueue{data: xs,};\n         let mut n = q.len() / 2;\n         while n > 0 {\n@@ -140,40 +140,40 @@ impl<T:Ord> PriorityQueue<T> {\n     // compared to using swaps, which involves twice as many moves.\n     fn siftup(&mut self, start: uint, mut pos: uint) {\n         unsafe {\n-            let new = replace(&mut self.data[pos], init());\n+            let new = replace(self.data.get_mut(pos), init());\n \n             while pos > start {\n                 let parent = (pos - 1) >> 1;\n-                if new > self.data[parent] {\n-                    let x = replace(&mut self.data[parent], init());\n-                    move_val_init(&mut self.data[pos], x);\n+                if new > *self.data.get(parent) {\n+                    let x = replace(self.data.get_mut(parent), init());\n+                    move_val_init(self.data.get_mut(pos), x);\n                     pos = parent;\n                     continue\n                 }\n                 break\n             }\n-            move_val_init(&mut self.data[pos], new);\n+            move_val_init(self.data.get_mut(pos), new);\n         }\n     }\n \n     fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n         unsafe {\n             let start = pos;\n-            let new = replace(&mut self.data[pos], init());\n+            let new = replace(self.data.get_mut(pos), init());\n \n             let mut child = 2 * pos + 1;\n             while child < end {\n                 let right = child + 1;\n-                if right < end && !(self.data[child] > self.data[right]) {\n+                if right < end && !(*self.data.get(child) > *self.data.get(right)) {\n                     child = right;\n                 }\n-                let x = replace(&mut self.data[child], init());\n-                move_val_init(&mut self.data[pos], x);\n+                let x = replace(self.data.get_mut(child), init());\n+                move_val_init(self.data.get_mut(pos), x);\n                 pos = child;\n                 child = 2 * pos + 1;\n             }\n \n-            move_val_init(&mut self.data[pos], new);\n+            move_val_init(self.data.get_mut(pos), new);\n             self.siftup(start, pos);\n         }\n     }\n@@ -224,8 +224,8 @@ mod tests {\n \n     #[test]\n     fn test_iterator() {\n-        let data = ~[5, 9, 3];\n-        let iterout = ~[9, 5, 3];\n+        let data = vec!(5, 9, 3);\n+        let iterout = [9, 5, 3];\n         let pq = PriorityQueue::from_vec(data);\n         let mut i = 0;\n         for el in pq.iter() {\n@@ -236,7 +236,7 @@ mod tests {\n \n     #[test]\n     fn test_top_and_pop() {\n-        let data = ~[2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n+        let data = vec!(2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1);\n         let mut sorted = data.clone();\n         sorted.sort();\n         let mut heap = PriorityQueue::from_vec(data);\n@@ -248,7 +248,7 @@ mod tests {\n \n     #[test]\n     fn test_push() {\n-        let mut heap = PriorityQueue::from_vec(~[2, 4, 9]);\n+        let mut heap = PriorityQueue::from_vec(vec!(2, 4, 9));\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.top() == 9);\n         heap.push(11);\n@@ -270,7 +270,7 @@ mod tests {\n \n     #[test]\n     fn test_push_unique() {\n-        let mut heap = PriorityQueue::from_vec(~[~2, ~4, ~9]);\n+        let mut heap = PriorityQueue::from_vec(vec!(~2, ~4, ~9));\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.top() == ~9);\n         heap.push(~11);\n@@ -292,7 +292,7 @@ mod tests {\n \n     #[test]\n     fn test_push_pop() {\n-        let mut heap = PriorityQueue::from_vec(~[5, 5, 2, 1, 3]);\n+        let mut heap = PriorityQueue::from_vec(vec!(5, 5, 2, 1, 3));\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.push_pop(6), 6);\n         assert_eq!(heap.len(), 5);\n@@ -306,7 +306,7 @@ mod tests {\n \n     #[test]\n     fn test_replace() {\n-        let mut heap = PriorityQueue::from_vec(~[5, 5, 2, 1, 3]);\n+        let mut heap = PriorityQueue::from_vec(vec!(5, 5, 2, 1, 3));\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.replace(6), 5);\n         assert_eq!(heap.len(), 5);\n@@ -318,7 +318,7 @@ mod tests {\n         assert_eq!(heap.len(), 5);\n     }\n \n-    fn check_to_vec(mut data: ~[int]) {\n+    fn check_to_vec(mut data: Vec<int>) {\n         let heap = PriorityQueue::from_vec(data.clone());\n         let mut v = heap.clone().to_vec();\n         v.sort();\n@@ -330,19 +330,19 @@ mod tests {\n \n     #[test]\n     fn test_to_vec() {\n-        check_to_vec(~[]);\n-        check_to_vec(~[5]);\n-        check_to_vec(~[3, 2]);\n-        check_to_vec(~[2, 3]);\n-        check_to_vec(~[5, 1, 2]);\n-        check_to_vec(~[1, 100, 2, 3]);\n-        check_to_vec(~[1, 3, 5, 7, 9, 2, 4, 6, 8, 0]);\n-        check_to_vec(~[2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n-        check_to_vec(~[9, 11, 9, 9, 9, 9, 11, 2, 3, 4, 11, 9, 0, 0, 0, 0]);\n-        check_to_vec(~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n-        check_to_vec(~[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]);\n-        check_to_vec(~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 1, 2]);\n-        check_to_vec(~[5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1]);\n+        check_to_vec(vec!());\n+        check_to_vec(vec!(5));\n+        check_to_vec(vec!(3, 2));\n+        check_to_vec(vec!(2, 3));\n+        check_to_vec(vec!(5, 1, 2));\n+        check_to_vec(vec!(1, 100, 2, 3));\n+        check_to_vec(vec!(1, 3, 5, 7, 9, 2, 4, 6, 8, 0));\n+        check_to_vec(vec!(2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1));\n+        check_to_vec(vec!(9, 11, 9, 9, 9, 9, 11, 2, 3, 4, 11, 9, 0, 0, 0, 0));\n+        check_to_vec(vec!(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n+        check_to_vec(vec!(10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0));\n+        check_to_vec(vec!(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 1, 2));\n+        check_to_vec(vec!(5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1));\n     }\n \n     #[test]\n@@ -380,9 +380,9 @@ mod tests {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = ~[9u, 8, 7, 6, 5, 4, 3, 2, 1];\n+        let xs = vec!(9u, 8, 7, 6, 5, 4, 3, 2, 1);\n \n-        let mut q: PriorityQueue<uint> = xs.rev_iter().map(|&x| x).collect();\n+        let mut q: PriorityQueue<uint> = xs.as_slice().rev_iter().map(|&x| x).collect();\n \n         for &x in xs.iter() {\n             assert_eq!(q.pop(), x);"}, {"sha": "c61fcd0c76bbd8220b319aaab445ba52517f7403", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "patch": "@@ -14,7 +14,6 @@\n //! collections::deque::Deque`.\n \n use std::cmp;\n-use std::slice;\n use std::iter::{Rev, RandomAccessIterator};\n \n use deque::Deque;\n@@ -27,7 +26,7 @@ static MINIMUM_CAPACITY: uint = 2u;\n pub struct RingBuf<T> {\n     nelts: uint,\n     lo: uint,\n-    elts: ~[Option<T>]\n+    elts: Vec<Option<T>>\n }\n \n impl<T> Container for RingBuf<T> {\n@@ -67,7 +66,7 @@ impl<T> Deque<T> for RingBuf<T> {\n \n     /// Remove and return the first element in the RingBuf, or None if it is empty\n     fn pop_front(&mut self) -> Option<T> {\n-        let result = self.elts[self.lo].take();\n+        let result = self.elts.get_mut(self.lo).take();\n         if result.is_some() {\n             self.lo = (self.lo + 1u) % self.elts.len();\n             self.nelts -= 1u;\n@@ -80,7 +79,7 @@ impl<T> Deque<T> for RingBuf<T> {\n         if self.nelts > 0 {\n             self.nelts -= 1;\n             let hi = self.raw_index(self.nelts);\n-            self.elts[hi].take()\n+            self.elts.get_mut(hi).take()\n         } else {\n             None\n         }\n@@ -94,7 +93,7 @@ impl<T> Deque<T> for RingBuf<T> {\n         if self.lo == 0u {\n             self.lo = self.elts.len() - 1u;\n         } else { self.lo -= 1u; }\n-        self.elts[self.lo] = Some(t);\n+        *self.elts.get_mut(self.lo) = Some(t);\n         self.nelts += 1u;\n     }\n \n@@ -104,7 +103,7 @@ impl<T> Deque<T> for RingBuf<T> {\n             grow(self.nelts, &mut self.lo, &mut self.elts);\n         }\n         let hi = self.raw_index(self.nelts);\n-        self.elts[hi] = Some(t);\n+        *self.elts.get_mut(hi) = Some(t);\n         self.nelts += 1u;\n     }\n }\n@@ -118,15 +117,15 @@ impl<T> RingBuf<T> {\n     /// Create an empty RingBuf with space for at least `n` elements.\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n         RingBuf{nelts: 0, lo: 0,\n-              elts: slice::from_fn(cmp::max(MINIMUM_CAPACITY, n), |_| None)}\n+              elts: Vec::from_fn(cmp::max(MINIMUM_CAPACITY, n), |_| None)}\n     }\n \n     /// Retrieve an element in the RingBuf by index\n     ///\n     /// Fails if there is no element with the given index\n     pub fn get<'a>(&'a self, i: uint) -> &'a T {\n         let idx = self.raw_index(i);\n-        match self.elts[idx] {\n+        match *self.elts.get(idx) {\n             None => fail!(),\n             Some(ref v) => v\n         }\n@@ -137,7 +136,7 @@ impl<T> RingBuf<T> {\n     /// Fails if there is no element with the given index\n     pub fn get_mut<'a>(&'a mut self, i: uint) -> &'a mut T {\n         let idx = self.raw_index(i);\n-        match self.elts[idx] {\n+        match *self.elts.get_mut(idx) {\n             None => fail!(),\n             Some(ref mut v) => v\n         }\n@@ -153,7 +152,7 @@ impl<T> RingBuf<T> {\n         assert!(j < self.len());\n         let ri = self.raw_index(i);\n         let rj = self.raw_index(j);\n-        self.elts.swap(ri, rj);\n+        self.elts.as_mut_slice().swap(ri, rj);\n     }\n \n     /// Return index in underlying vec for a given logical element index\n@@ -188,7 +187,7 @@ impl<T> RingBuf<T> {\n \n     /// Front-to-back iterator.\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts}\n+        Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts.as_slice()}\n     }\n \n     /// Back-to-front iterator.\n@@ -333,7 +332,7 @@ impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n \n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n-fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut ~[Option<T>]) {\n+fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut Vec<Option<T>>) {\n     assert_eq!(nelts, elts.len());\n     let lo = *loptr;\n     let newlen = nelts * 2;\n@@ -356,11 +355,11 @@ fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut ~[Option<T>]) {\n     assert!(newlen - nelts/2 >= nelts);\n     if lo <= (nelts - lo) { // A\n         for i in range(0u, lo) {\n-            elts.swap(i, nelts + i);\n+            elts.as_mut_slice().swap(i, nelts + i);\n         }\n     } else {                // B\n         for i in range(lo, nelts) {\n-            elts.swap(i, newlen - nelts + i);\n+            elts.as_mut_slice().swap(i, newlen - nelts + i);\n         }\n         *loptr += newlen - nelts;\n     }\n@@ -671,7 +670,7 @@ mod tests {\n         let mut d: RingBuf<int> = range(0, 5).collect();\n         d.pop_front();\n         d.swap(0, 3);\n-        assert_eq!(d.iter().map(|&x|x).collect::<~[int]>(), ~[4, 2, 3, 1]);\n+        assert_eq!(d.iter().map(|&x|x).collect::<Vec<int>>(), vec!(4, 2, 3, 1));\n     }\n \n     #[test]\n@@ -683,12 +682,12 @@ mod tests {\n         for i in range(0, 5) {\n             d.push_back(i);\n         }\n-        assert_eq!(d.iter().collect::<~[&int]>(), ~[&0,&1,&2,&3,&4]);\n+        assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), &[&0,&1,&2,&3,&4]);\n \n         for i in range(6, 9) {\n             d.push_front(i);\n         }\n-        assert_eq!(d.iter().collect::<~[&int]>(), ~[&8,&7,&6,&0,&1,&2,&3,&4]);\n+        assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), &[&8,&7,&6,&0,&1,&2,&3,&4]);\n \n         let mut it = d.iter();\n         let mut len = d.len();\n@@ -708,12 +707,12 @@ mod tests {\n         for i in range(0, 5) {\n             d.push_back(i);\n         }\n-        assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0]);\n+        assert_eq!(d.rev_iter().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0]);\n \n         for i in range(6, 9) {\n             d.push_front(i);\n         }\n-        assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0,&6,&7,&8]);\n+        assert_eq!(d.rev_iter().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0,&6,&7,&8]);\n     }\n \n     #[test]\n@@ -727,8 +726,8 @@ mod tests {\n         assert_eq!(d.pop_front(), Some(1));\n         d.push_back(4);\n \n-        assert_eq!(d.mut_rev_iter().map(|x| *x).collect::<~[int]>(),\n-                   ~[4, 3, 2]);\n+        assert_eq!(d.mut_rev_iter().map(|x| *x).collect::<Vec<int>>(),\n+                   vec!(4, 3, 2));\n     }\n \n     #[test]\n@@ -780,9 +779,9 @@ mod tests {\n     #[test]\n     fn test_from_iter() {\n         use std::iter;\n-        let v = ~[1,2,3,4,5,6,7];\n+        let v = vec!(1,2,3,4,5,6,7);\n         let deq: RingBuf<int> = v.iter().map(|&x| x).collect();\n-        let u: ~[int] = deq.iter().map(|&x| x).collect();\n+        let u: Vec<int> = deq.iter().map(|&x| x).collect();\n         assert_eq!(u, v);\n \n         let mut seq = iter::count(0u, 2).take(256);"}, {"sha": "4485987b15b4088f407ae6901b40ffd7b68573a6", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "patch": "@@ -17,11 +17,11 @@\n \n use std::iter::{Enumerate, FilterMap, Rev};\n use std::mem::replace;\n-use std::slice;\n+use std::{vec, slice};\n \n #[allow(missing_doc)]\n pub struct SmallIntMap<T> {\n-    v: ~[Option<T>],\n+    v: Vec<Option<T>>,\n }\n \n impl<V> Container for SmallIntMap<V> {\n@@ -45,7 +45,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n         if *key < self.v.len() {\n-            match self.v[*key] {\n+            match *self.v.get(*key) {\n               Some(ref value) => Some(value),\n               None => None\n             }\n@@ -59,7 +59,7 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n     /// Return a mutable reference to the value corresponding to the key\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n         if *key < self.v.len() {\n-            match self.v[*key] {\n+            match *self.v.get_mut(*key) {\n               Some(ref mut value) => Some(value),\n               None => None\n             }\n@@ -77,7 +77,7 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n         if len <= key {\n             self.v.grow_fn(key - len + 1, |_| None);\n         }\n-        self.v[key] = Some(value);\n+        *self.v.get_mut(key) = Some(value);\n         !exists\n     }\n \n@@ -104,17 +104,17 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n         if *key >= self.v.len() {\n             return None;\n         }\n-        self.v[*key].take()\n+        self.v.get_mut(*key).take()\n     }\n }\n \n impl<V> SmallIntMap<V> {\n     /// Create an empty SmallIntMap\n-    pub fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n+    pub fn new() -> SmallIntMap<V> { SmallIntMap{v: vec!()} }\n \n     /// Create an empty SmallIntMap with capacity `capacity`\n     pub fn with_capacity(capacity: uint) -> SmallIntMap<V> {\n-        SmallIntMap { v: slice::with_capacity(capacity) }\n+        SmallIntMap { v: Vec::with_capacity(capacity) }\n     }\n \n     pub fn get<'a>(&'a self, key: &uint) -> &'a V {\n@@ -158,9 +158,9 @@ impl<V> SmallIntMap<V> {\n     /// Empties the hash map, moving all values into the specified closure\n     pub fn move_iter(&mut self)\n         -> FilterMap<(uint, Option<V>), (uint, V),\n-                Enumerate<slice::MoveItems<Option<V>>>>\n+                Enumerate<vec::MoveItems<Option<V>>>>\n     {\n-        let values = replace(&mut self.v, ~[]);\n+        let values = replace(&mut self.v, vec!());\n         values.move_iter().enumerate().filter_map(|(i, v)| {\n             v.map(|v| (i, v))\n         })"}, {"sha": "1846ca0013e862c2c0d499ac21be1691a1a47452", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "patch": "@@ -139,7 +139,7 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Requires that it be frozen (immutable).\n     pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n         Entries {\n-            stack: ~[],\n+            stack: vec!(),\n             node: deref(&self.root),\n             remaining_min: self.length,\n             remaining_max: self.length\n@@ -156,7 +156,7 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// map, with the values being mutable.\n     pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n         MutEntries {\n-            stack: ~[],\n+            stack: vec!(),\n             node: mut_deref(&mut self.root),\n             remaining_min: self.length,\n             remaining_max: self.length\n@@ -173,8 +173,8 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     pub fn move_iter(self) -> MoveEntries<K, V> {\n         let TreeMap { root: root, length: length } = self;\n         let stk = match root {\n-            None => ~[],\n-            Some(~tn) => ~[tn]\n+            None => vec!(),\n+            Some(~tn) => vec!(tn)\n         };\n         MoveEntries {\n             stack: stk,\n@@ -222,7 +222,7 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// `traverse_left`/`traverse_right`/`traverse_complete`.\n     fn iter_for_traversal<'a>(&'a self) -> Entries<'a, K, V> {\n         Entries {\n-            stack: ~[],\n+            stack: vec!(),\n             node: deref(&self.root),\n             remaining_min: 0,\n             remaining_max: self.length\n@@ -245,7 +245,7 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// `traverse_left`/`traverse_right`/`traverse_complete`.\n     fn mut_iter_for_traversal<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n         MutEntries {\n-            stack: ~[],\n+            stack: vec!(),\n             node: mut_deref(&mut self.root),\n             remaining_min: 0,\n             remaining_max: self.length\n@@ -273,7 +273,7 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n \n /// Lazy forward iterator over a map\n pub struct Entries<'a, K, V> {\n-    stack: ~[&'a TreeNode<K, V>],\n+    stack: Vec<&'a TreeNode<K, V>>,\n     // See the comment on MutEntries; this is just to allow\n     // code-sharing (for this immutable-values iterator it *could* very\n     // well be Option<&'a TreeNode<K,V>>).\n@@ -290,7 +290,7 @@ pub struct RevEntries<'a, K, V> {\n /// Lazy forward iterator over a map that allows for the mutation of\n /// the values.\n pub struct MutEntries<'a, K, V> {\n-    stack: ~[&'a mut TreeNode<K, V>],\n+    stack: Vec<&'a mut TreeNode<K, V>>,\n     // Unfortunately, we require some unsafe-ness to get around the\n     // fact that we would be storing a reference *into* one of the\n     // nodes in the stack.\n@@ -482,7 +482,7 @@ fn mut_deref<K, V>(x: &mut Option<~TreeNode<K, V>>) -> *mut TreeNode<K, V> {\n \n /// Lazy forward iterator over a map that consumes the map while iterating\n pub struct MoveEntries<K, V> {\n-    stack: ~[TreeNode<K, V>],\n+    stack: Vec<TreeNode<K, V>>,\n     remaining: uint\n }\n \n@@ -1143,9 +1143,9 @@ mod test_treemap {\n     #[test]\n     fn test_rand_int() {\n         let mut map: TreeMap<int,int> = TreeMap::new();\n-        let mut ctrl = ~[];\n+        let mut ctrl = vec![];\n \n-        check_equal(ctrl, &map);\n+        check_equal(ctrl.as_slice(), &map);\n         assert!(map.find(&5).is_none());\n \n         let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(&[42]);\n@@ -1158,7 +1158,7 @@ mod test_treemap {\n                     assert!(map.insert(k, v));\n                     ctrl.push((k, v));\n                     check_structure(&map);\n-                    check_equal(ctrl, &map);\n+                    check_equal(ctrl.as_slice(), &map);\n                 }\n             }\n \n@@ -1167,7 +1167,7 @@ mod test_treemap {\n                 let (key, _) = ctrl.remove(r).unwrap();\n                 assert!(map.remove(&key));\n                 check_structure(&map);\n-                check_equal(ctrl, &map);\n+                check_equal(ctrl.as_slice(), &map);\n             }\n         }\n     }\n@@ -1414,7 +1414,7 @@ mod test_treemap {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = ~[(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n         let map: TreeMap<int, int> = xs.iter().map(|&x| x).collect();\n \n@@ -1725,7 +1725,7 @@ mod test_set {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = ~[1, 2, 3, 4, 5, 6, 7, 8, 9];\n+        let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n \n         let set: TreeSet<int> = xs.iter().map(|&x| x).collect();\n "}, {"sha": "5c290d56da39aff74f64b481532d240ad2900fa7", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9a7a2588798ab4ffaa4805397fa428348d6a2a/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=4b9a7a2588798ab4ffaa4805397fa428348d6a2a", "patch": "@@ -774,7 +774,7 @@ mod test_map {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = ~[(1u, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+        let xs = vec![(1u, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n         let map: TrieMap<int> = xs.iter().map(|&x| x).collect();\n \n@@ -1042,7 +1042,7 @@ mod test_set {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = ~[9u, 8, 7, 6, 5, 4, 3, 2, 1];\n+        let xs = vec![9u, 8, 7, 6, 5, 4, 3, 2, 1];\n \n         let set: TrieSet = xs.iter().map(|&x| x).collect();\n "}]}