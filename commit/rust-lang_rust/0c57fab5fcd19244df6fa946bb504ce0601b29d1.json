{"sha": "0c57fab5fcd19244df6fa946bb504ce0601b29d1", "node_id": "C_kwDOAAsO6NoAKDBjNTdmYWI1ZmNkMTkyNDRkZjZmYTk0NmJiNTA0Y2UwNjAxYjI5ZDE", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-11-25T00:58:49Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-11-30T21:54:53Z"}, "message": "Add conditional support for coverage map version 6\n\nThis commit augments Swatinem's initial commit in uncommitted PR #90047,\nwhich was a great starting point, but did not fully support LLVM\nCoverage Mapping Format version 6.\n\nVersion 6 requires adding the compilation directory when file paths are\nrelative, and since Rustc coverage maps use relative paths, we should\nadd the expected compilation directory entry.\n\nNote, however, that with the compilation directory, coverage reports\nfrom `llvm-cov show` can now report file names (when the report includes\nmore than one file) with the full absolute path to the file.\n\nThis would be a problem for test results, but the workaround (for the\nrust coverage tests) is to include an additional `llvm-cov show`\nparameter: `--compilation-dir=.`", "tree": {"sha": "5d6b5c16a885b57e7ebebfbc287cd63434ffc6b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d6b5c16a885b57e7ebebfbc287cd63434ffc6b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c57fab5fcd19244df6fa946bb504ce0601b29d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c57fab5fcd19244df6fa946bb504ce0601b29d1", "html_url": "https://github.com/rust-lang/rust/commit/0c57fab5fcd19244df6fa946bb504ce0601b29d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c57fab5fcd19244df6fa946bb504ce0601b29d1/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "566ad8da451a85ba2e45126cb7ad64f55450e31d", "url": "https://api.github.com/repos/rust-lang/rust/commits/566ad8da451a85ba2e45126cb7ad64f55450e31d", "html_url": "https://github.com/rust-lang/rust/commit/566ad8da451a85ba2e45126cb7ad64f55450e31d"}], "stats": {"total": 60, "additions": 47, "deletions": 13}, "files": [{"sha": "0390caaec33e55ef40f8710c521cd56134837e88", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0c57fab5fcd19244df6fa946bb504ce0601b29d1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c57fab5fcd19244df6fa946bb504ce0601b29d1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=0c57fab5fcd19244df6fa946bb504ce0601b29d1", "patch": "@@ -9,6 +9,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_llvm::RustString;\n use rustc_middle::mir::coverage::CodeRegion;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::Symbol;\n \n use std::ffi::CString;\n@@ -17,9 +18,10 @@ use tracing::debug;\n \n /// Generates and exports the Coverage Map.\n ///\n-/// This Coverage Map complies with Coverage Mapping Format version 5 (zero-based encoded as 4),\n-/// as defined at [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n-/// This version is supported by the LLVM coverage tools (`llvm-profdata` and `llvm-cov`)\n+/// Rust Coverage Map generation supports LLVM Coverage Mapping Format versions\n+/// 5 (LLVM 12, only) and 6 (zero-based encoded as 4 and 5, respectively), as defined at\n+/// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n+/// These versions are supported by the LLVM coverage tools (`llvm-profdata` and `llvm-cov`)\n /// bundled with Rust's fork of LLVM.\n ///\n /// Consequently, Rust's bundled version of Clang also generates Coverage Maps compliant with\n@@ -30,12 +32,13 @@ use tracing::debug;\n pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     let tcx = cx.tcx;\n \n-    // While our bundled LLVM might support Coverage Map Version 6\n-    // (encoded as a zero-based value: 5), we clamp that to Version 5,\n-    // as Version 6 would require us to use the 0-th filename as a path prefix\n-    // for all other relative paths, which we don't take advantage of right now.\n-    let _version = coverageinfo::mapping_version();\n-    let version = 4;\n+    // Ensure the installed version of LLVM supports at least Coverage Map\n+    // Version 5 (encoded as a zero-based value: 4), which was introduced with\n+    // LLVM 12.\n+    let version = coverageinfo::mapping_version();\n+    if version < 4 {\n+        tcx.sess.fatal(\"rustc option `-Z instrument-coverage` requires LLVM 12 or higher.\");\n+    }\n \n     debug!(\"Generating coverage map for CodegenUnit: `{}`\", cx.codegen_unit.name());\n \n@@ -57,7 +60,7 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n         return;\n     }\n \n-    let mut mapgen = CoverageMapGenerator::new();\n+    let mut mapgen = CoverageMapGenerator::new(tcx, version);\n \n     // Encode coverage mappings and generate function records\n     let mut function_data = Vec::new();\n@@ -112,8 +115,26 @@ struct CoverageMapGenerator {\n }\n \n impl CoverageMapGenerator {\n-    fn new() -> Self {\n-        Self { filenames: FxIndexSet::default() }\n+    fn new(tcx: TyCtxt<'_>, version: u32) -> Self {\n+        let mut filenames = FxIndexSet::default();\n+        if version >= 5 {\n+            // LLVM Coverage Mapping Format version 6 (zero-based encoded as 5)\n+            // requires setting the first filename to the compilation directory.\n+            // Since rustc generates coverage maps with relative paths, the\n+            // compilation directory can be combined with the the relative paths\n+            // to get absolute paths, if needed.\n+            let working_dir = tcx\n+                .sess\n+                .opts\n+                .working_dir\n+                .remapped_path_if_available()\n+                .to_string_lossy()\n+                .to_string();\n+            let c_filename =\n+                CString::new(working_dir).expect(\"null error converting filename to C string\");\n+            filenames.insert(c_filename);\n+        }\n+        Self { filenames }\n     }\n \n     /// Using the `expressions` and `counter_regions` collected for the current function, generate"}, {"sha": "f4d1ca0ec691130ffe2bcd74006655ae213d1012", "filename": "src/doc/unstable-book/src/compiler-flags/instrument-coverage.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c57fab5fcd19244df6fa946bb504ce0601b29d1/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Finstrument-coverage.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c57fab5fcd19244df6fa946bb504ce0601b29d1/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Finstrument-coverage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Finstrument-coverage.md?ref=0c57fab5fcd19244df6fa946bb504ce0601b29d1", "patch": "@@ -20,7 +20,7 @@ This document describes how to enable and use the LLVM instrumentation-based cov\n When `-Z instrument-coverage` is enabled, the Rust compiler enhances rust-based libraries and binaries by:\n \n -   Automatically injecting calls to an LLVM intrinsic ([`llvm.instrprof.increment`]), at functions and branches in compiled code, to increment counters when conditional sections of code are executed.\n--   Embedding additional information in the data section of each library and binary (using the [LLVM Code Coverage Mapping Format] _Version 5_, supported _only_ in LLVM 12 and up), to define the code regions (start and end positions in the source code) being counted.\n+-   Embedding additional information in the data section of each library and binary (using the [LLVM Code Coverage Mapping Format] _Version 5_, if compiling with LLVM 12, or _Version 6_, if compiling with LLVM 13 or higher), to define the code regions (start and end positions in the source code) being counted.\n \n When running a coverage-instrumented program, the counter values are written to a `profraw` file at program termination. LLVM bundles tools that read the counter results, combine those results with the coverage map (embedded in the program binary), and generate coverage reports in multiple formats.\n "}, {"sha": "3c4df3533e147f512a481954d373fdd95e20214a", "filename": "src/test/run-make-fulldeps/coverage-llvmir/Makefile", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c57fab5fcd19244df6fa946bb504ce0601b29d1/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0c57fab5fcd19244df6fa946bb504ce0601b29d1/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir%2FMakefile?ref=0c57fab5fcd19244df6fa946bb504ce0601b29d1", "patch": "@@ -1,5 +1,11 @@\n # needs-profiler-support\n \n+# Rust coverage maps support LLVM Coverage Mapping Format versions 5 and 6,\n+# corresponding with LLVM versions 12 and 13, respectively.\n+# When upgrading LLVM versions, consider whether to enforce a minimum LLVM\n+# version during testing, with an additional directive at the top of this file\n+# that sets, for example: `min-llvm-version: 12.0`\n+\n -include ../coverage/coverage_tools.mk\n \n BASEDIR=../coverage-llvmir"}, {"sha": "9122e0406c2efc49ce6d7131de87b01d3b5264b5", "filename": "src/test/run-make-fulldeps/coverage-reports/Makefile", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c57fab5fcd19244df6fa946bb504ce0601b29d1/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0c57fab5fcd19244df6fa946bb504ce0601b29d1/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile?ref=0c57fab5fcd19244df6fa946bb504ce0601b29d1", "patch": "@@ -1,6 +1,12 @@\n # needs-profiler-support\n # ignore-windows-gnu\n \n+# Rust coverage maps support LLVM Coverage Mapping Format versions 5 and 6,\n+# corresponding with LLVM versions 12 and 13, respectively.\n+# When upgrading LLVM versions, consider whether to enforce a minimum LLVM\n+# version during testing, with an additional directive at the top of this file\n+# that sets, for example: `min-llvm-version: 12.0`\n+\n # FIXME(mati865): MinGW GCC miscompiles compiler-rt profiling library but with Clang it works\n # properly. Since we only have GCC on the CI ignore the test for now.\n \n@@ -115,6 +121,7 @@ endif\n \t\"$(LLVM_BIN_DIR)\"/llvm-cov show \\\n \t\t\t$(DEBUG_FLAG) \\\n \t\t\t$(LLVM_COV_IGNORE_FILES) \\\n+\t\t\t--compilation-dir=. \\\n \t\t\t--Xdemangler=\"$(RUST_DEMANGLER)\" \\\n \t\t\t--show-line-counts-or-regions \\\n \t\t\t--instr-profile=\"$(TMPDIR)\"/$@.profdata \\"}]}