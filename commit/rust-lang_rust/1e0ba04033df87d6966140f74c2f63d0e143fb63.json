{"sha": "1e0ba04033df87d6966140f74c2f63d0e143fb63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMGJhMDQwMzNkZjg3ZDY5NjYxNDBmNzRjMmY2M2QwZTE0M2ZiNjM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-15T09:29:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-15T09:29:36Z"}, "message": "Merge #3966 #3968\n\n3966: Add support for bounds on associated types in trait definitions r=matklad a=flodiebold\n\nE.g.\r\n```rust\r\ntrait Trait {\r\n    type Item: SomeOtherTrait;\r\n}\r\n```\r\nNote that these don't simply desugar to where clauses; as I understand it, where clauses have to be proved by the *user* of the trait, but these bounds are proved by the *implementor*. (Also, where clauses on associated types are unstable.)\r\n\r\n(Another one from my recursive solver branch...)\n\n3968: Remove format from syntax_bridge hot path r=matklad a=edwin0cheng\n\nAlthough only around 1% speed up by running:\r\n\r\n```\r\nMeasure-Command {start-process .\\target\\release\\rust-analyzer \"analysis-stats -q .\" -NoNewWindow -wait}\r\n```\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "1e74385af4f803b04943a47cb40d0abd9d76e41d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e74385af4f803b04943a47cb40d0abd9d76e41d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e0ba04033df87d6966140f74c2f63d0e143fb63", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeltQACRBK7hj4Ov3rIwAAdHIIABb+M1vploq5NWAbrPM7r8jJ\numlOQVRW/7Obv42GE8+hTnSYQG4nVfppazg8p9n2a8EN9FYkaJl5JTrZCMtQ8nON\nDuXd0RfxCo8UYMwew0KiRqbecLgrhNqnTtx89Bus6Mn8Ab5lIrqn1RNHWNGx8msW\nazd8e657fjc1ViZQ94KXvVF+lSTprr0revlKfpIVrAz1TkiiC3KLtGOf5cMkCbao\n/fcoDqyhyYcjSDIXucB42HjC8jeMxXcGfBUT3WYh7igbEqzOmArw3Et8x/KWZDEO\nyMkI5TV/03KvtzWPJ7PsgdvLuPwq4XYZUG3iQbvmal8KoQYWElMlSgGUv58F9xM=\n=+rV4\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e74385af4f803b04943a47cb40d0abd9d76e41d\nparent d61909f9047ba94c4ed9af580193958257ab21e6\nparent c8b2ec8c20be44ae19d15e90ff812745f029899e\nparent 464af68ec56b1b35151acc3b53eea3d3d67e03d3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586942976 +0000\ncommitter GitHub <noreply@github.com> 1586942976 +0000\n\nMerge #3966 #3968\n\n3966: Add support for bounds on associated types in trait definitions r=matklad a=flodiebold\n\nE.g.\r\n```rust\r\ntrait Trait {\r\n    type Item: SomeOtherTrait;\r\n}\r\n```\r\nNote that these don't simply desugar to where clauses; as I understand it, where clauses have to be proved by the *user* of the trait, but these bounds are proved by the *implementor*. (Also, where clauses on associated types are unstable.)\r\n\r\n(Another one from my recursive solver branch...)\n\n3968: Remove format from syntax_bridge hot path r=matklad a=edwin0cheng\n\nAlthough only around 1% speed up by running:\r\n\r\n```\r\nMeasure-Command {start-process .\\target\\release\\rust-analyzer \"analysis-stats -q .\" -NoNewWindow -wait}\r\n```\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e0ba04033df87d6966140f74c2f63d0e143fb63", "html_url": "https://github.com/rust-lang/rust/commit/1e0ba04033df87d6966140f74c2f63d0e143fb63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e0ba04033df87d6966140f74c2f63d0e143fb63/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d61909f9047ba94c4ed9af580193958257ab21e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d61909f9047ba94c4ed9af580193958257ab21e6", "html_url": "https://github.com/rust-lang/rust/commit/d61909f9047ba94c4ed9af580193958257ab21e6"}, {"sha": "c8b2ec8c20be44ae19d15e90ff812745f029899e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8b2ec8c20be44ae19d15e90ff812745f029899e", "html_url": "https://github.com/rust-lang/rust/commit/c8b2ec8c20be44ae19d15e90ff812745f029899e"}, {"sha": "464af68ec56b1b35151acc3b53eea3d3d67e03d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/464af68ec56b1b35151acc3b53eea3d3d67e03d3", "html_url": "https://github.com/rust-lang/rust/commit/464af68ec56b1b35151acc3b53eea3d3d67e03d3"}], "stats": {"total": 135, "additions": 119, "deletions": 16}, "files": [{"sha": "ccb682f9abb2f42bd10ae387119cfb1d7b1ea129", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1e0ba04033df87d6966140f74c2f63d0e143fb63/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0ba04033df87d6966140f74c2f63d0e143fb63/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=1e0ba04033df87d6966140f74c2f63d0e143fb63", "patch": "@@ -9,7 +9,8 @@ use hir_expand::{\n };\n use ra_prof::profile;\n use ra_syntax::ast::{\n-    self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner, VisibilityOwner,\n+    self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner, TypeBoundsOwner,\n+    VisibilityOwner,\n };\n \n use crate::{\n@@ -110,6 +111,7 @@ pub struct TypeAliasData {\n     pub name: Name,\n     pub type_ref: Option<TypeRef>,\n     pub visibility: RawVisibility,\n+    pub bounds: Vec<TypeBound>,\n }\n \n impl TypeAliasData {\n@@ -122,9 +124,17 @@ impl TypeAliasData {\n         let name = node.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let type_ref = node.value.type_ref().map(TypeRef::from_ast);\n         let vis_default = RawVisibility::default_for_container(loc.container);\n-        let visibility =\n-            RawVisibility::from_ast_with_default(db, vis_default, node.map(|n| n.visibility()));\n-        Arc::new(TypeAliasData { name, type_ref, visibility })\n+        let visibility = RawVisibility::from_ast_with_default(\n+            db,\n+            vis_default,\n+            node.as_ref().map(|n| n.visibility()),\n+        );\n+        let bounds = if let Some(bound_list) = node.value.type_bound_list() {\n+            bound_list.bounds().map(TypeBound::from_ast).collect()\n+        } else {\n+            Vec::new()\n+        };\n+        Arc::new(TypeAliasData { name, type_ref, visibility, bounds })\n     }\n }\n "}, {"sha": "b3a2fc4395dfae992bd9819827b9f4ada3c35f9f", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1e0ba04033df87d6966140f74c2f63d0e143fb63/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0ba04033df87d6966140f74c2f63d0e143fb63/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=1e0ba04033df87d6966140f74c2f63d0e143fb63", "patch": "@@ -2093,6 +2093,33 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn associated_type_bound() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+pub trait Trait {\n+    type Item: OtherTrait<u32>;\n+}\n+pub trait OtherTrait<T> {\n+    fn foo(&self) -> T;\n+}\n+\n+// this is just a workaround for chalk#234\n+pub struct S<T>;\n+impl<T: Trait> Trait for S<T> {\n+    type Item = <T as Trait>::Item;\n+}\n+\n+fn test<T: Trait>() {\n+    let y: <S<T> as Trait>::Item = no_matter;\n+    y.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n #[test]\n fn dyn_trait_through_chalk() {\n     let t = type_at("}, {"sha": "44fbdb19701594c3eefd87876d44338b42a559f5", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e0ba04033df87d6966140f74c2f63d0e143fb63/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0ba04033df87d6966140f74c2f63d0e143fb63/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=1e0ba04033df87d6966140f74c2f63d0e143fb63", "patch": "@@ -194,13 +194,16 @@ fn solve(\n         }\n         remaining > 0\n     };\n-    let mut solve = || solver.solve_limited(&context, goal, should_continue);\n+    let mut solve = || {\n+        let solution = solver.solve_limited(&context, goal, should_continue);\n+        log::debug!(\"solve({:?}) => {:?}\", goal, solution);\n+        solution\n+    };\n     // don't set the TLS for Chalk unless Chalk debugging is active, to make\n     // extra sure we only use it for debugging\n     let solution =\n         if is_chalk_debug() { chalk::tls::set_current_program(db, solve) } else { solve() };\n \n-    log::debug!(\"solve({:?}) => {:?}\", goal, solution);\n     solution\n }\n "}, {"sha": "55eb0ffcb0bf999714ebb3af90b4879fc92d759f", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1e0ba04033df87d6966140f74c2f63d0e143fb63/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0ba04033df87d6966140f74c2f63d0e143fb63/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=1e0ba04033df87d6966140f74c2f63d0e143fb63", "patch": "@@ -673,6 +673,55 @@ fn convert_where_clauses(\n     result\n }\n \n+fn generic_predicate_to_inline_bound(\n+    db: &dyn HirDatabase,\n+    pred: &GenericPredicate,\n+    self_ty: &Ty,\n+) -> Option<chalk_rust_ir::InlineBound<Interner>> {\n+    // An InlineBound is like a GenericPredicate, except the self type is left out.\n+    // We don't have a special type for this, but Chalk does.\n+    match pred {\n+        GenericPredicate::Implemented(trait_ref) => {\n+            if &trait_ref.substs[0] != self_ty {\n+                // we can only convert predicates back to type bounds if they\n+                // have the expected self type\n+                return None;\n+            }\n+            let args_no_self = trait_ref.substs[1..]\n+                .iter()\n+                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n+                .collect();\n+            let trait_bound =\n+                chalk_rust_ir::TraitBound { trait_id: trait_ref.trait_.to_chalk(db), args_no_self };\n+            Some(chalk_rust_ir::InlineBound::TraitBound(trait_bound))\n+        }\n+        GenericPredicate::Projection(proj) => {\n+            if &proj.projection_ty.parameters[0] != self_ty {\n+                return None;\n+            }\n+            let trait_ = match proj.projection_ty.associated_ty.lookup(db.upcast()).container {\n+                AssocContainerId::TraitId(t) => t,\n+                _ => panic!(\"associated type not in trait\"),\n+            };\n+            let args_no_self = proj.projection_ty.parameters[1..]\n+                .iter()\n+                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n+                .collect();\n+            let alias_eq_bound = chalk_rust_ir::AliasEqBound {\n+                value: proj.ty.clone().to_chalk(db),\n+                trait_bound: chalk_rust_ir::TraitBound {\n+                    trait_id: trait_.to_chalk(db),\n+                    args_no_self,\n+                },\n+                associated_ty_id: proj.projection_ty.associated_ty.to_chalk(db),\n+                parameters: Vec::new(), // FIXME we don't support generic associated types yet\n+            };\n+            Some(chalk_rust_ir::InlineBound::AliasEqBound(alias_eq_bound))\n+        }\n+        GenericPredicate::Error => None,\n+    }\n+}\n+\n impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn associated_ty_data(&self, id: AssocTypeId) -> Arc<AssociatedTyDatum> {\n         self.db.associated_ty_data(id)\n@@ -761,12 +810,25 @@ pub(crate) fn associated_ty_data_query(\n         AssocContainerId::TraitId(t) => t,\n         _ => panic!(\"associated type not in trait\"),\n     };\n+\n+    // Lower bounds -- we could/should maybe move this to a separate query in `lower`\n+    let type_alias_data = db.type_alias_data(type_alias);\n     let generic_params = generics(db.upcast(), type_alias.into());\n-    let bound_data = chalk_rust_ir::AssociatedTyDatumBound {\n-        // FIXME add bounds and where clauses\n-        bounds: vec![],\n-        where_clauses: vec![],\n-    };\n+    let bound_vars = Substs::bound_vars(&generic_params);\n+    let resolver = hir_def::resolver::HasResolver::resolver(type_alias, db.upcast());\n+    let ctx = crate::TyLoweringContext::new(db, &resolver)\n+        .with_type_param_mode(crate::lower::TypeParamLoweringMode::Variable);\n+    let self_ty = Ty::Bound(crate::BoundVar::new(crate::DebruijnIndex::INNERMOST, 0));\n+    let bounds = type_alias_data\n+        .bounds\n+        .iter()\n+        .flat_map(|bound| GenericPredicate::from_type_bound(&ctx, bound, self_ty.clone()))\n+        .filter_map(|pred| generic_predicate_to_inline_bound(db, &pred, &self_ty))\n+        .map(|bound| make_binders(bound.shifted_in(&Interner), 0))\n+        .collect();\n+\n+    let where_clauses = convert_where_clauses(db, type_alias.into(), &bound_vars);\n+    let bound_data = chalk_rust_ir::AssociatedTyDatumBound { bounds, where_clauses };\n     let datum = AssociatedTyDatum {\n         trait_id: trait_.to_chalk(db),\n         id,"}, {"sha": "31e9b22e7dc415bc40504f3016dabf80e71a3d21", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1e0ba04033df87d6966140f74c2f63d0e143fb63/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e0ba04033df87d6966140f74c2f63d0e143fb63/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=1e0ba04033df87d6966140f74c2f63d0e143fb63", "patch": "@@ -607,12 +607,13 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n             let text: SmolStr = match self.cursor.token_tree() {\n                 Some(tt::TokenTree::Leaf(leaf)) => {\n                     // Mark the range if needed\n-                    let id = match leaf {\n-                        tt::Leaf::Ident(ident) => ident.id,\n-                        tt::Leaf::Punct(punct) => punct.id,\n-                        tt::Leaf::Literal(lit) => lit.id,\n+                    let (text, id) = match leaf {\n+                        tt::Leaf::Ident(ident) => (ident.text.clone(), ident.id),\n+                        tt::Leaf::Punct(punct) => {\n+                            (SmolStr::new_inline_from_ascii(1, &[punct.char as u8]), punct.id)\n+                        }\n+                        tt::Leaf::Literal(lit) => (lit.text.clone(), lit.id),\n                     };\n-                    let text = SmolStr::new(format!(\"{}\", leaf));\n                     let range = TextRange::offset_len(self.text_pos, TextUnit::of_str(&text));\n                     self.token_map.insert(id, range);\n                     self.cursor = self.cursor.bump();"}]}