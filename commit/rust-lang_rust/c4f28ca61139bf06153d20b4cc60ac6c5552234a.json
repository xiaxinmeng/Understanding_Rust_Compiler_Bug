{"sha": "c4f28ca61139bf06153d20b4cc60ac6c5552234a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ZjI4Y2E2MTEzOWJmMDYxNTNkMjBiNGNjNjBhYzZjNTU1MjIzNGE=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-07-09T04:25:41Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-07-09T07:31:55Z"}, "message": "Rewrite closure capture analysis", "tree": {"sha": "50399cba2fbf0c72ab5af9ac13c117cc6bb4cc95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50399cba2fbf0c72ab5af9ac13c117cc6bb4cc95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4f28ca61139bf06153d20b4cc60ac6c5552234a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4f28ca61139bf06153d20b4cc60ac6c5552234a", "html_url": "https://github.com/rust-lang/rust/commit/c4f28ca61139bf06153d20b4cc60ac6c5552234a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4f28ca61139bf06153d20b4cc60ac6c5552234a/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b090cd1ea6a20d16e467c723fd0dd9f1d0adf812", "url": "https://api.github.com/repos/rust-lang/rust/commits/b090cd1ea6a20d16e467c723fd0dd9f1d0adf812", "html_url": "https://github.com/rust-lang/rust/commit/b090cd1ea6a20d16e467c723fd0dd9f1d0adf812"}], "stats": {"total": 362, "additions": 169, "deletions": 193}, "files": [{"sha": "a19e663c31c19302fe8918b1811d957978ce55ca", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 136, "deletions": 142, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/c4f28ca61139bf06153d20b4cc60ac6c5552234a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f28ca61139bf06153d20b4cc60ac6c5552234a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=c4f28ca61139bf06153d20b4cc60ac6c5552234a", "patch": "@@ -149,8 +149,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             closure_def_id,\n             closure_span: span,\n             capture_clause,\n-            current_closure_kind: ty::ClosureKind::LATTICE_BOTTOM,\n-            current_origin: None,\n+            _current_closure_kind: ty::ClosureKind::LATTICE_BOTTOM,\n+            _current_origin: None,\n             capture_information: Default::default(),\n             fake_reads: Default::default(),\n         };\n@@ -167,9 +167,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             \"For closure={:?}, capture_information={:#?}\",\n             closure_def_id, delegate.capture_information\n         );\n+\n         self.log_capture_analysis_first_pass(closure_def_id, &delegate.capture_information, span);\n \n-        self.compute_min_captures(closure_def_id, capture_clause, delegate.capture_information);\n+        let (capture_information, closure_kind, origin) = self\n+            .process_collected_capture_information(capture_clause, delegate.capture_information);\n+\n+        self.compute_min_captures(closure_def_id, capture_information);\n \n         let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n \n@@ -204,22 +208,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             // This will update the min captures based on this new fake information.\n-            self.compute_min_captures(closure_def_id, capture_clause, capture_information);\n+            self.compute_min_captures(closure_def_id, capture_information);\n         }\n \n         let before_feature_tys = self.final_upvar_tys(closure_def_id);\n \n         if let Some(closure_substs) = infer_kind {\n             // Unify the (as yet unbound) type variable in the closure\n             // substs with the kind we inferred.\n-            let inferred_kind = delegate.current_closure_kind;\n             let closure_kind_ty = closure_substs.as_closure().kind_ty();\n-            self.demand_eqtype(span, inferred_kind.to_ty(self.tcx), closure_kind_ty);\n+            self.demand_eqtype(span, closure_kind.to_ty(self.tcx), closure_kind_ty);\n \n             // If we have an origin, store it.\n-            if let Some(origin) = delegate.current_origin.clone() {\n+            if let Some(origin) = origin {\n                 let origin = if enable_precise_capture(self.tcx, span) {\n-                    (origin.0, restrict_capture_precision(capture_clause, origin.1))\n+                    (origin.0, origin.1)\n                 } else {\n                     (origin.0, Place { projections: vec![], ..origin.1 })\n                 };\n@@ -306,6 +309,64 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n+    fn process_collected_capture_information(\n+        &self,\n+        capture_clause: hir::CaptureBy,\n+        capture_information: InferredCaptureInformation<'tcx>,\n+    ) -> (InferredCaptureInformation<'tcx>, ty::ClosureKind, Option<(Span, Place<'tcx>)>) {\n+        let mut processed: InferredCaptureInformation<'tcx> = Default::default();\n+\n+        let mut closure_kind = ty::ClosureKind::LATTICE_BOTTOM;\n+        let mut origin: Option<(Span, Place<'tcx>)> = None;\n+\n+        for (place, mut capture_info) in capture_information.into_iter() {\n+            let place = restrict_capture_precision(capture_clause, place);\n+            let usage_span = if let Some(usage_expr) = capture_info.path_expr_id {\n+                self.tcx.hir().span(usage_expr)\n+            } else {\n+                unreachable!()\n+            };\n+\n+            let updated = match capture_info.capture_kind {\n+                ty::UpvarCapture::ByValue(..) => match closure_kind {\n+                    ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n+                        (ty::ClosureKind::FnOnce, Some((usage_span, place.clone())))\n+                    }\n+                    // If closure is already FnOnce, don't update\n+                    ty::ClosureKind::FnOnce => (closure_kind, origin),\n+                },\n+\n+                ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                    kind: ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n+                    ..\n+                }) => {\n+                    match closure_kind {\n+                        ty::ClosureKind::Fn => {\n+                            (ty::ClosureKind::FnMut, Some((usage_span, place.clone())))\n+                        }\n+                        // Don't update the origin\n+                        ty::ClosureKind::FnMut | ty::ClosureKind::FnOnce => (closure_kind, origin),\n+                    }\n+                }\n+\n+                _ => (closure_kind, origin),\n+            };\n+\n+            closure_kind = updated.0;\n+            origin = updated.1;\n+\n+            let (place, capture_kind) = match capture_clause {\n+                hir::CaptureBy::Value => process_for_move(place, capture_info.capture_kind),\n+                hir::CaptureBy::Ref => process_for_ref(place, capture_info.capture_kind),\n+            };\n+\n+            capture_info.capture_kind = capture_kind;\n+            processed.insert(place, capture_info);\n+        }\n+\n+        (processed, closure_kind, origin)\n+    }\n+\n     /// Analyzes the information collected by `InferBorrowKind` to compute the min number of\n     /// Places (and corresponding capture kind) that we need to keep track of to support all\n     /// the required captured paths.\n@@ -378,7 +439,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn compute_min_captures(\n         &self,\n         closure_def_id: DefId,\n-        capture_clause: hir::CaptureBy,\n         capture_information: InferredCaptureInformation<'tcx>,\n     ) {\n         if capture_information.is_empty() {\n@@ -396,8 +456,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n \n-            let place = restrict_capture_precision(capture_clause, place);\n-\n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n                     let mutability = self.determine_capture_mutability(&typeck_results, &place);\n@@ -1336,11 +1394,11 @@ struct InferBorrowKind<'a, 'tcx> {\n     // we've taken the closure kind from the expectations instead, and\n     // for generators we don't even implement the closure traits\n     // really).\n-    current_closure_kind: ty::ClosureKind,\n+    _current_closure_kind: ty::ClosureKind,\n \n     // If we modified `current_closure_kind`, this field contains a `Some()` with the\n     // variable access that caused us to do so.\n-    current_origin: Option<(Span, Place<'tcx>)>,\n+    _current_origin: Option<(Span, Place<'tcx>)>,\n \n     /// For each Place that is captured by the closure, we track the minimal kind of\n     /// access we need (ref, ref mut, move, etc) and the expression that resulted in such access.\n@@ -1384,27 +1442,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id, mode\n         );\n \n-        match (self.capture_clause, mode) {\n-            // In non-move closures, we only care about moves\n-            (hir::CaptureBy::Ref, euv::Copy) => return,\n-\n-            // We want to capture Copy types that read through a ref via a reborrow\n-            (hir::CaptureBy::Value, euv::Copy)\n-                if place_with_id.place.deref_tys().any(ty::TyS::is_ref) =>\n-            {\n-                return;\n-            }\n-\n-            (hir::CaptureBy::Ref, euv::Move) | (hir::CaptureBy::Value, euv::Move | euv::Copy) => {}\n+        // AMAN: Don't upgrade copy types to ByValue\n+        match mode {\n+            euv::ConsumeMode::Copy => return,\n+            euv::ConsumeMode::Move => {}\n         };\n \n-        let place = truncate_capture_for_move(place_with_id.place.clone());\n-        let place_with_id = PlaceWithHirId { place: place.clone(), hir_id: place_with_id.hir_id };\n-\n-        if !self.capture_information.contains_key(&place) {\n-            self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n-        }\n-\n         let tcx = self.fcx.tcx;\n         let upvar_id = if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             upvar_id\n@@ -1416,16 +1459,6 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n         let usage_span = tcx.hir().span(diag_expr_id);\n \n-        if matches!(mode, euv::Move) {\n-            // To move out of an upvar, this must be a FnOnce closure\n-            self.adjust_closure_kind(\n-                upvar_id.closure_expr_id,\n-                ty::ClosureKind::FnOnce,\n-                usage_span,\n-                place.clone(),\n-            );\n-        }\n-\n         let capture_info = ty::CaptureInfo {\n             capture_kind_expr_id: Some(diag_expr_id),\n             path_expr_id: Some(diag_expr_id),\n@@ -1503,22 +1536,13 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             ty::ImmBorrow => false,\n         });\n \n-        let tcx = self.fcx.tcx;\n+        // let tcx = self.fcx.tcx;\n \n         // if this is an implicit deref of an\n         // upvar, then we need to modify the\n         // borrow_kind of the upvar to make sure it\n         // is inferred to mutable if necessary\n         self.adjust_upvar_borrow_kind(place_with_id, diag_expr_id, borrow_kind);\n-\n-        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n-            self.adjust_closure_kind(\n-                upvar_id.closure_expr_id,\n-                ty::ClosureKind::FnMut,\n-                tcx.hir().span(diag_expr_id),\n-                place_with_id.place.clone(),\n-            );\n-        }\n     }\n \n     /// We infer the borrow_kind with which to borrow upvars in a stack closure.\n@@ -1557,48 +1581,6 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         };\n     }\n \n-    fn adjust_closure_kind(\n-        &mut self,\n-        closure_id: LocalDefId,\n-        new_kind: ty::ClosureKind,\n-        upvar_span: Span,\n-        place: Place<'tcx>,\n-    ) {\n-        debug!(\n-            \"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, place={:?})\",\n-            closure_id, new_kind, upvar_span, place\n-        );\n-\n-        // Is this the closure whose kind is currently being inferred?\n-        if closure_id.to_def_id() != self.closure_def_id {\n-            debug!(\"adjust_closure_kind: not current closure\");\n-            return;\n-        }\n-\n-        // closures start out as `Fn`.\n-        let existing_kind = self.current_closure_kind;\n-\n-        debug!(\n-            \"adjust_closure_kind: closure_id={:?}, existing_kind={:?}, new_kind={:?}\",\n-            closure_id, existing_kind, new_kind\n-        );\n-\n-        match (existing_kind, new_kind) {\n-            (ty::ClosureKind::Fn, ty::ClosureKind::Fn)\n-            | (ty::ClosureKind::FnMut, ty::ClosureKind::Fn | ty::ClosureKind::FnMut)\n-            | (ty::ClosureKind::FnOnce, _) => {\n-                // no change needed\n-            }\n-\n-            (ty::ClosureKind::Fn, ty::ClosureKind::FnMut | ty::ClosureKind::FnOnce)\n-            | (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-                // new kind is stronger than the old kind\n-                self.current_closure_kind = new_kind;\n-                self.current_origin = Some((upvar_span, place));\n-            }\n-        }\n-    }\n-\n     fn init_capture_info_for_place(\n         &mut self,\n         place_with_id: &PlaceWithHirId<'tcx>,\n@@ -1607,12 +1589,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             assert_eq!(self.closure_def_id.expect_local(), upvar_id.closure_expr_id);\n \n-            let capture_kind = self.fcx.init_capture_kind_for_place(\n-                &place_with_id.place,\n-                self.capture_clause,\n-                upvar_id,\n-                self.closure_span,\n-            );\n+            // AMAN: Always initialize to ImmBorrow\n+            // We will increase the CaptureKind in process_collected_capture_information.\n+            let origin = UpvarRegion(upvar_id, self.closure_span);\n+            let upvar_region = self.fcx.next_region_var(origin);\n+            let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n+            let capture_kind = ty::UpvarCapture::ByRef(upvar_borrow);\n \n             let expr_id = Some(diag_expr_id);\n             let capture_info = ty::CaptureInfo {\n@@ -1711,44 +1693,12 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     }\n }\n \n-/// Deref of a box isn't captured in move clousres. This is motivated by:\n-///   1. We only want to capture data that is on the stack\n-///   2. One motivation for the user to use a box might be to reduce the amount of data that gets\n-///      moved (if size of pointer < size of data). We want to make sure that this optimization that\n-///      the user made is respected.\n-fn restrict_precision_for_box<'tcx>(\n-    capture_clause: hir::CaptureBy,\n-    mut place: Place<'tcx>,\n-) -> Place<'tcx> {\n-    match capture_clause {\n-        hir::CaptureBy::Ref => {}\n-        hir::CaptureBy::Value => {\n-            if ty::TyS::is_box(place.base_ty) {\n-                place.projections.truncate(0);\n-            } else {\n-                // Either the box is the last access or there is a deref applied on the box\n-                // In either case we want to stop at the box.\n-                let pos = place.projections.iter().position(|proj| ty::TyS::is_box(proj.ty));\n-                match pos {\n-                    None => {}\n-                    Some(idx) => {\n-                        place.projections.truncate(idx + 1);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    place\n-}\n-\n /// Truncate projections so that following rules are obeyed by the captured `place`:\n /// - No projections are applied to raw pointers, since these require unsafe blocks. We capture\n ///   them completely.\n /// - No Index projections are captured, since arrays are captured completely.\n-/// - Deref of a box isn't captured in move clousres.\n fn restrict_capture_precision<'tcx>(\n-    capture_clause: hir::CaptureBy,\n+    _capture_clause: hir::CaptureBy,\n     mut place: Place<'tcx>,\n ) -> Place<'tcx> {\n     if place.projections.is_empty() {\n@@ -1785,19 +1735,63 @@ fn restrict_capture_precision<'tcx>(\n \n     place.projections.truncate(length);\n \n-    // Dont't capture projections on top of a box in move closures.\n-    restrict_precision_for_box(capture_clause, place)\n+    place\n }\n \n-/// Truncates a place so that the resultant capture doesn't move data out of a reference\n-fn truncate_capture_for_move(mut place: Place<'tcx>) -> Place<'tcx> {\n-    if let Some(i) = place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref) {\n-        // We only drop Derefs in case of move closures\n-        // There might be an index projection or raw ptr ahead, so we don't stop here.\n-        place.projections.truncate(i);\n+fn process_for_move<'tcx>(\n+    mut place: Place<'tcx>,\n+    kind: ty::UpvarCapture<'tcx>,\n+) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    let contains_deref_of_ref = place.deref_tys().any(|ty| ty.is_ref());\n+    match kind {\n+        ty::UpvarCapture::ByRef(..) if contains_deref_of_ref => (place, kind),\n+\n+        // If there's any Deref and the data needs to be moved into the closure body,\n+        // or it's a Deref of a Box, truncate the path to the first deref\n+        _ if place.deref_tys().next().is_some() => {\n+            let first_deref =\n+                place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n+            let place = match first_deref {\n+                Some(idx) => {\n+                    place.projections.truncate(idx);\n+                    place\n+                }\n+                None => place,\n+            };\n+\n+            // AMAN: I think we don't need the span inside the ByValue anymore\n+            //       we have more detailed span in CaptureInfo\n+            (place, ty::UpvarCapture::ByValue(None))\n+        }\n+\n+        _ => (place, ty::UpvarCapture::ByValue(None)),\n     }\n+}\n \n-    place\n+fn process_for_ref<'tcx>(\n+    mut place: Place<'tcx>,\n+    kind: ty::UpvarCapture<'tcx>,\n+) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    let contains_deref =\n+        place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n+\n+    match kind {\n+        ty::UpvarCapture::ByValue(..) if contains_deref.is_some() => {\n+            let place = match contains_deref {\n+                Some(idx) => {\n+                    place.projections.truncate(idx);\n+                    place\n+                }\n+                // Because of the if guard on the match on `kind`, we should never get here.\n+                None => unreachable!(),\n+            };\n+\n+            (place, kind)\n+        }\n+\n+        ty::UpvarCapture::ByValue(..) => (place, kind),\n+        ty::UpvarCapture::ByRef(..) => (place, kind),\n+    }\n }\n \n fn construct_place_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {"}, {"sha": "d8d3bbee200db67df8cb258fec03b2097f227601", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4f28ca61139bf06153d20b4cc60ac6c5552234a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f28ca61139bf06153d20b4cc60ac6c5552234a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs?ref=c4f28ca61139bf06153d20b4cc60ac6c5552234a", "patch": "@@ -22,8 +22,7 @@ fn big_box() {\n     //~^ First Pass analysis includes:\n     //~| Min Capture analysis includes:\n         let p = t.0.0;\n-        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n-        //~| NOTE: Capturing t[(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n         //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n         println!(\"{} {:?}\", t.1, p);\n         //~^ NOTE: Capturing t[(1, 0)] -> ImmBorrow"}, {"sha": "097462253aae73f0d3d37ac1f03a6b86c5cc5b2b", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c4f28ca61139bf06153d20b4cc60ac6c5552234a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4f28ca61139bf06153d20b4cc60ac6c5552234a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr?ref=c4f28ca61139bf06153d20b4cc60ac6c5552234a", "patch": "@@ -19,18 +19,13 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n-  --> $DIR/by_value.rs:24:17\n-   |\n-LL |         let p = t.0.0;\n-   |                 ^^^^^\n-note: Capturing t[(0, 0)] -> ByValue\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n   --> $DIR/by_value.rs:24:17\n    |\n LL |         let p = t.0.0;\n    |                 ^^^^^\n note: Capturing t[(1, 0)] -> ImmBorrow\n-  --> $DIR/by_value.rs:28:29\n+  --> $DIR/by_value.rs:27:29\n    |\n LL |         println!(\"{} {:?}\", t.1, p);\n    |                             ^^^\n@@ -53,7 +48,7 @@ note: Min Capture t[(0, 0)] -> ByValue\n LL |         let p = t.0.0;\n    |                 ^^^^^\n note: Min Capture t[(1, 0)] -> ImmBorrow\n-  --> $DIR/by_value.rs:28:29\n+  --> $DIR/by_value.rs:27:29\n    |\n LL |         println!(\"{} {:?}\", t.1, p);\n    |                             ^^^"}, {"sha": "ed778e956ba4bf4482a26d2e68c8d033f9b1f2bd", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c4f28ca61139bf06153d20b4cc60ac6c5552234a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f28ca61139bf06153d20b4cc60ac6c5552234a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs?ref=c4f28ca61139bf06153d20b4cc60ac6c5552234a", "patch": "@@ -16,7 +16,7 @@ fn simple_move_closure() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         t.0.0 = \"new S\".into();\n-        //~^ NOTE: Capturing t[(0, 0),(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(0, 0),(0, 0)] -> MutBorrow\n         //~| NOTE: Min Capture t[(0, 0),(0, 0)] -> ByValue\n     };\n     c();\n@@ -100,8 +100,7 @@ fn struct_contains_ref_to_another_struct_3() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         let _t = t.0.0;\n-        //~^ NOTE: Capturing t[(0, 0),Deref] -> ImmBorrow\n-        //~| NOTE: Capturing t[(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(0, 0),Deref] -> ByValue\n         //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n     };\n \n@@ -122,8 +121,7 @@ fn truncate_box_derefs() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         let _t = b.0;\n-        //~^ NOTE: Capturing b[Deref,(0, 0)] -> ByValue\n-        //~| NOTE: Capturing b[] -> ByValue\n+        //~^ NOTE: Capturing b[Deref,(0, 0)] -> ImmBorrow\n         //~| NOTE: Min Capture b[] -> ByValue\n     };\n \n@@ -139,7 +137,7 @@ fn truncate_box_derefs() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         println!(\"{}\", b.0);\n-        //~^ NOTE: Capturing b[Deref,(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing b[Deref,(0, 0)] -> ImmBorrow\n         //~| NOTE: Min Capture b[] -> ByValue\n     };\n \n@@ -156,7 +154,7 @@ fn truncate_box_derefs() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         println!(\"{}\", t.1.0);\n-        //~^ NOTE: Capturing t[(1, 0),Deref,(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(1, 0),Deref,(0, 0)] -> ImmBorrow\n         //~| NOTE: Min Capture t[(1, 0)] -> ByValue\n     };\n }"}, {"sha": "563ccf06e0067c06505971757a2c0b20cd4c4a39", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.stderr", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c4f28ca61139bf06153d20b4cc60ac6c5552234a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4f28ca61139bf06153d20b4cc60ac6c5552234a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr?ref=c4f28ca61139bf06153d20b4cc60ac6c5552234a", "patch": "@@ -44,7 +44,7 @@ LL |     let mut c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/move_closure.rs:118:13\n+  --> $DIR/move_closure.rs:117:13\n    |\n LL |     let c = #[rustc_capture_analysis]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -53,7 +53,7 @@ LL |     let c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/move_closure.rs:135:13\n+  --> $DIR/move_closure.rs:133:13\n    |\n LL |     let c = #[rustc_capture_analysis]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -62,7 +62,7 @@ LL |     let c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/move_closure.rs:152:13\n+  --> $DIR/move_closure.rs:150:13\n    |\n LL |     let c = #[rustc_capture_analysis]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -82,7 +82,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),(0, 0)] -> ByValue\n+note: Capturing t[(0, 0),(0, 0)] -> MutBorrow\n   --> $DIR/move_closure.rs:18:9\n    |\n LL |         t.0.0 = \"new S\".into();\n@@ -221,17 +221,12 @@ LL | /     move || {\n LL | |\n LL | |\n LL | |         let _t = t.0.0;\n-...  |\n+LL | |\n LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref] -> ImmBorrow\n-  --> $DIR/move_closure.rs:102:18\n-   |\n-LL |         let _t = t.0.0;\n-   |                  ^^^^^\n-note: Capturing t[(0, 0)] -> ByValue\n+note: Capturing t[(0, 0),Deref] -> ByValue\n   --> $DIR/move_closure.rs:102:18\n    |\n LL |         let _t = t.0.0;\n@@ -244,7 +239,7 @@ LL | /     move || {\n LL | |\n LL | |\n LL | |         let _t = t.0.0;\n-...  |\n+LL | |\n LL | |\n LL | |     };\n    | |_____^\n@@ -256,48 +251,43 @@ LL |         let _t = t.0.0;\n    |                  ^^^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/move_closure.rs:121:5\n+  --> $DIR/move_closure.rs:120:5\n    |\n LL | /     move || {\n LL | |\n LL | |\n LL | |         let _t = b.0;\n-...  |\n+LL | |\n LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing b[Deref,(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:124:18\n-   |\n-LL |         let _t = b.0;\n-   |                  ^^^\n-note: Capturing b[] -> ByValue\n-  --> $DIR/move_closure.rs:124:18\n+note: Capturing b[Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/move_closure.rs:123:18\n    |\n LL |         let _t = b.0;\n    |                  ^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/move_closure.rs:121:5\n+  --> $DIR/move_closure.rs:120:5\n    |\n LL | /     move || {\n LL | |\n LL | |\n LL | |         let _t = b.0;\n-...  |\n+LL | |\n LL | |\n LL | |     };\n    | |_____^\n    |\n note: Min Capture b[] -> ByValue\n-  --> $DIR/move_closure.rs:124:18\n+  --> $DIR/move_closure.rs:123:18\n    |\n LL |         let _t = b.0;\n    |                  ^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/move_closure.rs:138:5\n+  --> $DIR/move_closure.rs:136:5\n    |\n LL | /     move || {\n LL | |\n@@ -308,14 +298,14 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing b[Deref,(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:141:24\n+note: Capturing b[Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/move_closure.rs:139:24\n    |\n LL |         println!(\"{}\", b.0);\n    |                        ^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/move_closure.rs:138:5\n+  --> $DIR/move_closure.rs:136:5\n    |\n LL | /     move || {\n LL | |\n@@ -327,13 +317,13 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture b[] -> ByValue\n-  --> $DIR/move_closure.rs:141:24\n+  --> $DIR/move_closure.rs:139:24\n    |\n LL |         println!(\"{}\", b.0);\n    |                        ^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/move_closure.rs:155:5\n+  --> $DIR/move_closure.rs:153:5\n    |\n LL | /     move || {\n LL | |\n@@ -344,14 +334,14 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(1, 0),Deref,(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:158:24\n+note: Capturing t[(1, 0),Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/move_closure.rs:156:24\n    |\n LL |         println!(\"{}\", t.1.0);\n    |                        ^^^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/move_closure.rs:155:5\n+  --> $DIR/move_closure.rs:153:5\n    |\n LL | /     move || {\n LL | |\n@@ -363,7 +353,7 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture t[(1, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:158:24\n+  --> $DIR/move_closure.rs:156:24\n    |\n LL |         println!(\"{}\", t.1.0);\n    |                        ^^^^^"}]}