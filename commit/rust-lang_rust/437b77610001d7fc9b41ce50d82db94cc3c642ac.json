{"sha": "437b77610001d7fc9b41ce50d82db94cc3c642ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzN2I3NzYxMDAwMWQ3ZmM5YjQxY2U1MGQ4MmRiOTRjYzNjNjQyYWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-18T05:28:47Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-18T05:30:13Z"}, "message": "rustc: Simplify the destination format in the DPS backend; optimize aliases to interior strings to require no allocation at all", "tree": {"sha": "9fbfd2f65ec9cfb4bbdfc5280eae9223333d2fc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fbfd2f65ec9cfb4bbdfc5280eae9223333d2fc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/437b77610001d7fc9b41ce50d82db94cc3c642ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/437b77610001d7fc9b41ce50d82db94cc3c642ac", "html_url": "https://github.com/rust-lang/rust/commit/437b77610001d7fc9b41ce50d82db94cc3c642ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/437b77610001d7fc9b41ce50d82db94cc3c642ac/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09ca57adb0290b015ea54dd44f20c781b98297b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/09ca57adb0290b015ea54dd44f20c781b98297b9", "html_url": "https://github.com/rust-lang/rust/commit/09ca57adb0290b015ea54dd44f20c781b98297b9"}], "stats": {"total": 193, "additions": 103, "deletions": 90}, "files": [{"sha": "8954eb16ebeba94588b800c60e1cb04f6b4ae933", "filename": "src/comp/middle/trans_dps.rs", "status": "modified", "additions": 103, "deletions": 90, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/437b77610001d7fc9b41ce50d82db94cc3c642ac/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/437b77610001d7fc9b41ce50d82db94cc3c642ac/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=437b77610001d7fc9b41ce50d82db94cc3c642ac", "patch": "@@ -64,68 +64,65 @@ fn mk_const(&@crate_ctxt ccx, &str name, bool exported, ValueRef llval)\n \n // Destination utilities\n \n-tag dest_slot {\n-    dst_nil;\n-    dst_imm(@mutable option[ValueRef]);\n-    dst_ptr(ValueRef);\n+tag dest {\n+    dst_nil;                                // Unit destination; ignore.\n+    dst_imm(@mutable option[ValueRef]);     // Fill with an immediate value.\n+    dst_alias(@mutable option[ValueRef]);   // Fill with an alias pointer.\n+    dst_copy(ValueRef);                     // Copy to the given address.\n+    dst_move(ValueRef);                     // Move to the given address.\n }\n \n-tag dest_mode { dm_copy; dm_move; dm_alias; }\n-\n-type dest = rec(dest_slot slot, dest_mode mode);\n+fn dest_imm(&ty::ctxt tcx, ty::t t) -> dest {\n+    if ty::type_is_nil(tcx, t) { dst_nil } else { dst_imm(@mutable none) }\n+}\n \n-fn dest_slot_for_ptr(&ty::ctxt tcx, ValueRef llptr, ty::t t) -> dest_slot {\n-    if ty::type_is_nil(tcx, t) { dst_nil } else { dst_ptr(llptr) }\n+fn dest_alias(&ty::ctxt tcx, ty::t t) -> dest {\n+    if ty::type_is_nil(tcx, t) { dst_nil } else { dst_alias(@mutable none) }\n }\n \n fn dest_copy(&ty::ctxt tcx, ValueRef llptr, ty::t t) -> dest {\n-    ret rec(slot=dest_slot_for_ptr(tcx, llptr, t), mode=dm_copy);\n+    if ty::type_is_nil(tcx, t) { dst_nil } else { dst_copy(llptr) }\n }\n \n fn dest_move(&ty::ctxt tcx, ValueRef llptr, ty::t t) -> dest {\n-    ret rec(slot=dest_slot_for_ptr(tcx, llptr, t), mode=dm_move);\n-}\n-\n-fn dest_alias(&ty::ctxt tcx, ValueRef llptr, ty::t t) -> dest {\n-    ret rec(slot=dest_slot_for_ptr(tcx, llptr, t), mode=dm_alias);\n-}\n-\n-fn dest_tmp(&@block_ctxt bcx, ty::t t, bool alias) -> tup(@block_ctxt, dest) {\n-    auto mode = if alias { dm_alias } else { dm_move };\n-    if ty::type_is_nil(bcx_tcx(bcx), t) {\n-        ret tup(bcx, rec(slot=dst_nil, mode=mode));\n-    }\n-    if trans::type_is_immediate(bcx_ccx(bcx), t) {\n-        ret tup(bcx, rec(slot=dst_imm(@mutable none), mode=mode));\n-    }\n-    auto r = trans::alloc_ty(bcx, t);\n-    trans::add_clean(bcx, r.val, t);\n-    ret tup(r.bcx, rec(slot=dest_slot_for_ptr(bcx_tcx(bcx), r.val, t),\n-                       mode=mode));\n+    if ty::type_is_nil(tcx, t) { dst_nil } else { dst_move(llptr) }\n }\n \n // Invariant: the type of the destination must be structural (non-immediate).\n fn dest_ptr(&dest dest) -> ValueRef {\n-    alt (dest.slot) {\n+    alt (dest) {\n       dst_nil { fail \"nil dest in dest_ptr\" }\n       dst_imm(_) { fail \"immediate dest in dest_ptr\" }\n-      dst_ptr(?llptr) { llptr }\n+      dst_alias(_) { fail \"alias dest in dest_ptr\" }\n+      dst_copy(?llptr) { llptr }\n+      dst_move(?llptr) { llptr }\n     }\n }\n \n fn dest_llval(&dest dest) -> ValueRef {\n-    alt (dest.slot) {\n+    alt (dest) {\n       dst_nil { ret tc::C_nil(); }\n       dst_imm(?box) {\n         alt (*box) {\n           none { fail \"immediate wasn't filled in prior to dest_llval\"; }\n           some(?llval) { ret llval; }\n         }\n       }\n-      dst_ptr(?llval) { ret llval; }\n+      dst_alias(?box) {\n+        alt (*box) {\n+          none { fail \"alias wasn't filled in prior to dest_llval\"; }\n+          some(?llval) { ret llval; }\n+        }\n+      }\n+      dst_copy(?llptr) { ret llptr; }\n+      dst_move(?llptr) { ret llptr; }\n     }\n }\n \n+fn dest_is_alias(&dest dest) -> bool {\n+    alt (dest) { dst_alias(_) { true } _ { false } }\n+}\n+\n \n // Accessors\n // TODO: When we have overloading, simplify these names!\n@@ -135,42 +132,44 @@ fn bcx_ccx(&@block_ctxt bcx) -> @crate_ctxt { ret bcx.fcx.lcx.ccx; }\n fn bcx_lcx(&@block_ctxt bcx) -> @local_ctxt { ret bcx.fcx.lcx; }\n fn bcx_fcx(&@block_ctxt bcx) -> @fn_ctxt { ret bcx.fcx; }\n fn lcx_ccx(&@local_ctxt lcx) -> @crate_ctxt { ret lcx.ccx; }\n+fn ccx_tcx(&@crate_ctxt ccx) -> ty::ctxt { ret ccx.tcx; }\n \n \n // Common operations\n \n // If \"cast\" is true, casts dest appropriately before the store.\n-fn store(&@block_ctxt bcx, &dest dest, ValueRef llsrc, bool cast)\n+fn store_imm(&@block_ctxt bcx, &dest dest, ValueRef llsrc, bool cast)\n         -> @block_ctxt {\n-    alt (dest.slot) {\n+    alt (dest) {\n       dst_nil { /* no-op */ }\n       dst_imm(?box) {\n-        if !std::option::is_none(*box) {\n-          fail \"attempt to store an immediate twice\";\n-        };\n+        assert (std::option::is_none(*box));\n         *box = some(llsrc);\n       }\n-      dst_ptr(?lldestptr_orig) {\n+      dst_alias(?box) {\n+        bcx_ccx(bcx).sess.unimpl(\"dst_alias spill in store_imm\");\n+      }\n+      dst_copy(?lldestptr_orig) | dst_move(?lldestptr_orig) {\n         auto lldestptr = lldestptr_orig;\n         if cast {\n             lldestptr = bcx.build.PointerCast(lldestptr,\n                                               tc::T_ptr(lltype_of(llsrc)));\n         }\n-\n         bcx.build.Store(llsrc, lldestptr);\n       }\n     }\n     ret bcx;\n }\n \n-fn memmove(&@block_ctxt bcx, &dest dest, ValueRef llsrcptr) -> @block_ctxt {\n-    alt (dest.slot) {\n-      // TODO: We might want to support these; I can't think of any case in\n-      // which we would want them off the top of my head, but feel free to add\n-      // them if they aid orthogonality.\n-      dst_nil { fail \"dst_nil in memmove\"; }\n-      dst_imm(_) { fail \"dst_imm in memmove\"; }\n-      dst_ptr(?lldestptr) {\n+fn store_ptr(&@block_ctxt bcx, &dest dest, ValueRef llsrcptr) -> @block_ctxt {\n+    alt (dest) {\n+      dst_nil { /* no-op */ }\n+      dst_imm(?box) { fail \"dst_imm in store_ptr\"; }\n+      dst_alias(?box) {\n+        assert (std::option::is_none(*box));\n+        *box = some(llsrcptr);\n+      }\n+      dst_copy(?lldestptr) | dst_move(?lldestptr) {\n         auto lldestty = llelement_type(trans::val_ty(llsrcptr));\n         auto llsrcty = llelement_type(trans::val_ty(llsrcptr));\n         auto dest_align = llalign_of(bcx_ccx(bcx), lldestty);\n@@ -190,6 +189,7 @@ fn memmove(&@block_ctxt bcx, &dest dest, ValueRef llsrcptr) -> @block_ctxt {\n         ret bcx;\n       }\n     }\n+    ret bcx;\n }\n \n // Allocates a value of the given LLVM size on either the task heap or the\n@@ -228,9 +228,9 @@ fn trans_lit(&@block_ctxt cx, &dest dest, &ast::lit lit) -> @block_ctxt {\n     auto bcx = cx;\n     alt (lit.node) {\n       ast::lit_str(?s, ast::sk_unique) {\n-        auto r = trans_lit_str_common(bcx_ccx(bcx), s);\n+        auto r = trans_lit_str_common(bcx_ccx(bcx), s, dest_is_alias(dest));\n         auto llstackpart = r._0; auto llheappartopt = r._1;\n-        bcx = memmove(bcx, dest, llstackpart);\n+        bcx = store_ptr(bcx, dest, llstackpart);\n         alt (llheappartopt) {\n           none { /* no-op */ }\n           some(?llheappart) {\n@@ -244,13 +244,13 @@ fn trans_lit(&@block_ctxt cx, &dest dest, &ast::lit lit) -> @block_ctxt {\n                                       tc::T_ptr(tc::T_ptr(llheappartty)));\n             malloc(bcx, lldestptrptr, hp_shared, none);\n             auto lldestptr = bcx.build.Load(lldestptrptr);\n-            memmove(bcx, rec(slot=dst_ptr(lldestptr), mode=dm_copy),\n-                    llheappart);\n+            store_ptr(bcx, dst_copy(lldestptr), llheappart);\n           }\n         }\n       }\n       _ {\n-        bcx = store(bcx, dest, trans_lit_common(bcx_ccx(bcx), lit), false);\n+        bcx = store_imm(bcx, dest, trans_lit_common(bcx_ccx(bcx), lit),\n+                        false);\n       }\n     }\n \n@@ -280,47 +280,35 @@ fn trans_log(&@block_ctxt cx, &span sp, int level, &@ast::expr expr)\n         ret lllevelptr;\n     }\n \n-    fn trans_log_upcall(&@block_ctxt cx, &span sp, ValueRef in_llval,\n-                        int level, ty::t t) -> @block_ctxt {\n-        auto bcx = cx;\n-        auto llval = in_llval;\n-        auto llupcall;\n-        alt (ty::struct(bcx_tcx(bcx), t)) {\n+    tag upcall_style { us_imm; us_imm_i32_zext; us_alias; us_alias_istr; }\n+    fn get_upcall(&@crate_ctxt ccx, &span sp, ty::t t)\n+            -> tup(ValueRef, upcall_style) {\n+        alt (ty::struct(ccx_tcx(ccx), t)) {\n           ty::ty_machine(ast::ty_f32) {\n-            llupcall = bcx_ccx(bcx).upcalls.log_float;\n+            ret tup(ccx.upcalls.log_float, us_imm);\n           }\n           ty::ty_machine(ast::ty_f64) | ty::ty_float {\n-            llupcall = bcx_ccx(bcx).upcalls.log_double;\n-\n-            // TODO: Here we have to spill due to legacy calling conventions.\n-            // This is no longer necessary.\n-            auto r = trans::alloc_ty(bcx, t);\n-            bcx = r.bcx; auto llptr = r.val;\n-            bcx.build.Store(llval, llptr);\n-            llval = llptr;\n+            // TODO: We have to spill due to legacy calling conventions that\n+            // should probably be modernized.\n+            ret tup(ccx.upcalls.log_double, us_alias);\n           }\n           ty::ty_bool | ty::ty_machine(ast::ty_i8) |\n                 ty::ty_machine(ast::ty_i16) | ty::ty_machine(ast::ty_u8) |\n                 ty::ty_machine(ast::ty_u16) {\n-            llupcall = bcx_ccx(bcx).upcalls.log_int;\n-            llval = bcx.build.ZExt(llval, tc::T_i32());\n+            ret tup(ccx.upcalls.log_int, us_imm_i32_zext);\n           }\n           ty::ty_int | ty::ty_machine(ast::ty_i32) |\n                 ty::ty_machine(ast::ty_u32) {\n-            llupcall = bcx_ccx(bcx).upcalls.log_int;\n+            ret tup(ccx.upcalls.log_int, us_imm);\n           }\n           ty::ty_istr {\n-            llupcall = bcx_ccx(bcx).upcalls.log_istr;\n+            ret tup(ccx.upcalls.log_istr, us_alias_istr);\n           }\n           _ {\n-            bcx_ccx(bcx).sess.span_unimpl(sp, \"logging for values of type \" +\n-                ppaux::ty_to_str(bcx_tcx(bcx), t));\n+            ccx.sess.span_unimpl(sp, \"logging for values of type \" +\n+                                 ppaux::ty_to_str(ccx_tcx(ccx), t));\n           }\n         }\n-\n-        bcx.build.Call(llupcall,\n-                       ~[bcx_fcx(bcx).lltaskptr, tc::C_int(level), llval]);\n-        ret bcx;\n     }\n \n     auto bcx = cx;\n@@ -336,11 +324,32 @@ fn trans_log(&@block_ctxt cx, &span sp, int level, &@ast::expr expr)\n     bcx.build.CondBr(should_log, log_bcx.llbb, next_bcx.llbb);\n \n     auto expr_t = ty::expr_ty(bcx_tcx(log_bcx), expr);\n-    auto r = dest_tmp(log_bcx, expr_t, true);\n-    log_bcx = r._0; auto tmp = r._1;\n-    log_bcx = trans_expr(log_bcx, tmp, expr);\n+    auto r = get_upcall(bcx_ccx(bcx), sp, expr_t);\n+    auto llupcall = r._0; auto style = r._1;\n \n-    log_bcx = trans_log_upcall(log_bcx, sp, dest_llval(tmp), level, expr_t);\n+    auto arg_dest;\n+    alt (style) {\n+      us_imm | us_imm_i32_zext {\n+        arg_dest = dest_imm(bcx_tcx(log_bcx), expr_t);\n+      }\n+      us_alias | us_alias_istr {\n+        arg_dest = dest_alias(bcx_tcx(log_bcx), expr_t);\n+      }\n+    }\n+    log_bcx = trans_expr(log_bcx, arg_dest, expr);\n+\n+    auto llarg = dest_llval(arg_dest);\n+    alt (style) {\n+      us_imm | us_alias { /* no-op */ }\n+      us_imm_i32_zext { llarg = log_bcx.build.ZExt(llarg, tc::T_i32()); }\n+      us_alias_istr {\n+        llarg = log_bcx.build.PointerCast(llarg,\n+                                          tc::T_ptr(tc::T_ivec(tc::T_i8())));\n+      }\n+    }\n+\n+    log_bcx.build.Call(llupcall,\n+                       ~[bcx_fcx(bcx).lltaskptr, tc::C_int(level), llarg]);\n \n     log_bcx = trans::trans_block_cleanups(log_bcx,\n                                           trans::find_scope_cx(log_bcx));\n@@ -393,7 +402,10 @@ fn trans_block(&@block_ctxt cx, &dest dest, &ast::block block)\n // Common setup code shared between the crate-constant literal string case and\n // the block-local literal string case. We don't use destination-passing style\n // since that doesn't work for crate constants.\n-fn trans_lit_str_common(&@crate_ctxt ccx, &str s)\n+//\n+// If |expand| is true, we never spill to the heap. This should be used\n+// whenever the destination size isn't fixed.\n+fn trans_lit_str_common(&@crate_ctxt ccx, &str s, bool expand)\n         -> tup(ValueRef, option[ValueRef]) {\n     auto llstackpart; auto llheappartopt;\n \n@@ -403,7 +415,12 @@ fn trans_lit_str_common(&@crate_ctxt ccx, &str s)\n     for (u8 ch in s) { array += ~[tc::C_u8(ch as uint)]; }\n     array += ~[tc::C_u8(0u)];\n \n-    if len < abi::ivec_default_length - 1u {    // minus 1 because of the \\0\n+    if expand {\n+        llstackpart = tc::C_struct(~[tc::C_uint(len + 1u),\n+                                     tc::C_uint(len + 1u),\n+                                     tc::C_array(tc::T_i8(), array)]);\n+        llheappartopt = none;\n+    } else if len < abi::ivec_default_length - 1u { // minus one for the null\n         while (ivec::len(array) < abi::ivec_default_length) {\n             array += ~[tc::C_u8(0u)];\n         }\n@@ -492,19 +509,15 @@ fn trans_init_local(&@block_ctxt bcx, &@ast::local local) -> @block_ctxt {\n           }\n         }\n       }\n-      none {\n-        ret store(bcx, dest_copy(bcx_tcx(bcx), llptr, t),\n-                  tc::C_null(llelement_type(trans::val_ty(llptr))), false);\n-      }\n+      none { ret bcx; }\n     }\n }\n \n fn trans_stmt(&@block_ctxt cx, &@ast::stmt stmt) -> @block_ctxt {\n     auto bcx = cx;\n     alt (stmt.node) {\n       ast::stmt_expr(?e, _) {\n-        auto tmp_r = dest_tmp(bcx, ty::expr_ty(bcx_tcx(bcx), e), true);\n-        bcx = tmp_r._0; auto tmp = tmp_r._1;\n+        auto tmp = dest_alias(bcx_tcx(bcx), ty::expr_ty(bcx_tcx(bcx), e));\n         ret trans_expr(bcx, tmp, e);\n       }\n       ast::stmt_decl(?d, _) {"}]}