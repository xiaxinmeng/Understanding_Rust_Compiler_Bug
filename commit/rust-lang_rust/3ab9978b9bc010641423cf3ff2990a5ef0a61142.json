{"sha": "3ab9978b9bc010641423cf3ff2990a5ef0a61142", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYjk5NzhiOWJjMDEwNjQxNDIzY2YzZmYyOTkwYTVlZjBhNjExNDI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-12T09:05:15Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-15T14:08:31Z"}, "message": "Remove support for dynamically-sized types from translation code", "tree": {"sha": "de74f510851b0d63f78d0642b146bce16dc07bfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de74f510851b0d63f78d0642b146bce16dc07bfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ab9978b9bc010641423cf3ff2990a5ef0a61142", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ab9978b9bc010641423cf3ff2990a5ef0a61142", "html_url": "https://github.com/rust-lang/rust/commit/3ab9978b9bc010641423cf3ff2990a5ef0a61142", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ab9978b9bc010641423cf3ff2990a5ef0a61142/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4d75a4ed14e42adcf6227e599ac762a0056a34e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4d75a4ed14e42adcf6227e599ac762a0056a34e", "html_url": "https://github.com/rust-lang/rust/commit/a4d75a4ed14e42adcf6227e599ac762a0056a34e"}], "stats": {"total": 705, "additions": 148, "deletions": 557}, "files": [{"sha": "461e0e62445e8fce5b8f0bbca57c74903686b769", "filename": "src/rustc/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=3ab9978b9bc010641423cf3ff2990a5ef0a61142", "patch": "@@ -76,19 +76,10 @@ fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> (copy_map, ref_map) {\n }\n \n fn visit_fn(cx: @ctx, _fk: visit::fn_kind, decl: ast::fn_decl,\n-            body: ast::blk, sp: span,\n+            body: ast::blk, _sp: span,\n             id: ast::node_id, sc: scope, v: vt<scope>) {\n     visit::visit_fn_decl(decl, sc, v);\n     let fty = ty::node_id_to_type(cx.tcx, id);\n-    let args = ty::ty_fn_args(fty);\n-    for arg in args {\n-        alt ty::resolved_mode(cx.tcx, arg.mode) {\n-          ast::by_val if ty::type_has_dynamic_size(cx.tcx, arg.ty) {\n-            err(*cx, sp, \"can not pass a dynamically-sized type by value\");\n-          }\n-          _ { /* fallthrough */ }\n-        }\n-    }\n \n     // Blocks need to obey any restrictions from the enclosing scope, and may\n     // be called multiple times."}, {"sha": "2fd5bfba9b66bfb8ef0396bd9eee3f20b0535e0d", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 42, "deletions": 145, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3ab9978b9bc010641423cf3ff2990a5ef0a61142", "patch": "@@ -267,10 +267,8 @@ fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n     let ccx = bcx.ccx();\n     let bumped = ptr_offs(bcx, base, sz);\n-    if check type_has_static_size(ccx, t) {\n-        let typ = T_ptr(type_of(ccx, t));\n-        PointerCast(bcx, bumped, typ)\n-    } else { bumped }\n+    let typ = T_ptr(type_of(ccx, t));\n+    PointerCast(bcx, bumped, typ)\n }\n \n // Replacement for the LLVM 'GEP' instruction when field indexing into a enum.\n@@ -310,11 +308,7 @@ fn opaque_box_body(bcx: block,\n     let ccx = bcx.ccx();\n     let boxptr = PointerCast(bcx, boxptr, T_ptr(T_box_header(ccx)));\n     let bodyptr = GEPi(bcx, boxptr, [1]);\n-    if check type_has_static_size(ccx, body_t) {\n-        PointerCast(bcx, bodyptr, T_ptr(type_of(ccx, body_t)))\n-    } else {\n-        PointerCast(bcx, bodyptr, T_ptr(T_i8()))\n-    }\n+    PointerCast(bcx, bodyptr, T_ptr(type_of(ccx, body_t)))\n }\n \n // trans_malloc_boxed_raw: expects an unboxed type and returns a pointer to\n@@ -350,41 +344,13 @@ fn trans_malloc_boxed(bcx: block, t: ty::t) ->\n \n // Type descriptor and type glue stuff\n \n-fn trans_stack_local_derived_tydesc(cx: block, llsz: ValueRef,\n-                                    llalign: ValueRef, llroottydesc: ValueRef,\n-                                    llfirstparam: ValueRef, n_params: uint)\n-    -> ValueRef {\n-    let llmyroottydesc = alloca(cx, cx.ccx().tydesc_type);\n-\n-    // By convention, desc 0 is the root descriptor.\n-    let llroottydesc = Load(cx, llroottydesc);\n-    Store(cx, llroottydesc, llmyroottydesc);\n-\n-    // Store a pointer to the rest of the descriptors.\n-    let ccx = cx.ccx();\n-    store_inbounds(cx, llfirstparam, llmyroottydesc,\n-                   [0, abi::tydesc_field_first_param]);\n-    store_inbounds(cx, C_uint(ccx, n_params), llmyroottydesc,\n-                   [0, abi::tydesc_field_n_params]);\n-    store_inbounds(cx, llsz, llmyroottydesc,\n-                   [0, abi::tydesc_field_size]);\n-    store_inbounds(cx, llalign, llmyroottydesc,\n-                   [0, abi::tydesc_field_align]);\n-    // FIXME legacy field, can be dropped\n-    store_inbounds(cx, C_uint(ccx, 0u), llmyroottydesc,\n-                   [0, abi::tydesc_field_obj_params]);\n-    ret llmyroottydesc;\n-}\n-\n fn get_tydesc_simple(bcx: block, t: ty::t) -> result {\n     let ti = none;\n     get_tydesc(bcx, t, ti)\n }\n \n fn get_tydesc(cx: block, t: ty::t,\n               &static_ti: option<@tydesc_info>) -> result {\n-\n-    // FIXME[mono]\n     assert !ty::type_has_params(t);\n     // Otherwise, generate a tydesc if necessary, and return it.\n     let info = get_static_tydesc(cx.ccx(), t);\n@@ -452,17 +418,9 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     log(debug, \"+++ declare_tydesc \" + ty_to_str(ccx.tcx, t));\n     let llsize;\n     let llalign;\n-    if check type_has_static_size(ccx, t) {\n-        let llty = type_of(ccx, t);\n-        llsize = llsize_of(ccx, llty);\n-        llalign = llalign_of(ccx, llty);\n-    } else {\n-        // These will be overwritten as the derived tydesc is generated, so\n-        // we create placeholder values.\n-\n-        llsize = C_int(ccx, 0);\n-        llalign = C_int(ccx, 0);\n-    }\n+    let llty = type_of(ccx, t);\n+    llsize = llsize_of(ccx, llty);\n+    llalign = llalign_of(ccx, llty);\n     let name;\n     if ccx.sess.opts.debuginfo {\n         name = mangle_internal_name_by_type_only(ccx, t, \"tydesc\");\n@@ -508,9 +466,7 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n     // the caller has no idea if it's dealing with something that can be\n     // passed by value.\n \n-    let llty = if check type_has_static_size(ccx, t) {\n-        T_ptr(type_of(ccx, t))\n-    } else { T_ptr(T_i8()) };\n+    let llty = T_ptr(type_of(ccx, t));\n \n     let bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;\n@@ -1200,17 +1156,12 @@ fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n fn memmove_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) ->\n     block {\n     let ccx = bcx.ccx();\n-    if check type_has_static_size(ccx, t) {\n-        if ty::type_is_structural(t) {\n-            let llsz = llsize_of(ccx, type_of(ccx, t));\n-            ret call_memmove(bcx, dst, src, llsz).bcx;\n-        }\n-        Store(bcx, Load(bcx, src), dst);\n-        ret bcx;\n+    if ty::type_is_structural(t) {\n+        let llsz = llsize_of(ccx, type_of(ccx, t));\n+        ret call_memmove(bcx, dst, src, llsz).bcx;\n     }\n-\n-    let {bcx, val: llsz} = size_of(bcx, t);\n-    ret call_memmove(bcx, dst, src, llsz).bcx;\n+    Store(bcx, Load(bcx, src), dst);\n+    ret bcx;\n }\n \n enum copy_action { INIT, DROP_EXISTING, }\n@@ -1372,10 +1323,8 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n         // make enums work, since enums have a different LLVM type depending\n         // on whether they're boxed or not\n         let ccx = bcx.ccx();\n-        if check type_has_static_size(ccx, e_ty) {\n-            let llety = T_ptr(type_of(ccx, e_ty));\n-            body = PointerCast(bcx, body, llety);\n-        }\n+        let llety = T_ptr(type_of(ccx, e_ty));\n+        body = PointerCast(bcx, body, llety);\n         bcx = trans_expr_save_in(bcx, e, body);\n         revoke_clean(bcx, box);\n         ret store_in_dest(bcx, box, dest);\n@@ -1583,10 +1532,8 @@ fn autoderef(cx: block, v: ValueRef, t: ty::t) -> result_t {\n             // to cast this pointer, since statically-sized enum types have\n             // different types depending on whether they're behind a box\n             // or not.\n-            if check type_has_static_size(ccx, t1) {\n-                let llty = type_of(ccx, t1);\n-                v1 = PointerCast(cx, body, T_ptr(llty));\n-            } else { v1 = body; }\n+            let llty = type_of(ccx, t1);\n+            v1 = PointerCast(cx, body, T_ptr(llty));\n           }\n           ty::ty_uniq(_) {\n             let derefed = uniq::autoderef(v1, t1);\n@@ -1608,9 +1555,7 @@ fn autoderef(cx: block, v: ValueRef, t: ty::t) -> result_t {\n             }\n             t1 =\n                 ty::substitute_type_params(ccx.tcx, tps, variants[0].args[0]);\n-            if check type_has_static_size(ccx, t1) {\n-                v1 = PointerCast(cx, v1, T_ptr(type_of(ccx, t1)));\n-            } else { } // FIXME: typestate hack\n+            v1 = PointerCast(cx, v1, T_ptr(type_of(ccx, t1)));\n           }\n           _ { break; }\n         }\n@@ -1724,7 +1669,7 @@ fn trans_for(cx: block, local: @ast::local, seq: @ast::expr,\n                                         body.span);\n         Br(bcx, scope_cx.llbb);\n         let curr = PointerCast(bcx, curr,\n-                               T_ptr(type_of_or_i8(bcx.ccx(), t)));\n+                               T_ptr(type_of(bcx.ccx(), t)));\n         let bcx = alt::bind_irrefutable_pat(scope_cx, local.node.pat,\n                                                   curr, false);\n         bcx = trans_block(bcx, body, ignore);\n@@ -2122,7 +2067,7 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n       ast::def_self(_) {\n         let slf = option::get(cx.fcx.llself);\n         let ptr = PointerCast(cx, slf.v,\n-                              T_ptr(type_of_or_i8(cx.ccx(), slf.t)));\n+                              T_ptr(type_of(cx.ccx(), slf.t)));\n         ret {val: ptr, kind: owned};\n       }\n       _ {\n@@ -2236,27 +2181,20 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n     } else { ix_val = ix.val; }\n \n     let unit_ty = node_id_type(cx, ex.id);\n-    let unit_sz = size_of(bcx, unit_ty);\n-    bcx = unit_sz.bcx;\n-    maybe_name_value(cx.ccx(), unit_sz.val, \"unit_sz\");\n-    let scaled_ix = Mul(bcx, ix_val, unit_sz.val);\n+    let llunitty = type_of(ccx, unit_ty);\n+    let unit_sz = llsize_of(ccx, llunitty);\n+    maybe_name_value(cx.ccx(), unit_sz, \"unit_sz\");\n+    let scaled_ix = Mul(bcx, ix_val, unit_sz);\n     maybe_name_value(cx.ccx(), scaled_ix, \"scaled_ix\");\n     let lim = tvec::get_fill(bcx, v);\n-    let body = tvec::get_dataptr(bcx, v, type_of_or_i8(ccx, unit_ty));\n+    let body = tvec::get_dataptr(bcx, v, type_of(ccx, unit_ty));\n     let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, lim);\n     bcx = with_cond(bcx, bounds_check) {|bcx|\n         // fail: bad bounds check.\n         trans_fail(bcx, some(ex.span), \"bounds check\")\n     };\n-    let elt = if check type_has_static_size(ccx, unit_ty) {\n-        let elt_1 = InBoundsGEP(bcx, body, [ix_val]);\n-        let llunitty = type_of(ccx, unit_ty);\n-        PointerCast(bcx, elt_1, T_ptr(llunitty))\n-    } else {\n-        body = PointerCast(bcx, body, T_ptr(T_i8()));\n-        InBoundsGEP(bcx, body, [scaled_ix])\n-    };\n-    ret lval_owned(bcx, elt);\n+    let elt = InBoundsGEP(bcx, body, [ix_val]);\n+    ret lval_owned(bcx, PointerCast(bcx, elt, T_ptr(llunitty)));\n }\n \n fn expr_is_lval(bcx: block, e: @ast::expr) -> bool {\n@@ -2315,9 +2253,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n           }\n           ty::ty_enum(_, _) {\n             let ety = expr_ty(cx, e);\n-            let ellty = if check type_has_static_size(ccx, ety) {\n-                T_ptr(type_of(ccx, ety))\n-            } else { T_typaram_ptr(ccx.tn) };\n+            let ellty = T_ptr(type_of(ccx, ety));\n             PointerCast(sub.bcx, sub.val, ellty)\n           }\n           ty::ty_ptr(_) | ty::ty_uniq(_) | ty::ty_rptr(_,_) { sub.val }\n@@ -3194,7 +3130,7 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n \n         if ty::type_is_str(e_ty) {\n             let data = tvec::get_dataptr(\n-                bcx, expr_res.val, type_of_or_i8(\n+                bcx, expr_res.val, type_of(\n                     ccx, ty::mk_mach_uint(tcx, ast::ty_u8)));\n             ret trans_fail_value(bcx, sp_opt, data);\n         } else if bcx.unreachable || ty::type_is_bot(e_ty) {\n@@ -3345,23 +3281,8 @@ fn zero_alloca(cx: block, llptr: ValueRef, t: ty::t)\n     -> block {\n     let bcx = cx;\n     let ccx = cx.ccx();\n-    if check type_has_static_size(ccx, t) {\n-        let llty = type_of(ccx, t);\n-        Store(bcx, C_null(llty), llptr);\n-    } else {\n-        let key = alt ccx.sess.targ_cfg.arch {\n-          session::arch_x86 | session::arch_arm { \"llvm.memset.p0i8.i32\" }\n-          session::arch_x86_64 { \"llvm.memset.p0i8.i64\" }\n-        };\n-        let i = ccx.intrinsics;\n-        let memset = i.get(key);\n-        let dst_ptr = PointerCast(cx, llptr, T_ptr(T_i8()));\n-        let size = size_of(cx, t);\n-        bcx = size.bcx;\n-        let align = C_i32(1i32); // cannot use computed value here.\n-        let volatile = C_bool(false);\n-        Call(cx, memset, [dst_ptr, C_u8(0u), size.val, align, volatile]);\n-    }\n+    let llty = type_of(ccx, t);\n+    Store(bcx, C_null(llty), llptr);\n     ret bcx;\n }\n \n@@ -3580,7 +3501,7 @@ fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n fn alloc_ty(cx: block, t: ty::t) -> result {\n     let bcx = cx, ccx = cx.ccx();\n     let llty = type_of(ccx, t);\n-    assert type_has_static_size(ccx, t);\n+    assert !ty::type_has_params(t);\n     let val = alloca(bcx, llty);\n \n     // NB: since we've pushed all size calculations in this\n@@ -3641,24 +3562,15 @@ fn trans_block(bcx: block, b: ast::blk, dest: dest)\n     ret bcx;\n }\n \n-// Creates the standard quartet of basic blocks: static allocas, copy args,\n-// derived tydescs, and dynamic allocas.\n+// Creates the standard set of basic blocks for a function\n fn mk_standard_basic_blocks(llfn: ValueRef) ->\n-   {sa: BasicBlockRef,\n-    ca: BasicBlockRef,\n-    dt: BasicBlockRef,\n-    da: BasicBlockRef,\n-    rt: BasicBlockRef} {\n-    ret {sa: str::as_c_str(\"static_allocas\", {|buf|\n-                 llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-         ca: str::as_c_str(\"load_env\", {|buf|\n-                 llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-         dt: str::as_c_str(\"derived_tydescs\", {|buf|\n-                 llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-         da: str::as_c_str(\"dynamic_allocas\", {|buf|\n-                 llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-         rt: str::as_c_str(\"return\", {|buf|\n-                 llvm::LLVMAppendBasicBlock(llfn, buf) })};\n+   {sa: BasicBlockRef, ca: BasicBlockRef, rt: BasicBlockRef} {\n+    {sa: str::as_c_str(\"static_allocas\", {|buf|\n+        llvm::LLVMAppendBasicBlock(llfn, buf) }),\n+     ca: str::as_c_str(\"load_env\", {|buf|\n+         llvm::LLVMAppendBasicBlock(llfn, buf) }),\n+     rt: str::as_c_str(\"return\", {|buf|\n+         llvm::LLVMAppendBasicBlock(llfn, buf) })}\n }\n \n \n@@ -3679,16 +3591,12 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n           llretptr: llvm::LLVMGetParam(llfndecl, 0u as c_uint),\n           mutable llstaticallocas: llbbs.sa,\n           mutable llloadenv: llbbs.ca,\n-          mutable llderivedtydescs_first: llbbs.dt,\n-          mutable llderivedtydescs: llbbs.dt,\n-          mutable lldynamicallocas: llbbs.da,\n           mutable llreturn: llbbs.rt,\n           mutable llself: none,\n           mutable personality: none,\n           llargs: int_hash::<local_val>(),\n           lllocals: int_hash::<local_val>(),\n           llupvars: int_hash::<ValueRef>(),\n-          derived_tydescs: ty::new_ty_hash(),\n           id: id,\n           self_id: maybe_self_id,\n           param_substs: param_substs,\n@@ -3776,8 +3684,8 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: [ast::arg],\n     ret bcx;\n }\n \n-// Ties up the llstaticallocas -> llloadenv -> llderivedtydescs ->\n-// lldynamicallocas -> lltop edges, and builds the return block.\n+// Ties up the llstaticallocas -> llloadenv -> lltop edges,\n+// and builds the return block.\n fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     tie_up_header_blocks(fcx, lltop);\n     let ret_cx = raw_block(fcx, fcx.llreturn);\n@@ -3786,9 +3694,7 @@ fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n \n fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     Br(raw_block(fcx, fcx.llstaticallocas), fcx.llloadenv);\n-    Br(raw_block(fcx, fcx.llloadenv), fcx.llderivedtydescs_first);\n-    Br(raw_block(fcx, fcx.llderivedtydescs), fcx.lldynamicallocas);\n-    Br(raw_block(fcx, fcx.lldynamicallocas), lltop);\n+    Br(raw_block(fcx, fcx.llloadenv), lltop);\n }\n \n enum self_arg { impl_self(ty::t), no_self, }\n@@ -3884,10 +3790,6 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n             in trans_res_ctor\"); }\n     };\n     let llretptr = fcx.llretptr;\n-    if ty::type_has_dynamic_size(ccx.tcx, ty::ty_fn_ret(fty)) {\n-        let llret_t = T_ptr(T_struct([ccx.int_type, llvm::LLVMTypeOf(arg)]));\n-        llretptr = BitCast(bcx, llretptr, llret_t);\n-    }\n \n     let dst = GEPi(bcx, llretptr, [0, 1]);\n     bcx = memmove_ty(bcx, dst, arg, arg_t);\n@@ -3946,9 +3848,6 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n           some(local_mem(x)) { x }\n         };\n         let arg_ty = arg_tys[i].ty;\n-        if ty::type_has_params(arg_ty) {\n-            lldestptr = PointerCast(bcx, lldestptr, val_ty(llarg));\n-        }\n         bcx = memmove_ty(bcx, lldestptr, llarg, arg_ty);\n         i += 1u;\n     }\n@@ -4718,7 +4617,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           maps: maps,\n           stats:\n               {mutable n_static_tydescs: 0u,\n-               mutable n_derived_tydescs: 0u,\n                mutable n_glues_created: 0u,\n                mutable n_null_glues: 0u,\n                mutable n_real_glues: 0u,\n@@ -4748,7 +4646,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     if ccx.sess.opts.stats {\n         #error(\"--- trans stats ---\");\n         #error(\"n_static_tydescs: %u\", ccx.stats.n_static_tydescs);\n-        #error(\"n_derived_tydescs: %u\", ccx.stats.n_derived_tydescs);\n         #error(\"n_glues_created: %u\", ccx.stats.n_glues_created);\n         #error(\"n_null_glues: %u\", ccx.stats.n_null_glues);\n         #error(\"n_real_glues: %u\", ccx.stats.n_real_glues);"}, {"sha": "d579d4c569c42aaa20b4506aba86244f85652f84", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 39, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=3ab9978b9bc010641423cf3ff2990a5ef0a61142", "patch": "@@ -15,7 +15,6 @@ import back::link::{\n     mangle_internal_name_by_path,\n     mangle_internal_name_by_path_and_seq};\n import util::ppaux::ty_to_str;\n-import shape::{size_of};\n import ast_map::{path, path_mod, path_name};\n import driver::session::session;\n import std::map::hashmap;\n@@ -215,16 +214,6 @@ type closure_result = {\n     bcx: block     // final bcx\n };\n \n-fn cast_if_we_can(bcx: block, llbox: ValueRef, t: ty::t) -> ValueRef {\n-    let ccx = bcx.ccx();\n-    if check type_has_static_size(ccx, t) {\n-        let llty = type_of(ccx, t);\n-        ret PointerCast(bcx, llbox, llty);\n-    } else {\n-        ret llbox;\n-    }\n-}\n-\n // Given a block context and a list of tydescs and values to bind\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n@@ -261,7 +250,8 @@ fn store_environment(bcx: block,\n     // whatever.\n     let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n     let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mutbl:ast::m_imm});\n-    let llbox = cast_if_we_can(bcx, llbox, cboxptr_ty);\n+\n+    let llbox = PointerCast(bcx, llbox, type_of(ccx, cboxptr_ty));\n     #debug[\"tuplify_box_ty = %s\", ty_to_str(tcx, cbox_ty)];\n \n     // Copy expr values into boxed bindings.\n@@ -717,32 +707,17 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     // And then, pick out the target function's own environment.  That's what\n     // we'll use as the environment the thunk gets.\n \n-    // Get f's return type, which will also be the return type of the entire\n-    // bind expression.\n-    let outgoing_ret_ty = ty::ty_fn_ret(outgoing_fty);\n-\n     // Get the types of the arguments to f.\n     let outgoing_args = ty::ty_fn_args(outgoing_fty);\n \n-    // The 'llretptr' that will arrive in the thunk we're creating also needs\n-    // to be the correct type.  Cast it to f's return type, if necessary.\n-    let llretptr = fcx.llretptr;\n-    if ty::type_has_params(outgoing_ret_ty) {\n-        let llretty = type_of(ccx, outgoing_ret_ty);\n-        llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n-    }\n-\n     // Set up the three implicit arguments to the thunk.\n-    let llargs: [ValueRef] = [llretptr, lltargetenv];\n+    let llargs: [ValueRef] = [fcx.llretptr, lltargetenv];\n \n     let a: uint = first_real_arg; // retptr, env come first\n     let b: int = starting_idx;\n     let outgoing_arg_index: uint = 0u;\n-    let llout_arg_tys: [TypeRef] =\n-        type_of_explicit_args(ccx, outgoing_args);\n     for arg: option<@ast::expr> in args {\n         let out_arg = outgoing_args[outgoing_arg_index];\n-        let llout_arg_ty = llout_arg_tys[outgoing_arg_index];\n         alt arg {\n           // Arg provided at binding time; thunk copies it from\n           // closure.\n@@ -762,23 +737,13 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n               }\n               ast::by_ref | ast::by_mutbl_ref | ast::by_move { }\n             }\n-\n-            // If the type is parameterized, then we need to cast the\n-            // type we actually have to the parameterized out type.\n-            if ty::type_has_params(out_arg.ty) {\n-                val = PointerCast(bcx, val, llout_arg_ty);\n-            }\n             llargs += [val];\n             b += 1;\n           }\n \n           // Arg will be provided when the thunk is invoked.\n           none {\n-            let arg: ValueRef = llvm::LLVMGetParam(llthunk, a as c_uint);\n-            if ty::type_has_params(out_arg.ty) {\n-                arg = PointerCast(bcx, arg, llout_arg_ty);\n-            }\n-            llargs += [arg];\n+            llargs += [llvm::LLVMGetParam(llthunk, a as c_uint)];\n             a += 1u;\n           }\n         }"}, {"sha": "5405b5da8155c09e1fa4d96efb2d24094a587105", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3ab9978b9bc010641423cf3ff2990a5ef0a61142", "patch": "@@ -26,8 +26,6 @@ fn new_namegen() -> namegen {\n     ret fn@(prefix: str) -> str { *i += 1; prefix + int::str(*i) };\n }\n \n-type derived_tydesc_info = {lltydesc: ValueRef, escapes: bool};\n-\n type tydesc_info =\n     {ty: ty::t,\n      tydesc: ValueRef,\n@@ -54,7 +52,6 @@ type tydesc_info =\n  */\n type stats =\n     {mutable n_static_tydescs: uint,\n-     mutable n_derived_tydescs: uint,\n      mutable n_glues_created: uint,\n      mutable n_null_glues: uint,\n      mutable n_real_glues: uint,\n@@ -150,14 +147,6 @@ type fn_ctxt = @{\n     // (LLVM requires that arguments be copied to local allocas before\n     // allowing most any operation to be performed on them.)\n     mutable llloadenv: BasicBlockRef,\n-    // The first and last block containing derived tydescs received from the\n-    // runtime. See description of derived_tydescs, below.\n-    mutable llderivedtydescs_first: BasicBlockRef,\n-    mutable llderivedtydescs: BasicBlockRef,\n-    // A block for all of the dynamically sized allocas.  This must be\n-    // after llderivedtydescs, because these sometimes depend on\n-    // information computed from derived tydescs.\n-    mutable lldynamicallocas: BasicBlockRef,\n     mutable llreturn: BasicBlockRef,\n     // The 'self' value currently in use in this function, if there\n     // is one.\n@@ -174,17 +163,6 @@ type fn_ctxt = @{\n     // Same as above, but for closure upvars\n     llupvars: hashmap<ast::node_id, ValueRef>,\n \n-    // Derived tydescs are tydescs created at runtime, for types that\n-    // involve type parameters inside type constructors.  For example,\n-    // suppose a function parameterized by T creates a vector of type\n-    // [T].  The function doesn't know what T is until runtime, and\n-    // the function's caller knows T but doesn't know that a vector is\n-    // involved.  So a tydesc for [T] can't be created until runtime,\n-    // when information about both \"[T]\" and \"T\" are available.  When\n-    // such a tydesc is created, we cache it in the derived_tydescs\n-    // table for the next time that such a tydesc is needed.\n-    derived_tydescs: hashmap<ty::t, derived_tydesc_info>,\n-\n     // The node_id of the function, or -1 if it doesn't correspond to\n     // a user-defined function.\n     id: ast::node_id,\n@@ -819,10 +797,6 @@ fn C_shape(ccx: @crate_ctxt, bytes: [u8]) -> ValueRef {\n     ret llvm::LLVMConstPointerCast(llglobal, T_ptr(T_i8()));\n }\n \n-pure fn type_has_static_size(cx: @crate_ctxt, t: ty::t) -> bool {\n-    !ty::type_has_dynamic_size(cx.tcx, t)\n-}\n-\n // Used to identify cached monomorphized functions\n enum mono_vtables { some_vts([mono_id]), no_vts }\n type mono_id = @{def: ast::def_id, substs: [ty::t], vtables: mono_vtables};\n@@ -869,7 +843,7 @@ fn node_id_type(bcx: block, id: ast::node_id) -> ty::t {\n     let t = ty::node_id_to_type(tcx, id);\n     alt bcx.fcx.param_substs {\n       some(substs) { ty::substitute_type_params(tcx, substs.tys, t) }\n-      _ { t }\n+      _ { assert !ty::type_has_params(t); t }\n     }\n }\n fn expr_ty(bcx: block, ex: @ast::expr) -> ty::t {"}, {"sha": "44f17111001b8c796247bd28f9e7bfe4f51678ec", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=3ab9978b9bc010641423cf3ff2990a5ef0a61142", "patch": "@@ -33,8 +33,8 @@ fn trans_self_arg(bcx: block, base: @ast::expr) -> result {\n     let m_by_ref = ast::expl(ast::by_ref);\n     let temp_cleanups = [];\n     let result = trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n-                                T_ptr(type_of_or_i8(bcx.ccx(), basety)), base,\n-                                temp_cleanups);\n+                                T_ptr(type_of::type_of(bcx.ccx(), basety)),\n+                                base, temp_cleanups);\n \n     // by-ref self argument should not require cleanup in the case of\n     // other arguments failing:"}, {"sha": "f632cf625c6f0e12be386901ab1ec9740aeec9b5", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 57, "deletions": 196, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=3ab9978b9bc010641423cf3ff2990a5ef0a61142", "patch": "@@ -96,8 +96,6 @@ fn mk_global(ccx: @crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n // Computes a set of variants of a enum that are guaranteed to have size and\n // alignment at least as large as any other variant of the enum. This is an\n // important performance optimization.\n-//\n-// FIXME: Use this in dynamic_size_of() as well.\n \n fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     // Compute the minimum and maximum size and alignment for each variant.\n@@ -109,7 +107,7 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     let variants = ty::enum_variants(ccx.tcx, tag_id);\n     for variant: ty::variant_info in *variants {\n         let bounded = true;\n-        let {a: min_size, b: min_align} = {a: 0u, b: 0u};\n+        let min_size = 0u, min_align = 0u;\n         for elem_t: ty::t in variant.args {\n             if ty::type_has_params(elem_t) {\n                 // FIXME: We could do better here; this causes us to\n@@ -179,7 +177,7 @@ fn round_up(size: u16, align: u8) -> u16 {\n type size_align = {size: u16, align: u8};\n \n fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: [uint],\n-                           did: ast::def_id) -> size_align {\n+                            did: ast::def_id) -> size_align {\n     let max_size = 0u16;\n     let max_align = 1u8;\n     let variants = ty::enum_variants(ccx.tcx, did);\n@@ -293,44 +291,37 @@ fn add_substr(&dest: [u8], src: [u8]) {\n }\n \n fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n-    let s = [];\n-\n     alt ty::get(t).struct {\n       ty::ty_nil | ty::ty_bool | ty::ty_uint(ast::ty_u8) |\n-      ty::ty_bot { s += [shape_u8]; }\n-      ty::ty_int(ast::ty_i) { s += [s_int(ccx.tcx)]; }\n-      ty::ty_float(ast::ty_f) { s += [s_float(ccx.tcx)]; }\n-      ty::ty_uint(ast::ty_u) | ty::ty_ptr(_) { s += [s_uint(ccx.tcx)]; }\n-      ty::ty_type { s += [s_tydesc(ccx.tcx)]; }\n-      ty::ty_send_type { s += [s_send_tydesc(ccx.tcx)]; }\n-      ty::ty_int(ast::ty_i8) { s += [shape_i8]; }\n-      ty::ty_uint(ast::ty_u16) { s += [shape_u16]; }\n-      ty::ty_int(ast::ty_i16) { s += [shape_i16]; }\n-      ty::ty_uint(ast::ty_u32) { s += [shape_u32]; }\n-      ty::ty_int(ast::ty_i32) | ty::ty_int(ast::ty_char) {s += [shape_i32];}\n-      ty::ty_uint(ast::ty_u64) { s += [shape_u64]; }\n-      ty::ty_int(ast::ty_i64) { s += [shape_i64]; }\n-      ty::ty_float(ast::ty_f32) { s += [shape_f32]; }\n-      ty::ty_float(ast::ty_f64) { s += [shape_f64]; }\n+      ty::ty_bot { [shape_u8] }\n+      ty::ty_int(ast::ty_i) { [s_int(ccx.tcx)] }\n+      ty::ty_float(ast::ty_f) { [s_float(ccx.tcx)] }\n+      ty::ty_uint(ast::ty_u) | ty::ty_ptr(_) { [s_uint(ccx.tcx)] }\n+      ty::ty_type { [s_tydesc(ccx.tcx)] }\n+      ty::ty_send_type { [s_send_tydesc(ccx.tcx)] }\n+      ty::ty_int(ast::ty_i8) { [shape_i8] }\n+      ty::ty_uint(ast::ty_u16) { [shape_u16] }\n+      ty::ty_int(ast::ty_i16) { [shape_i16] }\n+      ty::ty_uint(ast::ty_u32) { [shape_u32] }\n+      ty::ty_int(ast::ty_i32) | ty::ty_int(ast::ty_char) { [shape_i32] }\n+      ty::ty_uint(ast::ty_u64) { [shape_u64] }\n+      ty::ty_int(ast::ty_i64) { [shape_i64] }\n+      ty::ty_float(ast::ty_f32) { [shape_f32] }\n+      ty::ty_float(ast::ty_f64) { [shape_f64] }\n       ty::ty_str {\n-        s += [shape_vec];\n+        let s = [shape_vec];\n         add_bool(s, true); // type is POD\n         let unit_ty = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n         add_substr(s, shape_of(ccx, unit_ty, ty_param_map));\n+        s\n       }\n       ty::ty_enum(did, tps) {\n         alt enum_kind(ccx, did) {\n-          tk_unit {\n-            // FIXME: For now we do this.\n-            s += [s_variant_enum_t(ccx.tcx)];\n-          }\n-          tk_enum { s += [s_variant_enum_t(ccx.tcx)]; }\n+          // FIXME: For now we do this.\n+          tk_unit { [s_variant_enum_t(ccx.tcx)] }\n+          tk_enum { [s_variant_enum_t(ccx.tcx)] }\n           tk_newtype | tk_complex {\n-            s += [shape_enum];\n-\n-            let sub = [];\n-\n-            let id;\n+            let s = [shape_enum], id;\n             alt ccx.shape_cx.tag_id_to_index.find(did) {\n               none {\n                 id = ccx.shape_cx.next_tag_id;\n@@ -340,99 +331,85 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n               }\n               some(existing_id) { id = existing_id; }\n             }\n-            add_u16(sub, id as u16);\n+            add_u16(s, id as u16);\n \n-            add_u16(sub, vec::len(tps) as u16);\n+            add_u16(s, vec::len(tps) as u16);\n             for tp: ty::t in tps {\n                 let subshape = shape_of(ccx, tp, ty_param_map);\n-                add_u16(sub, vec::len(subshape) as u16);\n-                sub += subshape;\n+                add_u16(s, vec::len(subshape) as u16);\n+                s += subshape;\n             }\n-\n-            s += sub;\n+            s\n           }\n         }\n       }\n-      ty::ty_box(_) | ty::ty_opaque_box {\n-        s += [shape_box];\n-      }\n+      ty::ty_box(_) | ty::ty_opaque_box { [shape_box] }\n       ty::ty_uniq(mt) {\n-        s += [shape_uniq];\n+        let s = [shape_uniq];\n         add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n+        s\n       }\n       ty::ty_vec(mt) {\n-        s += [shape_vec];\n+        let s = [shape_vec];\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n         add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n+        s\n       }\n       ty::ty_rec(fields) {\n-        s += [shape_struct];\n-        let sub = [];\n+        let s = [shape_struct], sub = [];\n         for f: field in fields {\n             sub += shape_of(ccx, f.mt.ty, ty_param_map);\n         }\n         add_substr(s, sub);\n+        s\n       }\n       ty::ty_tup(elts) {\n-        s += [shape_struct];\n-        let sub = [];\n+        let s = [shape_struct], sub = [];\n         for elt in elts {\n             sub += shape_of(ccx, elt, ty_param_map);\n         }\n         add_substr(s, sub);\n+        s\n       }\n-      ty::ty_iface(_, _) { s += [shape_box_fn]; }\n-      ty::ty_class(_, _) { s += [shape_class]; }\n+      ty::ty_iface(_, _) { [shape_box_fn] }\n+      ty::ty_class(_, _) { [shape_class] }\n       ty::ty_rptr(_, tm) {\n-        s += [shape_rptr];\n+        let s = [shape_rptr];\n         add_substr(s, shape_of(ccx, tm.ty, ty_param_map));\n+        s\n       }\n       ty::ty_res(did, raw_subt, tps) {\n         let subt = ty::substitute_type_params(ccx.tcx, tps, raw_subt);\n         let ri = {did: did, tps: tps};\n         let id = interner::intern(ccx.shape_cx.resources, ri);\n \n-        s += [shape_res];\n+        let s = [shape_res];\n         add_u16(s, id as u16);\n         add_u16(s, vec::len(tps) as u16);\n         for tp: ty::t in tps {\n             add_substr(s, shape_of(ccx, tp, ty_param_map));\n         }\n         add_substr(s, shape_of(ccx, subt, ty_param_map));\n-\n+        s\n       }\n       ty::ty_param(n, _) {\n         // Find the type parameter in the parameter list.\n         alt vec::position_elt(ty_param_map, n) {\n-          some(i) { s += [shape_var, i as u8]; }\n+          some(i) { [shape_var, i as u8] }\n           none { fail \"ty param not found in ty_param_map\"; }\n         }\n       }\n-      ty::ty_fn({proto: ast::proto_box, _}) {\n-        s += [shape_box_fn];\n-      }\n-      ty::ty_fn({proto: ast::proto_uniq, _}) {\n-        s += [shape_uniq_fn];\n-      }\n+      ty::ty_fn({proto: ast::proto_box, _}) { [shape_box_fn] }\n+      ty::ty_fn({proto: ast::proto_uniq, _}) { [shape_uniq_fn] }\n       ty::ty_fn({proto: ast::proto_block, _}) |\n-      ty::ty_fn({proto: ast::proto_any, _}) {\n-        s += [shape_stack_fn];\n-      }\n-      ty::ty_fn({proto: ast::proto_bare, _}) {\n-        s += [shape_bare_fn];\n-      }\n-      ty::ty_opaque_closure_ptr(_) {\n-        s += [shape_opaque_closure_ptr];\n-      }\n-      ty::ty_constr(inner_t, _) {\n-        s += shape_of(ccx, inner_t, ty_param_map);\n-      }\n+      ty::ty_fn({proto: ast::proto_any, _}) { [shape_stack_fn] }\n+      ty::ty_fn({proto: ast::proto_bare, _}) { [shape_bare_fn] }\n+      ty::ty_opaque_closure_ptr(_) { [shape_opaque_closure_ptr] }\n+      ty::ty_constr(inner_t, _) { shape_of(ccx, inner_t, ty_param_map) }\n       ty::ty_var(_) | ty::ty_self(_) {\n         ccx.sess.bug(\"shape_of: unexpected type struct found\");\n       }\n     }\n-\n-    ret s;\n }\n \n // FIXME: We might discover other variants as we traverse these. Handle this.\n@@ -510,19 +487,15 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n         for v: uint in lv { add_u16(lv_table, v as u16); }\n \n         // Determine whether the enum has dynamic size.\n-        let dynamic = false;\n-        for variant: ty::variant_info in *variants {\n-            for typ: ty::t in variant.args {\n-                if ty::type_has_dynamic_size(ccx.tcx, typ) { dynamic = true; }\n-            }\n-        }\n+        let dynamic = vec::any(*variants, {|v|\n+            vec::any(v.args, {|t| ty::type_has_params(t)})\n+        });\n \n         // If we can, write in the static size and alignment of the enum.\n         // Otherwise, write a placeholder.\n-        let size_align;\n-        if dynamic {\n-            size_align = {size: 0u16, align: 0u8};\n-        } else { size_align = compute_static_enum_size(ccx, lv, did); }\n+        let size_align = if dynamic { {size: 0u16, align: 0u8} }\n+                         else { compute_static_enum_size(ccx, lv, did) };\n+        // Write in the static size and alignment of the enum.\n         add_u16(info, size_align.size);\n         info += [size_align.align];\n \n@@ -590,36 +563,6 @@ type tag_metrics = {\n     payload_align: ValueRef\n };\n \n-fn size_of(bcx: block, t: ty::t) -> result {\n-    let ccx = bcx.ccx();\n-    if check type_has_static_size(ccx, t) {\n-        rslt(bcx, llsize_of(ccx, type_of::type_of(ccx, t)))\n-    } else {\n-        let { bcx, sz, align: _ } = dynamic_metrics(bcx, t);\n-        rslt(bcx, sz)\n-    }\n-}\n-\n-fn align_of(bcx: block, t: ty::t) -> result {\n-    let ccx = bcx.ccx();\n-    if check type_has_static_size(ccx, t) {\n-        rslt(bcx, llalign_of(ccx, type_of::type_of(ccx, t)))\n-    } else {\n-        let { bcx, sz: _, align } = dynamic_metrics(bcx, t);\n-        rslt(bcx, align)\n-    }\n-}\n-\n-fn metrics(bcx: block, t: ty::t) -> metrics {\n-    let ccx = bcx.ccx();\n-    if check type_has_static_size(ccx, t) {\n-        let llty = type_of::type_of(ccx, t);\n-        { bcx: bcx, sz: llsize_of(ccx, llty), align: llalign_of(ccx, llty) }\n-    } else {\n-        dynamic_metrics(bcx, t)\n-    }\n-}\n-\n // Returns the real size of the given type for the current target.\n fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n     ret llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n@@ -645,7 +588,7 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n //\n // FIXME: Migrate trans over to use this.\n \n-// Computes the size of the data part of a non-dynamically-sized enum.\n+// Computes the size of the data part of an enum.\n fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n     if cx.enum_sizes.contains_key(t) { ret cx.enum_sizes.get(t); }\n     alt ty::get(t).struct {\n@@ -670,88 +613,6 @@ fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n     }\n }\n \n-fn dynamic_metrics(cx: block, t: ty::t) -> metrics {\n-    fn align_elements(cx: block, elts: [ty::t]) -> metrics {\n-        //\n-        // C padding rules:\n-        //\n-        //\n-        //   - Pad after each element so that next element is aligned.\n-        //   - Pad after final structure member so that whole structure\n-        //     is aligned to max alignment of interior.\n-        //\n-\n-        let off = C_int(cx.ccx(), 0);\n-        let max_align = C_int(cx.ccx(), 1);\n-        let bcx = cx;\n-        for e: ty::t in elts {\n-            let elt_align = align_of(bcx, e);\n-            bcx = elt_align.bcx;\n-            let elt_size = size_of(bcx, e);\n-            bcx = elt_size.bcx;\n-            let aligned_off = align_to(bcx, off, elt_align.val);\n-            off = Add(bcx, aligned_off, elt_size.val);\n-            max_align = umax(bcx, max_align, elt_align.val);\n-        }\n-        off = align_to(bcx, off, max_align);\n-        ret { bcx: bcx, sz: off, align: max_align };\n-    }\n-\n-    alt ty::get(t).struct {\n-      ty::ty_param(p, _) {\n-        let {bcx, val: tydesc} = base::get_tydesc_simple(cx, t);\n-        let szptr = GEPi(bcx, tydesc, [0, abi::tydesc_field_size]);\n-        let aptr = GEPi(bcx, tydesc, [0, abi::tydesc_field_align]);\n-        {bcx: bcx, sz: Load(bcx, szptr), align: Load(bcx, aptr)}\n-      }\n-      ty::ty_rec(flds) {\n-        let tys: [ty::t] = [];\n-        for f: ty::field in flds { tys += [f.mt.ty]; }\n-        align_elements(cx, tys)\n-      }\n-      ty::ty_tup(elts) {\n-        let tys = [];\n-        for tp in elts { tys += [tp]; }\n-        align_elements(cx, tys)\n-      }\n-      ty::ty_enum(tid, tps) {\n-        let bcx = cx;\n-        let ccx = bcx.ccx();\n-\n-        let compute_max_variant_size = fn@(bcx: block) -> result {\n-            // Compute max(variant sizes).\n-            let bcx = bcx;\n-            let max_size: ValueRef = C_int(ccx, 0);\n-            let variants = ty::enum_variants(bcx.tcx(), tid);\n-            for variant: ty::variant_info in *variants {\n-                // Perform type substitution on the raw argument types.\n-                let tys = vec::map(variant.args) {|raw_ty|\n-                    ty::substitute_type_params(cx.tcx(), tps, raw_ty)\n-                };\n-                let rslt = align_elements(bcx, tys);\n-                bcx = rslt.bcx;\n-                max_size = umax(bcx, rslt.sz, max_size);\n-            }\n-            rslt(bcx, max_size)\n-        };\n-\n-        let {bcx, val: sz} = alt enum_kind(ccx, tid) {\n-          tk_unit | tk_enum { rslt(bcx, llsize_of(ccx, T_enum_variant(ccx))) }\n-          tk_newtype { compute_max_variant_size(bcx) }\n-          tk_complex {\n-            let {bcx, val} = compute_max_variant_size(bcx);\n-            rslt(bcx, Add(bcx, val, llsize_of(ccx, T_enum_variant(ccx))))\n-          }\n-        };\n-\n-        { bcx: bcx, sz: sz, align: C_int(ccx, 1) }\n-      }\n-      _ {\n-        cx.tcx().sess.bug(\"dynamic_metrics: type has static size\");\n-      }\n-    }\n-}\n-\n // Creates a simpler, size-equivalent type. The resulting type is guaranteed\n // to have (a) the same size as the type that was passed in; (b) to be non-\n // recursive. This is done by replacing all boxes in a type with boxed unit"}, {"sha": "34e0ccfaffbc3d9aa5227997b9107d7ae49afc8c", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 25, "deletions": 64, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=3ab9978b9bc010641423cf3ff2990a5ef0a61142", "patch": "@@ -6,7 +6,7 @@ import base::{call_memmove, trans_shared_malloc,\n                INIT, copy_val, load_if_immediate, get_tydesc,\n                sub_block, do_spill_noroot,\n                dest};\n-import shape::{llsize_of, size_of};\n+import shape::llsize_of;\n import build::*;\n import common::*;\n \n@@ -40,29 +40,24 @@ type alloc_result =\n     {bcx: block,\n      val: ValueRef,\n      unit_ty: ty::t,\n-     llunitsz: ValueRef,\n      llunitty: TypeRef};\n \n fn alloc(bcx: block, vec_ty: ty::t, elts: uint) -> alloc_result {\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of::type_of_or_i8(ccx, unit_ty);\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n     let llvecty = T_vec(ccx, llunitty);\n-    let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n+    let unit_sz = llsize_of(ccx, llunitty);\n \n     let fill = Mul(bcx, C_uint(ccx, elts), unit_sz);\n-    let alloc = if elts < 4u {\n-                    Mul(bcx, C_int(ccx, 4), unit_sz)\n-                } else {\n-                    fill\n-                };\n+    let alloc = if elts < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n+                else { fill };\n     let {bcx: bcx, val: vptr} = alloc_raw(bcx, fill, alloc);\n     let vptr = PointerCast(bcx, vptr, T_ptr(llvecty));\n \n     ret {bcx: bcx,\n          val: vptr,\n          unit_ty: unit_ty,\n-         llunitsz: unit_sz,\n          llunitty: llunitty};\n }\n \n@@ -103,7 +98,6 @@ fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n     let vec_ty = node_id_type(bcx, id);\n     let {bcx: bcx,\n          val: vptr,\n-         llunitsz: llunitsz,\n          unit_ty: unit_ty,\n          llunitty: llunitty} =\n         alloc(bcx, vec_ty, args.len());\n@@ -113,9 +107,7 @@ fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n     let dataptr = get_dataptr(bcx, vptr, llunitty);\n     let i = 0u, temp_cleanups = [vptr];\n     for e in args {\n-        let lleltptr = if ty::type_has_dynamic_size(bcx.tcx(), unit_ty) {\n-            InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(ccx, i), llunitsz)])\n-        } else { InBoundsGEP(bcx, dataptr, [C_uint(ccx, i)]) };\n+        let lleltptr = InBoundsGEP(bcx, dataptr, [C_uint(ccx, i)]);\n         bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n         add_clean_temp_mem(bcx, lleltptr, unit_ty);\n         temp_cleanups += [lleltptr];\n@@ -137,26 +129,17 @@ fn trans_str(bcx: block, s: str, dest: dest) -> block {\n     ret base::store_in_dest(bcx, sptr, dest);\n }\n \n-fn trans_append(cx: block, vec_ty: ty::t, lhsptr: ValueRef,\n+fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n                 rhs: ValueRef) -> block {\n     // Cast to opaque interior vector types if necessary.\n-    let ccx = cx.ccx();\n-    let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n-    let dynamic = ty::type_has_dynamic_size(cx.tcx(), unit_ty);\n-    let (lhsptr, rhs) =\n-        if !dynamic {\n-            (lhsptr, rhs)\n-        } else {\n-            (PointerCast(cx, lhsptr, T_ptr(T_ptr(ccx.opaque_vec_type))),\n-             PointerCast(cx, rhs, T_ptr(ccx.opaque_vec_type)))\n-        };\n+    let ccx = bcx.ccx();\n+    let unit_ty = ty::sequence_element_type(ccx.tcx, vec_ty);\n     let strings = alt check ty::get(vec_ty).struct {\n       ty::ty_str { true }\n       ty::ty_vec(_) { false }\n     };\n \n-    let {bcx: bcx, val: unit_sz} = size_of(cx, unit_ty);\n-    let llunitty = type_of::type_of_or_i8(ccx, unit_ty);\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n \n     let lhs = Load(bcx, lhsptr);\n     let self_append = ICmp(bcx, lib::llvm::IntEQ, lhs, rhs);\n@@ -166,35 +149,25 @@ fn trans_append(cx: block, vec_ty: ty::t, lhsptr: ValueRef,\n     if strings { new_fill = Sub(bcx, new_fill, C_int(ccx, 1)); }\n     let opaque_lhs = PointerCast(bcx, lhsptr,\n                                  T_ptr(T_ptr(ccx.opaque_vec_type)));\n-    Call(bcx, cx.ccx().upcalls.vec_grow,\n+    Call(bcx, ccx.upcalls.vec_grow,\n          [opaque_lhs, new_fill]);\n     // Was overwritten if we resized\n     let lhs = Load(bcx, lhsptr);\n-    rhs = Select(bcx, self_append, lhs, rhs);\n+    let rhs = Select(bcx, self_append, lhs, rhs);\n \n     let lhs_data = get_dataptr(bcx, lhs, llunitty);\n     let lhs_off = lfill;\n     if strings { lhs_off = Sub(bcx, lhs_off, C_int(ccx, 1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n     let write_ptr_ptr = do_spill_noroot(bcx, write_ptr);\n-    let bcx = iter_vec_raw(bcx, rhs, vec_ty, rfill,\n-                     // We have to increment by the dynamically-computed size.\n-                     {|bcx, addr, _ty|\n-                         let write_ptr = Load(bcx, write_ptr_ptr);\n-                         let bcx =\n-                             copy_val(bcx, INIT, write_ptr,\n-                                      load_if_immediate(bcx, addr, unit_ty),\n-                                      unit_ty);\n-                         let incr = if dynamic {\n-                                        unit_sz\n-                                    } else {\n-                                        C_int(ccx, 1)\n-                                    };\n-                         Store(bcx, InBoundsGEP(bcx, write_ptr, [incr]),\n-                               write_ptr_ptr);\n-                         ret bcx;\n-                     });\n-    ret bcx;\n+    iter_vec_raw(bcx, rhs, vec_ty, rfill, {|bcx, addr, _ty|\n+        let write_ptr = Load(bcx, write_ptr_ptr);\n+        let bcx = copy_val(bcx, INIT, write_ptr,\n+                           load_if_immediate(bcx, addr, unit_ty), unit_ty);\n+        Store(bcx, InBoundsGEP(bcx, write_ptr, [C_int(ccx, 1)]),\n+              write_ptr_ptr);\n+        ret bcx;\n+    })\n }\n \n fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n@@ -226,8 +199,7 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n       _ { false }\n     };\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of::type_of_or_i8(ccx, unit_ty);\n-    let {bcx: bcx, val: llunitsz} = size_of(bcx, unit_ty);\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n \n     let lhs_fill = get_fill(bcx, lhs);\n     if strings { lhs_fill = Sub(bcx, lhs_fill, C_int(ccx, 1)); }\n@@ -244,13 +216,7 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n         let write_ptr = Load(bcx, write_ptr_ptr);\n         let bcx = copy_val(bcx, INIT, write_ptr,\n                            load_if_immediate(bcx, addr, unit_ty), unit_ty);\n-        let incr =\n-            if ty::type_has_dynamic_size(bcx.tcx(), unit_ty) {\n-                llunitsz\n-            } else {\n-                C_int(ccx, 1)\n-            };\n-        Store(bcx, InBoundsGEP(bcx, write_ptr, [incr]),\n+        Store(bcx, InBoundsGEP(bcx, write_ptr, [C_int(ccx, 1)]),\n               write_ptr_ptr);\n         ret bcx;\n     };\n@@ -268,8 +234,7 @@ fn iter_vec_raw(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n                 fill: ValueRef, f: iter_vec_block) -> block {\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of::type_of_or_i8(ccx, unit_ty);\n-    let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n     let vptr = PointerCast(bcx, vptr, T_ptr(T_vec(ccx, llunitty)));\n     let data_ptr = get_dataptr(bcx, vptr, llunitty);\n \n@@ -288,12 +253,8 @@ fn iter_vec_raw(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n     let next_cx = sub_block(header_cx, \"iter_vec_next\");\n     CondBr(header_cx, not_yet_at_end, body_cx.llbb, next_cx.llbb);\n     body_cx = f(body_cx, data_ptr, unit_ty);\n-    let increment =\n-        if ty::type_has_dynamic_size(bcx.tcx(), unit_ty) {\n-            unit_sz\n-        } else { C_int(ccx, 1) };\n-    AddIncomingToPhi(data_ptr, InBoundsGEP(body_cx, data_ptr, [increment]),\n-                     body_cx.llbb);\n+    AddIncomingToPhi(data_ptr, InBoundsGEP(body_cx, data_ptr,\n+                                           [C_int(ccx, 1)]), body_cx.llbb);\n     Br(body_cx, header_cx.llbb);\n     ret next_cx;\n }"}, {"sha": "7c19134faadae9915f5412cdb8d79e7fb7041a1d", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 10, "deletions": 40, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=3ab9978b9bc010641423cf3ff2990a5ef0a61142", "patch": "@@ -50,28 +50,12 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_float(t) { T_float_ty(cx, t) }\n       ty::ty_str { T_ptr(T_vec(cx, T_i8())) }\n       ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n-      ty::ty_box(mt) {\n-        let mt_ty = mt.ty;\n-        T_ptr(T_box(cx, type_of(cx, mt_ty))) }\n+      ty::ty_box(mt) { T_ptr(T_box(cx, type_of(cx, mt.ty))) }\n       ty::ty_opaque_box { T_ptr(T_box(cx, T_i8())) }\n-      ty::ty_uniq(mt) {\n-        let mt_ty = mt.ty;\n-        T_ptr(type_of(cx, mt_ty)) }\n-      ty::ty_vec(mt) {\n-        let mt_ty = mt.ty;\n-        if ty::type_has_dynamic_size(cx.tcx, mt_ty) {\n-            T_ptr(cx.opaque_vec_type)\n-        } else {\n-            T_ptr(T_vec(cx, type_of(cx, mt_ty))) }\n-      }\n-      ty::ty_ptr(mt) {\n-        let mt_ty = mt.ty;\n-        T_ptr(type_of(cx, mt_ty))\n-      }\n-      ty::ty_rptr(_, mt) {\n-        let mt_ty = mt.ty;\n-        T_ptr(type_of(cx, mt_ty))\n-      }\n+      ty::ty_uniq(mt) { T_ptr(type_of(cx, mt.ty)) }\n+      ty::ty_vec(mt) { T_ptr(T_vec(cx, type_of(cx, mt.ty))) }\n+      ty::ty_ptr(mt) { T_ptr(type_of(cx, mt.ty)) }\n+      ty::ty_rptr(_, mt) { T_ptr(type_of(cx, mt.ty)) }\n       ty::ty_rec(fields) {\n         let tys: [TypeRef] = [];\n         for f: ty::field in fields {\n@@ -80,9 +64,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         }\n         T_struct(tys)\n       }\n-      ty::ty_fn(_) {\n-        T_fn_pair(cx, type_of_fn_from_ty(cx, t))\n-      }\n+      ty::ty_fn(_) { T_fn_pair(cx, type_of_fn_from_ty(cx, t)) }\n       ty::ty_iface(_, _) { T_opaque_iface(cx) }\n       ty::ty_res(_, sub, tps) {\n         let sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n@@ -126,20 +108,8 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     -> TypeRef {\n     let degen = (*ty::enum_variants(cx.tcx, did)).len() == 1u;\n-    if check type_has_static_size(cx, t) {\n-        let size = shape::static_size_of_enum(cx, t);\n-        if !degen { T_enum(cx, size) }\n-        else if size == 0u { T_struct([T_enum_variant(cx)]) }\n-        else { T_array(T_i8(), size) }\n-    }\n-    else {\n-        if degen { T_struct([T_enum_variant(cx)]) }\n-        else { T_opaque_enum(cx) }\n-    }\n-}\n-\n-fn type_of_or_i8(ccx: @crate_ctxt, typ: ty::t) -> TypeRef {\n-    if check type_has_static_size(ccx, typ) {\n-        type_of(ccx, typ)\n-    } else { T_i8() }\n+    let size = shape::static_size_of_enum(cx, t);\n+    if !degen { T_enum(cx, size) }\n+    else if size == 0u { T_struct([T_enum_variant(cx)]) }\n+    else { T_array(T_i8(), size) }\n }"}, {"sha": "df34e37f6677f06b1a1160919c6bbcdd6a4486ec", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=3ab9978b9bc010641423cf3ff2990a5ef0a61142", "patch": "@@ -3,7 +3,7 @@ import lib::llvm::ValueRef;\n import common::*;\n import build::*;\n import base::*;\n-import shape::size_of;\n+import shape::llsize_of;\n \n export trans_uniq, make_free_glue, autoderef, duplicate, alloc_uniq;\n \n@@ -20,17 +20,10 @@ fn trans_uniq(bcx: block, contents: @ast::expr,\n fn alloc_uniq(cx: block, uniq_ty: ty::t) -> result {\n     let bcx = cx;\n     let contents_ty = content_ty(uniq_ty);\n-    let r = size_of(bcx, contents_ty);\n-    bcx = r.bcx;\n-    let llsz = r.val;\n-\n-    let llptrty = T_ptr(type_of::type_of(bcx.ccx(), contents_ty));\n-\n-    r = trans_shared_malloc(bcx, llptrty, llsz);\n-    bcx = r.bcx;\n-    let llptr = r.val;\n-\n-    ret rslt(bcx, llptr);\n+    let llty = type_of::type_of(bcx.ccx(), contents_ty);\n+    let llsz = llsize_of(bcx.ccx(), llty);\n+    let llptrty = T_ptr(llty);\n+    trans_shared_malloc(bcx, llptrty, llsz)\n }\n \n fn make_free_glue(bcx: block, vptr: ValueRef, t: ty::t)"}, {"sha": "f9f5a9efd3c1fe9e333a494621f277526e6121f5", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab9978b9bc010641423cf3ff2990a5ef0a61142/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=3ab9978b9bc010641423cf3ff2990a5ef0a61142", "patch": "@@ -99,7 +99,6 @@ export kind, kind_sendable, kind_copyable, kind_noncopyable;\n export kind_can_be_copied, kind_can_be_sent, proto_kind, kind_lteq, type_kind;\n export type_err;\n export type_err_to_str;\n-export type_has_dynamic_size;\n export type_needs_drop;\n export type_allows_implicit_copy;\n export type_is_integral;\n@@ -960,23 +959,6 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n     }\n }\n \n-pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool unchecked {\n-    /* type_structurally_contains can't be declared pure\n-    because it takes a function argument. But it should be\n-    referentially transparent, since a given type's size should\n-    never change once it's created.\n-    (It would be interesting to think about how to make such properties\n-    actually checkable. It seems to me like a lot of properties\n-    that the type context tracks about types should be immutable.)\n-    */\n-    type_has_params(ty) && type_structurally_contains(cx, ty) {|sty|\n-        alt sty {\n-          ty_param(_, _) { true }\n-          _ { false }\n-        }\n-    }\n-}\n-\n // Returns true for noncopyable types and types where a copy of a value can be\n // distinguished from the value itself. I.e. types with mutable content that's\n // not shared through a pointer.\n@@ -2250,6 +2232,7 @@ fn type_err_to_str(err: type_err) -> str {\n // Replaces type parameters in the given type using the given list of\n // substitions.\n fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n+    if !type_has_params(typ) { ret typ; }\n     // Precondition? idx < vec::len(substs)\n     fold_ty(cx, fm_param({|idx, _id| substs[idx]}), typ)\n }"}, {"sha": "2587e35219c6d59ad13a3470e728483236f4493d", "filename": "src/test/compile-fail/param-by-value.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4d75a4ed14e42adcf6227e599ac762a0056a34e/src%2Ftest%2Fcompile-fail%2Fparam-by-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d75a4ed14e42adcf6227e599ac762a0056a34e/src%2Ftest%2Fcompile-fail%2Fparam-by-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fparam-by-value.rs?ref=a4d75a4ed14e42adcf6227e599ac762a0056a34e", "patch": "@@ -1,4 +0,0 @@\n-// error-pattern:can not pass a dynamically-sized type by value\n-\n-fn f<T>(++_x: T) {}\n-fn main() {}"}]}