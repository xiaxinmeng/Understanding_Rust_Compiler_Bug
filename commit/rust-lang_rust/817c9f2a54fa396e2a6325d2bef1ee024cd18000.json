{"sha": "817c9f2a54fa396e2a6325d2bef1ee024cd18000", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxN2M5ZjJhNTRmYTM5NmUyYTYzMjVkMmJlZjFlZTAyNGNkMTgwMDA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-02T15:46:19Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-02T15:46:19Z"}, "message": "Include full module path in unresolved errors when looking in module\n\nCloses #1228", "tree": {"sha": "8dc477475956f4f95e53e354c31e6b63c6d57612", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dc477475956f4f95e53e354c31e6b63c6d57612"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/817c9f2a54fa396e2a6325d2bef1ee024cd18000", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/817c9f2a54fa396e2a6325d2bef1ee024cd18000", "html_url": "https://github.com/rust-lang/rust/commit/817c9f2a54fa396e2a6325d2bef1ee024cd18000", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/817c9f2a54fa396e2a6325d2bef1ee024cd18000/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f918ddd8becd9f25d6d0614d5d42cf860a60d5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f918ddd8becd9f25d6d0614d5d42cf860a60d5f", "html_url": "https://github.com/rust-lang/rust/commit/0f918ddd8becd9f25d6d0614d5d42cf860a60d5f"}], "stats": {"total": 89, "additions": 61, "deletions": 28}, "files": [{"sha": "9fdbaaaba7948dfa329414afdaaa055d0b03d0ae", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 61, "deletions": 28, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/817c9f2a54fa396e2a6325d2bef1ee024cd18000/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817c9f2a54fa396e2a6325d2bef1ee024cd18000/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=817c9f2a54fa396e2a6325d2bef1ee024cd18000", "patch": "@@ -83,12 +83,13 @@ type mod_index = hashmap<ident, list<mod_index_entry>>;\n // A tuple of an imported def and the import stmt that brung it\n type glob_imp_def = {def: def, item: @ast::view_item};\n \n-type indexed_mod =\n-    {m: option::t<ast::_mod>,\n-     index: mod_index,\n-     mutable glob_imports: [glob_imp_def],\n-     glob_imported_names: hashmap<str, import_state>};\n-\n+type indexed_mod = {\n+    m: option::t<ast::_mod>,\n+    index: mod_index,\n+    mutable glob_imports: [glob_imp_def],\n+    glob_imported_names: hashmap<str, import_state>,\n+    path: str\n+};\n \n /* native modules can't contain tags, and we don't store their ASTs because we\n    only need to look at them to determine exports, which they can't control.*/\n@@ -160,7 +161,8 @@ fn map_crate(e: @env, c: @ast::crate) {\n                      @{m: some(c.node.module),\n                        index: index_mod(c.node.module),\n                        mutable glob_imports: [],\n-                       glob_imported_names: new_str_hash::<import_state>()});\n+                       glob_imported_names: new_str_hash::<import_state>(),\n+                       path: \"\"});\n     fn index_vi(e: @env, i: @ast::view_item, sc: scopes, _v: vt<scopes>) {\n         alt i.node {\n           ast::view_item_import(name, ids, id) {\n@@ -177,6 +179,16 @@ fn map_crate(e: @env, c: @ast::crate) {\n           _ { }\n         }\n     }\n+    fn path_from_scope(sc: scopes, n: str) -> str {\n+        let path = n + \"::\";\n+        list::iter(sc) {|s|\n+            alt s {\n+              scope_item(i) { path = i.ident + \"::\" + path; }\n+              _ {}\n+            }\n+        }\n+        path\n+    }\n     fn index_i(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n         visit_item_with_scope(i, sc, v);\n         alt i.node {\n@@ -186,15 +198,17 @@ fn map_crate(e: @env, c: @ast::crate) {\n                              @{m: some(md),\n                                index: index_mod(md),\n                                mutable glob_imports: [],\n-                               glob_imported_names: s});\n+                               glob_imported_names: s,\n+                               path: path_from_scope(sc, i.ident)});\n           }\n           ast::item_native_mod(nmd) {\n             let s = new_str_hash::<import_state>();\n             e.mod_map.insert(i.id,\n                              @{m: none::<ast::_mod>,\n                                index: index_nmod(nmd),\n                                mutable glob_imports: [],\n-                               glob_imported_names: s});\n+                               glob_imported_names: s,\n+                               path: path_from_scope(sc, i.ident)});\n           }\n           _ { }\n         }\n@@ -416,7 +430,7 @@ fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n     while true && option::is_some(dcur) {\n         if i == path_len { break; }\n         dcur =\n-            lookup_in_mod_strict(e, sc, option::get(dcur), sp, path[i],\n+            lookup_in_mod_strict(e, option::get(dcur), sp, path[i],\n                                  ns_module, outside);\n         i += 1u;\n     }\n@@ -452,12 +466,12 @@ fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n // Import resolution\n fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n                   ids: [ast::ident], sp: codemap::span, sc: scopes) {\n-    fn register(e: env, id: node_id, sc: scopes, sp: codemap::span,\n+    fn register(e: env, id: node_id, cx: ctxt, sp: codemap::span,\n                 name: ast::ident, lookup: block(namespace) -> option::t<def>){\n         let val = lookup(ns_value), typ = lookup(ns_type),\n             md = lookup(ns_module);\n         if is_none(val) && is_none(typ) && is_none(md) {\n-            unresolved_err(e, sc, sp, name, \"import\");\n+            unresolved_err(e, cx, sp, name, \"import\");\n         } else {\n             e.imports.insert(id, resolved(val, typ, md, name, sp));\n         }\n@@ -507,16 +521,18 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n     let n_idents = vec::len(ids);\n     let end_id = ids[n_idents - 1u];\n     if n_idents == 1u {\n-        register(e, defid.node, sc, sp, name,\n+        register(e, defid.node, in_scope(sc), sp, name,\n                  {|ns| lookup_in_scope(e, sc, sp, end_id, ns) });\n     } else {\n         alt lookup_in_scope(e, sc, sp, ids[0], ns_module) {\n-          none. { unresolved_err(e, sc, sp, ids[0], ns_name(ns_module)); }\n+          none. {\n+            unresolved_err(e, in_scope(sc), sp, ids[0], ns_name(ns_module));\n+          }\n           some(dcur_) {\n             let dcur = dcur_, i = 1u;\n             while true {\n                 if i == n_idents - 1u {\n-                    register(e, defid.node, sc, sp, name, {|ns|\n+                    register(e, defid.node, in_mod(dcur), sp, name, {|ns|\n                         lookup_in_mod(e, dcur, sp, end_id, ns, outside)\n                     });\n                     break;\n@@ -525,7 +541,8 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n                                              outside) {\n                       some(dcur) { dcur }\n                       none. {\n-                        unresolved_err(e, sc, sp, ids[i], ns_name(ns_module));\n+                        unresolved_err(e, in_mod(dcur), sp, ids[i],\n+                                       ns_name(ns_module));\n                         break;\n                       }\n                     };\n@@ -557,7 +574,9 @@ fn ns_name(ns: namespace) -> str {\n     }\n }\n \n-fn unresolved_err(e: env, sc: scopes, sp: span, name: ident, kind: str) {\n+tag ctxt { in_mod(def); in_scope(scopes); }\n+\n+fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n     fn find_fn_or_mod_scope(sc: scopes) -> option::t<scope> {\n         let sc = sc;\n         while true {\n@@ -576,16 +595,24 @@ fn unresolved_err(e: env, sc: scopes, sp: span, name: ident, kind: str) {\n         }\n         fail;\n     }\n-    alt find_fn_or_mod_scope(sc) {\n-      some(err_scope) {\n-        for rs: {ident: str, sc: scope} in e.reported {\n-            if str::eq(rs.ident, name) && err_scope == rs.sc { ret; }\n+    let path = name;\n+    alt cx {\n+      in_scope(sc) {\n+        alt find_fn_or_mod_scope(sc) {\n+          some(err_scope) {\n+            for rs: {ident: str, sc: scope} in e.reported {\n+                if str::eq(rs.ident, name) && err_scope == rs.sc { ret; }\n+            }\n+            e.reported += [{ident: name, sc: err_scope}];\n+          }\n+          _ {}\n         }\n-        e.reported += [{ident: name, sc: err_scope}];\n       }\n-      _ {}\n+      in_mod(def) {\n+        path = e.mod_map.get(ast_util::def_id_of_def(def).node).path + path;\n+      }\n     }\n-    e.sess.span_err(sp, mk_unresolved_msg(name, kind));\n+    e.sess.span_err(sp, mk_unresolved_msg(path, kind));\n }\n \n fn unresolved_fatal(e: env, sp: span, id: ident, kind: str) -> ! {\n@@ -614,7 +641,7 @@ fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: ast::path_,\n     while i < n_idents && option::is_some(dcur) {\n         let curns = if n_idents == i + 1u { ns } else { ns_module };\n         dcur =\n-            lookup_in_mod_strict(e, sc, option::get(dcur), sp, pth.idents[i],\n+            lookup_in_mod_strict(e, option::get(dcur), sp, pth.idents[i],\n                                  curns, outside);\n         i += 1u;\n     }\n@@ -624,7 +651,10 @@ fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: ast::path_,\n fn lookup_in_scope_strict(e: env, sc: scopes, sp: span, name: ident,\n                           ns: namespace) -> option::t<def> {\n     alt lookup_in_scope(e, sc, sp, name, ns) {\n-      none. { unresolved_err(e, sc, sp, name, ns_name(ns)); ret none; }\n+      none. {\n+        unresolved_err(e, in_scope(sc), sp, name, ns_name(ns));\n+        ret none;\n+      }\n       some(d) { ret some(d); }\n     }\n }\n@@ -954,10 +984,13 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n     ret none::<def>;\n }\n \n-fn lookup_in_mod_strict(e: env, sc: scopes, m: def, sp: span, name: ident,\n+fn lookup_in_mod_strict(e: env, m: def, sp: span, name: ident,\n                         ns: namespace, dr: dir) -> option::t<def> {\n     alt lookup_in_mod(e, m, sp, name, ns, dr) {\n-      none. { unresolved_err(e, sc, sp, name, ns_name(ns)); ret none; }\n+      none. {\n+        unresolved_err(e, in_mod(m), sp, name, ns_name(ns));\n+        ret none;\n+      }\n       some(d) { ret some(d); }\n     }\n }"}]}