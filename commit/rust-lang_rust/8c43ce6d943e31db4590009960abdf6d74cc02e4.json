{"sha": "8c43ce6d943e31db4590009960abdf6d74cc02e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNDNjZTZkOTQzZTMxZGI0NTkwMDA5OTYwYWJkZjZkNzRjYzAyZTQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-23T19:38:22Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-26T08:49:23Z"}, "message": "Bring in the line-length police", "tree": {"sha": "346bde6cba99619ed66b2d00a23d7f4cf6a6134b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/346bde6cba99619ed66b2d00a23d7f4cf6a6134b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c43ce6d943e31db4590009960abdf6d74cc02e4", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c43ce6d943e31db4590009960abdf6d74cc02e4", "html_url": "https://github.com/rust-lang/rust/commit/8c43ce6d943e31db4590009960abdf6d74cc02e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c43ce6d943e31db4590009960abdf6d74cc02e4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf5152f486a88ea106a820387d7d807ea99962af", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf5152f486a88ea106a820387d7d807ea99962af", "html_url": "https://github.com/rust-lang/rust/commit/bf5152f486a88ea106a820387d7d807ea99962af"}], "stats": {"total": 198, "additions": 114, "deletions": 84}, "files": [{"sha": "bc2c199b83ffdd2626858ae2a415dd60f7e921d8", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8c43ce6d943e31db4590009960abdf6d74cc02e4/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c43ce6d943e31db4590009960abdf6d74cc02e4/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=8c43ce6d943e31db4590009960abdf6d74cc02e4", "patch": "@@ -10,45 +10,46 @@\n \n use std::rt::env::max_cached_stacks;\n use std::os::{errno, page_size, MemoryMap, MapReadable, MapWritable,\n-    MapNonStandardFlags, MapVirtual};\n-#[cfg(not(windows))]\n-use std::libc::{MAP_STACK, MAP_PRIVATE, MAP_ANON};\n-use std::libc::{c_uint, c_int, c_void, uintptr_t};\n+              MapNonStandardFlags, MapVirtual};\n+use std::libc;\n \n /// A task's stack. The name \"Stack\" is a vestige of segmented stacks.\n pub struct Stack {\n     priv buf: MemoryMap,\n     priv min_size: uint,\n-    priv valgrind_id: c_uint,\n+    priv valgrind_id: libc::c_uint,\n }\n \n // Try to use MAP_STACK on platforms that support it (it's what we're doing\n // anyway), but some platforms don't support it at all. For example, it appears\n // that there's a bug in freebsd that MAP_STACK implies MAP_FIXED (so it always\n // fails): http://lists.freebsd.org/pipermail/freebsd-bugs/2011-July/044840.html\n #[cfg(not(windows), not(target_os = \"freebsd\"))]\n-static STACK_FLAGS: c_int = MAP_STACK | MAP_PRIVATE | MAP_ANON;\n+static STACK_FLAGS: libc::c_int = libc::MAP_STACK | libc::MAP_PRIVATE |\n+                                  libc::MAP_ANON;\n #[cfg(target_os = \"freebsd\")]\n-static STACK_FLAGS: c_int = MAP_PRIVATE | MAP_ANON;\n+static STACK_FLAGS: libc::c_int = libc::MAP_PRIVATE | libc::MAP_ANON;\n #[cfg(windows)]\n-static STACK_FLAGS: c_int = 0;\n+static STACK_FLAGS: libc::c_int = 0;\n \n impl Stack {\n     /// Allocate a new stack of `size`. If size = 0, this will fail. Use\n     /// `dummy_stack` if you want a zero-sized stack.\n     pub fn new(size: uint) -> Stack {\n-        // Map in a stack. Eventually we might be able to handle stack allocation failure, which\n-        // would fail to spawn the task. But there's not many sensible things to do on OOM.\n-        // Failure seems fine (and is what the old stack allocation did).\n+        // Map in a stack. Eventually we might be able to handle stack\n+        // allocation failure, which would fail to spawn the task. But there's\n+        // not many sensible things to do on OOM.  Failure seems fine (and is\n+        // what the old stack allocation did).\n         let stack = match MemoryMap::new(size, [MapReadable, MapWritable,\n                                          MapNonStandardFlags(STACK_FLAGS)]) {\n             Ok(map) => map,\n-            Err(e) => fail!(\"Creating memory map for stack of size {} failed: {}\", size, e)\n+            Err(e) => fail!(\"mmap for stack of size {} failed: {}\", size, e)\n         };\n \n-        // Change the last page to be inaccessible. This is to provide safety; when an FFI\n-        // function overflows it will (hopefully) hit this guard page. It isn't guaranteed, but\n-        // that's why FFI is unsafe. buf.data is guaranteed to be aligned properly.\n+        // Change the last page to be inaccessible. This is to provide safety;\n+        // when an FFI function overflows it will (hopefully) hit this guard\n+        // page. It isn't guaranteed, but that's why FFI is unsafe. buf.data is\n+        // guaranteed to be aligned properly.\n         if !protect_last_page(&stack) {\n             fail!(\"Could not memory-protect guard page. stack={:?}, errno={}\",\n                   stack, errno());\n@@ -61,7 +62,9 @@ impl Stack {\n         };\n \n         // XXX: Using the FFI to call a C macro. Slow\n-        stk.valgrind_id = unsafe { rust_valgrind_stack_register(stk.start(), stk.end()) };\n+        stk.valgrind_id = unsafe {\n+            rust_valgrind_stack_register(stk.start(), stk.end())\n+        };\n         return stk;\n     }\n \n@@ -87,30 +90,27 @@ impl Stack {\n     }\n }\n \n-// These use ToPrimitive so that we never need to worry about the sizes of whatever types these\n-// (which we would with scalar casts). It's either a wrapper for a scalar cast or failure: fast, or\n-// will fail during compilation.\n #[cfg(unix)]\n fn protect_last_page(stack: &MemoryMap) -> bool {\n-    use std::libc::{mprotect, PROT_NONE, size_t};\n     unsafe {\n-        // This may seem backwards: the start of the segment is the last page? Yes! The stack grows\n-        // from higher addresses (the end of the allocated block) to lower addresses (the start of\n-        // the allocated block).\n-        let last_page = stack.data as *c_void;\n-        mprotect(last_page, page_size() as size_t, PROT_NONE) != -1\n+        // This may seem backwards: the start of the segment is the last page?\n+        // Yes! The stack grows from higher addresses (the end of the allocated\n+        // block) to lower addresses (the start of the allocated block).\n+        let last_page = stack.data as *libc::c_void;\n+        libc::mprotect(last_page, page_size() as libc::size_t,\n+                       libc::PROT_NONE) != -1\n     }\n }\n \n #[cfg(windows)]\n fn protect_last_page(stack: &MemoryMap) -> bool {\n-    use std::libc::{VirtualProtect, PAGE_NOACCESS, SIZE_T, LPDWORD, DWORD};\n     unsafe {\n         // see above\n-        let last_page = stack.data as *mut c_void;\n-        let mut old_prot: DWORD = 0;\n-        VirtualProtect(last_page, page_size() as SIZE_T, PAGE_NOACCESS,\n-                       &mut old_prot as LPDWORD) != 0\n+        let last_page = stack.data as *mut libc::c_void;\n+        let mut old_prot: libc::DWORD = 0;\n+        libc::VirtualProtect(last_page, page_size() as libc::SIZE_T,\n+                             libc::PAGE_NOACCESS,\n+                             &mut old_prot as libc::LPDWORD) != 0\n     }\n }\n \n@@ -124,7 +124,8 @@ impl Drop for Stack {\n }\n \n pub struct StackPool {\n-    // Ideally this would be some datastructure that preserved ordering on Stack.min_size.\n+    // Ideally this would be some datastructure that preserved ordering on\n+    // Stack.min_size.\n     priv stacks: ~[Stack],\n }\n \n@@ -151,6 +152,7 @@ impl StackPool {\n }\n \n extern {\n-    fn rust_valgrind_stack_register(start: *uintptr_t, end: *uintptr_t) -> c_uint;\n-    fn rust_valgrind_stack_deregister(id: c_uint);\n+    fn rust_valgrind_stack_register(start: *libc::uintptr_t,\n+                                    end: *libc::uintptr_t) -> libc::c_uint;\n+    fn rust_valgrind_stack_deregister(id: libc::c_uint);\n }"}, {"sha": "457d58ae464050f85bd42253435df62836f919cd", "filename": "src/libstd/os.rs", "status": "modified", "additions": 79, "deletions": 51, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/8c43ce6d943e31db4590009960abdf6d74cc02e4/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c43ce6d943e31db4590009960abdf6d74cc02e4/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=8c43ce6d943e31db4590009960abdf6d74cc02e4", "patch": "@@ -33,7 +33,7 @@ use container::Container;\n #[cfg(target_os = \"macos\")]\n use iter::range;\n use libc;\n-use libc::{c_char, c_void, c_int, size_t};\n+use libc::{c_char, c_void, c_int};\n use option::{Some, None};\n use os;\n use prelude::*;\n@@ -59,7 +59,7 @@ pub fn getcwd() -> Path {\n \n     let mut buf = [0 as c_char, ..BUF_BYTES];\n     unsafe {\n-        if libc::getcwd(buf.as_mut_ptr(), buf.len() as size_t).is_null() {\n+        if libc::getcwd(buf.as_mut_ptr(), buf.len() as libc::size_t).is_null() {\n             fail!()\n         }\n         Path::new(CString::new(buf.as_ptr(), false))\n@@ -350,14 +350,16 @@ pub fn self_exe_name() -> Option<Path> {\n             let mib = ~[CTL_KERN as c_int,\n                         KERN_PROC as c_int,\n                         KERN_PROC_PATHNAME as c_int, -1 as c_int];\n-            let mut sz: size_t = 0;\n+            let mut sz: libc::size_t = 0;\n             let err = sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n-                             ptr::mut_null(), &mut sz, ptr::null(), 0u as size_t);\n+                             ptr::mut_null(), &mut sz, ptr::null(),\n+                             0u as libc::size_t);\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             let mut v: ~[u8] = vec::with_capacity(sz as uint);\n             let err = sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n-                             v.as_mut_ptr() as *mut c_void, &mut sz, ptr::null(), 0u as size_t);\n+                             v.as_mut_ptr() as *mut c_void, &mut sz, ptr::null(),\n+                             0u as libc::size_t);\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n@@ -593,12 +595,12 @@ pub fn last_os_error() -> ~str {\n         #[cfg(target_os = \"macos\")]\n         #[cfg(target_os = \"android\")]\n         #[cfg(target_os = \"freebsd\")]\n-        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t)\n+        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)\n                       -> c_int {\n             #[nolink]\n             extern {\n-                fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t)\n-                              -> c_int;\n+                fn strerror_r(errnum: c_int, buf: *mut c_char,\n+                              buflen: libc::size_t) -> c_int;\n             }\n             unsafe {\n                 strerror_r(errnum, buf, buflen)\n@@ -609,12 +611,13 @@ pub fn last_os_error() -> ~str {\n         // and requires macros to instead use the POSIX compliant variant.\n         // So we just use __xpg_strerror_r which is always POSIX compliant\n         #[cfg(target_os = \"linux\")]\n-        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t) -> c_int {\n+        fn strerror_r(errnum: c_int, buf: *mut c_char,\n+                      buflen: libc::size_t) -> c_int {\n             #[nolink]\n             extern {\n                 fn __xpg_strerror_r(errnum: c_int,\n                                     buf: *mut c_char,\n-                                    buflen: size_t)\n+                                    buflen: libc::size_t)\n                                     -> c_int;\n             }\n             unsafe {\n@@ -626,7 +629,7 @@ pub fn last_os_error() -> ~str {\n \n         let p = buf.as_mut_ptr();\n         unsafe {\n-            if strerror_r(errno() as c_int, p, buf.len() as size_t) < 0 {\n+            if strerror_r(errno() as c_int, p, buf.len() as libc::size_t) < 0 {\n                 fail!(\"strerror_r failure\");\n             }\n \n@@ -829,13 +832,14 @@ pub fn page_size() -> uint {\n     }\n }\n \n-/// A memory mapped file or chunk of memory. This is a very system-specific interface to the OS's\n-/// memory mapping facilities (`mmap` on POSIX, `VirtualAlloc`/`CreateFileMapping` on win32). It\n-/// makes no attempt at abstracting platform differences, besides in error values returned. Consider\n+/// A memory mapped file or chunk of memory. This is a very system-specific\n+/// interface to the OS's memory mapping facilities (`mmap` on POSIX,\n+/// `VirtualAlloc`/`CreateFileMapping` on win32). It makes no attempt at\n+/// abstracting platform differences, besides in error values returned. Consider\n /// yourself warned.\n ///\n-/// The memory map is released (unmapped) when the destructor is run, so don't let it leave scope by\n-/// accident if you want it to stick around.\n+/// The memory map is released (unmapped) when the destructor is run, so don't\n+/// let it leave scope by accident if you want it to stick around.\n pub struct MemoryMap {\n     /// Pointer to the memory created or modified by this map.\n     data: *mut u8,\n@@ -847,11 +851,12 @@ pub struct MemoryMap {\n \n /// Type of memory map\n pub enum MemoryMapKind {\n-    /// Virtual memory map. Usually used to change the permissions of a given chunk of memory.\n-    /// Corresponds to `VirtualAlloc` on Windows.\n+    /// Virtual memory map. Usually used to change the permissions of a given\n+    /// chunk of memory.  Corresponds to `VirtualAlloc` on Windows.\n     MapFile(*u8),\n-    /// Virtual memory map. Usually used to change the permissions of a given chunk of memory, or\n-    /// for allocation. Corresponds to `VirtualAlloc` on Windows.\n+    /// Virtual memory map. Usually used to change the permissions of a given\n+    /// chunk of memory, or for allocation. Corresponds to `VirtualAlloc` on\n+    /// Windows.\n     MapVirtual\n }\n \n@@ -863,55 +868,63 @@ pub enum MapOption {\n     MapWritable,\n     /// The memory should be executable\n     MapExecutable,\n-    /// Create a map for a specific address range. Corresponds to `MAP_FIXED` on POSIX.\n+    /// Create a map for a specific address range. Corresponds to `MAP_FIXED` on\n+    /// POSIX.\n     MapAddr(*u8),\n     /// Create a memory mapping for a file with a given fd.\n     MapFd(c_int),\n-    /// When using `MapFd`, the start of the map is `uint` bytes from the start of the file.\n+    /// When using `MapFd`, the start of the map is `uint` bytes from the start\n+    /// of the file.\n     MapOffset(uint),\n-    /// On POSIX, this can be used to specify the default flags passed to `mmap`. By default it uses\n-    /// `MAP_PRIVATE` and, if not using `MapFd`, `MAP_ANON`. This will override both of those. This\n-    /// is platform-specific (the exact values used) and ignored on Windows.\n+    /// On POSIX, this can be used to specify the default flags passed to\n+    /// `mmap`. By default it uses `MAP_PRIVATE` and, if not using `MapFd`,\n+    /// `MAP_ANON`. This will override both of those. This is platform-specific\n+    /// (the exact values used) and ignored on Windows.\n     MapNonStandardFlags(c_int),\n }\n \n /// Possible errors when creating a map.\n pub enum MapError {\n     /// ## The following are POSIX-specific\n     ///\n-    /// fd was not open for reading or, if using `MapWritable`, was not open for writing.\n+    /// fd was not open for reading or, if using `MapWritable`, was not open for\n+    /// writing.\n     ErrFdNotAvail,\n     /// fd was not valid\n     ErrInvalidFd,\n-    /// Either the address given by `MapAddr` or offset given by `MapOffset` was not a multiple of\n-    /// `MemoryMap::granularity` (unaligned to page size).\n+    /// Either the address given by `MapAddr` or offset given by `MapOffset` was\n+    /// not a multiple of `MemoryMap::granularity` (unaligned to page size).\n     ErrUnaligned,\n     /// With `MapFd`, the fd does not support mapping.\n     ErrNoMapSupport,\n-    /// If using `MapAddr`, the address + `min_len` was outside of the process's address space. If\n-    /// using `MapFd`, the target of the fd didn't have enough resources to fulfill the request.\n+    /// If using `MapAddr`, the address + `min_len` was outside of the process's\n+    /// address space. If using `MapFd`, the target of the fd didn't have enough\n+    /// resources to fulfill the request.\n     ErrNoMem,\n     /// A zero-length map was requested. This is invalid according to\n-    /// [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html). Not all\n-    /// platforms obey this, but this wrapper does.\n+    /// [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html).\n+    /// Not all platforms obey this, but this wrapper does.\n     ErrZeroLength,\n     /// Unrecognized error. The inner value is the unrecognized errno.\n     ErrUnknown(int),\n     /// ## The following are win32-specific\n     ///\n-    /// Unsupported combination of protection flags (`MapReadable`/`MapWritable`/`MapExecutable`).\n+    /// Unsupported combination of protection flags\n+    /// (`MapReadable`/`MapWritable`/`MapExecutable`).\n     ErrUnsupProt,\n-    /// When using `MapFd`, `MapOffset` was given (Windows does not support this at all)\n+    /// When using `MapFd`, `MapOffset` was given (Windows does not support this\n+    /// at all)\n     ErrUnsupOffset,\n     /// When using `MapFd`, there was already a mapping to the file.\n     ErrAlreadyExists,\n-    /// Unrecognized error from `VirtualAlloc`. The inner value is the return value of GetLastError.\n+    /// Unrecognized error from `VirtualAlloc`. The inner value is the return\n+    /// value of GetLastError.\n     ErrVirtualAlloc(uint),\n-    /// Unrecognized error from `CreateFileMapping`. The inner value is the return value of\n-    /// `GetLastError`.\n+    /// Unrecognized error from `CreateFileMapping`. The inner value is the\n+    /// return value of `GetLastError`.\n     ErrCreateFileMappingW(uint),\n-    /// Unrecognized error from `MapViewOfFile`. The inner value is the return value of\n-    /// `GetLastError`.\n+    /// Unrecognized error from `MapViewOfFile`. The inner value is the return\n+    /// value of `GetLastError`.\n     ErrMapViewOfFile(uint)\n }\n \n@@ -920,15 +933,24 @@ impl fmt::Default for MapError {\n         let str = match *val {\n             ErrFdNotAvail => \"fd not available for reading or writing\",\n             ErrInvalidFd => \"Invalid fd\",\n-            ErrUnaligned => \"Unaligned address, invalid flags, negative length or unaligned offset\",\n+            ErrUnaligned => {\n+                \"Unaligned address, invalid flags, negative length or \\\n+                 unaligned offset\"\n+            }\n             ErrNoMapSupport=> \"File doesn't support mapping\",\n             ErrNoMem => \"Invalid address, or not enough available memory\",\n             ErrUnsupProt => \"Protection mode unsupported\",\n             ErrUnsupOffset => \"Offset in virtual memory mode is unsupported\",\n             ErrAlreadyExists => \"File mapping for specified file already exists\",\n             ErrZeroLength => \"Zero-length mapping not allowed\",\n-            ErrUnknown(code) => { write!(out.buf, \"Unknown error = {}\", code); return },\n-            ErrVirtualAlloc(code) => { write!(out.buf, \"VirtualAlloc failure = {}\", code); return },\n+            ErrUnknown(code) => {\n+                write!(out.buf, \"Unknown error = {}\", code);\n+                return\n+            },\n+            ErrVirtualAlloc(code) => {\n+                write!(out.buf, \"VirtualAlloc failure = {}\", code);\n+                return\n+            },\n             ErrCreateFileMappingW(code) => {\n                 format!(\"CreateFileMappingW failure = {}\", code);\n                 return\n@@ -944,8 +966,9 @@ impl fmt::Default for MapError {\n \n #[cfg(unix)]\n impl MemoryMap {\n-    /// Create a new mapping with the given `options`, at least `min_len` bytes long. `min_len`\n-    /// must be greater than zero; see the note on `ErrZeroLength`.\n+    /// Create a new mapping with the given `options`, at least `min_len` bytes\n+    /// long. `min_len` must be greater than zero; see the note on\n+    /// `ErrZeroLength`.\n     pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n         use libc::off_t;\n \n@@ -980,7 +1003,8 @@ impl MemoryMap {\n         if fd == -1 && !custom_flags { flags |= libc::MAP_ANON; }\n \n         let r = unsafe {\n-            libc::mmap(addr as *c_void, len as size_t, prot, flags, fd, offset)\n+            libc::mmap(addr as *c_void, len as libc::size_t, prot, flags, fd,\n+                       offset)\n         };\n         if r.equiv(&libc::MAP_FAILED) {\n             Err(match errno() as c_int {\n@@ -1004,7 +1028,8 @@ impl MemoryMap {\n         }\n     }\n \n-    /// Granularity that the offset or address must be for `MapOffset` and `MapAddr` respectively.\n+    /// Granularity that the offset or address must be for `MapOffset` and\n+    /// `MapAddr` respectively.\n     pub fn granularity() -> uint {\n         page_size()\n     }\n@@ -1051,8 +1076,10 @@ impl MemoryMap {\n                 MapAddr(addr_) => { lpAddress = addr_ as LPVOID; },\n                 MapFd(fd_) => { fd = fd_; },\n                 MapOffset(offset_) => { offset = offset_; },\n-                MapNonStandardFlags(f) => info!(\"MemoryMap::new: MapNonStandardFlags used on \\\n-                                                Windows: {}\", f),\n+                MapNonStandardFlags(f) => {\n+                    info!(\"MemoryMap::new: MapNonStandardFlags used on \\\n+                           Windows: {}\", f)\n+                }\n             }\n         }\n \n@@ -1138,17 +1165,18 @@ impl MemoryMap {\n \n #[cfg(windows)]\n impl Drop for MemoryMap {\n-    /// Unmap the mapping. Fails the task if any of `VirtualFree`, `UnmapViewOfFile`, or\n-    /// `CloseHandle` fail.\n+    /// Unmap the mapping. Fails the task if any of `VirtualFree`,\n+    /// `UnmapViewOfFile`, or `CloseHandle` fail.\n     fn drop(&mut self) {\n         use libc::types::os::arch::extra::{LPCVOID, HANDLE};\n         use libc::consts::os::extra::FALSE;\n+        if self.len == 0 { return }\n \n         unsafe {\n             match self.kind {\n                 MapVirtual => {\n                     if libc::VirtualFree(self.data as *mut c_void, 0,\n-                                         libc::MEM_RELEASE) == FALSE {\n+                                         libc::MEM_RELEASE) == 0 {\n                         error!(\"VirtualFree failed: {}\", errno());\n                     }\n                 },"}]}