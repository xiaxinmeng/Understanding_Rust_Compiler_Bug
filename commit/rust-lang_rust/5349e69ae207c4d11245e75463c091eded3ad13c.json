{"sha": "5349e69ae207c4d11245e75463c091eded3ad13c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNDllNjlhZTIwN2M0ZDExMjQ1ZTc1NDYzYzA5MWVkZWQzYWQxM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-21T04:21:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-21T04:21:25Z"}, "message": "Auto merge of #64047 - timvermeulen:cmp_min_max_by, r=cuviper\n\nAdd `cmp::{min_by, min_by_key, max_by, max_by_key}`\n\nThis adds the following functions to `core::cmp`:\n\n- `min_by`\n- `min_by_key`\n- `max_by`\n- `max_by_key`\n\n`min_by` and `max_by` are somewhat trivial to implement, but not entirely because `min_by` returns the first value in case the two are equal (and `max_by` the second). `min` and `max` can be implemented in terms of `min_by` and `max_by`, but not as easily the other way around.\n\nTo give an example of why I think these functions could be useful: the `Iterator::{min_by, min_by_key, max_by, max_by_key}` methods all currently hard-code the behavior mentioned above which is an ever so small duplication of logic. If we delegate them to `cmp::{min_by, max_by}` methods instead, we get the correct behavior for free. (edit: this is now included in the PR)\n\nI added `min_by_key` / `max_by_key` for consistency's sake but I wouldn't mind removing them. I don't have a particular use case in mind for them, and `min_by` / `max_by` seem to be more useful.\n\nTracking issue: #64460", "tree": {"sha": "edad552f0cdb10530194e80fc9010dac0dbda2b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edad552f0cdb10530194e80fc9010dac0dbda2b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5349e69ae207c4d11245e75463c091eded3ad13c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5349e69ae207c4d11245e75463c091eded3ad13c", "html_url": "https://github.com/rust-lang/rust/commit/5349e69ae207c4d11245e75463c091eded3ad13c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5349e69ae207c4d11245e75463c091eded3ad13c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "url": "https://api.github.com/repos/rust-lang/rust/commits/97e58c0d32bcb8730f8246d25f3d2fa8092b450a", "html_url": "https://github.com/rust-lang/rust/commit/97e58c0d32bcb8730f8246d25f3d2fa8092b450a"}, {"sha": "72175915d6ae5abbc45cf2860a90508d2b4a38ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/72175915d6ae5abbc45cf2860a90508d2b4a38ea", "html_url": "https://github.com/rust-lang/rust/commit/72175915d6ae5abbc45cf2860a90508d2b4a38ea"}], "stats": {"total": 163, "additions": 129, "deletions": 34}, "files": [{"sha": "4e2b1627e15ef17d9d24161dfcf8b5cc121392af", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 88, "deletions": 2, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5349e69ae207c4d11245e75463c091eded3ad13c/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5349e69ae207c4d11245e75463c091eded3ad13c/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=5349e69ae207c4d11245e75463c091eded3ad13c", "patch": "@@ -570,7 +570,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     #[inline]\n     fn max(self, other: Self) -> Self\n     where Self: Sized {\n-        if other >= self { other } else { self }\n+        max_by(self, other, Ord::cmp)\n     }\n \n     /// Compares and returns the minimum of two values.\n@@ -587,7 +587,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     #[inline]\n     fn min(self, other: Self) -> Self\n     where Self: Sized {\n-        if self <= other { self } else { other }\n+        min_by(self, other, Ord::cmp)\n     }\n \n     /// Restrict a value to a certain interval.\n@@ -898,6 +898,49 @@ pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     v1.min(v2)\n }\n \n+/// Returns the minimum of two values with respect to the specified comparison function.\n+///\n+/// Returns the first argument if the comparison determines them to be equal.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(cmp_min_max_by)]\n+///\n+/// use std::cmp;\n+///\n+/// assert_eq!(cmp::min_by(-2, 1, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), 1);\n+/// assert_eq!(cmp::min_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), -2);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n+pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n+    match compare(&v1, &v2) {\n+        Ordering::Less | Ordering::Equal => v1,\n+        Ordering::Greater => v2,\n+    }\n+}\n+\n+/// Returns the element that gives the minimum value from the specified function.\n+///\n+/// Returns the first argument if the comparison determines them to be equal.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(cmp_min_max_by)]\n+///\n+/// use std::cmp;\n+///\n+/// assert_eq!(cmp::min_by_key(-2, 1, |x: &i32| x.abs()), 1);\n+/// assert_eq!(cmp::min_by_key(-2, 2, |x: &i32| x.abs()), -2);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n+pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n+    min_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n+}\n+\n /// Compares and returns the maximum of two values.\n ///\n /// Returns the second argument if the comparison determines them to be equal.\n@@ -918,6 +961,49 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     v1.max(v2)\n }\n \n+/// Returns the maximum of two values with respect to the specified comparison function.\n+///\n+/// Returns the second argument if the comparison determines them to be equal.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(cmp_min_max_by)]\n+///\n+/// use std::cmp;\n+///\n+/// assert_eq!(cmp::max_by(-2, 1, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), -2);\n+/// assert_eq!(cmp::max_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), 2);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n+pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n+    match compare(&v1, &v2) {\n+        Ordering::Less | Ordering::Equal => v2,\n+        Ordering::Greater => v1,\n+    }\n+}\n+\n+/// Returns the element that gives the maximum value from the specified function.\n+///\n+/// Returns the second argument if the comparison determines them to be equal.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(cmp_min_max_by)]\n+///\n+/// use std::cmp;\n+///\n+/// assert_eq!(cmp::max_by_key(-2, 1, |x: &i32| x.abs()), -2);\n+/// assert_eq!(cmp::max_by_key(-2, 2, |x: &i32| x.abs()), 2);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n+pub fn max_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n+    max_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n+}\n+\n // Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types\n mod impls {\n     use crate::cmp::Ordering::{self, Less, Greater, Equal};"}, {"sha": "da49223dfb28510cf950f644540b0ecc56625322", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5349e69ae207c4d11245e75463c091eded3ad13c/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5349e69ae207c4d11245e75463c091eded3ad13c/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=5349e69ae207c4d11245e75463c091eded3ad13c", "patch": "@@ -1,4 +1,4 @@\n-use crate::cmp::Ordering;\n+use crate::cmp::{self, Ordering};\n use crate::ops::{Add, Try};\n \n use super::super::LoopState;\n@@ -2223,13 +2223,12 @@ pub trait Iterator {\n             move |x| (f(&x), x)\n         }\n \n-        // switch to y even if it is only equal, to preserve stability.\n         #[inline]\n-        fn select<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> bool {\n-            x_p <= y_p\n+        fn compare<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> Ordering {\n+            x_p.cmp(y_p)\n         }\n \n-        let (_, x) = select_fold1(self.map(key(f)), select)?;\n+        let (_, x) = self.map(key(f)).max_by(compare)?;\n         Some(x)\n     }\n \n@@ -2252,13 +2251,12 @@ pub trait Iterator {\n     fn max_by<F>(self, compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n-        // switch to y even if it is only equal, to preserve stability.\n         #[inline]\n-        fn select<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(&T, &T) -> bool {\n-            move |x, y| compare(x, y) != Ordering::Greater\n+        fn fold<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(T, T) -> T {\n+            move |x, y| cmp::max_by(x, y, &mut compare)\n         }\n \n-        select_fold1(self, select(compare))\n+        fold1(self, fold(compare))\n     }\n \n     /// Returns the element that gives the minimum value from the\n@@ -2285,13 +2283,12 @@ pub trait Iterator {\n             move |x| (f(&x), x)\n         }\n \n-        // only switch to y if it is strictly smaller, to preserve stability.\n         #[inline]\n-        fn select<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> bool {\n-            x_p > y_p\n+        fn compare<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> Ordering {\n+            x_p.cmp(y_p)\n         }\n \n-        let (_, x) = select_fold1(self.map(key(f)), select)?;\n+        let (_, x) = self.map(key(f)).min_by(compare)?;\n         Some(x)\n     }\n \n@@ -2314,13 +2311,12 @@ pub trait Iterator {\n     fn min_by<F>(self, compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n-        // only switch to y if it is strictly smaller, to preserve stability.\n         #[inline]\n-        fn select<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(&T, &T) -> bool {\n-            move |x, y| compare(x, y) == Ordering::Greater\n+        fn fold<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(T, T) -> T {\n+            move |x, y| cmp::min_by(x, y, &mut compare)\n         }\n \n-        select_fold1(self, select(compare))\n+        fold1(self, fold(compare))\n     }\n \n \n@@ -2958,28 +2954,18 @@ pub trait Iterator {\n     }\n }\n \n-/// Select an element from an iterator based on the given \"comparison\"\n-/// function.\n-///\n-/// This is an idiosyncratic helper to try to factor out the\n-/// commonalities of {max,min}{,_by}. In particular, this avoids\n-/// having to implement optimizations several times.\n+/// Fold an iterator without having to provide an initial value.\n #[inline]\n-fn select_fold1<I, F>(mut it: I, f: F) -> Option<I::Item>\n+fn fold1<I, F>(mut it: I, f: F) -> Option<I::Item>\n     where\n         I: Iterator,\n-        F: FnMut(&I::Item, &I::Item) -> bool,\n+        F: FnMut(I::Item, I::Item) -> I::Item,\n {\n-    #[inline]\n-    fn select<T>(mut f: impl FnMut(&T, &T) -> bool) -> impl FnMut(T, T) -> T {\n-        move |sel, x| if f(&sel, &x) { x } else { sel }\n-    }\n-\n     // start with the first element as our selection. This avoids\n     // having to use `Option`s inside the loop, translating to a\n     // sizeable performance gain (6x in one case).\n     let first = it.next()?;\n-    Some(it.fold(first, select(f)))\n+    Some(it.fold(first, f))\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "5e6778e222a291a3f17843aaede8c12e23902fa6", "filename": "src/libcore/tests/cmp.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5349e69ae207c4d11245e75463c091eded3ad13c/src%2Flibcore%2Ftests%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5349e69ae207c4d11245e75463c091eded3ad13c/src%2Flibcore%2Ftests%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcmp.rs?ref=5349e69ae207c4d11245e75463c091eded3ad13c", "patch": "@@ -1,4 +1,4 @@\n-use core::cmp::Ordering::{Less, Greater, Equal};\n+use core::cmp::{self, Ordering::*};\n \n #[test]\n fn test_int_totalord() {\n@@ -28,6 +28,28 @@ fn test_ord_max_min() {\n     assert_eq!(1.min(1), 1);\n }\n \n+#[test]\n+fn test_ord_min_max_by() {\n+    let f = |x: &i32, y: &i32| x.abs().cmp(&y.abs());\n+    assert_eq!(cmp::min_by(1, -1, f), 1);\n+    assert_eq!(cmp::min_by(1, -2, f), 1);\n+    assert_eq!(cmp::min_by(2, -1, f), -1);\n+    assert_eq!(cmp::max_by(1, -1, f), -1);\n+    assert_eq!(cmp::max_by(1, -2, f), -2);\n+    assert_eq!(cmp::max_by(2, -1, f), 2);\n+}\n+\n+#[test]\n+fn test_ord_min_max_by_key() {\n+    let f = |x: &i32| x.abs();\n+    assert_eq!(cmp::min_by_key(1, -1, f), 1);\n+    assert_eq!(cmp::min_by_key(1, -2, f), 1);\n+    assert_eq!(cmp::min_by_key(2, -1, f), -1);\n+    assert_eq!(cmp::max_by_key(1, -1, f), -1);\n+    assert_eq!(cmp::max_by_key(1, -2, f), -2);\n+    assert_eq!(cmp::max_by_key(2, -1, f), 2);\n+}\n+\n #[test]\n fn test_ordering_reverse() {\n     assert_eq!(Less.reverse(), Greater);"}, {"sha": "35661356028cbf2b861c0cdeac28dd2253e5ffdd", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5349e69ae207c4d11245e75463c091eded3ad13c/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5349e69ae207c4d11245e75463c091eded3ad13c/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=5349e69ae207c4d11245e75463c091eded3ad13c", "patch": "@@ -34,6 +34,7 @@\n #![feature(iter_partition_in_place)]\n #![feature(iter_is_partitioned)]\n #![feature(iter_order_by)]\n+#![feature(cmp_min_max_by)]\n \n extern crate test;\n "}]}