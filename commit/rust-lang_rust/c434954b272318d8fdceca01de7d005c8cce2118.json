{"sha": "c434954b272318d8fdceca01de7d005c8cce2118", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MzQ5NTRiMjcyMzE4ZDhmZGNlY2EwMWRlN2QwMDVjOGNjZTIxMTg=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-09T17:17:24Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-14T01:04:40Z"}, "message": "libsyntax: use tuple indexing", "tree": {"sha": "f74cad07a2383cc29fab6429c7826b48c5658f4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f74cad07a2383cc29fab6429c7826b48c5658f4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c434954b272318d8fdceca01de7d005c8cce2118", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c434954b272318d8fdceca01de7d005c8cce2118", "html_url": "https://github.com/rust-lang/rust/commit/c434954b272318d8fdceca01de7d005c8cce2118", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c434954b272318d8fdceca01de7d005c8cce2118/comments", "author": null, "committer": null, "parents": [{"sha": "4fd6a99851509cffbeeb7e4275dc35702e632c33", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fd6a99851509cffbeeb7e4275dc35702e632c33", "html_url": "https://github.com/rust-lang/rust/commit/4fd6a99851509cffbeeb7e4275dc35702e632c33"}], "stats": {"total": 20, "additions": 10, "deletions": 10}, "files": [{"sha": "310d5662afa20aab56f1d237e07ee2e93b7be2b9", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c434954b272318d8fdceca01de7d005c8cce2118/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c434954b272318d8fdceca01de7d005c8cce2118/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c434954b272318d8fdceca01de7d005c8cce2118", "patch": "@@ -431,7 +431,7 @@ pub fn str_lit(lit: &str) -> String {\n     /// Eat everything up to a non-whitespace\n     fn eat<'a>(it: &mut iter::Peekable<(uint, char), str::CharOffsets<'a>>) {\n         loop {\n-            match it.peek().map(|x| x.val1()) {\n+            match it.peek().map(|x| x.1) {\n                 Some(' ') | Some('\\n') | Some('\\r') | Some('\\t') => {\n                     it.next();\n                 },\n@@ -448,15 +448,15 @@ pub fn str_lit(lit: &str) -> String {\n                     '\\\\' => {\n                         let ch = chars.peek().unwrap_or_else(|| {\n                             panic!(\"{}\", error(i).as_slice())\n-                        }).val1();\n+                        }).1;\n \n                         if ch == '\\n' {\n                             eat(&mut chars);\n                         } else if ch == '\\r' {\n                             chars.next();\n                             let ch = chars.peek().unwrap_or_else(|| {\n                                 panic!(\"{}\", error(i).as_slice())\n-                            }).val1();\n+                            }).1;\n \n                             if ch != '\\n' {\n                                 panic!(\"lexer accepted bare CR\");\n@@ -474,7 +474,7 @@ pub fn str_lit(lit: &str) -> String {\n                     '\\r' => {\n                         let ch = chars.peek().unwrap_or_else(|| {\n                             panic!(\"{}\", error(i).as_slice())\n-                        }).val1();\n+                        }).1;\n \n                         if ch != '\\n' {\n                             panic!(\"lexer accepted bare CR\");\n@@ -600,7 +600,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n     /// Eat everything up to a non-whitespace\n     fn eat<'a, I: Iterator<(uint, u8)>>(it: &mut iter::Peekable<(uint, u8), I>) {\n         loop {\n-            match it.peek().map(|x| x.val1()) {\n+            match it.peek().map(|x| x.1) {\n                 Some(b' ') | Some(b'\\n') | Some(b'\\r') | Some(b'\\t') => {\n                     it.next();\n                 },\n@@ -615,11 +615,11 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n         match chars.next() {\n             Some((i, b'\\\\')) => {\n                 let em = error(i);\n-                match chars.peek().expect(em.as_slice()).val1() {\n+                match chars.peek().expect(em.as_slice()).1 {\n                     b'\\n' => eat(&mut chars),\n                     b'\\r' => {\n                         chars.next();\n-                        if chars.peek().expect(em.as_slice()).val1() != b'\\n' {\n+                        if chars.peek().expect(em.as_slice()).1 != b'\\n' {\n                             panic!(\"lexer accepted bare CR\");\n                         }\n                         eat(&mut chars);\n@@ -637,7 +637,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n             },\n             Some((i, b'\\r')) => {\n                 let em = error(i);\n-                if chars.peek().expect(em.as_slice()).val1() != b'\\n' {\n+                if chars.peek().expect(em.as_slice()).1 != b'\\n' {\n                     panic!(\"lexer accepted bare CR\");\n                 }\n                 chars.next();"}, {"sha": "e9cc91d94151a2f231a252ea3c856dbdba1b1b02", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c434954b272318d8fdceca01de7d005c8cce2118/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c434954b272318d8fdceca01de7d005c8cce2118/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c434954b272318d8fdceca01de7d005c8cce2118", "patch": "@@ -1740,8 +1740,8 @@ impl<'a> Parser<'a> {\n             }\n             token::Literal(lit, suf) => {\n                 let (suffix_illegal, out) = match lit {\n-                    token::Byte(i) => (true, LitByte(parse::byte_lit(i.as_str()).val0())),\n-                    token::Char(i) => (true, LitChar(parse::char_lit(i.as_str()).val0())),\n+                    token::Byte(i) => (true, LitByte(parse::byte_lit(i.as_str()).0)),\n+                    token::Char(i) => (true, LitChar(parse::char_lit(i.as_str()).0)),\n \n                     // there are some valid suffixes for integer and\n                     // float literals, so all the handling is done"}]}