{"sha": "14b15521c52549ebbb113173b4abecd124b5a823", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0YjE1NTIxYzUyNTQ5ZWJiYjExMzE3M2I0YWJlY2QxMjRiNWE4MjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-23T18:36:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-23T18:36:59Z"}, "message": "Auto merge of #71483 - Dylan-DPC:rollup-c2h9s8b, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #70633 (Confusing suggestion on incorrect closing `}`)\n - #71404 (Don't fuse Chain in its second iterator)\n - #71408 (Check code blocks tags)\n - #71442 (Add a \"by reference\" adaptor for `AllocRef`)\n - #71446 (Only use read_unaligned in transmute_copy if necessary)\n - #71470 (Fix doc links)\n - #71479 (add back Scalar::null_ptr)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "5e5d52670664d8541e938acf9b390aad4c8a341e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e5d52670664d8541e938acf9b390aad4c8a341e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14b15521c52549ebbb113173b4abecd124b5a823", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14b15521c52549ebbb113173b4abecd124b5a823", "html_url": "https://github.com/rust-lang/rust/commit/14b15521c52549ebbb113173b4abecd124b5a823", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14b15521c52549ebbb113173b4abecd124b5a823/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "413a12909f3b149af17d75268ed4a136afb82c36", "url": "https://api.github.com/repos/rust-lang/rust/commits/413a12909f3b149af17d75268ed4a136afb82c36", "html_url": "https://github.com/rust-lang/rust/commit/413a12909f3b149af17d75268ed4a136afb82c36"}, {"sha": "b107eb5ea4bdf1bc3f6ce7637a9d1980f8045117", "url": "https://api.github.com/repos/rust-lang/rust/commits/b107eb5ea4bdf1bc3f6ce7637a9d1980f8045117", "html_url": "https://github.com/rust-lang/rust/commit/b107eb5ea4bdf1bc3f6ce7637a9d1980f8045117"}], "stats": {"total": 1012, "additions": 939, "deletions": 73}, "files": [{"sha": "2f50234b6d58243ad75d6f089ae003bf09fdbfe3", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -73,7 +73,7 @@ pub struct VecDeque<T> {\n /// It produces the following sequence of matching slices:\n ///\n /// ([0 1], [a b])\n-/// ([2], [c])\n+/// (\\[2\\], \\[c\\])\n /// ([3 4], [d e])\n ///\n /// and the uneven remainder of either A or B is skipped."}, {"sha": "fb9f5faa018a4c7c91deca64610fe67f45c3626f", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -1024,7 +1024,7 @@ unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n }\n \n impl<T> Rc<[T]> {\n-    /// Copy elements from slice into newly allocated Rc<[T]>\n+    /// Copy elements from slice into newly allocated Rc<\\[T\\]>\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`\n     unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {"}, {"sha": "cde412bee78d9ab2d7d01d94fa6b50bd472dcc8a", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -902,7 +902,7 @@ unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n }\n \n impl<T> Arc<[T]> {\n-    /// Copy elements from slice into newly allocated Arc<[T]>\n+    /// Copy elements from slice into newly allocated Arc<\\[T\\]>\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`.\n     unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {"}, {"sha": "1346fbd4810038caf3064f5dd19f9dfcc90aebe2", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -364,4 +364,51 @@ pub unsafe trait AllocRef {\n             }\n         }\n     }\n+\n+    /// Creates a \"by reference\" adaptor for this instance of `AllocRef`.\n+    ///\n+    /// The returned adaptor also implements `AllocRef` and will simply borrow this.\n+    #[inline(always)]\n+    fn by_ref(&mut self) -> &mut Self {\n+        self\n+    }\n+}\n+\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+unsafe impl<A> AllocRef for &mut A\n+where\n+    A: AllocRef + ?Sized,\n+{\n+    #[inline]\n+    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n+        (**self).alloc(layout, init)\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+        (**self).dealloc(ptr, layout)\n+    }\n+\n+    #[inline]\n+    unsafe fn grow(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+        placement: ReallocPlacement,\n+        init: AllocInit,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        (**self).grow(ptr, layout, new_size, placement, init)\n+    }\n+\n+    #[inline]\n+    unsafe fn shrink(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+        placement: ReallocPlacement,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        (**self).shrink(ptr, layout, new_size, placement)\n+    }\n }"}, {"sha": "7bc2866dc2e6756eda3eaf9c2c18f2d8c41c32a1", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -282,7 +282,7 @@ impl<'a, 'f: 'a> DerefMut for VaList<'a, 'f> {\n mod sealed_trait {\n     /// Trait which whitelists the allowed types to be used with [VaList::arg]\n     ///\n-    /// [VaList::va_arg]: struct.VaList.html#method.arg\n+    /// [VaList::arg]: ../struct.VaList.html#method.arg\n     #[unstable(\n         feature = \"c_variadic\",\n         reason = \"the `c_variadic` feature has not been properly tested on \\"}, {"sha": "6700ef017bde43922f51411083d3f99d4b9ce134", "filename": "src/libcore/iter/adapters/chain.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -18,6 +18,9 @@ pub struct Chain<A, B> {\n     // adapter because its specialization for `FusedIterator` unconditionally descends into the\n     // iterator, and that could be expensive to keep revisiting stuff like nested chains. It also\n     // hurts compiler performance to add more iterator layers to `Chain`.\n+    //\n+    // Only the \"first\" iterator is actually set `None` when exhausted, depending on whether you\n+    // iterate forward or backward. If you mix directions, then both sides may be `None`.\n     a: Option<A>,\n     b: Option<B>,\n }\n@@ -43,6 +46,17 @@ macro_rules! fuse {\n     };\n }\n \n+/// Try an iterator method without fusing,\n+/// like an inline `.as_mut().and_then(...)`\n+macro_rules! maybe {\n+    ($self:ident . $iter:ident . $($call:tt)+) => {\n+        match $self.$iter {\n+            Some(ref mut iter) => iter.$($call)+,\n+            None => None,\n+        }\n+    };\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> Iterator for Chain<A, B>\n where\n@@ -54,7 +68,7 @@ where\n     #[inline]\n     fn next(&mut self) -> Option<A::Item> {\n         match fuse!(self.a.next()) {\n-            None => fuse!(self.b.next()),\n+            None => maybe!(self.b.next()),\n             item => item,\n         }\n     }\n@@ -85,7 +99,7 @@ where\n         }\n         if let Some(ref mut b) = self.b {\n             acc = b.try_fold(acc, f)?;\n-            self.b = None;\n+            // we don't fuse the second iterator\n         }\n         Try::from_ok(acc)\n     }\n@@ -114,7 +128,7 @@ where\n             }\n             self.a = None;\n         }\n-        fuse!(self.b.nth(n))\n+        maybe!(self.b.nth(n))\n     }\n \n     #[inline]\n@@ -123,7 +137,7 @@ where\n         P: FnMut(&Self::Item) -> bool,\n     {\n         match fuse!(self.a.find(&mut predicate)) {\n-            None => fuse!(self.b.find(predicate)),\n+            None => maybe!(self.b.find(predicate)),\n             item => item,\n         }\n     }\n@@ -174,7 +188,7 @@ where\n     #[inline]\n     fn next_back(&mut self) -> Option<A::Item> {\n         match fuse!(self.b.next_back()) {\n-            None => fuse!(self.a.next_back()),\n+            None => maybe!(self.a.next_back()),\n             item => item,\n         }\n     }\n@@ -190,7 +204,7 @@ where\n             }\n             self.b = None;\n         }\n-        fuse!(self.a.nth_back(n))\n+        maybe!(self.a.nth_back(n))\n     }\n \n     #[inline]\n@@ -199,7 +213,7 @@ where\n         P: FnMut(&Self::Item) -> bool,\n     {\n         match fuse!(self.b.rfind(&mut predicate)) {\n-            None => fuse!(self.a.rfind(predicate)),\n+            None => maybe!(self.a.rfind(predicate)),\n             item => item,\n         }\n     }\n@@ -216,7 +230,7 @@ where\n         }\n         if let Some(ref mut a) = self.a {\n             acc = a.try_rfold(acc, f)?;\n-            self.a = None;\n+            // we don't fuse the second iterator\n         }\n         Try::from_ok(acc)\n     }\n@@ -236,8 +250,6 @@ where\n }\n \n // Note: *both* must be fused to handle double-ended iterators.\n-// Now that we \"fuse\" both sides, we *could* implement this unconditionally,\n-// but we should be cautious about committing to that in the public API.\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A, B> FusedIterator for Chain<A, B>\n where"}, {"sha": "7fcfbf108144c1cb3302141b05a2d678aa22668c", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -924,7 +924,12 @@ pub fn drop<T>(_x: T) {}\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    ptr::read_unaligned(src as *const T as *const U)\n+    // If U has a higher alignment requirement, src may not be suitably aligned.\n+    if align_of::<U>() > align_of::<T>() {\n+        ptr::read_unaligned(src as *const T as *const U)\n+    } else {\n+        ptr::read(src as *const T as *const U)\n+    }\n }\n \n /// Opaque type representing the discriminant of an enum."}, {"sha": "7da02b11676abd32a36a0a601798160ad06591ee", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -207,50 +207,64 @@ fn test_iterator_chain_find() {\n     assert_eq!(iter.next(), None);\n }\n \n-#[test]\n-fn test_iterator_chain_size_hint() {\n-    struct Iter {\n-        is_empty: bool,\n-    }\n+struct Toggle {\n+    is_empty: bool,\n+}\n \n-    impl Iterator for Iter {\n-        type Item = ();\n+impl Iterator for Toggle {\n+    type Item = ();\n \n-        // alternates between `None` and `Some(())`\n-        fn next(&mut self) -> Option<Self::Item> {\n-            if self.is_empty {\n-                self.is_empty = false;\n-                None\n-            } else {\n-                self.is_empty = true;\n-                Some(())\n-            }\n+    // alternates between `None` and `Some(())`\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.is_empty {\n+            self.is_empty = false;\n+            None\n+        } else {\n+            self.is_empty = true;\n+            Some(())\n         }\n+    }\n \n-        fn size_hint(&self) -> (usize, Option<usize>) {\n-            if self.is_empty { (0, Some(0)) } else { (1, Some(1)) }\n-        }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.is_empty { (0, Some(0)) } else { (1, Some(1)) }\n     }\n+}\n \n-    impl DoubleEndedIterator for Iter {\n-        fn next_back(&mut self) -> Option<Self::Item> {\n-            self.next()\n-        }\n+impl DoubleEndedIterator for Toggle {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.next()\n     }\n+}\n \n+#[test]\n+fn test_iterator_chain_size_hint() {\n     // this chains an iterator of length 0 with an iterator of length 1,\n     // so after calling `.next()` once, the iterator is empty and the\n     // state is `ChainState::Back`. `.size_hint()` should now disregard\n     // the size hint of the left iterator\n-    let mut iter = Iter { is_empty: true }.chain(once(()));\n+    let mut iter = Toggle { is_empty: true }.chain(once(()));\n     assert_eq!(iter.next(), Some(()));\n     assert_eq!(iter.size_hint(), (0, Some(0)));\n \n-    let mut iter = once(()).chain(Iter { is_empty: true });\n+    let mut iter = once(()).chain(Toggle { is_empty: true });\n     assert_eq!(iter.next_back(), Some(()));\n     assert_eq!(iter.size_hint(), (0, Some(0)));\n }\n \n+#[test]\n+fn test_iterator_chain_unfused() {\n+    // Chain shouldn't be fused in its second iterator, depending on direction\n+    let mut iter = NonFused::new(empty()).chain(Toggle { is_empty: true });\n+    iter.next().unwrap_none();\n+    iter.next().unwrap();\n+    iter.next().unwrap_none();\n+\n+    let mut iter = Toggle { is_empty: true }.chain(NonFused::new(empty()));\n+    iter.next_back().unwrap_none();\n+    iter.next_back().unwrap();\n+    iter.next_back().unwrap_none();\n+}\n+\n #[test]\n fn test_zip_nth() {\n     let xs = [0, 1, 2, 4, 5];"}, {"sha": "e7d36d327cd89c14af2ddf628eff1aef612e366c", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -42,6 +42,7 @@\n #![feature(unwrap_infallible)]\n #![feature(leading_trailing_ones)]\n #![feature(const_forget)]\n+#![feature(option_unwrap_none)]\n \n extern crate test;\n "}, {"sha": "bcd59702289591e6288682e431a72d973eb7ebc0", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -61,7 +61,8 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::{\n     BARE_TRAIT_OBJECTS, ELIDED_LIFETIMES_IN_PATHS, EXPLICIT_OUTLIVES_REQUIREMENTS,\n-    INTRA_DOC_LINK_RESOLUTION_FAILURE, MISSING_DOC_CODE_EXAMPLES, PRIVATE_DOC_TESTS,\n+    INTRA_DOC_LINK_RESOLUTION_FAILURE, INVALID_CODEBLOCK_ATTRIBUTE, MISSING_DOC_CODE_EXAMPLES,\n+    PRIVATE_DOC_TESTS,\n };\n use rustc_span::Span;\n \n@@ -299,6 +300,7 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n     add_lint_group!(\n         \"rustdoc\",\n         INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+        INVALID_CODEBLOCK_ATTRIBUTE,\n         MISSING_DOC_CODE_EXAMPLES,\n         PRIVATE_DOC_TESTS\n     );"}, {"sha": "f3c1c87dad484b5aead0f759570aa4a332644ac2", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -188,6 +188,11 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n+    #[inline]\n+    pub fn null_ptr(cx: &impl HasDataLayout) -> Self {\n+        Scalar::Raw { data: 0, size: cx.data_layout().pointer_size.bytes() as u8 }\n+    }\n+\n     #[inline]\n     pub fn zst() -> Self {\n         Scalar::Raw { data: 0, size: 0 }"}, {"sha": "c08659ec9f6486ac53ec260b9d91575f0734eb2b", "filename": "src/librustc_parse/lexer/tokentrees.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustc_parse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustc_parse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Ftokentrees.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -1,6 +1,6 @@\n use super::{StringReader, UnmatchedBrace};\n \n-use rustc_ast::token::{self, Token};\n+use rustc_ast::token::{self, DelimToken, Token};\n use rustc_ast::tokenstream::{\n     DelimSpan,\n     IsJoint::{self, *},\n@@ -22,6 +22,7 @@ impl<'a> StringReader<'a> {\n             matching_delim_spans: Vec::new(),\n             last_unclosed_found_span: None,\n             last_delim_empty_block_spans: FxHashMap::default(),\n+            matching_block_spans: Vec::new(),\n         };\n         let res = tt_reader.parse_all_token_trees();\n         (res, tt_reader.unmatched_braces)\n@@ -42,6 +43,9 @@ struct TokenTreesReader<'a> {\n     last_unclosed_found_span: Option<Span>,\n     /// Collect empty block spans that might have been auto-inserted by editors.\n     last_delim_empty_block_spans: FxHashMap<token::DelimToken, Span>,\n+    /// Collect the spans of braces (Open, Close). Used only\n+    /// for detecting if blocks are empty and only braces.\n+    matching_block_spans: Vec<(Span, Span)>,\n }\n \n impl<'a> TokenTreesReader<'a> {\n@@ -77,6 +81,7 @@ impl<'a> TokenTreesReader<'a> {\n \n     fn parse_token_tree(&mut self) -> PResult<'a, TreeAndJoint> {\n         let sm = self.string_reader.sess.source_map();\n+\n         match self.token.kind {\n             token::Eof => {\n                 let msg = \"this file contains an unclosed delimiter\";\n@@ -146,6 +151,14 @@ impl<'a> TokenTreesReader<'a> {\n                             }\n                         }\n \n+                        match (open_brace, delim) {\n+                            //only add braces\n+                            (DelimToken::Brace, DelimToken::Brace) => {\n+                                self.matching_block_spans.push((open_brace_span, close_brace_span));\n+                            }\n+                            _ => {}\n+                        }\n+\n                         if self.open_braces.is_empty() {\n                             // Clear up these spans to avoid suggesting them as we've found\n                             // properly matched delimiters so far for an entire block.\n@@ -164,6 +177,7 @@ impl<'a> TokenTreesReader<'a> {\n                     token::CloseDelim(other) => {\n                         let mut unclosed_delimiter = None;\n                         let mut candidate = None;\n+\n                         if self.last_unclosed_found_span != Some(self.token.span) {\n                             // do not complain about the same unclosed delimiter multiple times\n                             self.last_unclosed_found_span = Some(self.token.span);\n@@ -224,12 +238,27 @@ impl<'a> TokenTreesReader<'a> {\n                 let mut err =\n                     self.string_reader.sess.span_diagnostic.struct_span_err(self.token.span, &msg);\n \n-                if let Some(span) = self.last_delim_empty_block_spans.remove(&delim) {\n-                    err.span_label(\n-                        span,\n-                        \"this block is empty, you might have not meant to close it\",\n-                    );\n+                // Braces are added at the end, so the last element is the biggest block\n+                if let Some(parent) = self.matching_block_spans.last() {\n+                    if let Some(span) = self.last_delim_empty_block_spans.remove(&delim) {\n+                        // Check if the (empty block) is in the last properly closed block\n+                        if (parent.0.to(parent.1)).contains(span) {\n+                            err.span_label(\n+                                span,\n+                                \"block is empty, you might have not meant to close it\",\n+                            );\n+                        } else {\n+                            err.span_label(parent.0, \"this opening brace...\");\n+\n+                            err.span_label(parent.1, \"...matches this closing brace\");\n+                        }\n+                    } else {\n+                        err.span_label(parent.0, \"this opening brace...\");\n+\n+                        err.span_label(parent.1, \"...matches this closing brace\");\n+                    }\n                 }\n+\n                 err.span_label(self.token.span, \"unexpected closing delimiter\");\n                 Err(err)\n             }"}, {"sha": "3ace9ecbd60e5af8adfde2d5d8b11778b881972c", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -386,6 +386,12 @@ declare_lint! {\n     \"failures in resolving intra-doc link targets\"\n }\n \n+declare_lint! {\n+    pub INVALID_CODEBLOCK_ATTRIBUTE,\n+    Warn,\n+    \"codeblock attribute looks a lot like a known one\"\n+}\n+\n declare_lint! {\n     pub MISSING_CRATE_LEVEL_DOCS,\n     Allow,\n@@ -553,6 +559,7 @@ declare_lint_pass! {\n         UNSTABLE_NAME_COLLISIONS,\n         IRREFUTABLE_LET_PATTERNS,\n         INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+        INVALID_CODEBLOCK_ATTRIBUTE,\n         MISSING_CRATE_LEVEL_DOCS,\n         MISSING_DOC_CODE_EXAMPLES,\n         PRIVATE_DOC_TESTS,"}, {"sha": "f83bb9b1162de9e4711826adbbddcfc8486df68e", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -253,6 +253,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     let missing_doc_example = rustc_lint::builtin::MISSING_DOC_CODE_EXAMPLES.name;\n     let private_doc_tests = rustc_lint::builtin::PRIVATE_DOC_TESTS.name;\n     let no_crate_level_docs = rustc_lint::builtin::MISSING_CRATE_LEVEL_DOCS.name;\n+    let invalid_codeblock_attribute_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTE.name;\n \n     // In addition to those specific lints, we also need to whitelist those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n@@ -263,6 +264,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         missing_doc_example.to_owned(),\n         private_doc_tests.to_owned(),\n         no_crate_level_docs.to_owned(),\n+        invalid_codeblock_attribute_name.to_owned(),\n     ];\n \n     whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n@@ -275,7 +277,10 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n     let lint_opts = lints()\n         .filter_map(|lint| {\n-            if lint.name == warnings_lint_name || lint.name == intra_link_resolution_failure_name {\n+            if lint.name == warnings_lint_name\n+                || lint.name == intra_link_resolution_failure_name\n+                || lint.name == invalid_codeblock_attribute_name\n+            {\n                 None\n             } else {\n                 Some((lint.name_lower(), lint::Allow))"}, {"sha": "862c20dd16a556790061ce2b345df22b20eed870", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 114, "deletions": 4, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -20,7 +20,12 @@\n #![allow(non_camel_case_types)]\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::HirId;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::lint;\n use rustc_span::edition::Edition;\n+use rustc_span::Span;\n use std::borrow::Cow;\n use std::cell::RefCell;\n use std::collections::VecDeque;\n@@ -192,7 +197,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n         if let Some(Event::Start(Tag::CodeBlock(kind))) = event {\n             let parse_result = match kind {\n                 CodeBlockKind::Fenced(ref lang) => {\n-                    LangString::parse(&lang, self.check_error_codes, false)\n+                    LangString::parse_without_check(&lang, self.check_error_codes, false)\n                 }\n                 CodeBlockKind::Indented => LangString::all_false(),\n             };\n@@ -560,6 +565,7 @@ pub fn find_testable_code<T: test::Tester>(\n     tests: &mut T,\n     error_codes: ErrorCodes,\n     enable_per_target_ignores: bool,\n+    extra_info: Option<&ExtraInfo<'_, '_>>,\n ) {\n     let mut parser = Parser::new(doc).into_offset_iter();\n     let mut prev_offset = 0;\n@@ -573,7 +579,12 @@ pub fn find_testable_code<T: test::Tester>(\n                         if lang.is_empty() {\n                             LangString::all_false()\n                         } else {\n-                            LangString::parse(lang, error_codes, enable_per_target_ignores)\n+                            LangString::parse(\n+                                lang,\n+                                error_codes,\n+                                enable_per_target_ignores,\n+                                extra_info,\n+                            )\n                         }\n                     }\n                     CodeBlockKind::Indented => LangString::all_false(),\n@@ -615,6 +626,49 @@ pub fn find_testable_code<T: test::Tester>(\n     }\n }\n \n+pub struct ExtraInfo<'a, 'b> {\n+    hir_id: Option<HirId>,\n+    item_did: Option<DefId>,\n+    sp: Span,\n+    tcx: &'a TyCtxt<'b>,\n+}\n+\n+impl<'a, 'b> ExtraInfo<'a, 'b> {\n+    pub fn new(tcx: &'a TyCtxt<'b>, hir_id: HirId, sp: Span) -> ExtraInfo<'a, 'b> {\n+        ExtraInfo { hir_id: Some(hir_id), item_did: None, sp, tcx }\n+    }\n+\n+    pub fn new_did(tcx: &'a TyCtxt<'b>, did: DefId, sp: Span) -> ExtraInfo<'a, 'b> {\n+        ExtraInfo { hir_id: None, item_did: Some(did), sp, tcx }\n+    }\n+\n+    fn error_invalid_codeblock_attr(&self, msg: &str, help: &str) {\n+        let hir_id = match (self.hir_id, self.item_did) {\n+            (Some(h), _) => h,\n+            (None, Some(item_did)) => {\n+                match self.tcx.hir().as_local_hir_id(item_did) {\n+                    Some(hir_id) => hir_id,\n+                    None => {\n+                        // If non-local, no need to check anything.\n+                        return;\n+                    }\n+                }\n+            }\n+            (None, None) => return,\n+        };\n+        self.tcx.struct_span_lint_hir(\n+            lint::builtin::INVALID_CODEBLOCK_ATTRIBUTE,\n+            hir_id,\n+            self.sp,\n+            |lint| {\n+                let mut diag = lint.build(msg);\n+                diag.help(help);\n+                diag.emit();\n+            },\n+        );\n+    }\n+}\n+\n #[derive(Eq, PartialEq, Clone, Debug)]\n pub struct LangString {\n     original: String,\n@@ -652,10 +706,19 @@ impl LangString {\n         }\n     }\n \n+    fn parse_without_check(\n+        string: &str,\n+        allow_error_code_check: ErrorCodes,\n+        enable_per_target_ignores: bool,\n+    ) -> LangString {\n+        Self::parse(string, allow_error_code_check, enable_per_target_ignores, None)\n+    }\n+\n     fn parse(\n         string: &str,\n         allow_error_code_check: ErrorCodes,\n         enable_per_target_ignores: bool,\n+        extra: Option<&ExtraInfo<'_, '_>>,\n     ) -> LangString {\n         let allow_error_code_check = allow_error_code_check.as_bool();\n         let mut seen_rust_tags = false;\n@@ -715,6 +778,53 @@ impl LangString {\n                         seen_other_tags = true;\n                     }\n                 }\n+                x if extra.is_some() => {\n+                    let s = x.to_lowercase();\n+                    match if s == \"compile-fail\" || s == \"compile_fail\" || s == \"compilefail\" {\n+                        Some((\n+                            \"compile_fail\",\n+                            \"the code block will either not be tested if not marked as a rust one \\\n+                             or won't fail if it compiles successfully\",\n+                        ))\n+                    } else if s == \"should-panic\" || s == \"should_panic\" || s == \"shouldpanic\" {\n+                        Some((\n+                            \"should_panic\",\n+                            \"the code block will either not be tested if not marked as a rust one \\\n+                             or won't fail if it doesn't panic when running\",\n+                        ))\n+                    } else if s == \"no-run\" || s == \"no_run\" || s == \"norun\" {\n+                        Some((\n+                            \"no_run\",\n+                            \"the code block will either not be tested if not marked as a rust one \\\n+                             or will be run (which you might not want)\",\n+                        ))\n+                    } else if s == \"allow-fail\" || s == \"allow_fail\" || s == \"allowfail\" {\n+                        Some((\n+                            \"allow_fail\",\n+                            \"the code block will either not be tested if not marked as a rust one \\\n+                             or will be run (which you might not want)\",\n+                        ))\n+                    } else if s == \"test-harness\" || s == \"test_harness\" || s == \"testharness\" {\n+                        Some((\n+                            \"test_harness\",\n+                            \"the code block will either not be tested if not marked as a rust one \\\n+                             or the code will be wrapped inside a main function\",\n+                        ))\n+                    } else {\n+                        None\n+                    } {\n+                        Some((flag, help)) => {\n+                            if let Some(ref extra) = extra {\n+                                extra.error_invalid_codeblock_attr(\n+                                    &format!(\"unknown attribute `{}`. Did you mean `{}`?\", x, flag),\n+                                    help,\n+                                );\n+                            }\n+                        }\n+                        None => {}\n+                    }\n+                    seen_other_tags = true;\n+                }\n                 _ => seen_other_tags = true,\n             }\n         }\n@@ -934,7 +1044,7 @@ crate struct RustCodeBlock {\n \n /// Returns a range of bytes for each code block in the markdown that is tagged as `rust` or\n /// untagged (and assumed to be rust).\n-crate fn rust_code_blocks(md: &str) -> Vec<RustCodeBlock> {\n+crate fn rust_code_blocks(md: &str, extra_info: &ExtraInfo<'_, '_>) -> Vec<RustCodeBlock> {\n     let mut code_blocks = vec![];\n \n     if md.is_empty() {\n@@ -951,7 +1061,7 @@ crate fn rust_code_blocks(md: &str) -> Vec<RustCodeBlock> {\n                     let lang_string = if syntax.is_empty() {\n                         LangString::all_false()\n                     } else {\n-                        LangString::parse(&*syntax, ErrorCodes::Yes, false)\n+                        LangString::parse(&*syntax, ErrorCodes::Yes, false, Some(extra_info))\n                     };\n                     if !lang_string.rust {\n                         continue;"}, {"sha": "c871587a0a919f5b141bf9440428a27841b5db2b", "filename": "src/librustdoc/html/markdown/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -64,7 +64,7 @@ fn test_lang_string_parse() {\n         edition: Option<Edition>,\n     ) {\n         assert_eq!(\n-            LangString::parse(s, ErrorCodes::Yes, true),\n+            LangString::parse(s, ErrorCodes::Yes, true, None),\n             LangString {\n                 should_panic,\n                 no_run,"}, {"sha": "b4c0f0ac4c5d94febbc8798e3a7e6b353c357ee0", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -153,7 +153,7 @@ pub fn test(mut options: Options, diag: &rustc_errors::Handler) -> i32 {\n     collector.set_position(DUMMY_SP);\n     let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n \n-    find_testable_code(&input_str, &mut collector, codes, options.enable_per_target_ignores);\n+    find_testable_code(&input_str, &mut collector, codes, options.enable_per_target_ignores, None);\n \n     options.test_args.insert(0, \"rustdoctest\".to_string());\n     testing::test_main("}, {"sha": "d1f2c12ccd630c6435cd32b733e8a81787cb728e", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -10,7 +10,7 @@ use crate::clean;\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::html::markdown::{self, RustCodeBlock};\n-use crate::passes::Pass;\n+use crate::passes::{span_of_attrs, Pass};\n \n pub const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n     name: \"check-code-block-syntax\",\n@@ -114,7 +114,9 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n impl<'a, 'tcx> DocFolder for SyntaxChecker<'a, 'tcx> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if let Some(dox) = &item.attrs.collapsed_doc_value() {\n-            for code_block in markdown::rust_code_blocks(&dox) {\n+            let sp = span_of_attrs(&item.attrs).unwrap_or(item.source.span());\n+            let extra = crate::html::markdown::ExtraInfo::new_did(&self.cx.tcx, item.def_id, sp);\n+            for code_block in markdown::rust_code_blocks(&dox, &extra) {\n                 self.check_rust_syntax(&item, &dox, code_block);\n             }\n         }"}, {"sha": "70366c90139c2825b5d3f1da04b61c47e68a73f8", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -338,7 +338,7 @@ pub fn look_for_tests<'tcx>(\n \n     let mut tests = Tests { found_tests: 0 };\n \n-    find_testable_code(&dox, &mut tests, ErrorCodes::No, false);\n+    find_testable_code(&dox, &mut tests, ErrorCodes::No, false, None);\n \n     if check_missing_code && tests.found_tests == 0 {\n         let sp = span_of_attrs(&item.attrs).unwrap_or(item.source.span());"}, {"sha": "e2940efd49c0d567260696f3e571cb646def9ebb", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 81, "deletions": 16, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -5,9 +5,11 @@ use rustc_errors::ErrorReported;\n use rustc_feature::UnstableFeatures;\n use rustc_hir as hir;\n use rustc_hir::intravisit;\n+use rustc_hir::{HirId, CRATE_HIR_ID};\n use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n-use rustc_session::{self, config, DiagnosticOutput, Session};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::{self, config, lint, DiagnosticOutput, Session};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::sym;\n@@ -25,6 +27,7 @@ use tempfile::Builder as TempFileBuilder;\n use crate::clean::Attributes;\n use crate::config::Options;\n use crate::html::markdown::{self, ErrorCodes, Ignore, LangString};\n+use crate::passes::span_of_attrs;\n \n #[derive(Clone, Default)]\n pub struct TestOptions {\n@@ -40,6 +43,45 @@ pub struct TestOptions {\n pub fn run(options: Options) -> i32 {\n     let input = config::Input::File(options.input.clone());\n \n+    let warnings_lint_name = lint::builtin::WARNINGS.name;\n+    let invalid_codeblock_attribute_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTE.name;\n+\n+    // In addition to those specific lints, we also need to whitelist those given through\n+    // command line, otherwise they'll get ignored and we don't want that.\n+    let mut whitelisted_lints =\n+        vec![warnings_lint_name.to_owned(), invalid_codeblock_attribute_name.to_owned()];\n+\n+    whitelisted_lints.extend(options.lint_opts.iter().map(|(lint, _)| lint).cloned());\n+\n+    let lints = || {\n+        lint::builtin::HardwiredLints::get_lints()\n+            .into_iter()\n+            .chain(rustc_lint::SoftLints::get_lints().into_iter())\n+    };\n+\n+    let lint_opts = lints()\n+        .filter_map(|lint| {\n+            if lint.name == warnings_lint_name || lint.name == invalid_codeblock_attribute_name {\n+                None\n+            } else {\n+                Some((lint.name_lower(), lint::Allow))\n+            }\n+        })\n+        .chain(options.lint_opts.clone().into_iter())\n+        .collect::<Vec<_>>();\n+\n+    let lint_caps = lints()\n+        .filter_map(|lint| {\n+            // We don't want to whitelist *all* lints so let's\n+            // ignore those ones.\n+            if whitelisted_lints.iter().any(|l| lint.name == l) {\n+                None\n+            } else {\n+                Some((lint::LintId::of(lint), lint::Allow))\n+            }\n+        })\n+        .collect();\n+\n     let crate_types = if options.proc_macro_crate {\n         vec![config::CrateType::ProcMacro]\n     } else {\n@@ -50,10 +92,11 @@ pub fn run(options: Options) -> i32 {\n         maybe_sysroot: options.maybe_sysroot.clone(),\n         search_paths: options.libs.clone(),\n         crate_types,\n+        lint_opts: if !options.display_warnings { lint_opts } else { vec![] },\n+        lint_cap: Some(options.lint_cap.clone().unwrap_or_else(|| lint::Forbid)),\n         cg: options.codegen_options.clone(),\n         externs: options.externs.clone(),\n         unstable_features: UnstableFeatures::from_environment(),\n-        lint_cap: Some(rustc_session::lint::Level::Allow),\n         actually_rustdoc: true,\n         debugging_opts: config::DebuggingOptions { ..config::basic_debugging_options() },\n         edition: options.edition,\n@@ -75,7 +118,7 @@ pub fn run(options: Options) -> i32 {\n         diagnostic_output: DiagnosticOutput::Default,\n         stderr: None,\n         crate_name: options.crate_name.clone(),\n-        lint_caps: Default::default(),\n+        lint_caps,\n         register_lints: None,\n         override_queries: None,\n         registry: rustc_driver::diagnostics_registry(),\n@@ -105,17 +148,25 @@ pub fn run(options: Options) -> i32 {\n \n             global_ctxt.enter(|tcx| {\n                 let krate = tcx.hir().krate();\n+\n                 let mut hir_collector = HirCollector {\n                     sess: compiler.session(),\n                     collector: &mut collector,\n                     map: tcx.hir(),\n                     codes: ErrorCodes::from(\n                         compiler.session().opts.unstable_features.is_nightly_build(),\n                     ),\n+                    tcx,\n                 };\n-                hir_collector.visit_testable(\"\".to_string(), &krate.item.attrs, |this| {\n-                    intravisit::walk_crate(this, krate);\n-                });\n+                hir_collector.visit_testable(\n+                    \"\".to_string(),\n+                    &krate.item.attrs,\n+                    CRATE_HIR_ID,\n+                    krate.item.span,\n+                    |this| {\n+                        intravisit::walk_crate(this, krate);\n+                    },\n+                );\n             });\n             compiler.session().abort_if_errors();\n \n@@ -881,18 +932,21 @@ impl Tester for Collector {\n     }\n }\n \n-struct HirCollector<'a, 'hir> {\n+struct HirCollector<'a, 'hir, 'tcx> {\n     sess: &'a Session,\n     collector: &'a mut Collector,\n     map: Map<'hir>,\n     codes: ErrorCodes,\n+    tcx: TyCtxt<'tcx>,\n }\n \n-impl<'a, 'hir> HirCollector<'a, 'hir> {\n+impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n     fn visit_testable<F: FnOnce(&mut Self)>(\n         &mut self,\n         name: String,\n         attrs: &[ast::Attribute],\n+        hir_id: HirId,\n+        sp: Span,\n         nested: F,\n     ) {\n         let mut attrs = Attributes::from_ast(self.sess.diagnostic(), attrs);\n@@ -918,6 +972,11 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n                 self.collector,\n                 self.codes,\n                 self.collector.enable_per_target_ignores,\n+                Some(&crate::html::markdown::ExtraInfo::new(\n+                    &self.tcx,\n+                    hir_id,\n+                    span_of_attrs(&attrs).unwrap_or(sp),\n+                )),\n             );\n         }\n \n@@ -929,7 +988,7 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n     }\n }\n \n-impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n+impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx> {\n     type Map = Map<'hir>;\n \n     fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n@@ -943,25 +1002,25 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n             item.ident.to_string()\n         };\n \n-        self.visit_testable(name, &item.attrs, |this| {\n+        self.visit_testable(name, &item.attrs, item.hir_id, item.span, |this| {\n             intravisit::walk_item(this, item);\n         });\n     }\n \n     fn visit_trait_item(&mut self, item: &'hir hir::TraitItem) {\n-        self.visit_testable(item.ident.to_string(), &item.attrs, |this| {\n+        self.visit_testable(item.ident.to_string(), &item.attrs, item.hir_id, item.span, |this| {\n             intravisit::walk_trait_item(this, item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, item: &'hir hir::ImplItem) {\n-        self.visit_testable(item.ident.to_string(), &item.attrs, |this| {\n+        self.visit_testable(item.ident.to_string(), &item.attrs, item.hir_id, item.span, |this| {\n             intravisit::walk_impl_item(this, item);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, item: &'hir hir::ForeignItem) {\n-        self.visit_testable(item.ident.to_string(), &item.attrs, |this| {\n+        self.visit_testable(item.ident.to_string(), &item.attrs, item.hir_id, item.span, |this| {\n             intravisit::walk_foreign_item(this, item);\n         });\n     }\n@@ -972,19 +1031,25 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n         g: &'hir hir::Generics,\n         item_id: hir::HirId,\n     ) {\n-        self.visit_testable(v.ident.to_string(), &v.attrs, |this| {\n+        self.visit_testable(v.ident.to_string(), &v.attrs, v.id, v.span, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }\n \n     fn visit_struct_field(&mut self, f: &'hir hir::StructField) {\n-        self.visit_testable(f.ident.to_string(), &f.attrs, |this| {\n+        self.visit_testable(f.ident.to_string(), &f.attrs, f.hir_id, f.span, |this| {\n             intravisit::walk_struct_field(this, f);\n         });\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'hir hir::MacroDef) {\n-        self.visit_testable(macro_def.ident.to_string(), &macro_def.attrs, |_| ());\n+        self.visit_testable(\n+            macro_def.ident.to_string(),\n+            &macro_def.attrs,\n+            macro_def.hir_id,\n+            macro_def.span,\n+            |_| (),\n+        );\n     }\n }\n "}, {"sha": "c4140bbb70a784f8290239b337f367fed4151279", "filename": "src/test/rustdoc-ui/check-attr-test.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Frustdoc-ui%2Fcheck-attr-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Frustdoc-ui%2Fcheck-attr-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcheck-attr-test.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -0,0 +1,38 @@\n+// compile-flags:--test\n+\n+#![deny(invalid_codeblock_attribute)]\n+\n+/// foo\n+///\n+/// ```compile-fail,compilefail,comPile_fail\n+/// boo\n+/// ```\n+pub fn foo() {}\n+\n+/// bar\n+///\n+/// ```should-panic,shouldpanic,shOuld_panic\n+/// boo\n+/// ```\n+pub fn bar() {}\n+\n+/// foobar\n+///\n+/// ```no-run,norun,nO_run\n+/// boo\n+/// ```\n+pub fn foobar() {}\n+\n+/// barfoo\n+///\n+/// ```allow-fail,allowfail,allOw_fail\n+/// boo\n+/// ```\n+pub fn barfoo() {}\n+\n+/// b\n+///\n+/// ```test-harness,testharness,tesT_harness\n+/// boo\n+/// ```\n+pub fn b() {}"}, {"sha": "45a2d6ec15e7d5437fdb13cdbc206d8a0f6924e8", "filename": "src/test/rustdoc-ui/check-attr-test.stderr", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Frustdoc-ui%2Fcheck-attr-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Frustdoc-ui%2Fcheck-attr-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcheck-attr-test.stderr?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -0,0 +1,187 @@\n+error: unknown attribute `compile-fail`. Did you mean `compile_fail`?\n+ --> $DIR/check-attr-test.rs:5:1\n+  |\n+5 | / /// foo\n+6 | | ///\n+7 | | /// ```compile-fail,compilefail,comPile_fail\n+8 | | /// boo\n+9 | | /// ```\n+  | |_______^\n+  |\n+note: the lint level is defined here\n+ --> $DIR/check-attr-test.rs:3:9\n+  |\n+3 | #![deny(invalid_codeblock_attribute)]\n+  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  = help: the code block will either not be tested if not marked as a rust one or won't fail if it compiles successfully\n+\n+error: unknown attribute `compilefail`. Did you mean `compile_fail`?\n+ --> $DIR/check-attr-test.rs:5:1\n+  |\n+5 | / /// foo\n+6 | | ///\n+7 | | /// ```compile-fail,compilefail,comPile_fail\n+8 | | /// boo\n+9 | | /// ```\n+  | |_______^\n+  |\n+  = help: the code block will either not be tested if not marked as a rust one or won't fail if it compiles successfully\n+\n+error: unknown attribute `comPile_fail`. Did you mean `compile_fail`?\n+ --> $DIR/check-attr-test.rs:5:1\n+  |\n+5 | / /// foo\n+6 | | ///\n+7 | | /// ```compile-fail,compilefail,comPile_fail\n+8 | | /// boo\n+9 | | /// ```\n+  | |_______^\n+  |\n+  = help: the code block will either not be tested if not marked as a rust one or won't fail if it compiles successfully\n+\n+error: unknown attribute `should-panic`. Did you mean `should_panic`?\n+  --> $DIR/check-attr-test.rs:12:1\n+   |\n+12 | / /// bar\n+13 | | ///\n+14 | | /// ```should-panic,shouldpanic,shOuld_panic\n+15 | | /// boo\n+16 | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or won't fail if it doesn't panic when running\n+\n+error: unknown attribute `shouldpanic`. Did you mean `should_panic`?\n+  --> $DIR/check-attr-test.rs:12:1\n+   |\n+12 | / /// bar\n+13 | | ///\n+14 | | /// ```should-panic,shouldpanic,shOuld_panic\n+15 | | /// boo\n+16 | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or won't fail if it doesn't panic when running\n+\n+error: unknown attribute `shOuld_panic`. Did you mean `should_panic`?\n+  --> $DIR/check-attr-test.rs:12:1\n+   |\n+12 | / /// bar\n+13 | | ///\n+14 | | /// ```should-panic,shouldpanic,shOuld_panic\n+15 | | /// boo\n+16 | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or won't fail if it doesn't panic when running\n+\n+error: unknown attribute `no-run`. Did you mean `no_run`?\n+  --> $DIR/check-attr-test.rs:19:1\n+   |\n+19 | / /// foobar\n+20 | | ///\n+21 | | /// ```no-run,norun,nO_run\n+22 | | /// boo\n+23 | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or will be run (which you might not want)\n+\n+error: unknown attribute `norun`. Did you mean `no_run`?\n+  --> $DIR/check-attr-test.rs:19:1\n+   |\n+19 | / /// foobar\n+20 | | ///\n+21 | | /// ```no-run,norun,nO_run\n+22 | | /// boo\n+23 | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or will be run (which you might not want)\n+\n+error: unknown attribute `nO_run`. Did you mean `no_run`?\n+  --> $DIR/check-attr-test.rs:19:1\n+   |\n+19 | / /// foobar\n+20 | | ///\n+21 | | /// ```no-run,norun,nO_run\n+22 | | /// boo\n+23 | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or will be run (which you might not want)\n+\n+error: unknown attribute `allow-fail`. Did you mean `allow_fail`?\n+  --> $DIR/check-attr-test.rs:26:1\n+   |\n+26 | / /// barfoo\n+27 | | ///\n+28 | | /// ```allow-fail,allowfail,allOw_fail\n+29 | | /// boo\n+30 | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or will be run (which you might not want)\n+\n+error: unknown attribute `allowfail`. Did you mean `allow_fail`?\n+  --> $DIR/check-attr-test.rs:26:1\n+   |\n+26 | / /// barfoo\n+27 | | ///\n+28 | | /// ```allow-fail,allowfail,allOw_fail\n+29 | | /// boo\n+30 | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or will be run (which you might not want)\n+\n+error: unknown attribute `allOw_fail`. Did you mean `allow_fail`?\n+  --> $DIR/check-attr-test.rs:26:1\n+   |\n+26 | / /// barfoo\n+27 | | ///\n+28 | | /// ```allow-fail,allowfail,allOw_fail\n+29 | | /// boo\n+30 | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or will be run (which you might not want)\n+\n+error: unknown attribute `test-harness`. Did you mean `test_harness`?\n+  --> $DIR/check-attr-test.rs:33:1\n+   |\n+33 | / /// b\n+34 | | ///\n+35 | | /// ```test-harness,testharness,tesT_harness\n+36 | | /// boo\n+37 | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or the code will be wrapped inside a main function\n+\n+error: unknown attribute `testharness`. Did you mean `test_harness`?\n+  --> $DIR/check-attr-test.rs:33:1\n+   |\n+33 | / /// b\n+34 | | ///\n+35 | | /// ```test-harness,testharness,tesT_harness\n+36 | | /// boo\n+37 | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or the code will be wrapped inside a main function\n+\n+error: unknown attribute `tesT_harness`. Did you mean `test_harness`?\n+  --> $DIR/check-attr-test.rs:33:1\n+   |\n+33 | / /// b\n+34 | | ///\n+35 | | /// ```test-harness,testharness,tesT_harness\n+36 | | /// boo\n+37 | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or the code will be wrapped inside a main function\n+\n+error: aborting due to 15 previous errors\n+"}, {"sha": "a93ec291319071fa3f588579daadb096d2b39725", "filename": "src/test/rustdoc-ui/check-attr.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Frustdoc-ui%2Fcheck-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Frustdoc-ui%2Fcheck-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcheck-attr.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -0,0 +1,51 @@\n+#![deny(invalid_codeblock_attribute)]\n+\n+/// foo\n+//~^ ERROR\n+//~^^ ERROR\n+//~^^^ ERROR\n+///\n+/// ```compile-fail,compilefail,comPile_fail\n+/// boo\n+/// ```\n+pub fn foo() {}\n+\n+/// bar\n+//~^ ERROR\n+//~^^ ERROR\n+//~^^^ ERROR\n+///\n+/// ```should-panic,shouldpanic,sHould_panic\n+/// boo\n+/// ```\n+pub fn bar() {}\n+\n+/// foobar\n+//~^ ERROR\n+//~^^ ERROR\n+//~^^^ ERROR\n+///\n+/// ```no-run,norun,no_Run\n+/// boo\n+/// ```\n+pub fn foobar() {}\n+\n+/// barfoo\n+//~^ ERROR\n+//~^^ ERROR\n+//~^^^ ERROR\n+///\n+/// ```allow-fail,allowfail,alLow_fail\n+/// boo\n+/// ```\n+pub fn barfoo() {}\n+\n+/// b\n+//~^ ERROR\n+//~^^ ERROR\n+//~^^^ ERROR\n+///\n+/// ```test-harness,testharness,teSt_harness\n+/// boo\n+/// ```\n+pub fn b() {}"}, {"sha": "5d6939bd09205982b29c837e09e276b0c9fb9226", "filename": "src/test/rustdoc-ui/check-attr.stderr", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Frustdoc-ui%2Fcheck-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Frustdoc-ui%2Fcheck-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcheck-attr.stderr?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -0,0 +1,217 @@\n+error: unknown attribute `compile-fail`. Did you mean `compile_fail`?\n+  --> $DIR/check-attr.rs:3:1\n+   |\n+LL | / /// foo\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/check-attr.rs:1:9\n+   |\n+LL | #![deny(invalid_codeblock_attribute)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: the code block will either not be tested if not marked as a rust one or won't fail if it compiles successfully\n+\n+error: unknown attribute `compilefail`. Did you mean `compile_fail`?\n+  --> $DIR/check-attr.rs:3:1\n+   |\n+LL | / /// foo\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or won't fail if it compiles successfully\n+\n+error: unknown attribute `comPile_fail`. Did you mean `compile_fail`?\n+  --> $DIR/check-attr.rs:3:1\n+   |\n+LL | / /// foo\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or won't fail if it compiles successfully\n+\n+error: unknown attribute `should-panic`. Did you mean `should_panic`?\n+  --> $DIR/check-attr.rs:13:1\n+   |\n+LL | / /// bar\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or won't fail if it doesn't panic when running\n+\n+error: unknown attribute `shouldpanic`. Did you mean `should_panic`?\n+  --> $DIR/check-attr.rs:13:1\n+   |\n+LL | / /// bar\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or won't fail if it doesn't panic when running\n+\n+error: unknown attribute `sHould_panic`. Did you mean `should_panic`?\n+  --> $DIR/check-attr.rs:13:1\n+   |\n+LL | / /// bar\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or won't fail if it doesn't panic when running\n+\n+error: unknown attribute `no-run`. Did you mean `no_run`?\n+  --> $DIR/check-attr.rs:23:1\n+   |\n+LL | / /// foobar\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or will be run (which you might not want)\n+\n+error: unknown attribute `norun`. Did you mean `no_run`?\n+  --> $DIR/check-attr.rs:23:1\n+   |\n+LL | / /// foobar\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or will be run (which you might not want)\n+\n+error: unknown attribute `no_Run`. Did you mean `no_run`?\n+  --> $DIR/check-attr.rs:23:1\n+   |\n+LL | / /// foobar\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or will be run (which you might not want)\n+\n+error: unknown attribute `allow-fail`. Did you mean `allow_fail`?\n+  --> $DIR/check-attr.rs:33:1\n+   |\n+LL | / /// barfoo\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or will be run (which you might not want)\n+\n+error: unknown attribute `allowfail`. Did you mean `allow_fail`?\n+  --> $DIR/check-attr.rs:33:1\n+   |\n+LL | / /// barfoo\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or will be run (which you might not want)\n+\n+error: unknown attribute `alLow_fail`. Did you mean `allow_fail`?\n+  --> $DIR/check-attr.rs:33:1\n+   |\n+LL | / /// barfoo\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or will be run (which you might not want)\n+\n+error: unknown attribute `test-harness`. Did you mean `test_harness`?\n+  --> $DIR/check-attr.rs:43:1\n+   |\n+LL | / /// b\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or the code will be wrapped inside a main function\n+\n+error: unknown attribute `testharness`. Did you mean `test_harness`?\n+  --> $DIR/check-attr.rs:43:1\n+   |\n+LL | / /// b\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or the code will be wrapped inside a main function\n+\n+error: unknown attribute `teSt_harness`. Did you mean `test_harness`?\n+  --> $DIR/check-attr.rs:43:1\n+   |\n+LL | / /// b\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | | /// boo\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = help: the code block will either not be tested if not marked as a rust one or the code will be wrapped inside a main function\n+\n+error: aborting due to 15 previous errors\n+"}, {"sha": "f560f68f613685ddc7ef92a5e77ae96aeddc4595", "filename": "src/test/ui/parser/issue-70583-block-is-empty-1.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Fui%2Fparser%2Fissue-70583-block-is-empty-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Fui%2Fparser%2Fissue-70583-block-is-empty-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-70583-block-is-empty-1.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -0,0 +1,20 @@\n+pub enum ErrorHandled {\n+    Reported,\n+    TooGeneric,\n+}\n+\n+impl ErrorHandled {\n+    pub fn assert_reported(self) {\n+        match self {\n+            ErrorHandled::Reported => {}\n+            ErrorHandled::TooGeneric => panic!(),\n+        }\n+    }\n+}\n+\n+fn struct_generic(x: Vec<i32>) {\n+    for v in x {\n+        println!(\"{}\", v);\n+    }\n+    }\n+} //~ ERROR unexpected closing delimiter: `}`"}, {"sha": "39bf113ef83de58b648c2b9cd038ff58a2a178e4", "filename": "src/test/ui/parser/issue-70583-block-is-empty-1.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Fui%2Fparser%2Fissue-70583-block-is-empty-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Fui%2Fparser%2Fissue-70583-block-is-empty-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-70583-block-is-empty-1.stderr?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -0,0 +1,13 @@\n+error: unexpected closing delimiter: `}`\n+  --> $DIR/issue-70583-block-is-empty-1.rs:20:1\n+   |\n+LL | fn struct_generic(x: Vec<i32>) {\n+   |                                - this opening brace...\n+...\n+LL |     }\n+   |     - ...matches this closing brace\n+LL | }\n+   | ^ unexpected closing delimiter\n+\n+error: aborting due to previous error\n+"}, {"sha": "80f53338a689e92f831d208220ed74b51ba6b0d1", "filename": "src/test/ui/parser/issue-70583-block-is-empty-2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Fui%2Fparser%2Fissue-70583-block-is-empty-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Fui%2Fparser%2Fissue-70583-block-is-empty-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-70583-block-is-empty-2.rs?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -0,0 +1,14 @@\n+pub enum ErrorHandled {\n+    Reported,\n+    TooGeneric,\n+}\n+\n+impl ErrorHandled {\n+    pub fn assert_reported(self) {\n+        match self {\n+            ErrorHandled::Reported => {}}\n+                                     //^~ ERROR block is empty, you might have not meant to close it\n+            ErrorHandled::TooGeneric => panic!(),\n+        }\n+    }\n+} //~ ERROR unexpected closing delimiter: `}`"}, {"sha": "5d37b216427f6b023c0389b70121018b39a62dbc", "filename": "src/test/ui/parser/issue-70583-block-is-empty-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Fui%2Fparser%2Fissue-70583-block-is-empty-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Fui%2Fparser%2Fissue-70583-block-is-empty-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-70583-block-is-empty-2.stderr?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -0,0 +1,11 @@\n+error: unexpected closing delimiter: `}`\n+  --> $DIR/issue-70583-block-is-empty-2.rs:14:1\n+   |\n+LL |             ErrorHandled::Reported => {}}\n+   |                                       -- block is empty, you might have not meant to close it\n+...\n+LL | }\n+   | ^ unexpected closing delimiter\n+\n+error: aborting due to previous error\n+"}, {"sha": "424c7a60c196f06ce9707d048e40bddae1cb85dc", "filename": "src/test/ui/parser/macro-mismatched-delim-paren-brace.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Fui%2Fparser%2Fmacro-mismatched-delim-paren-brace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Fui%2Fparser%2Fmacro-mismatched-delim-paren-brace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro-mismatched-delim-paren-brace.stderr?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -1,6 +1,11 @@\n error: unexpected closing delimiter: `}`\n   --> $DIR/macro-mismatched-delim-paren-brace.rs:5:1\n    |\n+LL | fn main() {\n+   |           - this opening brace...\n+...\n+LL |     }\n+   |     - ...matches this closing brace\n LL | }\n    | ^ unexpected closing delimiter\n "}, {"sha": "c871e549c9ec3da0b6d6f613c86796108fae24ed", "filename": "src/test/ui/parser/mismatched-delim-brace-empty-block.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Fui%2Fparser%2Fmismatched-delim-brace-empty-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14b15521c52549ebbb113173b4abecd124b5a823/src%2Ftest%2Fui%2Fparser%2Fmismatched-delim-brace-empty-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-delim-brace-empty-block.stderr?ref=14b15521c52549ebbb113173b4abecd124b5a823", "patch": "@@ -1,6 +1,12 @@\n error: unexpected closing delimiter: `}`\n   --> $DIR/mismatched-delim-brace-empty-block.rs:5:1\n    |\n+LL | fn main() {\n+   |           - this opening brace...\n+LL | \n+LL | }\n+   | - ...matches this closing brace\n+LL |     let _ = ();\n LL | }\n    | ^ unexpected closing delimiter\n "}]}