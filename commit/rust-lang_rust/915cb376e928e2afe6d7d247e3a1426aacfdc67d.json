{"sha": "915cb376e928e2afe6d7d247e3a1426aacfdc67d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNWNiMzc2ZTkyOGUyYWZlNmQ3ZDI0N2UzYTE0MjZhYWNmZGM2N2Q=", "commit": {"author": {"name": "Peter Atashian", "email": "retep998@gmail.com", "date": "2015-12-06T08:27:21Z"}, "committer": {"name": "Peter Atashian", "email": "retep998@gmail.com", "date": "2015-12-14T23:04:35Z"}, "message": "Overhaul MSVC linker and Windows SDK detection code\nFixes https://github.com/rust-lang/rust/issues/30229\n\nSigned-off-by: Peter Atashian <retep998@gmail.com>", "tree": {"sha": "dd2513038869dfa2e025b364e712dabae025973f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd2513038869dfa2e025b364e712dabae025973f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/915cb376e928e2afe6d7d247e3a1426aacfdc67d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/915cb376e928e2afe6d7d247e3a1426aacfdc67d", "html_url": "https://github.com/rust-lang/rust/commit/915cb376e928e2afe6d7d247e3a1426aacfdc67d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/915cb376e928e2afe6d7d247e3a1426aacfdc67d/comments", "author": {"login": "retep998", "id": 666308, "node_id": "MDQ6VXNlcjY2NjMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/666308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/retep998", "html_url": "https://github.com/retep998", "followers_url": "https://api.github.com/users/retep998/followers", "following_url": "https://api.github.com/users/retep998/following{/other_user}", "gists_url": "https://api.github.com/users/retep998/gists{/gist_id}", "starred_url": "https://api.github.com/users/retep998/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/retep998/subscriptions", "organizations_url": "https://api.github.com/users/retep998/orgs", "repos_url": "https://api.github.com/users/retep998/repos", "events_url": "https://api.github.com/users/retep998/events{/privacy}", "received_events_url": "https://api.github.com/users/retep998/received_events", "type": "User", "site_admin": false}, "committer": {"login": "retep998", "id": 666308, "node_id": "MDQ6VXNlcjY2NjMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/666308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/retep998", "html_url": "https://github.com/retep998", "followers_url": "https://api.github.com/users/retep998/followers", "following_url": "https://api.github.com/users/retep998/following{/other_user}", "gists_url": "https://api.github.com/users/retep998/gists{/gist_id}", "starred_url": "https://api.github.com/users/retep998/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/retep998/subscriptions", "organizations_url": "https://api.github.com/users/retep998/orgs", "repos_url": "https://api.github.com/users/retep998/repos", "events_url": "https://api.github.com/users/retep998/events{/privacy}", "received_events_url": "https://api.github.com/users/retep998/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f150c178ea8275fab158bc7fe2a3b5af9ab8f3fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/f150c178ea8275fab158bc7fe2a3b5af9ab8f3fe", "html_url": "https://github.com/rust-lang/rust/commit/f150c178ea8275fab158bc7fe2a3b5af9ab8f3fe"}], "stats": {"total": 459, "additions": 173, "deletions": 286}, "files": [{"sha": "3b5b94381b372f08ab62067c996cf4136206c000", "filename": "src/librustc_trans/back/msvc/mod.rs", "status": "modified", "additions": 173, "deletions": 245, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/915cb376e928e2afe6d7d247e3a1426aacfdc67d/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915cb376e928e2afe6d7d247e3a1426aacfdc67d/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs?ref=915cb376e928e2afe6d7d247e3a1426aacfdc67d", "patch": "@@ -28,7 +28,7 @@\n //! shell or MSYS shells.\n //!\n //! As a high-level note, all logic in this module for looking up various\n-//! paths/files is copied over from Clang in its MSVCToolChain.cpp file, but\n+//! paths/files is based on Microsoft's logic in their vcvars bat files, but\n //! comments can also be found below leading through the various code paths.\n \n use std::process::Command;\n@@ -42,290 +42,218 @@ pub fn link_exe_cmd(sess: &Session) -> Command {\n     use std::env;\n     use std::ffi::OsString;\n     use std::fs;\n-    use std::io;\n     use std::path::{Path, PathBuf};\n-    use self::registry::{RegistryKey, LOCAL_MACHINE};\n+    use self::registry::{LOCAL_MACHINE};\n \n-    // When finding the link.exe binary the 32-bit version is at the top level\n-    // but the versions to cross to other architectures are stored in\n-    // sub-folders. Unknown architectures also just bail out early to return the\n-    // standard `link.exe` command.\n-    let extra = match &sess.target.target.arch[..] {\n-        \"x86\" => \"\",\n-        \"x86_64\" => \"amd64\",\n-        \"arm\" => \"arm\",\n+    let arch = &sess.target.target.arch;\n+    let (binsub, libsub, vclibsub) =\n+        match (bin_subdir(arch), lib_subdir(arch), vc_lib_subdir(arch)) {\n+        (Some(x), Some(y), Some(z)) => (x, y, z),\n         _ => return Command::new(\"link.exe\"),\n     };\n \n-    let vs_install_dir = get_vs_install_dir();\n-\n-    // First up, we need to find the `link.exe` binary itself, and there's a few\n-    // locations that we can look. First up is the standard VCINSTALLDIR\n-    // environment variable which is normally set by the vcvarsall.bat file. If\n-    // an environment is set up manually by whomever's driving the compiler then\n-    // we shouldn't muck with that decision and should instead respect that.\n+    // First we need to figure out whether the environment is already correctly\n+    // configured by vcvars. We do this by looking at the environment variable\n+    // `VCINSTALLDIR` which is always set by vcvars, and unlikely to be set\n+    // otherwise. If it is defined, then we derive the path to `link.exe` from\n+    // that and trust that everything else is configured correctly.\n+    //\n+    // If `VCINSTALLDIR` wasn't defined (or we couldn't find the linker where it\n+    // claimed it should be), then we resort to finding everything ourselves.\n+    // First we find where the latest version of MSVC is installed and what\n+    // version it is. Then based on the version we find the appropriate SDKs.\n+    //\n+    // For MSVC 14 (VS 2015) we look for the Win10 SDK and failing that we look\n+    // for the Win8.1 SDK. We also look for the Universal CRT.\n     //\n-    // Next up is looking in PATH itself. Here we look for `cl.exe` and then\n-    // assume that `link.exe` is next to it if we find it. Note that we look for\n-    // `cl.exe` because MinGW ships /usr/bin/link.exe which is normally found in\n-    // PATH but we're not interested in finding that.\n+    // For MSVC 12 (VS 2013) we look for the Win8.1 SDK.\n     //\n-    // Finally we read the Windows registry to discover the VS install root.\n-    // From here we probe for `link.exe` just to make sure that it exists.\n-    let mut cmd = env::var_os(\"VCINSTALLDIR\").and_then(|dir| {\n+    // For MSVC 11 (VS 2012) we look for the Win8 SDK.\n+    //\n+    // For all other versions the user has to execute the appropriate vcvars bat\n+    // file themselves to configure the environment.\n+    //\n+    // If despite our best efforts we are still unable to find MSVC then we just\n+    // blindly call `link.exe` and hope for the best.\n+    return env::var_os(\"VCINSTALLDIR\").and_then(|dir| {\n+        debug!(\"Environment already configured by user. Assuming it works.\");\n         let mut p = PathBuf::from(dir);\n         p.push(\"bin\");\n-        p.push(extra);\n+        p.push(binsub);\n         p.push(\"link.exe\");\n-        if fs::metadata(&p).is_ok() {Some(p)} else {None}\n-    }).or_else(|| {\n-        env::var_os(\"PATH\").and_then(|path| {\n-            env::split_paths(&path).find(|path| {\n-                fs::metadata(&path.join(\"cl.exe\")).is_ok()\n-            }).map(|p| {\n-                p.join(\"link.exe\")\n-            })\n-        })\n+        if !p.is_file() { return None }\n+        Some(Command::new(p))\n     }).or_else(|| {\n-        vs_install_dir.as_ref().and_then(|p| {\n-            let mut p = p.join(\"VC/bin\");\n-            p.push(extra);\n-            p.push(\"link.exe\");\n-            if fs::metadata(&p).is_ok() {Some(p)} else {None}\n+        get_vc_dir().and_then(|(ver, vcdir)| {\n+            debug!(\"Found VC installation directory {:?}\", vcdir);\n+            let mut linker = vcdir.clone();\n+            linker.push(\"bin\");\n+            linker.push(binsub);\n+            linker.push(\"link.exe\");\n+            if !linker.is_file() { return None }\n+            let mut cmd = Command::new(linker);\n+            add_lib(&mut cmd, &vcdir.join(\"lib\").join(vclibsub));\n+            if ver == \"14.0\" {\n+                if let Some(dir) = get_ucrt_dir() {\n+                    debug!(\"Found Universal CRT {:?}\", dir);\n+                    add_lib(&mut cmd, &dir.join(\"ucrt\").join(libsub));\n+                }\n+                if let Some(dir) = get_sdk10_dir() {\n+                    debug!(\"Found Win10 SDK {:?}\", dir);\n+                    add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n+                } else if let Some(dir) = get_sdk81_dir() {\n+                    debug!(\"Found Win8.1 SDK {:?}\", dir);\n+                    add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n+                }\n+            } else if ver == \"12.0\" {\n+                if let Some(dir) = get_sdk81_dir() {\n+                    debug!(\"Found Win8.1 SDK {:?}\", dir);\n+                    add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n+                }\n+            } else { // ver == \"11.0\"\n+                if let Some(dir) = get_sdk8_dir() {\n+                    debug!(\"Found Win8 SDK {:?}\", dir);\n+                    add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n+                }\n+            }\n+            Some(cmd)\n         })\n-    }).map(|linker| {\n-        Command::new(linker)\n     }).unwrap_or_else(|| {\n+        debug!(\"Failed to locate linker.\");\n         Command::new(\"link.exe\")\n     });\n \n-    // The MSVC linker uses the LIB environment variable as the default lookup\n-    // path for libraries. This environment variable is normally set up by the\n-    // VS shells, so we only want to start adding our own pieces if it's not\n-    // set.\n-    //\n-    // If we're adding our own pieces, then we need to add a few primary\n-    // directories to the default search path for the linker. The first is in\n-    // the VS install direcotry, the next is the Windows SDK directory, and the\n-    // last is the possible UCRT installation directory.\n-    //\n-    // The UCRT is a recent addition to Visual Studio installs (2015 at the time\n-    // of this writing), and it's in the normal windows SDK folder, but there\n-    // apparently aren't registry keys pointing to it. As a result we detect the\n-    // installation and then add it manually. This logic will probably need to\n-    // be tweaked over time...\n-    if env::var_os(\"LIB\").is_none() {\n-        if let Some(mut vs_install_dir) = vs_install_dir {\n-            vs_install_dir.push(\"VC/lib\");\n-            vs_install_dir.push(extra);\n-            let mut arg = OsString::from(\"/LIBPATH:\");\n-            arg.push(&vs_install_dir);\n-            cmd.arg(arg);\n+    // A convenience function to make the above code simpler\n+    fn add_lib(cmd: &mut Command, lib: &Path) {\n+        let mut arg: OsString = \"/LIBPATH:\".into();\n+        arg.push(lib);\n+        cmd.arg(arg);\n+    }\n \n-            if let Some((ucrt_root, vers)) = ucrt_install_dir(&vs_install_dir) {\n-                if let Some(arch) = windows_sdk_v8_subdir(sess) {\n-                    let mut arg = OsString::from(\"/LIBPATH:\");\n-                    arg.push(ucrt_root.join(\"Lib\").join(vers)\n-                                      .join(\"ucrt\").join(arch));\n-                    cmd.arg(arg);\n-                }\n-            }\n-        }\n-        if let Some(path) = get_windows_sdk_lib_path(sess) {\n-            let mut arg = OsString::from(\"/LIBPATH:\");\n-            arg.push(&path);\n-            cmd.arg(arg);\n-        }\n+    // To find MSVC we look in a specific registry key for the newest of the\n+    // three versions that we support.\n+    fn get_vc_dir() -> Option<(&'static str, PathBuf)> {\n+        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\VisualStudio\\SxS\\VC7\".as_ref())\n+        .ok().and_then(|key| {\n+            [\"14.0\", \"12.0\", \"11.0\"].iter().filter_map(|ver| {\n+                key.query_str(ver).ok().map(|p| (*ver, p.into()))\n+            }).next()\n+        })\n     }\n \n-    return cmd;\n+    // To find the Universal CRT we look in a specific registry key for where\n+    // all the Universal CRTs are located and then sort them asciibetically to\n+    // find the newest version. While this sort of sorting isn't ideal,  it is\n+    // what vcvars does so that's good enough for us.\n+    fn get_ucrt_dir() -> Option<PathBuf> {\n+        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots\".as_ref())\n+        .ok().and_then(|key| {\n+            key.query_str(\"KitsRoot10\").ok()\n+        }).and_then(|root| {\n+            fs::read_dir(Path::new(&root).join(\"Lib\")).ok()\n+        }).and_then(|readdir| {\n+            let mut dirs: Vec<_> = readdir.filter_map(|dir| dir.ok())\n+                .map(|dir| dir.path()).collect();\n+            dirs.sort();\n+            dirs.pop()\n+        })\n+    }\n \n-    // When looking for the Visual Studio installation directory we look in a\n-    // number of locations in varying degrees of precedence:\n-    //\n-    // 1. The Visual Studio registry keys\n-    // 2. The Visual Studio Express registry keys\n-    // 3. A number of somewhat standard environment variables\n-    //\n-    // If we find a hit from any of these keys then we strip off the IDE/Tools\n-    // folders which are typically found at the end.\n-    //\n-    // As a final note, when we take a look at the registry keys they're\n-    // typically found underneath the version of what's installed, but we don't\n-    // quite know what's installed. As a result we probe all sub-keys of the two\n-    // keys we're looking at to find out the maximum version of what's installed\n-    // and we use that root directory.\n-    fn get_vs_install_dir() -> Option<PathBuf> {\n-        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\VisualStudio\".as_ref()).or_else(|_| {\n-            LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\VCExpress\".as_ref())\n-        }).ok().and_then(|key| {\n-            max_version(&key).and_then(|(_vers, key)| {\n-                key.query_str(\"InstallDir\").ok()\n-            })\n-        }).or_else(|| {\n-            env::var_os(\"VS120COMNTOOLS\")\n-        }).or_else(|| {\n-            env::var_os(\"VS100COMNTOOLS\")\n-        }).or_else(|| {\n-            env::var_os(\"VS90COMNTOOLS\")\n-        }).or_else(|| {\n-            env::var_os(\"VS80COMNTOOLS\")\n-        }).map(PathBuf::from).and_then(|mut dir| {\n-            if dir.ends_with(\"Common7/IDE\") || dir.ends_with(\"Common7/Tools\") {\n-                dir.pop();\n-                dir.pop();\n-                Some(dir)\n-            } else {\n-                None\n-            }\n+    // Vcvars finds the correct version of the Windows 10 SDK by looking\n+    // for the include um/Windows.h because sometimes a given version will\n+    // only have UCRT bits without the rest of the SDK. Since we only care about\n+    // libraries and not includes, we just look for the folder `um` in the lib\n+    // section. Like we do for the Universal CRT, we sort the possibilities\n+    // asciibetically to find the newest one as that is what vcvars does.\n+    fn get_sdk10_dir() -> Option<PathBuf> {\n+        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v10.0\".as_ref())\n+        .ok().and_then(|key| {\n+            key.query_str(\"InstallationFolder\").ok()\n+        }).and_then(|root| {\n+            fs::read_dir(Path::new(&root).join(\"lib\")).ok()\n+        }).and_then(|readdir| {\n+            let mut dirs: Vec<_> = readdir.filter_map(|dir| dir.ok())\n+                .map(|dir| dir.path()).collect();\n+            dirs.sort();\n+            dirs.into_iter().rev().filter(|dir| {\n+                dir.join(\"um\").is_dir()\n+            }).next()\n         })\n     }\n \n-    // Given a registry key, look at all the sub keys and find the one which has\n-    // the maximal numeric value.\n-    //\n-    // Returns the name of the maximal key as well as the opened maximal key.\n-    fn max_version(key: &RegistryKey) -> Option<(OsString, RegistryKey)> {\n-        let mut max_vers = 0;\n-        let mut max_key = None;\n-        for subkey in key.iter().filter_map(|k| k.ok()) {\n-            let val = subkey.to_str().and_then(|s| {\n-                s.trim_left_matches(\"v\").replace(\".\", \"\").parse().ok()\n-            });\n-            let val = match val {\n-                Some(s) => s,\n-                None => continue,\n-            };\n-            if val > max_vers {\n-                if let Ok(k) = key.open(&subkey) {\n-                    max_vers = val;\n-                    max_key = Some((subkey, k));\n-                }\n-            }\n-        }\n-        return max_key\n+    // Interestingly there are several subdirectories, `win7` `win8` and\n+    // `winv6.3`. Vcvars seems to only care about `winv6.3` though, so the same\n+    // applies to us. Note that if we were targetting kernel mode drivers\n+    // instead of user mode applications, we would care.\n+    fn get_sdk81_dir() -> Option<PathBuf> {\n+        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v8.1\".as_ref())\n+        .ok().and_then(|key| {\n+            key.query_str(\"InstallationFolder\").ok()\n+        }).map(|root| {\n+            Path::new(&root).join(\"lib\").join(\"winv6.3\")\n+        })\n     }\n \n-    fn get_windows_sdk_path() -> Option<(PathBuf, usize, Option<OsString>)> {\n-        let key = r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\";\n-        let key = LOCAL_MACHINE.open(key.as_ref());\n-        let (n, k) = match key.ok().as_ref().and_then(max_version) {\n-            Some(p) => p,\n-            None => return None,\n-        };\n-        let mut parts = n.to_str().unwrap().trim_left_matches(\"v\").splitn(2, \".\");\n-        let major = parts.next().unwrap().parse::<usize>().unwrap();\n-        let _minor = parts.next().unwrap().parse::<usize>().unwrap();\n-        k.query_str(\"InstallationFolder\").ok().map(|folder| {\n-            let ver = k.query_str(\"ProductVersion\");\n-            (PathBuf::from(folder), major, ver.ok())\n+    fn get_sdk8_dir() -> Option<PathBuf> {\n+        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v8.0\".as_ref())\n+        .ok().and_then(|key| {\n+            key.query_str(\"InstallationFolder\").ok()\n+        }).map(|root| {\n+            Path::new(&root).join(\"lib\").join(\"win8\")\n         })\n     }\n \n-    fn get_windows_sdk_lib_path(sess: &Session) -> Option<PathBuf> {\n-        let (mut path, major, ver) = match get_windows_sdk_path() {\n-            Some(p) => p,\n-            None => return None,\n-        };\n-        path.push(\"Lib\");\n-        if major <= 7 {\n-            // In Windows SDK 7.x, x86 libraries are directly in the Lib folder,\n-            // x64 libraries are inside, and it's not necessary to link against\n-            // the SDK 7.x when targeting ARM or other architectures.\n-            let x86 = match &sess.target.target.arch[..] {\n-                \"x86\" => true,\n-                \"x86_64\" => false,\n-                _ => return None,\n-            };\n-            Some(if x86 {path} else {path.join(\"x64\")})\n-        } else if major <= 8 {\n-            // Windows SDK 8.x installs libraries in a folder whose names\n-            // depend on the version of the OS you're targeting. By default\n-            // choose the newest, which usually corresponds to the version of\n-            // the OS you've installed the SDK on.\n-            let extra = match windows_sdk_v8_subdir(sess) {\n-                Some(e) => e,\n-                None => return None,\n-            };\n-            [\"winv6.3\", \"win8\", \"win7\"].iter().map(|p| path.join(p)).find(|part| {\n-                fs::metadata(part).is_ok()\n-            }).map(|path| {\n-                path.join(\"um\").join(extra)\n-            })\n-        } else if let Some(mut ver) = ver {\n-            // Windows SDK 10 splits the libraries into architectures the same\n-            // as Windows SDK 8.x, except for the addition of arm64.\n-            // Additionally, the SDK 10 is split by Windows 10 build numbers\n-            // rather than the OS version like the SDK 8.x does.\n-            let extra = match windows_sdk_v10_subdir(sess) {\n-                Some(e) => e,\n-                None => return None,\n-            };\n-            // To get the correct directory we need to get the Windows SDK 10\n-            // version, and so far it looks like the \"ProductVersion\" of the SDK\n-            // corresponds to the folder name that the libraries are located in\n-            // except that the folder contains an extra \".0\". For now just\n-            // append a \".0\" to look for find the directory we're in. This logic\n-            // will likely want to be refactored one day.\n-            ver.push(\".0\");\n-            let p = path.join(ver).join(\"um\").join(extra);\n-            fs::metadata(&p).ok().map(|_| p)\n+    // When choosing the linker toolchain to use, we have to choose the one\n+    // which matches the host architecture. Otherwise we end up in situations\n+    // where someone on 32-bit Windows is trying to cross compile to 64-bit and\n+    // it tries to invoke the native 64-bit linker which won't work.\n+    //\n+    // FIXME - This currently functions based on the host architecture of rustc\n+    // itself but it should instead detect the bitness of the OS itself.\n+    //\n+    // FIXME - Figure out what happens when the host architecture is arm.\n+    //\n+    // FIXME - Some versions of MSVC may not come with all these toolchains.\n+    // Consider returning an array of toolchains and trying them one at a time\n+    // until the linker is found.\n+    fn bin_subdir(arch: &str) -> Option<&'static str> {\n+        if cfg!(target_arch = \"x86_64\") {\n+            match arch {\n+                \"x86\" => Some(\"amd64_x86\"),\n+                \"x86_64\" => Some(\"amd64\"),\n+                \"arm\" => Some(\"amd64_arm\"),\n+                _ => None,\n+            }\n+        } else if cfg!(target_arch = \"x86\") {\n+            match arch {\n+                \"x86\" => Some(\"\"),\n+                \"x86_64\" => Some(\"x86_amd64\"),\n+                \"arm\" => Some(\"x86_arm\"),\n+                _ => None,\n+            }\n         } else { None }\n     }\n-\n-    fn windows_sdk_v8_subdir(sess: &Session) -> Option<&'static str> {\n-        match &sess.target.target.arch[..] {\n+    fn lib_subdir(arch: &str) -> Option<&'static str> {\n+        match arch {\n             \"x86\" => Some(\"x86\"),\n             \"x86_64\" => Some(\"x64\"),\n             \"arm\" => Some(\"arm\"),\n-            _ => return None,\n+            _ => None,\n         }\n     }\n-\n-    fn windows_sdk_v10_subdir(sess: &Session) -> Option<&'static str> {\n-        match &sess.target.target.arch[..] {\n-            \"x86\" => Some(\"x86\"),\n-            \"x86_64\" => Some(\"x64\"),\n+    // MSVC's x86 libraries are not in a subfolder\n+    fn vc_lib_subdir(arch: &str) -> Option<&'static str> {\n+        match arch {\n+            \"x86\" => Some(\"\"),\n+            \"x86_64\" => Some(\"amd64\"),\n             \"arm\" => Some(\"arm\"),\n-            \"aarch64\" => Some(\"arm64\"), // FIXME - Check if aarch64 is correct\n-            _ => return None,\n+            _ => None,\n         }\n     }\n-\n-    fn ucrt_install_dir(vs_install_dir: &Path) -> Option<(PathBuf, String)> {\n-        let is_vs_14 = vs_install_dir.iter().filter_map(|p| p.to_str()).any(|s| {\n-            s == \"Microsoft Visual Studio 14.0\"\n-        });\n-        if !is_vs_14 {\n-            return None\n-        }\n-        let key = r\"SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots\";\n-        let sdk_dir = LOCAL_MACHINE.open(key.as_ref()).and_then(|p| {\n-            p.query_str(\"KitsRoot10\")\n-        }).map(PathBuf::from);\n-        let sdk_dir = match sdk_dir {\n-            Ok(p) => p,\n-            Err(..) => return None,\n-        };\n-        (move || -> io::Result<_> {\n-            let mut max = None;\n-            let mut max_s = None;\n-            for entry in try!(fs::read_dir(&sdk_dir.join(\"Lib\"))) {\n-                let entry = try!(entry);\n-                if let Ok(s) = entry.file_name().into_string() {\n-                    if let Ok(u) = s.replace(\".\", \"\").parse::<usize>() {\n-                        if Some(u) > max {\n-                            max = Some(u);\n-                            max_s = Some(s);\n-                        }\n-                    }\n-                }\n-            }\n-            Ok(max_s.map(|m| (sdk_dir, m)))\n-        })().ok().and_then(|x| x)\n-    }\n }\n \n+// If we're not on Windows, then there's no registry to search through and MSVC\n+// wouldn't be able to run, so we just call `link.exe` and hope for the best.\n #[cfg(not(windows))]\n pub fn link_exe_cmd(_sess: &Session) -> Command {\n     Command::new(\"link.exe\")"}, {"sha": "24179a0cccd226e30792fb01000a748299382d47", "filename": "src/librustc_trans/back/msvc/registry.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/915cb376e928e2afe6d7d247e3a1426aacfdc67d/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915cb376e928e2afe6d7d247e3a1426aacfdc67d/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs?ref=915cb376e928e2afe6d7d247e3a1426aacfdc67d", "patch": "@@ -11,7 +11,6 @@\n use std::io;\n use std::ffi::{OsString, OsStr};\n use std::os::windows::prelude::*;\n-use std::ops::RangeFrom;\n use std::ptr;\n use libc::{c_void, c_long};\n \n@@ -34,7 +33,6 @@ const KEY_NOTIFY: REGSAM = 0x0010;\n const SYNCHRONIZE: REGSAM = 0x00100000;\n const REG_SZ: DWORD = 1;\n const ERROR_SUCCESS: i32 = 0;\n-const ERROR_NO_MORE_ITEMS: DWORD = 259;\n \n enum __HKEY__ {}\n pub type HKEY = *mut __HKEY__;\n@@ -56,14 +54,6 @@ extern \"system\" {\n                         lpType: LPDWORD,\n                         lpData: LPBYTE,\n                         lpcbData: LPDWORD) -> LONG;\n-    fn RegEnumKeyExW(hKey: HKEY,\n-                     dwIndex: DWORD,\n-                     lpName: LPWSTR,\n-                     lpcName: LPDWORD,\n-                     lpReserved: LPDWORD,\n-                     lpClass: LPWSTR,\n-                     lpcClass: LPDWORD,\n-                     lpftLastWriteTime: PFILETIME) -> LONG;\n     fn RegCloseKey(hKey: HKEY) -> LONG;\n }\n \n@@ -76,11 +66,6 @@ enum Repr {\n     Owned(OwnedKey),\n }\n \n-pub struct Iter<'a> {\n-    idx: RangeFrom<DWORD>,\n-    key: &'a RegistryKey,\n-}\n-\n unsafe impl Sync for RegistryKey {}\n unsafe impl Send for RegistryKey {}\n \n@@ -108,10 +93,6 @@ impl RegistryKey {\n         }\n     }\n \n-    pub fn iter(&self) -> Iter {\n-        Iter { idx: 0.., key: self }\n-    }\n-\n     pub fn query_str(&self, name: &str) -> io::Result<OsString> {\n         let name: &OsStr = name.as_ref();\n         let name = name.encode_wide().chain(Some(0)).collect::<Vec<_>>();\n@@ -155,25 +136,3 @@ impl Drop for OwnedKey {\n         unsafe { RegCloseKey(self.0); }\n     }\n }\n-\n-impl<'a> Iterator for Iter<'a> {\n-    type Item = io::Result<OsString>;\n-\n-    fn next(&mut self) -> Option<io::Result<OsString>> {\n-        self.idx.next().and_then(|i| unsafe {\n-            let mut v = Vec::with_capacity(256);\n-            let mut len = v.capacity() as DWORD;\n-            let ret = RegEnumKeyExW(self.key.raw(), i, v.as_mut_ptr(), &mut len,\n-                                    ptr::null_mut(), ptr::null_mut(), ptr::null_mut(),\n-                                    ptr::null_mut());\n-            if ret == ERROR_NO_MORE_ITEMS as LONG {\n-                None\n-            } else if ret != ERROR_SUCCESS {\n-                Some(Err(io::Error::from_raw_os_error(ret as i32)))\n-            } else {\n-                v.set_len(len as usize);\n-                Some(Ok(OsString::from_wide(&v)))\n-            }\n-        })\n-    }\n-}"}]}