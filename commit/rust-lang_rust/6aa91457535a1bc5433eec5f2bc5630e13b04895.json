{"sha": "6aa91457535a1bc5433eec5f2bc5630e13b04895", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYTkxNDU3NTM1YTFiYzU0MzNlZWM1ZjJiYzU2MzBlMTNiMDQ4OTU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-27T02:29:59Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-27T06:40:54Z"}, "message": "Avoid using the hir map when visibility checking in `resolve`\n\nRefactor `ty::Visibility` methods to use a new trait `NodeIdTree` instead of the ast map.", "tree": {"sha": "a3c29adaf051fab42f71d2113ac618340e94e884", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3c29adaf051fab42f71d2113ac618340e94e884"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6aa91457535a1bc5433eec5f2bc5630e13b04895", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6aa91457535a1bc5433eec5f2bc5630e13b04895", "html_url": "https://github.com/rust-lang/rust/commit/6aa91457535a1bc5433eec5f2bc5630e13b04895", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6aa91457535a1bc5433eec5f2bc5630e13b04895/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33bb26998c3ef4982a4e838a626e6837f602263a", "url": "https://api.github.com/repos/rust-lang/rust/commits/33bb26998c3ef4982a4e838a626e6837f602263a", "html_url": "https://github.com/rust-lang/rust/commit/33bb26998c3ef4982a4e838a626e6837f602263a"}], "stats": {"total": 60, "additions": 44, "deletions": 16}, "files": [{"sha": "0c23f5332982dc5620419d139b394aca38b8e9e7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6aa91457535a1bc5433eec5f2bc5630e13b04895/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa91457535a1bc5433eec5f2bc5630e13b04895/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6aa91457535a1bc5433eec5f2bc5630e13b04895", "patch": "@@ -283,6 +283,22 @@ pub enum Visibility {\n     PrivateExternal,\n }\n \n+pub trait NodeIdTree {\n+    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool;\n+}\n+\n+impl<'a> NodeIdTree for ast_map::Map<'a> {\n+    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n+        let mut node_ancestor = node;\n+        loop {\n+            if node_ancestor == ancestor { return true }\n+            let node_ancestor_parent = self.get_module_parent(node_ancestor);\n+            if node_ancestor_parent == node_ancestor { return false }\n+            node_ancestor = node_ancestor_parent;\n+        }\n+    }\n+}\n+\n impl Visibility {\n     pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: &TyCtxt) -> Self {\n         match *visibility {\n@@ -301,7 +317,7 @@ impl Visibility {\n     }\n \n     /// Returns true if an item with this visibility is accessible from the given block.\n-    pub fn is_accessible_from(self, block: NodeId, map: &ast_map::Map) -> bool {\n+    pub fn is_accessible_from<T: NodeIdTree>(self, block: NodeId, tree: &T) -> bool {\n         let restriction = match self {\n             // Public items are visible everywhere.\n             Visibility::Public => return true,\n@@ -311,24 +327,18 @@ impl Visibility {\n             Visibility::Restricted(module) => module,\n         };\n \n-        let mut block_ancestor = block;\n-        loop {\n-            if block_ancestor == restriction { return true }\n-            let block_ancestor_parent = map.get_module_parent(block_ancestor);\n-            if block_ancestor_parent == block_ancestor { return false }\n-            block_ancestor = block_ancestor_parent;\n-        }\n+        tree.is_descendant_of(block, restriction)\n     }\n \n     /// Returns true if this visibility is at least as accessible as the given visibility\n-    pub fn is_at_least(self, vis: Visibility, map: &ast_map::Map) -> bool {\n+    pub fn is_at_least<T: NodeIdTree>(self, vis: Visibility, tree: &T) -> bool {\n         let vis_restriction = match vis {\n             Visibility::Public => return self == Visibility::Public,\n             Visibility::PrivateExternal => return true,\n             Visibility::Restricted(module) => module,\n         };\n \n-        self.is_accessible_from(vis_restriction, map)\n+        self.is_accessible_from(vis_restriction, tree)\n     }\n }\n "}, {"sha": "fdb834a32fbc65564debf27b02799e802bebf036", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6aa91457535a1bc5433eec5f2bc5630e13b04895/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa91457535a1bc5433eec5f2bc5630e13b04895/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6aa91457535a1bc5433eec5f2bc5630e13b04895", "patch": "@@ -1121,6 +1121,21 @@ impl<'a> ResolverArenas<'a> {\n     }\n }\n \n+impl<'a, 'tcx> ty::NodeIdTree for Resolver<'a, 'tcx> {\n+    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n+        let ancestor = self.ast_map.local_def_id(ancestor);\n+        let mut module = *self.module_map.get(&node).unwrap();\n+        loop {\n+            if module.def_id() == Some(ancestor) { return true; }\n+            let module_parent = match self.get_nearest_normal_module_parent(module) {\n+                Some(parent) => parent,\n+                None => return false,\n+            };\n+            module = module_parent;\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn new(session: &'a Session,\n            ast_map: &'a hir_map::Map<'tcx>,\n@@ -1131,6 +1146,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let graph_root =\n             ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, arenas);\n         let graph_root = arenas.alloc_module(graph_root);\n+        let mut module_map = NodeMap();\n+        module_map.insert(CRATE_NODE_ID, graph_root);\n \n         Resolver {\n             session: session,\n@@ -1161,7 +1178,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             freevars_seen: NodeMap(),\n             export_map: NodeMap(),\n             trait_map: NodeMap(),\n-            module_map: NodeMap(),\n+            module_map: module_map,\n             used_imports: HashSet::new(),\n             used_crates: HashSet::new(),\n \n@@ -3343,7 +3360,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn is_accessible(&self, vis: ty::Visibility) -> bool {\n         let current_module = self.get_nearest_normal_module_parent_or_self(self.current_module);\n         let node_id = self.ast_map.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n-        vis.is_accessible_from(node_id, &self.ast_map)\n+        vis.is_accessible_from(node_id, self)\n     }\n \n     fn check_privacy(&mut self, name: Name, binding: &'a NameBinding<'a>, span: Span) {"}, {"sha": "f0639a8517686e343f8d0a450e6255d34a60e07b", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6aa91457535a1bc5433eec5f2bc5630e13b04895/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa91457535a1bc5433eec5f2bc5630e13b04895/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=6aa91457535a1bc5433eec5f2bc5630e13b04895", "patch": "@@ -552,9 +552,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             _ => (),\n         }\n \n-        let ast_map = self.resolver.ast_map;\n         match (&value_result, &type_result) {\n-            (&Success(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis, ast_map) &&\n+            (&Success(binding), _) if !binding.pseudo_vis()\n+                                              .is_at_least(directive.vis, self.resolver) &&\n                                       self.resolver.is_accessible(binding.vis) => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"consider marking `{}` as `pub` in the imported module\",\n@@ -564,7 +564,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     .emit();\n             }\n \n-            (_, &Success(binding)) if !binding.pseudo_vis().is_at_least(directive.vis, ast_map) &&\n+            (_, &Success(binding)) if !binding.pseudo_vis()\n+                                              .is_at_least(directive.vis, self.resolver) &&\n                                       self.resolver.is_accessible(binding.vis) => {\n                 if binding.is_extern_crate() {\n                     let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n@@ -691,7 +692,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n             if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n                 if ns == TypeNS && orig_binding.is_variant() &&\n-                   !orig_binding.vis.is_at_least(binding.vis, &self.resolver.ast_map) {\n+                   !orig_binding.vis.is_at_least(binding.vis, self.resolver) {\n                     let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring its enum as `pub`\",\n                                       name);"}]}