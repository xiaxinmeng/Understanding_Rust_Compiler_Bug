{"sha": "a64b7698a44c2bf090049798a6fac906e96296ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NGI3Njk4YTQ0YzJiZjA5MDA0OTc5OGE2ZmFjOTA2ZTk2Mjk2ZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-13T00:39:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-13T00:39:34Z"}, "message": "Auto merge of #7661 - camsteffen:eta, r=giraffate\n\nFix various redundant_closure bugs\n\nchangelog: Fix various false negatives and false positives for [`redundant_closure`]\n\nCloses #3071\nCloses #4002\n\nThis lint is full of weird nuances and this is basically a re-write to tighten up the logic.", "tree": {"sha": "feddb871e43eb71d838923950e4fefe45c1b2ac3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/feddb871e43eb71d838923950e4fefe45c1b2ac3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a64b7698a44c2bf090049798a6fac906e96296ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a64b7698a44c2bf090049798a6fac906e96296ec", "html_url": "https://github.com/rust-lang/rust/commit/a64b7698a44c2bf090049798a6fac906e96296ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a64b7698a44c2bf090049798a6fac906e96296ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2636a1b7b573bf82428238ab8e848e11af46ca8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2636a1b7b573bf82428238ab8e848e11af46ca8c", "html_url": "https://github.com/rust-lang/rust/commit/2636a1b7b573bf82428238ab8e848e11af46ca8c"}, {"sha": "ae2a95fadc098b326f2114fc5ee6f55ee0db81a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae2a95fadc098b326f2114fc5ee6f55ee0db81a8", "html_url": "https://github.com/rust-lang/rust/commit/ae2a95fadc098b326f2114fc5ee6f55ee0db81a8"}], "stats": {"total": 559, "additions": 272, "deletions": 287}, "files": [{"sha": "6c861fb33a9787fa407b7b2d7cd536697a30b0bc", "filename": "clippy_lints/src/disallowed_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_lints%2Fsrc%2Fdisallowed_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_lints%2Fsrc%2Fdisallowed_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_type.rs?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -48,7 +48,7 @@ impl DisallowedType {\n         Self {\n             disallowed: disallowed\n                 .iter()\n-                .map(|s| s.split(\"::\").map(|seg| Symbol::intern(seg)).collect::<Vec<_>>())\n+                .map(|s| s.split(\"::\").map(Symbol::intern).collect::<Vec<_>>())\n                 .collect(),\n             def_ids: FxHashSet::default(),\n             prim_tys: FxHashSet::default(),"}, {"sha": "9df92cc5b640667faf06c1f63dcf3b3b634d7541", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 92, "deletions": 148, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -1,16 +1,16 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::higher::VecArgs;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{implements_trait, type_is_unsafe_function};\n use clippy_utils::usage::UsedAfterExprVisitor;\n-use clippy_utils::{get_enclosing_loop_or_closure, higher};\n-use clippy_utils::{is_adjusted, iter_input_pats};\n+use clippy_utils::{get_enclosing_loop_or_closure, higher, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{def_id, Expr, ExprKind, Param, PatKind, QPath};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, ClosureKind, Ty};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Expr, ExprKind, Param, PatKind, Unsafety};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n+use rustc_middle::ty::subst::Subst;\n+use rustc_middle::ty::{self, ClosureKind, Ty, TypeFoldable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -52,12 +52,6 @@ declare_clippy_lint! {\n     /// ### Why is this bad?\n     /// It's unnecessary to create the closure.\n     ///\n-    /// ### Known problems\n-    /// [#3071](https://github.com/rust-lang/rust-clippy/issues/3071),\n-    /// [#3942](https://github.com/rust-lang/rust-clippy/issues/3942),\n-    /// [#4002](https://github.com/rust-lang/rust-clippy/issues/4002)\n-    ///\n-    ///\n     /// ### Example\n     /// ```rust,ignore\n     /// Some('a').map(|s| s.to_uppercase());\n@@ -75,32 +69,16 @@ declare_lint_pass!(EtaReduction => [REDUNDANT_CLOSURE, REDUNDANT_CLOSURE_FOR_MET\n \n impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if in_external_macro(cx.sess(), expr.span) {\n+        if expr.span.from_expansion() {\n             return;\n         }\n-\n-        match expr.kind {\n-            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) => {\n-                for arg in args {\n-                    // skip `foo(macro!())`\n-                    if arg.span.ctxt() == expr.span.ctxt() {\n-                        check_closure(cx, arg);\n-                    }\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-}\n-\n-fn check_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Closure(_, decl, eid, _, _) = expr.kind {\n-        let body = cx.tcx.hir().body(eid);\n-        let ex = &body.value;\n-\n-        if ex.span.ctxt() != expr.span.ctxt() {\n-            if decl.inputs.is_empty() {\n-                if let Some(VecArgs::Vec(&[])) = higher::VecArgs::hir(cx, ex) {\n+        let body = match expr.kind {\n+            ExprKind::Closure(_, _, id, _, _) => cx.tcx.hir().body(id),\n+            _ => return,\n+        };\n+        if body.value.span.from_expansion() {\n+            if body.params.is_empty() {\n+                if let Some(VecArgs::Vec(&[])) = higher::VecArgs::hir(cx, &body.value) {\n                     // replace `|| vec![]` with `Vec::new`\n                     span_lint_and_sugg(\n                         cx,\n@@ -117,33 +95,30 @@ fn check_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n             return;\n         }\n \n-        if_chain!(\n-            if let ExprKind::Call(caller, args) = ex.kind;\n-\n-            if let ExprKind::Path(_) = caller.kind;\n-\n-            // Not the same number of arguments, there is no way the closure is the same as the function return;\n-            if args.len() == decl.inputs.len();\n-\n-            // Are the expression or the arguments type-adjusted? Then we need the closure\n-            if !(is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)));\n-\n-            let fn_ty = cx.typeck_results().expr_ty(caller);\n-\n-            if matches!(fn_ty.kind(), ty::FnDef(_, _) | ty::FnPtr(_) | ty::Closure(_, _));\n-\n-            if !type_is_unsafe_function(cx, fn_ty);\n-\n-            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n+        let closure_ty = cx.typeck_results().expr_ty(expr);\n \n+        if_chain!(\n+            if let ExprKind::Call(callee, args) = body.value.kind;\n+            if let ExprKind::Path(_) = callee.kind;\n+            if check_inputs(cx, body.params, args);\n+            let callee_ty = cx.typeck_results().expr_ty_adjusted(callee);\n+            let call_ty = cx.typeck_results().type_dependent_def_id(body.value.hir_id)\n+                .map_or(callee_ty, |id| cx.tcx.type_of(id));\n+            if check_sig(cx, closure_ty, call_ty);\n+            let substs = cx.typeck_results().node_substs(callee.hir_id);\n+            // This fixes some false positives that I don't entirely understand\n+            if substs.is_empty() || !cx.typeck_results().expr_ty(expr).has_late_bound_regions();\n+            // A type param function ref like `T::f` is not 'static, however\n+            // it is if cast like `T::f as fn()`. This seems like a rustc bug.\n+            if !substs.types().any(|t| matches!(t.kind(), ty::Param(_)));\n             then {\n                 span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure\", |diag| {\n-                    if let Some(mut snippet) = snippet_opt(cx, caller.span) {\n+                    if let Some(mut snippet) = snippet_opt(cx, callee.span) {\n                         if_chain! {\n-                            if let ty::Closure(_, substs) = fn_ty.kind();\n+                            if let ty::Closure(_, substs) = callee_ty.peel_refs().kind();\n                             if let ClosureKind::FnMut = substs.as_closure().kind();\n-                            if UsedAfterExprVisitor::is_found(cx, caller)\n-                                || get_enclosing_loop_or_closure(cx.tcx, expr).is_some();\n+                            if get_enclosing_loop_or_closure(cx.tcx, expr).is_some()\n+                                || UsedAfterExprVisitor::is_found(cx, callee);\n \n                             then {\n                                 // Mutable closure is used after current expr; we cannot consume it.\n@@ -162,110 +137,79 @@ fn check_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         );\n \n         if_chain!(\n-            if let ExprKind::MethodCall(path, _, args, _) = ex.kind;\n-\n-            // Not the same number of arguments, there is no way the closure is the same as the function return;\n-            if args.len() == decl.inputs.len();\n-\n-            // Are the expression or the arguments type-adjusted? Then we need the closure\n-            if !(is_adjusted(cx, ex) || args.iter().skip(1).any(|arg| is_adjusted(cx, arg)));\n-\n-            let method_def_id = cx.typeck_results().type_dependent_def_id(ex.hir_id).unwrap();\n-            if !type_is_unsafe_function(cx, cx.tcx.type_of(method_def_id));\n-\n-            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n-\n-            if let Some(name) = get_ufcs_type_name(cx, method_def_id, &args[0]);\n-\n+            if let ExprKind::MethodCall(path, _, args, _) = body.value.kind;\n+            if check_inputs(cx, body.params, args);\n+            let method_def_id = cx.typeck_results().type_dependent_def_id(body.value.hir_id).unwrap();\n+            let substs = cx.typeck_results().node_substs(body.value.hir_id);\n+            let call_ty = cx.tcx.type_of(method_def_id).subst(cx.tcx, substs);\n+            if check_sig(cx, closure_ty, call_ty);\n             then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    REDUNDANT_CLOSURE_FOR_METHOD_CALLS,\n-                    expr.span,\n-                    \"redundant closure\",\n-                    \"replace the closure with the method itself\",\n-                    format!(\"{}::{}\", name, path.ident.name),\n-                    Applicability::MachineApplicable,\n-                );\n+                span_lint_and_then(cx, REDUNDANT_CLOSURE_FOR_METHOD_CALLS, expr.span, \"redundant closure\", |diag| {\n+                    let name = get_ufcs_type_name(cx, method_def_id);\n+                    diag.span_suggestion(\n+                        expr.span,\n+                        \"replace the closure with the method itself\",\n+                        format!(\"{}::{}\", name, path.ident.name),\n+                        Applicability::MachineApplicable,\n+                    );\n+                })\n             }\n         );\n     }\n }\n \n-/// Tries to determine the type for universal function call to be used instead of the closure\n-fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_arg: &Expr<'_>) -> Option<String> {\n-    let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0];\n-    let actual_type_of_self = &cx.typeck_results().node_type(self_arg.hir_id);\n-\n-    if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n-        if match_borrow_depth(expected_type_of_self, actual_type_of_self)\n-            && implements_trait(cx, actual_type_of_self, trait_id, &[])\n-        {\n-            return Some(cx.tcx.def_path_str(trait_id));\n-        }\n+fn check_inputs(cx: &LateContext<'_>, params: &[Param<'_>], call_args: &[Expr<'_>]) -> bool {\n+    if params.len() != call_args.len() {\n+        return false;\n     }\n-\n-    cx.tcx.impl_of_method(method_def_id).and_then(|_| {\n-        //a type may implicitly implement other type's methods (e.g. Deref)\n-        if match_types(expected_type_of_self, actual_type_of_self) {\n-            Some(get_type_name(cx, actual_type_of_self))\n-        } else {\n-            None\n+    std::iter::zip(params, call_args).all(|(param, arg)| {\n+        match param.pat.kind {\n+            PatKind::Binding(_, id, ..) if path_to_local_id(arg, id) => {},\n+            _ => return false,\n+        }\n+        match *cx.typeck_results().expr_adjustments(arg) {\n+            [] => true,\n+            [Adjustment {\n+                kind: Adjust::Deref(None),\n+                ..\n+            }, Adjustment {\n+                kind: Adjust::Borrow(AutoBorrow::Ref(_, mu2)),\n+                ..\n+            }] => {\n+                // re-borrow with the same mutability is allowed\n+                let ty = cx.typeck_results().expr_ty(arg);\n+                matches!(*ty.kind(), ty::Ref(.., mu1) if mu1 == mu2.into())\n+            },\n+            _ => false,\n         }\n     })\n }\n \n-fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n-    match (&lhs.kind(), &rhs.kind()) {\n-        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(t1, t2),\n-        (l, r) => !matches!((l, r), (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _))),\n-    }\n-}\n-\n-fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n-    match (&lhs.kind(), &rhs.kind()) {\n-        (ty::Bool, ty::Bool)\n-        | (ty::Char, ty::Char)\n-        | (ty::Int(_), ty::Int(_))\n-        | (ty::Uint(_), ty::Uint(_))\n-        | (ty::Str, ty::Str) => true,\n-        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_types(t1, t2),\n-        (ty::Array(t1, _), ty::Array(t2, _)) | (ty::Slice(t1), ty::Slice(t2)) => match_types(t1, t2),\n-        (ty::Adt(def1, _), ty::Adt(def2, _)) => def1 == def2,\n-        (_, _) => false,\n+fn check_sig<'tcx>(cx: &LateContext<'tcx>, closure_ty: Ty<'tcx>, call_ty: Ty<'tcx>) -> bool {\n+    let call_sig = call_ty.fn_sig(cx.tcx);\n+    if call_sig.unsafety() == Unsafety::Unsafe {\n+        return false;\n     }\n-}\n-\n-fn get_type_name(cx: &LateContext<'_>, ty: Ty<'_>) -> String {\n-    match ty.kind() {\n-        ty::Adt(t, _) => cx.tcx.def_path_str(t.did),\n-        ty::Ref(_, r, _) => get_type_name(cx, r),\n-        _ => ty.to_string(),\n+    if !closure_ty.has_late_bound_regions() {\n+        return true;\n     }\n+    let substs = match closure_ty.kind() {\n+        ty::Closure(_, substs) => substs,\n+        _ => return false,\n+    };\n+    let closure_sig = cx.tcx.signature_unclosure(substs.as_closure().sig(), Unsafety::Normal);\n+    cx.tcx.erase_late_bound_regions(closure_sig) == cx.tcx.erase_late_bound_regions(call_sig)\n }\n \n-fn compare_inputs(\n-    closure_inputs: &mut dyn Iterator<Item = &Param<'_>>,\n-    call_args: &mut dyn Iterator<Item = &Expr<'_>>,\n-) -> bool {\n-    for (closure_input, function_arg) in closure_inputs.zip(call_args) {\n-        if let PatKind::Binding(_, _, ident, _) = closure_input.pat.kind {\n-            // XXXManishearth Should I be checking the binding mode here?\n-            if let ExprKind::Path(QPath::Resolved(None, p)) = function_arg.kind {\n-                if p.segments.len() != 1 {\n-                    // If it's a proper path, it can't be a local variable\n-                    return false;\n-                }\n-                if p.segments[0].ident.name != ident.name {\n-                    // The two idents should be the same\n-                    return false;\n-                }\n-            } else {\n-                return false;\n+fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: DefId) -> String {\n+    match cx.tcx.associated_item(method_def_id).container {\n+        ty::TraitContainer(def_id) => cx.tcx.def_path_str(def_id),\n+        ty::ImplContainer(def_id) => {\n+            let ty = cx.tcx.type_of(def_id);\n+            match ty.kind() {\n+                ty::Adt(adt, _) => cx.tcx.def_path_str(adt.did),\n+                _ => ty.to_string(),\n             }\n-        } else {\n-            return false;\n-        }\n+        },\n     }\n-    true\n }"}, {"sha": "508cac33848f76d0b081bbc5189c3882894c2fa3", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -69,8 +69,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n                     ty::Str => true,\n                     _ => false,\n                 };\n-                if format_args.args.iter().all(|e| is_display_arg(e));\n-                if format_args.fmt_expr.map_or(true, |e| check_unformatted(e));\n+                if format_args.args.iter().all(is_display_arg);\n+                if format_args.fmt_expr.map_or(true, check_unformatted);\n                 then {\n                     let is_new_string = match value.kind {\n                         ExprKind::Binary(..) => true,"}, {"sha": "4dcd5c87722eec0f8c9e43f0e4f9fa6a4efc0cc5", "filename": "clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -65,7 +65,7 @@ fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n-        ExprKind::Block(b, _) => extract_first_expr(b).map_or(false, |subexpr| is_simple_break_expr(subexpr)),\n+        ExprKind::Block(b, _) => extract_first_expr(b).map_or(false, is_simple_break_expr),\n         _ => false,\n     }\n }"}, {"sha": "d696e17d656d49fd2427762e37657ac864ea373e", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -372,7 +372,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n             for (_, ref mutbl, ref argspan) in decl\n                 .inputs\n                 .iter()\n-                .filter_map(|ty| get_rptr_lm(ty))\n+                .filter_map(get_rptr_lm)\n                 .filter(|&(lt, _, _)| lt.name == out.name)\n             {\n                 if *mutbl == Mutability::Mut {"}, {"sha": "2fa98831c7740aa31e7765ddf463cb36eba3d658", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 37, "deletions": 48, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -46,15 +46,12 @@ pub fn eq_pat(l: &Pat, r: &Pat) -> bool {\n         | (Ref(l, Mutability::Not), Ref(r, Mutability::Not))\n         | (Ref(l, Mutability::Mut), Ref(r, Mutability::Mut)) => eq_pat(l, r),\n         (Tuple(l), Tuple(r)) | (Slice(l), Slice(r)) => over(l, r, |l, r| eq_pat(l, r)),\n-        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n+        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, eq_qself) && eq_path(lp, rp),\n         (TupleStruct(lqself, lp, lfs), TupleStruct(rqself, rp, rfs)) => {\n             eq_maybe_qself(lqself, rqself) && eq_path(lp, rp) && over(lfs, rfs, |l, r| eq_pat(l, r))\n         },\n         (Struct(lqself, lp, lfs, lr), Struct(rqself, rp, rfs, rr)) => {\n-            lr == rr\n-                && eq_maybe_qself(lqself, rqself)\n-                && eq_path(lp, rp)\n-                && unordered_over(lfs, rfs, |lf, rf| eq_field_pat(lf, rf))\n+            lr == rr && eq_maybe_qself(lqself, rqself) && eq_path(lp, rp) && unordered_over(lfs, rfs, eq_field_pat)\n         },\n         (Or(ls), Or(rs)) => unordered_over(ls, rs, |l, r| eq_pat(l, r)),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n@@ -76,7 +73,7 @@ pub fn eq_field_pat(l: &PatField, r: &PatField) -> bool {\n     l.is_placeholder == r.is_placeholder\n         && eq_id(l.ident, r.ident)\n         && eq_pat(&l.pat, &r.pat)\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && over(&l.attrs, &r.attrs, eq_attr)\n }\n \n pub fn eq_qself(l: &QSelf, r: &QSelf) -> bool {\n@@ -92,7 +89,7 @@ pub fn eq_maybe_qself(l: &Option<QSelf>, r: &Option<QSelf>) -> bool {\n }\n \n pub fn eq_path(l: &Path, r: &Path) -> bool {\n-    over(&l.segments, &r.segments, |l, r| eq_path_seg(l, r))\n+    over(&l.segments, &r.segments, eq_path_seg)\n }\n \n pub fn eq_path_seg(l: &PathSegment, r: &PathSegment) -> bool {\n@@ -101,9 +98,7 @@ pub fn eq_path_seg(l: &PathSegment, r: &PathSegment) -> bool {\n \n pub fn eq_generic_args(l: &GenericArgs, r: &GenericArgs) -> bool {\n     match (l, r) {\n-        (GenericArgs::AngleBracketed(l), GenericArgs::AngleBracketed(r)) => {\n-            over(&l.args, &r.args, |l, r| eq_angle_arg(l, r))\n-        },\n+        (GenericArgs::AngleBracketed(l), GenericArgs::AngleBracketed(r)) => over(&l.args, &r.args, eq_angle_arg),\n         (GenericArgs::Parenthesized(l), GenericArgs::Parenthesized(r)) => {\n             over(&l.inputs, &r.inputs, |l, r| eq_ty(l, r)) && eq_fn_ret_ty(&l.output, &r.output)\n         },\n@@ -142,7 +137,7 @@ pub fn eq_struct_rest(l: &StructRest, r: &StructRest) -> bool {\n \n pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n     use ExprKind::*;\n-    if !over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r)) {\n+    if !over(&l.attrs, &r.attrs, eq_attr) {\n         return false;\n     }\n     match (&l.kind, &r.kind) {\n@@ -173,20 +168,20 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Assign(l1, l2, _), Assign(r1, r2, _)) | (Index(l1, l2), Index(r1, r2)) => eq_expr(l1, r1) && eq_expr(l2, r2),\n         (AssignOp(lo, lp, lv), AssignOp(ro, rp, rv)) => lo.node == ro.node && eq_expr(lp, rp) && eq_expr(lv, rv),\n         (Field(lp, lf), Field(rp, rf)) => eq_id(*lf, *rf) && eq_expr(lp, rp),\n-        (Match(ls, la), Match(rs, ra)) => eq_expr(ls, rs) && over(la, ra, |l, r| eq_arm(l, r)),\n+        (Match(ls, la), Match(rs, ra)) => eq_expr(ls, rs) && over(la, ra, eq_arm),\n         (Closure(lc, la, lm, lf, lb, _), Closure(rc, ra, rm, rf, rb, _)) => {\n             lc == rc && la.is_async() == ra.is_async() && lm == rm && eq_fn_decl(lf, rf) && eq_expr(lb, rb)\n         },\n         (Async(lc, _, lb), Async(rc, _, rb)) => lc == rc && eq_block(lb, rb),\n         (Range(lf, lt, ll), Range(rf, rt, rl)) => ll == rl && eq_expr_opt(lf, rf) && eq_expr_opt(lt, rt),\n         (AddrOf(lbk, lm, le), AddrOf(rbk, rm, re)) => lbk == rbk && lm == rm && eq_expr(le, re),\n-        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n+        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, eq_qself) && eq_path(lp, rp),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n         (Struct(lse), Struct(rse)) => {\n             eq_maybe_qself(&lse.qself, &rse.qself)\n                 && eq_path(&lse.path, &rse.path)\n                 && eq_struct_rest(&lse.rest, &rse.rest)\n-                && unordered_over(&lse.fields, &rse.fields, |l, r| eq_field(l, r))\n+                && unordered_over(&lse.fields, &rse.fields, eq_field)\n         },\n         _ => false,\n     }\n@@ -196,23 +191,23 @@ pub fn eq_field(l: &ExprField, r: &ExprField) -> bool {\n     l.is_placeholder == r.is_placeholder\n         && eq_id(l.ident, r.ident)\n         && eq_expr(&l.expr, &r.expr)\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && over(&l.attrs, &r.attrs, eq_attr)\n }\n \n pub fn eq_arm(l: &Arm, r: &Arm) -> bool {\n     l.is_placeholder == r.is_placeholder\n         && eq_pat(&l.pat, &r.pat)\n         && eq_expr(&l.body, &r.body)\n         && eq_expr_opt(&l.guard, &r.guard)\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && over(&l.attrs, &r.attrs, eq_attr)\n }\n \n pub fn eq_label(l: &Option<Label>, r: &Option<Label>) -> bool {\n     both(l, r, |l, r| eq_id(l.ident, r.ident))\n }\n \n pub fn eq_block(l: &Block, r: &Block) -> bool {\n-    l.rules == r.rules && over(&l.stmts, &r.stmts, |l, r| eq_stmt(l, r))\n+    l.rules == r.rules && over(&l.stmts, &r.stmts, eq_stmt)\n }\n \n pub fn eq_stmt(l: &Stmt, r: &Stmt) -> bool {\n@@ -222,13 +217,13 @@ pub fn eq_stmt(l: &Stmt, r: &Stmt) -> bool {\n             eq_pat(&l.pat, &r.pat)\n                 && both(&l.ty, &r.ty, |l, r| eq_ty(l, r))\n                 && eq_local_kind(&l.kind, &r.kind)\n-                && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+                && over(&l.attrs, &r.attrs, eq_attr)\n         },\n         (Item(l), Item(r)) => eq_item(l, r, eq_item_kind),\n         (Expr(l), Expr(r)) | (Semi(l), Semi(r)) => eq_expr(l, r),\n         (Empty, Empty) => true,\n         (MacCall(l), MacCall(r)) => {\n-            l.style == r.style && eq_mac_call(&l.mac, &r.mac) && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+            l.style == r.style && eq_mac_call(&l.mac, &r.mac) && over(&l.attrs, &r.attrs, eq_attr)\n         },\n         _ => false,\n     }\n@@ -245,10 +240,7 @@ pub fn eq_local_kind(l: &LocalKind, r: &LocalKind) -> bool {\n }\n \n pub fn eq_item<K>(l: &Item<K>, r: &Item<K>, mut eq_kind: impl FnMut(&K, &K) -> bool) -> bool {\n-    eq_id(l.ident, r.ident)\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n-        && eq_vis(&l.vis, &r.vis)\n-        && eq_kind(&l.kind, &r.kind)\n+    eq_id(l.ident, r.ident) && over(&l.attrs, &r.attrs, eq_attr) && eq_vis(&l.vis, &r.vis) && eq_kind(&l.kind, &r.kind)\n }\n \n pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n@@ -272,29 +264,26 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n                 }\n         },\n         (ForeignMod(l), ForeignMod(r)) => {\n-            both(&l.abi, &r.abi, |l, r| eq_str_lit(l, r))\n-                && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_foreign_item_kind))\n+            both(&l.abi, &r.abi, eq_str_lit) && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_foreign_item_kind))\n         },\n         (TyAlias(box TyAliasKind(ld, lg, lb, lt)), TyAlias(box TyAliasKind(rd, rg, rb, rt))) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n-                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && over(lb, rb, eq_generic_bound)\n                 && both(lt, rt, |l, r| eq_ty(l, r))\n         },\n-        (Enum(le, lg), Enum(re, rg)) => {\n-            over(&le.variants, &re.variants, |l, r| eq_variant(l, r)) && eq_generics(lg, rg)\n-        },\n+        (Enum(le, lg), Enum(re, rg)) => over(&le.variants, &re.variants, eq_variant) && eq_generics(lg, rg),\n         (Struct(lv, lg), Struct(rv, rg)) | (Union(lv, lg), Union(rv, rg)) => {\n             eq_variant_data(lv, rv) && eq_generics(lg, rg)\n         },\n         (Trait(box TraitKind(la, lu, lg, lb, li)), Trait(box TraitKind(ra, ru, rg, rb, ri))) => {\n             la == ra\n                 && matches!(lu, Unsafe::No) == matches!(ru, Unsafe::No)\n                 && eq_generics(lg, rg)\n-                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && over(lb, rb, eq_generic_bound)\n                 && over(li, ri, |l, r| eq_item(l, r, eq_assoc_item_kind))\n         },\n-        (TraitAlias(lg, lb), TraitAlias(rg, rb)) => eq_generics(lg, rg) && over(lb, rb, |l, r| eq_generic_bound(l, r)),\n+        (TraitAlias(lg, lb), TraitAlias(rg, rb)) => eq_generics(lg, rg) && over(lb, rb, eq_generic_bound),\n         (\n             Impl(box ImplKind {\n                 unsafety: lu,\n@@ -342,7 +331,7 @@ pub fn eq_foreign_item_kind(l: &ForeignItemKind, r: &ForeignItemKind) -> bool {\n         (TyAlias(box TyAliasKind(ld, lg, lb, lt)), TyAlias(box TyAliasKind(rd, rg, rb, rt))) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n-                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && over(lb, rb, eq_generic_bound)\n                 && both(lt, rt, |l, r| eq_ty(l, r))\n         },\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n@@ -360,7 +349,7 @@ pub fn eq_assoc_item_kind(l: &AssocItemKind, r: &AssocItemKind) -> bool {\n         (TyAlias(box TyAliasKind(ld, lg, lb, lt)), TyAlias(box TyAliasKind(rd, rg, rb, rt))) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n-                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && over(lb, rb, eq_generic_bound)\n                 && both(lt, rt, |l, r| eq_ty(l, r))\n         },\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n@@ -370,7 +359,7 @@ pub fn eq_assoc_item_kind(l: &AssocItemKind, r: &AssocItemKind) -> bool {\n \n pub fn eq_variant(l: &Variant, r: &Variant) -> bool {\n     l.is_placeholder == r.is_placeholder\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && over(&l.attrs, &r.attrs, eq_attr)\n         && eq_vis(&l.vis, &r.vis)\n         && eq_id(l.ident, r.ident)\n         && eq_variant_data(&l.data, &r.data)\n@@ -381,14 +370,14 @@ pub fn eq_variant_data(l: &VariantData, r: &VariantData) -> bool {\n     use VariantData::*;\n     match (l, r) {\n         (Unit(_), Unit(_)) => true,\n-        (Struct(l, _), Struct(r, _)) | (Tuple(l, _), Tuple(r, _)) => over(l, r, |l, r| eq_struct_field(l, r)),\n+        (Struct(l, _), Struct(r, _)) | (Tuple(l, _), Tuple(r, _)) => over(l, r, eq_struct_field),\n         _ => false,\n     }\n }\n \n pub fn eq_struct_field(l: &FieldDef, r: &FieldDef) -> bool {\n     l.is_placeholder == r.is_placeholder\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && over(&l.attrs, &r.attrs, eq_attr)\n         && eq_vis(&l.vis, &r.vis)\n         && both(&l.ident, &r.ident, |l, r| eq_id(*l, *r))\n         && eq_ty(&l.ty, &r.ty)\n@@ -406,7 +395,7 @@ pub fn eq_fn_header(l: &FnHeader, r: &FnHeader) -> bool {\n }\n \n pub fn eq_generics(l: &Generics, r: &Generics) -> bool {\n-    over(&l.params, &r.params, |l, r| eq_generic_param(l, r))\n+    over(&l.params, &r.params, eq_generic_param)\n         && over(&l.where_clause.predicates, &r.where_clause.predicates, |l, r| {\n             eq_where_predicate(l, r)\n         })\n@@ -419,10 +408,10 @@ pub fn eq_where_predicate(l: &WherePredicate, r: &WherePredicate) -> bool {\n             over(&l.bound_generic_params, &r.bound_generic_params, |l, r| {\n                 eq_generic_param(l, r)\n             }) && eq_ty(&l.bounded_ty, &r.bounded_ty)\n-                && over(&l.bounds, &r.bounds, |l, r| eq_generic_bound(l, r))\n+                && over(&l.bounds, &r.bounds, eq_generic_bound)\n         },\n         (RegionPredicate(l), RegionPredicate(r)) => {\n-            eq_id(l.lifetime.ident, r.lifetime.ident) && over(&l.bounds, &r.bounds, |l, r| eq_generic_bound(l, r))\n+            eq_id(l.lifetime.ident, r.lifetime.ident) && over(&l.bounds, &r.bounds, eq_generic_bound)\n         },\n         (EqPredicate(l), EqPredicate(r)) => eq_ty(&l.lhs_ty, &r.lhs_ty) && eq_ty(&l.rhs_ty, &r.rhs_ty),\n         _ => false,\n@@ -469,7 +458,7 @@ pub fn eq_fn_decl(l: &FnDecl, r: &FnDecl) -> bool {\n             l.is_placeholder == r.is_placeholder\n                 && eq_pat(&l.pat, &r.pat)\n                 && eq_ty(&l.ty, &r.ty)\n-                && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+                && over(&l.attrs, &r.attrs, eq_attr)\n         })\n }\n \n@@ -496,13 +485,13 @@ pub fn eq_ty(l: &Ty, r: &Ty) -> bool {\n         (BareFn(l), BareFn(r)) => {\n             l.unsafety == r.unsafety\n                 && eq_ext(&l.ext, &r.ext)\n-                && over(&l.generic_params, &r.generic_params, |l, r| eq_generic_param(l, r))\n+                && over(&l.generic_params, &r.generic_params, eq_generic_param)\n                 && eq_fn_decl(&l.decl, &r.decl)\n         },\n         (Tup(l), Tup(r)) => over(l, r, |l, r| eq_ty(l, r)),\n-        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n-        (TraitObject(lg, ls), TraitObject(rg, rs)) => ls == rs && over(lg, rg, |l, r| eq_generic_bound(l, r)),\n-        (ImplTrait(_, lg), ImplTrait(_, rg)) => over(lg, rg, |l, r| eq_generic_bound(l, r)),\n+        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, eq_qself) && eq_path(lp, rp),\n+        (TraitObject(lg, ls), TraitObject(rg, rs)) => ls == rs && over(lg, rg, eq_generic_bound),\n+        (ImplTrait(_, lg), ImplTrait(_, rg)) => over(lg, rg, eq_generic_bound),\n         (Typeof(l), Typeof(r)) => eq_expr(&l.value, &r.value),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n         _ => false,\n@@ -533,7 +522,7 @@ pub fn eq_generic_param(l: &GenericParam, r: &GenericParam) -> bool {\n     use GenericParamKind::*;\n     l.is_placeholder == r.is_placeholder\n         && eq_id(l.ident, r.ident)\n-        && over(&l.bounds, &r.bounds, |l, r| eq_generic_bound(l, r))\n+        && over(&l.bounds, &r.bounds, eq_generic_bound)\n         && match (&l.kind, &r.kind) {\n             (Lifetime, Lifetime) => true,\n             (Type { default: l }, Type { default: r }) => both(l, r, |l, r| eq_ty(l, r)),\n@@ -548,10 +537,10 @@ pub fn eq_generic_param(l: &GenericParam, r: &GenericParam) -> bool {\n                     kw_span: _,\n                     default: rd,\n                 },\n-            ) => eq_ty(lt, rt) && both(ld, rd, |ld, rd| eq_anon_const(ld, rd)),\n+            ) => eq_ty(lt, rt) && both(ld, rd, eq_anon_const),\n             _ => false,\n         }\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && over(&l.attrs, &r.attrs, eq_attr)\n }\n \n pub fn eq_generic_bound(l: &GenericBound, r: &GenericBound) -> bool {\n@@ -568,7 +557,7 @@ pub fn eq_assoc_constraint(l: &AssocTyConstraint, r: &AssocTyConstraint) -> bool\n     eq_id(l.ident, r.ident)\n         && match (&l.kind, &r.kind) {\n             (Equality { ty: l }, Equality { ty: r }) => eq_ty(l, r),\n-            (Bound { bounds: l }, Bound { bounds: r }) => over(l, r, |l, r| eq_generic_bound(l, r)),\n+            (Bound { bounds: l }, Bound { bounds: r }) => over(l, r, eq_generic_bound),\n             _ => false,\n         }\n }"}, {"sha": "9650294fc7b879f93450bbf5da74bc64da5abda2", "filename": "clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -27,10 +27,9 @@ fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Lit(..) | ExprKind::ConstBlock(..) | ExprKind::Path(..) | ExprKind::Field(..) => true,\n         ExprKind::AddrOf(_, _, addr_of_expr) => identify_some_pure_patterns(addr_of_expr),\n-        ExprKind::Tup(tup_exprs) => tup_exprs.iter().all(|expr| identify_some_pure_patterns(expr)),\n+        ExprKind::Tup(tup_exprs) => tup_exprs.iter().all(identify_some_pure_patterns),\n         ExprKind::Struct(_, fields, expr) => {\n-            fields.iter().all(|f| identify_some_pure_patterns(f.expr))\n-                && expr.map_or(true, |e| identify_some_pure_patterns(e))\n+            fields.iter().all(|f| identify_some_pure_patterns(f.expr)) && expr.map_or(true, identify_some_pure_patterns)\n         },\n         ExprKind::Call(\n             &Expr {\n@@ -45,7 +44,7 @@ fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n                 ..\n             },\n             args,\n-        ) => args.iter().all(|expr| identify_some_pure_patterns(expr)),\n+        ) => args.iter().all(identify_some_pure_patterns),\n         ExprKind::Block(\n             &Block {\n                 stmts,"}, {"sha": "9d9a1a3e5003fe010e60c5c3194c012ef9fce015", "filename": "tests/ui/eta.fixed", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Feta.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Feta.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.fixed?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -14,7 +14,7 @@\n     clippy::needless_borrow\n )]\n \n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n \n macro_rules! mac {\n     () => {\n@@ -30,19 +30,18 @@ macro_rules! closure_mac {\n \n fn main() {\n     let a = Some(1u8).map(foo);\n-    meta(foo);\n     let c = Some(1u8).map(|a| {1+2; foo}(a));\n     true.then(|| mac!()); // don't lint function in macro expansion\n     Some(1).map(closure_mac!()); // don't lint closure in macro expansion\n     let _: Option<Vec<u8>> = true.then(std::vec::Vec::new); // special case vec!\n-    let d = Some(1u8).map(|a| foo((|b| foo2(b))(a))); //is adjusted?\n-    all(&[1, 2, 3], &2, |x, y| below(x, y)); //is adjusted\n+    let d = Some(1u8).map(|a| foo(foo2(a))); //is adjusted?\n+    all(&[1, 2, 3], &2, below); //is adjusted\n     unsafe {\n         Some(1u8).map(|a| unsafe_fn(a)); // unsafe fn\n     }\n \n     // See #815\n-    let e = Some(1u8).map(|a| divergent(a));\n+    let e = Some(1u8).map(divergent);\n     let e = Some(1u8).map(generic);\n     let e = Some(1u8).map(generic);\n     // See #515\n@@ -90,24 +89,17 @@ impl<'a> std::ops::Deref for TestStruct<'a> {\n fn test_redundant_closures_containing_method_calls() {\n     let i = 10;\n     let e = Some(TestStruct { some_ref: &i }).map(TestStruct::foo);\n-    let e = Some(TestStruct { some_ref: &i }).map(TestStruct::foo);\n     let e = Some(TestStruct { some_ref: &i }).map(TestTrait::trait_foo);\n     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo_ref());\n-    let e = Some(TestStruct { some_ref: &i }).map(TestTrait::trait_foo);\n-    let e = Some(&mut vec![1, 2, 3]).map(std::vec::Vec::clear);\n     let e = Some(&mut vec![1, 2, 3]).map(std::vec::Vec::clear);\n     unsafe {\n         let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo_unsafe());\n     }\n     let e = Some(\"str\").map(std::string::ToString::to_string);\n-    let e = Some(\"str\").map(str::to_string);\n-    let e = Some('a').map(char::to_uppercase);\n     let e = Some('a').map(char::to_uppercase);\n     let e: std::vec::Vec<usize> = vec!['a', 'b', 'c'].iter().map(|c| c.len_utf8()).collect();\n     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(char::to_ascii_uppercase).collect();\n-    let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(char::to_ascii_uppercase).collect();\n-    let p = Some(PathBuf::new());\n-    let e = p.as_ref().and_then(|s| s.to_str());\n+    let e = Some(PathBuf::new()).as_ref().and_then(|s| s.to_str());\n     let c = Some(TestStruct { some_ref: &i })\n         .as_ref()\n         .map(|c| c.to_ascii_uppercase());\n@@ -119,10 +111,6 @@ fn test_redundant_closures_containing_method_calls() {\n         t.iter().filter(|x| x.trait_foo_ref());\n         t.iter().map(|x| x.trait_foo_ref());\n     }\n-\n-    let mut some = Some(|x| x * x);\n-    let arr = [Ok(1), Err(2)];\n-    let _: Vec<_> = arr.iter().map(|x| x.map_err(|e| some.take().unwrap()(e))).collect();\n }\n \n struct Thunk<T>(Box<dyn FnMut() -> T>);\n@@ -145,13 +133,6 @@ fn foobar() {\n     thunk.unwrap()\n }\n \n-fn meta<F>(f: F)\n-where\n-    F: Fn(u8),\n-{\n-    f(1u8)\n-}\n-\n fn foo(_: u8) {}\n \n fn foo2(_: u8) -> u8 {\n@@ -180,7 +161,7 @@ fn generic<T>(_: T) -> u8 {\n }\n \n fn passes_fn_mut(mut x: Box<dyn FnMut()>) {\n-    requires_fn_once(|| x());\n+    requires_fn_once(x);\n }\n fn requires_fn_once<T: FnOnce()>(_: T) {}\n \n@@ -236,3 +217,35 @@ fn mutable_closure_in_loop() {\n         Some(1).map(&mut closure);\n     }\n }\n+\n+fn late_bound_lifetimes() {\n+    fn take_asref_path<P: AsRef<Path>>(path: P) {}\n+\n+    fn map_str<F>(thunk: F)\n+    where\n+        F: FnOnce(&str),\n+    {\n+    }\n+\n+    fn map_str_to_path<F>(thunk: F)\n+    where\n+        F: FnOnce(&str) -> &Path,\n+    {\n+    }\n+    map_str(|s| take_asref_path(s));\n+    map_str_to_path(std::convert::AsRef::as_ref);\n+}\n+\n+mod type_param_bound {\n+    trait Trait {\n+        fn fun();\n+    }\n+\n+    fn take<T: 'static>(_: T) {}\n+\n+    fn test<X: Trait>() {\n+        // don't lint, but it's questionable that rust requires a cast\n+        take(|| X::fun());\n+        take(X::fun as fn());\n+    }\n+}"}, {"sha": "3b53b9b28eb1497da86faa49266dbcb59a3ddc0c", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -14,7 +14,7 @@\n     clippy::needless_borrow\n )]\n \n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n \n macro_rules! mac {\n     () => {\n@@ -30,7 +30,6 @@ macro_rules! closure_mac {\n \n fn main() {\n     let a = Some(1u8).map(|a| foo(a));\n-    meta(|a| foo(a));\n     let c = Some(1u8).map(|a| {1+2; foo}(a));\n     true.then(|| mac!()); // don't lint function in macro expansion\n     Some(1).map(closure_mac!()); // don't lint closure in macro expansion\n@@ -90,24 +89,17 @@ impl<'a> std::ops::Deref for TestStruct<'a> {\n fn test_redundant_closures_containing_method_calls() {\n     let i = 10;\n     let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo());\n-    let e = Some(TestStruct { some_ref: &i }).map(TestStruct::foo);\n     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo());\n     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo_ref());\n-    let e = Some(TestStruct { some_ref: &i }).map(TestTrait::trait_foo);\n     let e = Some(&mut vec![1, 2, 3]).map(|v| v.clear());\n-    let e = Some(&mut vec![1, 2, 3]).map(std::vec::Vec::clear);\n     unsafe {\n         let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo_unsafe());\n     }\n     let e = Some(\"str\").map(|s| s.to_string());\n-    let e = Some(\"str\").map(str::to_string);\n     let e = Some('a').map(|s| s.to_uppercase());\n-    let e = Some('a').map(char::to_uppercase);\n     let e: std::vec::Vec<usize> = vec!['a', 'b', 'c'].iter().map(|c| c.len_utf8()).collect();\n     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(|c| c.to_ascii_uppercase()).collect();\n-    let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(char::to_ascii_uppercase).collect();\n-    let p = Some(PathBuf::new());\n-    let e = p.as_ref().and_then(|s| s.to_str());\n+    let e = Some(PathBuf::new()).as_ref().and_then(|s| s.to_str());\n     let c = Some(TestStruct { some_ref: &i })\n         .as_ref()\n         .map(|c| c.to_ascii_uppercase());\n@@ -119,10 +111,6 @@ fn test_redundant_closures_containing_method_calls() {\n         t.iter().filter(|x| x.trait_foo_ref());\n         t.iter().map(|x| x.trait_foo_ref());\n     }\n-\n-    let mut some = Some(|x| x * x);\n-    let arr = [Ok(1), Err(2)];\n-    let _: Vec<_> = arr.iter().map(|x| x.map_err(|e| some.take().unwrap()(e))).collect();\n }\n \n struct Thunk<T>(Box<dyn FnMut() -> T>);\n@@ -145,13 +133,6 @@ fn foobar() {\n     thunk.unwrap()\n }\n \n-fn meta<F>(f: F)\n-where\n-    F: Fn(u8),\n-{\n-    f(1u8)\n-}\n-\n fn foo(_: u8) {}\n \n fn foo2(_: u8) -> u8 {\n@@ -236,3 +217,35 @@ fn mutable_closure_in_loop() {\n         Some(1).map(|n| closure(n));\n     }\n }\n+\n+fn late_bound_lifetimes() {\n+    fn take_asref_path<P: AsRef<Path>>(path: P) {}\n+\n+    fn map_str<F>(thunk: F)\n+    where\n+        F: FnOnce(&str),\n+    {\n+    }\n+\n+    fn map_str_to_path<F>(thunk: F)\n+    where\n+        F: FnOnce(&str) -> &Path,\n+    {\n+    }\n+    map_str(|s| take_asref_path(s));\n+    map_str_to_path(|s| s.as_ref());\n+}\n+\n+mod type_param_bound {\n+    trait Trait {\n+        fn fun();\n+    }\n+\n+    fn take<T: 'static>(_: T) {}\n+\n+    fn test<X: Trait>() {\n+        // don't lint, but it's questionable that rust requires a cast\n+        take(|| X::fun());\n+        take(X::fun as fn());\n+    }\n+}"}, {"sha": "48d7e9e9c96262ee27ebe6387ef145dae6b709a1", "filename": "tests/ui/eta.stderr", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Feta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Feta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.stderr?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -7,104 +7,128 @@ LL |     let a = Some(1u8).map(|a| foo(a));\n    = note: `-D clippy::redundant-closure` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:33:10\n+  --> $DIR/eta.rs:36:40\n    |\n-LL |     meta(|a| foo(a));\n-   |          ^^^^^^^^^^ help: replace the closure with the function itself: `foo`\n+LL |     let _: Option<Vec<u8>> = true.then(|| vec![]); // special case vec!\n+   |                                        ^^^^^^^^^ help: replace the closure with `Vec::new`: `std::vec::Vec::new`\n \n error: redundant closure\n-  --> $DIR/eta.rs:37:40\n+  --> $DIR/eta.rs:37:35\n    |\n-LL |     let _: Option<Vec<u8>> = true.then(|| vec![]); // special case vec!\n-   |                                        ^^^^^^^^^ help: replace the closure with `Vec::new`: `std::vec::Vec::new`\n+LL |     let d = Some(1u8).map(|a| foo((|b| foo2(b))(a))); //is adjusted?\n+   |                                   ^^^^^^^^^^^^^ help: replace the closure with the function itself: `foo2`\n \n error: this expression borrows a reference (`&u8`) that is immediately dereferenced by the compiler\n-  --> $DIR/eta.rs:39:21\n+  --> $DIR/eta.rs:38:21\n    |\n LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n    |                     ^^^ help: change this to: `&2`\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:46:27\n+  --> $DIR/eta.rs:38:26\n+   |\n+LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n+   |                          ^^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `below`\n+\n+error: redundant closure\n+  --> $DIR/eta.rs:44:27\n+   |\n+LL |     let e = Some(1u8).map(|a| divergent(a));\n+   |                           ^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `divergent`\n+\n+error: redundant closure\n+  --> $DIR/eta.rs:45:27\n    |\n LL |     let e = Some(1u8).map(|a| generic(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `generic`\n \n error: redundant closure\n-  --> $DIR/eta.rs:92:51\n+  --> $DIR/eta.rs:91:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo());\n    |                                                   ^^^^^^^^^^^ help: replace the closure with the method itself: `TestStruct::foo`\n    |\n    = note: `-D clippy::redundant-closure-for-method-calls` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:94:51\n+  --> $DIR/eta.rs:92:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo());\n    |                                                   ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `TestTrait::trait_foo`\n \n error: redundant closure\n-  --> $DIR/eta.rs:97:42\n+  --> $DIR/eta.rs:94:42\n    |\n LL |     let e = Some(&mut vec![1, 2, 3]).map(|v| v.clear());\n    |                                          ^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::vec::Vec::clear`\n \n error: redundant closure\n-  --> $DIR/eta.rs:102:29\n+  --> $DIR/eta.rs:98:29\n    |\n LL |     let e = Some(\"str\").map(|s| s.to_string());\n    |                             ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::string::ToString::to_string`\n \n error: redundant closure\n-  --> $DIR/eta.rs:104:27\n+  --> $DIR/eta.rs:99:27\n    |\n LL |     let e = Some('a').map(|s| s.to_uppercase());\n    |                           ^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_uppercase`\n \n error: redundant closure\n-  --> $DIR/eta.rs:107:65\n+  --> $DIR/eta.rs:101:65\n    |\n LL |     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(|c| c.to_ascii_uppercase()).collect();\n    |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_ascii_uppercase`\n \n error: redundant closure\n-  --> $DIR/eta.rs:190:27\n+  --> $DIR/eta.rs:164:22\n+   |\n+LL |     requires_fn_once(|| x());\n+   |                      ^^^^^^ help: replace the closure with the function itself: `x`\n+\n+error: redundant closure\n+  --> $DIR/eta.rs:171:27\n    |\n LL |     let a = Some(1u8).map(|a| foo_ptr(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `foo_ptr`\n \n error: redundant closure\n-  --> $DIR/eta.rs:195:27\n+  --> $DIR/eta.rs:176:27\n    |\n LL |     let a = Some(1u8).map(|a| closure(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `closure`\n \n error: redundant closure\n-  --> $DIR/eta.rs:227:28\n+  --> $DIR/eta.rs:208:28\n    |\n LL |     x.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:228:28\n+  --> $DIR/eta.rs:209:28\n    |\n LL |     y.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:229:28\n+  --> $DIR/eta.rs:210:28\n    |\n LL |     z.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:236:21\n+  --> $DIR/eta.rs:217:21\n    |\n LL |         Some(1).map(|n| closure(n));\n    |                     ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut closure`\n \n-error: aborting due to 17 previous errors\n+error: redundant closure\n+  --> $DIR/eta.rs:236:21\n+   |\n+LL |     map_str_to_path(|s| s.as_ref());\n+   |                     ^^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::convert::AsRef::as_ref`\n+\n+error: aborting due to 21 previous errors\n "}, {"sha": "fec3a95edd62da54cddde339c8566e0fa56656e9", "filename": "tests/ui/map_flatten.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Fmap_flatten.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Fmap_flatten.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.fixed?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -4,6 +4,7 @@\n #![allow(clippy::let_underscore_drop)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::map_identity)]\n+#![allow(clippy::redundant_closure)]\n #![allow(clippy::unnecessary_wraps)]\n #![feature(result_flattening)]\n "}, {"sha": "aa1f76e335af0dad3a395921b3e25e6fbf82b6a4", "filename": "tests/ui/map_flatten.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.rs?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -4,6 +4,7 @@\n #![allow(clippy::let_underscore_drop)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::map_identity)]\n+#![allow(clippy::redundant_closure)]\n #![allow(clippy::unnecessary_wraps)]\n #![feature(result_flattening)]\n "}, {"sha": "bcd2047e6faa3d3683b11f396e6a818855c94d21", "filename": "tests/ui/map_flatten.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Fmap_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Fmap_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.stderr?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -1,43 +1,43 @@\n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:17:46\n+  --> $DIR/map_flatten.rs:18:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id)`\n    |\n    = note: `-D clippy::map-flatten` implied by `-D warnings`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:18:46\n+  --> $DIR/map_flatten.rs:19:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_ref)`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:19:46\n+  --> $DIR/map_flatten.rs:20:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_closure)`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:20:46\n+  --> $DIR/map_flatten.rs:21:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(|x| x.checked_add(1))`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:23:46\n+  --> $DIR/map_flatten.rs:24:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `flat_map` instead: `.flat_map(|x| 0..x)`\n \n error: called `map(..).flatten()` on an `Option`\n-  --> $DIR/map_flatten.rs:26:39\n+  --> $DIR/map_flatten.rs:27:39\n    |\n LL |     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n    |                                       ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `.and_then(|x| x)`\n \n error: called `map(..).flatten()` on an `Result`\n-  --> $DIR/map_flatten.rs:29:41\n+  --> $DIR/map_flatten.rs:30:41\n    |\n LL |     let _: Result<_, &str> = (Ok(Ok(1))).map(|x| x).flatten();\n    |                                         ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `.and_then(|x| x)`"}, {"sha": "9644a23296831bf1a67092feecba921180aa3ba7", "filename": "tests/ui/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsemicolon_if_nothing_returned.rs?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::semicolon_if_nothing_returned)]\n+#![allow(clippy::redundant_closure)]\n #![feature(label_break_value)]\n \n fn get_unit() {}\n@@ -30,8 +31,8 @@ fn unsafe_checks_error() {\n     use std::ptr;\n \n     let mut s = MaybeUninit::<String>::uninit();\n-    let _d = || unsafe { \n-        ptr::drop_in_place(s.as_mut_ptr()) \n+    let _d = || unsafe {\n+        ptr::drop_in_place(s.as_mut_ptr())\n     };\n }\n "}, {"sha": "78813e7cc1c39c5aa294f08db14ca9cfe0688a50", "filename": "tests/ui/semicolon_if_nothing_returned.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a64b7698a44c2bf090049798a6fac906e96296ec/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr?ref=a64b7698a44c2bf090049798a6fac906e96296ec", "patch": "@@ -1,33 +1,33 @@\n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:8:5\n+  --> $DIR/semicolon_if_nothing_returned.rs:9:5\n    |\n LL |     println!(\"Hello\")\n    |     ^^^^^^^^^^^^^^^^^ help: add a `;` here: `println!(\"Hello\");`\n    |\n    = note: `-D clippy::semicolon-if-nothing-returned` implied by `-D warnings`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:12:5\n+  --> $DIR/semicolon_if_nothing_returned.rs:13:5\n    |\n LL |     get_unit()\n    |     ^^^^^^^^^^ help: add a `;` here: `get_unit();`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:17:5\n+  --> $DIR/semicolon_if_nothing_returned.rs:18:5\n    |\n LL |     y = x + 1\n    |     ^^^^^^^^^ help: add a `;` here: `y = x + 1;`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:23:9\n+  --> $DIR/semicolon_if_nothing_returned.rs:24:9\n    |\n LL |         hello()\n    |         ^^^^^^^ help: add a `;` here: `hello();`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:34:9\n+  --> $DIR/semicolon_if_nothing_returned.rs:35:9\n    |\n-LL |         ptr::drop_in_place(s.as_mut_ptr()) \n+LL |         ptr::drop_in_place(s.as_mut_ptr())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add a `;` here: `ptr::drop_in_place(s.as_mut_ptr());`\n \n error: aborting due to 5 previous errors"}]}