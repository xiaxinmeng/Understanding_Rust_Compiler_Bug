{"sha": "1dc572b85e1f7bc245fb31ba659c822d68fda0bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYzU3MmI4NWUxZjdiYzI0NWZiMzFiYTY1OWM4MjJkNjhmZGEwYmM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-13T21:02:53Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:29Z"}, "message": "rustc: represent the discriminant as a field for Layout::{Raw,StructWrapped}NullablePointer.", "tree": {"sha": "e21336bff6e175a908444af73f7eabfd9187c69a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e21336bff6e175a908444af73f7eabfd9187c69a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dc572b85e1f7bc245fb31ba659c822d68fda0bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc572b85e1f7bc245fb31ba659c822d68fda0bc", "html_url": "https://github.com/rust-lang/rust/commit/1dc572b85e1f7bc245fb31ba659c822d68fda0bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dc572b85e1f7bc245fb31ba659c822d68fda0bc/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30710609c06beecf4ef33d04d2814f9503f37b6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/30710609c06beecf4ef33d04d2814f9503f37b6b", "html_url": "https://github.com/rust-lang/rust/commit/30710609c06beecf4ef33d04d2814f9503f37b6b"}], "stats": {"total": 193, "additions": 112, "deletions": 81}, "files": [{"sha": "e7e0d08b69c2038778c09e1e0b0b34f9ab76aa1d", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1dc572b85e1f7bc245fb31ba659c822d68fda0bc/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc572b85e1f7bc245fb31ba659c822d68fda0bc/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=1dc572b85e1f7bc245fb31ba659c822d68fda0bc", "patch": "@@ -12,6 +12,7 @@ pub use self::Integer::*;\n pub use self::Layout::*;\n pub use self::Primitive::*;\n \n+use rustc_back::slice::ref_slice;\n use session::{self, DataTypeKind, Session};\n use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions, ReprFlags};\n \n@@ -582,7 +583,7 @@ pub enum Primitive {\n     Pointer\n }\n \n-impl Primitive {\n+impl<'a, 'tcx> Primitive {\n     pub fn size<C: HasDataLayout>(self, cx: C) -> Size {\n         let dl = cx.data_layout();\n \n@@ -611,6 +612,15 @@ impl Primitive {\n             Pointer => dl.pointer_align\n         }\n     }\n+\n+    pub fn to_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            Int(i) => i.to_ty(tcx, false),\n+            F32 => tcx.types.f32,\n+            F64 => tcx.types.f64,\n+            Pointer => tcx.mk_mut_ptr(tcx.mk_nil()),\n+        }\n+    }\n }\n \n /// A structure, a product type in ADT terms.\n@@ -1202,9 +1212,7 @@ impl<'a, 'tcx> Layout {\n             let layout = tcx.intern_layout(layout);\n             let fields = match *layout {\n                 Scalar { .. } |\n-                CEnum { .. } |\n-                RawNullablePointer { .. } |\n-                StructWrappedNullablePointer { .. } => {\n+                CEnum { .. } => {\n                     FieldPlacement::union(0)\n                 }\n \n@@ -1241,7 +1249,14 @@ impl<'a, 'tcx> Layout {\n                     FieldPlacement::union(def.struct_variant().fields.len())\n                 }\n \n-                General { .. } => FieldPlacement::union(1)\n+                General { .. } |\n+                RawNullablePointer { .. } => FieldPlacement::union(1),\n+\n+                StructWrappedNullablePointer { ref discr_offset, .. } => {\n+                    FieldPlacement::Arbitrary {\n+                        offsets: ref_slice(discr_offset)\n+                    }\n+                }\n             };\n             Ok(CachedLayout {\n                 layout,\n@@ -1520,7 +1535,7 @@ impl<'a, 'tcx> Layout {\n                     if let Some((discr, offset, primitive)) = choice {\n                         // HACK(eddyb) work around not being able to move\n                         // out of arrays with just the indexing operator.\n-                        let st = if discr == 0 { st0 } else { st1 };\n+                        let mut st = if discr == 0 { st0 } else { st1 };\n \n                         // FIXME(eddyb) should take advantage of a newtype.\n                         if offset.bytes() == 0 && primitive.size(dl) == st.stride() &&\n@@ -1531,6 +1546,14 @@ impl<'a, 'tcx> Layout {\n                             });\n                         }\n \n+                        let mut discr_align = primitive.align(dl);\n+                        if offset.abi_align(discr_align) != offset {\n+                            st.packed = true;\n+                            discr_align = dl.i8_align;\n+                        }\n+                        st.align = st.align.max(discr_align);\n+                        st.primitive_align = st.primitive_align.max(discr_align);\n+\n                         return success(StructWrappedNullablePointer {\n                             nndiscr: discr as u64,\n                             nonnull: st,\n@@ -2292,7 +2315,7 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n             match tcx.struct_tail(pointee).sty {\n                 ty::TySlice(element) => slice(element),\n                 ty::TyStr => slice(tcx.types.u8),\n-                ty::TyDynamic(..) => tcx.mk_mut_ptr(tcx.mk_nil()),\n+                ty::TyDynamic(..) => Pointer.to_ty(tcx),\n                 _ => bug!(\"FullLayout::field_type({:?}): not applicable\", self)\n             }\n         };\n@@ -2350,6 +2373,10 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n                             General { discr, .. } => {\n                                 return [discr.to_ty(tcx, false)][i];\n                             }\n+                            RawNullablePointer { discr, .. } |\n+                            StructWrappedNullablePointer { discr, .. } => {\n+                                return [discr.to_ty(tcx)][i];\n+                            }\n                             _ if def.variants.len() > 1 => return [][i],\n \n                             // Enums with one variant behave like structs."}, {"sha": "cb4abc61c6221268c490927fbac146d51148dd05", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 53, "deletions": 64, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/1dc572b85e1f7bc245fb31ba659c822d68fda0bc/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc572b85e1f7bc245fb31ba659c822d68fda0bc/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=1dc572b85e1f7bc245fb31ba659c822d68fda0bc", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, Align, Layout, LayoutOf, Size};\n+use rustc::ty::layout::{self, Align, Layout, LayoutOf};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -205,50 +205,68 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 l = l.for_variant(variant_index)\n             }\n         }\n-        let fty = l.field(ccx, ix).ty;\n+        let field = l.field(ccx, ix);\n+        let offset = l.fields.offset(ix).bytes();\n \n         let alignment = self.alignment | Alignment::from(&*l);\n \n         // Handle all the non-aggregate cases first.\n         match *l {\n             layout::UntaggedUnion { .. } => {\n-                let ty = ccx.llvm_type_of(fty);\n+                let ty = ccx.llvm_type_of(field.ty);\n                 return LvalueRef::new_sized(\n-                    bcx.pointercast(self.llval, ty.ptr_to()), fty, alignment);\n+                    bcx.pointercast(self.llval, ty.ptr_to()), field.ty, alignment);\n             }\n-            layout::General { .. } if l.variant_index.is_none() => {\n-                let ty = ccx.llvm_type_of(fty);\n+            // Discriminant field of enums.\n+            layout::General { .. } |\n+            layout::RawNullablePointer { .. } |\n+            layout::StructWrappedNullablePointer { .. } if l.variant_index.is_none() => {\n+                let ty = ccx.llvm_type_of(field.ty);\n+                let size = field.size(ccx).bytes();\n+\n+                // If the discriminant is not on a multiple of the primitive's size,\n+                // we need to go through i8*. Also assume the worst alignment.\n+                if offset % size != 0 {\n+                    let byte_ptr = bcx.pointercast(self.llval, Type::i8p(ccx));\n+                    let byte_ptr = bcx.inbounds_gep(byte_ptr, &[C_usize(ccx, offset)]);\n+                    let byte_align = Alignment::Packed(Align::from_bytes(1, 1).unwrap());\n+                    return LvalueRef::new_sized(\n+                        bcx.pointercast(byte_ptr, ty.ptr_to()), field.ty, byte_align);\n+                }\n+\n+                let discr_ptr = bcx.pointercast(self.llval, ty.ptr_to());\n                 return LvalueRef::new_sized(\n-                    bcx.pointercast(self.llval, ty.ptr_to()), fty, alignment);\n+                    bcx.inbounds_gep(discr_ptr, &[C_usize(ccx, offset / size)]),\n+                    field.ty, alignment);\n             }\n             layout::RawNullablePointer { nndiscr, .. } |\n             layout::StructWrappedNullablePointer { nndiscr,  .. }\n                 if l.variant_index.unwrap() as u64 != nndiscr => {\n                 // The unit-like case might have a nonzero number of unit-like fields.\n                 // (e.d., Result of Either with (), as one side.)\n-                let ty = ccx.llvm_type_of(fty);\n-                assert_eq!(ccx.size_of(fty).bytes(), 0);\n+                let ty = ccx.llvm_type_of(field.ty);\n+                assert_eq!(field.size(ccx).bytes(), 0);\n                 return LvalueRef::new_sized(\n-                    bcx.pointercast(self.llval, ty.ptr_to()), fty,\n+                    bcx.pointercast(self.llval, ty.ptr_to()), field.ty,\n                     Alignment::Packed(Align::from_bytes(1, 1).unwrap()));\n             }\n             layout::RawNullablePointer { .. } => {\n-                let ty = ccx.llvm_type_of(fty);\n+                let ty = ccx.llvm_type_of(field.ty);\n                 return LvalueRef::new_sized(\n-                    bcx.pointercast(self.llval, ty.ptr_to()), fty, alignment);\n+                    bcx.pointercast(self.llval, ty.ptr_to()), field.ty, alignment);\n             }\n             _ => {}\n         }\n \n         let simple = || {\n             LvalueRef {\n                 llval: bcx.struct_gep(self.llval, l.llvm_field_index(ix)),\n-                llextra: if !ccx.shared().type_has_metadata(fty) {\n-                    ptr::null_mut()\n-                } else {\n+                llextra: if ccx.shared().type_has_metadata(field.ty) {\n                     self.llextra\n+                } else {\n+                    ptr::null_mut()\n                 },\n-                ty: LvalueTy::from_ty(fty),\n+                ty: LvalueTy::from_ty(field.ty),\n                 alignment,\n             }\n         };\n@@ -264,13 +282,13 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         // Simple case - we can just GEP the field\n         //   * Packed struct - There is no alignment padding\n         //   * Field is sized - pointer is properly aligned already\n-        if is_packed || ccx.shared().type_is_sized(fty) {\n+        if is_packed || !field.is_unsized() {\n             return simple();\n         }\n \n         // If the type of the last field is [T], str or a foreign type, then we don't need to do\n         // any adjusments\n-        match fty.sty {\n+        match field.ty.sty {\n             ty::TySlice(..) | ty::TyStr | ty::TyForeign(..) => return simple(),\n             _ => ()\n         }\n@@ -299,12 +317,10 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n         let meta = self.llextra;\n \n-\n-        let offset = l.fields.offset(ix).bytes();\n         let unaligned_offset = C_usize(ccx, offset);\n \n         // Get the alignment of the field\n-        let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n+        let (_, align) = glue::size_and_align_of_dst(bcx, field.ty, meta);\n \n         // Bump the unaligned offset up to the appropriate alignment using the\n         // following expression:\n@@ -323,39 +339,17 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n \n         // Finally, cast back to the type expected\n-        let ll_fty = ccx.llvm_type_of(fty);\n+        let ll_fty = ccx.llvm_type_of(field.ty);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n \n         LvalueRef {\n             llval: bcx.pointercast(byte_ptr, ll_fty.ptr_to()),\n             llextra: self.llextra,\n-            ty: LvalueTy::from_ty(fty),\n+            ty: LvalueTy::from_ty(field.ty),\n             alignment,\n         }\n     }\n \n-    // Return a pointer to the discriminant, given its type and offset.\n-    fn gepi_discr_at_offset(self, bcx: &Builder,\n-                            discr: ty::layout::Primitive,\n-                            offset: Size)\n-                            -> (ValueRef, Alignment) {\n-        let size = discr.size(bcx.ccx);\n-        let ptr_ty = Type::from_primitive(bcx.ccx, discr).ptr_to();\n-\n-        // If the discriminant is not on a multiple of the primitive's size,\n-        // we need to go through i8*. Also assume the worst alignment.\n-        if offset.bytes() % size.bytes() != 0 {\n-            let byte_ptr = bcx.pointercast(self.llval, Type::i8p(bcx.ccx));\n-            let byte_ptr = bcx.inbounds_gep(byte_ptr, &[C_usize(bcx.ccx, offset.bytes())]);\n-            let byte_align = Alignment::Packed(Align::from_bytes(1, 1).unwrap());\n-            return (bcx.pointercast(byte_ptr, ptr_ty), byte_align);\n-        }\n-\n-        let discr_ptr = bcx.pointercast(self.llval, ptr_ty);\n-        (bcx.inbounds_gep(discr_ptr, &[C_usize(bcx.ccx, offset.bytes() / size.bytes())]),\n-         self.alignment)\n-    }\n-\n     /// Helper for cases where the discriminant is simply loaded.\n     fn load_discr(self, bcx: &Builder, ity: layout::Integer, ptr: ValueRef,\n                   min: u64, max: u64) -> ValueRef {\n@@ -394,16 +388,12 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 self.load_discr(bcx, discr, ptr.llval, 0, variants.len() as u64 - 1)\n             }\n             layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx, 0),\n-            layout::RawNullablePointer { nndiscr, discr } |\n-            layout::StructWrappedNullablePointer { nndiscr, discr, .. } => {\n-                let discr_offset = match *l {\n-                    layout::StructWrappedNullablePointer { discr_offset, .. } => discr_offset,\n-                    _ => Size::from_bytes(0),\n-                };\n-                let (lldiscrptr, alignment) = self.gepi_discr_at_offset(bcx, discr, discr_offset);\n-                let lldiscr = bcx.load(lldiscrptr, alignment.non_abi());\n+            layout::RawNullablePointer { nndiscr, .. } |\n+            layout::StructWrappedNullablePointer { nndiscr, .. } => {\n+                let ptr = self.project_field(bcx, 0);\n+                let lldiscr = bcx.load(ptr.llval, ptr.alignment.non_abi());\n                 let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n-                bcx.icmp(cmp, lldiscr, C_null(Type::from_primitive(bcx.ccx, discr)))\n+                bcx.icmp(cmp, lldiscr, C_null(bcx.ccx.llvm_type_of(ptr.ty.to_ty(bcx.tcx()))))\n             },\n             _ => bug!(\"{} is not an enum\", l.ty)\n         };\n@@ -434,14 +424,14 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             | layout::Vector { .. } => {\n                 assert_eq!(to, 0);\n             }\n-            layout::RawNullablePointer { nndiscr, discr, .. } |\n-            layout::StructWrappedNullablePointer { nndiscr, discr, .. } => {\n+            layout::RawNullablePointer { nndiscr, .. } |\n+            layout::StructWrappedNullablePointer { nndiscr, .. } => {\n                 if to != nndiscr {\n-                    let (use_memset, discr_offset) = match *l {\n-                        layout::StructWrappedNullablePointer { discr_offset, .. } => {\n-                            (target_sets_discr_via_memset(bcx), discr_offset)\n+                    let use_memset = match *l {\n+                        layout::StructWrappedNullablePointer { .. } => {\n+                            target_sets_discr_via_memset(bcx)\n                         }\n-                        _ => (false, Size::from_bytes(0)),\n+                        _ => false,\n                     };\n                     if use_memset {\n                         // Issue #34427: As workaround for LLVM bug on\n@@ -454,10 +444,9 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                         let align = C_u32(bcx.ccx, align.abi() as u32);\n                         base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                     } else {\n-                        let (lldiscrptr, alignment) =\n-                            self.gepi_discr_at_offset(bcx, discr, discr_offset);\n-                        bcx.store(C_null(Type::from_primitive(bcx.ccx, discr)),\n-                            lldiscrptr, alignment.non_abi());\n+                        let ptr = self.project_field(bcx, 0);\n+                        bcx.store(C_null(bcx.ccx.llvm_type_of(ptr.ty.to_ty(bcx.tcx()))),\n+                            ptr.llval, ptr.alignment.non_abi());\n                     }\n                 }\n             }"}, {"sha": "bb8f3f23108ecbf92892ee33393046bb569493d5", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1dc572b85e1f7bc245fb31ba659c822d68fda0bc/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc572b85e1f7bc245fb31ba659c822d68fda0bc/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=1dc572b85e1f7bc245fb31ba659c822d68fda0bc", "patch": "@@ -287,14 +287,4 @@ impl Type {\n             I128 => Type::i128(cx),\n         }\n     }\n-\n-    pub fn from_primitive(cx: &CrateContext, p: layout::Primitive) -> Type {\n-        use rustc::ty::layout::Primitive::*;\n-        match p {\n-            Int(i) => Type::from_integer(cx, i),\n-            F32 => Type::f32(cx),\n-            F64 => Type::f64(cx),\n-            Pointer => Type::i8p(cx),\n-        }\n-    }\n }"}, {"sha": "1179f16daa238c699752302617b8b1905a518daf", "filename": "src/test/run-pass/packed-struct-optimized-enum.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1dc572b85e1f7bc245fb31ba659c822d68fda0bc/src%2Ftest%2Frun-pass%2Fpacked-struct-optimized-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc572b85e1f7bc245fb31ba659c822d68fda0bc/src%2Ftest%2Frun-pass%2Fpacked-struct-optimized-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-optimized-enum.rs?ref=1dc572b85e1f7bc245fb31ba659c822d68fda0bc", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[repr(packed)]\n+#[derive(Copy, Clone)]\n+struct Packed<T>(T);\n+\n+fn main() {\n+    let one = (Some(Packed((&(), 0))), true);\n+    let two = [one, one];\n+    let stride = (&two[1] as *const _ as usize) - (&two[0] as *const _ as usize);\n+\n+    // This can fail if rustc and LLVM disagree on the size of a type.\n+    // In this case, `Option<Packed<(&(), u32)>>` was erronously not\n+    // marked as packed despite needing alignment `1` and containing\n+    // its `&()` discriminant, which has alignment larger than `1`.\n+    assert_eq!(stride, std::mem::size_of_val(&one));\n+}"}]}