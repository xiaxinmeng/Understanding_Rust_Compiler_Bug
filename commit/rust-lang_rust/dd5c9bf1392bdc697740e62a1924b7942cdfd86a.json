{"sha": "dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkNWM5YmYxMzkyYmRjNjk3NzQwZTYyYTE5MjRiNzk0MmNkZmQ4NmE=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-10-08T00:02:06Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-10-16T16:58:50Z"}, "message": "Use map_bound(_ref) instead of Binder::bind when possible", "tree": {"sha": "d98fd43351d17cd47664b76ec663a250f534cc23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d98fd43351d17cd47664b76ec663a250f534cc23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "html_url": "https://github.com/rust-lang/rust/commit/dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a78a62fc996ba16f7a111c99520b23f77029f4eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a78a62fc996ba16f7a111c99520b23f77029f4eb", "html_url": "https://github.com/rust-lang/rust/commit/a78a62fc996ba16f7a111c99520b23f77029f4eb"}], "stats": {"total": 316, "additions": 173, "deletions": 143}, "files": [{"sha": "e1f675e3ae9c13d305dc2f218512645beaaaf941", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -673,17 +673,9 @@ fn codegen_emcc_try(\n fn gen_fn<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     name: &str,\n-    inputs: Vec<Ty<'tcx>>,\n-    output: Ty<'tcx>,\n+    rust_fn_sig: ty::PolyFnSig<'tcx>,\n     codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n ) -> &'ll Value {\n-    let rust_fn_sig = ty::Binder::bind(cx.tcx.mk_fn_sig(\n-        inputs.into_iter(),\n-        output,\n-        false,\n-        hir::Unsafety::Unsafe,\n-        Abi::Rust,\n-    ));\n     let fn_abi = FnAbi::of_fn_ptr(cx, rust_fn_sig, &[]);\n     let llfn = cx.declare_fn(name, &fn_abi);\n     cx.set_frame_pointer_elimination(llfn);\n@@ -710,22 +702,32 @@ fn get_rust_try_fn<'ll, 'tcx>(\n     // Define the type up front for the signature of the rust_try function.\n     let tcx = cx.tcx;\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n-    let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n+    // `unsafe fn(*mut i8) -> ()`\n+    let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n         iter::once(i8p),\n         tcx.mk_unit(),\n         false,\n         hir::Unsafety::Unsafe,\n         Abi::Rust,\n     )));\n-    let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n+    // `unsafe fn(*mut i8, *mut i8) -> ()`\n+    let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n         [i8p, i8p].iter().cloned(),\n         tcx.mk_unit(),\n         false,\n         hir::Unsafety::Unsafe,\n         Abi::Rust,\n     )));\n     let output = tcx.types.i32;\n-    let rust_try = gen_fn(cx, \"__rust_try\", vec![try_fn_ty, i8p, catch_fn_ty], output, codegen);\n+    // `unsafe fn(unsafe fn(*mut i8) -> (), unsafe fn(*mut i8, *mut i8) -> ()) -> i32`\n+    let rust_fn_sig = ty::Binder::dummy(cx.tcx.mk_fn_sig(\n+        vec![try_fn_ty, i8p, catch_fn_ty].into_iter(),\n+        output,\n+        false,\n+        hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    ));\n+    let rust_try = gen_fn(cx, \"__rust_try\", rust_fn_sig, codegen);\n     cx.rust_try_fn.set(Some(rust_try));\n     rust_try\n }"}, {"sha": "afa6a2a8166a85e9ceae774d85fdc3758b5c732a", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -551,7 +551,8 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n+        let result = self.relate(a.skip_binder(), b.skip_binder())?;\n+        Ok(a.map_bound(|_| result))\n     }\n \n     fn relate_item_substs(\n@@ -833,7 +834,8 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n+        let result = self.relate(a.skip_binder(), b.skip_binder())?;\n+        Ok(a.map_bound(|_| result))\n     }\n \n     fn tys(&mut self, t: Ty<'tcx>, _t: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {"}, {"sha": "b1ec7a7902dbf7882e6de58865c85fecb5d66690", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -636,7 +636,7 @@ where\n         if let (Some(a), Some(b)) = (a.no_bound_vars(), b.no_bound_vars()) {\n             // Fast path for the common case.\n             self.relate(a, b)?;\n-            return Ok(ty::Binder::bind(a));\n+            return Ok(ty::Binder::dummy(a));\n         }\n \n         if self.ambient_covariance() {\n@@ -1004,6 +1004,6 @@ where\n         self.first_free_index.shift_in(1);\n         let result = self.relate(a.skip_binder(), a.skip_binder())?;\n         self.first_free_index.shift_out(1);\n-        Ok(ty::Binder::bind(result))\n+        Ok(a.map_bound(|_| result))\n     }\n }"}, {"sha": "043d24c9767d0941ddb6fcbafe62d7a0744e22aa", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -126,14 +126,15 @@ impl Elaborator<'tcx> {\n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n \n-        match obligation.predicate.skip_binders() {\n+        let bound_predicate = obligation.predicate.bound_atom(tcx);\n+        match bound_predicate.skip_binder() {\n             ty::PredicateAtom::Trait(data, _) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n                 let obligations = predicates.predicates.iter().map(|&(pred, _)| {\n                     predicate_obligation(\n-                        pred.subst_supertrait(tcx, &ty::Binder::bind(data.trait_ref)),\n+                        pred.subst_supertrait(tcx, &bound_predicate.map_bound(|_| data.trait_ref)),\n                         obligation.param_env,\n                         obligation.cause.clone(),\n                     )"}, {"sha": "5f5593eb0d81c4ee404fae18a6e132771baf72d2", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -118,6 +118,7 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n+        let result = self.relate(a.skip_binder(), b.skip_binder())?;\n+        Ok(a.map_bound(|_| result))\n     }\n }"}, {"sha": "20dc49991b45ddf883b6eab49a6d46eea59144ed", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -618,10 +618,9 @@ pub trait PrettyPrinter<'tcx>:\n                         // may contain unbound variables. We therefore do this manually.\n                         //\n                         // FIXME(lcnr): Find out why exactly this is the case :)\n-                        if let ty::PredicateAtom::Trait(pred, _) =\n-                            predicate.bound_atom(self.tcx()).skip_binder()\n-                        {\n-                            let trait_ref = ty::Binder::bind(pred.trait_ref);\n+                        let bound_predicate = predicate.bound_atom(self.tcx());\n+                        if let ty::PredicateAtom::Trait(pred, _) = bound_predicate.skip_binder() {\n+                            let trait_ref = bound_predicate.map_bound(|_| pred.trait_ref);\n                             // Don't print +Sized, but rather +?Sized if absent.\n                             if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n                                 is_sized = true;"}, {"sha": "5f326d700ee0b260fa2472feffe825b2c96bb64c", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -549,7 +549,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateAtom<'a> {\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.as_ref().skip_binder()).map(ty::Binder::bind)\n+        tcx.lift(self.as_ref().skip_binder()).map(|v| self.map_bound_ref(|_| v))\n     }\n }\n "}, {"sha": "932cadee1003f1dc05294de067ded0eb1ea5cd0d", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -702,15 +702,19 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n     pub fn with_self_ty(&self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ty::Predicate<'tcx> {\n         use crate::ty::ToPredicate;\n         match self.skip_binder() {\n-            ExistentialPredicate::Trait(tr) => {\n-                Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate(tcx)\n-            }\n+            ExistentialPredicate::Trait(tr) => self\n+                .map_bound_ref(|_| tr)\n+                .with_self_ty(tcx, self_ty)\n+                .without_const()\n+                .to_predicate(tcx),\n             ExistentialPredicate::Projection(p) => {\n-                Binder(p.with_self_ty(tcx, self_ty)).to_predicate(tcx)\n+                self.map_bound_ref(|_| p.with_self_ty(tcx, self_ty)).to_predicate(tcx)\n             }\n             ExistentialPredicate::AutoTrait(did) => {\n-                let trait_ref =\n-                    Binder(ty::TraitRef { def_id: did, substs: tcx.mk_substs_trait(self_ty, &[]) });\n+                let trait_ref = self.map_bound_ref(|_| ty::TraitRef {\n+                    def_id: did,\n+                    substs: tcx.mk_substs_trait(self_ty, &[]),\n+                });\n                 trait_ref.without_const().to_predicate(tcx)\n             }\n         }\n@@ -775,7 +779,7 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n \n impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n     pub fn principal(&self) -> Option<ty::Binder<ExistentialTraitRef<'tcx>>> {\n-        self.skip_binder().principal().map(Binder::bind)\n+        self.map_bound_ref(|b| b.principal()).transpose()\n     }\n \n     pub fn principal_def_id(&self) -> Option<DefId> {\n@@ -858,8 +862,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n     }\n \n     pub fn to_poly_trait_predicate(&self) -> ty::PolyTraitPredicate<'tcx> {\n-        // Note that we preserve binding levels\n-        Binder(ty::TraitPredicate { trait_ref: self.skip_binder() })\n+        self.map_bound(|trait_ref| ty::TraitPredicate { trait_ref })\n     }\n }\n "}, {"sha": "96a0c339e18576414446dee84e0948f53d871cf1", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -642,18 +642,19 @@ impl AutoTraitFinder<'tcx> {\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n \n-            match predicate.skip_binders() {\n+            let bound_predicate = predicate.bound_atom(select.infcx().tcx);\n+            match bound_predicate.skip_binder() {\n                 ty::PredicateAtom::Trait(p, _) => {\n                     if self.is_param_no_infer(p.trait_ref.substs)\n                         && !only_projections\n                         && is_new_pred\n                     {\n                         self.add_user_pred(computed_preds, predicate);\n                     }\n-                    predicates.push_back(ty::Binder::bind(p));\n+                    predicates.push_back(bound_predicate.map_bound_ref(|_| p));\n                 }\n                 ty::PredicateAtom::Projection(p) => {\n-                    let p = ty::Binder::bind(p);\n+                    let p = bound_predicate.map_bound_ref(|_| p);\n                     debug!(\n                         \"evaluate_nested_obligations: examining projection predicate {:?}\",\n                         predicate\n@@ -783,13 +784,13 @@ impl AutoTraitFinder<'tcx> {\n                     }\n                 }\n                 ty::PredicateAtom::RegionOutlives(binder) => {\n-                    let binder = ty::Binder::bind(binder);\n+                    let binder = bound_predicate.map_bound_ref(|_| binder);\n                     if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }\n                 ty::PredicateAtom::TypeOutlives(binder) => {\n-                    let binder = ty::Binder::bind(binder);\n+                    let binder = bound_predicate.map_bound_ref(|_| binder);\n                     match (\n                         binder.no_bound_vars(),\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),"}, {"sha": "3c4394e7d034b33b6df260d97277d2781ee5291d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -255,9 +255,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n \n-                match obligation.predicate.skip_binders() {\n+                let bound_predicate = obligation.predicate.bound_atom(self.tcx);\n+                match bound_predicate.skip_binder() {\n                     ty::PredicateAtom::Trait(trait_predicate, _) => {\n-                        let trait_predicate = ty::Binder::bind(trait_predicate);\n+                        let trait_predicate = bound_predicate.map_bound_ref(|_| trait_predicate);\n                         let trait_predicate = self.resolve_vars_if_possible(&trait_predicate);\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n@@ -531,7 +532,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n \n                     ty::PredicateAtom::RegionOutlives(predicate) => {\n-                        let predicate = ty::Binder::bind(predicate);\n+                        let predicate = bound_predicate.map_bound_ref(|_| predicate);\n                         let predicate = self.resolve_vars_if_possible(&predicate);\n                         let err = self\n                             .region_outlives_predicate(&obligation.cause, predicate)\n@@ -1078,9 +1079,10 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         // FIXME: It should be possible to deal with `ForAll` in a cleaner way.\n-        let (cond, error) = match (cond.skip_binders(), error.skip_binders()) {\n+        let bound_error = error.bound_atom(self.tcx);\n+        let (cond, error) = match (cond.skip_binders(), bound_error.skip_binder()) {\n             (ty::PredicateAtom::Trait(..), ty::PredicateAtom::Trait(error, _)) => {\n-                (cond, ty::Binder::bind(error))\n+                (cond, bound_error.map_bound_ref(|_| error))\n             }\n             _ => {\n                 // FIXME: make this work in other cases too.\n@@ -1089,9 +1091,10 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n \n         for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n-            if let ty::PredicateAtom::Trait(implication, _) = obligation.predicate.skip_binders() {\n+            let bound_predicate = obligation.predicate.bound_atom(self.tcx);\n+            if let ty::PredicateAtom::Trait(implication, _) = bound_predicate.skip_binder() {\n                 let error = error.to_poly_trait_ref();\n-                let implication = ty::Binder::bind(implication.trait_ref);\n+                let implication = bound_predicate.map_bound_ref(|_| implication.trait_ref);\n                 // FIXME: I'm just not taking associated types at all here.\n                 // Eventually I'll need to implement param-env-aware\n                 // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n@@ -1169,12 +1172,13 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             //\n             // this can fail if the problem was higher-ranked, in which\n             // cause I have no idea for a good error message.\n-            if let ty::PredicateAtom::Projection(data) = predicate.skip_binders() {\n+            let bound_predicate = predicate.bound_atom(self.tcx);\n+            if let ty::PredicateAtom::Projection(data) = bound_predicate.skip_binder() {\n                 let mut selcx = SelectionContext::new(self);\n                 let (data, _) = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    &ty::Binder::bind(data),\n+                    &bound_predicate.map_bound_ref(|_| data),\n                 );\n                 let mut obligations = vec![];\n                 let normalized_ty = super::normalize_projection_type(\n@@ -1455,10 +1459,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        let mut err = match predicate.skip_binders() {\n+        let bound_predicate = predicate.bound_atom(self.tcx);\n+        let mut err = match bound_predicate.skip_binder() {\n             ty::PredicateAtom::Trait(data, _) => {\n-                let trait_ref = ty::Binder::bind(data.trait_ref);\n-                let self_ty = trait_ref.skip_binder().self_ty();\n+                let self_ty = data.trait_ref.self_ty();\n+                let trait_ref = bound_predicate.map_bound_ref(|_| data.trait_ref);\n                 debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind(), trait_ref);\n \n                 if predicate.references_error() {\n@@ -1582,7 +1587,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.emit_inference_failure_err(body_id, span, a.into(), ErrorCode::E0282)\n             }\n             ty::PredicateAtom::Projection(data) => {\n-                let trait_ref = ty::Binder::bind(data).to_poly_trait_ref(self.tcx);\n+                let trait_ref = bound_predicate.map_bound_ref(|_| data).to_poly_trait_ref(self.tcx);\n                 let self_ty = trait_ref.skip_binder().self_ty();\n                 let ty = data.ty;\n                 if predicate.references_error() {"}, {"sha": "01217457eb4b63c3a7552dce0e318e12a1a89794", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 // This means we need to pass it the bound version of our\n                 // predicate.\n                 ty::PredicateAtom::Trait(trait_ref, _constness) => {\n-                    let trait_obligation = obligation.with(Binder::bind(trait_ref));\n+                    let trait_obligation = obligation.with(binder.map_bound_ref(|_| trait_ref));\n \n                     self.process_trait_obligation(\n                         obligation,\n@@ -362,7 +362,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     )\n                 }\n                 ty::PredicateAtom::Projection(data) => {\n-                    let project_obligation = obligation.with(Binder::bind(data));\n+                    let project_obligation = obligation.with(binder.map_bound_ref(|_| data));\n \n                     self.process_projection_obligation(\n                         project_obligation,"}, {"sha": "295ba6041fb979188151ce1afd8b1ed8eafcde30", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -623,7 +623,8 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n         .obligations\n         .iter()\n         .filter(|obligation| {\n-            match obligation.predicate.skip_binders() {\n+            let bound_predicate = obligation.predicate.bound_atom(infcx.tcx);\n+            match bound_predicate.skip_binder() {\n                 // We found a `T: Foo<X = U>` predicate, let's check\n                 // if `U` references any unresolved type\n                 // variables. In principle, we only care if this\n@@ -633,9 +634,9 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n                 // indirect obligations (e.g., we project to `?0`,\n                 // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n                 // ?0>`).\n-                ty::PredicateAtom::Projection(data) => {\n-                    infcx.unresolved_type_vars(&ty::Binder::bind(data.ty)).is_some()\n-                }\n+                ty::PredicateAtom::Projection(data) => infcx\n+                    .unresolved_type_vars(&bound_predicate.map_bound_ref(|_| data.ty))\n+                    .is_some(),\n \n                 // We are only interested in `T: Foo<X = U>` predicates, whre\n                 // `U` references one of `unresolved_type_vars`. =)\n@@ -907,8 +908,9 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n         debug!(?predicate);\n+        let bound_predicate = predicate.bound_atom(infcx.tcx);\n         if let ty::PredicateAtom::Projection(data) = predicate.skip_binders() {\n-            let data = ty::Binder::bind(data);\n+            let data = bound_predicate.map_bound_ref(|_| data);\n             let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n \n             let is_match = same_def_id"}, {"sha": "29c9c29d2089e46b28d5cd0bcb0bad08316af034", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -449,16 +449,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         let result = ensure_sufficient_stack(|| {\n-            match obligation.predicate.skip_binders() {\n+            let bound_predicate = obligation.predicate.bound_atom(self.infcx().tcx);\n+            match bound_predicate.skip_binder() {\n                 ty::PredicateAtom::Trait(t, _) => {\n-                    let t = ty::Binder::bind(t);\n+                    let t = bound_predicate.map_bound_ref(|_| t);\n                     debug_assert!(!t.has_escaping_bound_vars());\n                     let obligation = obligation.with(t);\n                     self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n                 }\n \n                 ty::PredicateAtom::Subtype(p) => {\n-                    let p = ty::Binder::bind(p);\n+                    let p = bound_predicate.map_bound_ref(|_| p);\n                     // Does this code ever run?\n                     match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                         Some(Ok(InferOk { mut obligations, .. })) => {\n@@ -502,7 +503,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n \n                 ty::PredicateAtom::Projection(data) => {\n-                    let data = ty::Binder::bind(data);\n+                    let data = bound_predicate.map_bound_ref(|_| data);\n                     let project_obligation = obligation.with(data);\n                     match project::poly_project_and_unify_type(self, &project_obligation) {\n                         Ok(Ok(Some(mut subobligations))) => {\n@@ -1174,8 +1175,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .iter()\n             .enumerate()\n             .filter_map(|(idx, bound)| {\n-                if let ty::PredicateAtom::Trait(pred, _) = bound.skip_binders() {\n-                    let bound = ty::Binder::bind(pred.trait_ref);\n+                let bound_predicate = bound.bound_atom(self.infcx.tcx);\n+                if let ty::PredicateAtom::Trait(pred, _) = bound_predicate.skip_binder() {\n+                    let bound = bound_predicate.map_bound_ref(|_| pred.trait_ref);\n                     if self.infcx.probe(|_| {\n                         match self.match_projection(\n                             obligation,\n@@ -1529,16 +1531,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Str | ty::Slice(_) | ty::Dynamic(..) | ty::Foreign(..) => None,\n \n-            ty::Tuple(tys) => {\n-                Where(ty::Binder::bind(tys.last().into_iter().map(|k| k.expect_ty()).collect()))\n-            }\n+            ty::Tuple(tys) => Where(\n+                obligation\n+                    .predicate\n+                    .map_bound_ref(|_| tys.last().into_iter().map(|k| k.expect_ty()).collect()),\n+            ),\n \n             ty::Adt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n-                Where(ty::Binder::bind(\n-                    sized_crit.iter().map(|ty| ty.subst(self.tcx(), substs)).collect(),\n-                ))\n+                Where(obligation.predicate.map_bound_ref(|_| {\n+                    sized_crit.iter().map(|ty| ty.subst(self.tcx(), substs)).collect()\n+                }))\n             }\n \n             ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => None,\n@@ -1590,12 +1594,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Array(element_ty, _) => {\n                 // (*) binder moved here\n-                Where(ty::Binder::bind(vec![element_ty]))\n+                Where(obligation.predicate.map_bound_ref(|_| vec![*element_ty]))\n             }\n \n             ty::Tuple(tys) => {\n                 // (*) binder moved here\n-                Where(ty::Binder::bind(tys.iter().map(|k| k.expect_ty()).collect()))\n+                Where(\n+                    obligation\n+                        .predicate\n+                        .map_bound_ref(|_| tys.iter().map(|k| k.expect_ty()).collect()),\n+                )\n             }\n \n             ty::Closure(_, substs) => {\n@@ -1605,7 +1613,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // Not yet resolved.\n                     Ambiguous\n                 } else {\n-                    Where(ty::Binder::bind(substs.as_closure().upvar_tys().collect()))\n+                    Where(\n+                        obligation\n+                            .predicate\n+                            .map_bound_ref(|_| substs.as_closure().upvar_tys().collect()),\n+                    )\n                 }\n             }\n "}, {"sha": "2ca94c6444ab0f6a6f93c6f3026191c2968e21a0", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -762,27 +762,19 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_solve::rust_ir::QuantifiedInlineBound<RustInterner<'tcx>>> {\n-        match self.bound_atom(interner.tcx).skip_binder() {\n-            ty::PredicateAtom::Trait(predicate, _) => {\n-                let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, &ty::Binder::bind(predicate));\n-\n-                Some(chalk_ir::Binders::new(\n-                    binders,\n-                    chalk_solve::rust_ir::InlineBound::TraitBound(\n-                        predicate.trait_ref.lower_into(interner),\n-                    ),\n-                ))\n-            }\n-            ty::PredicateAtom::Projection(predicate) => {\n-                let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, &ty::Binder::bind(predicate));\n-\n-                Some(chalk_ir::Binders::new(\n-                    binders,\n-                    chalk_solve::rust_ir::InlineBound::AliasEqBound(predicate.lower_into(interner)),\n-                ))\n-            }\n+        let (predicate, binders, _named_regions) =\n+            collect_bound_vars(interner, interner.tcx, &self.bound_atom(interner.tcx));\n+        match predicate {\n+            ty::PredicateAtom::Trait(predicate, _) => Some(chalk_ir::Binders::new(\n+                binders,\n+                chalk_solve::rust_ir::InlineBound::TraitBound(\n+                    predicate.trait_ref.lower_into(interner),\n+                ),\n+            )),\n+            ty::PredicateAtom::Projection(predicate) => Some(chalk_ir::Binders::new(\n+                binders,\n+                chalk_solve::rust_ir::InlineBound::AliasEqBound(predicate.lower_into(interner)),\n+            )),\n             ty::PredicateAtom::TypeOutlives(_predicate) => None,\n             ty::PredicateAtom::WellFormed(_ty) => None,\n "}, {"sha": "cea7eaec9a7133c34453de26249cc3b398b225b1", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -1095,9 +1095,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     obligation.predicate\n                 );\n \n-                match obligation.predicate.skip_binders() {\n+                let bound_predicate = obligation.predicate.bound_atom(tcx);\n+                match bound_predicate.skip_binder() {\n                     ty::PredicateAtom::Trait(pred, _) => {\n-                        let pred = ty::Binder::bind(pred);\n+                        let pred = bound_predicate.map_bound_ref(|_| pred);\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n                                 .in_definition_order()\n@@ -1106,7 +1107,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         );\n                     }\n                     ty::PredicateAtom::Projection(pred) => {\n-                        let pred = ty::Binder::bind(pred);\n+                        let pred = bound_predicate.map_bound_ref(|_| pred);\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n                         let references_self ="}, {"sha": "500cc92921b965aafa856eddcb45d57c2c1aefbd", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -192,14 +192,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     obligation.predicate\n                 );\n \n+                let bound_predicate = obligation.predicate.bound_atom(self.tcx);\n                 if let ty::PredicateAtom::Projection(proj_predicate) =\n                     obligation.predicate.skip_binders()\n                 {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n                     self.deduce_sig_from_projection(\n                         Some(obligation.cause.span),\n-                        ty::Binder::bind(proj_predicate),\n+                        bound_predicate.map_bound_ref(|_| proj_predicate),\n                     )\n                 } else {\n                     None"}, {"sha": "0eb5593e8bd788fa3e7882cc9b71f1a322d0f7cb", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -583,7 +583,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         while !queue.is_empty() {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n-            let trait_pred = match obligation.predicate.skip_binders() {\n+            let bound_predicate = obligation.predicate.bound_atom(self.tcx);\n+            let trait_pred = match bound_predicate.skip_binder() {\n                 ty::PredicateAtom::Trait(trait_pred, _)\n                     if traits.contains(&trait_pred.def_id()) =>\n                 {\n@@ -594,7 +595,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             has_unsized_tuple_coercion = true;\n                         }\n                     }\n-                    ty::Binder::bind(trait_pred)\n+                    bound_predicate.map_bound_ref(|_| trait_pred)\n                 }\n                 _ => {\n                     coercion.obligations.push(obligation);"}, {"sha": "c777b87d4886fdc97ca3d4a9abc84763d279defe", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -226,13 +226,15 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // could be extended easily also to the other `Predicate`.\n         let predicate_matches_closure = |p: Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n+            let bound_predicate = predicate.bound_atom(tcx);\n+            let bound_p = p.bound_atom(tcx);\n             match (predicate.skip_binders(), p.skip_binders()) {\n-                (ty::PredicateAtom::Trait(a, _), ty::PredicateAtom::Trait(b, _)) => {\n-                    relator.relate(ty::Binder::bind(a), ty::Binder::bind(b)).is_ok()\n-                }\n-                (ty::PredicateAtom::Projection(a), ty::PredicateAtom::Projection(b)) => {\n-                    relator.relate(ty::Binder::bind(a), ty::Binder::bind(b)).is_ok()\n-                }\n+                (ty::PredicateAtom::Trait(a, _), ty::PredicateAtom::Trait(b, _)) => relator\n+                    .relate(bound_predicate.map_bound_ref(|_| a), bound_p.map_bound_ref(|_| b))\n+                    .is_ok(),\n+                (ty::PredicateAtom::Projection(a), ty::PredicateAtom::Projection(b)) => relator\n+                    .relate(bound_predicate.map_bound_ref(|_| a), bound_p.map_bound_ref(|_| b))\n+                    .is_ok(),\n                 _ => predicate == p,\n             }\n         };"}, {"sha": "f40a250200e4a1df9f846ea50e7b217f1b26b64b", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -328,14 +328,14 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n \n             kw::Try => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n-                let try_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n+                let try_fn_ty = ty::Binder::dummy(tcx.mk_fn_sig(\n                     iter::once(mut_u8),\n                     tcx.mk_unit(),\n                     false,\n                     hir::Unsafety::Normal,\n                     Abi::Rust,\n                 ));\n-                let catch_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n+                let catch_fn_ty = ty::Binder::dummy(tcx.mk_fn_sig(\n                     [mut_u8, mut_u8].iter().cloned(),\n                     tcx.mk_unit(),\n                     false,"}, {"sha": "e6e7e229f8883be02609c7314cf29a0d8f6b283f", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -796,29 +796,30 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // FIXME: do we want to commit to this behavior for param bounds?\n         debug!(\"assemble_inherent_candidates_from_param(param_ty={:?})\", param_ty);\n \n-        let bounds =\n-            self.param_env.caller_bounds().iter().map(ty::Predicate::skip_binders).filter_map(\n-                |predicate| match predicate {\n-                    ty::PredicateAtom::Trait(trait_predicate, _) => {\n-                        match trait_predicate.trait_ref.self_ty().kind() {\n-                            ty::Param(ref p) if *p == param_ty => {\n-                                Some(ty::Binder::bind(trait_predicate.trait_ref))\n-                            }\n-                            _ => None,\n+        let tcx = self.tcx;\n+        let bounds = self.param_env.caller_bounds().iter().filter_map(|predicate| {\n+            let bound_predicate = predicate.bound_atom(tcx);\n+            match bound_predicate.skip_binder() {\n+                ty::PredicateAtom::Trait(trait_predicate, _) => {\n+                    match trait_predicate.trait_ref.self_ty().kind() {\n+                        ty::Param(ref p) if *p == param_ty => {\n+                            Some(bound_predicate.map_bound_ref(|_| trait_predicate.trait_ref))\n                         }\n+                        _ => None,\n                     }\n-                    ty::PredicateAtom::Subtype(..)\n-                    | ty::PredicateAtom::Projection(..)\n-                    | ty::PredicateAtom::RegionOutlives(..)\n-                    | ty::PredicateAtom::WellFormed(..)\n-                    | ty::PredicateAtom::ObjectSafe(..)\n-                    | ty::PredicateAtom::ClosureKind(..)\n-                    | ty::PredicateAtom::TypeOutlives(..)\n-                    | ty::PredicateAtom::ConstEvaluatable(..)\n-                    | ty::PredicateAtom::ConstEquate(..)\n-                    | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n-                },\n-            );\n+                }\n+                ty::PredicateAtom::Subtype(..)\n+                | ty::PredicateAtom::Projection(..)\n+                | ty::PredicateAtom::RegionOutlives(..)\n+                | ty::PredicateAtom::WellFormed(..)\n+                | ty::PredicateAtom::ObjectSafe(..)\n+                | ty::PredicateAtom::ClosureKind(..)\n+                | ty::PredicateAtom::TypeOutlives(..)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..)\n+                | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n+            }\n+        });\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {\n             let trait_ref = this.erase_late_bound_regions(&poly_trait_ref);"}, {"sha": "d1d6d002d4c96da4801822440a11b667b82fce2b", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -637,9 +637,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     };\n                     let mut format_pred = |pred: ty::Predicate<'tcx>| {\n-                        match pred.skip_binders() {\n+                        let bound_predicate = pred.bound_atom(tcx);\n+                        match bound_predicate.skip_binder() {\n                             ty::PredicateAtom::Projection(pred) => {\n-                                let pred = ty::Binder::bind(pred);\n+                                let pred = bound_predicate.map_bound_ref(|_| pred);\n                                 // `<Foo as Iterator>::Item = String`.\n                                 let trait_ref =\n                                     pred.skip_binder().projection_ty.trait_ref(self.tcx);\n@@ -658,8 +659,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 Some((obligation, trait_ref.self_ty()))\n                             }\n                             ty::PredicateAtom::Trait(poly_trait_ref, _) => {\n-                                let poly_trait_ref = ty::Binder::bind(poly_trait_ref);\n-                                let p = poly_trait_ref.skip_binder().trait_ref;\n+                                let p = poly_trait_ref.trait_ref;\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n                                 let obligation = format!(\"{}: {}\", self_ty, path);"}, {"sha": "124ba91f74c91155cac6c5cb4cc5c56649127328", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -850,7 +850,8 @@ fn bounds_from_generic_predicates<'tcx>(\n     let mut projections = vec![];\n     for (predicate, _) in predicates.predicates {\n         debug!(\"predicate {:?}\", predicate);\n-        match predicate.skip_binders() {\n+        let bound_predicate = predicate.bound_atom(tcx);\n+        match bound_predicate.skip_binder() {\n             ty::PredicateAtom::Trait(trait_predicate, _) => {\n                 let entry = types.entry(trait_predicate.self_ty()).or_default();\n                 let def_id = trait_predicate.def_id();\n@@ -861,7 +862,7 @@ fn bounds_from_generic_predicates<'tcx>(\n                 }\n             }\n             ty::PredicateAtom::Projection(projection_pred) => {\n-                projections.push(ty::Binder::bind(projection_pred));\n+                projections.push(bound_predicate.map_bound_ref(|_| projection_pred));\n             }\n             _ => {}\n         }"}, {"sha": "c1fa39e96eb95656761c724c11dc641f5a684de0", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -317,7 +317,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: LocalDefId) {\n                 }\n             }\n \n-            let se_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n+            let se_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n                 [tcx.types.isize, tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))].iter().cloned(),\n                 tcx.types.isize,\n                 false,"}, {"sha": "f6a4dfd85a5ef2cb0d98b15b94dcea15ab1ba09f", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5c9bf1392bdc697740e62a1924b7942cdfd86a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=dd5c9bf1392bdc697740e62a1924b7942cdfd86a", "patch": "@@ -315,13 +315,16 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         pred: ty::Predicate<'tcx>,\n     ) -> FxHashSet<GenericParamDef> {\n-        let regions = match pred.skip_binders() {\n-            ty::PredicateAtom::Trait(poly_trait_pred, _) => {\n-                tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(poly_trait_pred))\n-            }\n-            ty::PredicateAtom::Projection(poly_proj_pred) => {\n-                tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(poly_proj_pred))\n-            }\n+        let bound_predicate = pred.bound_atom(tcx);\n+        let regions = match bound_predicate.skip_binder() {\n+            ty::PredicateAtom::Trait(poly_trait_pred, _) => tcx\n+                .collect_referenced_late_bound_regions(\n+                    &bound_predicate.map_bound_ref(|_| poly_trait_pred),\n+                ),\n+            ty::PredicateAtom::Projection(poly_proj_pred) => tcx\n+                .collect_referenced_late_bound_regions(\n+                    &bound_predicate.map_bound_ref(|_| poly_proj_pred),\n+                ),\n             _ => return FxHashSet::default(),\n         };\n "}]}