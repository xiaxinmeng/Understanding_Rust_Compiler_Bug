{"sha": "7d31ffc1ac9e9ea356e896e63307168a64501b9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMzFmZmMxYWM5ZTllYTM1NmU4OTZlNjMzMDcxNjhhNjQ1MDFiOWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-18T13:00:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-18T13:00:50Z"}, "message": "Auto merge of #74468 - Manishearth:rollup-5nhvz80, r=Manishearth\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #72414 ( Add lazy initialization primitives to std)\n - #74069 (Compare tagged/niche-filling layout and pick the best one)\n - #74418 (ci: Set `shell: bash` as a default, remove duplicates)\n - #74441 (bootstrap.py: patch RPATH on NixOS to handle the new zlib dependency.)\n - #74444 (Add regression test for #69414)\n - #74448 (improper_ctypes_definitions: allow `Box`)\n - #74449 (Test codegen of compare_exchange operations)\n - #74450 (Fix `Safety` docs for `from_raw_parts_mut`)\n - #74453 (Use intra-doc links in `str` and `BTreeSet`)\n - #74457 (rustbuild: drop tool::should_install)\n - #74464 (Use pathdiff crate)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "aa1118412d2690e0e595788144b14970826c3d1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa1118412d2690e0e595788144b14970826c3d1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d31ffc1ac9e9ea356e896e63307168a64501b9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d31ffc1ac9e9ea356e896e63307168a64501b9d", "html_url": "https://github.com/rust-lang/rust/commit/7d31ffc1ac9e9ea356e896e63307168a64501b9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d31ffc1ac9e9ea356e896e63307168a64501b9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "html_url": "https://github.com/rust-lang/rust/commit/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02"}, {"sha": "cae9c503b0d6de9702ca99bda95c081b1eb530f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cae9c503b0d6de9702ca99bda95c081b1eb530f5", "html_url": "https://github.com/rust-lang/rust/commit/cae9c503b0d6de9702ca99bda95c081b1eb530f5"}], "stats": {"total": 2186, "additions": 1715, "deletions": 471}, "files": [{"sha": "86de37820003ae425f59eee735e23666f7099015", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 1, "deletions": 81, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -26,7 +26,7 @@ name: CI\n       - \"**\"\n defaults:\n   run:\n-    shell: \"python src/ci/exec-with-shell.py {0}\"\n+    shell: bash\n jobs:\n   pr:\n     name: PR\n@@ -54,7 +54,6 @@ jobs:\n     steps:\n       - name: disable git crlf conversion\n         run: git config --global core.autocrlf false\n-        shell: bash\n       - name: checkout the source code\n         uses: actions/checkout@v1\n         with:\n@@ -66,85 +65,66 @@ jobs:\n         if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: add extra environment variables\n         run: src/ci/scripts/setup-environment.sh\n-        shell: bash\n         env:\n           EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n         if: success() && !env.SKIP_JOB\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install awscli\n         run: src/ci/scripts/install-awscli.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install WIX\n         run: src/ci/scripts/install-wix.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: ensure the build happens on a partition with enough space\n         run: src/ci/scripts/symlink-build-dir.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install MSYS2\n         run: src/ci/scripts/install-msys2.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install MinGW\n         run: src/ci/scripts/install-mingw.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install ninja\n         run: src/ci/scripts/install-ninja.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: enable ipv6 on Docker\n         run: src/ci/scripts/enable-docker-ipv6.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: checkout submodules\n         run: src/ci/scripts/checkout-submodules.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: ensure line endings are correct\n         run: src/ci/scripts/verify-line-endings.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: run the build\n         run: src/ci/scripts/run-build-from-ci.sh\n-        shell: bash\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n           TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n         if: success() && !env.SKIP_JOB\n       - name: upload artifacts to S3\n         run: src/ci/scripts/upload-artifacts.sh\n-        shell: bash\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n@@ -173,7 +153,6 @@ jobs:\n     steps:\n       - name: disable git crlf conversion\n         run: git config --global core.autocrlf false\n-        shell: bash\n       - name: checkout the source code\n         uses: actions/checkout@v1\n         with:\n@@ -185,85 +164,66 @@ jobs:\n         if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: add extra environment variables\n         run: src/ci/scripts/setup-environment.sh\n-        shell: bash\n         env:\n           EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n         if: success() && !env.SKIP_JOB\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install awscli\n         run: src/ci/scripts/install-awscli.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install WIX\n         run: src/ci/scripts/install-wix.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: ensure the build happens on a partition with enough space\n         run: src/ci/scripts/symlink-build-dir.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install MSYS2\n         run: src/ci/scripts/install-msys2.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install MinGW\n         run: src/ci/scripts/install-mingw.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install ninja\n         run: src/ci/scripts/install-ninja.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: enable ipv6 on Docker\n         run: src/ci/scripts/enable-docker-ipv6.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: checkout submodules\n         run: src/ci/scripts/checkout-submodules.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: ensure line endings are correct\n         run: src/ci/scripts/verify-line-endings.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: run the build\n         run: src/ci/scripts/run-build-from-ci.sh\n-        shell: bash\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n           TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n         if: success() && !env.SKIP_JOB\n       - name: upload artifacts to S3\n         run: src/ci/scripts/upload-artifacts.sh\n-        shell: bash\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n@@ -510,7 +470,6 @@ jobs:\n     steps:\n       - name: disable git crlf conversion\n         run: git config --global core.autocrlf false\n-        shell: bash\n       - name: checkout the source code\n         uses: actions/checkout@v1\n         with:\n@@ -522,85 +481,66 @@ jobs:\n         if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: add extra environment variables\n         run: src/ci/scripts/setup-environment.sh\n-        shell: bash\n         env:\n           EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n         if: success() && !env.SKIP_JOB\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install awscli\n         run: src/ci/scripts/install-awscli.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install WIX\n         run: src/ci/scripts/install-wix.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: ensure the build happens on a partition with enough space\n         run: src/ci/scripts/symlink-build-dir.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install MSYS2\n         run: src/ci/scripts/install-msys2.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install MinGW\n         run: src/ci/scripts/install-mingw.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install ninja\n         run: src/ci/scripts/install-ninja.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: enable ipv6 on Docker\n         run: src/ci/scripts/enable-docker-ipv6.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: checkout submodules\n         run: src/ci/scripts/checkout-submodules.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: ensure line endings are correct\n         run: src/ci/scripts/verify-line-endings.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: run the build\n         run: src/ci/scripts/run-build-from-ci.sh\n-        shell: bash\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n           TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n         if: success() && !env.SKIP_JOB\n       - name: upload artifacts to S3\n         run: src/ci/scripts/upload-artifacts.sh\n-        shell: bash\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n@@ -655,7 +595,6 @@ jobs:\n     steps:\n       - name: disable git crlf conversion\n         run: git config --global core.autocrlf false\n-        shell: bash\n       - name: checkout the source code\n         uses: actions/checkout@v1\n         with:\n@@ -667,85 +606,66 @@ jobs:\n         if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: add extra environment variables\n         run: src/ci/scripts/setup-environment.sh\n-        shell: bash\n         env:\n           EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n         if: success() && !env.SKIP_JOB\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install awscli\n         run: src/ci/scripts/install-awscli.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install WIX\n         run: src/ci/scripts/install-wix.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: ensure the build happens on a partition with enough space\n         run: src/ci/scripts/symlink-build-dir.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install MSYS2\n         run: src/ci/scripts/install-msys2.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install MinGW\n         run: src/ci/scripts/install-mingw.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: install ninja\n         run: src/ci/scripts/install-ninja.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: enable ipv6 on Docker\n         run: src/ci/scripts/enable-docker-ipv6.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: checkout submodules\n         run: src/ci/scripts/checkout-submodules.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: ensure line endings are correct\n         run: src/ci/scripts/verify-line-endings.sh\n-        shell: bash\n         if: success() && !env.SKIP_JOB\n       - name: run the build\n         run: src/ci/scripts/run-build-from-ci.sh\n-        shell: bash\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n           TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n         if: success() && !env.SKIP_JOB\n       - name: upload artifacts to S3\n         run: src/ci/scripts/upload-artifacts.sh\n-        shell: bash\n         env:\n           AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\""}, {"sha": "3ee7d07900700cdc1797ecbcbc1fcb8efd98c8df", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -2142,6 +2142,12 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"pathdiff\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"877630b3de15c0b64cc52f659345724fbf6bdad9bd9566699fc53688f3c34a34\"\n+\n [[package]]\n name = \"percent-encoding\"\n version = \"1.0.1\"\n@@ -3318,6 +3324,7 @@ dependencies = [\n  \"log\",\n  \"memmap\",\n  \"num_cpus\",\n+ \"pathdiff\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n  \"rustc_attr\","}, {"sha": "c3f1bac177de7dd6695196a0b12cc2ca69048cc5", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 66, "deletions": 38, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -349,6 +349,7 @@ def __init__(self):\n         self.use_vendored_sources = ''\n         self.verbose = False\n         self.git_version = None\n+        self.nix_deps_dir = None\n \n     def download_stage0(self):\n         \"\"\"Fetch the build system for Rust, written in Rust\n@@ -388,8 +389,12 @@ def support_xz():\n             filename = \"rustc-{}-{}{}\".format(rustc_channel, self.build,\n                                               tarball_suffix)\n             self._download_stage0_helper(filename, \"rustc\", tarball_suffix)\n-            self.fix_executable(\"{}/bin/rustc\".format(self.bin_root()))\n-            self.fix_executable(\"{}/bin/rustdoc\".format(self.bin_root()))\n+            self.fix_bin_or_dylib(\"{}/bin/rustc\".format(self.bin_root()))\n+            self.fix_bin_or_dylib(\"{}/bin/rustdoc\".format(self.bin_root()))\n+            lib_dir = \"{}/lib\".format(self.bin_root())\n+            for lib in os.listdir(lib_dir):\n+                if lib.endswith(\".so\"):\n+                    self.fix_bin_or_dylib(\"{}/{}\".format(lib_dir, lib))\n             with output(self.rustc_stamp()) as rust_stamp:\n                 rust_stamp.write(self.date)\n \n@@ -408,7 +413,7 @@ def support_xz():\n             filename = \"cargo-{}-{}{}\".format(cargo_channel, self.build,\n                                               tarball_suffix)\n             self._download_stage0_helper(filename, \"cargo\", tarball_suffix)\n-            self.fix_executable(\"{}/bin/cargo\".format(self.bin_root()))\n+            self.fix_bin_or_dylib(\"{}/bin/cargo\".format(self.bin_root()))\n             with output(self.cargo_stamp()) as cargo_stamp:\n                 cargo_stamp.write(self.date)\n \n@@ -421,8 +426,8 @@ def support_xz():\n                 [channel, date] = rustfmt_channel.split('-', 1)\n                 filename = \"rustfmt-{}-{}{}\".format(channel, self.build, tarball_suffix)\n                 self._download_stage0_helper(filename, \"rustfmt-preview\", tarball_suffix, date)\n-                self.fix_executable(\"{}/bin/rustfmt\".format(self.bin_root()))\n-                self.fix_executable(\"{}/bin/cargo-fmt\".format(self.bin_root()))\n+                self.fix_bin_or_dylib(\"{}/bin/rustfmt\".format(self.bin_root()))\n+                self.fix_bin_or_dylib(\"{}/bin/cargo-fmt\".format(self.bin_root()))\n                 with output(self.rustfmt_stamp()) as rustfmt_stamp:\n                     rustfmt_stamp.write(self.date + self.rustfmt_channel)\n \n@@ -440,12 +445,12 @@ def _download_stage0_helper(self, filename, pattern, tarball_suffix, date=None):\n             get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n         unpack(tarball, tarball_suffix, self.bin_root(), match=pattern, verbose=self.verbose)\n \n-    @staticmethod\n-    def fix_executable(fname):\n-        \"\"\"Modifies the interpreter section of 'fname' to fix the dynamic linker\n+    def fix_bin_or_dylib(self, fname):\n+        \"\"\"Modifies the interpreter section of 'fname' to fix the dynamic linker,\n+        or the RPATH section, to fix the dynamic library search path\n \n         This method is only required on NixOS and uses the PatchELF utility to\n-        change the dynamic linker of ELF executables.\n+        change the interpreter/RPATH of ELF executables.\n \n         Please see https://nixos.org/patchelf.html for more information\n         \"\"\"\n@@ -472,38 +477,61 @@ def fix_executable(fname):\n         nix_os_msg = \"info: you seem to be running NixOS. Attempting to patch\"\n         print(nix_os_msg, fname)\n \n-        try:\n-            interpreter = subprocess.check_output(\n-                [\"patchelf\", \"--print-interpreter\", fname])\n-            interpreter = interpreter.strip().decode(default_encoding)\n-        except subprocess.CalledProcessError as reason:\n-            print(\"warning: failed to call patchelf:\", reason)\n-            return\n-\n-        loader = interpreter.split(\"/\")[-1]\n-\n-        try:\n-            ldd_output = subprocess.check_output(\n-                ['ldd', '/run/current-system/sw/bin/sh'])\n-            ldd_output = ldd_output.strip().decode(default_encoding)\n-        except subprocess.CalledProcessError as reason:\n-            print(\"warning: unable to call ldd:\", reason)\n-            return\n-\n-        for line in ldd_output.splitlines():\n-            libname = line.split()[0]\n-            if libname.endswith(loader):\n-                loader_path = libname[:len(libname) - len(loader)]\n-                break\n+        # Only build `stage0/.nix-deps` once.\n+        nix_deps_dir = self.nix_deps_dir\n+        if not nix_deps_dir:\n+            nix_deps_dir = \"{}/.nix-deps\".format(self.bin_root())\n+            if not os.path.exists(nix_deps_dir):\n+                os.makedirs(nix_deps_dir)\n+\n+            nix_deps = [\n+                # Needed for the path of `ld-linux.so` (via `nix-support/dynamic-linker`).\n+                \"stdenv.cc.bintools\",\n+\n+                # Needed as a system dependency of `libLLVM-*.so`.\n+                \"zlib\",\n+\n+                # Needed for patching ELF binaries (see doc comment above).\n+                \"patchelf\",\n+            ]\n+\n+            # Run `nix-build` to \"build\" each dependency (which will likely reuse\n+            # the existing `/nix/store` copy, or at most download a pre-built copy).\n+            # Importantly, we don't rely on `nix-build` printing the `/nix/store`\n+            # path on stdout, but use `-o` to symlink it into `stage0/.nix-deps/$dep`,\n+            # ensuring garbage collection will never remove the `/nix/store` path\n+            # (which would break our patched binaries that hardcode those paths).\n+            for dep in nix_deps:\n+                try:\n+                    subprocess.check_output([\n+                        \"nix-build\", \"<nixpkgs>\",\n+                        \"-A\", dep,\n+                        \"-o\", \"{}/{}\".format(nix_deps_dir, dep),\n+                    ])\n+                except subprocess.CalledProcessError as reason:\n+                    print(\"warning: failed to call nix-build:\", reason)\n+                    return\n+\n+            self.nix_deps_dir = nix_deps_dir\n+\n+        patchelf = \"{}/patchelf/bin/patchelf\".format(nix_deps_dir)\n+\n+        if fname.endswith(\".so\"):\n+            # Dynamic library, patch RPATH to point to system dependencies.\n+            dylib_deps = [\"zlib\"]\n+            rpath_entries = [\n+                # Relative default, all binary and dynamic libraries we ship\n+                # appear to have this (even when `../lib` is redundant).\n+                \"$ORIGIN/../lib\",\n+            ] + [\"{}/{}/lib\".format(nix_deps_dir, dep) for dep in dylib_deps]\n+            patchelf_args = [\"--set-rpath\", \":\".join(rpath_entries)]\n         else:\n-            print(\"warning: unable to find the path to the dynamic linker\")\n-            return\n-\n-        correct_interpreter = loader_path + loader\n+            bintools_dir = \"{}/stdenv.cc.bintools\".format(nix_deps_dir)\n+            with open(\"{}/nix-support/dynamic-linker\".format(bintools_dir)) as dynamic_linker:\n+                patchelf_args = [\"--set-interpreter\", dynamic_linker.read().rstrip()]\n \n         try:\n-            subprocess.check_output(\n-                [\"patchelf\", \"--set-interpreter\", correct_interpreter, fname])\n+            subprocess.check_output([patchelf] + patchelf_args + [fname])\n         except subprocess.CalledProcessError as reason:\n             print(\"warning: failed to call patchelf:\", reason)\n             return"}, {"sha": "dcdc681e87dbb010e75ee5c34eee6951bd990da1", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -160,11 +160,6 @@ macro_rules! install {\n                 config.extended && config.tools.as_ref()\n                     .map_or(true, |t| t.contains($path))\n             }\n-\n-            #[allow(dead_code)]\n-            fn should_install(builder: &Builder<'_>) -> bool {\n-                builder.config.tools.as_ref().map_or(false, |t| t.contains($path))\n-            }\n         }\n \n         impl Step for $name {\n@@ -211,8 +206,7 @@ install!((self, builder, _config),\n         install_cargo(builder, self.compiler.stage, self.target);\n     };\n     Rls, \"rls\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Rls { compiler: self.compiler, target: self.target }).is_some() ||\n-            Self::should_install(builder) {\n+        if builder.ensure(dist::Rls { compiler: self.compiler, target: self.target }).is_some() {\n             install_rls(builder, self.compiler.stage, self.target);\n         } else {\n             builder.info(\n@@ -222,27 +216,14 @@ install!((self, builder, _config),\n     };\n     RustAnalyzer, \"rust-analyzer\", Self::should_build(_config), only_hosts: true, {\n         builder.ensure(dist::RustAnalyzer { compiler: self.compiler, target: self.target });\n-        if Self::should_install(builder) {\n-            install_rust_analyzer(builder, self.compiler.stage, self.target);\n-        } else {\n-            builder.info(\n-                &format!(\"skipping Install rust-analyzer stage{} ({})\", self.compiler.stage, self.target),\n-            );\n-        }\n+        install_rust_analyzer(builder, self.compiler.stage, self.target);\n     };\n     Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n         builder.ensure(dist::Clippy { compiler: self.compiler, target: self.target });\n-        if Self::should_install(builder) {\n-            install_clippy(builder, self.compiler.stage, self.target);\n-        } else {\n-            builder.info(\n-                &format!(\"skipping Install clippy stage{} ({})\", self.compiler.stage, self.target),\n-            );\n-        }\n+        install_clippy(builder, self.compiler.stage, self.target);\n     };\n     Miri, \"miri\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Miri { compiler: self.compiler, target: self.target }).is_some() ||\n-            Self::should_install(builder) {\n+        if builder.ensure(dist::Miri { compiler: self.compiler, target: self.target }).is_some() {\n             install_miri(builder, self.compiler.stage, self.target);\n         } else {\n             builder.info(\n@@ -254,7 +235,7 @@ install!((self, builder, _config),\n         if builder.ensure(dist::Rustfmt {\n             compiler: self.compiler,\n             target: self.target\n-        }).is_some() || Self::should_install(builder) {\n+        }).is_some() {\n             install_rustfmt(builder, self.compiler.stage, self.target);\n         } else {\n             builder.info("}, {"sha": "26ce69e33d9c3ea14450b82061ac05a0a88874b6", "filename": "src/ci/exec-with-shell.py", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fci%2Fexec-with-shell.py", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fci%2Fexec-with-shell.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fexec-with-shell.py?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -1,16 +0,0 @@\n-#!/usr/bin/env python\n-# A simple wrapper that forwards the arguments to bash, unless the\n-# CI_OVERRIDE_SHELL environment variable is present: in that case the content\n-# of that environment variable is used as the shell path.\n-\n-import os\n-import sys\n-import subprocess\n-\n-try:\n-    shell = os.environ[\"CI_OVERRIDE_SHELL\"]\n-except KeyError:\n-    shell = \"bash\"\n-\n-res = subprocess.call([shell] + sys.argv[1:])\n-sys.exit(res)"}, {"sha": "5573d87aa2e55c278399a8f0e0c1b6a12bf11600", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -79,7 +79,6 @@ x--expand-yaml-anchors--remove:\n     steps:\n       - name: disable git crlf conversion\n         run: git config --global core.autocrlf false\n-        shell: bash\n \n       - name: checkout the source code\n         uses: actions/checkout@v1\n@@ -95,7 +94,6 @@ x--expand-yaml-anchors--remove:\n \n       - name: add extra environment variables\n         run: src/ci/scripts/setup-environment.sh\n-        shell: bash\n         env:\n           # Since it's not possible to merge `${{ matrix.env }}` with the other\n           # variables in `job.<name>.env`, the variables defined in the matrix\n@@ -106,67 +104,54 @@ x--expand-yaml-anchors--remove:\n \n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n-        shell: bash\n         <<: *step\n \n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n-        shell: bash\n         <<: *step\n \n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n-        shell: bash\n         <<: *step\n \n       - name: install awscli\n         run: src/ci/scripts/install-awscli.sh\n-        shell: bash\n         <<: *step\n \n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n-        shell: bash\n         <<: *step\n \n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n-        shell: bash\n         <<: *step\n \n       - name: install WIX\n         run: src/ci/scripts/install-wix.sh\n-        shell: bash\n         <<: *step\n \n       - name: ensure the build happens on a partition with enough space\n         run: src/ci/scripts/symlink-build-dir.sh\n-        shell: bash\n         <<: *step\n \n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: bash\n         <<: *step\n \n       - name: install MSYS2\n         run: src/ci/scripts/install-msys2.sh\n-        shell: bash\n         <<: *step\n \n       - name: install MinGW\n         run: src/ci/scripts/install-mingw.sh\n-        shell: bash\n         <<: *step\n \n       - name: install ninja\n         run: src/ci/scripts/install-ninja.sh\n-        shell: bash\n         <<: *step\n \n       - name: enable ipv6 on Docker\n         run: src/ci/scripts/enable-docker-ipv6.sh\n-        shell: bash\n         <<: *step\n \n       # Disable automatic line ending conversion (again). On Windows, when we're\n@@ -176,22 +161,18 @@ x--expand-yaml-anchors--remove:\n       # appropriate line endings.\n       - name: disable git crlf conversion\n         run: src/ci/scripts/disable-git-crlf-conversion.sh\n-        shell: bash\n         <<: *step\n \n       - name: checkout submodules\n         run: src/ci/scripts/checkout-submodules.sh\n-        shell: bash\n         <<: *step\n \n       - name: ensure line endings are correct\n         run: src/ci/scripts/verify-line-endings.sh\n-        shell: bash\n         <<: *step\n \n       - name: run the build\n         run: src/ci/scripts/run-build-from-ci.sh\n-        shell: bash\n         env:\n           AWS_ACCESS_KEY_ID: ${{ env.CACHES_AWS_ACCESS_KEY_ID }}\n           AWS_SECRET_ACCESS_KEY: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\n@@ -200,7 +181,6 @@ x--expand-yaml-anchors--remove:\n \n       - name: upload artifacts to S3\n         run: src/ci/scripts/upload-artifacts.sh\n-        shell: bash\n         env:\n           AWS_ACCESS_KEY_ID: ${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\n           AWS_SECRET_ACCESS_KEY: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\n@@ -250,18 +230,10 @@ on:\n \n defaults:\n   run:\n-    # While on Linux and macOS builders it just forwards the arguments to the\n-    # system bash, this wrapper allows switching from the host's bash.exe to\n-    # the one we install along with MSYS2 mid-build on Windows.\n-    #\n-    # Once the step to install MSYS2 is executed, the CI_OVERRIDE_SHELL\n-    # environment variable is set pointing to our MSYS2's bash.exe. From that\n-    # moment the host's bash.exe will not be called anymore.\n-    #\n-    # This is needed because we can't launch our own bash.exe from the host\n-    # bash.exe, as that would load two different cygwin1.dll in memory, causing\n-    # \"cygwin heap mismatch\" errors.\n-    shell: python src/ci/exec-with-shell.py {0}\n+    # On Linux, macOS, and Windows, use the system-provided bash as the default\n+    # shell. (This should only make a difference on Windows, where the default\n+    # shell is PowerShell.)\n+    shell: bash\n \n jobs:\n   pr:"}, {"sha": "185d361582505224f9a223ca0a1d78ff14b79ae9", "filename": "src/ci/scripts/install-msys2.sh", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Fci%2Fscripts%2Finstall-msys2.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Fci%2Fscripts%2Finstall-msys2.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2.sh?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -12,9 +12,6 @@ if isWindows; then\n     mkdir -p \"${msys2Path}/home/${USERNAME}\"\n     ciCommandAddPath \"${msys2Path}/usr/bin\"\n \n-    echo \"switching shell to use our own bash\"\n-    ciCommandSetEnv CI_OVERRIDE_SHELL \"${msys2Path}/usr/bin/bash.exe\"\n-\n     # Detect the native Python version installed on the agent. On GitHub\n     # Actions, the C:\\hostedtoolcache\\windows\\Python directory contains a\n     # subdirectory for each installed Python version."}, {"sha": "530cb0c91b8e314894a198802100ad04873f792d", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -22,7 +22,6 @@ use super::Recover;\n /// to any other item, as determined by the [`Ord`] trait, changes while it is in the set. This is\n /// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n ///\n-/// [`BTreeMap`]: struct.BTreeMap.html\n /// [`Ord`]: ../../std/cmp/trait.Ord.html\n /// [`Cell`]: ../../std/cell/struct.Cell.html\n /// [`RefCell`]: ../../std/cell/struct.RefCell.html\n@@ -78,8 +77,7 @@ impl<T: Clone> Clone for BTreeSet<T> {\n /// This `struct` is created by the [`iter`] method on [`BTreeSet`].\n /// See its documentation for more.\n ///\n-/// [`BTreeSet`]: struct.BTreeSet.html\n-/// [`iter`]: struct.BTreeSet.html#method.iter\n+/// [`iter`]: BTreeSet::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     iter: Keys<'a, T, ()>,\n@@ -97,8 +95,7 @@ impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n /// This `struct` is created by the [`into_iter`] method on [`BTreeSet`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n-/// [`BTreeSet`]: struct.BTreeSet.html\n-/// [`into_iter`]: struct.BTreeSet.html#method.into_iter\n+/// [`into_iter`]: BTreeSet#method.into_iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IntoIter<T> {\n@@ -110,8 +107,7 @@ pub struct IntoIter<T> {\n /// This `struct` is created by the [`range`] method on [`BTreeSet`].\n /// See its documentation for more.\n ///\n-/// [`BTreeSet`]: struct.BTreeSet.html\n-/// [`range`]: struct.BTreeSet.html#method.range\n+/// [`range`]: BTreeSet::range\n #[derive(Debug)]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, T: 'a> {\n@@ -194,8 +190,7 @@ where\n /// This `struct` is created by the [`difference`] method on [`BTreeSet`].\n /// See its documentation for more.\n ///\n-/// [`BTreeSet`]: struct.BTreeSet.html\n-/// [`difference`]: struct.BTreeSet.html#method.difference\n+/// [`difference`]: BTreeSet::difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T: 'a> {\n     inner: DifferenceInner<'a, T>,\n@@ -227,8 +222,7 @@ impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n /// This `struct` is created by the [`symmetric_difference`] method on\n /// [`BTreeSet`]. See its documentation for more.\n ///\n-/// [`BTreeSet`]: struct.BTreeSet.html\n-/// [`symmetric_difference`]: struct.BTreeSet.html#method.symmetric_difference\n+/// [`symmetric_difference`]: BTreeSet::symmetric_difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n \n@@ -244,8 +238,7 @@ impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n /// This `struct` is created by the [`intersection`] method on [`BTreeSet`].\n /// See its documentation for more.\n ///\n-/// [`BTreeSet`]: struct.BTreeSet.html\n-/// [`intersection`]: struct.BTreeSet.html#method.intersection\n+/// [`intersection`]: BTreeSet::intersection\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T: 'a> {\n     inner: IntersectionInner<'a, T>,\n@@ -277,8 +270,7 @@ impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n /// This `struct` is created by the [`union`] method on [`BTreeSet`].\n /// See its documentation for more.\n ///\n-/// [`BTreeSet`]: struct.BTreeSet.html\n-/// [`union`]: struct.BTreeSet.html#method.union\n+/// [`union`]: BTreeSet::union\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n "}, {"sha": "5cf7217ef11e81724f0c34482f1f9b18a780a063", "filename": "src/libcore/lazy.rs", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibcore%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibcore%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flazy.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -0,0 +1,379 @@\n+//! Lazy values and one-time initialization of static data.\n+\n+use crate::cell::{Cell, UnsafeCell};\n+use crate::fmt;\n+use crate::mem;\n+use crate::ops::Deref;\n+\n+/// A cell which can be written to only once.\n+///\n+/// Unlike `RefCell`, a `OnceCell` only provides shared `&T` references to its value.\n+/// Unlike `Cell`, a `OnceCell` doesn't require copying or replacing the value to access it.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::lazy::OnceCell;\n+///\n+/// let cell = OnceCell::new();\n+/// assert!(cell.get().is_none());\n+///\n+/// let value: &String = cell.get_or_init(|| {\n+///     \"Hello, World!\".to_string()\n+/// });\n+/// assert_eq!(value, \"Hello, World!\");\n+/// assert!(cell.get().is_some());\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct OnceCell<T> {\n+    // Invariant: written to at most once.\n+    inner: UnsafeCell<Option<T>>,\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T> Default for OnceCell<T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.get() {\n+            Some(v) => f.debug_tuple(\"OnceCell\").field(v).finish(),\n+            None => f.write_str(\"OnceCell(Uninit)\"),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Clone> Clone for OnceCell<T> {\n+    fn clone(&self) -> OnceCell<T> {\n+        let res = OnceCell::new();\n+        if let Some(value) = self.get() {\n+            match res.set(value.clone()) {\n+                Ok(()) => (),\n+                Err(_) => unreachable!(),\n+            }\n+        }\n+        res\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: PartialEq> PartialEq for OnceCell<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Eq> Eq for OnceCell<T> {}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T> From<T> for OnceCell<T> {\n+    fn from(value: T) -> Self {\n+        OnceCell { inner: UnsafeCell::new(Some(value)) }\n+    }\n+}\n+\n+impl<T> OnceCell<T> {\n+    /// Creates a new empty cell.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub const fn new() -> OnceCell<T> {\n+        OnceCell { inner: UnsafeCell::new(None) }\n+    }\n+\n+    /// Gets the reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get(&self) -> Option<&T> {\n+        // Safety: Safe due to `inner`'s invariant\n+        unsafe { &*self.inner.get() }.as_ref()\n+    }\n+\n+    /// Gets the mutable reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_mut(&mut self) -> Option<&mut T> {\n+        // Safety: Safe because we have unique access\n+        unsafe { &mut *self.inner.get() }.as_mut()\n+    }\n+\n+    /// Sets the contents of the cell to `value`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This method returns `Ok(())` if the cell was empty and `Err(value)` if\n+    /// it was full.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// assert!(cell.get().is_none());\n+    ///\n+    /// assert_eq!(cell.set(92), Ok(()));\n+    /// assert_eq!(cell.set(62), Err(62));\n+    ///\n+    /// assert!(cell.get().is_some());\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn set(&self, value: T) -> Result<(), T> {\n+        // Safety: Safe because we cannot have overlapping mutable borrows\n+        let slot = unsafe { &*self.inner.get() };\n+        if slot.is_some() {\n+            return Err(value);\n+        }\n+\n+        // Safety: This is the only place where we set the slot, no races\n+        // due to reentrancy/concurrency are possible, and we've\n+        // checked that slot is currently `None`, so this write\n+        // maintains the `inner`'s invariant.\n+        let slot = unsafe { &mut *self.inner.get() };\n+        *slot = Some(value);\n+        Ok(())\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f`\n+    /// if the cell was empty.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. Doing\n+    /// so results in a panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// let value = cell.get_or_init(|| 92);\n+    /// assert_eq!(value, &92);\n+    /// let value = cell.get_or_init(|| unreachable!());\n+    /// assert_eq!(value, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_init<F>(&self, f: F) -> &T\n+    where\n+        F: FnOnce() -> T,\n+    {\n+        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n+            Ok(val) => val,\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if\n+    /// the cell was empty. If the cell was empty and `f` failed, an\n+    /// error is returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. Doing\n+    /// so results in a panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+    /// assert!(cell.get().is_none());\n+    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n+    ///     Ok(92)\n+    /// });\n+    /// assert_eq!(value, Ok(&92));\n+    /// assert_eq!(cell.get(), Some(&92))\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        if let Some(val) = self.get() {\n+            return Ok(val);\n+        }\n+        let val = f()?;\n+        // Note that *some* forms of reentrant initialization might lead to\n+        // UB (see `reentrant_init` test). I believe that just removing this\n+        // `assert`, while keeping `set/get` would be sound, but it seems\n+        // better to panic, rather than to silently use an old value.\n+        assert!(self.set(val).is_ok(), \"reentrant init\");\n+        Ok(self.get().unwrap())\n+    }\n+\n+    /// Consumes the cell, returning the wrapped value.\n+    ///\n+    /// Returns `None` if the cell was empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell: OnceCell<String> = OnceCell::new();\n+    /// assert_eq!(cell.into_inner(), None);\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn into_inner(self) -> Option<T> {\n+        // Because `into_inner` takes `self` by value, the compiler statically verifies\n+        // that it is not currently borrowed. So it is safe to move out `Option<T>`.\n+        self.inner.into_inner()\n+    }\n+\n+    /// Takes the value out of this `OnceCell`, moving it back to an uninitialized state.\n+    ///\n+    /// Has no effect and returns `None` if the `OnceCell` hasn't been initialized.\n+    ///\n+    /// Safety is guaranteed by requiring a mutable reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let mut cell: OnceCell<String> = OnceCell::new();\n+    /// assert_eq!(cell.take(), None);\n+    ///\n+    /// let mut cell = OnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n+    /// assert_eq!(cell.get(), None);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn take(&mut self) -> Option<T> {\n+        mem::take(self).into_inner()\n+    }\n+}\n+\n+/// A value which is initialized on the first access.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::lazy::Lazy;\n+///\n+/// let lazy: Lazy<i32> = Lazy::new(|| {\n+///     println!(\"initializing\");\n+///     92\n+/// });\n+/// println!(\"ready\");\n+/// println!(\"{}\", *lazy);\n+/// println!(\"{}\", *lazy);\n+///\n+/// // Prints:\n+/// //   ready\n+/// //   initializing\n+/// //   92\n+/// //   92\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct Lazy<T, F = fn() -> T> {\n+    cell: OnceCell<T>,\n+    init: Cell<Option<F>>,\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug, F> fmt::Debug for Lazy<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n+    }\n+}\n+\n+impl<T, F> Lazy<T, F> {\n+    /// Creates a new lazy value with the given initializing function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// # fn main() {\n+    /// use std::lazy::Lazy;\n+    ///\n+    /// let hello = \"Hello, World!\".to_string();\n+    ///\n+    /// let lazy = Lazy::new(|| hello.to_uppercase());\n+    ///\n+    /// assert_eq!(&*lazy, \"HELLO, WORLD!\");\n+    /// # }\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub const fn new(init: F) -> Lazy<T, F> {\n+        Lazy { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n+    }\n+}\n+\n+impl<T, F: FnOnce() -> T> Lazy<T, F> {\n+    /// Forces the evaluation of this lazy value and returns a reference to\n+    /// the result.\n+    ///\n+    /// This is equivalent to the `Deref` impl, but is explicit.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::Lazy;\n+    ///\n+    /// let lazy = Lazy::new(|| 92);\n+    ///\n+    /// assert_eq!(Lazy::force(&lazy), &92);\n+    /// assert_eq!(&*lazy, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn force(this: &Lazy<T, F>) -> &T {\n+        this.cell.get_or_init(|| match this.init.take() {\n+            Some(f) => f(),\n+            None => panic!(\"`Lazy` instance has previously been poisoned\"),\n+        })\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F: FnOnce() -> T> Deref for Lazy<T, F> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        Lazy::force(self)\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Default> Default for Lazy<T> {\n+    /// Creates a new lazy value using `Default` as the initializing function.\n+    fn default() -> Lazy<T> {\n+        Lazy::new(T::default)\n+    }\n+}"}, {"sha": "1621cf79751665fe32d70efda4bea36a44f8afed", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -239,6 +239,8 @@ pub mod char;\n pub mod ffi;\n #[cfg(not(test))] // See #65860\n pub mod iter;\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub mod lazy;\n pub mod option;\n pub mod panic;\n pub mod panicking;"}, {"sha": "20b2c3d3c965a8eb2c4cbc7d5de1e2891492cd1b", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -6095,7 +6095,7 @@ pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * `data` must be [valid] for writes for `len * mem::size_of::<T>()` many bytes,\n+/// * `data` must be [valid] for boths reads and writes for `len * mem::size_of::<T>()` many bytes,\n ///   and it must be properly aligned. This means in particular:\n ///\n ///     * The entire memory range of this slice must be contained within a single allocated object!"}, {"sha": "faf58cafbb70b626d582c91b31822a316800d807", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 73, "deletions": 153, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -31,9 +31,8 @@ pub mod lossy;\n /// `FromStr`'s [`from_str`] method is often used implicitly, through\n /// [`str`]'s [`parse`] method. See [`parse`]'s documentation for examples.\n ///\n-/// [`from_str`]: #tymethod.from_str\n-/// [`str`]: ../../std/primitive.str.html\n-/// [`parse`]: ../../std/primitive.str.html#method.parse\n+/// [`from_str`]: FromStr::from_str\n+/// [`parse`]: str::parse\n ///\n /// `FromStr` does not have a lifetime parameter, and so you can only parse types\n /// that do not contain a lifetime parameter themselves. In other words, you can\n@@ -143,7 +142,7 @@ impl FromStr for bool {\n \n /// An error returned when parsing a `bool` using [`from_str`] fails\n ///\n-/// [`from_str`]: ../../std/primitive.bool.html#method.from_str\n+/// [`from_str`]: FromStr::from_str\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseBoolError {\n@@ -266,8 +265,7 @@ impl Utf8Error {\n /// that it is valid UTF-8. `from_utf8()` checks to ensure that the bytes are valid\n /// UTF-8, and then does the conversion.\n ///\n-/// [`&str`]: ../../std/primitive.str.html\n-/// [`u8`]: ../../std/primitive.u8.html\n+/// [`&str`]: str\n /// [byteslice]: ../../std/primitive.slice.html\n ///\n /// If you are sure that the byte slice is valid UTF-8, and you don't want to\n@@ -398,7 +396,7 @@ pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n /// it are valid UTF-8. If this constraint is violated, undefined behavior\n /// results, as the rest of Rust assumes that [`&str`]s are valid UTF-8.\n ///\n-/// [`&str`]: ../../std/primitive.str.html\n+/// [`&str`]: str\n ///\n /// # Examples\n ///\n@@ -429,9 +427,7 @@ pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n /// Converts a slice of bytes to a string slice without checking\n /// that the string contains valid UTF-8; mutable version.\n ///\n-/// See the immutable version, [`from_utf8_unchecked()`][fromutf8], for more information.\n-///\n-/// [fromutf8]: fn.from_utf8_unchecked.html\n+/// See the immutable version, [`from_utf8_unchecked()`] for more information.\n ///\n /// # Examples\n ///\n@@ -476,13 +472,11 @@ Section: Iterators\n \n /// An iterator over the [`char`]s of a string slice.\n ///\n-/// [`char`]: ../../std/primitive.char.html\n ///\n /// This struct is created by the [`chars`] method on [`str`].\n /// See its documentation for more.\n ///\n-/// [`chars`]: ../../std/primitive.str.html#method.chars\n-/// [`str`]: ../../std/primitive.str.html\n+/// [`chars`]: str::chars\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chars<'a> {\n@@ -676,13 +670,10 @@ impl<'a> Chars<'a> {\n \n /// An iterator over the [`char`]s of a string slice, and their positions.\n ///\n-/// [`char`]: ../../std/primitive.char.html\n-///\n /// This struct is created by the [`char_indices`] method on [`str`].\n /// See its documentation for more.\n ///\n-/// [`char_indices`]: ../../std/primitive.str.html#method.char_indices\n-/// [`str`]: ../../std/primitive.str.html\n+/// [`char_indices`]: str::char_indices\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CharIndices<'a> {\n@@ -756,8 +747,7 @@ impl<'a> CharIndices<'a> {\n /// This struct is created by the [`bytes`] method on [`str`].\n /// See its documentation for more.\n ///\n-/// [`bytes`]: ../../std/primitive.str.html#method.bytes\n-/// [`str`]: ../../std/primitive.str.html\n+/// [`bytes`]: str::bytes\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone, Debug)]\n pub struct Bytes<'a>(Copied<slice::Iter<'a, u8>>);\n@@ -1249,12 +1239,12 @@ generate_pattern_iterators! {\n     forward:\n         /// Created with the method [`split`].\n         ///\n-        /// [`split`]: ../../std/primitive.str.html#method.split\n+        /// [`split`]: str::split\n         struct Split;\n     reverse:\n         /// Created with the method [`rsplit`].\n         ///\n-        /// [`rsplit`]: ../../std/primitive.str.html#method.rsplit\n+        /// [`rsplit`]: str::rsplit\n         struct RSplit;\n     stability:\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1267,12 +1257,12 @@ generate_pattern_iterators! {\n     forward:\n         /// Created with the method [`split_terminator`].\n         ///\n-        /// [`split_terminator`]: ../../std/primitive.str.html#method.split_terminator\n+        /// [`split_terminator`]: str::split_terminator\n         struct SplitTerminator;\n     reverse:\n         /// Created with the method [`rsplit_terminator`].\n         ///\n-        /// [`rsplit_terminator`]: ../../std/primitive.str.html#method.rsplit_terminator\n+        /// [`rsplit_terminator`]: str::rsplit_terminator\n         struct RSplitTerminator;\n     stability:\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1343,12 +1333,12 @@ generate_pattern_iterators! {\n     forward:\n         /// Created with the method [`splitn`].\n         ///\n-        /// [`splitn`]: ../../std/primitive.str.html#method.splitn\n+        /// [`splitn`]: str::splitn\n         struct SplitN;\n     reverse:\n         /// Created with the method [`rsplitn`].\n         ///\n-        /// [`rsplitn`]: ../../std/primitive.str.html#method.rsplitn\n+        /// [`rsplitn`]: str::rsplitn\n         struct RSplitN;\n     stability:\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1398,12 +1388,12 @@ generate_pattern_iterators! {\n     forward:\n         /// Created with the method [`match_indices`].\n         ///\n-        /// [`match_indices`]: ../../std/primitive.str.html#method.match_indices\n+        /// [`match_indices`]: str::match_indices\n         struct MatchIndices;\n     reverse:\n         /// Created with the method [`rmatch_indices`].\n         ///\n-        /// [`rmatch_indices`]: ../../std/primitive.str.html#method.rmatch_indices\n+        /// [`rmatch_indices`]: str::rmatch_indices\n         struct RMatchIndices;\n     stability:\n         #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n@@ -1455,12 +1445,12 @@ generate_pattern_iterators! {\n     forward:\n         /// Created with the method [`matches`].\n         ///\n-        /// [`matches`]: ../../std/primitive.str.html#method.matches\n+        /// [`matches`]: str::matches\n         struct Matches;\n     reverse:\n         /// Created with the method [`rmatches`].\n         ///\n-        /// [`rmatches`]: ../../std/primitive.str.html#method.rmatches\n+        /// [`rmatches`]: str::rmatches\n         struct RMatches;\n     stability:\n         #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n@@ -1474,8 +1464,7 @@ generate_pattern_iterators! {\n /// This struct is created with the [`lines`] method on [`str`].\n /// See its documentation for more.\n ///\n-/// [`lines`]: ../../std/primitive.str.html#method.lines\n-/// [`str`]: ../../std/primitive.str.html\n+/// [`lines`]: str::lines\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone, Debug)]\n pub struct Lines<'a>(Map<SplitTerminator<'a, char>, LinesAnyMap>);\n@@ -1513,7 +1502,7 @@ impl FusedIterator for Lines<'_> {}\n \n /// Created with the method [`lines_any`].\n ///\n-/// [`lines_any`]: ../../std/primitive.str.html#method.lines_any\n+/// [`lines_any`]: str::lines_any\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(since = \"1.4.0\", reason = \"use lines()/Lines instead now\")]\n #[derive(Clone, Debug)]\n@@ -2347,9 +2336,7 @@ impl str {\n     }\n \n     /// Converts a string slice to a byte slice. To convert the byte slice back\n-    /// into a string slice, use the [`str::from_utf8`] function.\n-    ///\n-    /// [`str::from_utf8`]: ./str/fn.from_utf8.html\n+    /// into a string slice, use the [`from_utf8`] function.\n     ///\n     /// # Examples\n     ///\n@@ -2429,8 +2416,7 @@ impl str {\n     /// The caller must ensure that the returned pointer is never written to.\n     /// If you need to mutate the contents of the string slice, use [`as_mut_ptr`].\n     ///\n-    /// [`u8`]: primitive.u8.html\n-    /// [`as_mut_ptr`]: #method.as_mut_ptr\n+    /// [`as_mut_ptr`]: str::as_mut_ptr\n     ///\n     /// # Examples\n     ///\n@@ -2455,8 +2441,6 @@ impl str {\n     ///\n     /// It is your responsibility to make sure that the string slice only gets\n     /// modified in a way that it remains valid UTF-8.\n-    ///\n-    /// [`u8`]: primitive.u8.html\n     #[stable(feature = \"str_as_mut_ptr\", since = \"1.36.0\")]\n     #[inline]\n     pub fn as_mut_ptr(&mut self) -> *mut u8 {\n@@ -2468,8 +2452,6 @@ impl str {\n     /// This is the non-panicking alternative to indexing the `str`. Returns\n     /// [`None`] whenever equivalent indexing operation would panic.\n     ///\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2495,8 +2477,6 @@ impl str {\n     /// This is the non-panicking alternative to indexing the `str`. Returns\n     /// [`None`] whenever equivalent indexing operation would panic.\n     ///\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2600,16 +2580,15 @@ impl str {\n     /// This is generally not recommended, use with caution! For a safe\n     /// alternative see [`str`] and [`Index`].\n     ///\n-    /// [`str`]: primitive.str.html\n-    /// [`Index`]: ops/trait.Index.html\n+    /// [`Index`]: crate::ops::Index\n     ///\n     /// This new slice goes from `begin` to `end`, including `begin` but\n     /// excluding `end`.\n     ///\n     /// To get a mutable string slice instead, see the\n     /// [`slice_mut_unchecked`] method.\n     ///\n-    /// [`slice_mut_unchecked`]: #method.slice_mut_unchecked\n+    /// [`slice_mut_unchecked`]: str::slice_mut_unchecked\n     ///\n     /// # Safety\n     ///\n@@ -2652,16 +2631,15 @@ impl str {\n     /// This is generally not recommended, use with caution! For a safe\n     /// alternative see [`str`] and [`IndexMut`].\n     ///\n-    /// [`str`]: primitive.str.html\n-    /// [`IndexMut`]: ops/trait.IndexMut.html\n+    /// [`IndexMut`]: crate::ops::IndexMut\n     ///\n     /// This new slice goes from `begin` to `end`, including `begin` but\n     /// excluding `end`.\n     ///\n     /// To get an immutable string slice instead, see the\n     /// [`slice_unchecked`] method.\n     ///\n-    /// [`slice_unchecked`]: #method.slice_unchecked\n+    /// [`slice_unchecked`]: str::slice_unchecked\n     ///\n     /// # Safety\n     ///\n@@ -2692,7 +2670,7 @@ impl str {\n     /// To get mutable string slices instead, see the [`split_at_mut`]\n     /// method.\n     ///\n-    /// [`split_at_mut`]: #method.split_at_mut\n+    /// [`split_at_mut`]: str::split_at_mut\n     ///\n     /// # Panics\n     ///\n@@ -2733,7 +2711,7 @@ impl str {\n     ///\n     /// To get immutable string slices instead, see the [`split_at`] method.\n     ///\n-    /// [`split_at`]: #method.split_at\n+    /// [`split_at`]: str::split_at\n     ///\n     /// # Panics\n     ///\n@@ -2913,7 +2891,7 @@ impl str {\n     /// Core Property `White_Space`. If you only want to split on ASCII whitespace\n     /// instead, use [`split_ascii_whitespace`].\n     ///\n-    /// [`split_ascii_whitespace`]: #method.split_ascii_whitespace\n+    /// [`split_ascii_whitespace`]: str::split_ascii_whitespace\n     ///\n     /// # Examples\n     ///\n@@ -2954,7 +2932,7 @@ impl str {\n     ///\n     /// To split by Unicode `Whitespace` instead, use [`split_whitespace`].\n     ///\n-    /// [`split_whitespace`]: #method.split_whitespace\n+    /// [`split_whitespace`]: str::split_whitespace\n     ///\n     /// # Examples\n     ///\n@@ -3068,8 +3046,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Examples\n     ///\n@@ -3095,8 +3072,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Examples\n     ///\n@@ -3121,8 +3097,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Examples\n     ///\n@@ -3150,9 +3125,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Examples\n     ///\n@@ -3199,9 +3172,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Examples\n     ///\n@@ -3247,21 +3218,18 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n     /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n     /// If the pattern allows a reverse search but its results might differ\n     /// from a forward search, the [`rsplit`] method can be used.\n     ///\n-    /// [`rsplit`]: #method.rsplit\n+    /// [`rsplit`]: str::rsplit\n     ///\n     /// # Examples\n     ///\n@@ -3348,7 +3316,7 @@ impl str {\n     ///\n     /// Use [`split_whitespace`] for this behavior.\n     ///\n-    /// [`split_whitespace`]: #method.split_whitespace\n+    /// [`split_whitespace`]: str::split_whitespace\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n@@ -3369,8 +3337,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Examples\n     ///\n@@ -3409,20 +3376,17 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n     ///\n     /// The returned iterator requires that the pattern supports a reverse\n     /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n     /// search yields the same elements.\n     ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n     /// For iterating from the front, the [`split`] method can be used.\n     ///\n-    /// [`split`]: #method.split\n+    /// [`split`]: str::split\n     ///\n     /// # Examples\n     ///\n@@ -3463,13 +3427,12 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// Equivalent to [`split`], except that the trailing substring\n     /// is skipped if empty.\n     ///\n-    /// [`split`]: #method.split\n+    /// [`split`]: str::split\n     ///\n     /// This method can be used for string data that is _terminated_,\n     /// rather than _separated_ by a pattern.\n@@ -3480,12 +3443,10 @@ impl str {\n     /// allows a reverse search and forward/reverse search yields the same\n     /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n     /// If the pattern allows a reverse search but its results might differ\n     /// from a forward search, the [`rsplit_terminator`] method can be used.\n     ///\n-    /// [`rsplit_terminator`]: #method.rsplit_terminator\n+    /// [`rsplit_terminator`]: str::rsplit_terminator\n     ///\n     /// # Examples\n     ///\n@@ -3510,13 +3471,12 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// Equivalent to [`split`], except that the trailing substring is\n     /// skipped if empty.\n     ///\n-    /// [`split`]: #method.split\n+    /// [`split`]: str::split\n     ///\n     /// This method can be used for string data that is _terminated_,\n     /// rather than _separated_ by a pattern.\n@@ -3530,7 +3490,7 @@ impl str {\n     /// For iterating from the front, the [`split_terminator`] method can be\n     /// used.\n     ///\n-    /// [`split_terminator`]: #method.split_terminator\n+    /// [`split_terminator`]: str::split_terminator\n     ///\n     /// # Examples\n     ///\n@@ -3559,8 +3519,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3570,7 +3529,7 @@ impl str {\n     /// If the pattern allows a reverse search, the [`rsplitn`] method can be\n     /// used.\n     ///\n-    /// [`rsplitn`]: #method.rsplitn\n+    /// [`rsplitn`]: str::rsplitn\n     ///\n     /// # Examples\n     ///\n@@ -3612,8 +3571,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3622,7 +3580,7 @@ impl str {\n     ///\n     /// For splitting from the front, the [`splitn`] method can be used.\n     ///\n-    /// [`splitn`]: #method.splitn\n+    /// [`splitn`]: str::splitn\n     ///\n     /// # Examples\n     ///\n@@ -3660,21 +3618,18 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n     /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n     /// If the pattern allows a reverse search but its results might differ\n     /// from a forward search, the [`rmatches`] method can be used.\n     ///\n-    /// [`rmatches`]: #method.rmatches\n+    /// [`rmatches`]: str::matches\n     ///\n     /// # Examples\n     ///\n@@ -3699,20 +3654,17 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n     ///\n     /// The returned iterator requires that the pattern supports a reverse\n     /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n     /// search yields the same elements.\n     ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n     /// For iterating from the front, the [`matches`] method can be used.\n     ///\n-    /// [`matches`]: #method.matches\n+    /// [`matches`]: str::matches\n     ///\n     /// # Examples\n     ///\n@@ -3743,21 +3695,18 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n     /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n     /// If the pattern allows a reverse search but its results might differ\n     /// from a forward search, the [`rmatch_indices`] method can be used.\n     ///\n-    /// [`rmatch_indices`]: #method.rmatch_indices\n+    /// [`rmatch_indices`]: str::match_indices\n     ///\n     /// # Examples\n     ///\n@@ -3788,20 +3737,17 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n     ///\n     /// The returned iterator requires that the pattern supports a reverse\n     /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n     /// search yields the same elements.\n     ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n     /// For iterating from the front, the [`match_indices`] method can be used.\n     ///\n-    /// [`match_indices`]: #method.match_indices\n+    /// [`match_indices`]: str::match_indices\n     ///\n     /// # Examples\n     ///\n@@ -4009,8 +3955,7 @@ impl str {\n     /// The [pattern] can be a [`char`], a slice of [`char`]s, or a function\n     /// or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Examples\n     ///\n@@ -4057,8 +4002,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Text directionality\n     ///\n@@ -4102,8 +4046,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Examples\n     ///\n@@ -4130,8 +4073,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Examples\n     ///\n@@ -4157,8 +4099,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Text directionality\n     ///\n@@ -4206,8 +4147,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Text directionality\n     ///\n@@ -4243,8 +4183,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n-    /// [`char`]: primitive.char.html\n-    /// [pattern]: str/pattern/index.html\n+    /// [pattern]: self::pattern\n     ///\n     /// # Text directionality\n     ///\n@@ -4292,15 +4231,14 @@ impl str {\n     /// you're trying to parse into.\n     ///\n     /// `parse` can parse any type that implements the [`FromStr`] trait.\n-    ///\n-    /// [`FromStr`]: str/trait.FromStr.html\n+\n     ///\n     /// # Errors\n     ///\n     /// Will return [`Err`] if it's not possible to parse this string slice into\n     /// the desired type.\n     ///\n-    /// [`Err`]: str/trait.FromStr.html#associatedtype.Err\n+    /// [`Err`]: FromStr::Err\n     ///\n     /// # Examples\n     ///\n@@ -4428,8 +4366,6 @@ impl str {\n     /// Note: only extended grapheme codepoints that begin the string will be\n     /// escaped.\n     ///\n-    /// [`char::escape_debug`]: ../std/primitive.char.html#method.escape_debug\n-    ///\n     /// # Examples\n     ///\n     /// As an iterator:\n@@ -4474,8 +4410,6 @@ impl str {\n \n     /// Return an iterator that escapes each char in `self` with [`char::escape_default`].\n     ///\n-    /// [`char::escape_default`]: ../std/primitive.char.html#method.escape_default\n-    ///\n     /// # Examples\n     ///\n     /// As an iterator:\n@@ -4512,8 +4446,6 @@ impl str {\n \n     /// Return an iterator that escapes each char in `self` with [`char::escape_unicode`].\n     ///\n-    /// [`char::escape_unicode`]: ../std/primitive.char.html#method.escape_unicode\n-    ///\n     /// # Examples\n     ///\n     /// As an iterator:\n@@ -4596,8 +4528,7 @@ impl Default for &mut str {\n /// This struct is created by the [`split_whitespace`] method on [`str`].\n /// See its documentation for more.\n ///\n-/// [`split_whitespace`]: ../../std/primitive.str.html#method.split_whitespace\n-/// [`str`]: ../../std/primitive.str.html\n+/// [`split_whitespace`]: str::split_whitespace\n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n #[derive(Clone, Debug)]\n pub struct SplitWhitespace<'a> {\n@@ -4610,8 +4541,7 @@ pub struct SplitWhitespace<'a> {\n /// This struct is created by the [`split_ascii_whitespace`] method on [`str`].\n /// See its documentation for more.\n ///\n-/// [`split_ascii_whitespace`]: ../../std/primitive.str.html#method.split_ascii_whitespace\n-/// [`str`]: ../../std/primitive.str.html\n+/// [`split_ascii_whitespace`]: str::split_ascii_whitespace\n #[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n #[derive(Clone, Debug)]\n pub struct SplitAsciiWhitespace<'a> {\n@@ -4626,8 +4556,7 @@ pub struct SplitAsciiWhitespace<'a> {\n /// This struct is created by the [`split_inclusive`] method on [`str`].\n /// See its documentation for more.\n ///\n-/// [`split_inclusive`]: ../../std/primitive.str.html#method.split_inclusive\n-/// [`str`]: ../../std/primitive.str.html\n+/// [`split_inclusive`]: str::split_inclusive\n #[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n pub struct SplitInclusive<'a, P: Pattern<'a>>(SplitInternal<'a, P>);\n \n@@ -4761,13 +4690,10 @@ impl<'a, P: Pattern<'a>> FusedIterator for SplitInclusive<'a, P> {}\n \n /// An iterator of [`u16`] over the string encoded as UTF-16.\n ///\n-/// [`u16`]: ../../std/primitive.u16.html\n-///\n /// This struct is created by the [`encode_utf16`] method on [`str`].\n /// See its documentation for more.\n ///\n-/// [`encode_utf16`]: ../../std/primitive.str.html#method.encode_utf16\n-/// [`str`]: ../../std/primitive.str.html\n+/// [`encode_utf16`]: str::encode_utf16\n #[derive(Clone)]\n #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n pub struct EncodeUtf16<'a> {\n@@ -4818,8 +4744,6 @@ impl<'a> Iterator for EncodeUtf16<'a> {\n impl FusedIterator for EncodeUtf16<'_> {}\n \n /// The return type of [`str::escape_debug`].\n-///\n-/// [`str::escape_debug`]: ../../std/primitive.str.html#method.escape_debug\n #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n #[derive(Clone, Debug)]\n pub struct EscapeDebug<'a> {\n@@ -4830,17 +4754,13 @@ pub struct EscapeDebug<'a> {\n }\n \n /// The return type of [`str::escape_default`].\n-///\n-/// [`str::escape_default`]: ../../std/primitive.str.html#method.escape_default\n #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n #[derive(Clone, Debug)]\n pub struct EscapeDefault<'a> {\n     inner: FlatMap<Chars<'a>, char::EscapeDefault, CharEscapeDefault>,\n }\n \n /// The return type of [`str::escape_unicode`].\n-///\n-/// [`str::escape_unicode`]: ../../std/primitive.str.html#method.escape_unicode\n #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n #[derive(Clone, Debug)]\n pub struct EscapeUnicode<'a> {"}, {"sha": "1c0bddb9aef624c4671ae98aa201f4ed10c02dae", "filename": "src/libcore/tests/lazy.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibcore%2Ftests%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibcore%2Ftests%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flazy.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -0,0 +1,124 @@\n+use core::{\n+    cell::Cell,\n+    lazy::{Lazy, OnceCell},\n+    sync::atomic::{AtomicUsize, Ordering::SeqCst},\n+};\n+\n+#[test]\n+fn once_cell() {\n+    let c = OnceCell::new();\n+    assert!(c.get().is_none());\n+    c.get_or_init(|| 92);\n+    assert_eq!(c.get(), Some(&92));\n+\n+    c.get_or_init(|| panic!(\"Kabom!\"));\n+    assert_eq!(c.get(), Some(&92));\n+}\n+\n+#[test]\n+fn once_cell_get_mut() {\n+    let mut c = OnceCell::new();\n+    assert!(c.get_mut().is_none());\n+    c.set(90).unwrap();\n+    *c.get_mut().unwrap() += 2;\n+    assert_eq!(c.get_mut(), Some(&mut 92));\n+}\n+\n+#[test]\n+fn once_cell_drop() {\n+    static DROP_CNT: AtomicUsize = AtomicUsize::new(0);\n+    struct Dropper;\n+    impl Drop for Dropper {\n+        fn drop(&mut self) {\n+            DROP_CNT.fetch_add(1, SeqCst);\n+        }\n+    }\n+\n+    let x = OnceCell::new();\n+    x.get_or_init(|| Dropper);\n+    assert_eq!(DROP_CNT.load(SeqCst), 0);\n+    drop(x);\n+    assert_eq!(DROP_CNT.load(SeqCst), 1);\n+}\n+\n+#[test]\n+fn unsync_once_cell_drop_empty() {\n+    let x = OnceCell::<&'static str>::new();\n+    drop(x);\n+}\n+\n+#[test]\n+fn clone() {\n+    let s = OnceCell::new();\n+    let c = s.clone();\n+    assert!(c.get().is_none());\n+\n+    s.set(\"hello\").unwrap();\n+    let c = s.clone();\n+    assert_eq!(c.get().map(|c| *c), Some(\"hello\"));\n+}\n+\n+#[test]\n+fn from_impl() {\n+    assert_eq!(OnceCell::from(\"value\").get(), Some(&\"value\"));\n+    assert_ne!(OnceCell::from(\"foo\").get(), Some(&\"bar\"));\n+}\n+\n+#[test]\n+fn partialeq_impl() {\n+    assert!(OnceCell::from(\"value\") == OnceCell::from(\"value\"));\n+    assert!(OnceCell::from(\"foo\") != OnceCell::from(\"bar\"));\n+\n+    assert!(OnceCell::<&'static str>::new() == OnceCell::new());\n+    assert!(OnceCell::<&'static str>::new() != OnceCell::from(\"value\"));\n+}\n+\n+#[test]\n+fn into_inner() {\n+    let cell: OnceCell<&'static str> = OnceCell::new();\n+    assert_eq!(cell.into_inner(), None);\n+    let cell = OnceCell::new();\n+    cell.set(\"hello\").unwrap();\n+    assert_eq!(cell.into_inner(), Some(\"hello\"));\n+}\n+\n+#[test]\n+fn lazy_new() {\n+    let called = Cell::new(0);\n+    let x = Lazy::new(|| {\n+        called.set(called.get() + 1);\n+        92\n+    });\n+\n+    assert_eq!(called.get(), 0);\n+\n+    let y = *x - 30;\n+    assert_eq!(y, 62);\n+    assert_eq!(called.get(), 1);\n+\n+    let y = *x - 30;\n+    assert_eq!(y, 62);\n+    assert_eq!(called.get(), 1);\n+}\n+\n+#[test]\n+fn aliasing_in_get() {\n+    let x = OnceCell::new();\n+    x.set(42).unwrap();\n+    let at_x = x.get().unwrap(); // --- (shared) borrow of inner `Option<T>` --+\n+    let _ = x.set(27); // <-- temporary (unique) borrow of inner `Option<T>`   |\n+    println!(\"{}\", at_x); // <------- up until here ---------------------------+\n+}\n+\n+#[test]\n+#[should_panic(expected = \"reentrant init\")]\n+fn reentrant_init() {\n+    let x: OnceCell<Box<i32>> = OnceCell::new();\n+    let dangling_ref: Cell<Option<&i32>> = Cell::new(None);\n+    x.get_or_init(|| {\n+        let r = x.get_or_init(|| Box::new(92));\n+        dangling_ref.set(Some(r));\n+        Box::new(62)\n+    });\n+    eprintln!(\"use after free: {:?}\", dangling_ref.get().unwrap());\n+}"}, {"sha": "47ed6db6c677b17428d423aa2cd40379df8e3645", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -43,6 +43,7 @@\n #![feature(option_unwrap_none)]\n #![feature(peekable_next_if)]\n #![feature(partition_point)]\n+#![feature(once_cell)]\n #![feature(unsafe_block_in_unsafe_fn)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n@@ -62,6 +63,7 @@ mod fmt;\n mod hash;\n mod intrinsics;\n mod iter;\n+mod lazy;\n mod manually_drop;\n mod mem;\n mod nonzero;"}, {"sha": "e100e0095c92a4bfd37142ee7c9310b8ad8f2f86", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -18,6 +18,7 @@ log = \"0.4.5\"\n libc = \"0.2.50\"\n jobserver = \"0.1.11\"\n tempfile = \"3.1\"\n+pathdiff = \"0.2.0\"\n \n rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "005d2efdd3b26ab95bff7995c2c7a5f5778eb61d", "filename": "src/librustc_codegen_ssa/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -1,3 +1,4 @@\n+use pathdiff::diff_paths;\n use rustc_data_structures::fx::FxHashSet;\n use std::env;\n use std::fs;\n@@ -109,37 +110,7 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig<'_>, lib: &Path) -> Str\n // In particular, this handles the case on unix where both paths are\n // absolute but with only the root as the common directory.\n fn path_relative_from(path: &Path, base: &Path) -> Option<PathBuf> {\n-    use std::path::Component;\n-\n-    if path.is_absolute() != base.is_absolute() {\n-        path.is_absolute().then(|| PathBuf::from(path))\n-    } else {\n-        let mut ita = path.components();\n-        let mut itb = base.components();\n-        let mut comps: Vec<Component<'_>> = vec![];\n-        loop {\n-            match (ita.next(), itb.next()) {\n-                (None, None) => break,\n-                (Some(a), None) => {\n-                    comps.push(a);\n-                    comps.extend(ita.by_ref());\n-                    break;\n-                }\n-                (None, _) => comps.push(Component::ParentDir),\n-                (Some(a), Some(b)) if comps.is_empty() && a == b => (),\n-                (Some(a), Some(b)) if b == Component::CurDir => comps.push(a),\n-                (Some(_), Some(b)) if b == Component::ParentDir => return None,\n-                (Some(a), Some(_)) => {\n-                    comps.push(Component::ParentDir);\n-                    comps.extend(itb.map(|_| Component::ParentDir));\n-                    comps.push(a);\n-                    comps.extend(ita.by_ref());\n-                    break;\n-                }\n-            }\n-        }\n-        Some(comps.iter().map(|c| c.as_os_str()).collect())\n-    }\n+    diff_paths(path, base)\n }\n \n fn get_install_prefix_rpath(config: &mut RPathConfig<'_>) -> String {"}, {"sha": "1affc9457b89e167492782df5bd0b1d8314b96f6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -531,6 +531,11 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         match ty.kind {\n             ty::FnPtr(_) => true,\n             ty::Ref(..) => true,\n+            ty::Adt(def, _)\n+                if def.is_box() && matches!(self.mode, ImproperCTypesMode::Definitions) =>\n+            {\n+                true\n+            }\n             ty::Adt(def, substs) if def.repr.transparent() && !def.is_union() => {\n                 let guaranteed_nonnull_optimization = self\n                     .cx\n@@ -558,7 +563,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n \n     /// Check if this enum can be safely exported based on the \"nullable pointer optimization\".\n-    /// Currently restricted to function pointers, references, `core::num::NonZero*`,\n+    /// Currently restricted to function pointers, boxes, references, `core::num::NonZero*`,\n     /// `core::ptr::NonNull`, and `#[repr(transparent)]` newtypes.\n     fn is_repr_nullable_ptr(\n         &self,\n@@ -692,6 +697,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         match ty.kind {\n+            ty::Adt(def, _)\n+                if def.is_box() && matches!(self.mode, ImproperCTypesMode::Definitions) =>\n+            {\n+                FfiSafe\n+            }\n+\n             ty::Adt(def, substs) => {\n                 if def.is_phantom_data() {\n                     return FfiPhantom(ty);"}, {"sha": "a68301385b7a5b5a983609f57ce7d4057a438ebf", "filename": "src/librustc_middle/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibrustc_middle%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibrustc_middle%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flib.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -27,6 +27,7 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(cmp_min_max_by)]\n #![feature(const_fn)]\n #![feature(const_panic)]\n #![feature(const_fn_transmute)]"}, {"sha": "8ae9269a6bf684e566ee2fa0ef27c98f4758ac4a", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -876,6 +876,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     .iter_enumerated()\n                     .all(|(i, v)| v.discr == ty::VariantDiscr::Relative(i.as_u32()));\n \n+                let mut niche_filling_layout = None;\n+\n                 // Niche-filling enum optimization.\n                 if !def.repr.inhibit_enum_layout_opt() && no_explicit_discriminants {\n                     let mut dataful_variant = None;\n@@ -972,7 +974,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             let largest_niche =\n                                 Niche::from_scalar(dl, offset, niche_scalar.clone());\n \n-                            return Ok(tcx.intern_layout(Layout {\n+                            niche_filling_layout = Some(Layout {\n                                 variants: Variants::Multiple {\n                                     tag: niche_scalar,\n                                     tag_encoding: TagEncoding::Niche {\n@@ -991,7 +993,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                 largest_niche,\n                                 size,\n                                 align,\n-                            }));\n+                            });\n                         }\n                     }\n                 }\n@@ -1214,7 +1216,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag.clone());\n \n-                tcx.intern_layout(Layout {\n+                let tagged_layout = Layout {\n                     variants: Variants::Multiple {\n                         tag,\n                         tag_encoding: TagEncoding::Direct,\n@@ -1229,7 +1231,23 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     abi,\n                     align,\n                     size,\n-                })\n+                };\n+\n+                let best_layout = match (tagged_layout, niche_filling_layout) {\n+                    (tagged_layout, Some(niche_filling_layout)) => {\n+                        // Pick the smaller layout; otherwise,\n+                        // pick the layout with the larger niche; otherwise,\n+                        // pick tagged as it has simpler codegen.\n+                        cmp::min_by_key(tagged_layout, niche_filling_layout, |layout| {\n+                            let niche_size =\n+                                layout.largest_niche.as_ref().map_or(0, |n| n.available(dl));\n+                            (layout.size, cmp::Reverse(niche_size))\n+                        })\n+                    }\n+                    (tagged_layout, None) => tagged_layout,\n+                };\n+\n+                tcx.intern_layout(best_layout)\n             }\n \n             // Types with no meaningful known layout."}, {"sha": "86e1cfae582e87bcc14e2e1ac69f19a4652438e3", "filename": "src/libstd/lazy.rs", "status": "added", "additions": 844, "deletions": 0, "changes": 844, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibstd%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibstd%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flazy.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -0,0 +1,844 @@\n+//! Lazy values and one-time initialization of static data.\n+\n+use crate::{\n+    cell::{Cell, UnsafeCell},\n+    fmt,\n+    mem::{self, MaybeUninit},\n+    ops::{Deref, Drop},\n+    panic::{RefUnwindSafe, UnwindSafe},\n+    sync::Once,\n+};\n+\n+#[doc(inline)]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub use core::lazy::*;\n+\n+/// A synchronization primitive which can be written to only once.\n+///\n+/// This type is a thread-safe `OnceCell`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::lazy::SyncOnceCell;\n+///\n+/// static CELL: SyncOnceCell<String> = SyncOnceCell::new();\n+/// assert!(CELL.get().is_none());\n+///\n+/// std::thread::spawn(|| {\n+///     let value: &String = CELL.get_or_init(|| {\n+///         \"Hello, World!\".to_string()\n+///     });\n+///     assert_eq!(value, \"Hello, World!\");\n+/// }).join().unwrap();\n+///\n+/// let value: Option<&String> = CELL.get();\n+/// assert!(value.is_some());\n+/// assert_eq!(value.unwrap().as_str(), \"Hello, World!\");\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct SyncOnceCell<T> {\n+    once: Once,\n+    // Whether or not the value is initialized is tracked by `state_and_queue`.\n+    value: UnsafeCell<MaybeUninit<T>>,\n+}\n+\n+// Why do we need `T: Send`?\n+// Thread A creates a `SyncOnceCell` and shares it with\n+// scoped thread B, which fills the cell, which is\n+// then destroyed by A. That is, destructor observes\n+// a sent value.\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+unsafe impl<T: Sync + Send> Sync for SyncOnceCell<T> {}\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+unsafe impl<T: Send> Send for SyncOnceCell<T> {}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: RefUnwindSafe + UnwindSafe> RefUnwindSafe for SyncOnceCell<T> {}\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: UnwindSafe> UnwindSafe for SyncOnceCell<T> {}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T> Default for SyncOnceCell<T> {\n+    fn default() -> SyncOnceCell<T> {\n+        SyncOnceCell::new()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug> fmt::Debug for SyncOnceCell<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.get() {\n+            Some(v) => f.debug_tuple(\"Once\").field(v).finish(),\n+            None => f.write_str(\"Once(Uninit)\"),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Clone> Clone for SyncOnceCell<T> {\n+    fn clone(&self) -> SyncOnceCell<T> {\n+        let cell = Self::new();\n+        if let Some(value) = self.get() {\n+            match cell.set(value.clone()) {\n+                Ok(()) => (),\n+                Err(_) => unreachable!(),\n+            }\n+        }\n+        cell\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T> From<T> for SyncOnceCell<T> {\n+    fn from(value: T) -> Self {\n+        let cell = Self::new();\n+        match cell.set(value) {\n+            Ok(()) => cell,\n+            Err(_) => unreachable!(),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: PartialEq> PartialEq for SyncOnceCell<T> {\n+    fn eq(&self, other: &SyncOnceCell<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Eq> Eq for SyncOnceCell<T> {}\n+\n+impl<T> SyncOnceCell<T> {\n+    /// Creates a new empty cell.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub const fn new() -> SyncOnceCell<T> {\n+        SyncOnceCell { once: Once::new(), value: UnsafeCell::new(MaybeUninit::uninit()) }\n+    }\n+\n+    /// Gets the reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty, or being initialized. This\n+    /// method never blocks.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get(&self) -> Option<&T> {\n+        if self.is_initialized() {\n+            // Safe b/c checked is_initialized\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Gets the mutable reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty. This method never blocks.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_mut(&mut self) -> Option<&mut T> {\n+        if self.is_initialized() {\n+            // Safe b/c checked is_initialized and we have a unique access\n+            Some(unsafe { self.get_unchecked_mut() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Sets the contents of this cell to `value`.\n+    ///\n+    /// Returns `Ok(())` if the cell's value was updated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// static CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n+    ///\n+    /// fn main() {\n+    ///     assert!(CELL.get().is_none());\n+    ///\n+    ///     std::thread::spawn(|| {\n+    ///         assert_eq!(CELL.set(92), Ok(()));\n+    ///     }).join().unwrap();\n+    ///\n+    ///     assert_eq!(CELL.set(62), Err(62));\n+    ///     assert_eq!(CELL.get(), Some(&92));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn set(&self, value: T) -> Result<(), T> {\n+        let mut value = Some(value);\n+        self.get_or_init(|| value.take().unwrap());\n+        match value {\n+            None => Ok(()),\n+            Some(value) => Err(value),\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if the cell\n+    /// was empty.\n+    ///\n+    /// Many threads may call `get_or_init` concurrently with different\n+    /// initializing functions, but it is guaranteed that only one function\n+    /// will be executed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. The\n+    /// exact outcome is unspecified. Current implementation deadlocks, but\n+    /// this may be changed to a panic in the future.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// let cell = SyncOnceCell::new();\n+    /// let value = cell.get_or_init(|| 92);\n+    /// assert_eq!(value, &92);\n+    /// let value = cell.get_or_init(|| unreachable!());\n+    /// assert_eq!(value, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_init<F>(&self, f: F) -> &T\n+    where\n+        F: FnOnce() -> T,\n+    {\n+        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n+            Ok(val) => val,\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if\n+    /// the cell was empty. If the cell was empty and `f` failed, an\n+    /// error is returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and\n+    /// the cell remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`.\n+    /// The exact outcome is unspecified. Current implementation\n+    /// deadlocks, but this may be changed to a panic in the future.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// let cell = SyncOnceCell::new();\n+    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+    /// assert!(cell.get().is_none());\n+    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n+    ///     Ok(92)\n+    /// });\n+    /// assert_eq!(value, Ok(&92));\n+    /// assert_eq!(cell.get(), Some(&92))\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        // Fast path check\n+        // NOTE: We need to perform an acquire on the state in this method\n+        // in order to correctly synchronize `SyncLazy::force`. This is\n+        // currently done by calling `self.get()`, which in turn calls\n+        // `self.is_initialized()`, which in turn performs the acquire.\n+        if let Some(value) = self.get() {\n+            return Ok(value);\n+        }\n+        self.initialize(f)?;\n+\n+        debug_assert!(self.is_initialized());\n+\n+        // Safety: The inner value has been initialized\n+        Ok(unsafe { self.get_unchecked() })\n+    }\n+\n+    /// Consumes the `SyncOnceCell`, returning the wrapped value. Returns\n+    /// `None` if the cell was empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// let cell: SyncOnceCell<String> = SyncOnceCell::new();\n+    /// assert_eq!(cell.into_inner(), None);\n+    ///\n+    /// let cell = SyncOnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn into_inner(mut self) -> Option<T> {\n+        // Safety: Safe because we immediately free `self` without dropping\n+        let inner = unsafe { self.take_inner() };\n+\n+        // Don't drop this `SyncOnceCell`. We just moved out one of the fields, but didn't set\n+        // the state to uninitialized.\n+        mem::ManuallyDrop::new(self);\n+        inner\n+    }\n+\n+    /// Takes the value out of this `SyncOnceCell`, moving it back to an uninitialized state.\n+    ///\n+    /// Has no effect and returns `None` if the `SyncOnceCell` hasn't been initialized.\n+    ///\n+    /// Safety is guaranteed by requiring a mutable reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// let mut cell: SyncOnceCell<String> = SyncOnceCell::new();\n+    /// assert_eq!(cell.take(), None);\n+    ///\n+    /// let mut cell = SyncOnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n+    /// assert_eq!(cell.get(), None);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn take(&mut self) -> Option<T> {\n+        mem::take(self).into_inner()\n+    }\n+\n+    /// Takes the wrapped value out of a `SyncOnceCell`.\n+    /// Afterwards the cell is no longer initialized.\n+    ///\n+    /// Safety: The cell must now be free'd WITHOUT dropping. No other usages of the cell\n+    /// are valid. Only used by `into_inner` and `drop`.\n+    unsafe fn take_inner(&mut self) -> Option<T> {\n+        // The mutable reference guarantees there are no other threads that can observe us\n+        // taking out the wrapped value.\n+        // Right after this function `self` is supposed to be freed, so it makes little sense\n+        // to atomically set the state to uninitialized.\n+        if self.is_initialized() {\n+            let value = mem::replace(&mut self.value, UnsafeCell::new(MaybeUninit::uninit()));\n+            Some(value.into_inner().assume_init())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_initialized(&self) -> bool {\n+        self.once.is_completed()\n+    }\n+\n+    #[cold]\n+    fn initialize<F, E>(&self, f: F) -> Result<(), E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        let mut res: Result<(), E> = Ok(());\n+        let slot = &self.value;\n+\n+        // Ignore poisoning from other threads\n+        // If another thread panics, then we'll be able to run our closure\n+        self.once.call_once_force(|p| {\n+            match f() {\n+                Ok(value) => {\n+                    unsafe { (&mut *slot.get()).write(value) };\n+                }\n+                Err(e) => {\n+                    res = Err(e);\n+\n+                    // Treat the underlying `Once` as poisoned since we\n+                    // failed to initialize our value. Calls\n+                    p.poison();\n+                }\n+            }\n+        });\n+        res\n+    }\n+\n+    /// Safety: The value must be initialized\n+    unsafe fn get_unchecked(&self) -> &T {\n+        debug_assert!(self.is_initialized());\n+        (&*self.value.get()).get_ref()\n+    }\n+\n+    /// Safety: The value must be initialized\n+    unsafe fn get_unchecked_mut(&mut self) -> &mut T {\n+        debug_assert!(self.is_initialized());\n+        (&mut *self.value.get()).get_mut()\n+    }\n+}\n+\n+impl<T> Drop for SyncOnceCell<T> {\n+    fn drop(&mut self) {\n+        // Safety: The cell is being dropped, so it can't be accessed again\n+        unsafe { self.take_inner() };\n+    }\n+}\n+\n+/// A value which is initialized on the first access.\n+///\n+/// This type is a thread-safe `Lazy`, and can be used in statics.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::collections::HashMap;\n+///\n+/// use std::lazy::SyncLazy;\n+///\n+/// static HASHMAP: SyncLazy<HashMap<i32, String>> = SyncLazy::new(|| {\n+///     println!(\"initializing\");\n+///     let mut m = HashMap::new();\n+///     m.insert(13, \"Spica\".to_string());\n+///     m.insert(74, \"Hoyten\".to_string());\n+///     m\n+/// });\n+///\n+/// fn main() {\n+///     println!(\"ready\");\n+///     std::thread::spawn(|| {\n+///         println!(\"{:?}\", HASHMAP.get(&13));\n+///     }).join().unwrap();\n+///     println!(\"{:?}\", HASHMAP.get(&74));\n+///\n+///     // Prints:\n+///     //   ready\n+///     //   initializing\n+///     //   Some(\"Spica\")\n+///     //   Some(\"Hoyten\")\n+/// }\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct SyncLazy<T, F = fn() -> T> {\n+    cell: SyncOnceCell<T>,\n+    init: Cell<Option<F>>,\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug, F> fmt::Debug for SyncLazy<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n+    }\n+}\n+\n+// We never create a `&F` from a `&SyncLazy<T, F>` so it is fine\n+// to not impl `Sync` for `F`\n+// we do create a `&mut Option<F>` in `force`, but this is\n+// properly synchronized, so it only happens once\n+// so it also does not contribute to this impl.\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+unsafe impl<T, F: Send> Sync for SyncLazy<T, F> where SyncOnceCell<T>: Sync {}\n+// auto-derived `Send` impl is OK.\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F: RefUnwindSafe> RefUnwindSafe for SyncLazy<T, F> where SyncOnceCell<T>: RefUnwindSafe {}\n+\n+impl<T, F> SyncLazy<T, F> {\n+    /// Creates a new lazy value with the given initializing\n+    /// function.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub const fn new(f: F) -> SyncLazy<T, F> {\n+        SyncLazy { cell: SyncOnceCell::new(), init: Cell::new(Some(f)) }\n+    }\n+}\n+\n+impl<T, F: FnOnce() -> T> SyncLazy<T, F> {\n+    /// Forces the evaluation of this lazy value and\n+    /// returns a reference to result. This is equivalent\n+    /// to the `Deref` impl, but is explicit.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::SyncLazy;\n+    ///\n+    /// let lazy = SyncLazy::new(|| 92);\n+    ///\n+    /// assert_eq!(SyncLazy::force(&lazy), &92);\n+    /// assert_eq!(&*lazy, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn force(this: &SyncLazy<T, F>) -> &T {\n+        this.cell.get_or_init(|| match this.init.take() {\n+            Some(f) => f(),\n+            None => panic!(\"Lazy instance has previously been poisoned\"),\n+        })\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F: FnOnce() -> T> Deref for SyncLazy<T, F> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        SyncLazy::force(self)\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Default> Default for SyncLazy<T> {\n+    /// Creates a new lazy value using `Default` as the initializing function.\n+    fn default() -> SyncLazy<T> {\n+        SyncLazy::new(T::default)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        lazy::{Lazy, SyncLazy, SyncOnceCell},\n+        panic,\n+        sync::{\n+            atomic::{AtomicUsize, Ordering::SeqCst},\n+            mpsc::channel,\n+            Mutex,\n+        },\n+    };\n+\n+    #[test]\n+    fn lazy_default() {\n+        static CALLED: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct Foo(u8);\n+        impl Default for Foo {\n+            fn default() -> Self {\n+                CALLED.fetch_add(1, SeqCst);\n+                Foo(42)\n+            }\n+        }\n+\n+        let lazy: Lazy<Mutex<Foo>> = <_>::default();\n+\n+        assert_eq!(CALLED.load(SeqCst), 0);\n+\n+        assert_eq!(lazy.lock().unwrap().0, 42);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+\n+        lazy.lock().unwrap().0 = 21;\n+\n+        assert_eq!(lazy.lock().unwrap().0, 21);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+    }\n+\n+    #[test]\n+    fn lazy_poisoning() {\n+        let x: Lazy<String> = Lazy::new(|| panic!(\"kaboom\"));\n+        for _ in 0..2 {\n+            let res = panic::catch_unwind(panic::AssertUnwindSafe(|| x.len()));\n+            assert!(res.is_err());\n+        }\n+    }\n+\n+    // miri doesn't support threads\n+    #[cfg(not(miri))]\n+    fn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n+        crate::thread::spawn(f).join().unwrap()\n+    }\n+\n+    #[cfg(not(miri))]\n+    fn spawn(f: impl FnOnce() + Send + 'static) {\n+        let _ = crate::thread::spawn(f);\n+    }\n+\n+    // \"stub threads\" for Miri\n+    #[cfg(miri)]\n+    fn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n+        f(())\n+    }\n+\n+    #[cfg(miri)]\n+    fn spawn(f: impl FnOnce() + Send + 'static) {\n+        f(())\n+    }\n+\n+    #[test]\n+    fn sync_once_cell() {\n+        static ONCE_CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n+\n+        assert!(ONCE_CELL.get().is_none());\n+\n+        spawn_and_wait(|| {\n+            ONCE_CELL.get_or_init(|| 92);\n+            assert_eq!(ONCE_CELL.get(), Some(&92));\n+        });\n+\n+        ONCE_CELL.get_or_init(|| panic!(\"Kabom!\"));\n+        assert_eq!(ONCE_CELL.get(), Some(&92));\n+    }\n+\n+    #[test]\n+    fn sync_once_cell_get_mut() {\n+        let mut c = SyncOnceCell::new();\n+        assert!(c.get_mut().is_none());\n+        c.set(90).unwrap();\n+        *c.get_mut().unwrap() += 2;\n+        assert_eq!(c.get_mut(), Some(&mut 92));\n+    }\n+\n+    #[test]\n+    fn sync_once_cell_get_unchecked() {\n+        let c = SyncOnceCell::new();\n+        c.set(92).unwrap();\n+        unsafe {\n+            assert_eq!(c.get_unchecked(), &92);\n+        }\n+    }\n+\n+    #[test]\n+    fn sync_once_cell_drop() {\n+        static DROP_CNT: AtomicUsize = AtomicUsize::new(0);\n+        struct Dropper;\n+        impl Drop for Dropper {\n+            fn drop(&mut self) {\n+                DROP_CNT.fetch_add(1, SeqCst);\n+            }\n+        }\n+\n+        let x = SyncOnceCell::new();\n+        spawn_and_wait(move || {\n+            x.get_or_init(|| Dropper);\n+            assert_eq!(DROP_CNT.load(SeqCst), 0);\n+            drop(x);\n+        });\n+\n+        assert_eq!(DROP_CNT.load(SeqCst), 1);\n+    }\n+\n+    #[test]\n+    fn sync_once_cell_drop_empty() {\n+        let x = SyncOnceCell::<String>::new();\n+        drop(x);\n+    }\n+\n+    #[test]\n+    fn clone() {\n+        let s = SyncOnceCell::new();\n+        let c = s.clone();\n+        assert!(c.get().is_none());\n+\n+        s.set(\"hello\".to_string()).unwrap();\n+        let c = s.clone();\n+        assert_eq!(c.get().map(String::as_str), Some(\"hello\"));\n+    }\n+\n+    #[test]\n+    fn get_or_try_init() {\n+        let cell: SyncOnceCell<String> = SyncOnceCell::new();\n+        assert!(cell.get().is_none());\n+\n+        let res = panic::catch_unwind(|| cell.get_or_try_init(|| -> Result<_, ()> { panic!() }));\n+        assert!(res.is_err());\n+        assert!(!cell.is_initialized());\n+        assert!(cell.get().is_none());\n+\n+        assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+\n+        assert_eq!(\n+            cell.get_or_try_init(|| Ok::<_, ()>(\"hello\".to_string())),\n+            Ok(&\"hello\".to_string())\n+        );\n+        assert_eq!(cell.get(), Some(&\"hello\".to_string()));\n+    }\n+\n+    #[test]\n+    fn from_impl() {\n+        assert_eq!(SyncOnceCell::from(\"value\").get(), Some(&\"value\"));\n+        assert_ne!(SyncOnceCell::from(\"foo\").get(), Some(&\"bar\"));\n+    }\n+\n+    #[test]\n+    fn partialeq_impl() {\n+        assert!(SyncOnceCell::from(\"value\") == SyncOnceCell::from(\"value\"));\n+        assert!(SyncOnceCell::from(\"foo\") != SyncOnceCell::from(\"bar\"));\n+\n+        assert!(SyncOnceCell::<String>::new() == SyncOnceCell::new());\n+        assert!(SyncOnceCell::<String>::new() != SyncOnceCell::from(\"value\".to_owned()));\n+    }\n+\n+    #[test]\n+    fn into_inner() {\n+        let cell: SyncOnceCell<String> = SyncOnceCell::new();\n+        assert_eq!(cell.into_inner(), None);\n+        let cell = SyncOnceCell::new();\n+        cell.set(\"hello\".to_string()).unwrap();\n+        assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+    }\n+\n+    #[test]\n+    fn sync_lazy_new() {\n+        static CALLED: AtomicUsize = AtomicUsize::new(0);\n+        static SYNC_LAZY: SyncLazy<i32> = SyncLazy::new(|| {\n+            CALLED.fetch_add(1, SeqCst);\n+            92\n+        });\n+\n+        assert_eq!(CALLED.load(SeqCst), 0);\n+\n+        spawn_and_wait(|| {\n+            let y = *SYNC_LAZY - 30;\n+            assert_eq!(y, 62);\n+            assert_eq!(CALLED.load(SeqCst), 1);\n+        });\n+\n+        let y = *SYNC_LAZY - 30;\n+        assert_eq!(y, 62);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+    }\n+\n+    #[test]\n+    fn sync_lazy_default() {\n+        static CALLED: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct Foo(u8);\n+        impl Default for Foo {\n+            fn default() -> Self {\n+                CALLED.fetch_add(1, SeqCst);\n+                Foo(42)\n+            }\n+        }\n+\n+        let lazy: SyncLazy<Mutex<Foo>> = <_>::default();\n+\n+        assert_eq!(CALLED.load(SeqCst), 0);\n+\n+        assert_eq!(lazy.lock().unwrap().0, 42);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+\n+        lazy.lock().unwrap().0 = 21;\n+\n+        assert_eq!(lazy.lock().unwrap().0, 21);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+    }\n+\n+    #[test]\n+    #[cfg_attr(miri, ignore)] // leaks memory\n+    fn static_sync_lazy() {\n+        static XS: SyncLazy<Vec<i32>> = SyncLazy::new(|| {\n+            let mut xs = Vec::new();\n+            xs.push(1);\n+            xs.push(2);\n+            xs.push(3);\n+            xs\n+        });\n+\n+        spawn_and_wait(|| {\n+            assert_eq!(&*XS, &vec![1, 2, 3]);\n+        });\n+\n+        assert_eq!(&*XS, &vec![1, 2, 3]);\n+    }\n+\n+    #[test]\n+    #[cfg_attr(miri, ignore)] // leaks memory\n+    fn static_sync_lazy_via_fn() {\n+        fn xs() -> &'static Vec<i32> {\n+            static XS: SyncOnceCell<Vec<i32>> = SyncOnceCell::new();\n+            XS.get_or_init(|| {\n+                let mut xs = Vec::new();\n+                xs.push(1);\n+                xs.push(2);\n+                xs.push(3);\n+                xs\n+            })\n+        }\n+        assert_eq!(xs(), &vec![1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn sync_lazy_poisoning() {\n+        let x: SyncLazy<String> = SyncLazy::new(|| panic!(\"kaboom\"));\n+        for _ in 0..2 {\n+            let res = panic::catch_unwind(|| x.len());\n+            assert!(res.is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn is_sync_send() {\n+        fn assert_traits<T: Send + Sync>() {}\n+        assert_traits::<SyncOnceCell<String>>();\n+        assert_traits::<SyncLazy<String>>();\n+    }\n+\n+    #[test]\n+    fn eval_once_macro() {\n+        macro_rules! eval_once {\n+            (|| -> $ty:ty {\n+                $($body:tt)*\n+            }) => {{\n+                static ONCE_CELL: SyncOnceCell<$ty> = SyncOnceCell::new();\n+                fn init() -> $ty {\n+                    $($body)*\n+                }\n+                ONCE_CELL.get_or_init(init)\n+            }};\n+        }\n+\n+        let fib: &'static Vec<i32> = eval_once! {\n+            || -> Vec<i32> {\n+                let mut res = vec![1, 1];\n+                for i in 0..10 {\n+                    let next = res[i] + res[i + 1];\n+                    res.push(next);\n+                }\n+                res\n+            }\n+        };\n+        assert_eq!(fib[5], 8)\n+    }\n+\n+    #[test]\n+    #[cfg_attr(miri, ignore)] // deadlocks without real threads\n+    fn sync_once_cell_does_not_leak_partially_constructed_boxes() {\n+        static ONCE_CELL: SyncOnceCell<String> = SyncOnceCell::new();\n+\n+        let n_readers = 10;\n+        let n_writers = 3;\n+        const MSG: &str = \"Hello, World\";\n+\n+        let (tx, rx) = channel();\n+\n+        for _ in 0..n_readers {\n+            let tx = tx.clone();\n+            spawn(move || {\n+                loop {\n+                    if let Some(msg) = ONCE_CELL.get() {\n+                        tx.send(msg).unwrap();\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+        for _ in 0..n_writers {\n+            spawn(move || {\n+                let _ = ONCE_CELL.set(MSG.to_owned());\n+            });\n+        }\n+\n+        for _ in 0..n_readers {\n+            let msg = rx.recv().unwrap();\n+            assert_eq!(msg, MSG);\n+        }\n+    }\n+}"}, {"sha": "be8d9f7a7c9cd2d914c444bc33c62f184b5b4a21", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -287,13 +287,15 @@\n #![feature(linkage)]\n #![feature(llvm_asm)]\n #![feature(log_syntax)]\n+#![feature(maybe_uninit_extra)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n #![feature(min_specialization)]\n #![feature(needs_panic_runtime)]\n #![feature(negative_impls)]\n #![feature(never_type)]\n #![feature(nll)]\n+#![feature(once_cell)]\n #![feature(optin_builtin_traits)]\n #![feature(or_patterns)]\n #![feature(panic_info_message)]\n@@ -477,6 +479,9 @@ pub mod process;\n pub mod sync;\n pub mod time;\n \n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub mod lazy;\n+\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub mod task {\n     //! Types and Traits for working with asynchronous tasks."}, {"sha": "64260990824b86fdc9e51afeed8aeca6dea34ff9", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -132,6 +132,7 @@ unsafe impl Send for Once {}\n #[derive(Debug)]\n pub struct OnceState {\n     poisoned: bool,\n+    set_state_on_drop_to: Cell<usize>,\n }\n \n /// Initialization value for static [`Once`] values.\n@@ -321,7 +322,7 @@ impl Once {\n         }\n \n         let mut f = Some(f);\n-        self.call_inner(true, &mut |p| f.take().unwrap()(&OnceState { poisoned: p }));\n+        self.call_inner(true, &mut |p| f.take().unwrap()(p));\n     }\n \n     /// Returns `true` if some `call_once` call has completed\n@@ -385,7 +386,7 @@ impl Once {\n     // currently no way to take an `FnOnce` and call it via virtual dispatch\n     // without some allocation overhead.\n     #[cold]\n-    fn call_inner(&self, ignore_poisoning: bool, init: &mut dyn FnMut(bool)) {\n+    fn call_inner(&self, ignore_poisoning: bool, init: &mut dyn FnMut(&OnceState)) {\n         let mut state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n         loop {\n             match state_and_queue {\n@@ -413,8 +414,12 @@ impl Once {\n                     };\n                     // Run the initialization function, letting it know if we're\n                     // poisoned or not.\n-                    init(state_and_queue == POISONED);\n-                    waiter_queue.set_state_on_drop_to = COMPLETE;\n+                    let init_state = OnceState {\n+                        poisoned: state_and_queue == POISONED,\n+                        set_state_on_drop_to: Cell::new(COMPLETE),\n+                    };\n+                    init(&init_state);\n+                    waiter_queue.set_state_on_drop_to = init_state.set_state_on_drop_to.get();\n                     break;\n                 }\n                 _ => {\n@@ -554,6 +559,14 @@ impl OnceState {\n     pub fn poisoned(&self) -> bool {\n         self.poisoned\n     }\n+\n+    /// Poison the associated [`Once`] without explicitly panicking.\n+    ///\n+    /// [`Once`]: struct.Once.html\n+    // NOTE: This is currently only exposed for the `lazy` module\n+    pub(crate) fn poison(&self) {\n+        self.set_state_on_drop_to.set(POISONED);\n+    }\n }\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]"}, {"sha": "ff94ac8543f8b02fd8427e57e597b1b0aac02989", "filename": "src/test/codegen/atomic-operations.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fcodegen%2Fatomic-operations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fcodegen%2Fatomic-operations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fatomic-operations.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -0,0 +1,60 @@\n+// Code generation of atomic operations.\n+//\n+// compile-flags: -O\n+#![crate_type = \"lib\"]\n+\n+use std::sync::atomic::{AtomicI32, Ordering::*};\n+\n+// CHECK-LABEL: @compare_exchange\n+#[no_mangle]\n+pub fn compare_exchange(a: &AtomicI32) {\n+    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 10 monotonic monotonic\n+    let _ = a.compare_exchange(0, 10, Relaxed, Relaxed);\n+\n+    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 20 release monotonic\n+    let _ = a.compare_exchange(0, 20, Release, Relaxed);\n+\n+    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 30 acquire monotonic\n+    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 31 acquire acquire\n+    let _ = a.compare_exchange(0, 30, Acquire, Relaxed);\n+    let _ = a.compare_exchange(0, 31, Acquire, Acquire);\n+\n+    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 40 acq_rel monotonic\n+    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 41 acq_rel acquire\n+    let _ = a.compare_exchange(0, 40, AcqRel, Relaxed);\n+    let _ = a.compare_exchange(0, 41, AcqRel, Acquire);\n+\n+    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 50 seq_cst monotonic\n+    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 51 seq_cst acquire\n+    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 52 seq_cst seq_cst\n+    let _ = a.compare_exchange(0, 50, SeqCst, Relaxed);\n+    let _ = a.compare_exchange(0, 51, SeqCst, Acquire);\n+    let _ = a.compare_exchange(0, 52, SeqCst, SeqCst);\n+}\n+\n+// CHECK-LABEL: @compare_exchange_weak\n+#[no_mangle]\n+pub fn compare_exchange_weak(w: &AtomicI32) {\n+    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 10 monotonic monotonic\n+    let _ = w.compare_exchange_weak(1, 10, Relaxed, Relaxed);\n+\n+    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 20 release monotonic\n+    let _ = w.compare_exchange_weak(1, 20, Release, Relaxed);\n+\n+    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 30 acquire monotonic\n+    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 31 acquire acquire\n+    let _ = w.compare_exchange_weak(1, 30, Acquire, Relaxed);\n+    let _ = w.compare_exchange_weak(1, 31, Acquire, Acquire);\n+\n+    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 40 acq_rel monotonic\n+    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 41 acq_rel acquire\n+    let _ = w.compare_exchange_weak(1, 40, AcqRel, Relaxed);\n+    let _ = w.compare_exchange_weak(1, 41, AcqRel, Acquire);\n+\n+    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 50 seq_cst monotonic\n+    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 51 seq_cst acquire\n+    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 52 seq_cst seq_cst\n+    let _ = w.compare_exchange_weak(1, 50, SeqCst, Relaxed);\n+    let _ = w.compare_exchange_weak(1, 51, SeqCst, Acquire);\n+    let _ = w.compare_exchange_weak(1, 52, SeqCst, SeqCst);\n+}"}, {"sha": "ea75a3d04035828c432665eb5786d001261d3ec3", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param-ungated.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -1,3 +1,6 @@\n+// compile-flags: -Zsave-analysis\n+// Regression test for #69414 ^\n+\n use std::marker::PhantomData;\n \n struct B<T, const N: T>(PhantomData<[T; N]>); //~ ERROR const generics are unstable"}, {"sha": "616f0fa8f1af0796df83ee863b48b71abc2771f0", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param-ungated.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -1,11 +1,11 @@\n error[E0770]: the type of const parameters must not depend on other generic parameters\n-  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:22\n+  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:6:22\n    |\n LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n    |                      ^ the type must not depend on the parameter `T`\n \n error[E0658]: const generics are unstable\n-  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:19\n+  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:6:19\n    |\n LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n    |                   ^"}, {"sha": "aa02e578663286e4add09881b496b47a5a247af5", "filename": "src/test/ui/lint/lint-ctypes-fn.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Flint%2Flint-ctypes-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Flint%2Flint-ctypes-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-fn.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -71,7 +71,8 @@ pub extern \"C\" fn str_type(p: &str) { }\n //~^ ERROR: uses type `str`\n \n pub extern \"C\" fn box_type(p: Box<u32>) { }\n-//~^ ERROR uses type `std::boxed::Box<u32>`\n+\n+pub extern \"C\" fn opt_box_type(p: Option<Box<u32>>) { }\n \n pub extern \"C\" fn char_type(p: char) { }\n //~^ ERROR uses type `char`\n@@ -106,7 +107,6 @@ pub extern \"C\" fn fn_type2(p: fn()) { }\n //~^ ERROR uses type `fn()`\n \n pub extern \"C\" fn fn_contained(p: RustBadRet) { }\n-//~^ ERROR: uses type `std::boxed::Box<u32>`\n \n pub extern \"C\" fn transparent_i128(p: TransparentI128) { }\n //~^ ERROR: uses type `i128`\n@@ -115,7 +115,6 @@ pub extern \"C\" fn transparent_str(p: TransparentStr) { }\n //~^ ERROR: uses type `str`\n \n pub extern \"C\" fn transparent_fn(p: TransparentBadFn) { }\n-//~^ ERROR: uses type `std::boxed::Box<u32>`\n \n pub extern \"C\" fn good3(fptr: Option<extern fn()>) { }\n "}, {"sha": "d0a449514e50ef767db39de3abc0817ba96eeab5", "filename": "src/test/ui/lint/lint-ctypes-fn.stderr", "status": "modified", "additions": 14, "deletions": 41, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Flint%2Flint-ctypes-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Flint%2Flint-ctypes-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-fn.stderr?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -21,17 +21,8 @@ LL | pub extern \"C\" fn str_type(p: &str) { }\n    = help: consider using `*const u8` and a length instead\n    = note: string slices have no C equivalent\n \n-error: `extern` fn uses type `std::boxed::Box<u32>`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:73:31\n-   |\n-LL | pub extern \"C\" fn box_type(p: Box<u32>) { }\n-   |                               ^^^^^^^^ not FFI-safe\n-   |\n-   = help: consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n-   = note: this struct has unspecified layout\n-\n error: `extern` fn uses type `char`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:76:32\n+  --> $DIR/lint-ctypes-fn.rs:77:32\n    |\n LL | pub extern \"C\" fn char_type(p: char) { }\n    |                                ^^^^ not FFI-safe\n@@ -40,23 +31,23 @@ LL | pub extern \"C\" fn char_type(p: char) { }\n    = note: the `char` type has no C equivalent\n \n error: `extern` fn uses type `i128`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:79:32\n+  --> $DIR/lint-ctypes-fn.rs:80:32\n    |\n LL | pub extern \"C\" fn i128_type(p: i128) { }\n    |                                ^^^^ not FFI-safe\n    |\n    = note: 128-bit integers don't currently have a known stable ABI\n \n error: `extern` fn uses type `u128`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:82:32\n+  --> $DIR/lint-ctypes-fn.rs:83:32\n    |\n LL | pub extern \"C\" fn u128_type(p: u128) { }\n    |                                ^^^^ not FFI-safe\n    |\n    = note: 128-bit integers don't currently have a known stable ABI\n \n error: `extern` fn uses type `(i32, i32)`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:85:33\n+  --> $DIR/lint-ctypes-fn.rs:86:33\n    |\n LL | pub extern \"C\" fn tuple_type(p: (i32, i32)) { }\n    |                                 ^^^^^^^^^^ not FFI-safe\n@@ -65,7 +56,7 @@ LL | pub extern \"C\" fn tuple_type(p: (i32, i32)) { }\n    = note: tuples have unspecified layout\n \n error: `extern` fn uses type `(i32, i32)`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:88:34\n+  --> $DIR/lint-ctypes-fn.rs:89:34\n    |\n LL | pub extern \"C\" fn tuple_type2(p: I32Pair) { }\n    |                                  ^^^^^^^ not FFI-safe\n@@ -74,7 +65,7 @@ LL | pub extern \"C\" fn tuple_type2(p: I32Pair) { }\n    = note: tuples have unspecified layout\n \n error: `extern` fn uses type `ZeroSize`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:91:32\n+  --> $DIR/lint-ctypes-fn.rs:92:32\n    |\n LL | pub extern \"C\" fn zero_size(p: ZeroSize) { }\n    |                                ^^^^^^^^ not FFI-safe\n@@ -88,7 +79,7 @@ LL | pub struct ZeroSize;\n    | ^^^^^^^^^^^^^^^^^^^^\n \n error: `extern` fn uses type `ZeroSizeWithPhantomData`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:94:40\n+  --> $DIR/lint-ctypes-fn.rs:95:40\n    |\n LL | pub extern \"C\" fn zero_size_phantom(p: ZeroSizeWithPhantomData) { }\n    |                                        ^^^^^^^^^^^^^^^^^^^^^^^ not FFI-safe\n@@ -101,15 +92,15 @@ LL | pub struct ZeroSizeWithPhantomData(PhantomData<i32>);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `extern` fn uses type `std::marker::PhantomData<bool>`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:97:51\n+  --> $DIR/lint-ctypes-fn.rs:98:51\n    |\n LL | pub extern \"C\" fn zero_size_phantom_toplevel() -> PhantomData<bool> {\n    |                                                   ^^^^^^^^^^^^^^^^^ not FFI-safe\n    |\n    = note: composed only of `PhantomData`\n \n error: `extern` fn uses type `fn()`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:102:30\n+  --> $DIR/lint-ctypes-fn.rs:103:30\n    |\n LL | pub extern \"C\" fn fn_type(p: RustFn) { }\n    |                              ^^^^^^ not FFI-safe\n@@ -118,23 +109,14 @@ LL | pub extern \"C\" fn fn_type(p: RustFn) { }\n    = note: this function pointer has Rust-specific calling convention\n \n error: `extern` fn uses type `fn()`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:105:31\n+  --> $DIR/lint-ctypes-fn.rs:106:31\n    |\n LL | pub extern \"C\" fn fn_type2(p: fn()) { }\n    |                               ^^^^ not FFI-safe\n    |\n    = help: consider using an `extern fn(...) -> ...` function pointer instead\n    = note: this function pointer has Rust-specific calling convention\n \n-error: `extern` fn uses type `std::boxed::Box<u32>`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:108:35\n-   |\n-LL | pub extern \"C\" fn fn_contained(p: RustBadRet) { }\n-   |                                   ^^^^^^^^^^ not FFI-safe\n-   |\n-   = help: consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n-   = note: this struct has unspecified layout\n-\n error: `extern` fn uses type `i128`, which is not FFI-safe\n   --> $DIR/lint-ctypes-fn.rs:111:39\n    |\n@@ -152,25 +134,16 @@ LL | pub extern \"C\" fn transparent_str(p: TransparentStr) { }\n    = help: consider using `*const u8` and a length instead\n    = note: string slices have no C equivalent\n \n-error: `extern` fn uses type `std::boxed::Box<u32>`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:117:37\n-   |\n-LL | pub extern \"C\" fn transparent_fn(p: TransparentBadFn) { }\n-   |                                     ^^^^^^^^^^^^^^^^ not FFI-safe\n-   |\n-   = help: consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n-   = note: this struct has unspecified layout\n-\n error: `extern` fn uses type `std::marker::PhantomData<bool>`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:161:43\n+  --> $DIR/lint-ctypes-fn.rs:160:43\n    |\n LL | pub extern \"C\" fn unused_generic2<T>() -> PhantomData<bool> {\n    |                                           ^^^^^^^^^^^^^^^^^ not FFI-safe\n    |\n    = note: composed only of `PhantomData`\n \n error: `extern` fn uses type `std::vec::Vec<T>`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:174:39\n+  --> $DIR/lint-ctypes-fn.rs:173:39\n    |\n LL | pub extern \"C\" fn used_generic4<T>(x: Vec<T>) { }\n    |                                       ^^^^^^ not FFI-safe\n@@ -179,13 +152,13 @@ LL | pub extern \"C\" fn used_generic4<T>(x: Vec<T>) { }\n    = note: this struct has unspecified layout\n \n error: `extern` fn uses type `std::vec::Vec<T>`, which is not FFI-safe\n-  --> $DIR/lint-ctypes-fn.rs:177:41\n+  --> $DIR/lint-ctypes-fn.rs:176:41\n    |\n LL | pub extern \"C\" fn used_generic5<T>() -> Vec<T> {\n    |                                         ^^^^^^ not FFI-safe\n    |\n    = help: consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n    = note: this struct has unspecified layout\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 17 previous errors\n "}, {"sha": "bdf95350c70451c6a82eb66a03c8332f790b95e8", "filename": "src/test/ui/lint/lint-ctypes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Flint%2Flint-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Flint%2Flint-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -48,6 +48,8 @@ extern {\n     pub fn slice_type(p: &[u32]); //~ ERROR: uses type `[u32]`\n     pub fn str_type(p: &str); //~ ERROR: uses type `str`\n     pub fn box_type(p: Box<u32>); //~ ERROR uses type `std::boxed::Box<u32>`\n+    pub fn opt_box_type(p: Option<Box<u32>>);\n+    //~^ ERROR uses type `std::option::Option<std::boxed::Box<u32>>`\n     pub fn char_type(p: char); //~ ERROR uses type `char`\n     pub fn i128_type(p: i128); //~ ERROR uses type `i128`\n     pub fn u128_type(p: u128); //~ ERROR uses type `u128`"}, {"sha": "13b9adca3f9f5af7c4cd86f6d369daac55ae66b8", "filename": "src/test/ui/lint/lint-ctypes.stderr", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Flint%2Flint-ctypes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Flint%2Flint-ctypes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes.stderr?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -58,8 +58,17 @@ LL |     pub fn box_type(p: Box<u32>);\n    = help: consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n    = note: this struct has unspecified layout\n \n+error: `extern` block uses type `std::option::Option<std::boxed::Box<u32>>`, which is not FFI-safe\n+  --> $DIR/lint-ctypes.rs:51:28\n+   |\n+LL |     pub fn opt_box_type(p: Option<Box<u32>>);\n+   |                            ^^^^^^^^^^^^^^^^ not FFI-safe\n+   |\n+   = help: consider adding a `#[repr(C)]`, `#[repr(transparent)]`, or integer `#[repr(...)]` attribute to this enum\n+   = note: enum has no representation hint\n+\n error: `extern` block uses type `char`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:51:25\n+  --> $DIR/lint-ctypes.rs:53:25\n    |\n LL |     pub fn char_type(p: char);\n    |                         ^^^^ not FFI-safe\n@@ -68,31 +77,31 @@ LL |     pub fn char_type(p: char);\n    = note: the `char` type has no C equivalent\n \n error: `extern` block uses type `i128`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:52:25\n+  --> $DIR/lint-ctypes.rs:54:25\n    |\n LL |     pub fn i128_type(p: i128);\n    |                         ^^^^ not FFI-safe\n    |\n    = note: 128-bit integers don't currently have a known stable ABI\n \n error: `extern` block uses type `u128`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:53:25\n+  --> $DIR/lint-ctypes.rs:55:25\n    |\n LL |     pub fn u128_type(p: u128);\n    |                         ^^^^ not FFI-safe\n    |\n    = note: 128-bit integers don't currently have a known stable ABI\n \n error: `extern` block uses type `dyn std::clone::Clone`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:54:26\n+  --> $DIR/lint-ctypes.rs:56:26\n    |\n LL |     pub fn trait_type(p: &dyn Clone);\n    |                          ^^^^^^^^^^ not FFI-safe\n    |\n    = note: trait objects have no C equivalent\n \n error: `extern` block uses type `(i32, i32)`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:55:26\n+  --> $DIR/lint-ctypes.rs:57:26\n    |\n LL |     pub fn tuple_type(p: (i32, i32));\n    |                          ^^^^^^^^^^ not FFI-safe\n@@ -101,7 +110,7 @@ LL |     pub fn tuple_type(p: (i32, i32));\n    = note: tuples have unspecified layout\n \n error: `extern` block uses type `(i32, i32)`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:56:27\n+  --> $DIR/lint-ctypes.rs:58:27\n    |\n LL |     pub fn tuple_type2(p: I32Pair);\n    |                           ^^^^^^^ not FFI-safe\n@@ -110,7 +119,7 @@ LL |     pub fn tuple_type2(p: I32Pair);\n    = note: tuples have unspecified layout\n \n error: `extern` block uses type `ZeroSize`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:57:25\n+  --> $DIR/lint-ctypes.rs:59:25\n    |\n LL |     pub fn zero_size(p: ZeroSize);\n    |                         ^^^^^^^^ not FFI-safe\n@@ -124,7 +133,7 @@ LL | pub struct ZeroSize;\n    | ^^^^^^^^^^^^^^^^^^^^\n \n error: `extern` block uses type `ZeroSizeWithPhantomData`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:58:33\n+  --> $DIR/lint-ctypes.rs:60:33\n    |\n LL |     pub fn zero_size_phantom(p: ZeroSizeWithPhantomData);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^ not FFI-safe\n@@ -137,15 +146,15 @@ LL | pub struct ZeroSizeWithPhantomData(::std::marker::PhantomData<i32>);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `extern` block uses type `std::marker::PhantomData<bool>`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:61:12\n+  --> $DIR/lint-ctypes.rs:63:12\n    |\n LL |         -> ::std::marker::PhantomData<bool>;\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not FFI-safe\n    |\n    = note: composed only of `PhantomData`\n \n error: `extern` block uses type `fn()`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:62:23\n+  --> $DIR/lint-ctypes.rs:64:23\n    |\n LL |     pub fn fn_type(p: RustFn);\n    |                       ^^^^^^ not FFI-safe\n@@ -154,7 +163,7 @@ LL |     pub fn fn_type(p: RustFn);\n    = note: this function pointer has Rust-specific calling convention\n \n error: `extern` block uses type `fn()`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:63:24\n+  --> $DIR/lint-ctypes.rs:65:24\n    |\n LL |     pub fn fn_type2(p: fn());\n    |                        ^^^^ not FFI-safe\n@@ -163,7 +172,7 @@ LL |     pub fn fn_type2(p: fn());\n    = note: this function pointer has Rust-specific calling convention\n \n error: `extern` block uses type `std::boxed::Box<u32>`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:64:28\n+  --> $DIR/lint-ctypes.rs:66:28\n    |\n LL |     pub fn fn_contained(p: RustBadRet);\n    |                            ^^^^^^^^^^ not FFI-safe\n@@ -172,15 +181,15 @@ LL |     pub fn fn_contained(p: RustBadRet);\n    = note: this struct has unspecified layout\n \n error: `extern` block uses type `i128`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:65:32\n+  --> $DIR/lint-ctypes.rs:67:32\n    |\n LL |     pub fn transparent_i128(p: TransparentI128);\n    |                                ^^^^^^^^^^^^^^^ not FFI-safe\n    |\n    = note: 128-bit integers don't currently have a known stable ABI\n \n error: `extern` block uses type `str`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:66:31\n+  --> $DIR/lint-ctypes.rs:68:31\n    |\n LL |     pub fn transparent_str(p: TransparentStr);\n    |                               ^^^^^^^^^^^^^^ not FFI-safe\n@@ -189,7 +198,7 @@ LL |     pub fn transparent_str(p: TransparentStr);\n    = note: string slices have no C equivalent\n \n error: `extern` block uses type `std::boxed::Box<u32>`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:67:30\n+  --> $DIR/lint-ctypes.rs:69:30\n    |\n LL |     pub fn transparent_fn(p: TransparentBadFn);\n    |                              ^^^^^^^^^^^^^^^^ not FFI-safe\n@@ -198,7 +207,7 @@ LL |     pub fn transparent_fn(p: TransparentBadFn);\n    = note: this struct has unspecified layout\n \n error: `extern` block uses type `[u8; 8]`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:68:27\n+  --> $DIR/lint-ctypes.rs:70:27\n    |\n LL |     pub fn raw_array(arr: [u8; 8]);\n    |                           ^^^^^^^ not FFI-safe\n@@ -207,20 +216,20 @@ LL |     pub fn raw_array(arr: [u8; 8]);\n    = note: passing raw arrays by value is not FFI-safe\n \n error: `extern` block uses type `u128`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:70:34\n+  --> $DIR/lint-ctypes.rs:72:34\n    |\n LL |     pub static static_u128_type: u128;\n    |                                  ^^^^ not FFI-safe\n    |\n    = note: 128-bit integers don't currently have a known stable ABI\n \n error: `extern` block uses type `u128`, which is not FFI-safe\n-  --> $DIR/lint-ctypes.rs:71:40\n+  --> $DIR/lint-ctypes.rs:73:40\n    |\n LL |     pub static static_u128_array_type: [u128; 16];\n    |                                        ^^^^^^^^^^ not FFI-safe\n    |\n    = note: 128-bit integers don't currently have a known stable ABI\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 24 previous errors\n "}, {"sha": "1894cd218ee347f94546d2b7fa32a878f5937ad1", "filename": "src/test/ui/print_type_sizes/niche-filling.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -8,12 +8,12 @@ print-type-size     variant `Some`: 12 bytes\n print-type-size         field `.0`: 12 bytes\n print-type-size     variant `None`: 0 bytes\n print-type-size type: `EmbeddedDiscr`: 8 bytes, alignment: 4 bytes\n+print-type-size     discriminant: 1 bytes\n print-type-size     variant `Record`: 7 bytes\n-print-type-size         field `.val`: 4 bytes\n-print-type-size         field `.post`: 2 bytes\n print-type-size         field `.pre`: 1 bytes\n+print-type-size         field `.post`: 2 bytes\n+print-type-size         field `.val`: 4 bytes\n print-type-size     variant `None`: 0 bytes\n-print-type-size     end padding: 1 bytes\n print-type-size type: `MyOption<Union1<std::num::NonZeroU32>>`: 8 bytes, alignment: 4 bytes\n print-type-size     discriminant: 4 bytes\n print-type-size     variant `Some`: 4 bytes"}, {"sha": "73a11a5e743f6a7f85810bfbcc0d86d54cf7fd3d", "filename": "src/test/ui/type-sizes.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftest%2Fui%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-sizes.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -5,6 +5,7 @@\n #![feature(never_type)]\n \n use std::mem::size_of;\n+use std::num::NonZeroU8;\n \n struct t {a: u8, b: i8}\n struct u {a: u8, b: i8, c: u8}\n@@ -102,6 +103,23 @@ enum Option2<A, B> {\n     None\n }\n \n+// Two layouts are considered for `CanBeNicheFilledButShouldnt`:\n+//   Niche-filling:\n+//     { u32 (4 bytes), NonZeroU8 + tag in niche (1 byte), padding (3 bytes) }\n+//   Tagged:\n+//     { tag (1 byte), NonZeroU8 (1 byte), padding (2 bytes), u32 (4 bytes) }\n+// Both are the same size (due to padding),\n+// but the tagged layout is better as the tag creates a niche with 254 invalid values,\n+// allowing types like `Option<Option<CanBeNicheFilledButShouldnt>>` to fit into 8 bytes.\n+pub enum CanBeNicheFilledButShouldnt {\n+    A(NonZeroU8, u32),\n+    B\n+}\n+pub enum AlwaysTaggedBecauseItHasNoNiche {\n+    A(u8, u32),\n+    B\n+}\n+\n pub fn main() {\n     assert_eq!(size_of::<u8>(), 1 as usize);\n     assert_eq!(size_of::<u32>(), 4 as usize);\n@@ -145,4 +163,11 @@ pub fn main() {\n     assert_eq!(size_of::<Option<Option<(&(), bool)>>>(), size_of::<(bool, &())>());\n     assert_eq!(size_of::<Option<Option2<bool, &()>>>(), size_of::<(bool, &())>());\n     assert_eq!(size_of::<Option<Option2<&(), bool>>>(), size_of::<(bool, &())>());\n+\n+    assert_eq!(size_of::<CanBeNicheFilledButShouldnt>(), 8);\n+    assert_eq!(size_of::<Option<CanBeNicheFilledButShouldnt>>(), 8);\n+    assert_eq!(size_of::<Option<Option<CanBeNicheFilledButShouldnt>>>(), 8);\n+    assert_eq!(size_of::<AlwaysTaggedBecauseItHasNoNiche>(), 8);\n+    assert_eq!(size_of::<Option<AlwaysTaggedBecauseItHasNoNiche>>(), 8);\n+    assert_eq!(size_of::<Option<Option<AlwaysTaggedBecauseItHasNoNiche>>>(), 8);\n }"}, {"sha": "559267a494f29a009954f07d66b8f02399e1f8ac", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d31ffc1ac9e9ea356e896e63307168a64501b9d/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=7d31ffc1ac9e9ea356e896e63307168a64501b9d", "patch": "@@ -123,6 +123,7 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"opaque-debug\",\n     \"parking_lot\",\n     \"parking_lot_core\",\n+    \"pathdiff\",\n     \"pkg-config\",\n     \"polonius-engine\",\n     \"ppv-lite86\","}]}