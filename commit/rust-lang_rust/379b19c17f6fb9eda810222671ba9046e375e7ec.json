{"sha": "379b19c17f6fb9eda810222671ba9046e375e7ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3OWIxOWMxN2Y2ZmI5ZWRhODEwMjIyNjcxYmE5MDQ2ZTM3NWU3ZWM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-07T13:27:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-07T13:27:20Z"}, "message": "Rollup merge of #63793 - oli-obk:\ud83e\uddf9, r=dtolnay\n\nHave tidy ensure that we document all `unsafe` blocks in libcore\n\ncc @rust-lang/libs\n\nI documented a few and added ignore flags on the other files. We can incrementally document the files, but won't regress any files this way.", "tree": {"sha": "a443a94d9e2c5101779487b24bd345f025fb3867", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a443a94d9e2c5101779487b24bd345f025fb3867"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/379b19c17f6fb9eda810222671ba9046e375e7ec", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdxBu4CRBK7hj4Ov3rIwAAdHIIAKlRbKsYNTek0jY8bHm5c1wt\naHpWeqgIg4UMPsCF07NAGHe8bil49qm/+/60D4vUOK2tH46iw1oOZB3OKAcLXP2Y\n9H9Qa+wW9a16/8rFjI33jMMupVS+EWy9fBc4afIwrjelkHMKqkVpUQs05N/j7gjk\nRHOB+v4V9DOM8mSJ+20nV8Ud8Utq+sS6sdspsZjZP+db7JKTGaG99riMWYvtd/Ry\nftjNmWheLSjVGZPcEGCrSCvokOvWCBsaAzt+rH01/2rGQZVsXOof2RyiWkxGVgvN\nWOJcAA33fxvCCMWLrF72/1Aq0ajSCsFzO/RCwwgxhsY0v4SGsFcFwWsPdhzx52I=\n=vrr5\n-----END PGP SIGNATURE-----\n", "payload": "tree a443a94d9e2c5101779487b24bd345f025fb3867\nparent 50f8aadd746ebc929a752e5ffb133936ee75c52f\nparent e28287b32c40c44fb120c9a3a7eae6f82a7031fa\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1573133240 +0100\ncommitter GitHub <noreply@github.com> 1573133240 +0100\n\nRollup merge of #63793 - oli-obk:\ud83e\uddf9, r=dtolnay\n\nHave tidy ensure that we document all `unsafe` blocks in libcore\n\ncc @rust-lang/libs\n\nI documented a few and added ignore flags on the other files. We can incrementally document the files, but won't regress any files this way.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/379b19c17f6fb9eda810222671ba9046e375e7ec", "html_url": "https://github.com/rust-lang/rust/commit/379b19c17f6fb9eda810222671ba9046e375e7ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/379b19c17f6fb9eda810222671ba9046e375e7ec/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50f8aadd746ebc929a752e5ffb133936ee75c52f", "url": "https://api.github.com/repos/rust-lang/rust/commits/50f8aadd746ebc929a752e5ffb133936ee75c52f", "html_url": "https://github.com/rust-lang/rust/commit/50f8aadd746ebc929a752e5ffb133936ee75c52f"}, {"sha": "e28287b32c40c44fb120c9a3a7eae6f82a7031fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e28287b32c40c44fb120c9a3a7eae6f82a7031fa", "html_url": "https://github.com/rust-lang/rust/commit/e28287b32c40c44fb120c9a3a7eae6f82a7031fa"}], "stats": {"total": 222, "additions": 180, "deletions": 42}, "files": [{"sha": "1b06baeb711c2293b863c390e62d3298afc0ee8d", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -1,5 +1,7 @@\n //! Memory allocation APIs\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use crate::cmp;"}, {"sha": "39a5dd7263ccfcbdcb8ad9fdda0446a649ea5d03", "filename": "src/libcore/any.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -182,6 +182,7 @@ impl dyn Any {\n     #[inline]\n     pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n         if self.is::<T>() {\n+            // SAFETY: just checked whether we are pointing to the correct type\n             unsafe {\n                 Some(&*(self as *const dyn Any as *const T))\n             }\n@@ -217,6 +218,7 @@ impl dyn Any {\n     #[inline]\n     pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n         if self.is::<T>() {\n+            // SAFETY: just checked whether we are pointing to the correct type\n             unsafe {\n                 Some(&mut *(self as *mut dyn Any as *mut T))\n             }\n@@ -424,7 +426,11 @@ impl TypeId {\n     #[rustc_const_unstable(feature=\"const_type_id\")]\n     pub const fn of<T: ?Sized + 'static>() -> TypeId {\n         TypeId {\n+            #[cfg(bootstrap)]\n+            // SAFETY: going away soon\n             t: unsafe { intrinsics::type_id::<T>() },\n+            #[cfg(not(bootstrap))]\n+            t: intrinsics::type_id::<T>(),\n         }\n     }\n }"}, {"sha": "307e9b90ee2c0cfe1f62e6f875867796453534ea", "filename": "src/libcore/array/iter.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -51,7 +51,7 @@ where\n     /// iterator (either via `IntoIterator` for arrays or via another way).\n     #[unstable(feature = \"array_value_iter\", issue = \"65798\")]\n     pub fn new(array: [T; N]) -> Self {\n-        // The transmute here is actually safe. The docs of `MaybeUninit`\n+        // SAFETY: The transmute here is actually safe. The docs of `MaybeUninit`\n         // promise:\n         //\n         // > `MaybeUninit<T>` is guaranteed to have the same size and alignment\n@@ -84,10 +84,10 @@ where\n     /// Returns an immutable slice of all elements that have not been yielded\n     /// yet.\n     fn as_slice(&self) -> &[T] {\n-        // This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n+        let slice = &self.data[self.alive.clone()];\n+        // SAFETY: This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n         // the size and alignment of `T`. Furthermore, we know that all\n         // elements within `alive` are properly initialized.\n-        let slice = &self.data[self.alive.clone()];\n         unsafe {\n             mem::transmute::<&[MaybeUninit<T>], &[T]>(slice)\n         }\n@@ -117,7 +117,8 @@ where\n         let idx = self.alive.start;\n         self.alive.start += 1;\n \n-        // Read the element from the array. This is safe: `idx` is an index\n+        // Read the element from the array.\n+        // SAFETY: This is safe: `idx` is an index\n         // into the \"alive\" region of the array. Reading this element means\n         // that `data[idx]` is regarded as dead now (i.e. do not touch). As\n         // `idx` was the start of the alive-zone, the alive zone is now\n@@ -163,7 +164,8 @@ where\n         // + 1]`.\n         self.alive.end -= 1;\n \n-        // Read the element from the array. This is safe: `alive.end` is an\n+        // Read the element from the array.\n+        // SAFETY: This is safe: `alive.end` is an\n         // index into the \"alive\" region of the array. Compare the previous\n         // comment that states that the alive region is\n         // `data[alive.start..alive.end + 1]`. Reading this element means that\n@@ -226,6 +228,7 @@ where\n     [T; N]: LengthAtMost32,\n {\n     fn clone(&self) -> Self {\n+        // SAFETY: each point of unsafety is documented inside the unsafe block\n         unsafe {\n             // This creates a new uninitialized array. Note that the `assume_init`\n             // refers to the array, not the individual elements. And it is Ok if"}, {"sha": "74a7d062d3f4afe37dede82858bdd864c05671da", "filename": "src/libcore/array/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fmod.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -156,6 +156,7 @@ where\n     fn try_from(slice: &[T]) -> Result<&[T; N], TryFromSliceError> {\n         if slice.len() == N {\n             let ptr = slice.as_ptr() as *const [T; N];\n+            // SAFETY: ok because we just checked that the length fits\n             unsafe { Ok(&*ptr) }\n         } else {\n             Err(TryFromSliceError(()))\n@@ -173,6 +174,7 @@ where\n     fn try_from(slice: &mut [T]) -> Result<&mut [T; N], TryFromSliceError> {\n         if slice.len() == N {\n             let ptr = slice.as_mut_ptr() as *mut [T; N];\n+            // SAFETY: ok because we just checked that the length fits\n             unsafe { Ok(&mut *ptr) }\n         } else {\n             Err(TryFromSliceError(()))"}, {"sha": "9b588525bd6982775644f7035e3641141388ebe6", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -135,6 +135,7 @@ impl FusedIterator for EscapeDefault {}\n #[stable(feature = \"ascii_escape_display\", since = \"1.39.0\")]\n impl fmt::Display for EscapeDefault {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // SAFETY: ok because `escape_default` created only valid utf-8 data\n         f.write_str(unsafe { from_utf8_unchecked(&self.data[self.range.clone()]) })\n     }\n }"}, {"sha": "e921dd1ba0636bec010bacdd41ed3cece7f457ec", "filename": "src/libcore/benches/ascii.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fbenches%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fbenches%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fascii.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -118,6 +118,7 @@ benches! {\n     }\n \n     fn case07_fake_simd_u32(bytes: &mut [u8]) {\n+        // SAFETY: transmuting a sequence of `u8` to `u32` is always fine\n         let (before, aligned, after) = unsafe {\n             bytes.align_to_mut::<u32>()\n         };\n@@ -142,6 +143,7 @@ benches! {\n     }\n \n     fn case08_fake_simd_u64(bytes: &mut [u8]) {\n+        // SAFETY: transmuting a sequence of `u8` to `u64` is always fine\n         let (before, aligned, after) = unsafe {\n             bytes.align_to_mut::<u64>()\n         };"}, {"sha": "87d8e7aff058dc284c4a4da4ae22e2d858262047", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -187,6 +187,8 @@\n //! ```\n //!\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cmp::Ordering;"}, {"sha": "28f520744956135539159da9449d148c0833d0b6", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -224,6 +224,7 @@ impl TryFrom<u32> for char {\n         if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n             Err(CharTryFromError(()))\n         } else {\n+            // SAFETY: checked that it's a legal unicode value\n             Ok(unsafe { from_u32_unchecked(i) })\n         }\n     }"}, {"sha": "ae09251c776de4e9d2b352054b6aec9b255b5773", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -87,7 +87,7 @@ impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n         };\n \n         if u < 0xD800 || 0xDFFF < u {\n-            // not a surrogate\n+            // SAFETY: not a surrogate\n             Some(Ok(unsafe { from_u32_unchecked(u as u32) }))\n         } else if u >= 0xDC00 {\n             // a trailing surrogate\n@@ -107,6 +107,7 @@ impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n \n             // all ok, so lets decode it.\n             let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n+            // SAFETY: we checked that it's a legal unicode value\n             Some(Ok(unsafe { from_u32_unchecked(c) }))\n         }\n     }"}, {"sha": "c048bab287dd2aa0408f639689ce19fb4622f105", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -438,6 +438,7 @@ impl char {\n     #[inline]\n     pub fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n         let code = self as u32;\n+        // SAFETY: each arm checks the size of the slice and only uses `get_unchecked` unsafe ops\n         unsafe {\n             let len = if code < MAX_ONE_B && !dst.is_empty() {\n                 *dst.get_unchecked_mut(0) = code as u8;\n@@ -507,6 +508,7 @@ impl char {\n     #[inline]\n     pub fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n         let mut code = self as u32;\n+        // SAFETY: each arm checks whether there are enough bits to write into\n         unsafe {\n             if (code & 0xFFFF) == code && !dst.is_empty() {\n                 // The BMP falls through (assuming non-surrogate, as it should)"}, {"sha": "499dd0facd38c6ba47948122a1ddc3313b29585c", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -315,6 +315,7 @@ impl<'f> Clone for VaListImpl<'f> {\n     #[inline]\n     fn clone(&self) -> Self {\n         let mut dest = crate::mem::MaybeUninit::uninit();\n+        // SAFETY: we write to the `MaybeUninit`, thus it is initialized and `assume_init` is legal\n         unsafe {\n             va_copy(dest.as_mut_ptr(), self);\n             dest.assume_init()"}, {"sha": "b52b56b1bdbc28f7cb0d5d5dfcbbe67e0108d668", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -2,6 +2,8 @@ use crate::fmt::{Formatter, Result, LowerExp, UpperExp, Display, Debug};\n use crate::mem::MaybeUninit;\n use crate::num::flt2dec;\n \n+// ignore-tidy-undocumented-unsafe\n+\n // Don't inline this so callers don't use the stack space this function\n // requires unless they have to.\n #[inline(never)]"}, {"sha": "5a039144f667fe7ec20cabacfa4cd1f8cf1afca3", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -1,5 +1,7 @@\n //! Utilities for formatting and printing strings.\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cell::{UnsafeCell, Cell, RefCell, Ref, RefMut};"}, {"sha": "3c7aefc090f8ede41a3478f17f17b675912ffa3a", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -1,5 +1,7 @@\n //! Integer and floating-point number formatting\n \n+// ignore-tidy-undocumented-unsafe\n+\n \n use crate::fmt;\n use crate::ops::{Div, Rem, Sub};"}, {"sha": "0082363692df67572c8c9e86d806e1d2e7a71a0d", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -79,6 +79,8 @@\n //! }\n //! ```\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fmt;"}, {"sha": "194d9e6e2f8ad498da7873b60a7a0ec90cab0e0f", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -1,5 +1,7 @@\n //! An implementation of SipHash.\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![allow(deprecated)] // the types in this module are deprecated\n \n use crate::marker::PhantomData;"}, {"sha": "f68a3e5a76fd74b0e5324444bb76165387847dbc", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -2,6 +2,8 @@\n \n //! Hints to compiler that affects how code should be emitted or optimized.\n \n+// ignore-tidy-undocumented-unsafe\n+\n use crate::intrinsics;\n \n /// Informs the compiler that this point in the code is not reachable, enabling"}, {"sha": "39d571006e66a154fc7a6dad0a69bd6f27e5b2a3", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -517,8 +517,18 @@ impl<I> Iterator for StepBy<I> where I: Iterator {\n         // overflow handling\n         loop {\n             let mul = n.checked_mul(step);\n-            if unsafe { intrinsics::likely(mul.is_some()) } {\n-                return self.iter.nth(mul.unwrap() - 1);\n+            #[cfg(bootstrap)]\n+            {\n+                // SAFETY: going away soon\n+                if unsafe { intrinsics::likely(mul.is_some()) } {\n+                    return self.iter.nth(mul.unwrap() - 1);\n+                }\n+            }\n+            #[cfg(not(bootstrap))]\n+            {\n+                if intrinsics::likely(mul.is_some()) {\n+                    return self.iter.nth(mul.unwrap() - 1);\n+                }\n             }\n             let div_n = usize::MAX / n;\n             let div_step = usize::MAX / step;"}, {"sha": "14d9d5499b88033010c7d8944ee83ff22911d672", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -1,3 +1,5 @@\n+// ignore-tidy-undocumented-unsafe\n+\n use crate::cmp;\n \n use super::super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen};"}, {"sha": "4b3dc1c83c41dab3ecea4afeb4778810ac0ceec4", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -1,6 +1,8 @@\n use crate::intrinsics;\n use crate::mem::ManuallyDrop;\n \n+// ignore-tidy-undocumented-unsafe\n+\n /// A wrapper type to construct uninitialized instances of `T`.\n ///\n /// # Initialization invariant"}, {"sha": "26909be9496645458c37519a3817360d3c2d7f2e", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -93,6 +93,8 @@ pub fn forget<T>(t: T) {\n #[inline]\n #[unstable(feature = \"forget_unsized\", issue = \"0\")]\n pub fn forget_unsized<T: ?Sized>(t: T) {\n+    // SAFETY: the forget intrinsic could be safe, but there's no point in making it safe since\n+    // we'll be implementing this function soon via `ManuallyDrop`\n     unsafe { intrinsics::forget(t) }\n }\n \n@@ -266,7 +268,11 @@ pub const fn size_of<T>() -> usize {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n+    #[cfg(bootstrap)]\n+    // SAFETY: going away soon\n     unsafe { intrinsics::size_of_val(val) }\n+    #[cfg(not(bootstrap))]\n+    intrinsics::size_of_val(val)\n }\n \n /// Returns the [ABI]-required minimum alignment of a type.\n@@ -310,7 +316,11 @@ pub fn min_align_of<T>() -> usize {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")]\n pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n+    #[cfg(bootstrap)]\n+    // SAFETY: going away soon\n     unsafe { intrinsics::min_align_of_val(val) }\n+    #[cfg(not(bootstrap))]\n+    intrinsics::min_align_of_val(val)\n }\n \n /// Returns the [ABI]-required minimum alignment of a type.\n@@ -350,8 +360,9 @@ pub const fn align_of<T>() -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n-    unsafe { intrinsics::min_align_of_val(val) }\n+    min_align_of_val(val)\n }\n \n /// Returns `true` if dropping values of type `T` matters.\n@@ -508,6 +519,8 @@ pub unsafe fn uninitialized<T>() -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n+    // SAFETY: the raw pointers have been created from safe mutable references satisfying all the\n+    // constraints on `ptr::swap_nonoverlapping_one`\n     unsafe {\n         ptr::swap_nonoverlapping_one(x, y);\n     }\n@@ -822,7 +835,11 @@ impl<T> fmt::Debug for Discriminant<T> {\n /// ```\n #[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n+    #[cfg(bootstrap)]\n+    // SAFETY: going away soon\n     unsafe {\n         Discriminant(intrinsics::discriminant_value(v), PhantomData)\n     }\n+    #[cfg(not(bootstrap))]\n+    Discriminant(intrinsics::discriminant_value(v), PhantomData)\n }"}, {"sha": "641463026261d9525264f2c3324473b74ad53d30", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -58,6 +58,8 @@ mod fpu_precision {\n     pub struct FPUControlWord(u16);\n \n     fn set_cw(cw: u16) {\n+        // SAFETY: the `fldcw` instruction has been audited to be able to work correctly with\n+        // any `u16`\n         unsafe { asm!(\"fldcw $0\" :: \"m\" (cw) :: \"volatile\") }\n     }\n \n@@ -74,6 +76,8 @@ mod fpu_precision {\n \n         // Get the original value of the control word to restore it later, when the\n         // `FPUControlWord` structure is dropped\n+        // SAFETY: the `fnstcw` instruction has been audited to be able to work correctly with\n+        // any `u16`\n         unsafe { asm!(\"fnstcw $0\" : \"=*m\" (&cw) ::: \"volatile\") }\n \n         // Set the control word to the desired precision. This is achieved by masking away the old"}, {"sha": "7662bba6b5e139deaf01f225fce4a2eb5d8b6181", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -414,6 +414,7 @@ impl f32 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn to_bits(self) -> u32 {\n+        // SAFETY: `u32` is a plain old datatype so we can always transmute to it\n         unsafe { mem::transmute(self) }\n     }\n \n@@ -456,6 +457,7 @@ impl f32 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn from_bits(v: u32) -> Self {\n+        // SAFETY: `u32` is a plain old datatype so we can always transmute from it\n         // It turns out the safety issues with sNaN were overblown! Hooray!\n         unsafe { mem::transmute(v) }\n     }"}, {"sha": "4a2a35dfb099928ef79a262b8e3b1f779eea845e", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -427,6 +427,7 @@ impl f64 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn to_bits(self) -> u64 {\n+        // SAFETY: `u64` is a plain old datatype so we can always transmute to it\n         unsafe { mem::transmute(self) }\n     }\n \n@@ -469,6 +470,7 @@ impl f64 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn from_bits(v: u64) -> Self {\n+        // SAFETY: `u64` is a plain old datatype so we can always transmute from it\n         // It turns out the safety issues with sNaN were overblown! Hooray!\n         unsafe { mem::transmute(v) }\n     }"}, {"sha": "4b9e82c7cfee9abd16cc4f0a99d8c1ad2187ec28", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -71,6 +71,7 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n                 #[inline]\n                 pub fn new(n: $Int) -> Option<Self> {\n                     if n != 0 {\n+                        // SAFETY: we just checked that there's no `0`\n                         Some(unsafe { $Ty(n) })\n                     } else {\n                         None\n@@ -703,6 +704,7 @@ $EndFeature, \"\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n+                    // SAFETY: div by zero and by INT_MIN have been checked above\n                     Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n                 }\n             }\n@@ -759,6 +761,7 @@ $EndFeature, \"\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n+                    // SAFETY: div by zero and by INT_MIN have been checked above\n                     Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n                 }\n             }\n@@ -1329,6 +1332,8 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shl(self, rhs: u32) -> Self {\n+                // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n+                // out of bounds\n                 unsafe {\n                     intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n                 }\n@@ -1358,6 +1363,8 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shr(self, rhs: u32) -> Self {\n+                // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n+                // out of bounds\n                 unsafe {\n                     intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n                 }\n@@ -2113,6 +2120,8 @@ assert_eq!(\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                // SAFETY: integers are plain old datatypes so we can always transmute them to\n+                // arrays of bytes\n                 unsafe { mem::transmute(self) }\n             }\n         }\n@@ -2221,6 +2230,7 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                // SAFETY: integers are plain old datatypes so we can always transmute to them\n                 unsafe { mem::transmute(bytes) }\n             }\n         }\n@@ -2748,6 +2758,8 @@ assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n             pub fn checked_div(self, rhs: Self) -> Option<Self> {\n                 match rhs {\n                     0 => None,\n+                    // SAFETY: div by zero has been checked above and unsigned types have no other\n+                    // failure modes for division\n                     rhs => Some(unsafe { intrinsics::unchecked_div(self, rhs) }),\n                 }\n             }\n@@ -2799,6 +2811,8 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n                 if rhs == 0 {\n                     None\n                 } else {\n+                    // SAFETY: div by zero has been checked above and unsigned types have no other\n+                    // failure modes for division\n                     Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n                 }\n             }\n@@ -3248,6 +3262,8 @@ assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shl(self, rhs: u32) -> Self {\n+                // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n+                // out of bounds\n                 unsafe {\n                     intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n                 }\n@@ -3279,6 +3295,8 @@ assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shr(self, rhs: u32) -> Self {\n+                // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n+                // out of bounds\n                 unsafe {\n                     intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n                 }\n@@ -3775,11 +3793,11 @@ assert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n         fn one_less_than_next_power_of_two(self) -> Self {\n             if self <= 1 { return 0; }\n \n-            // Because `p > 0`, it cannot consist entirely of leading zeros.\n+            let p = self - 1;\n+            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n             // That means the shift is always in-bounds, and some processors\n             // (such as intel pre-haswell) have more efficient ctlz\n             // intrinsics when the argument is non-zero.\n-            let p = self - 1;\n             let z = unsafe { intrinsics::ctlz_nonzero(p) };\n             <$SelfT>::max_value() >> z\n         }\n@@ -3925,6 +3943,8 @@ assert_eq!(\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                // SAFETY: integers are plain old datatypes so we can always transmute them to\n+                // arrays of bytes\n                 unsafe { mem::transmute(self) }\n             }\n         }\n@@ -4033,6 +4053,7 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                // SAFETY: integers are plain old datatypes so we can always transmute to them\n                 unsafe { mem::transmute(bytes) }\n             }\n         }"}, {"sha": "958f31c0fd22a824c39252b106906945c6288056", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -133,6 +133,8 @@\n //! [`Box<T>`]: ../../std/boxed/struct.Box.html\n //! [`i32`]: ../../std/primitive.i32.html\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::iter::{FromIterator, FusedIterator, TrustedLen};"}, {"sha": "b88dc336097f33ce5739aac3d5811b90b3264ba3", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -20,6 +20,8 @@\n //! one function. Currently, the actual symbol is declared in the standard\n //! library, but the location of this may change over time.\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![allow(dead_code, missing_docs)]\n #![unstable(feature = \"core_panic\",\n             reason = \"internal details of the implementation of the `panic!` \\"}, {"sha": "1219fd09a9dfafda837a6fd27a1481cbc2070b74", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -552,6 +552,7 @@ impl<P: Deref> Pin<P> {\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_ref(&self) -> Pin<&P::Target> {\n+        // SAFETY: see documentation on this function\n         unsafe { Pin::new_unchecked(&*self.pointer) }\n     }\n \n@@ -610,6 +611,7 @@ impl<P: DerefMut> Pin<P> {\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_mut(&mut self) -> Pin<&mut P::Target> {\n+        // SAFETY: see documentation on this function\n         unsafe { Pin::new_unchecked(&mut *self.pointer) }\n     }\n "}, {"sha": "5a75730cf2bd4e14e43834e13835ba8ffda8f647", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -65,6 +65,8 @@\n //! [`write_volatile`]: ./fn.write_volatile.html\n //! [`NonNull::dangling`]: ./struct.NonNull.html#method.dangling\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::intrinsics;"}, {"sha": "7599991f0f15a78a49dd66c5bfc521cebdfc0d22", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -7,6 +7,8 @@ use crate::mem;\n use crate::ptr::Unique;\n use crate::cmp::Ordering;\n \n+// ignore-tidy-undocumented-unsafe\n+\n /// `*mut T` but non-zero and covariant.\n ///\n /// This is often the correct thing to use when building data structures using"}, {"sha": "11a3aed1ab41b945f51be27de8498be21d2c055d", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -5,6 +5,8 @@ use crate::marker::{PhantomData, Unsize};\n use crate::mem;\n use crate::ptr::NonNull;\n \n+// ignore-tidy-undocumented-unsafe\n+\n /// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n /// of this wrapper owns the referent. Useful for building abstractions like\n /// `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`."}, {"sha": "2a2169dd348c211ec14edac3e33e5f5c886ac54e", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -1,6 +1,8 @@\n // Original implementation taken from rust-memchr.\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n+// ignore-tidy-undocumented-unsafe\n+\n use crate::cmp;\n use crate::mem;\n "}, {"sha": "c8fe9f98613150f2bf31d03e25b5d97d3d575e5d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -1,4 +1,5 @@\n // ignore-tidy-filelength\n+// ignore-tidy-undocumented-unsafe\n \n //! Slice management and manipulation.\n //!"}, {"sha": "a719a51b61605b2c194c3894d6309c8056ba151b", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -6,6 +6,8 @@\n //! Unstable sorting is compatible with libcore because it doesn't allocate memory, unlike our\n //! stable sorting implementation.\n \n+// ignore-tidy-undocumented-unsafe\n+\n use crate::cmp;\n use crate::mem::{self, MaybeUninit};\n use crate::ptr;"}, {"sha": "762de0489a9756e36e129cac371e370e0a786b21", "filename": "src/libcore/str/lossy.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Flossy.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -3,6 +3,8 @@ use crate::str as core_str;\n use crate::fmt::{self, Write};\n use crate::mem;\n \n+// ignore-tidy-undocumented-unsafe\n+\n /// Lossy UTF-8 string.\n #[unstable(feature = \"str_internals\", issue = \"0\")]\n pub struct Utf8Lossy {"}, {"sha": "25b7eec5b33432ab5cb5689e0cf48d202d4e8999", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -1,4 +1,5 @@\n // ignore-tidy-filelength\n+// ignore-tidy-undocumented-unsafe\n \n //! String manipulation.\n //!"}, {"sha": "a494274118a74171dfbf50da47664bcb2ff3628e", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -3,6 +3,8 @@\n //! For more details, see the traits [`Pattern`], [`Searcher`],\n //! [`ReverseSearcher`], and [`DoubleEndedSearcher`].\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![unstable(feature = \"pattern\",\n             reason = \"API not fully fleshed out and ready to be stabilized\",\n             issue = \"27721\")]"}, {"sha": "d311cb16b64d37250f66d9bbd56b2a83a3dd87db", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -112,6 +112,8 @@\n //! println!(\"live threads: {}\", old_thread_count + 1);\n //! ```\n \n+// ignore-tidy-undocumented-unsafe\n+\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]"}, {"sha": "a35897e9bc1ac4899bc9263fb432229549d52df1", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -85,6 +85,8 @@ fn ldexp_f64(a: f64, b: i32) -> f64 {\n     extern {\n         fn ldexp(x: f64, n: i32) -> f64;\n     }\n+    // SAFETY: assuming a correct `ldexp` has been supplied, the given arguments cannot possibly\n+    // cause undefined behavior\n     unsafe { ldexp(a, b) }\n }\n "}, {"sha": "57fc1a7b76075f35f283f761fc96c5eb6d9ba010", "filename": "src/libcore/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -920,7 +920,7 @@ impl fmt::Debug for Duration {\n             if end == 0 {\n                 write!(f, \"{}\", integer_part)\n             } else {\n-                // We are only writing ASCII digits into the buffer and it was\n+                // SAFETY: We are only writing ASCII digits into the buffer and it was\n                 // initialized with '0's, so it contains valid UTF8.\n                 let s = unsafe {\n                     crate::str::from_utf8_unchecked(&buf[..end])"}, {"sha": "b3ef3217ec6a091a19a67b82ffe0e773a0111c78", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -76,7 +76,10 @@ pub fn encode_with_shorthand<E, T, M>(encoder: &mut E,\n \n     // The shorthand encoding uses the same usize as the\n     // discriminant, with an offset so they can't conflict.\n+    #[cfg(bootstrap)]\n     let discriminant = unsafe { intrinsics::discriminant_value(variant) };\n+    #[cfg(not(bootstrap))]\n+    let discriminant = intrinsics::discriminant_value(variant);\n     assert!(discriminant < SHORTHAND_OFFSET as u64);\n     let shorthand = start + SHORTHAND_OFFSET;\n "}, {"sha": "693f6f05fab2847914218ca76fb862faaa7ab824", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -67,11 +67,13 @@ fn equate_intrinsic_type<'tcx>(\n pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n     match intrinsic {\n         \"size_of\" | \"min_align_of\" | \"needs_drop\" | \"caller_location\" |\n+        \"size_of_val\" | \"min_align_of_val\" |\n         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n         \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" |\n         \"saturating_add\" | \"saturating_sub\" |\n         \"rotate_left\" | \"rotate_right\" |\n         \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" | \"bitreverse\" |\n+        \"discriminant_value\" | \"type_id\" | \"likely\" | \"unlikely\" |\n         \"minnumf32\" | \"minnumf64\" | \"maxnumf32\" | \"maxnumf64\" | \"type_name\"\n         => hir::Unsafety::Normal,\n         _ => hir::Unsafety::Unsafe,"}, {"sha": "32d2d40241c8222becc670a21099cab67622f2a1", "filename": "src/test/ui/enum-discriminant/discriminant_value.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_value.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -51,34 +51,31 @@ enum Mixed {\n }\n \n pub fn main() {\n-    unsafe {\n+    assert_eq!(discriminant_value(&CLike1::A), 0);\n+    assert_eq!(discriminant_value(&CLike1::B), 1);\n+    assert_eq!(discriminant_value(&CLike1::C), 2);\n+    assert_eq!(discriminant_value(&CLike1::D), 3);\n \n-        assert_eq!(discriminant_value(&CLike1::A), 0);\n-        assert_eq!(discriminant_value(&CLike1::B), 1);\n-        assert_eq!(discriminant_value(&CLike1::C), 2);\n-        assert_eq!(discriminant_value(&CLike1::D), 3);\n+    assert_eq!(discriminant_value(&CLike2::A), 5);\n+    assert_eq!(discriminant_value(&CLike2::B), 2);\n+    assert_eq!(discriminant_value(&CLike2::C), 19);\n+    assert_eq!(discriminant_value(&CLike2::D), 20);\n \n-        assert_eq!(discriminant_value(&CLike2::A), 5);\n-        assert_eq!(discriminant_value(&CLike2::B), 2);\n-        assert_eq!(discriminant_value(&CLike2::C), 19);\n-        assert_eq!(discriminant_value(&CLike2::D), 20);\n+    assert_eq!(discriminant_value(&CLike3::A), 5);\n+    assert_eq!(discriminant_value(&CLike3::B), 6);\n+    assert_eq!(discriminant_value(&CLike3::C), -1_i8 as u64);\n+    assert_eq!(discriminant_value(&CLike3::D), 0);\n \n-        assert_eq!(discriminant_value(&CLike3::A), 5);\n-        assert_eq!(discriminant_value(&CLike3::B), 6);\n-        assert_eq!(discriminant_value(&CLike3::C), -1_i8 as u64);\n-        assert_eq!(discriminant_value(&CLike3::D), 0);\n+    assert_eq!(discriminant_value(&ADT::First(0,0)), 0);\n+    assert_eq!(discriminant_value(&ADT::Second(5)), 1);\n \n-        assert_eq!(discriminant_value(&ADT::First(0,0)), 0);\n-        assert_eq!(discriminant_value(&ADT::Second(5)), 1);\n+    assert_eq!(discriminant_value(&NullablePointer::Nothing), 1);\n+    assert_eq!(discriminant_value(&NullablePointer::Something(&CONST)), 0);\n \n-        assert_eq!(discriminant_value(&NullablePointer::Nothing), 1);\n-        assert_eq!(discriminant_value(&NullablePointer::Something(&CONST)), 0);\n+    assert_eq!(discriminant_value(&10), 0);\n+    assert_eq!(discriminant_value(&\"test\"), 0);\n \n-        assert_eq!(discriminant_value(&10), 0);\n-        assert_eq!(discriminant_value(&\"test\"), 0);\n-\n-        assert_eq!(3, discriminant_value(&Mixed::Unit));\n-        assert_eq!(2, discriminant_value(&Mixed::Tuple(5)));\n-        assert_eq!(1, discriminant_value(&Mixed::Struct{a: 7, b: 11}));\n-    }\n+    assert_eq!(3, discriminant_value(&Mixed::Unit));\n+    assert_eq!(2, discriminant_value(&Mixed::Tuple(5)));\n+    assert_eq!(1, discriminant_value(&Mixed::Struct{a: 7, b: 11}));\n }"}, {"sha": "f0b762c6254a38b5b0532556bda78b78118a201b", "filename": "src/test/ui/issues/issue-43398.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Ftest%2Fui%2Fissues%2Fissue-43398.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Ftest%2Fui%2Fissues%2Fissue-43398.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43398.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -7,9 +7,7 @@\n enum Big { A, B }\n \n fn main() {\n-    unsafe {\n-        println!(\"{} {:?}\",\n-            std::intrinsics::discriminant_value(&Big::A),\n-            std::mem::discriminant(&Big::B));\n-    }\n+    println!(\"{} {:?}\",\n+        std::intrinsics::discriminant_value(&Big::A),\n+        std::mem::discriminant(&Big::B));\n }"}, {"sha": "40a70c623a741bf6f6f55767dab8f5843565ce3d", "filename": "src/test/ui/issues/issue-51582.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Ftest%2Fui%2Fissues%2Fissue-51582.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Ftest%2Fui%2Fissues%2Fissue-51582.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51582.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -14,5 +14,5 @@ fn main() {\n     assert_eq!(1, make_b() as u8);\n     assert_eq!(1, make_b() as i32);\n     assert_eq!(1, make_b() as u32);\n-    assert_eq!(1, unsafe { std::intrinsics::discriminant_value(&make_b()) });\n+    assert_eq!(1, std::intrinsics::discriminant_value(&make_b()));\n }"}, {"sha": "5abe481368df53f2832947736942558a15e1fe23", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379b19c17f6fb9eda810222671ba9046e375e7ec/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=379b19c17f6fb9eda810222671ba9046e375e7ec", "patch": "@@ -160,6 +160,8 @@ pub fn check(path: &Path, bad: &mut bool) {\n         let can_contain = contents.contains(\"// ignore-tidy-\") ||\n             contents.contains(\"# ignore-tidy-\");\n         let mut skip_cr = contains_ignore_directive(can_contain, &contents, \"cr\");\n+        let mut skip_undocumented_unsafe =\n+            contains_ignore_directive(can_contain, &contents, \"undocumented-unsafe\");\n         let mut skip_tab = contains_ignore_directive(can_contain, &contents, \"tab\");\n         let mut skip_line_length = contains_ignore_directive(can_contain, &contents, \"linelength\");\n         let mut skip_file_length = contains_ignore_directive(can_contain, &contents, \"filelength\");\n@@ -171,6 +173,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n         let mut leading_new_lines = false;\n         let mut trailing_new_lines = 0;\n         let mut lines = 0;\n+        let mut last_safety_comment = false;\n         for (i, line) in contents.split('\\n').enumerate() {\n             let mut err = |msg: &str| {\n                 tidy_error!(bad, \"{}:{}: {}\", file.display(), i + 1, msg);\n@@ -200,6 +203,20 @@ pub fn check(path: &Path, bad: &mut bool) {\n                     err(\"XXX is deprecated; use FIXME\")\n                 }\n             }\n+            let is_test = || file.components().any(|c| c.as_os_str() == \"tests\");\n+            // for now we just check libcore\n+            if line.contains(\"unsafe {\") && !line.trim().starts_with(\"//\") && !last_safety_comment {\n+                if file.components().any(|c| c.as_os_str() == \"libcore\") && !is_test() {\n+                    suppressible_tidy_err!(err, skip_undocumented_unsafe, \"undocumented unsafe\");\n+                }\n+            }\n+            if line.contains(\"// SAFETY: \") || line.contains(\"// Safety: \") {\n+                last_safety_comment = true;\n+            } else if line.trim().starts_with(\"//\") || line.trim().is_empty() {\n+                // keep previous value\n+            } else {\n+                last_safety_comment = false;\n+            }\n             if (line.starts_with(\"// Copyright\") ||\n                 line.starts_with(\"# Copyright\") ||\n                 line.starts_with(\"Copyright\"))"}]}