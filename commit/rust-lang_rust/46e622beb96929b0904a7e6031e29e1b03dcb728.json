{"sha": "46e622beb96929b0904a7e6031e29e1b03dcb728", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZTYyMmJlYjk2OTI5YjA5MDRhN2U2MDMxZTI5ZTFiMDNkY2I3Mjg=", "commit": {"author": {"name": "chansuke", "email": "chansuke@georepublic.de", "date": "2019-06-05T18:33:39Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-16T11:17:01Z"}, "message": "Separate librustcdoc module", "tree": {"sha": "222f951673d5f9d80b3fe4a95fb7d67f8dbd3804", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/222f951673d5f9d80b3fe4a95fb7d67f8dbd3804"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46e622beb96929b0904a7e6031e29e1b03dcb728", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46e622beb96929b0904a7e6031e29e1b03dcb728", "html_url": "https://github.com/rust-lang/rust/commit/46e622beb96929b0904a7e6031e29e1b03dcb728", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46e622beb96929b0904a7e6031e29e1b03dcb728/comments", "author": null, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "638f63b6e40c38441aa191c91e8532bcc40c7b69", "url": "https://api.github.com/repos/rust-lang/rust/commits/638f63b6e40c38441aa191c91e8532bcc40c7b69", "html_url": "https://github.com/rust-lang/rust/commit/638f63b6e40c38441aa191c91e8532bcc40c7b69"}], "stats": {"total": 1017, "additions": 507, "deletions": 510}, "files": [{"sha": "c9f76bd5096052996d10460e8b6aaac80ecc3d36", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 127, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/46e622beb96929b0904a7e6031e29e1b03dcb728/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46e622beb96929b0904a7e6031e29e1b03dcb728/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=46e622beb96929b0904a7e6031e29e1b03dcb728", "patch": "@@ -1050,130 +1050,4 @@ fn test_unique_id() {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::{ErrorCodes, LangString, Markdown, MarkdownHtml, IdMap};\n-    use super::plain_summary_line;\n-    use std::cell::RefCell;\n-    use syntax::edition::{Edition, DEFAULT_EDITION};\n-\n-    #[test]\n-    fn test_lang_string_parse() {\n-        fn t(s: &str,\n-            should_panic: bool, no_run: bool, ignore: bool, rust: bool, test_harness: bool,\n-            compile_fail: bool, allow_fail: bool, error_codes: Vec<String>,\n-             edition: Option<Edition>) {\n-            assert_eq!(LangString::parse(s, ErrorCodes::Yes), LangString {\n-                should_panic,\n-                no_run,\n-                ignore,\n-                rust,\n-                test_harness,\n-                compile_fail,\n-                error_codes,\n-                original: s.to_owned(),\n-                allow_fail,\n-                edition,\n-            })\n-        }\n-\n-        fn v() -> Vec<String> {\n-            Vec::new()\n-        }\n-\n-        // ignore-tidy-linelength\n-        // marker                | should_panic | no_run | ignore | rust | test_harness\n-        //                       | compile_fail | allow_fail | error_codes | edition\n-        t(\"\",                      false,         false,   false,   true,  false, false, false, v(), None);\n-        t(\"rust\",                  false,         false,   false,   true,  false, false, false, v(), None);\n-        t(\"sh\",                    false,         false,   false,   false, false, false, false, v(), None);\n-        t(\"ignore\",                false,         false,   true,    true,  false, false, false, v(), None);\n-        t(\"should_panic\",          true,          false,   false,   true,  false, false, false, v(), None);\n-        t(\"no_run\",                false,         true,    false,   true,  false, false, false, v(), None);\n-        t(\"test_harness\",          false,         false,   false,   true,  true,  false, false, v(), None);\n-        t(\"compile_fail\",          false,         true,    false,   true,  false, true,  false, v(), None);\n-        t(\"allow_fail\",            false,         false,   false,   true,  false, false, true,  v(), None);\n-        t(\"{.no_run .example}\",    false,         true,    false,   true,  false, false, false, v(), None);\n-        t(\"{.sh .should_panic}\",   true,          false,   false,   false, false, false, false, v(), None);\n-        t(\"{.example .rust}\",      false,         false,   false,   true,  false, false, false, v(), None);\n-        t(\"{.test_harness .rust}\", false,         false,   false,   true,  true,  false, false, v(), None);\n-        t(\"text, no_run\",          false,         true,    false,   false, false, false, false, v(), None);\n-        t(\"text,no_run\",           false,         true,    false,   false, false, false, false, v(), None);\n-        t(\"edition2015\",           false,         false,   false,   true,  false, false, false, v(), Some(Edition::Edition2015));\n-        t(\"edition2018\",           false,         false,   false,   true,  false, false, false, v(), Some(Edition::Edition2018));\n-    }\n-\n-    #[test]\n-    fn test_header() {\n-        fn t(input: &str, expect: &str) {\n-            let mut map = IdMap::new();\n-            let output = Markdown(input, &[], RefCell::new(&mut map),\n-                                  ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n-            assert_eq!(output, expect, \"original: {}\", input);\n-        }\n-\n-        t(\"# Foo bar\", \"<h1 id=\\\"foo-bar\\\" class=\\\"section-header\\\">\\\n-          <a href=\\\"#foo-bar\\\">Foo bar</a></h1>\");\n-        t(\"## Foo-bar_baz qux\", \"<h2 id=\\\"foo-bar_baz-qux\\\" class=\\\"section-\\\n-          header\\\"><a href=\\\"#foo-bar_baz-qux\\\">Foo-bar_baz qux</a></h2>\");\n-        t(\"### **Foo** *bar* baz!?!& -_qux_-%\",\n-          \"<h3 id=\\\"foo-bar-baz--qux-\\\" class=\\\"section-header\\\">\\\n-          <a href=\\\"#foo-bar-baz--qux-\\\"><strong>Foo</strong> \\\n-          <em>bar</em> baz!?!&amp; -<em>qux</em>-%</a></h3>\");\n-        t(\"#### **Foo?** & \\\\*bar?!*  _`baz`_ \u2764 #qux\",\n-          \"<h4 id=\\\"foo--bar--baz--qux\\\" class=\\\"section-header\\\">\\\n-          <a href=\\\"#foo--bar--baz--qux\\\"><strong>Foo?</strong> &amp; *bar?!*  \\\n-          <em><code>baz</code></em> \u2764 #qux</a></h4>\");\n-    }\n-\n-    #[test]\n-    fn test_header_ids_multiple_blocks() {\n-        let mut map = IdMap::new();\n-        fn t(map: &mut IdMap, input: &str, expect: &str) {\n-            let output = Markdown(input, &[], RefCell::new(map),\n-                                  ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n-            assert_eq!(output, expect, \"original: {}\", input);\n-        }\n-\n-        t(&mut map, \"# Example\", \"<h1 id=\\\"example\\\" class=\\\"section-header\\\">\\\n-            <a href=\\\"#example\\\">Example</a></h1>\");\n-        t(&mut map, \"# Panics\", \"<h1 id=\\\"panics\\\" class=\\\"section-header\\\">\\\n-            <a href=\\\"#panics\\\">Panics</a></h1>\");\n-        t(&mut map, \"# Example\", \"<h1 id=\\\"example-1\\\" class=\\\"section-header\\\">\\\n-            <a href=\\\"#example-1\\\">Example</a></h1>\");\n-        t(&mut map, \"# Main\", \"<h1 id=\\\"main\\\" class=\\\"section-header\\\">\\\n-            <a href=\\\"#main\\\">Main</a></h1>\");\n-        t(&mut map, \"# Example\", \"<h1 id=\\\"example-2\\\" class=\\\"section-header\\\">\\\n-            <a href=\\\"#example-2\\\">Example</a></h1>\");\n-        t(&mut map, \"# Panics\", \"<h1 id=\\\"panics-1\\\" class=\\\"section-header\\\">\\\n-            <a href=\\\"#panics-1\\\">Panics</a></h1>\");\n-    }\n-\n-    #[test]\n-    fn test_plain_summary_line() {\n-        fn t(input: &str, expect: &str) {\n-            let output = plain_summary_line(input);\n-            assert_eq!(output, expect, \"original: {}\", input);\n-        }\n-\n-        t(\"hello [Rust](https://www.rust-lang.org) :)\", \"hello Rust :)\");\n-        t(\"hello [Rust](https://www.rust-lang.org \\\"Rust\\\") :)\", \"hello Rust :)\");\n-        t(\"code `let x = i32;` ...\", \"code `let x = i32;` ...\");\n-        t(\"type `Type<'static>` ...\", \"type `Type<'static>` ...\");\n-        t(\"# top header\", \"top header\");\n-        t(\"## header\", \"header\");\n-    }\n-\n-    #[test]\n-    fn test_markdown_html_escape() {\n-        fn t(input: &str, expect: &str) {\n-            let mut idmap = IdMap::new();\n-            let output = MarkdownHtml(input, RefCell::new(&mut idmap),\n-                                      ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n-            assert_eq!(output, expect, \"original: {}\", input);\n-        }\n-\n-        t(\"`Struct<'a, T>`\", \"<p><code>Struct&lt;'a, T&gt;</code></p>\\n\");\n-        t(\"Struct<'a, T>\", \"<p>Struct&lt;'a, T&gt;</p>\\n\");\n-        t(\"Struct<br>\", \"<p>Struct&lt;br&gt;</p>\\n\");\n-    }\n-}\n+mod tests;"}, {"sha": "f470e649d82656e11a96e755dbab822ae7022805", "filename": "src/librustdoc/html/markdown/tests.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/46e622beb96929b0904a7e6031e29e1b03dcb728/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46e622beb96929b0904a7e6031e29e1b03dcb728/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs?ref=46e622beb96929b0904a7e6031e29e1b03dcb728", "patch": "@@ -0,0 +1,125 @@\n+use super::{ErrorCodes, LangString, Markdown, MarkdownHtml, IdMap};\n+use super::plain_summary_line;\n+use std::cell::RefCell;\n+use syntax::edition::{Edition, DEFAULT_EDITION};\n+\n+#[test]\n+fn test_lang_string_parse() {\n+    fn t(s: &str,\n+        should_panic: bool, no_run: bool, ignore: bool, rust: bool, test_harness: bool,\n+        compile_fail: bool, allow_fail: bool, error_codes: Vec<String>,\n+         edition: Option<Edition>) {\n+        assert_eq!(LangString::parse(s, ErrorCodes::Yes), LangString {\n+            should_panic,\n+            no_run,\n+            ignore,\n+            rust,\n+            test_harness,\n+            compile_fail,\n+            error_codes,\n+            original: s.to_owned(),\n+            allow_fail,\n+            edition,\n+        })\n+    }\n+\n+    fn v() -> Vec<String> {\n+        Vec::new()\n+    }\n+\n+    // ignore-tidy-linelength\n+    // marker                | should_panic | no_run | ignore | rust | test_harness\n+    //                       | compile_fail | allow_fail | error_codes | edition\n+    t(\"\",                      false,         false,   false,   true,  false, false, false, v(), None);\n+    t(\"rust\",                  false,         false,   false,   true,  false, false, false, v(), None);\n+    t(\"sh\",                    false,         false,   false,   false, false, false, false, v(), None);\n+    t(\"ignore\",                false,         false,   true,    true,  false, false, false, v(), None);\n+    t(\"should_panic\",          true,          false,   false,   true,  false, false, false, v(), None);\n+    t(\"no_run\",                false,         true,    false,   true,  false, false, false, v(), None);\n+    t(\"test_harness\",          false,         false,   false,   true,  true,  false, false, v(), None);\n+    t(\"compile_fail\",          false,         true,    false,   true,  false, true,  false, v(), None);\n+    t(\"allow_fail\",            false,         false,   false,   true,  false, false, true,  v(), None);\n+    t(\"{.no_run .example}\",    false,         true,    false,   true,  false, false, false, v(), None);\n+    t(\"{.sh .should_panic}\",   true,          false,   false,   false, false, false, false, v(), None);\n+    t(\"{.example .rust}\",      false,         false,   false,   true,  false, false, false, v(), None);\n+    t(\"{.test_harness .rust}\", false,         false,   false,   true,  true,  false, false, v(), None);\n+    t(\"text, no_run\",          false,         true,    false,   false, false, false, false, v(), None);\n+    t(\"text,no_run\",           false,         true,    false,   false, false, false, false, v(), None);\n+    t(\"edition2015\",           false,         false,   false,   true,  false, false, false, v(), Some(Edition::Edition2015));\n+    t(\"edition2018\",           false,         false,   false,   true,  false, false, false, v(), Some(Edition::Edition2018));\n+}\n+\n+#[test]\n+fn test_header() {\n+    fn t(input: &str, expect: &str) {\n+        let mut map = IdMap::new();\n+        let output = Markdown(input, &[], RefCell::new(&mut map),\n+                              ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n+        assert_eq!(output, expect, \"original: {}\", input);\n+    }\n+\n+    t(\"# Foo bar\", \"<h1 id=\\\"foo-bar\\\" class=\\\"section-header\\\">\\\n+      <a href=\\\"#foo-bar\\\">Foo bar</a></h1>\");\n+    t(\"## Foo-bar_baz qux\", \"<h2 id=\\\"foo-bar_baz-qux\\\" class=\\\"section-\\\n+      header\\\"><a href=\\\"#foo-bar_baz-qux\\\">Foo-bar_baz qux</a></h2>\");\n+    t(\"### **Foo** *bar* baz!?!& -_qux_-%\",\n+      \"<h3 id=\\\"foo-bar-baz--qux-\\\" class=\\\"section-header\\\">\\\n+      <a href=\\\"#foo-bar-baz--qux-\\\"><strong>Foo</strong> \\\n+      <em>bar</em> baz!?!&amp; -<em>qux</em>-%</a></h3>\");\n+    t(\"#### **Foo?** & \\\\*bar?!*  _`baz`_ \u2764 #qux\",\n+      \"<h4 id=\\\"foo--bar--baz--qux\\\" class=\\\"section-header\\\">\\\n+      <a href=\\\"#foo--bar--baz--qux\\\"><strong>Foo?</strong> &amp; *bar?!*  \\\n+      <em><code>baz</code></em> \u2764 #qux</a></h4>\");\n+}\n+\n+#[test]\n+fn test_header_ids_multiple_blocks() {\n+    let mut map = IdMap::new();\n+    fn t(map: &mut IdMap, input: &str, expect: &str) {\n+        let output = Markdown(input, &[], RefCell::new(map),\n+                              ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n+        assert_eq!(output, expect, \"original: {}\", input);\n+    }\n+\n+    t(&mut map, \"# Example\", \"<h1 id=\\\"example\\\" class=\\\"section-header\\\">\\\n+        <a href=\\\"#example\\\">Example</a></h1>\");\n+    t(&mut map, \"# Panics\", \"<h1 id=\\\"panics\\\" class=\\\"section-header\\\">\\\n+        <a href=\\\"#panics\\\">Panics</a></h1>\");\n+    t(&mut map, \"# Example\", \"<h1 id=\\\"example-1\\\" class=\\\"section-header\\\">\\\n+        <a href=\\\"#example-1\\\">Example</a></h1>\");\n+    t(&mut map, \"# Main\", \"<h1 id=\\\"main\\\" class=\\\"section-header\\\">\\\n+        <a href=\\\"#main\\\">Main</a></h1>\");\n+    t(&mut map, \"# Example\", \"<h1 id=\\\"example-2\\\" class=\\\"section-header\\\">\\\n+        <a href=\\\"#example-2\\\">Example</a></h1>\");\n+    t(&mut map, \"# Panics\", \"<h1 id=\\\"panics-1\\\" class=\\\"section-header\\\">\\\n+        <a href=\\\"#panics-1\\\">Panics</a></h1>\");\n+}\n+\n+#[test]\n+fn test_plain_summary_line() {\n+    fn t(input: &str, expect: &str) {\n+        let output = plain_summary_line(input);\n+        assert_eq!(output, expect, \"original: {}\", input);\n+    }\n+\n+    t(\"hello [Rust](https://www.rust-lang.org) :)\", \"hello Rust :)\");\n+    t(\"hello [Rust](https://www.rust-lang.org \\\"Rust\\\") :)\", \"hello Rust :)\");\n+    t(\"code `let x = i32;` ...\", \"code `let x = i32;` ...\");\n+    t(\"type `Type<'static>` ...\", \"type `Type<'static>` ...\");\n+    t(\"# top header\", \"top header\");\n+    t(\"## header\", \"header\");\n+}\n+\n+#[test]\n+fn test_markdown_html_escape() {\n+    fn t(input: &str, expect: &str) {\n+        let mut idmap = IdMap::new();\n+        let output = MarkdownHtml(input, RefCell::new(&mut idmap),\n+                                  ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n+        assert_eq!(output, expect, \"original: {}\", input);\n+    }\n+\n+    t(\"`Struct<'a, T>`\", \"<p><code>Struct&lt;'a, T&gt;</code></p>\\n\");\n+    t(\"Struct<'a, T>\", \"<p>Struct&lt;'a, T&gt;</p>\\n\");\n+    t(\"Struct<br>\", \"<p>Struct&lt;br&gt;</p>\\n\");\n+}"}, {"sha": "2564c611e54e59ebc25de0698cf1aab91b08b686", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 1, "deletions": 82, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/46e622beb96929b0904a7e6031e29e1b03dcb728/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46e622beb96929b0904a7e6031e29e1b03dcb728/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=46e622beb96929b0904a7e6031e29e1b03dcb728", "patch": "@@ -188,85 +188,4 @@ impl fmt::Display for Toc {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::{TocBuilder, Toc, TocEntry};\n-\n-    #[test]\n-    fn builder_smoke() {\n-        let mut builder = TocBuilder::new();\n-\n-        // this is purposely not using a fancy macro like below so\n-        // that we're sure that this is doing the correct thing, and\n-        // there's been no macro mistake.\n-        macro_rules! push {\n-            ($level: expr, $name: expr) => {\n-                assert_eq!(builder.push($level,\n-                                        $name.to_string(),\n-                                        \"\".to_string()),\n-                           $name);\n-            }\n-        }\n-        push!(2, \"0.1\");\n-        push!(1, \"1\");\n-        {\n-            push!(2, \"1.1\");\n-            {\n-                push!(3, \"1.1.1\");\n-                push!(3, \"1.1.2\");\n-            }\n-            push!(2, \"1.2\");\n-            {\n-                push!(3, \"1.2.1\");\n-                push!(3, \"1.2.2\");\n-            }\n-        }\n-        push!(1, \"2\");\n-        push!(1, \"3\");\n-        {\n-            push!(4, \"3.0.0.1\");\n-            {\n-                push!(6, \"3.0.0.1.0.1\");\n-            }\n-            push!(4, \"3.0.0.2\");\n-            push!(2, \"3.1\");\n-            {\n-                push!(4, \"3.1.0.1\");\n-            }\n-        }\n-\n-        macro_rules! toc {\n-            ($(($level: expr, $name: expr, $(($sub: tt))* )),*) => {\n-                Toc {\n-                    entries: vec![\n-                        $(\n-                            TocEntry {\n-                                level: $level,\n-                                name: $name.to_string(),\n-                                sec_number: $name.to_string(),\n-                                id: \"\".to_string(),\n-                                children: toc!($($sub),*)\n-                            }\n-                            ),*\n-                        ]\n-                }\n-            }\n-        }\n-        let expected = toc!(\n-            (2, \"0.1\", ),\n-\n-            (1, \"1\",\n-             ((2, \"1.1\", ((3, \"1.1.1\", )) ((3, \"1.1.2\", ))))\n-             ((2, \"1.2\", ((3, \"1.2.1\", )) ((3, \"1.2.2\", ))))\n-             ),\n-\n-            (1, \"2\", ),\n-\n-            (1, \"3\",\n-             ((4, \"3.0.0.1\", ((6, \"3.0.0.1.0.1\", ))))\n-             ((4, \"3.0.0.2\", ))\n-             ((2, \"3.1\", ((4, \"3.1.0.1\", ))))\n-             )\n-            );\n-        assert_eq!(expected, builder.into_toc());\n-    }\n-}\n+mod tests;"}, {"sha": "ef69ada4664962839c5fc8327a9de7712d2dcc89", "filename": "src/librustdoc/html/toc/tests.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/46e622beb96929b0904a7e6031e29e1b03dcb728/src%2Flibrustdoc%2Fhtml%2Ftoc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46e622beb96929b0904a7e6031e29e1b03dcb728/src%2Flibrustdoc%2Fhtml%2Ftoc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc%2Ftests.rs?ref=46e622beb96929b0904a7e6031e29e1b03dcb728", "patch": "@@ -0,0 +1,80 @@\n+use super::{TocBuilder, Toc, TocEntry};\n+\n+#[test]\n+fn builder_smoke() {\n+    let mut builder = TocBuilder::new();\n+\n+    // this is purposely not using a fancy macro like below so\n+    // that we're sure that this is doing the correct thing, and\n+    // there's been no macro mistake.\n+    macro_rules! push {\n+        ($level: expr, $name: expr) => {\n+            assert_eq!(builder.push($level,\n+                                    $name.to_string(),\n+                                    \"\".to_string()),\n+                       $name);\n+        }\n+    }\n+    push!(2, \"0.1\");\n+    push!(1, \"1\");\n+    {\n+        push!(2, \"1.1\");\n+        {\n+            push!(3, \"1.1.1\");\n+            push!(3, \"1.1.2\");\n+        }\n+        push!(2, \"1.2\");\n+        {\n+            push!(3, \"1.2.1\");\n+            push!(3, \"1.2.2\");\n+        }\n+    }\n+    push!(1, \"2\");\n+    push!(1, \"3\");\n+    {\n+        push!(4, \"3.0.0.1\");\n+        {\n+            push!(6, \"3.0.0.1.0.1\");\n+        }\n+        push!(4, \"3.0.0.2\");\n+        push!(2, \"3.1\");\n+        {\n+            push!(4, \"3.1.0.1\");\n+        }\n+    }\n+\n+    macro_rules! toc {\n+        ($(($level: expr, $name: expr, $(($sub: tt))* )),*) => {\n+            Toc {\n+                entries: vec![\n+                    $(\n+                        TocEntry {\n+                            level: $level,\n+                            name: $name.to_string(),\n+                            sec_number: $name.to_string(),\n+                            id: \"\".to_string(),\n+                            children: toc!($($sub),*)\n+                        }\n+                        ),*\n+                    ]\n+            }\n+        }\n+    }\n+    let expected = toc!(\n+        (2, \"0.1\", ),\n+\n+        (1, \"1\",\n+         ((2, \"1.1\", ((3, \"1.1.1\", )) ((3, \"1.1.2\", ))))\n+         ((2, \"1.2\", ((3, \"1.2.1\", )) ((3, \"1.2.2\", ))))\n+         ),\n+\n+        (1, \"2\", ),\n+\n+        (1, \"3\",\n+         ((4, \"3.0.0.1\", ((6, \"3.0.0.1.0.1\", ))))\n+         ((4, \"3.0.0.2\", ))\n+         ((2, \"3.1\", ((4, \"3.1.0.1\", ))))\n+         )\n+        );\n+    assert_eq!(expected, builder.into_toc());\n+}"}, {"sha": "9a9fd941240bcfc515270a44183a1a95992f7927", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 301, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/46e622beb96929b0904a7e6031e29e1b03dcb728/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46e622beb96929b0904a7e6031e29e1b03dcb728/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=46e622beb96929b0904a7e6031e29e1b03dcb728", "patch": "@@ -975,304 +975,4 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::{TestOptions, make_test};\n-    use syntax::edition::DEFAULT_EDITION;\n-\n-    #[test]\n-    fn make_test_basic() {\n-        //basic use: wraps with `fn main`, adds `#![allow(unused)]`\n-        let opts = TestOptions::default();\n-        let input =\n-\"assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-fn main() {\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_crate_name_no_use() {\n-        // If you give a crate name but *don't* use it within the test, it won't bother inserting\n-        // the `extern crate` statement.\n-        let opts = TestOptions::default();\n-        let input =\n-\"assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-fn main() {\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_crate_name() {\n-        // If you give a crate name and use it within the test, it will insert an `extern crate`\n-        // statement before `fn main`.\n-        let opts = TestOptions::default();\n-        let input =\n-\"use asdf::qwop;\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-extern crate asdf;\n-fn main() {\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 3));\n-    }\n-\n-    #[test]\n-    fn make_test_no_crate_inject() {\n-        // Even if you do use the crate within the test, setting `opts.no_crate_inject` will skip\n-        // adding it anyway.\n-        let opts = TestOptions {\n-            no_crate_inject: true,\n-            display_warnings: false,\n-            attrs: vec![],\n-        };\n-        let input =\n-\"use asdf::qwop;\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-fn main() {\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_ignore_std() {\n-        // Even if you include a crate name, and use it in the doctest, we still won't include an\n-        // `extern crate` statement if the crate is \"std\" -- that's included already by the\n-        // compiler!\n-        let opts = TestOptions::default();\n-        let input =\n-\"use std::*;\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-fn main() {\n-use std::*;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"std\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_manual_extern_crate() {\n-        // When you manually include an `extern crate` statement in your doctest, `make_test`\n-        // assumes you've included one for your own crate too.\n-        let opts = TestOptions::default();\n-        let input =\n-\"extern crate asdf;\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-extern crate asdf;\n-fn main() {\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_manual_extern_crate_with_macro_use() {\n-        let opts = TestOptions::default();\n-        let input =\n-\"#[macro_use] extern crate asdf;\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-#[macro_use] extern crate asdf;\n-fn main() {\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_opts_attrs() {\n-        // If you supplied some doctest attributes with `#![doc(test(attr(...)))]`, it will use\n-        // those instead of the stock `#![allow(unused)]`.\n-        let mut opts = TestOptions::default();\n-        opts.attrs.push(\"feature(sick_rad)\".to_string());\n-        let input =\n-\"use asdf::qwop;\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![feature(sick_rad)]\n-extern crate asdf;\n-fn main() {\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 3));\n-\n-        // Adding more will also bump the returned line offset.\n-        opts.attrs.push(\"feature(hella_dope)\".to_string());\n-        let expected =\n-\"#![feature(sick_rad)]\n-#![feature(hella_dope)]\n-extern crate asdf;\n-fn main() {\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 4));\n-    }\n-\n-    #[test]\n-    fn make_test_crate_attrs() {\n-        // Including inner attributes in your doctest will apply them to the whole \"crate\", pasting\n-        // them outside the generated main function.\n-        let opts = TestOptions::default();\n-        let input =\n-\"#![feature(sick_rad)]\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-#![feature(sick_rad)]\n-fn main() {\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_with_main() {\n-        // Including your own `fn main` wrapper lets the test use it verbatim.\n-        let opts = TestOptions::default();\n-        let input =\n-\"fn main() {\n-    assert_eq!(2+2, 4);\n-}\";\n-        let expected =\n-\"#![allow(unused)]\n-fn main() {\n-    assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 1));\n-    }\n-\n-    #[test]\n-    fn make_test_fake_main() {\n-        // ... but putting it in a comment will still provide a wrapper.\n-        let opts = TestOptions::default();\n-        let input =\n-\"//Ceci n'est pas une `fn main`\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-//Ceci n'est pas une `fn main`\n-fn main() {\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_dont_insert_main() {\n-        // Even with that, if you set `dont_insert_main`, it won't create the `fn main` wrapper.\n-        let opts = TestOptions::default();\n-        let input =\n-\"//Ceci n'est pas une `fn main`\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-//Ceci n'est pas une `fn main`\n-assert_eq!(2+2, 4);\".to_string();\n-        let output = make_test(input, None, true, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 1));\n-    }\n-\n-    #[test]\n-    fn make_test_display_warnings() {\n-        // If the user is asking to display doctest warnings, suppress the default `allow(unused)`.\n-        let mut opts = TestOptions::default();\n-        opts.display_warnings = true;\n-        let input =\n-\"assert_eq!(2+2, 4);\";\n-        let expected =\n-\"fn main() {\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 1));\n-    }\n-\n-    #[test]\n-    fn make_test_issues_21299_33731() {\n-        let opts = TestOptions::default();\n-\n-        let input =\n-\"// fn main\n-assert_eq!(2+2, 4);\";\n-\n-        let expected =\n-\"#![allow(unused)]\n-// fn main\n-fn main() {\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-\n-        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-\n-        let input =\n-\"extern crate hella_qwop;\n-assert_eq!(asdf::foo, 4);\";\n-\n-        let expected =\n-\"#![allow(unused)]\n-extern crate hella_qwop;\n-extern crate asdf;\n-fn main() {\n-assert_eq!(asdf::foo, 4);\n-}\".to_string();\n-\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 3));\n-    }\n-\n-    #[test]\n-    fn make_test_main_in_macro() {\n-        let opts = TestOptions::default();\n-        let input =\n-\"#[macro_use] extern crate my_crate;\n-test_wrapper! {\n-    fn main() {}\n-}\";\n-        let expected =\n-\"#![allow(unused)]\n-#[macro_use] extern crate my_crate;\n-test_wrapper! {\n-    fn main() {}\n-}\".to_string();\n-\n-        let output = make_test(input, Some(\"my_crate\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 1));\n-    }\n-}\n+mod tests;"}, {"sha": "d4d558b7cd78cd997a9edb818d9b034241c48dbd", "filename": "src/librustdoc/test/tests.rs", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/46e622beb96929b0904a7e6031e29e1b03dcb728/src%2Flibrustdoc%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46e622beb96929b0904a7e6031e29e1b03dcb728/src%2Flibrustdoc%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest%2Ftests.rs?ref=46e622beb96929b0904a7e6031e29e1b03dcb728", "patch": "@@ -0,0 +1,299 @@\n+use super::{TestOptions, make_test};\n+use syntax::edition::DEFAULT_EDITION;\n+\n+#[test]\n+fn make_test_basic() {\n+    //basic use: wraps with `fn main`, adds `#![allow(unused)]`\n+    let opts = TestOptions::default();\n+    let input =\n+\"assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+fn main() {\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_crate_name_no_use() {\n+    // If you give a crate name but *don't* use it within the test, it won't bother inserting\n+    // the `extern crate` statement.\n+    let opts = TestOptions::default();\n+    let input =\n+\"assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+fn main() {\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_crate_name() {\n+    // If you give a crate name and use it within the test, it will insert an `extern crate`\n+    // statement before `fn main`.\n+    let opts = TestOptions::default();\n+    let input =\n+\"use asdf::qwop;\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+extern crate asdf;\n+fn main() {\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 3));\n+}\n+\n+#[test]\n+fn make_test_no_crate_inject() {\n+    // Even if you do use the crate within the test, setting `opts.no_crate_inject` will skip\n+    // adding it anyway.\n+    let opts = TestOptions {\n+        no_crate_inject: true,\n+        display_warnings: false,\n+        attrs: vec![],\n+    };\n+    let input =\n+\"use asdf::qwop;\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+fn main() {\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_ignore_std() {\n+    // Even if you include a crate name, and use it in the doctest, we still won't include an\n+    // `extern crate` statement if the crate is \"std\" -- that's included already by the\n+    // compiler!\n+    let opts = TestOptions::default();\n+    let input =\n+\"use std::*;\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+fn main() {\n+use std::*;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"std\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_manual_extern_crate() {\n+    // When you manually include an `extern crate` statement in your doctest, `make_test`\n+    // assumes you've included one for your own crate too.\n+    let opts = TestOptions::default();\n+    let input =\n+\"extern crate asdf;\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+extern crate asdf;\n+fn main() {\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_manual_extern_crate_with_macro_use() {\n+    let opts = TestOptions::default();\n+    let input =\n+\"#[macro_use] extern crate asdf;\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+#[macro_use] extern crate asdf;\n+fn main() {\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_opts_attrs() {\n+    // If you supplied some doctest attributes with `#![doc(test(attr(...)))]`, it will use\n+    // those instead of the stock `#![allow(unused)]`.\n+    let mut opts = TestOptions::default();\n+    opts.attrs.push(\"feature(sick_rad)\".to_string());\n+    let input =\n+\"use asdf::qwop;\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![feature(sick_rad)]\n+extern crate asdf;\n+fn main() {\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 3));\n+\n+    // Adding more will also bump the returned line offset.\n+    opts.attrs.push(\"feature(hella_dope)\".to_string());\n+    let expected =\n+\"#![feature(sick_rad)]\n+#![feature(hella_dope)]\n+extern crate asdf;\n+fn main() {\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 4));\n+}\n+\n+#[test]\n+fn make_test_crate_attrs() {\n+    // Including inner attributes in your doctest will apply them to the whole \"crate\", pasting\n+    // them outside the generated main function.\n+    let opts = TestOptions::default();\n+    let input =\n+\"#![feature(sick_rad)]\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+#![feature(sick_rad)]\n+fn main() {\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_with_main() {\n+    // Including your own `fn main` wrapper lets the test use it verbatim.\n+    let opts = TestOptions::default();\n+    let input =\n+\"fn main() {\n+    assert_eq!(2+2, 4);\n+}\";\n+    let expected =\n+\"#![allow(unused)]\n+fn main() {\n+    assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 1));\n+}\n+\n+#[test]\n+fn make_test_fake_main() {\n+    // ... but putting it in a comment will still provide a wrapper.\n+    let opts = TestOptions::default();\n+    let input =\n+\"//Ceci n'est pas une `fn main`\n+assert_eq!(2+2, 4);\";\n+    let expected =\n+\"#![allow(unused)]\n+//Ceci n'est pas une `fn main`\n+fn main() {\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_dont_insert_main() {\n+    // Even with that, if you set `dont_insert_main`, it won't create the `fn main` wrapper.\n+    let opts = TestOptions::default();\n+    let input =\n+\"//Ceci n'est pas une `fn main`\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+//Ceci n'est pas une `fn main`\n+assert_eq!(2+2, 4);\".to_string();\n+    let output = make_test(input, None, true, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 1));\n+}\n+\n+#[test]\n+fn make_test_display_warnings() {\n+    // If the user is asking to display doctest warnings, suppress the default `allow(unused)`.\n+    let mut opts = TestOptions::default();\n+    opts.display_warnings = true;\n+    let input =\n+\"assert_eq!(2+2, 4);\";\n+        let expected =\n+\"fn main() {\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 1));\n+}\n+\n+#[test]\n+fn make_test_issues_21299_33731() {\n+    let opts = TestOptions::default();\n+\n+    let input =\n+\"// fn main\n+assert_eq!(2+2, 4);\";\n+\n+    let expected =\n+\"#![allow(unused)]\n+// fn main\n+fn main() {\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+\n+    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+\n+    let input =\n+\"extern crate hella_qwop;\n+assert_eq!(asdf::foo, 4);\";\n+\n+    let expected =\n+\"#![allow(unused)]\n+extern crate hella_qwop;\n+extern crate asdf;\n+fn main() {\n+assert_eq!(asdf::foo, 4);\n+}\".to_string();\n+\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 3));\n+}\n+\n+#[test]\n+fn make_test_main_in_macro() {\n+    let opts = TestOptions::default();\n+    let input =\n+\"#[macro_use] extern crate my_crate;\n+test_wrapper! {\n+    fn main() {}\n+}\";\n+    let expected =\n+\"#![allow(unused)]\n+#[macro_use] extern crate my_crate;\n+test_wrapper! {\n+    fn main() {}\n+}\".to_string();\n+\n+    let output = make_test(input, Some(\"my_crate\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 1));\n+}"}]}