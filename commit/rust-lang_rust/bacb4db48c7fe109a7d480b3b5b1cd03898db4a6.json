{"sha": "bacb4db48c7fe109a7d480b3b5b1cd03898db4a6", "node_id": "C_kwDOAAsO6NoAKGJhY2I0ZGI0OGM3ZmUxMDlhN2Q0ODBiM2I1YjFjZDAzODk4ZGI0YTY", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-07T10:27:38Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-07T10:27:38Z"}, "message": "Only encode position from start of file.", "tree": {"sha": "b54ca24169d09be8a1c439bbe331903f30a99571", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b54ca24169d09be8a1c439bbe331903f30a99571"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bacb4db48c7fe109a7d480b3b5b1cd03898db4a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bacb4db48c7fe109a7d480b3b5b1cd03898db4a6", "html_url": "https://github.com/rust-lang/rust/commit/bacb4db48c7fe109a7d480b3b5b1cd03898db4a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bacb4db48c7fe109a7d480b3b5b1cd03898db4a6/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16ba778c12e3303ab4d334c1c3dbfa5173248a80", "url": "https://api.github.com/repos/rust-lang/rust/commits/16ba778c12e3303ab4d334c1c3dbfa5173248a80", "html_url": "https://github.com/rust-lang/rust/commit/16ba778c12e3303ab4d334c1c3dbfa5173248a80"}], "stats": {"total": 52, "additions": 22, "deletions": 30}, "files": [{"sha": "4b2dcc7a70bc4de3812f3f938309a0eef39b2889", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bacb4db48c7fe109a7d480b3b5b1cd03898db4a6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb4db48c7fe109a7d480b3b5b1cd03898db4a6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=bacb4db48c7fe109a7d480b3b5b1cd03898db4a6", "patch": "@@ -581,28 +581,26 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n             foreign_data.imported_source_file(metadata_index, sess)\n         };\n \n-        // Make sure our binary search above is correct.\n+        // Make sure our span is well-formed.\n         debug_assert!(\n-            lo >= source_file.original_start_pos && lo <= source_file.original_end_pos,\n-            \"Bad binary search: lo={:?} source_file.original_start_pos={:?} source_file.original_end_pos={:?}\",\n+            lo + source_file.original_start_pos <= source_file.original_end_pos,\n+            \"Malformed encoded span: lo={:?} source_file.original_start_pos={:?} source_file.original_end_pos={:?}\",\n             lo,\n             source_file.original_start_pos,\n             source_file.original_end_pos\n         );\n \n-        // Make sure we correctly filtered out invalid spans during encoding\n+        // Make sure we correctly filtered out invalid spans during encoding.\n         debug_assert!(\n-            hi >= source_file.original_start_pos && hi <= source_file.original_end_pos,\n-            \"Bad binary search: hi={:?} source_file.original_start_pos={:?} source_file.original_end_pos={:?}\",\n+            hi + source_file.original_start_pos <= source_file.original_end_pos,\n+            \"Malformed encoded span: hi={:?} source_file.original_start_pos={:?} source_file.original_end_pos={:?}\",\n             hi,\n             source_file.original_start_pos,\n             source_file.original_end_pos\n         );\n \n-        let lo =\n-            (lo + source_file.translated_source_file.start_pos) - source_file.original_start_pos;\n-        let hi =\n-            (hi + source_file.translated_source_file.start_pos) - source_file.original_start_pos;\n+        let lo = lo + source_file.translated_source_file.start_pos;\n+        let hi = hi + source_file.translated_source_file.start_pos;\n \n         // Do not try to decode parent for foreign spans.\n         Span::new(lo, hi, ctxt, None)"}, {"sha": "6b3118e71527c33cf14233a00f12d2dc69abbf84", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bacb4db48c7fe109a7d480b3b5b1cd03898db4a6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb4db48c7fe109a7d480b3b5b1cd03898db4a6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=bacb4db48c7fe109a7d480b3b5b1cd03898db4a6", "patch": "@@ -235,16 +235,14 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n                 (source_map.files()[source_file_index].clone(), source_file_index);\n         }\n         let (ref source_file, source_file_index) = s.source_file_cache;\n+        debug_assert!(source_file.contains(span.lo));\n \n         if !source_file.contains(span.hi) {\n             // Unfortunately, macro expansion still sometimes generates Spans\n             // that malformed in this way.\n             return TAG_PARTIAL_SPAN.encode(s);\n         }\n \n-        // Length is independent of the span provenance.\n-        let len = span.hi - span.lo;\n-\n         // There are two possible cases here:\n         // 1. This span comes from a 'foreign' crate - e.g. some crate upstream of the\n         // crate we are writing metadata for. When the metadata for *this* crate gets\n@@ -261,7 +259,7 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n         // if we're a proc-macro crate.\n         // This allows us to avoid loading the dependencies of proc-macro crates: all of\n         // the information we need to decode `Span`s is stored in the proc-macro crate.\n-        let (tag, lo, metadata_index) = if source_file.is_imported() && !s.is_proc_macro {\n+        let (tag, metadata_index) = if source_file.is_imported() && !s.is_proc_macro {\n             // To simplify deserialization, we 'rebase' this span onto the crate it originally came from\n             // (the crate that 'owns' the file it references. These rebased 'lo' and 'hi' values\n             // are relative to the source map information for the 'foreign' crate whose CrateNum\n@@ -271,18 +269,15 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n             //\n             // All of this logic ensures that the final result of deserialization is a 'normal'\n             // Span that can be used without any additional trouble.\n-            let (external_start_pos, metadata_index) = {\n+            let metadata_index = {\n                 // Introduce a new scope so that we drop the 'lock()' temporary\n                 match &*source_file.external_src.lock() {\n-                    ExternalSource::Foreign { original_start_pos, metadata_index, .. } => {\n-                        (*original_start_pos, *metadata_index)\n-                    }\n+                    ExternalSource::Foreign { metadata_index, .. } => *metadata_index,\n                     src => panic!(\"Unexpected external source {:?}\", src),\n                 }\n             };\n-            let lo = (span.lo - source_file.start_pos) + external_start_pos;\n \n-            (TAG_VALID_SPAN_FOREIGN, lo, metadata_index)\n+            (TAG_VALID_SPAN_FOREIGN, metadata_index)\n         } else {\n             // Record the fact that we need to encode the data for this `SourceFile`\n             let source_files =\n@@ -291,14 +286,19 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n             let metadata_index: u32 =\n                 metadata_index.try_into().expect(\"cannot export more than U32_MAX files\");\n \n-            (TAG_VALID_SPAN_LOCAL, span.lo, metadata_index)\n+            (TAG_VALID_SPAN_LOCAL, metadata_index)\n         };\n \n-        tag.encode(s);\n-        lo.encode(s);\n+        // Encode the start position relative to the file start, so we profit more from the\n+        // variable-length integer encoding.\n+        let lo = span.lo - source_file.start_pos;\n \n         // Encode length which is usually less than span.hi and profits more\n         // from the variable-length integer encoding that we use.\n+        let len = span.hi - span.lo;\n+\n+        tag.encode(s);\n+        lo.encode(s);\n         len.encode(s);\n \n         // Encode the index of the `SourceFile` for the span, in order to make decoding faster."}, {"sha": "8d26cd6bee3340978a335750b71257972e45f0d2", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bacb4db48c7fe109a7d480b3b5b1cd03898db4a6/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb4db48c7fe109a7d480b3b5b1cd03898db4a6/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=bacb4db48c7fe109a7d480b3b5b1cd03898db4a6", "patch": "@@ -1094,10 +1094,6 @@ pub enum ExternalSource {\n     Unneeded,\n     Foreign {\n         kind: ExternalSourceKind,\n-        /// This SourceFile's byte-offset within the source_map of its original crate.\n-        original_start_pos: BytePos,\n-        /// The end of this SourceFile within the source_map of its original crate.\n-        original_end_pos: BytePos,\n         /// Index of the file inside metadata.\n         metadata_index: u32,\n     },"}, {"sha": "c0fbb7f2c9f8e61d93b8616ef8d83b486e20cfea", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bacb4db48c7fe109a7d480b3b5b1cd03898db4a6/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb4db48c7fe109a7d480b3b5b1cd03898db4a6/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=bacb4db48c7fe109a7d480b3b5b1cd03898db4a6", "patch": "@@ -336,7 +336,7 @@ impl SourceMap {\n         mut file_local_non_narrow_chars: Vec<NonNarrowChar>,\n         mut file_local_normalized_pos: Vec<NormalizedPos>,\n         original_start_pos: BytePos,\n-        original_end_pos: BytePos,\n+        _original_end_pos: BytePos,\n         metadata_index: u32,\n     ) -> Lrc<SourceFile> {\n         let start_pos = self\n@@ -382,8 +382,6 @@ impl SourceMap {\n             src_hash,\n             external_src: Lock::new(ExternalSource::Foreign {\n                 kind: ExternalSourceKind::AbsentOk,\n-                original_start_pos,\n-                original_end_pos,\n                 metadata_index,\n             }),\n             start_pos,"}]}