{"sha": "705d818bd52a6324d5e7693cc4306457395eebc8", "node_id": "C_kwDOAAsO6NoAKDcwNWQ4MThiZDUyYTYzMjRkNWU3NjkzY2M0MzA2NDU3Mzk1ZWViYzg", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-02-16T09:56:01Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-06-14T14:07:11Z"}, "message": "implement valtrees as the type-system representation for constant values", "tree": {"sha": "f5363e1a8b0426bc961970028c23670869e344fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5363e1a8b0426bc961970028c23670869e344fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/705d818bd52a6324d5e7693cc4306457395eebc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/705d818bd52a6324d5e7693cc4306457395eebc8", "html_url": "https://github.com/rust-lang/rust/commit/705d818bd52a6324d5e7693cc4306457395eebc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/705d818bd52a6324d5e7693cc4306457395eebc8/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edab34ab2abbafc16a78daedf71dbacd2eb0b7bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/edab34ab2abbafc16a78daedf71dbacd2eb0b7bf", "html_url": "https://github.com/rust-lang/rust/commit/edab34ab2abbafc16a78daedf71dbacd2eb0b7bf"}], "stats": {"total": 2628, "additions": 1601, "deletions": 1027}, "files": [{"sha": "ef72e6efb946b3cabe8a9881ea9ab2438018791e", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -127,7 +127,7 @@ pub(crate) fn codegen_constant<'tcx>(\n         ConstantKind::Val(val, ty) => return codegen_const_value(fx, val, ty),\n     };\n     let const_val = match const_.kind() {\n-        ConstKind::Value(const_val) => const_val,\n+        ConstKind::Value(valtree) => fx.tcx.valtree_to_const_val((const_.ty(), valtree)),\n         ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n             if fx.tcx.is_static(def.did) =>\n         {\n@@ -468,9 +468,10 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n ) -> Option<ConstValue<'tcx>> {\n     match operand {\n         Operand::Constant(const_) => match const_.literal {\n-            ConstantKind::Ty(const_) => {\n-                fx.monomorphize(const_).eval(fx.tcx, ParamEnv::reveal_all()).kind().try_to_value()\n-            }\n+            ConstantKind::Ty(const_) => fx\n+                .monomorphize(const_)\n+                .eval_for_mir(fx.tcx, ParamEnv::reveal_all())\n+                .try_to_value(fx.tcx),\n             ConstantKind::Val(val, _) => Some(val),\n         },\n         // FIXME(rust-lang/rust#85105): Casts like `IMM8 as u32` result in the const being stored"}, {"sha": "9a995fbf65ca25429a2ef91dbdaacf628d04479f", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n                     err\n                 }),\n-            ty::ConstKind::Value(value) => Ok(value),\n+            ty::ConstKind::Value(val) => Ok(self.cx.tcx().valtree_to_const_val((ct.ty(), val))),\n             err => span_bug!(\n                 constant.span,\n                 \"encountered bad ConstKind after monomorphizing: {:?}\",\n@@ -58,14 +58,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         constant\n             .map(|val| {\n                 let field_ty = ty.builtin_index().unwrap();\n-                let c = ty::Const::from_value(bx.tcx(), val, ty);\n+                let c = mir::ConstantKind::from_value(val, ty);\n                 let values: Vec<_> = bx\n                     .tcx()\n-                    .destructure_const(ty::ParamEnv::reveal_all().and(c))\n+                    .destructure_mir_constant(ty::ParamEnv::reveal_all(), c)\n                     .fields\n                     .iter()\n                     .map(|field| {\n-                        if let Some(prim) = field.kind().try_to_scalar() {\n+                        if let Some(prim) = field.try_to_scalar() {\n                             let layout = bx.layout_of(field_ty);\n                             let Abi::Scalar(scalar) = layout.abi else {\n                                 bug!(\"from_const: invalid ByVal layout: {:#?}\", layout);"}, {"sha": "b7e5e7aea49ce5a1cdf544db80be81b02bb79d5e", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -196,7 +196,7 @@ pub(super) fn op_to_const<'tcx>(\n }\n \n #[instrument(skip(tcx), level = \"debug\")]\n-fn turn_into_const_value<'tcx>(\n+pub(crate) fn turn_into_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     constant: ConstAlloc<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n@@ -222,6 +222,7 @@ fn turn_into_const_value<'tcx>(\n     const_val\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n pub fn eval_to_const_value_raw_provider<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n@@ -256,6 +257,7 @@ pub fn eval_to_const_value_raw_provider<'tcx>(\n     tcx.eval_to_allocation_raw(key).map(|val| turn_into_const_value(tcx, val, key))\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n pub fn eval_to_allocation_raw_provider<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,"}, {"sha": "51edf64de802a8c831c508d8881fa1e6af0ea0aa", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 89, "deletions": 105, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,12 +1,11 @@\n // Not in interpret to make sure we do not use private implementation details\n \n-use std::convert::TryFrom;\n-\n use rustc_hir::Mutability;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{EvalToValTreeResult, GlobalId};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n+use rustc_target::abi::VariantIdx;\n \n use crate::interpret::{\n     intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MemPlaceMeta,\n@@ -25,6 +24,12 @@ pub use fn_queries::*;\n pub use machine::*;\n pub(crate) use valtrees::{const_to_valtree_inner, valtree_to_const_value};\n \n+pub(crate) enum ValTreeCreationError {\n+    NonSupportedType,\n+    Other,\n+}\n+pub(crate) type ValTreeCreationResult<'tcx> = Result<ty::ValTree<'tcx>, ValTreeCreationError>;\n+\n pub(crate) fn const_caller_location(\n     tcx: TyCtxt<'_>,\n     (file, line, col): (Symbol, u32, u32),\n@@ -39,23 +44,15 @@ pub(crate) fn const_caller_location(\n     ConstValue::Scalar(Scalar::from_maybe_pointer(loc_place.ptr, &tcx))\n }\n \n-// We forbid type-level constants that contain more than `VALTREE_MAX_NODES` nodes.\n-const VALTREE_MAX_NODES: usize = 1000;\n-\n-pub(crate) enum ValTreeCreationError {\n-    NodesOverflow,\n-    NonSupportedType,\n-    Other,\n-}\n-pub(crate) type ValTreeCreationResult<'tcx> = Result<ty::ValTree<'tcx>, ValTreeCreationError>;\n-\n /// Evaluates a constant and turns it into a type-level constant value.\n pub(crate) fn eval_to_valtree<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cid: GlobalId<'tcx>,\n ) -> EvalToValTreeResult<'tcx> {\n     let const_alloc = tcx.eval_to_allocation_raw(param_env.and(cid))?;\n+\n+    // FIXME Need to provide a span to `eval_to_valtree`\n     let ecx = mk_eval_cx(\n         tcx, DUMMY_SP, param_env,\n         // It is absolutely crucial for soundness that\n@@ -65,65 +62,89 @@ pub(crate) fn eval_to_valtree<'tcx>(\n     let place = ecx.raw_const_to_mplace(const_alloc).unwrap();\n     debug!(?place);\n \n-    let mut num_nodes = 0;\n-    let valtree_result = const_to_valtree_inner(&ecx, &place, &mut num_nodes);\n+    let valtree_result = const_to_valtree_inner(&ecx, &place);\n \n     match valtree_result {\n         Ok(valtree) => Ok(Some(valtree)),\n-        Err(err) => {\n-            let did = cid.instance.def_id();\n-            let s = cid.display(tcx);\n-            match err {\n-                ValTreeCreationError::NodesOverflow => {\n-                    let msg = format!(\"maximum number of nodes exceeded in constant {}\", &s);\n-                    let mut diag = match tcx.hir().span_if_local(did) {\n-                        Some(span) => tcx.sess.struct_span_err(span, &msg),\n-                        None => tcx.sess.struct_err(&msg),\n-                    };\n-                    diag.emit();\n-\n-                    Ok(None)\n-                }\n-                ValTreeCreationError::NonSupportedType | ValTreeCreationError::Other => Ok(None),\n-            }\n-        }\n+        Err(_) => Ok(None),\n     }\n }\n \n-/// This function should never fail for validated constants. However, it is also invoked from the\n-/// pretty printer which might attempt to format invalid constants and in that case it might fail.\n+/// Tries to destructure constants of type Array or Adt into the constants\n+/// of its fields.\n pub(crate) fn try_destructure_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    val: ty::Const<'tcx>,\n-) -> InterpResult<'tcx, mir::DestructuredConst<'tcx>> {\n-    trace!(\"destructure_const: {:?}\", val);\n-    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n-    let op = ecx.const_to_op(val, None)?;\n-    // We go to `usize` as we cannot allocate anything bigger anyway.\n-    let (field_count, variant, down) = match val.ty().kind() {\n-        ty::Array(_, len) => (usize::try_from(len.eval_usize(tcx, param_env)).unwrap(), None, op),\n-        // Checks if we have any variants, to avoid downcasting to a non-existing variant (when\n-        // there are no variants `read_discriminant` successfully returns a non-existing variant\n-        // index).\n-        ty::Adt(def, _) if def.variants().is_empty() => throw_ub!(Unreachable),\n-        ty::Adt(def, _) => {\n-            let variant = ecx.read_discriminant(&op)?.1;\n-            let down = ecx.operand_downcast(&op, variant)?;\n-            (def.variant(variant).fields.len(), Some(variant), down)\n-        }\n-        ty::Tuple(substs) => (substs.len(), None, op),\n-        _ => bug!(\"cannot destructure constant {:?}\", val),\n-    };\n-    let fields = (0..field_count)\n-        .map(|i| {\n-            let field_op = ecx.operand_field(&down, i)?;\n-            let val = op_to_const(&ecx, &field_op);\n-            Ok(ty::Const::from_value(tcx, val, field_op.layout.ty))\n-        })\n-        .collect::<InterpResult<'tcx, Vec<_>>>()?;\n-    let fields = tcx.arena.alloc_from_iter(fields);\n-    Ok(mir::DestructuredConst { variant, fields })\n+    const_: ty::Const<'tcx>,\n+) -> Option<mir::DestructuredConst<'tcx>> {\n+    if let ty::ConstKind::Value(valtree) = const_.val() {\n+        let branches = match valtree {\n+            ty::ValTree::Branch(b) => b,\n+            _ => return None,\n+        };\n+\n+        let (fields, variant) = match const_.ty().kind() {\n+            ty::Array(inner_ty, _) | ty::Slice(inner_ty) => {\n+                // construct the consts for the elements of the array/slice\n+                let field_consts = branches\n+                    .iter()\n+                    .map(|b| {\n+                        tcx.mk_const(ty::ConstS { kind: ty::ConstKind::Value(*b), ty: *inner_ty })\n+                    })\n+                    .collect::<Vec<_>>();\n+                debug!(?field_consts);\n+\n+                (field_consts, None)\n+            }\n+            ty::Adt(def, _) if def.variants().is_empty() => bug!(\"unreachable\"),\n+            ty::Adt(def, substs) => {\n+                let variant_idx = if def.is_enum() {\n+                    VariantIdx::from_u32(branches[0].unwrap_leaf().try_to_u32().ok()?)\n+                } else {\n+                    VariantIdx::from_u32(0)\n+                };\n+                let fields = &def.variant(variant_idx).fields;\n+                let mut field_consts = Vec::with_capacity(fields.len());\n+\n+                // Note: First element inValTree corresponds to variant of enum\n+                let mut valtree_idx = if def.is_enum() { 1 } else { 0 };\n+                for field in fields {\n+                    let field_ty = field.ty(tcx, substs);\n+                    let field_valtree = branches[valtree_idx]; // first element of branches is variant\n+                    let field_const = tcx.mk_const(ty::ConstS {\n+                        kind: ty::ConstKind::Value(field_valtree),\n+                        ty: field_ty,\n+                    });\n+                    field_consts.push(field_const);\n+                    valtree_idx += 1;\n+                }\n+                debug!(?field_consts);\n+\n+                (field_consts, Some(variant_idx))\n+            }\n+            ty::Tuple(elem_tys) => {\n+                let fields = elem_tys\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, elem_ty)| {\n+                        let elem_valtree = branches[i];\n+                        tcx.mk_const(ty::ConstS {\n+                            kind: ty::ConstKind::Value(elem_valtree),\n+                            ty: elem_ty,\n+                        })\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                (fields, None)\n+            }\n+            _ => bug!(\"cannot destructure constant {:?}\", const_),\n+        };\n+\n+        let fields = tcx.arena.alloc_from_iter(fields.into_iter());\n+\n+        Some(mir::DestructuredConst { variant, fields })\n+    } else {\n+        None\n+    }\n }\n \n #[instrument(skip(tcx), level = \"debug\")]\n@@ -143,8 +164,8 @@ pub(crate) fn try_destructure_mir_constant<'tcx>(\n             throw_ub!(Unreachable)\n         }\n         ty::Adt(def, _) => {\n-            let variant = ecx.read_discriminant(&op).unwrap().1;\n-            let down = ecx.operand_downcast(&op, variant).unwrap();\n+            let variant = ecx.read_discriminant(&op)?.1;\n+            let down = ecx.operand_downcast(&op, variant)?;\n             (def.variants()[variant].fields.len(), Some(variant), down)\n         }\n         ty::Tuple(substs) => (substs.len(), None, op),\n@@ -163,43 +184,6 @@ pub(crate) fn try_destructure_mir_constant<'tcx>(\n     Ok(mir::DestructuredMirConstant { variant, fields })\n }\n \n-#[instrument(skip(tcx), level = \"debug\")]\n-pub(crate) fn deref_const<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    val: ty::Const<'tcx>,\n-) -> ty::Const<'tcx> {\n-    trace!(\"deref_const: {:?}\", val);\n-    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n-    let op = ecx.const_to_op(val, None).unwrap();\n-    let mplace = ecx.deref_operand(&op).unwrap();\n-    if let Some(alloc_id) = mplace.ptr.provenance {\n-        assert_eq!(\n-            tcx.get_global_alloc(alloc_id).unwrap().unwrap_memory().inner().mutability,\n-            Mutability::Not,\n-            \"deref_const cannot be used with mutable allocations as \\\n-            that could allow pattern matching to observe mutable statics\",\n-        );\n-    }\n-\n-    let ty = match mplace.meta {\n-        MemPlaceMeta::None => mplace.layout.ty,\n-        MemPlaceMeta::Poison => bug!(\"poison metadata in `deref_const`: {:#?}\", mplace),\n-        // In case of unsized types, figure out the real type behind.\n-        MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n-            ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n-            ty::Slice(elem_ty) => tcx.mk_array(*elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n-            _ => bug!(\n-                \"type {} should not have metadata, but had {:?}\",\n-                mplace.layout.ty,\n-                mplace.meta\n-            ),\n-        },\n-    };\n-\n-    tcx.mk_const(ty::ConstS { kind: ty::ConstKind::Value(op_to_const(&ecx, &mplace.into())), ty })\n-}\n-\n #[instrument(skip(tcx), level = \"debug\")]\n pub(crate) fn deref_mir_constant<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -211,16 +195,16 @@ pub(crate) fn deref_mir_constant<'tcx>(\n     let mplace = ecx.deref_operand(&op).unwrap();\n     if let Some(alloc_id) = mplace.ptr.provenance {\n         assert_eq!(\n-            tcx.get_global_alloc(alloc_id).unwrap().unwrap_memory().0.0.mutability,\n+            tcx.get_global_alloc(alloc_id).unwrap().unwrap_memory().0 .0.mutability,\n             Mutability::Not,\n-            \"deref_const cannot be used with mutable allocations as \\\n+            \"deref_mir_constant cannot be used with mutable allocations as \\\n             that could allow pattern matching to observe mutable statics\",\n         );\n     }\n \n     let ty = match mplace.meta {\n         MemPlaceMeta::None => mplace.layout.ty,\n-        MemPlaceMeta::Poison => bug!(\"poison metadata in `deref_const`: {:#?}\", mplace),\n+        MemPlaceMeta::Poison => bug!(\"poison metadata in `deref_mir_constant`: {:#?}\", mplace),\n         // In case of unsized types, figure out the real type behind.\n         MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n             ty::Str => bug!(\"there's no sized equivalent of a `str`\"),"}, {"sha": "080133275a606cd864b33776c7ecf3bae7aa95ad", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,24 +1,21 @@\n use super::eval_queries::{mk_eval_cx, op_to_const};\n use super::machine::CompileTimeEvalContext;\n-use super::{ValTreeCreationError, ValTreeCreationResult, VALTREE_MAX_NODES};\n+use super::{ValTreeCreationError, ValTreeCreationResult};\n use crate::interpret::{\n     intern_const_alloc_recursive, ConstValue, ImmTy, Immediate, InternKind, MemPlaceMeta,\n     MemoryKind, PlaceTy, Scalar, ScalarMaybeUninit,\n };\n+use crate::interpret::{MPlaceTy, Value};\n+use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_target::abi::{Align, VariantIdx};\n \n-use crate::interpret::MPlaceTy;\n-use crate::interpret::Value;\n-use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n-\n #[instrument(skip(ecx), level = \"debug\")]\n fn branches<'tcx>(\n     ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n     place: &MPlaceTy<'tcx>,\n     n: usize,\n     variant: Option<VariantIdx>,\n-    num_nodes: &mut usize,\n ) -> ValTreeCreationResult<'tcx> {\n     let place = match variant {\n         Some(variant) => ecx.mplace_downcast(&place, variant).unwrap(),\n@@ -30,7 +27,7 @@ fn branches<'tcx>(\n     let mut fields = Vec::with_capacity(n);\n     for i in 0..n {\n         let field = ecx.mplace_field(&place, i).unwrap();\n-        let valtree = const_to_valtree_inner(ecx, &field, num_nodes)?;\n+        let valtree = const_to_valtree_inner(ecx, &field)?;\n         fields.push(Some(valtree));\n     }\n \n@@ -42,19 +39,13 @@ fn branches<'tcx>(\n         .collect::<Option<Vec<_>>>()\n         .expect(\"should have already checked for errors in ValTree creation\");\n \n-    // Have to account for ZSTs here\n-    if branches.len() == 0 {\n-        *num_nodes += 1;\n-    }\n-\n     Ok(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches)))\n }\n \n #[instrument(skip(ecx), level = \"debug\")]\n fn slice_branches<'tcx>(\n     ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n     place: &MPlaceTy<'tcx>,\n-    num_nodes: &mut usize,\n ) -> ValTreeCreationResult<'tcx> {\n     let n = place\n         .len(&ecx.tcx.tcx)\n@@ -63,7 +54,7 @@ fn slice_branches<'tcx>(\n     let mut elems = Vec::with_capacity(n as usize);\n     for i in 0..n {\n         let place_elem = ecx.mplace_index(place, i).unwrap();\n-        let valtree = const_to_valtree_inner(ecx, &place_elem, num_nodes)?;\n+        let valtree = const_to_valtree_inner(ecx, &place_elem)?;\n         elems.push(valtree);\n     }\n \n@@ -74,26 +65,19 @@ fn slice_branches<'tcx>(\n pub(crate) fn const_to_valtree_inner<'tcx>(\n     ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n     place: &MPlaceTy<'tcx>,\n-    num_nodes: &mut usize,\n ) -> ValTreeCreationResult<'tcx> {\n-    if *num_nodes >= VALTREE_MAX_NODES {\n-        return Err(ValTreeCreationError::NodesOverflow);\n-    }\n-\n     let ty = place.layout.ty;\n     debug!(\"ty kind: {:?}\", ty.kind());\n \n     match ty.kind() {\n         ty::FnDef(..) => {\n-            *num_nodes += 1;\n             Ok(ty::ValTree::zst())\n         }\n         ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n             let Ok(val) = ecx.read_immediate(&place.into()) else {\n                 return Err(ValTreeCreationError::Other);\n             };\n             let val = val.to_scalar().unwrap();\n-            *num_nodes += 1;\n \n             Ok(ty::ValTree::Leaf(val.assert_int()))\n         }\n@@ -110,11 +94,11 @@ pub(crate) fn const_to_valtree_inner<'tcx>(\n             };\n             debug!(?derefd_place);\n \n-            const_to_valtree_inner(ecx, &derefd_place, num_nodes)\n+            const_to_valtree_inner(ecx, &derefd_place)\n         }\n \n         ty::Str | ty::Slice(_) | ty::Array(_, _) => {\n-            slice_branches(ecx, place, num_nodes)\n+            slice_branches(ecx, place)\n         }\n         // Trait objects are not allowed in type level constants, as we have no concept for\n         // resolving their backing type, even if we can do that at const eval time. We may\n@@ -123,7 +107,7 @@ pub(crate) fn const_to_valtree_inner<'tcx>(\n         ty::Dynamic(..) => Err(ValTreeCreationError::NonSupportedType),\n \n         ty::Tuple(elem_tys) => {\n-            branches(ecx, place, elem_tys.len(), None, num_nodes)\n+            branches(ecx, place, elem_tys.len(), None)\n         }\n \n         ty::Adt(def, _) => {\n@@ -136,7 +120,7 @@ pub(crate) fn const_to_valtree_inner<'tcx>(\n             let Ok((_, variant)) = ecx.read_discriminant(&place.into()) else {\n                 return Err(ValTreeCreationError::Other);\n             };\n-            branches(ecx, place, def.variant(variant).fields.len(), def.is_enum().then_some(variant), num_nodes)\n+            branches(ecx, place, def.variant(variant).fields.len(), def.is_enum().then_some(variant))\n         }\n \n         ty::Never\n@@ -234,13 +218,9 @@ fn create_pointee_place<'tcx>(\n         // Get the size of the memory behind the DST\n         let dst_size = unsized_inner_ty_size.checked_mul(num_elems as u64, &tcx).unwrap();\n \n-        let ptr = ecx\n-            .allocate_ptr(\n-                size_of_sized_part.checked_add(dst_size, &tcx).unwrap(),\n-                Align::from_bytes(1).unwrap(),\n-                MemoryKind::Stack,\n-            )\n-            .unwrap();\n+        let size = size_of_sized_part.checked_add(dst_size, &tcx).unwrap();\n+        let align = Align::from_bytes(size.bytes().next_power_of_two()).unwrap();\n+        let ptr = ecx.allocate_ptr(size, align, MemoryKind::Stack).unwrap();\n         debug!(?ptr);\n \n         let place = MPlaceTy::from_aligned_ptr_with_meta(\n@@ -262,7 +242,7 @@ fn create_pointee_place<'tcx>(\n #[instrument(skip(tcx), level = \"debug\")]\n pub fn valtree_to_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n+    param_env_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n     valtree: ty::ValTree<'tcx>,\n ) -> ConstValue<'tcx> {\n     // Basic idea: We directly construct `Scalar` values from trivial `ValTree`s\n@@ -272,8 +252,8 @@ pub fn valtree_to_const_value<'tcx>(\n     // create inner `MPlace`s which are filled recursively.\n     // FIXME Does this need an example?\n \n-    let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::empty(), false);\n-    let param_env_ty = ty::ParamEnv::empty().and(ty);\n+    let (param_env, ty) = param_env_ty.into_parts();\n+    let mut ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n \n     match ty.kind() {\n         ty::FnDef(..) => {\n@@ -336,7 +316,6 @@ pub fn valtree_to_const_value<'tcx>(\n     }\n }\n \n-// FIXME Needs a better/correct name\n #[instrument(skip(ecx), level = \"debug\")]\n fn valtree_into_mplace<'tcx>(\n     ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,"}, {"sha": "e9a9c0e171376f62182575fc98cdf7b5a2b76e86", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -637,7 +637,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::ConstKind::Infer(..) | ty::ConstKind::Placeholder(..) => {\n                 span_bug!(self.cur_span(), \"const_to_op: Unexpected ConstKind {:?}\", c)\n             }\n-            ty::ConstKind::Value(val) => self.const_val_to_op(val, c.ty(), layout),\n+            ty::ConstKind::Value(valtree) => {\n+                let ty = val.ty();\n+                let const_val = self.tcx.valtree_to_const_val((ty, valtree));\n+                self.const_val_to_op(const_val, ty, layout)\n+            }\n         }\n     }\n "}, {"sha": "64a74e9d7e206931ee3fe0f3309aaaca8ce4fdc4", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -34,17 +34,15 @@ pub mod interpret;\n pub mod transform;\n pub mod util;\n \n+use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n \n pub fn provide(providers: &mut Providers) {\n     const_eval::provide(providers);\n     providers.eval_to_const_value_raw = const_eval::eval_to_const_value_raw_provider;\n     providers.eval_to_allocation_raw = const_eval::eval_to_allocation_raw_provider;\n     providers.const_caller_location = const_eval::const_caller_location;\n-    providers.try_destructure_const = |tcx, param_env_and_val| {\n-        let (param_env, c) = param_env_and_val.into_parts();\n-        const_eval::try_destructure_const(tcx, param_env, c).ok()\n-    };\n+    providers.try_destructure_const = |tcx, val| const_eval::try_destructure_const(tcx, val);\n     providers.eval_to_valtree = |tcx, param_env_and_value| {\n         let (param_env, raw) = param_env_and_value.into_parts();\n         const_eval::eval_to_valtree(tcx, param_env, raw)\n@@ -53,11 +51,8 @@ pub fn provide(providers: &mut Providers) {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::try_destructure_mir_constant(tcx, param_env, value).ok()\n     };\n-    providers.valtree_to_const_val =\n-        |tcx, (ty, valtree)| const_eval::valtree_to_const_value(tcx, ty, valtree);\n-    providers.deref_const = |tcx, param_env_and_value| {\n-        let (param_env, value) = param_env_and_value.into_parts();\n-        const_eval::deref_const(tcx, param_env, value)\n+    providers.valtree_to_const_val = |tcx, (ty, valtree)| {\n+        const_eval::valtree_to_const_value(tcx, ty::ParamEnv::empty().and(ty), valtree)\n     };\n     providers.deref_mir_constant = |tcx, param_env_and_value| {\n         let (param_env, value) = param_env_and_value.into_parts();"}, {"sha": "3595a488d0c5b716f3b721147e6a2f43bfbd0b03", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -765,7 +765,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         let unit = Rvalue::Use(Operand::Constant(Box::new(Constant {\n                             span: statement.source_info.span,\n                             user_ty: None,\n-                            literal: ty::Const::zero_sized(self.tcx, self.tcx.types.unit).into(),\n+                            literal: ConstantKind::zero_sized(self.tcx.types.unit),\n                         })));\n                         mem::replace(rhs, unit)\n                     },\n@@ -835,26 +835,25 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             let mut promoted_operand = |ty, span| {\n                 promoted.span = span;\n                 promoted.local_decls[RETURN_PLACE] = LocalDecl::new(ty, span);\n+                let _const = tcx.mk_const(ty::ConstS {\n+                    ty,\n+                    kind: ty::ConstKind::Unevaluated(ty::Unevaluated {\n+                        def,\n+                        substs: InternalSubsts::for_item(tcx, def.did, |param, _| {\n+                            if let ty::GenericParamDefKind::Lifetime = param.kind {\n+                                tcx.lifetimes.re_erased.into()\n+                            } else {\n+                                tcx.mk_param_from_def(param)\n+                            }\n+                        }),\n+                        promoted: Some(promoted_id),\n+                    }),\n+                });\n \n                 Operand::Constant(Box::new(Constant {\n                     span,\n                     user_ty: None,\n-                    literal: tcx\n-                        .mk_const(ty::ConstS {\n-                            ty,\n-                            kind: ty::ConstKind::Unevaluated(ty::Unevaluated {\n-                                def,\n-                                substs: InternalSubsts::for_item(tcx, def.did, |param, _| {\n-                                    if let ty::GenericParamDefKind::Lifetime = param.kind {\n-                                        tcx.lifetimes.re_erased.into()\n-                                    } else {\n-                                        tcx.mk_param_from_def(param)\n-                                    }\n-                                }),\n-                                promoted: Some(promoted_id),\n-                            }),\n-                        })\n-                        .into(),\n+                    literal: ConstantKind::from_const(_const, tcx),\n                 }))\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();"}, {"sha": "93a067cb5160633e441a632fa43e621a1cb561a1", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n-use rustc_middle::mir::interpret::{ErrorHandled, EvalToConstValueResult};\n+use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n use rustc_middle::traits::select;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n@@ -1616,6 +1616,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         u\n     }\n \n+    pub fn try_const_eval_resolve(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        unevaluated: ty::Unevaluated<'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Option<Span>,\n+    ) -> Result<ty::Const<'tcx>, ErrorHandled> {\n+        match self.const_eval_resolve(param_env, unevaluated, span) {\n+            Ok(Some(val)) => Ok(ty::Const::from_value(self.tcx, val, ty)),\n+            Ok(None) => {\n+                let tcx = self.tcx;\n+                let def_id = unevaluated.def.did;\n+                span_bug!(\n+                    tcx.def_span(def_id),\n+                    \"unable to construct a constant value for the unevaluated constant {:?}\",\n+                    unevaluated\n+                );\n+            }\n+            Err(err) => Err(err),\n+        }\n+    }\n+\n     /// Resolves and evaluates a constant.\n     ///\n     /// The constant can be located on a trait like `<A as B>::C`, in which case the given\n@@ -1634,7 +1656,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         unevaluated: ty::Unevaluated<'tcx>,\n         span: Option<Span>,\n-    ) -> EvalToConstValueResult<'tcx> {\n+    ) -> EvalToValTreeResult<'tcx> {\n         let substs = self.resolve_vars_if_possible(unevaluated.substs);\n         debug!(?substs);\n \n@@ -1658,7 +1680,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         // The return value is the evaluated value which doesn't contain any reference to inference\n         // variables, thus we don't need to substitute back the original values.\n-        self.tcx.const_eval_resolve(param_env_erased, unevaluated, span)\n+        self.tcx.const_eval_resolve_for_typeck(param_env_erased, unevaluated, span)\n     }\n \n     /// `ty_or_const_infer_var_changed` is equivalent to one of these two:"}, {"sha": "69353232f06590d863ee4a9b2e714a0cd66b4398", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 73, "deletions": 7, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,4 +1,4 @@\n-use super::{ErrorHandled, EvalToConstValueResult, GlobalId};\n+use super::{ErrorHandled, EvalToConstValueResult, EvalToValTreeResult, GlobalId};\n \n use crate::mir;\n use crate::ty::fold::TypeFoldable;\n@@ -11,6 +11,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Evaluates a constant without providing any substitutions. This is useful to evaluate consts\n     /// that can't take any generic arguments like statics, const items or enum discriminants. If a\n     /// generic parameter is used within the constant `ErrorHandled::ToGeneric` will be returned.\n+    ///\n+    /// Note: Returns a `ConstValue`, which isn't supposed to be used in the type system. In order to\n+    /// evaluate to a type-system level constant value use `const_eval_poly_for_typeck`.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn const_eval_poly(self, def_id: DefId) -> EvalToConstValueResult<'tcx> {\n         // In some situations def_id will have substitutions within scope, but they aren't allowed\n         // to be used. So we can't use `Instance::mono`, instead we feed unresolved substitutions\n@@ -23,6 +27,22 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.const_eval_global_id(param_env, cid, None)\n     }\n \n+    /// Evaluates a constant without providing any substitutions. This is useful to evaluate consts\n+    /// that can't take any generic arguments like statics, const items or enum discriminants. If a\n+    /// generic parameter is used within the constant `ErrorHandled::ToGeneric` will be returned.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub fn const_eval_poly_for_typeck(self, def_id: DefId) -> EvalToValTreeResult<'tcx> {\n+        // In some situations def_id will have substitutions within scope, but they aren't allowed\n+        // to be used. So we can't use `Instance::mono`, instead we feed unresolved substitutions\n+        // into `const_eval` which will return `ErrorHandled::ToGeneric` if any of them are\n+        // encountered.\n+        let substs = InternalSubsts::identity_for_item(self, def_id);\n+        let instance = ty::Instance::new(def_id, substs);\n+        let cid = GlobalId { instance, promoted: None };\n+        let param_env = self.param_env(def_id).with_reveal_all_normalized(self);\n+        self.const_eval_global_id_for_typeck(param_env, cid, None)\n+    }\n+\n     /// Resolves and evaluates a constant.\n     ///\n     /// The constant can be located on a trait like `<A as B>::C`, in which case the given\n@@ -59,6 +79,33 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n+    pub fn const_eval_resolve_for_typeck(\n+        self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ct: ty::Unevaluated<'tcx>,\n+        span: Option<Span>,\n+    ) -> EvalToValTreeResult<'tcx> {\n+        // Cannot resolve `Unevaluated` constants that contain inference\n+        // variables. We reject those here since `resolve_opt_const_arg`\n+        // would fail otherwise.\n+        //\n+        // When trying to evaluate constants containing inference variables,\n+        // use `Infcx::const_eval_resolve` instead.\n+        if ct.substs.has_infer_types_or_consts() {\n+            bug!(\"did not expect inference variables here\");\n+        }\n+\n+        match ty::Instance::resolve_opt_const_arg(self, param_env, ct.def, ct.substs) {\n+            Ok(Some(instance)) => {\n+                let cid = GlobalId { instance, promoted: ct.promoted };\n+                self.const_eval_global_id_for_typeck(param_env, cid, span)\n+            }\n+            Ok(None) => Err(ErrorHandled::TooGeneric),\n+            Err(error_reported) => Err(ErrorHandled::Reported(error_reported)),\n+        }\n+    }\n+\n     pub fn const_eval_instance(\n         self,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -68,7 +115,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.const_eval_global_id(param_env, GlobalId { instance, promoted: None }, span)\n     }\n \n-    /// Evaluate a constant.\n+    /// Evaluate a constant to a `ConstValue`.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn const_eval_global_id(\n         self,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -86,6 +134,27 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Evaluate a constant to a type-level constant.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub fn const_eval_global_id_for_typeck(\n+        self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        cid: GlobalId<'tcx>,\n+        span: Option<Span>,\n+    ) -> EvalToValTreeResult<'tcx> {\n+        let param_env = param_env.with_const();\n+        debug!(?param_env);\n+        // Const-eval shouldn't depend on lifetimes at all, so we can erase them, which should\n+        // improve caching of queries.\n+        let inputs = self.erase_regions(param_env.and(cid));\n+        debug!(?inputs);\n+        if let Some(span) = span {\n+            self.at(span).eval_to_valtree(inputs)\n+        } else {\n+            self.eval_to_valtree(inputs)\n+        }\n+    }\n+\n     /// Evaluate a static's initializer, returning the allocation of the initializer's memory.\n     #[inline(always)]\n     pub fn eval_static_initializer(\n@@ -125,11 +194,8 @@ impl<'tcx> TyCtxtAt<'tcx> {\n impl<'tcx> TyCtxt<'tcx> {\n     /// Destructure a type-level constant ADT or array into its variant index and its field values.\n     /// Panics if the destructuring fails, use `try_destructure_const` for fallible version.\n-    pub fn destructure_const(\n-        self,\n-        param_env_and_val: ty::ParamEnvAnd<'tcx, ty::Const<'tcx>>,\n-    ) -> mir::DestructuredConst<'tcx> {\n-        self.try_destructure_const(param_env_and_val).unwrap()\n+    pub fn destructure_const(self, const_: ty::Const<'tcx>) -> mir::DestructuredConst<'tcx> {\n+        self.try_destructure_const(const_).unwrap()\n     }\n \n     /// Destructure a mir constant ADT or array into its variant index and its field values."}, {"sha": "f566467b7ce09758f0d816a51d53bf2a720c68d0", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -78,6 +78,7 @@ impl<'tcx> ConstValue<'tcx> {\n         Some(self.try_to_scalar()?.assert_int())\n     }\n \n+    #[inline(always)]\n     pub fn try_to_bits(&self, size: Size) -> Option<u128> {\n         self.try_to_scalar_int()?.to_bits(size).ok()\n     }"}, {"sha": "512615ccbab8594c5081d80109142d6960cdc3cb", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 235, "deletions": 34, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -3,7 +3,9 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n use crate::mir::coverage::{CodeRegion, CoverageKind};\n-use crate::mir::interpret::{ConstAllocation, ConstValue, GlobalAlloc, LitToConstInput, Scalar};\n+use crate::mir::interpret::{\n+    AllocRange, ConstAllocation, ConstValue, GlobalAlloc, LitToConstInput, Scalar,\n+};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -1444,7 +1446,11 @@ impl<'tcx> BasicBlockData<'tcx> {\n     }\n \n     pub fn visitable(&self, index: usize) -> &dyn MirVisitable<'tcx> {\n-        if index < self.statements.len() { &self.statements[index] } else { &self.terminator }\n+        if index < self.statements.len() {\n+            &self.statements[index]\n+        } else {\n+            &self.terminator\n+        }\n     }\n }\n \n@@ -2465,7 +2471,11 @@ impl<'tcx> Operand<'tcx> {\n     /// find as the `func` in a [`TerminatorKind::Call`].\n     pub fn const_fn_def(&self) -> Option<(DefId, SubstsRef<'tcx>)> {\n         let const_ty = self.constant()?.literal.ty();\n-        if let ty::FnDef(def_id, substs) = *const_ty.kind() { Some((def_id, substs)) } else { None }\n+        if let ty::FnDef(def_id, substs) = *const_ty.kind() {\n+            Some((def_id, substs))\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -2953,62 +2963,62 @@ impl<'tcx> Constant<'tcx> {\n     }\n }\n \n-impl<'tcx> From<ty::Const<'tcx>> for ConstantKind<'tcx> {\n-    #[inline]\n-    fn from(ct: ty::Const<'tcx>) -> Self {\n-        match ct.kind() {\n-            ty::ConstKind::Value(cv) => {\n-                // FIXME Once valtrees are introduced we need to convert those\n-                // into `ConstValue` instances here\n-                Self::Val(cv, ct.ty())\n-            }\n-            _ => Self::Ty(ct),\n-        }\n-    }\n-}\n-\n impl<'tcx> ConstantKind<'tcx> {\n     /// Returns `None` if the constant is not trivially safe for use in the type system.\n+    #[inline]\n     pub fn const_for_ty(&self) -> Option<ty::Const<'tcx>> {\n         match self {\n             ConstantKind::Ty(c) => Some(*c),\n             ConstantKind::Val(..) => None,\n         }\n     }\n \n+    #[inline(always)]\n     pub fn ty(&self) -> Ty<'tcx> {\n         match self {\n             ConstantKind::Ty(c) => c.ty(),\n             ConstantKind::Val(_, ty) => *ty,\n         }\n     }\n \n-    pub fn try_val(&self) -> Option<ConstValue<'tcx>> {\n+    pub fn try_val(&self, tcx: TyCtxt<'tcx>) -> Option<ConstValue<'tcx>> {\n         match self {\n             ConstantKind::Ty(c) => match c.kind() {\n-                ty::ConstKind::Value(v) => Some(v),\n+                ty::ConstKind::Value(v) => Some(tcx.valtree_to_const_val((c.ty(), v))),\n                 _ => None,\n             },\n             ConstantKind::Val(v, _) => Some(*v),\n         }\n     }\n \n     #[inline]\n-    pub fn try_to_value(self) -> Option<interpret::ConstValue<'tcx>> {\n+    pub fn try_to_value(self, tcx: TyCtxt<'tcx>) -> Option<interpret::ConstValue<'tcx>> {\n         match self {\n-            ConstantKind::Ty(c) => c.kind().try_to_value(),\n+            ConstantKind::Ty(c) => match c.kind() {\n+                ty::ConstKind::Value(valtree) => Some(tcx.valtree_to_const_val((c.ty(), valtree))),\n+                _ => None,\n+            },\n             ConstantKind::Val(val, _) => Some(val),\n         }\n     }\n \n     #[inline]\n     pub fn try_to_scalar(self) -> Option<Scalar> {\n-        self.try_to_value()?.try_to_scalar()\n+        match self {\n+            ConstantKind::Ty(c) => match c.val() {\n+                ty::ConstKind::Value(valtree) => match valtree {\n+                    ty::ValTree::Leaf(scalar_int) => Some(Scalar::Int(scalar_int)),\n+                    ty::ValTree::Branch(_) => None,\n+                },\n+                _ => None,\n+            },\n+            ConstantKind::Val(val, _) => val.try_to_scalar(),\n+        }\n     }\n \n     #[inline]\n     pub fn try_to_scalar_int(self) -> Option<ScalarInt> {\n-        Some(self.try_to_value()?.try_to_scalar()?.assert_int())\n+        Some(self.try_to_scalar()?.assert_int())\n     }\n \n     #[inline]\n@@ -3025,9 +3035,7 @@ impl<'tcx> ConstantKind<'tcx> {\n     pub fn eval(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Self {\n         match self {\n             Self::Ty(c) => {\n-                // FIXME Need to use a different evaluation function that directly returns a `ConstValue`\n-                // if evaluation succeeds and does not create a ValTree first\n-                if let Some(val) = c.kind().try_eval(tcx, param_env) {\n+                if let Some(val) = c.kind().try_eval_for_mir(tcx, param_env) {\n                     match val {\n                         Ok(val) => Self::Val(val, c.ty()),\n                         Err(_) => Self::Ty(tcx.const_error(self.ty())),\n@@ -3081,6 +3089,11 @@ impl<'tcx> ConstantKind<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    pub fn from_value(val: ConstValue<'tcx>, ty: Ty<'tcx>) -> Self {\n+        Self::Val(val, ty)\n+    }\n+\n     pub fn from_bits(\n         tcx: TyCtxt<'tcx>,\n         bits: u128,\n@@ -3097,11 +3110,13 @@ impl<'tcx> ConstantKind<'tcx> {\n         Self::Val(cv, param_env_ty.value)\n     }\n \n+    #[inline]\n     pub fn from_bool(tcx: TyCtxt<'tcx>, v: bool) -> Self {\n         let cv = ConstValue::from_bool(v);\n         Self::Val(cv, tcx.types.bool)\n     }\n \n+    #[inline]\n     pub fn zero_sized(ty: Ty<'tcx>) -> Self {\n         let cv = ConstValue::Scalar(Scalar::ZST);\n         Self::Val(cv, ty)\n@@ -3112,6 +3127,12 @@ impl<'tcx> ConstantKind<'tcx> {\n         Self::from_bits(tcx, n as u128, ty::ParamEnv::empty().and(ty))\n     }\n \n+    #[inline]\n+    pub fn from_scalar(_tcx: TyCtxt<'tcx>, s: Scalar, ty: Ty<'tcx>) -> Self {\n+        let val = ConstValue::Scalar(s);\n+        Self::Val(val, ty)\n+    }\n+\n     /// Literals are converted to `ConstantKindVal`, const generic parameters are eagerly\n     /// converted to a constant, everything else becomes `Unevaluated`.\n     pub fn from_anon_const(\n@@ -3199,8 +3220,10 @@ impl<'tcx> ConstantKind<'tcx> {\n             }\n             _ => expr,\n         };\n+        debug!(\"expr.kind: {:?}\", expr.kind);\n \n         let ty = tcx.type_of(def.def_id_for_type_of());\n+        debug!(?ty);\n \n         // FIXME(const_generics): We currently have to special case parameters because `min_const_generics`\n         // does not provide the parents generics to anonymous constants. We still allow generic const\n@@ -3224,6 +3247,7 @@ impl<'tcx> ConstantKind<'tcx> {\n                     kind: ty::ConstKind::Param(ty::ParamConst::new(index, name)),\n                     ty,\n                 });\n+                debug!(?ty_const);\n \n                 return Self::Ty(ty_const);\n             }\n@@ -3253,8 +3277,12 @@ impl<'tcx> ConstantKind<'tcx> {\n         debug!(?span, ?param_env);\n \n         match tcx.const_eval_resolve(param_env, uneval, Some(span)) {\n-            Ok(val) => Self::Val(val, ty),\n+            Ok(val) => {\n+                debug!(\"evaluated const value: {:?}\", val);\n+                Self::Val(val, ty)\n+            }\n             Err(_) => {\n+                debug!(\"error encountered during evaluation\");\n                 // Error was handled in `const_eval_resolve`. Here we just create a\n                 // new unevaluated const and error hard later in codegen\n                 let ty_const = tcx.mk_const(ty::ConstS {\n@@ -3265,11 +3293,22 @@ impl<'tcx> ConstantKind<'tcx> {\n                     }),\n                     ty,\n                 });\n+                debug!(?ty_const);\n \n                 Self::Ty(ty_const)\n             }\n         }\n     }\n+\n+    pub fn from_const(c: ty::Const<'tcx>, tcx: TyCtxt<'tcx>) -> Self {\n+        match c.val() {\n+            ty::ConstKind::Value(valtree) => {\n+                let const_val = tcx.valtree_to_const_val((c.ty(), valtree));\n+                Self::Val(const_val, c.ty())\n+            }\n+            _ => Self::Ty(c),\n+        }\n+    }\n }\n \n /// A collection of projections into user types.\n@@ -3485,20 +3524,182 @@ fn pretty_print_const<'tcx>(\n     })\n }\n \n+fn pretty_print_byte_str(fmt: &mut Formatter<'_>, byte_str: &[u8]) -> fmt::Result {\n+    fmt.write_str(\"b\\\"\")?;\n+    for &c in byte_str {\n+        for e in std::ascii::escape_default(c) {\n+            fmt.write_char(e as char)?;\n+        }\n+    }\n+    fmt.write_str(\"\\\"\")?;\n+\n+    Ok(())\n+}\n+\n+fn comma_sep<'tcx>(fmt: &mut Formatter<'_>, elems: Vec<ConstantKind<'tcx>>) -> fmt::Result {\n+    let mut first = true;\n+    for elem in elems {\n+        if !first {\n+            fmt.write_str(\", \")?;\n+        }\n+        fmt.write_str(&format!(\"{}\", elem))?;\n+        first = false;\n+    }\n+    Ok(())\n+}\n+\n fn pretty_print_const_value<'tcx>(\n-    val: interpret::ConstValue<'tcx>,\n+    ct: ConstValue<'tcx>,\n     ty: Ty<'tcx>,\n     fmt: &mut Formatter<'_>,\n-    print_types: bool,\n+    print_ty: bool,\n ) -> fmt::Result {\n     use crate::ty::print::PrettyPrinter;\n+\n     ty::tls::with(|tcx| {\n-        let val = tcx.lift(val).unwrap();\n+        let ct = tcx.lift(ct).unwrap();\n         let ty = tcx.lift(ty).unwrap();\n-        let mut cx = FmtPrinter::new(tcx, Namespace::ValueNS);\n-        cx.print_alloc_ids = true;\n-        let cx = cx.pretty_print_const_value(val, ty, print_types)?;\n-        fmt.write_str(&cx.into_buffer())?;\n+\n+        if tcx.sess.verbose() {\n+            fmt.write_str(&format!(\"ConstValue({:?}: {})\", ct, ty))?;\n+            return Ok(());\n+        }\n+\n+        let u8_type = tcx.types.u8;\n+        match (ct, ty.kind()) {\n+            // Byte/string slices, printed as (byte) string literals.\n+            (ConstValue::Slice { data, start, end }, ty::Ref(_, inner, _)) => {\n+                match inner.kind() {\n+                    ty::Slice(t) => {\n+                        if *t == u8_type {\n+                            // The `inspect` here is okay since we checked the bounds, and there are\n+                            // no relocations (we have an active slice reference here). We don't use\n+                            // this result to affect interpreter execution.\n+                            let byte_str = data\n+                                .inner()\n+                                .inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n+                            pretty_print_byte_str(fmt, byte_str)?;\n+                            return Ok(());\n+                        }\n+                    }\n+                    ty::Str => {\n+                        // The `inspect` here is okay since we checked the bounds, and there are no\n+                        // relocations (we have an active `str` reference here). We don't use this\n+                        // result to affect interpreter execution.\n+                        let slice = data\n+                            .inner()\n+                            .inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n+                        fmt.write_str(&format!(\"{:?}\", String::from_utf8_lossy(slice)))?;\n+                        return Ok(());\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            (ConstValue::ByRef { alloc, offset }, ty::Array(t, n)) if *t == u8_type => {\n+                let n = n.val().try_to_bits(tcx.data_layout.pointer_size).unwrap();\n+                // cast is ok because we already checked for pointer size (32 or 64 bit) above\n+                let range = AllocRange { start: offset, size: Size::from_bytes(n) };\n+                let byte_str = alloc.inner().get_bytes(&tcx, range).unwrap();\n+                fmt.write_str(\"*\")?;\n+                pretty_print_byte_str(fmt, byte_str)?;\n+                return Ok(());\n+            }\n+            // Aggregates, printed as array/tuple/struct/variant construction syntax.\n+            //\n+            // NB: the `has_param_types_or_consts` check ensures that we can use\n+            // the `destructure_const` query with an empty `ty::ParamEnv` without\n+            // introducing ICEs (e.g. via `layout_of`) from missing bounds.\n+            // E.g. `transmute([0usize; 2]): (u8, *mut T)` needs to know `T: Sized`\n+            // to be able to destructure the tuple into `(0u8, *mut T)\n+            //\n+            // FIXME(eddyb) for `--emit=mir`/`-Z dump-mir`, we should provide the\n+            // correct `ty::ParamEnv` to allow printing *all* constant values.\n+            (_, ty::Array(..) | ty::Tuple(..) | ty::Adt(..)) if !ty.has_param_types_or_consts() => {\n+                let ct = tcx.lift(ct).unwrap();\n+                let ty = tcx.lift(ty).unwrap();\n+                if let Some(contents) = tcx.try_destructure_mir_constant(\n+                    ty::ParamEnv::reveal_all().and(ConstantKind::Val(ct, ty)),\n+                ) {\n+                    let fields = contents.fields.iter().copied().collect::<Vec<_>>();\n+                    match *ty.kind() {\n+                        ty::Array(..) => {\n+                            fmt.write_str(\"[\")?;\n+                            comma_sep(fmt, fields)?;\n+                            fmt.write_str(\"]\")?;\n+                        }\n+                        ty::Tuple(..) => {\n+                            fmt.write_str(\"(\")?;\n+                            comma_sep(fmt, fields)?;\n+                            if contents.fields.len() == 1 {\n+                                fmt.write_str(\",\")?;\n+                            }\n+                            fmt.write_str(\")\")?;\n+                        }\n+                        ty::Adt(def, _) if def.variants().is_empty() => {\n+                            fmt.write_str(&format!(\"{{unreachable(): {}}}\", ty))?;\n+                        }\n+                        ty::Adt(def, substs) => {\n+                            let variant_idx = contents\n+                                .variant\n+                                .expect(\"destructed mir constant of adt without variant idx\");\n+                            let variant_def = &def.variant(variant_idx);\n+                            let substs = tcx.lift(substs).unwrap();\n+                            let mut cx = FmtPrinter::new(tcx, Namespace::ValueNS);\n+                            cx.print_alloc_ids = true;\n+                            let cx = cx.print_value_path(variant_def.def_id, substs)?;\n+                            fmt.write_str(&cx.into_buffer())?;\n+\n+                            match variant_def.ctor_kind {\n+                                CtorKind::Const => {}\n+                                CtorKind::Fn => {\n+                                    fmt.write_str(\"(\")?;\n+                                    comma_sep(fmt, fields)?;\n+                                    fmt.write_str(\")\")?;\n+                                }\n+                                CtorKind::Fictive => {\n+                                    fmt.write_str(\" {{ \")?;\n+                                    let mut first = true;\n+                                    for (field_def, field) in iter::zip(&variant_def.fields, fields)\n+                                    {\n+                                        if !first {\n+                                            fmt.write_str(\", \")?;\n+                                        }\n+                                        fmt.write_str(&format!(\"{}: {}\", field_def.name, field))?;\n+                                        first = false;\n+                                    }\n+                                    fmt.write_str(\" }}\")?;\n+                                }\n+                            }\n+                        }\n+                        _ => unreachable!(),\n+                    }\n+                    return Ok(());\n+                } else {\n+                    // Fall back to debug pretty printing for invalid constants.\n+                    fmt.write_str(&format!(\"{:?}\", ct))?;\n+                    if print_ty {\n+                        fmt.write_str(&format!(\": {}\", ty))?;\n+                    }\n+                    return Ok(());\n+                };\n+            }\n+            (ConstValue::Scalar(scalar), _) => {\n+                let mut cx = FmtPrinter::new(tcx, Namespace::ValueNS);\n+                cx.print_alloc_ids = true;\n+                let ty = tcx.lift(ty).unwrap();\n+                cx = cx.pretty_print_const_scalar(scalar, ty, print_ty)?;\n+                fmt.write_str(&cx.into_buffer())?;\n+                return Ok(());\n+            }\n+            // FIXME(oli-obk): also pretty print arrays and other aggregate constants by reading\n+            // their fields instead of just dumping the memory.\n+            _ => {}\n+        }\n+        // fallback\n+        fmt.write_str(&format!(\"{:?}\", ct))?;\n+        if print_ty {\n+            fmt.write_str(&format!(\": {}\", ty))?;\n+        }\n         Ok(())\n     })\n }"}, {"sha": "a81a60df2be8a16c77728abd4bf2d8a36641ccbb", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -454,7 +454,12 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n                 ConstValue::ByRef { .. } => format!(\"ByRef(..)\"),\n             };\n \n-            let kind = match literal {\n+            let fmt_valtree = |valtree: &ty::ValTree<'tcx>| match valtree {\n+                ty::ValTree::Leaf(leaf) => format!(\"ValTree::Leaf({:?})\", leaf),\n+                ty::ValTree::Branch(_) => format!(\"ValTree::Branch(..)\"),\n+            };\n+\n+            let val = match literal {\n                 ConstantKind::Ty(ct) => match ct.kind() {\n                     ty::ConstKind::Param(p) => format!(\"Param({})\", p),\n                     ty::ConstKind::Unevaluated(uv) => format!(\n@@ -463,7 +468,7 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n                         uv.substs,\n                         uv.promoted,\n                     ),\n-                    ty::ConstKind::Value(val) => format!(\"Value({})\", fmt_val(&val)),\n+                    ty::ConstKind::Value(val) => format!(\"Value({})\", fmt_valtree(&val)),\n                     ty::ConstKind::Error(_) => \"Error\".to_string(),\n                     // These variants shouldn't exist in the MIR.\n                     ty::ConstKind::Placeholder(_)\n@@ -665,7 +670,8 @@ pub fn write_allocations<'tcx>(\n     ) -> impl DoubleEndedIterator<Item = AllocId> + '_ {\n         alloc.inner().relocations().values().map(|id| *id)\n     }\n-    fn alloc_ids_from_const(val: ConstValue<'_>) -> impl Iterator<Item = AllocId> + '_ {\n+\n+    fn alloc_ids_from_const_val(val: ConstValue<'_>) -> impl Iterator<Item = AllocId> + '_ {\n         match val {\n             ConstValue::Scalar(interpret::Scalar::Ptr(ptr, _)) => {\n                 Either::Left(Either::Left(std::iter::once(ptr.provenance)))\n@@ -681,17 +687,11 @@ pub fn write_allocations<'tcx>(\n     struct CollectAllocIds(BTreeSet<AllocId>);\n \n     impl<'tcx> Visitor<'tcx> for CollectAllocIds {\n-        fn visit_const(&mut self, c: ty::Const<'tcx>, _loc: Location) {\n-            if let ty::ConstKind::Value(val) = c.kind() {\n-                self.0.extend(alloc_ids_from_const(val));\n-            }\n-        }\n-\n         fn visit_constant(&mut self, c: &Constant<'tcx>, loc: Location) {\n             match c.literal {\n                 ConstantKind::Ty(c) => self.visit_const(c, loc),\n                 ConstantKind::Val(val, _) => {\n-                    self.0.extend(alloc_ids_from_const(val));\n+                    self.0.extend(alloc_ids_from_const_val(val));\n                 }\n             }\n         }"}, {"sha": "da4793fa039d0f36be8d16495b450ae807ab6894", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,6 +1,6 @@\n //! Values computed by queries that use MIR.\n \n-use crate::mir::{self, Body, Promoted};\n+use crate::mir::{Body, ConstantKind, Promoted};\n use crate::ty::{self, OpaqueHiddenType, Ty, TyCtxt};\n use rustc_data_structures::stable_map::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n@@ -427,7 +427,7 @@ pub struct DestructuredConst<'tcx> {\n #[derive(Copy, Clone, Debug, HashStable)]\n pub struct DestructuredMirConstant<'tcx> {\n     pub variant: Option<VariantIdx>,\n-    pub fields: &'tcx [mir::ConstantKind<'tcx>],\n+    pub fields: &'tcx [ConstantKind<'tcx>],\n }\n \n /// Coverage information summarized from a MIR if instrumented for source code coverage (see"}, {"sha": "c65e79a80fb8ebf29b28595c1913466986367eb0", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,3 +1,4 @@\n+use crate::mir;\n use crate::mir::interpret::Scalar;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n@@ -676,7 +677,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                     .values\n                     .iter()\n                     .map(|&u| {\n-                        ty::Const::from_scalar(tcx, Scalar::from_uint(u, size), switch_ty)\n+                        mir::ConstantKind::from_scalar(tcx, Scalar::from_uint(u, size), switch_ty)\n                             .to_string()\n                             .into()\n                     })"}, {"sha": "22b1ad4190489a43a3d2f4f3d0b204987a54d89e", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -968,7 +968,6 @@ rustc_queries! {\n         key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>\n     ) -> EvalToValTreeResult<'tcx> {\n         desc { \"evaluate type-level constant\" }\n-        remap_env_constness\n     }\n \n     /// Converts a type level constant value into `ConstValue`\n@@ -980,7 +979,7 @@ rustc_queries! {\n     /// field values or return `None` if constant is invalid.\n     ///\n     /// Use infallible `TyCtxt::destructure_const` when you know that constant is valid.\n-    query try_destructure_const(key: ty::ParamEnvAnd<'tcx, ty::Const<'tcx>>) -> Option<mir::DestructuredConst<'tcx>> {\n+    query try_destructure_const(key: ty::Const<'tcx>) -> Option<mir::DestructuredConst<'tcx>> {\n         desc { \"destructure type level constant\"}\n     }\n \n@@ -991,15 +990,6 @@ rustc_queries! {\n         remap_env_constness\n     }\n \n-    /// Dereference a constant reference or raw pointer and turn the result into a constant\n-    /// again.\n-    query deref_const(\n-        key: ty::ParamEnvAnd<'tcx, ty::Const<'tcx>>\n-    ) -> ty::Const<'tcx> {\n-        desc { \"deref constant\" }\n-        remap_env_constness\n-    }\n-\n     /// Dereference a constant reference or raw pointer and turn the result into a constant\n     /// again.\n     query deref_mir_constant("}, {"sha": "70abdb9ab4cd7be51106e777960dc5852b829c93", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -5,7 +5,6 @@\n //! its name suggest, is to provide an abstraction boundary for creating\n //! interned Chalk types.\n \n-use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::{self, AdtDef, TyCtxt};\n \n use rustc_hir::def_id::DefId;\n@@ -62,7 +61,7 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n     type InternedType = Box<chalk_ir::TyData<Self>>;\n     type InternedLifetime = Box<chalk_ir::LifetimeData<Self>>;\n     type InternedConst = Box<chalk_ir::ConstData<Self>>;\n-    type InternedConcreteConst = ConstValue<'tcx>;\n+    type InternedConcreteConst = ty::ValTree<'tcx>;\n     type InternedGenericArg = Box<chalk_ir::GenericArgData<Self>>;\n     type InternedGoal = Box<chalk_ir::GoalData<Self>>;\n     type InternedGoals = Vec<chalk_ir::Goal<Self>>;"}, {"sha": "47abbb723dce1ca37c42f176b0202237423e8cf0", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,5 +1,5 @@\n-use crate::mir::interpret::ConstValue;\n-use crate::mir::interpret::{LitToConstInput, Scalar};\n+use crate::mir::interpret::LitToConstInput;\n+use crate::mir::ConstantKind;\n use crate::ty::{\n     self, InlineConstSubsts, InlineConstSubstsParts, InternalSubsts, ParamEnv, ParamEnvAnd, Ty,\n     TyCtxt, TypeFoldable,\n@@ -195,14 +195,13 @@ impl<'tcx> Const<'tcx> {\n \n     /// Interns the given value as a constant.\n     #[inline]\n-    pub fn from_value(tcx: TyCtxt<'tcx>, val: ConstValue<'tcx>, ty: Ty<'tcx>) -> Self {\n+    pub fn from_value(tcx: TyCtxt<'tcx>, val: ty::ValTree<'tcx>, ty: Ty<'tcx>) -> Self {\n         tcx.mk_const(ConstS { kind: ConstKind::Value(val), ty })\n     }\n \n-    #[inline]\n-    /// Interns the given scalar as a constant.\n-    pub fn from_scalar(tcx: TyCtxt<'tcx>, val: Scalar, ty: Ty<'tcx>) -> Self {\n-        Self::from_value(tcx, ConstValue::Scalar(val), ty)\n+    pub fn from_scalar_int(tcx: TyCtxt<'tcx>, i: ScalarInt, ty: Ty<'tcx>) -> Self {\n+        let valtree = ty::ValTree::from_scalar_int(i);\n+        Self::from_value(tcx, valtree, ty)\n     }\n \n     #[inline]\n@@ -212,13 +211,14 @@ impl<'tcx> Const<'tcx> {\n             .layout_of(ty)\n             .unwrap_or_else(|e| panic!(\"could not compute layout for {:?}: {:?}\", ty, e))\n             .size;\n-        Self::from_scalar(tcx, Scalar::from_uint(bits, size), ty.value)\n+        Self::from_scalar_int(tcx, ScalarInt::try_from_uint(bits, size).unwrap(), ty.value)\n     }\n \n     #[inline]\n     /// Creates an interned zst constant.\n     pub fn zero_sized(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Self {\n-        Self::from_scalar(tcx, Scalar::ZST, ty)\n+        let valtree = ty::ValTree::zst();\n+        Self::from_value(tcx, valtree, ty)\n     }\n \n     #[inline]\n@@ -263,16 +263,31 @@ impl<'tcx> Const<'tcx> {\n     /// Tries to evaluate the constant if it is `Unevaluated`. If that doesn't succeed, return the\n     /// unevaluated constant.\n     pub fn eval(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Const<'tcx> {\n-        if let Some(val) = self.kind().try_eval(tcx, param_env) {\n+        if let Some(val) = self.kind().try_eval_for_typeck(tcx, param_env) {\n             match val {\n                 Ok(val) => Const::from_value(tcx, val, self.ty()),\n                 Err(ErrorGuaranteed { .. }) => tcx.const_error(self.ty()),\n             }\n         } else {\n+            // Either the constant isn't evaluatable or ValTree creation failed.\n             self\n         }\n     }\n \n+    #[inline]\n+    /// Tries to evaluate the constant if it is `Unevaluated` and creates a ConstValue if the\n+    /// evaluation succeeds. If it doesn't succeed, returns the unevaluated constant.\n+    pub fn eval_for_mir(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> ConstantKind<'tcx> {\n+        if let Some(val) = self.val().try_eval_for_mir(tcx, param_env) {\n+            match val {\n+                Ok(const_val) => ConstantKind::from_value(const_val, self.ty()),\n+                Err(ErrorGuaranteed { .. }) => ConstantKind::Ty(tcx.const_error(self.ty())),\n+            }\n+        } else {\n+            ConstantKind::Ty(self)\n+        }\n+    }\n+\n     #[inline]\n     /// Panics if the value cannot be evaluated or doesn't contain a valid integer of the given type.\n     pub fn eval_bits(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {"}, {"sha": "10d03065c795f7e5db4838a671e757b461291177", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 70, "deletions": 13, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -63,7 +63,7 @@ pub enum ConstKind<'tcx> {\n     Unevaluated(Unevaluated<'tcx>),\n \n     /// Used to hold computed value.\n-    Value(ConstValue<'tcx>),\n+    Value(ty::ValTree<'tcx>),\n \n     /// A placeholder for a const which could not be computed; this is\n     /// propagated to avoid useless error messages.\n@@ -75,7 +75,7 @@ static_assert_size!(ConstKind<'_>, 40);\n \n impl<'tcx> ConstKind<'tcx> {\n     #[inline]\n-    pub fn try_to_value(self) -> Option<ConstValue<'tcx>> {\n+    pub fn try_to_value(self) -> Option<ty::ValTree<'tcx>> {\n         if let ConstKind::Value(val) = self { Some(val) } else { None }\n     }\n \n@@ -86,7 +86,7 @@ impl<'tcx> ConstKind<'tcx> {\n \n     #[inline]\n     pub fn try_to_scalar_int(self) -> Option<ScalarInt> {\n-        Some(self.try_to_value()?.try_to_scalar()?.assert_int())\n+        self.try_to_value()?.try_to_scalar_int()\n     }\n \n     #[inline]\n@@ -115,23 +115,65 @@ pub enum InferConst<'tcx> {\n     Fresh(u32),\n }\n \n+enum EvalMode {\n+    Typeck,\n+    Mir,\n+}\n+\n+enum EvalResult<'tcx> {\n+    ValTree(ty::ValTree<'tcx>),\n+    ConstVal(ConstValue<'tcx>),\n+}\n+\n impl<'tcx> ConstKind<'tcx> {\n     #[inline]\n     /// Tries to evaluate the constant if it is `Unevaluated`. If that doesn't succeed, return the\n     /// unevaluated constant.\n     pub fn eval(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Self {\n-        self.try_eval(tcx, param_env).and_then(Result::ok).map_or(self, ConstKind::Value)\n+        self.try_eval_for_typeck(tcx, param_env).and_then(Result::ok).map_or(self, ConstKind::Value)\n     }\n \n     #[inline]\n     /// Tries to evaluate the constant if it is `Unevaluated`. If that isn't possible or necessary\n     /// return `None`.\n     // FIXME(@lcnr): Completely rework the evaluation/normalization system for `ty::Const` once valtrees are merged.\n-    pub fn try_eval(\n+    pub fn try_eval_for_mir(\n         self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ParamEnv<'tcx>,\n     ) -> Option<Result<ConstValue<'tcx>, ErrorGuaranteed>> {\n+        match self.try_eval_inner(tcx, param_env, EvalMode::Mir) {\n+            Some(Ok(EvalResult::ValTree(_))) => unreachable!(),\n+            Some(Ok(EvalResult::ConstVal(v))) => Some(Ok(v)),\n+            Some(Err(e)) => Some(Err(e)),\n+            None => None,\n+        }\n+    }\n+\n+    #[inline]\n+    /// Tries to evaluate the constant if it is `Unevaluated`. If that isn't possible or necessary\n+    /// return `None`.\n+    // FIXME(@lcnr): Completely rework the evaluation/normalization system for `ty::Const` once valtrees are merged.\n+    pub fn try_eval_for_typeck(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+    ) -> Option<Result<ty::ValTree<'tcx>, ErrorGuaranteed>> {\n+        match self.try_eval_inner(tcx, param_env, EvalMode::Typeck) {\n+            Some(Ok(EvalResult::ValTree(v))) => Some(Ok(v)),\n+            Some(Ok(EvalResult::ConstVal(_))) => unreachable!(),\n+            Some(Err(e)) => Some(Err(e)),\n+            None => None,\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_eval_inner(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        eval_mode: EvalMode,\n+    ) -> Option<Result<EvalResult<'tcx>, ErrorGuaranteed>> {\n         if let ConstKind::Unevaluated(unevaluated) = self {\n             use crate::mir::interpret::ErrorHandled;\n \n@@ -166,14 +208,29 @@ impl<'tcx> ConstKind<'tcx> {\n             let (param_env, unevaluated) = param_env_and.into_parts();\n             // try to resolve e.g. associated constants to their definition on an impl, and then\n             // evaluate the const.\n-            match tcx.const_eval_resolve(param_env, unevaluated, None) {\n-                // NOTE(eddyb) `val` contains no lifetimes/types/consts,\n-                // and we use the original type, so nothing from `substs`\n-                // (which may be identity substs, see above),\n-                // can leak through `val` into the const we return.\n-                Ok(val) => Some(Ok(val)),\n-                Err(ErrorHandled::TooGeneric | ErrorHandled::Linted) => None,\n-                Err(ErrorHandled::Reported(e)) => Some(Err(e)),\n+            match eval_mode {\n+                EvalMode::Typeck => {\n+                    match tcx.const_eval_resolve_for_typeck(param_env, unevaluated, None) {\n+                        // NOTE(eddyb) `val` contains no lifetimes/types/consts,\n+                        // and we use the original type, so nothing from `substs`\n+                        // (which may be identity substs, see above),\n+                        // can leak through `val` into the const we return.\n+                        Ok(val) => Some(Ok(EvalResult::ValTree(val?))),\n+                        Err(ErrorHandled::TooGeneric | ErrorHandled::Linted) => None,\n+                        Err(ErrorHandled::Reported(e)) => Some(Err(e)),\n+                    }\n+                }\n+                EvalMode::Mir => {\n+                    match tcx.const_eval_resolve(param_env, unevaluated, None) {\n+                        // NOTE(eddyb) `val` contains no lifetimes/types/consts,\n+                        // and we use the original type, so nothing from `substs`\n+                        // (which may be identity substs, see above),\n+                        // can leak through `val` into the const we return.\n+                        Ok(val) => Some(Ok(EvalResult::ConstVal(val))),\n+                        Err(ErrorHandled::TooGeneric | ErrorHandled::Linted) => None,\n+                        Err(ErrorHandled::Reported(e)) => Some(Err(e)),\n+                    }\n+                }\n             }\n         } else {\n             None"}, {"sha": "973dc3dd4a10ab61e1ded24e001629b6bbf0a467", "filename": "compiler/rustc_middle/src/ty/consts/valtree.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,4 +1,6 @@\n use super::ScalarInt;\n+use crate::mir::interpret::{AllocId, Scalar};\n+use crate::ty::{self, Ty, TyCtxt};\n use rustc_macros::{HashStable, TyDecodable, TyEncodable};\n \n #[derive(Copy, Clone, Debug, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]\n@@ -50,4 +52,61 @@ impl<'tcx> ValTree<'tcx> {\n             _ => bug!(\"expected branch, got {:?}\", self),\n         }\n     }\n+\n+    pub fn from_raw_bytes<'a>(tcx: TyCtxt<'tcx>, bytes: &'a [u8]) -> Self {\n+        let branches = bytes.iter().map(|b| Self::Leaf(ScalarInt::from(*b)));\n+        let interned = tcx.arena.alloc_from_iter(branches);\n+\n+        Self::Branch(interned)\n+    }\n+\n+    pub fn from_scalar_int(i: ScalarInt) -> Self {\n+        Self::Leaf(i)\n+    }\n+\n+    pub fn try_to_scalar(self) -> Option<Scalar<AllocId>> {\n+        self.try_to_scalar_int().map(Scalar::Int)\n+    }\n+\n+    pub fn try_to_scalar_int(self) -> Option<ScalarInt> {\n+        match self {\n+            Self::Leaf(s) => Some(s),\n+            Self::Branch(_) => None,\n+        }\n+    }\n+\n+    pub fn try_to_machine_usize(self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n+        self.try_to_scalar_int().map(|s| s.try_to_machine_usize(tcx).ok()).flatten()\n+    }\n+\n+    /// Get the values inside the ValTree as a slice of bytes. This only works for\n+    /// constants with types &str and &[u8].\n+    pub fn try_to_raw_bytes(self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<&'tcx [u8]> {\n+        match ty.kind() {\n+            ty::Ref(_, inner_ty, _) => match inner_ty.kind() {\n+                ty::Str => {\n+                    let leafs = self\n+                        .unwrap_branch()\n+                        .into_iter()\n+                        .map(|v| v.unwrap_leaf().try_to_u8().unwrap())\n+                        .collect::<Vec<_>>();\n+\n+                    return Some(tcx.arena.alloc_from_iter(leafs.into_iter()));\n+                }\n+                ty::Slice(slice_ty) if *slice_ty == tcx.types.u8 => {\n+                    let leafs = self\n+                        .unwrap_branch()\n+                        .into_iter()\n+                        .map(|v| v.unwrap_leaf().try_to_u8().unwrap())\n+                        .collect::<Vec<_>>();\n+\n+                    return Some(tcx.arena.alloc_from_iter(leafs.into_iter()));\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        }\n+\n+        None\n+    }\n }"}, {"sha": "0930f3edf72541e85066a704808a6326159634eb", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 47, "deletions": 21, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -8,7 +8,7 @@ use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_lifetime;\n use crate::middle::stability;\n-use crate::mir::interpret::{self, Allocation, ConstAllocation, ConstValue, Scalar};\n+use crate::mir::interpret::{self, Allocation, ConstAllocation};\n use crate::mir::{\n     Body, BorrowCheckResult, Field, Local, Place, PlaceElem, ProjectionKind, Promoted,\n };\n@@ -991,7 +991,7 @@ impl<'tcx> CommonConsts<'tcx> {\n \n         CommonConsts {\n             unit: mk_const(ty::ConstS {\n-                kind: ty::ConstKind::Value(ConstValue::Scalar(Scalar::ZST)),\n+                kind: ty::ConstKind::Value(ty::ValTree::zst()),\n                 ty: types.unit,\n             }),\n         }\n@@ -1186,11 +1186,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             };\n             debug!(\"layout_scalar_valid_range: attr={:?}\", attr);\n             if let Some(\n-                &[\n-                    ast::NestedMetaItem::Literal(ast::Lit {\n-                        kind: ast::LitKind::Int(a, _), ..\n-                    }),\n-                ],\n+                &[ast::NestedMetaItem::Literal(ast::Lit { kind: ast::LitKind::Int(a, _), .. })],\n             ) = attr.meta_item_list().as_deref()\n             {\n                 Bound::Included(a)\n@@ -1663,7 +1659,7 @@ macro_rules! nop_lift {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n             type Lifted = $lifted;\n             fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-                if tcx.interners.$set.contains_pointer_to(&InternedInSet(&*self.0.0)) {\n+                if tcx.interners.$set.contains_pointer_to(&InternedInSet(&*self.0 .0)) {\n                     // SAFETY: `self` is interned and therefore valid\n                     // for the entire lifetime of the `TyCtxt`.\n                     Some(unsafe { mem::transmute(self) })\n@@ -2248,7 +2244,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// `*r == kind`.\n     #[inline]\n     pub fn reuse_or_mk_region(self, r: Region<'tcx>, kind: RegionKind) -> Region<'tcx> {\n-        if *r == kind { r } else { self.mk_region(kind) }\n+        if *r == kind {\n+            r\n+        } else {\n+            self.mk_region(kind)\n+        }\n     }\n \n     #[allow(rustc::usage_of_ty_tykind)]\n@@ -2268,7 +2268,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         pred: Predicate<'tcx>,\n         binder: Binder<'tcx, PredicateKind<'tcx>>,\n     ) -> Predicate<'tcx> {\n-        if pred.kind() != binder { self.mk_predicate(binder) } else { pred }\n+        if pred.kind() != binder {\n+            self.mk_predicate(binder)\n+        } else {\n+            pred\n+        }\n     }\n \n     pub fn mk_mach_int(self, tm: IntTy) -> Ty<'tcx> {\n@@ -2413,7 +2417,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_diverging_default(self) -> Ty<'tcx> {\n-        if self.features().never_type_fallback { self.types.never } else { self.types.unit }\n+        if self.features().never_type_fallback {\n+            self.types.never\n+        } else {\n+            self.types.unit\n+        }\n     }\n \n     #[inline]\n@@ -2564,11 +2572,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         eps: &[ty::Binder<'tcx, ExistentialPredicate<'tcx>>],\n     ) -> &'tcx List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>> {\n         assert!(!eps.is_empty());\n-        assert!(\n-            eps.array_windows()\n-                .all(|[a, b]| a.skip_binder().stable_cmp(self, &b.skip_binder())\n-                    != Ordering::Greater)\n-        );\n+        assert!(eps\n+            .array_windows()\n+            .all(|[a, b]| a.skip_binder().stable_cmp(self, &b.skip_binder()) != Ordering::Greater));\n         self._intern_poly_existential_predicates(eps)\n     }\n \n@@ -2601,29 +2607,49 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn intern_substs(self, ts: &[GenericArg<'tcx>]) -> &'tcx List<GenericArg<'tcx>> {\n-        if ts.is_empty() { List::empty() } else { self._intern_substs(ts) }\n+        if ts.is_empty() {\n+            List::empty()\n+        } else {\n+            self._intern_substs(ts)\n+        }\n     }\n \n     pub fn intern_projs(self, ps: &[ProjectionKind]) -> &'tcx List<ProjectionKind> {\n-        if ps.is_empty() { List::empty() } else { self._intern_projs(ps) }\n+        if ps.is_empty() {\n+            List::empty()\n+        } else {\n+            self._intern_projs(ps)\n+        }\n     }\n \n     pub fn intern_place_elems(self, ts: &[PlaceElem<'tcx>]) -> &'tcx List<PlaceElem<'tcx>> {\n-        if ts.is_empty() { List::empty() } else { self._intern_place_elems(ts) }\n+        if ts.is_empty() {\n+            List::empty()\n+        } else {\n+            self._intern_place_elems(ts)\n+        }\n     }\n \n     pub fn intern_canonical_var_infos(\n         self,\n         ts: &[CanonicalVarInfo<'tcx>],\n     ) -> CanonicalVarInfos<'tcx> {\n-        if ts.is_empty() { List::empty() } else { self._intern_canonical_var_infos(ts) }\n+        if ts.is_empty() {\n+            List::empty()\n+        } else {\n+            self._intern_canonical_var_infos(ts)\n+        }\n     }\n \n     pub fn intern_bound_variable_kinds(\n         self,\n         ts: &[ty::BoundVariableKind],\n     ) -> &'tcx List<ty::BoundVariableKind> {\n-        if ts.is_empty() { List::empty() } else { self._intern_bound_variable_kinds(ts) }\n+        if ts.is_empty() {\n+            List::empty()\n+        } else {\n+            self._intern_bound_variable_kinds(ts)\n+        }\n     }\n \n     pub fn mk_fn_sig<I>("}, {"sha": "e8dd179eac19831c92d0bb09296bb1d8852e525f", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -369,7 +369,6 @@ impl<'tcx> Instance<'tcx> {\n     }\n \n     // This should be kept up to date with `resolve`.\n-    #[instrument(level = \"debug\", skip(tcx))]\n     pub fn resolve_opt_const_arg(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "8da447d16fbfdd2ef63a15e68a5288d03eda8126", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -2161,22 +2161,28 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns the possibly-auto-generated MIR of a `(DefId, Subst)` pair.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n         match instance {\n-            ty::InstanceDef::Item(def) => match self.def_kind(def.did) {\n-                DefKind::Const\n-                | DefKind::Static(..)\n-                | DefKind::AssocConst\n-                | DefKind::Ctor(..)\n-                | DefKind::AnonConst\n-                | DefKind::InlineConst => self.mir_for_ctfe_opt_const_arg(def),\n-                // If the caller wants `mir_for_ctfe` of a function they should not be using\n-                // `instance_mir`, so we'll assume const fn also wants the optimized version.\n-                _ => {\n-                    assert_eq!(def.const_param_did, None);\n-                    self.optimized_mir(def.did)\n+            ty::InstanceDef::Item(def) => {\n+                debug!(\"calling def_kind on def: {:?}\", def);\n+                let def_kind = self.def_kind(def.did);\n+                debug!(\"returned from def_kind: {:?}\", def_kind);\n+                match def_kind {\n+                    DefKind::Const\n+                    | DefKind::Static(..)\n+                    | DefKind::AssocConst\n+                    | DefKind::Ctor(..)\n+                    | DefKind::AnonConst\n+                    | DefKind::InlineConst => self.mir_for_ctfe_opt_const_arg(def),\n+                    // If the caller wants `mir_for_ctfe` of a function they should not be using\n+                    // `instance_mir`, so we'll assume const fn also wants the optimized version.\n+                    _ => {\n+                        assert_eq!(def.const_param_did, None);\n+                        self.optimized_mir(def.did)\n+                    }\n                 }\n-            },\n+            }\n             ty::InstanceDef::VtableShim(..)\n             | ty::InstanceDef::ReifyShim(..)\n             | ty::InstanceDef::Intrinsic(..)"}, {"sha": "7a096bbc4d96fb05456ff1d3b7d751908494fe88", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -98,7 +98,6 @@ pub trait Printer<'tcx>: Sized {\n \n     // Defaults (should not be overridden):\n \n-    #[instrument(skip(self), level = \"debug\")]\n     fn default_print_def_path(\n         self,\n         def_id: DefId,\n@@ -302,6 +301,7 @@ impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for ty::Region<'_> {\n impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for Ty<'tcx> {\n     type Output = P::Type;\n     type Error = P::Error;\n+\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n         cx.print_type(*self)\n     }"}, {"sha": "3b11f7572a6403a8ab7c73ab2085c2b53bcc3305", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 53, "deletions": 70, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,4 +1,4 @@\n-use crate::mir::interpret::{AllocRange, ConstValue, GlobalAlloc, Pointer, Provenance, Scalar};\n+use crate::mir::interpret::{AllocRange, GlobalAlloc, Pointer, Provenance, Scalar};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n use crate::ty::{\n     self, ConstInt, DefIdTree, ParamConst, ScalarInt, Term, Ty, TyCtxt, TypeFoldable,\n@@ -607,7 +607,11 @@ pub trait PrettyPrinter<'tcx>:\n                         }\n                     }\n                 } else {\n-                    if verbose { p!(write(\"{:?}\", infer_ty)) } else { p!(write(\"{}\", infer_ty)) }\n+                    if verbose {\n+                        p!(write(\"{:?}\", infer_ty))\n+                    } else {\n+                        p!(write(\"{}\", infer_ty))\n+                    }\n                 }\n             }\n             ty::Error(_) => p!(\"[type error]\"),\n@@ -1224,7 +1228,7 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::ConstKind::Param(ParamConst { name, .. }) => p!(write(\"{}\", name)),\n             ty::ConstKind::Value(value) => {\n-                return self.pretty_print_const_value(value, ct.ty(), print_ty);\n+                return self.pretty_print_const_valtree(value, ct.ty(), print_ty);\n             }\n \n             ty::ConstKind::Bound(debruijn, bound_var) => {\n@@ -1262,7 +1266,7 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Ref(_, inner, _) => {\n                 if let ty::Array(elem, len) = inner.kind() {\n                     if let ty::Uint(ty::UintTy::U8) = elem.kind() {\n-                        if let ty::ConstKind::Value(ConstValue::Scalar(int)) = len.kind() {\n+                        if let ty::ConstKind::Value(ty::ValTree::Leaf(int)) = len.kind() {\n                             match self.tcx().get_global_alloc(alloc_id) {\n                                 Some(GlobalAlloc::Memory(alloc)) => {\n                                     let len = int.assert_bits(self.tcx().data_layout.pointer_size);\n@@ -1331,7 +1335,11 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Uint(_) | ty::Int(_) => {\n                 let int =\n                     ConstInt::new(int, matches!(ty.kind(), ty::Int(_)), ty.is_ptr_sized_integral());\n-                if print_ty { p!(write(\"{:#?}\", int)) } else { p!(write(\"{:?}\", int)) }\n+                if print_ty {\n+                    p!(write(\"{:#?}\", int))\n+                } else {\n+                    p!(write(\"{:?}\", int))\n+                }\n             }\n             // Char\n             ty::Char if char::try_from(int).is_ok() => {\n@@ -1408,85 +1416,64 @@ pub trait PrettyPrinter<'tcx>:\n         Ok(self)\n     }\n \n-    fn pretty_print_const_value(\n+    fn pretty_print_const_valtree(\n         mut self,\n-        ct: ConstValue<'tcx>,\n+        valtree: ty::ValTree<'tcx>,\n         ty: Ty<'tcx>,\n         print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n         if self.tcx().sess.verbose() {\n-            p!(write(\"ConstValue({:?}: \", ct), print(ty), \")\");\n+            p!(write(\"ValTree({:?}: \", valtree), print(ty), \")\");\n             return Ok(self);\n         }\n \n         let u8_type = self.tcx().types.u8;\n-\n-        match (ct, ty.kind()) {\n-            // Byte/string slices, printed as (byte) string literals.\n-            (ConstValue::Slice { data, start, end }, ty::Ref(_, inner, _)) => {\n-                match inner.kind() {\n-                    ty::Slice(t) => {\n-                        if *t == u8_type {\n-                            // The `inspect` here is okay since we checked the bounds, and there are\n-                            // no relocations (we have an active slice reference here). We don't use\n-                            // this result to affect interpreter execution.\n-                            let byte_str = data\n-                                .inner()\n-                                .inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n-                            return self.pretty_print_byte_str(byte_str);\n-                        }\n-                    }\n-                    ty::Str => {\n-                        // The `inspect` here is okay since we checked the bounds, and there are no\n-                        // relocations (we have an active `str` reference here). We don't use this\n-                        // result to affect interpreter execution.\n-                        let slice = data\n-                            .inner()\n-                            .inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n-                        p!(write(\"{:?}\", String::from_utf8_lossy(slice)));\n-                        return Ok(self);\n-                    }\n-                    _ => {}\n+        match (valtree, ty.kind()) {\n+            (ty::ValTree::Branch(_), ty::Ref(_, inner_ty, _)) => match inner_ty.kind() {\n+                ty::Slice(t) if *t == u8_type => {\n+                    let bytes = valtree.try_to_raw_bytes(self.tcx(), ty).unwrap_or_else(|| {\n+                        bug!(\n+                            \"expected to convert valtree {:?} to raw bytes for type {:?}\",\n+                            valtree,\n+                            t\n+                        )\n+                    });\n+                    return self.pretty_print_byte_str(bytes);\n                 }\n-            }\n-            (ConstValue::ByRef { alloc, offset }, ty::Array(t, n)) if *t == u8_type => {\n-                let n = n.kind().try_to_bits(self.tcx().data_layout.pointer_size).unwrap();\n-                // cast is ok because we already checked for pointer size (32 or 64 bit) above\n-                let range = AllocRange { start: offset, size: Size::from_bytes(n) };\n-\n-                let byte_str = alloc.inner().get_bytes(&self.tcx(), range).unwrap();\n+                ty::Str => {\n+                    let bytes = valtree.try_to_raw_bytes(self.tcx(), ty).unwrap_or_else(|| {\n+                        bug!(\"expected to convert valtree to raw bytes for type {:?}\", ty)\n+                    });\n+                    p!(write(\"{:?}\", String::from_utf8_lossy(bytes)));\n+                    return Ok(self);\n+                }\n+                _ => {}\n+            },\n+            (ty::ValTree::Branch(_), ty::Array(t, _)) if *t == u8_type => {\n+                let bytes = valtree.try_to_raw_bytes(self.tcx(), *t).unwrap_or_else(|| {\n+                    bug!(\"expected to convert valtree to raw bytes for type {:?}\", t)\n+                });\n                 p!(\"*\");\n-                p!(pretty_print_byte_str(byte_str));\n+                p!(pretty_print_byte_str(bytes));\n                 return Ok(self);\n             }\n-\n             // Aggregates, printed as array/tuple/struct/variant construction syntax.\n-            //\n-            // NB: the `has_param_types_or_consts` check ensures that we can use\n-            // the `destructure_const` query with an empty `ty::ParamEnv` without\n-            // introducing ICEs (e.g. via `layout_of`) from missing bounds.\n-            // E.g. `transmute([0usize; 2]): (u8, *mut T)` needs to know `T: Sized`\n-            // to be able to destructure the tuple into `(0u8, *mut T)\n-            //\n-            // FIXME(eddyb) for `--emit=mir`/`-Z dump-mir`, we should provide the\n-            // correct `ty::ParamEnv` to allow printing *all* constant values.\n-            (_, ty::Array(..) | ty::Tuple(..) | ty::Adt(..)) if !ty.has_param_types_or_consts() => {\n+            (ty::ValTree::Branch(_), ty::Array(..) | ty::Tuple(..) | ty::Adt(..))\n+                if !ty.has_param_types_or_consts() =>\n+            {\n                 let Some(contents) = self.tcx().try_destructure_const(\n-                    ty::ParamEnv::reveal_all()\n-                        .and(self.tcx().mk_const(ty::ConstS { kind: ty::ConstKind::Value(ct), ty })),\n+                    ty::Const::from_value(self.tcx(), valtree, ty)\n                 ) else {\n                     // Fall back to debug pretty printing for invalid constants.\n-                    p!(write(\"{:?}\", ct));\n+                    p!(write(\"{:?}\", valtree));\n                     if print_ty {\n                         p!(\": \", print(ty));\n                     }\n                     return Ok(self);\n                 };\n-\n                 let fields = contents.fields.iter().copied();\n-\n                 match *ty.kind() {\n                     ty::Array(..) => {\n                         p!(\"[\", comma_sep(fields), \"]\");\n@@ -1513,7 +1500,6 @@ pub trait PrettyPrinter<'tcx>:\n                             contents.variant.expect(\"destructed const of adt without variant idx\");\n                         let variant_def = &def.variant(variant_idx);\n                         p!(print_value_path(variant_def.def_id, substs));\n-\n                         match variant_def.ctor_kind {\n                             CtorKind::Const => {}\n                             CtorKind::Fn => {\n@@ -1535,21 +1521,20 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n                     _ => unreachable!(),\n                 }\n-\n                 return Ok(self);\n             }\n-\n-            (ConstValue::Scalar(scalar), _) => {\n-                return self.pretty_print_const_scalar(scalar, ty, print_ty);\n+            (ty::ValTree::Leaf(leaf), _) => {\n+                return self.pretty_print_const_scalar_int(leaf, ty, print_ty);\n             }\n-\n             // FIXME(oli-obk): also pretty print arrays and other aggregate constants by reading\n             // their fields instead of just dumping the memory.\n             _ => {}\n         }\n \n         // fallback\n-        p!(write(\"{:?}\", ct));\n+        if valtree != ty::ValTree::zst() {\n+            p!(write(\"{:?}\", valtree));\n+        }\n         if print_ty {\n             p!(\": \", print(ty));\n         }\n@@ -2296,7 +2281,6 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         Ok(inner)\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n     fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<'tcx, T>)\n     where\n         T: TypeFoldable<'tcx>,\n@@ -2309,9 +2293,8 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_, 'tcx> {\n             type BreakTy = ();\n \n-            #[instrument(skip(self), level = \"trace\")]\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                trace!(\"address: {:p}\", r.0.0);\n+                trace!(\"address: {:p}\", r.0 .0);\n                 if let ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) = *r {\n                     self.used_region_names.insert(name);\n                 } else if let ty::RePlaceholder(ty::PlaceholderRegion {\n@@ -2326,7 +2309,6 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n \n             // We collect types in order to prevent really large types from compiling for\n             // a really long time. See issue #83150 for why this is necessary.\n-            #[instrument(skip(self), level = \"trace\")]\n             fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 let not_previously_inserted = self.type_collector.insert(ty);\n                 if not_previously_inserted {\n@@ -2353,6 +2335,7 @@ where\n {\n     type Output = P;\n     type Error = P::Error;\n+\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n         cx.in_binder(self)\n     }"}, {"sha": "51980acd38f749d27d9923f747c6a31d2393ba05", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 64, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -4,7 +4,6 @@\n //! types or regions but can be other things. Examples of type relations are\n //! subtyping, type equality, etc.\n \n-use crate::mir::interpret::{get_slice_bytes, ConstValue, GlobalAlloc, Scalar};\n use crate::ty::error::{ExpectedFound, TypeError};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n use crate::ty::{self, ImplSubject, Term, Ty, TyCtxt, TypeFoldable};\n@@ -613,9 +612,7 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n \n         (ty::ConstKind::Param(a_p), ty::ConstKind::Param(b_p)) => a_p.index == b_p.index,\n         (ty::ConstKind::Placeholder(p1), ty::ConstKind::Placeholder(p2)) => p1 == p2,\n-        (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => {\n-            check_const_value_eq(relation, a_val, b_val, a, b)?\n-        }\n+        (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n \n         (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu))\n             if tcx.features().generic_const_exprs =>\n@@ -649,66 +646,6 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     if is_match { Ok(a) } else { Err(TypeError::ConstMismatch(expected_found(relation, a, b))) }\n }\n \n-fn check_const_value_eq<'tcx, R: TypeRelation<'tcx>>(\n-    relation: &mut R,\n-    a_val: ConstValue<'tcx>,\n-    b_val: ConstValue<'tcx>,\n-    // FIXME(oli-obk): these arguments should go away with valtrees\n-    a: ty::Const<'tcx>,\n-    b: ty::Const<'tcx>,\n-    // FIXME(oli-obk): this should just be `bool` with valtrees\n-) -> RelateResult<'tcx, bool> {\n-    let tcx = relation.tcx();\n-    Ok(match (a_val, b_val) {\n-        (ConstValue::Scalar(Scalar::Int(a_val)), ConstValue::Scalar(Scalar::Int(b_val))) => {\n-            a_val == b_val\n-        }\n-        (\n-            ConstValue::Scalar(Scalar::Ptr(a_val, _a_size)),\n-            ConstValue::Scalar(Scalar::Ptr(b_val, _b_size)),\n-        ) => {\n-            a_val == b_val\n-                || match (tcx.global_alloc(a_val.provenance), tcx.global_alloc(b_val.provenance)) {\n-                    (GlobalAlloc::Function(a_instance), GlobalAlloc::Function(b_instance)) => {\n-                        a_instance == b_instance\n-                    }\n-                    _ => false,\n-                }\n-        }\n-\n-        (ConstValue::Slice { .. }, ConstValue::Slice { .. }) => {\n-            get_slice_bytes(&tcx, a_val) == get_slice_bytes(&tcx, b_val)\n-        }\n-\n-        (ConstValue::ByRef { alloc: alloc_a, .. }, ConstValue::ByRef { alloc: alloc_b, .. })\n-            if a.ty().is_ref() || b.ty().is_ref() =>\n-        {\n-            if a.ty().is_ref() && b.ty().is_ref() {\n-                alloc_a == alloc_b\n-            } else {\n-                false\n-            }\n-        }\n-        (ConstValue::ByRef { .. }, ConstValue::ByRef { .. }) => {\n-            let a_destructured = tcx.destructure_const(relation.param_env().and(a));\n-            let b_destructured = tcx.destructure_const(relation.param_env().and(b));\n-\n-            // Both the variant and each field have to be equal.\n-            if a_destructured.variant == b_destructured.variant {\n-                for (a_field, b_field) in iter::zip(a_destructured.fields, b_destructured.fields) {\n-                    relation.consts(*a_field, *b_field)?;\n-                }\n-\n-                true\n-            } else {\n-                false\n-            }\n-        }\n-\n-        _ => false,\n-    })\n-}\n-\n impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,"}, {"sha": "3d6e50f0c0622ee1869e8b0feacdeb51374c9bf7", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,12 +1,16 @@\n //! See docs in build/expr/mod.rs\n \n-use crate::build::{lit_to_mir_constant, Builder};\n+use crate::build::{parse_float_into_constval, Builder};\n+use rustc_ast as ast;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::mir::interpret::{ConstValue, LitToConstError, LitToConstInput, Scalar};\n+use rustc_middle::mir::interpret::{\n+    Allocation, ConstValue, LitToConstError, LitToConstInput, Scalar,\n+};\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt};\n+use rustc_target::abi::Size;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n@@ -84,3 +88,54 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n }\n+\n+#[instrument(skip(tcx, lit_input))]\n+pub(crate) fn lit_to_mir_constant<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    lit_input: LitToConstInput<'tcx>,\n+) -> Result<ConstantKind<'tcx>, LitToConstError> {\n+    let LitToConstInput { lit, ty, neg } = lit_input;\n+    let trunc = |n| {\n+        let param_ty = ty::ParamEnv::reveal_all().and(ty);\n+        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n+        trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n+        let result = width.truncate(n);\n+        trace!(\"trunc result: {}\", result);\n+        Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n+    };\n+\n+    let value = match (lit, &ty.kind()) {\n+        (ast::LitKind::Str(s, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_str() => {\n+            let s = s.as_str();\n+            let allocation = Allocation::from_bytes_byte_aligned_immutable(s.as_bytes());\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n+        }\n+        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n+            if matches!(inner_ty.kind(), ty::Slice(_)) =>\n+        {\n+            let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n+        }\n+        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n+            let id = tcx.allocate_bytes(data);\n+            ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n+        }\n+        (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n+            ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n+        }\n+        (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n+            trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?\n+        }\n+        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n+            parse_float_into_constval(*n, *fty, neg).ok_or(LitToConstError::Reported)?\n+        }\n+        (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n+        (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n+        (ast::LitKind::Err(_), _) => return Err(LitToConstError::Reported),\n+        _ => return Err(LitToConstError::TypeError),\n+    };\n+\n+    Ok(ConstantKind::Val(value, ty))\n+}"}, {"sha": "51f7aa642c84fefb760c52eaa94f2c10cc40da38", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 64, "deletions": 54, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,7 +1,7 @@\n use crate::build;\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n-use crate::thir::constant::parse_float;\n+use crate::thir::constant::parse_float_into_scalar;\n use crate::thir::pattern::pat_from_hir;\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n@@ -14,14 +14,16 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::middle::region;\n-use rustc_middle::mir::interpret::Allocation;\n-use rustc_middle::mir::interpret::{ConstValue, LitToConstError, LitToConstInput, Scalar};\n+use rustc_middle::mir::interpret::{\n+    Allocation, ConstValue, LitToConstError, LitToConstInput, Scalar,\n+};\n use rustc_middle::mir::*;\n use rustc_middle::thir::{BindingMode, Expr, ExprId, LintLevel, LocalVarId, PatKind, Thir};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use rustc_span::Symbol;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n@@ -266,57 +268,6 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n     })\n }\n \n-#[instrument(skip(tcx, lit_input))]\n-pub(crate) fn lit_to_mir_constant<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    lit_input: LitToConstInput<'tcx>,\n-) -> Result<ConstantKind<'tcx>, LitToConstError> {\n-    let LitToConstInput { lit, ty, neg } = lit_input;\n-    let trunc = |n| {\n-        let param_ty = ty::ParamEnv::reveal_all().and(ty);\n-        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n-        trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n-        let result = width.truncate(n);\n-        trace!(\"trunc result: {}\", result);\n-        Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n-    };\n-\n-    let value = match (lit, &ty.kind()) {\n-        (ast::LitKind::Str(s, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_str() => {\n-            let s = s.as_str();\n-            let allocation = Allocation::from_bytes_byte_aligned_immutable(s.as_bytes());\n-            let allocation = tcx.intern_const_alloc(allocation);\n-            ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n-        }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n-            if matches!(inner_ty.kind(), ty::Slice(_)) =>\n-        {\n-            let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n-            let allocation = tcx.intern_const_alloc(allocation);\n-            ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n-        }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n-            let id = tcx.allocate_bytes(data);\n-            ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n-        }\n-        (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n-            ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n-        }\n-        (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n-            trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?\n-        }\n-        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n-            parse_float(*n, *fty, neg).ok_or(LitToConstError::Reported)?\n-        }\n-        (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n-        (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n-        (ast::LitKind::Err(_), _) => return Err(LitToConstError::Reported),\n-        _ => return Err(LitToConstError::TypeError),\n-    };\n-\n-    Ok(ConstantKind::Val(value, ty))\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n@@ -1137,6 +1088,65 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n }\n \n+fn parse_float_into_constval<'tcx>(\n+    num: Symbol,\n+    float_ty: ty::FloatTy,\n+    neg: bool,\n+) -> Option<ConstValue<'tcx>> {\n+    parse_float_into_scalar(num, float_ty, neg).map(ConstValue::Scalar)\n+}\n+\n+#[instrument(skip(tcx, lit_input))]\n+pub(crate) fn lit_to_mir_constant<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    lit_input: LitToConstInput<'tcx>,\n+) -> Result<ConstantKind<'tcx>, LitToConstError> {\n+    let LitToConstInput { lit, ty, neg } = lit_input;\n+    let trunc = |n| {\n+        let param_ty = ty::ParamEnv::reveal_all().and(ty);\n+        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n+        trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n+        let result = width.truncate(n);\n+        trace!(\"trunc result: {}\", result);\n+        Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n+    };\n+\n+    let value = match (lit, &ty.kind()) {\n+        (ast::LitKind::Str(s, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_str() => {\n+            let s = s.as_str();\n+            let allocation = Allocation::from_bytes_byte_aligned_immutable(s.as_bytes());\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n+        }\n+        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n+            if matches!(inner_ty.kind(), ty::Slice(_)) =>\n+        {\n+            let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n+        }\n+        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n+            let id = tcx.allocate_bytes(data);\n+            ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n+        }\n+        (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n+            ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n+        }\n+        (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n+            trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?\n+        }\n+        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n+            parse_float_into_constval(*n, *fty, neg).ok_or(LitToConstError::Reported)?\n+        }\n+        (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n+        (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n+        (ast::LitKind::Err(_), _) => return Err(LitToConstError::Reported),\n+        _ => return Err(LitToConstError::TypeError),\n+    };\n+\n+    Ok(ConstantKind::Val(value, ty))\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Builder methods are broken up into modules, depending on what kind\n // of thing is being lowered. Note that they use the `unpack` macro"}, {"sha": "cfb09ecedd635b976954d4fe578356268f211426", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,13 +1,10 @@\n+use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc_ast as ast;\n-use rustc_middle::mir::interpret::{\n-    Allocation, ConstValue, LitToConstError, LitToConstInput, Scalar,\n-};\n-use rustc_middle::ty::{self, ParamEnv, TyCtxt};\n+use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput, Scalar};\n+use rustc_middle::ty::{self, ParamEnv, ScalarInt, TyCtxt};\n use rustc_span::symbol::Symbol;\n-use rustc_target::abi::Size;\n \n-// FIXME Once valtrees are available, get rid of this function and the query\n pub(crate) fn lit_to_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     lit_input: LitToConstInput<'tcx>,\n@@ -20,58 +17,59 @@ pub(crate) fn lit_to_const<'tcx>(\n         trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n         let result = width.truncate(n);\n         trace!(\"trunc result: {}\", result);\n-        Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n+\n+        Ok(ScalarInt::try_from_uint(result, width)\n+            .unwrap_or_else(|| bug!(\"expected to create ScalarInt from uint {:?}\", result)))\n     };\n \n-    let lit = match (lit, &ty.kind()) {\n+    let valtree = match (lit, &ty.kind()) {\n         (ast::LitKind::Str(s, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_str() => {\n-            let s = s.as_str();\n-            let allocation = Allocation::from_bytes_byte_aligned_immutable(s.as_bytes());\n-            let allocation = tcx.intern_const_alloc(allocation);\n-            ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n+            let str_bytes = s.as_str().as_bytes();\n+            ty::ValTree::from_raw_bytes(tcx, str_bytes)\n         }\n         (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n             if matches!(inner_ty.kind(), ty::Slice(_)) =>\n         {\n-            let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n-            let allocation = tcx.intern_const_alloc(allocation);\n-            ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n+            let bytes = data as &[u8];\n+            ty::ValTree::from_raw_bytes(tcx, bytes)\n         }\n         (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n-            let id = tcx.allocate_bytes(data);\n-            ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n+            let bytes = data as &[u8];\n+            ty::ValTree::from_raw_bytes(tcx, bytes)\n         }\n         (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n-            ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n+            ty::ValTree::from_scalar_int((*n).into())\n         }\n         (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n-            trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?\n+            let scalar_int =\n+                trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?;\n+            ty::ValTree::from_scalar_int(scalar_int)\n         }\n         (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n-            parse_float(*n, *fty, neg).ok_or(LitToConstError::Reported)?\n+            parse_float_into_valtree(*n, *fty, neg).ok_or(LitToConstError::Reported)?\n         }\n-        (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n-        (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n+        (ast::LitKind::Bool(b), ty::Bool) => ty::ValTree::from_scalar_int((*b).into()),\n+        (ast::LitKind::Char(c), ty::Char) => ty::ValTree::from_scalar_int((*c).into()),\n         (ast::LitKind::Err(_), _) => return Err(LitToConstError::Reported),\n         _ => return Err(LitToConstError::TypeError),\n     };\n-    Ok(ty::Const::from_value(tcx, lit, ty))\n+\n+    Ok(ty::Const::from_value(tcx, valtree, ty))\n }\n \n-// FIXME move this to rustc_mir_build::build\n-pub(crate) fn parse_float<'tcx>(\n+pub(crate) fn parse_float_into_scalar(\n     num: Symbol,\n-    fty: ty::FloatTy,\n+    float_ty: ty::FloatTy,\n     neg: bool,\n-) -> Option<ConstValue<'tcx>> {\n+) -> Option<Scalar> {\n     let num = num.as_str();\n-    use rustc_apfloat::ieee::{Double, Single};\n-    let scalar = match fty {\n+    match float_ty {\n         ty::FloatTy::F32 => {\n             let Ok(rust_f) = num.parse::<f32>() else { return None };\n             let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n                 panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n             });\n+\n             assert!(\n                 u128::from(rust_f.to_bits()) == f.to_bits(),\n                 \"apfloat::ieee::Single gave different result for `{}`: \\\n@@ -82,16 +80,19 @@ pub(crate) fn parse_float<'tcx>(\n                 Single::from_bits(rust_f.to_bits().into()),\n                 rust_f.to_bits()\n             );\n+\n             if neg {\n                 f = -f;\n             }\n-            Scalar::from_f32(f)\n+\n+            Some(Scalar::from_f32(f))\n         }\n         ty::FloatTy::F64 => {\n             let Ok(rust_f) = num.parse::<f64>() else { return None };\n             let mut f = num.parse::<Double>().unwrap_or_else(|e| {\n                 panic!(\"apfloat::ieee::Double failed to parse `{}`: {:?}\", num, e)\n             });\n+\n             assert!(\n                 u128::from(rust_f.to_bits()) == f.to_bits(),\n                 \"apfloat::ieee::Double gave different result for `{}`: \\\n@@ -102,12 +103,20 @@ pub(crate) fn parse_float<'tcx>(\n                 Double::from_bits(rust_f.to_bits().into()),\n                 rust_f.to_bits()\n             );\n+\n             if neg {\n                 f = -f;\n             }\n-            Scalar::from_f64(f)\n+\n+            Some(Scalar::from_f64(f))\n         }\n-    };\n+    }\n+}\n \n-    Some(ConstValue::Scalar(scalar))\n+fn parse_float_into_valtree<'tcx>(\n+    num: Symbol,\n+    float_ty: ty::FloatTy,\n+    neg: bool,\n+) -> Option<ty::ValTree<'tcx>> {\n+    parse_float_into_scalar(num, float_ty, neg).map(|s| ty::ValTree::Leaf(s.try_to_int().unwrap()))\n }"}, {"sha": "b423c645447472b02be080cd0c1c10359d692b9b", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -371,6 +371,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n                 let destructured = tcx.destructure_mir_constant(param_env, cv);\n+\n                 PatKind::Variant {\n                     adt_def: *adt_def,\n                     substs,\n@@ -502,7 +503,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // deref pattern.\n                 _ => {\n                     if !pointee_ty.is_sized(tcx.at(span), param_env) {\n-                        // `tcx.deref_const()` below will ICE with an unsized type\n+                        // `tcx.deref_mirconstant()` below will ICE with an unsized type\n                         // (except slices, which are handled in a separate arm above).\n                         let msg = format!(\"cannot use unsized non-slice type `{}` in constant patterns\", pointee_ty);\n                         if self.include_lint_checks {"}, {"sha": "e28cb67217c89aabf6745746832c3400854cf5d2", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -185,11 +185,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n             (Some(PatKind::Constant { value: lo }), None) => {\n                 let hi = ty.numeric_max_val(self.tcx)?;\n-                Some((*lo, hi.into()))\n+                Some((*lo, mir::ConstantKind::from_const(hi, self.tcx)))\n             }\n             (None, Some(PatKind::Constant { value: hi })) => {\n                 let lo = ty.numeric_min_val(self.tcx)?;\n-                Some((lo.into(), *hi))\n+                Some((mir::ConstantKind::from_const(lo, self.tcx), *hi))\n             }\n             _ => None,\n         }\n@@ -798,11 +798,12 @@ pub(crate) fn compare_const_vals<'tcx>(\n     if let ty::Str = ty.kind() && let (\n         Some(a_val @ ConstValue::Slice { .. }),\n         Some(b_val @ ConstValue::Slice { .. }),\n-    ) = (a.try_val(), b.try_val())\n+    ) = (a.try_val(tcx), b.try_val(tcx))\n     {\n         let a_bytes = get_slice_bytes(&tcx, a_val);\n         let b_bytes = get_slice_bytes(&tcx, b_val);\n         return from_bool(a_bytes == b_bytes);\n     }\n+\n     fallback()\n }"}, {"sha": "8d16c5f22c3f4ab31cfccfa3bf7b6fc8c9ece0b1", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1032,7 +1032,7 @@ where\n         Operand::Constant(Box::new(Constant {\n             span: self.source_info.span,\n             user_ty: None,\n-            literal: ty::Const::from_usize(self.tcx(), val.into()).into(),\n+            literal: ConstantKind::from_usize(self.tcx(), val.into()),\n         }))\n     }\n "}, {"sha": "8944ebed9a70487063c2adf9c7a38779528cc768", "filename": "compiler/rustc_mir_transform/src/const_debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_debuginfo.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -19,7 +19,7 @@ impl<'tcx> MirPass<'tcx> for ConstDebugInfo {\n         sess.opts.debugging_opts.unsound_mir_opts && sess.mir_opt_level() > 0\n     }\n \n-    fn run_pass(&self, _: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         trace!(\"running ConstDebugInfo on {:?}\", body.source);\n \n         for (local, constant) in find_optimization_oportunities(body) {"}, {"sha": "412a5b4fc9104d2d083bdd979031038ab18e6eb4", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -67,6 +67,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         true\n     }\n \n+    #[instrument(skip(self, tcx), level = \"debug\")]\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // will be evaluated by miri and produce its errors there\n         if body.source.promoted.is_some() {\n@@ -687,7 +688,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Operand::Constant(Box::new(Constant {\n             span,\n             user_ty: None,\n-            literal: ty::Const::from_scalar(self.tcx, scalar, ty).into(),\n+            literal: ConstantKind::from_scalar(self.tcx, scalar, ty),\n         }))\n     }\n \n@@ -765,20 +766,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             if let Some(Some(alloc)) = alloc {\n                                 // Assign entire constant in a single statement.\n                                 // We can't use aggregates, as we run after the aggregate-lowering `MirPhase`.\n+                                let const_val = ConstValue::ByRef { alloc, offset: Size::ZERO };\n+                                let literal = ConstantKind::Val(const_val, ty);\n                                 *rval = Rvalue::Use(Operand::Constant(Box::new(Constant {\n                                     span: source_info.span,\n                                     user_ty: None,\n-                                    literal: self\n-                                        .ecx\n-                                        .tcx\n-                                        .mk_const(ty::ConstS {\n-                                            ty,\n-                                            kind: ty::ConstKind::Value(ConstValue::ByRef {\n-                                                alloc,\n-                                                offset: Size::ZERO,\n-                                            }),\n-                                        })\n-                                        .into(),\n+                                    literal,\n                                 })));\n                             }\n                         }"}, {"sha": "e0e27c53f1822e22b7dbb11bd3cd396ed86da5bf", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -470,7 +470,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         Rvalue::Use(Operand::Constant(Box::new(Constant {\n             span,\n             user_ty: None,\n-            literal: ty::Const::from_bool(self.tcx, val).into(),\n+            literal: ConstantKind::from_bool(self.tcx, val),\n         })))\n     }\n "}, {"sha": "f3c67319596d14397e21e9db08fcf4b8aebdc51b", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -991,7 +991,7 @@ fn insert_panic_block<'tcx>(\n         cond: Operand::Constant(Box::new(Constant {\n             span: body.span,\n             user_ty: None,\n-            literal: ty::Const::from_bool(tcx, false).into(),\n+            literal: ConstantKind::from_bool(tcx, false),\n         })),\n         expected: true,\n         msg: message,"}, {"sha": "ea10ec5f25c1577282e45920e06ae824f9d14258", "filename": "compiler/rustc_mir_transform/src/instcombine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -3,8 +3,8 @@\n use crate::MirPass;\n use rustc_hir::Mutability;\n use rustc_middle::mir::{\n-    BinOp, Body, Constant, LocalDecls, Operand, Place, ProjectionElem, Rvalue, SourceInfo,\n-    Statement, StatementKind, Terminator, TerminatorKind, UnOp,\n+    BinOp, Body, Constant, ConstantKind, LocalDecls, Operand, Place, ProjectionElem, Rvalue,\n+    SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UnOp,\n };\n use rustc_middle::ty::{self, TyCtxt};\n \n@@ -129,8 +129,8 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n                     return;\n                 }\n \n-                let constant =\n-                    Constant { span: source_info.span, literal: len.into(), user_ty: None };\n+                let literal = ConstantKind::from_const(len, self.tcx);\n+                let constant = Constant { span: source_info.span, literal, user_ty: None };\n                 *rvalue = Rvalue::Use(Operand::Constant(Box::new(constant)));\n             }\n         }"}, {"sha": "b89322514657898a84fa01274c030f4867b88ecf", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -531,8 +531,10 @@ fn inner_optimized_mir(tcx: TyCtxt<'_>, did: LocalDefId) -> Body<'_> {\n         None => {}\n         Some(other) => panic!(\"do not use `optimized_mir` for constants: {:?}\", other),\n     }\n+    debug!(\"about to call mir_drops_elaborated...\");\n     let mut body =\n         tcx.mir_drops_elaborated_and_const_checked(ty::WithOptConstParam::unknown(did)).steal();\n+    debug!(\"body: {:#?}\", body);\n     run_optimization_passes(tcx, &mut body);\n \n     debug_assert!(!body.has_free_regions(), \"Free regions in optimized MIR\");"}, {"sha": "989b94b68c101443ba50c6776d270822e2eb0f7a", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                                     Rvalue::Use(Operand::Constant(Box::new(Constant {\n                                         span: terminator.source_info.span,\n                                         user_ty: None,\n-                                        literal: ty::Const::zero_sized(tcx, tcx.types.unit).into(),\n+                                        literal: ConstantKind::zero_sized(tcx.types.unit),\n                                     }))),\n                                 ))),\n                             });"}, {"sha": "89808d3d4cdbd9c9056c358806eb64daf951f34c", "filename": "compiler/rustc_mir_transform/src/remove_noop_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -15,7 +15,7 @@ impl<'tcx> MirPass<'tcx> for RemoveNoopLandingPads {\n         sess.panic_strategy() != PanicStrategy::Abort\n     }\n \n-    fn run_pass(&self, _: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"remove_noop_landing_pads({:?})\", body);\n         self.remove_nop_landing_pads(body)\n     }\n@@ -81,6 +81,8 @@ impl RemoveNoopLandingPads {\n     }\n \n     fn remove_nop_landing_pads(&self, body: &mut Body<'_>) {\n+        debug!(\"body: {:#?}\", body);\n+\n         // make sure there's a single resume block\n         let resume_block = {\n             let patch = MirPatch::new(body);"}, {"sha": "3be1783ae3389ad6b1061af775b473d6a38dab23", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -430,7 +430,7 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n         let func = Operand::Constant(Box::new(Constant {\n             span: self.span,\n             user_ty: None,\n-            literal: ty::Const::zero_sized(tcx, func_ty).into(),\n+            literal: ConstantKind::zero_sized(func_ty),\n         }));\n \n         let ref_loc = self.make_place(\n@@ -630,7 +630,7 @@ fn build_call_shim<'tcx>(\n                 Operand::Constant(Box::new(Constant {\n                     span,\n                     user_ty: None,\n-                    literal: ty::Const::zero_sized(tcx, ty).into(),\n+                    literal: ConstantKind::zero_sized(ty),\n                 })),\n                 rcvr.into_iter().collect::<Vec<_>>(),\n             )"}, {"sha": "2af22e129a5f7e67373de4020f5898bbb3c813d1", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -323,6 +323,7 @@ impl<'tcx> InliningMap<'tcx> {\n     }\n }\n \n+#[instrument(skip(tcx, mode), level = \"debug\")]\n pub fn collect_crate_mono_items(\n     tcx: TyCtxt<'_>,\n     mode: MonoItemCollectionMode,\n@@ -362,6 +363,7 @@ pub fn collect_crate_mono_items(\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n+#[instrument(skip(tcx, mode), level = \"debug\")]\n fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<'_>> {\n     debug!(\"collecting roots\");\n     let mut roots = MonoItems { compute_inlining: false, tcx, items: Vec::new() };\n@@ -400,6 +402,7 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n \n /// Collect all monomorphized items reachable from `starting_point`, and emit a note diagnostic if a\n /// post-monorphization error is encountered during a collection step.\n+#[instrument(skip(tcx, visited, recursion_depths, recursion_limit, inlining_map), level = \"debug\")]\n fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     starting_point: Spanned<MonoItem<'tcx>>,\n@@ -752,13 +755,15 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     /// This does not walk the constant, as it has been handled entirely here and trying\n     /// to walk it would attempt to evaluate the `ty::Const` inside, which doesn't necessarily\n     /// work, as some constants cannot be represented in the type system.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn visit_constant(&mut self, constant: &mir::Constant<'tcx>, location: Location) {\n         let literal = self.monomorphize(constant.literal);\n         let val = match literal {\n             mir::ConstantKind::Val(val, _) => val,\n             mir::ConstantKind::Ty(ct) => match ct.kind() {\n-                ty::ConstKind::Value(val) => val,\n+                ty::ConstKind::Value(val) => self.tcx.valtree_to_const_val((ct.ty(), val)),\n                 ty::ConstKind::Unevaluated(ct) => {\n+                    debug!(?ct);\n                     let param_env = ty::ParamEnv::reveal_all();\n                     match self.tcx.const_eval_resolve(param_env, ct, None) {\n                         // The `monomorphize` call should have evaluated that constant already.\n@@ -778,14 +783,18 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.visit_ty(literal.ty(), TyContext::Location(location));\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn visit_const(&mut self, constant: ty::Const<'tcx>, location: Location) {\n         debug!(\"visiting const {:?} @ {:?}\", constant, location);\n \n         let substituted_constant = self.monomorphize(constant);\n         let param_env = ty::ParamEnv::reveal_all();\n \n         match substituted_constant.kind() {\n-            ty::ConstKind::Value(val) => collect_const_value(self.tcx, val, self.output),\n+            ty::ConstKind::Value(val) => {\n+                let const_val = self.tcx.valtree_to_const_val((constant.ty(), val));\n+                collect_const_value(self.tcx, const_val, self.output)\n+            }\n             ty::ConstKind::Unevaluated(unevaluated) => {\n                 match self.tcx.const_eval_resolve(param_env, unevaluated, None) {\n                     // The `monomorphize` call should have evaluated that constant already.\n@@ -1120,6 +1129,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     }\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n fn create_fn_mono_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n@@ -1133,7 +1143,10 @@ fn create_fn_mono_item<'tcx>(\n         crate::util::dump_closure_profile(tcx, instance);\n     }\n \n-    respan(source, MonoItem::Fn(instance.polymorphize(tcx)))\n+    let respanned = respan(source, MonoItem::Fn(instance.polymorphize(tcx)));\n+    debug!(?respanned);\n+\n+    respanned\n }\n \n /// Creates a `MonoItem` for each method that is referenced by the vtable for\n@@ -1275,6 +1288,7 @@ impl<'v> RootCollector<'_, 'v> {\n \n     /// If `def_id` represents a root, pushes it onto the list of\n     /// outputs. (Note that all roots must be monomorphic.)\n+    #[instrument(skip(self), level = \"debug\")]\n     fn push_if_root(&mut self, def_id: LocalDefId) {\n         if self.is_root(def_id) {\n             debug!(\"RootCollector::push_if_root: found root def_id={:?}\", def_id);\n@@ -1415,17 +1429,17 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut MonoIte\n }\n \n /// Scans the MIR in order to find function calls, closures, and drop-glue.\n+#[instrument(skip(tcx, output), level = \"debug\")]\n fn collect_neighbours<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n     output: &mut MonoItems<'tcx>,\n ) {\n-    debug!(\"collect_neighbours: {:?}\", instance.def_id());\n     let body = tcx.instance_mir(instance.def);\n-\n     MirNeighborCollector { tcx, body: &body, output, instance }.visit_body(&body);\n }\n \n+#[instrument(skip(tcx, output), level = \"debug\")]\n fn collect_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     value: ConstValue<'tcx>,"}, {"sha": "f67b87a6a52b8e08d0d526ffa6d4d5c0b2ca8705", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,7 +1,6 @@\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::CrateNum;\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n-use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::print::{PrettyPrinter, Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt, TypeFoldable};\n@@ -30,6 +29,7 @@ pub(super) fn mangle<'tcx>(\n         match key.disambiguated_data.data {\n             DefPathData::TypeNs(_) | DefPathData::ValueNs(_) => {\n                 instance_ty = tcx.type_of(ty_def_id);\n+                debug!(?instance_ty);\n                 break;\n             }\n             _ => {\n@@ -261,10 +261,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolPrinter<'tcx> {\n     fn print_const(self, ct: ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n         // only print integers\n         match (ct.kind(), ct.ty().kind()) {\n-            (\n-                ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(scalar))),\n-                ty::Int(_) | ty::Uint(_),\n-            ) => {\n+            (ty::ConstKind::Value(ty::ValTree::Leaf(scalar)), ty::Int(_) | ty::Uint(_)) => {\n                 // The `pretty_print_const` formatting depends on -Zverbose\n                 // flag, so we cannot reuse it here.\n                 let signed = matches!(ct.ty().kind(), ty::Int(_));"}, {"sha": "ff07063679746392e98b8bb4e2cb0d4c893a95f5", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 50, "deletions": 38, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -5,7 +5,6 @@ use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n-use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::print::{Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n@@ -604,16 +603,18 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n         if let Some(&i) = self.consts.get(&ct) {\n             return self.print_backref(i);\n         }\n+\n         let start = self.out.len();\n+        let ty = ct.ty();\n \n-        match ct.ty().kind() {\n+        match ty.kind() {\n             ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Char => {\n-                self = ct.ty().print(self)?;\n+                self = ty.print(self)?;\n \n-                let mut bits = ct.eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ct.ty());\n+                let mut bits = ct.eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ty);\n \n                 // Negative integer values are mangled using `n` as a \"sign prefix\".\n-                if let ty::Int(ity) = ct.ty().kind() {\n+                if let ty::Int(ity) = ty.kind() {\n                     let val =\n                         Integer::from_int_ty(&self.tcx, *ity).size().sign_extend(bits) as i128;\n                     if val < 0 {\n@@ -626,45 +627,57 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n             }\n \n             // HACK(eddyb) because `ty::Const` only supports sized values (for now),\n-            // we can't use `deref_const` + supporting `str`, we have to specially\n+            // we can't use dereference the const + supporting `str`, we have to specially\n             // handle `&str` and include both `&` (\"R\") and `str` (\"e\") prefixes.\n-            ty::Ref(_, ty, hir::Mutability::Not) if *ty == self.tcx.types.str_ => {\n-                self.push(\"R\");\n-                match ct.kind() {\n-                    ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => {\n-                        // NOTE(eddyb) the following comment was kept from `ty::print::pretty`:\n-                        // The `inspect` here is okay since we checked the bounds, and there are no\n-                        // relocations (we have an active `str` reference here). We don't use this\n-                        // result to affect interpreter execution.\n-                        let slice = data\n-                            .inner()\n-                            .inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n-                        let s = std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n-\n-                        self.push(\"e\");\n-                        // FIXME(eddyb) use a specialized hex-encoding loop.\n-                        for byte in s.bytes() {\n-                            let _ = write!(self.out, \"{:02x}\", byte);\n+            ty::Ref(_, inner_ty, mutbl) => {\n+                self.push(match mutbl {\n+                    hir::Mutability::Not => \"R\",\n+                    hir::Mutability::Mut => \"Q\",\n+                });\n+\n+                match inner_ty.kind() {\n+                    ty::Str if *mutbl == hir::Mutability::Not => {\n+                        match ct.kind() {\n+                            ty::ConstKind::Value(valtree) => {\n+                                let slice =\n+                                    valtree.try_to_raw_bytes(self.tcx(), ty).unwrap_or_else(|| {\n+                                        bug!(\n+                                        \"expected to get raw bytes from valtree {:?} for type {:}\",\n+                                        valtree, ty\n+                                    )\n+                                    });\n+                                let s = std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n+\n+                                self.push(\"e\");\n+\n+                                // FIXME(eddyb) use a specialized hex-encoding loop.\n+                                for byte in s.bytes() {\n+                                    let _ = write!(self.out, \"{:02x}\", byte);\n+                                }\n+\n+                                self.push(\"_\");\n+                            }\n+\n+                            _ => {\n+                                bug!(\"symbol_names: unsupported `&str` constant: {:?}\", ct);\n+                            }\n                         }\n-                        self.push(\"_\");\n                     }\n-\n                     _ => {\n-                        bug!(\"symbol_names: unsupported `&str` constant: {:?}\", ct);\n+                        let pointee_ty = ct\n+                            .ty()\n+                            .builtin_deref(true)\n+                            .expect(\"tried to dereference on non-ptr type\")\n+                            .ty;\n+                        let dereferenced_const =\n+                            self.tcx.mk_const(ty::ConstS { val: ct.val(), ty: pointee_ty });\n+                        self = dereferenced_const.print(self)?;\n                     }\n                 }\n             }\n \n-            ty::Ref(_, _, mutbl) => {\n-                self.push(match mutbl {\n-                    hir::Mutability::Not => \"R\",\n-                    hir::Mutability::Mut => \"Q\",\n-                });\n-                self = self.tcx.deref_const(ty::ParamEnv::reveal_all().and(ct)).print(self)?;\n-            }\n-\n-            ty::Array(..) | ty::Tuple(..) | ty::Adt(..) => {\n-                let contents = self.tcx.destructure_const(ty::ParamEnv::reveal_all().and(ct));\n+            ty::Array(..) | ty::Tuple(..) | ty::Adt(..) | ty::Slice(_) => {\n+                let contents = self.tcx.destructure_const(ct);\n                 let fields = contents.fields.iter().copied();\n \n                 let print_field_list = |mut this: Self| {\n@@ -676,7 +689,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                 };\n \n                 match *ct.ty().kind() {\n-                    ty::Array(..) => {\n+                    ty::Array(..) | ty::Slice(_) => {\n                         self.push(\"A\");\n                         self = print_field_list(self)?;\n                     }\n@@ -723,7 +736,6 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                     _ => unreachable!(),\n                 }\n             }\n-\n             _ => {\n                 bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\", ct.ty(), ct);\n             }"}, {"sha": "a63790b594d83cbb982dc5418f6c305da1849d6a", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -6,6 +6,7 @@ use super::*;\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxt;\n use crate::traits::project::ProjectAndUnifyResult;\n+use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::{Region, RegionVid, Term};\n \n@@ -834,7 +835,16 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                                 unevaluated,\n                                 Some(obligation.cause.span),\n                             ) {\n-                                Ok(val) => Ok(ty::Const::from_value(select.tcx(), val, c.ty())),\n+                                Ok(Some(valtree)) => {\n+                                    Ok(ty::Const::from_value(select.tcx(), valtree, c.ty()))\n+                                }\n+                                Ok(None) => {\n+                                    let tcx = self.tcx;\n+                                    let def_id = unevaluated.def.did;\n+                                    let reported = tcx.sess.struct_span_err(tcx.def_span(def_id), &format!(\"unable to construct a constant value for the unevaluated constant {:?}\", unevaluated)).emit();\n+\n+                                    Err(ErrorHandled::Reported(reported))\n+                                }\n                                 Err(err) => Err(err),\n                             }\n                         } else {"}, {"sha": "5d08ea99ac64a2975c3917fda763de80518eae22", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -13,9 +13,7 @@ use rustc_hir::def::DefKind;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{\n-    ConstValue, ErrorHandled, LitToConstError, LitToConstInput, Scalar,\n-};\n+use rustc_middle::mir::interpret::{ErrorHandled, LitToConstError, LitToConstInput};\n use rustc_middle::thir;\n use rustc_middle::thir::abstract_const::{self, Node, NodeId, NotConstEvaluatable};\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n@@ -449,9 +447,8 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 self.nodes.push(Node::Leaf(constant))\n             }\n             &ExprKind::NonHirLiteral { lit , user_ty: _} => {\n-                // FIXME Construct a Valtree from this ScalarInt when introducing Valtrees\n-                let const_value = ConstValue::Scalar(Scalar::Int(lit));\n-                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, const_value, node.ty)))\n+                let val = ty::ValTree::from_scalar_int(lit);\n+                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n             }\n             &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n                 let uneval = ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs);"}, {"sha": "7c4b5decee4f499a8f4c9e395bb7a5ff66965ef7", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -407,7 +407,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     let pred =\n                         ty::Binder::dummy(infcx.replace_bound_vars_with_placeholders(binder));\n                     ProcessResult::Changed(mk_pending(vec![\n-                        obligation.with(pred.to_predicate(self.selcx.tcx())),\n+                        obligation.with(pred.to_predicate(self.selcx.tcx()))\n                     ]))\n                 }\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n@@ -594,22 +594,24 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n \n                     let mut evaluate = |c: Const<'tcx>| {\n                         if let ty::ConstKind::Unevaluated(unevaluated) = c.kind() {\n-                            match self.selcx.infcx().const_eval_resolve(\n+                            match self.selcx.infcx().try_const_eval_resolve(\n                                 obligation.param_env,\n                                 unevaluated,\n+                                c.ty(),\n                                 Some(obligation.cause.span),\n                             ) {\n-                                Ok(val) => Ok(Const::from_value(self.selcx.tcx(), val, c.ty())),\n-                                Err(ErrorHandled::TooGeneric) => {\n-                                    stalled_on.extend(\n-                                        unevaluated\n-                                            .substs\n-                                            .iter()\n-                                            .filter_map(TyOrConstInferVar::maybe_from_generic_arg),\n-                                    );\n-                                    Err(ErrorHandled::TooGeneric)\n-                                }\n-                                Err(err) => Err(err),\n+                                Ok(val) => Ok(val),\n+                                Err(e) => match e {\n+                                    ErrorHandled::TooGeneric => {\n+                                        stalled_on.extend(\n+                                            unevaluated.substs.iter().filter_map(\n+                                                TyOrConstInferVar::maybe_from_generic_arg,\n+                                            ),\n+                                        );\n+                                        Err(ErrorHandled::TooGeneric)\n+                                    }\n+                                    _ => Err(e),\n+                                },\n                             }\n                         } else {\n                             Ok(c)"}, {"sha": "a72f90746edfa70b0d19ab18191d5da18ddcf623", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -618,11 +618,14 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn fold_const(&mut self, constant: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         if self.selcx.tcx().lazy_normalization() || !self.eager_inference_replacement {\n             constant\n         } else {\n             let constant = constant.super_fold_with(self);\n+            debug!(?constant);\n+            debug!(\"self.param_env: {:?}\", self.param_env);\n             constant.eval(self.selcx.tcx(), self.param_env)\n         }\n     }"}, {"sha": "b80a27eb07d061373d5620dc72a4b80fe24dd29c", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -100,7 +100,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n     }\n }\n \n-/// Visitor to find the maximum escaping bound var\n+// Visitor to find the maximum escaping bound var\n struct MaxEscapingBoundVarVisitor {\n     // The index which would count as escaping\n     outer_index: ty::DebruijnIndex,\n@@ -336,12 +336,15 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n     ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         Ok(match constant {\n             mir::ConstantKind::Ty(c) => {\n-                let const_folded = c.try_fold_with(self)?;\n+                let const_folded = c.try_super_fold_with(self)?;\n                 match const_folded.kind() {\n-                    ty::ConstKind::Value(cv) => {\n-                        // FIXME With Valtrees we need to convert `cv: ValTree`\n-                        // to a `ConstValue` here.\n-                        mir::ConstantKind::Val(cv, const_folded.ty())\n+                    ty::ConstKind::Value(valtree) => {\n+                        let tcx = self.infcx.tcx;\n+                        let ty = const_folded.ty();\n+                        let const_val = tcx.valtree_to_const_val((ty, valtree));\n+                        debug!(?ty, ?valtree, ?const_val);\n+\n+                        mir::ConstantKind::Val(const_val, ty)\n                     }\n                     _ => mir::ConstantKind::Ty(const_folded),\n                 }"}, {"sha": "a002006f0e67674d99910cca714a602082dd15ac", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -636,13 +636,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     let evaluate = |c: ty::Const<'tcx>| {\n                         if let ty::ConstKind::Unevaluated(unevaluated) = c.kind() {\n-                            self.infcx\n-                                .const_eval_resolve(\n-                                    obligation.param_env,\n-                                    unevaluated,\n-                                    Some(obligation.cause.span),\n-                                )\n-                                .map(|val| ty::Const::from_value(self.tcx(), val, c.ty()))\n+                            match self.infcx.try_const_eval_resolve(\n+                                obligation.param_env,\n+                                unevaluated,\n+                                c.ty(),\n+                                Some(obligation.cause.span),\n+                            ) {\n+                                Ok(val) => Ok(val),\n+                                Err(e) => Err(e),\n+                            }\n                         } else {\n                             Ok(c)\n                         }\n@@ -2576,7 +2578,11 @@ impl<'o, 'tcx> TraitObligationStackList<'o, 'tcx> {\n     }\n \n     fn depth(&self) -> usize {\n-        if let Some(head) = self.head { head.depth } else { 0 }\n+        if let Some(head) = self.head {\n+            head.depth\n+        } else {\n+            0\n+        }\n     }\n }\n "}, {"sha": "5d394ed2263ffc8141c96414eb02c4675acaed62", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -25,7 +25,6 @@ pub(crate) fn provide(p: &mut Providers) {\n     };\n }\n \n-#[instrument(level = \"debug\", skip(tcx))]\n fn try_normalize_after_erasing_regions<'tcx, T: TypeFoldable<'tcx> + PartialEq + Copy>(\n     tcx: TyCtxt<'tcx>,\n     goal: ParamEnvAnd<'tcx, T>,"}, {"sha": "552db5406df8d3ac6c0c33f2c6dda3a71b8cf065", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -112,7 +112,6 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n     }\n }\n \n-#[instrument(level = \"debug\", skip(tcx))]\n fn resolve_instance<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, (DefId, SubstsRef<'tcx>)>,\n@@ -141,7 +140,6 @@ fn resolve_instance_of_const_arg<'tcx>(\n     )\n }\n \n-#[instrument(level = \"debug\", skip(tcx))]\n fn inner_resolve_instance<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>)>,"}, {"sha": "7125a7578bd8155ecaba7ac85f9d0a38cbe5f311", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -15,7 +15,6 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -264,13 +263,13 @@ pub(crate) fn print_const(cx: &DocContext<'_>, n: ty::Const<'_>) -> String {\n }\n \n pub(crate) fn print_evaluated_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<String> {\n-    tcx.const_eval_poly(def_id).ok().and_then(|val| {\n+    tcx.const_eval_poly_for_typeck(def_id).ok().and_then(|val| {\n         let ty = tcx.type_of(def_id);\n         match (val, ty.kind()) {\n             (_, &ty::Ref(..)) => None,\n-            (ConstValue::Scalar(_), &ty::Adt(_, _)) => None,\n-            (ConstValue::Scalar(_), _) => {\n-                let const_ = ty::Const::from_value(tcx, val, ty);\n+            (Some(ty::ValTree::Branch(_)), &ty::Adt(_, _)) => None,\n+            (Some(ty::ValTree::Leaf(_)), _) => {\n+                let const_ = ty::Const::from_value(tcx, val.unwrap(), ty);\n                 Some(print_const_with_custom_print_scalar(tcx, const_))\n             }\n             _ => None,\n@@ -308,10 +307,10 @@ fn print_const_with_custom_print_scalar(tcx: TyCtxt<'_>, ct: ty::Const<'_>) -> S\n     // Use a slightly different format for integer types which always shows the actual value.\n     // For all other types, fallback to the original `pretty_print_const`.\n     match (ct.kind(), ct.ty().kind()) {\n-        (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Uint(ui)) => {\n+        (ty::ConstKind::Value(ty::ValTree::Leaf(int)), ty::Uint(ui)) => {\n             format!(\"{}{}\", format_integer_with_underscore_sep(&int.to_string()), ui.name_str())\n         }\n-        (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Int(i)) => {\n+        (ty::ConstKind::Value(ty::ValTree::Leaf(int)), ty::Int(i)) => {\n             let ty = tcx.lift(ct.ty()).unwrap();\n             let size = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size;\n             let data = int.assert_bits(size);"}, {"sha": "d32df9544997e628b9c466fb4ddabd4b67795137", "filename": "src/test/incremental/issue-54242.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fincremental%2Fissue-54242.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fincremental%2Fissue-54242.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-54242.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -14,7 +14,7 @@ impl Tr for str {\n     type Arr = [u8; 8];\n     #[cfg(cfail)]\n     type Arr = [u8; Self::C];\n-    //[cfail]~^ ERROR cycle detected when simplifying constant\n+    //[cfail]~^ ERROR cycle detected when evaluate type-level constant\n }\n \n fn main() {}"}, {"sha": "d23203742f07be35e6b4fd48ca2e9ee1c1a68ef6", "filename": "src/test/mir-opt/box_expr.main.ElaborateDrops.before.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fbox_expr.main.ElaborateDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fbox_expr.main.ElaborateDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbox_expr.main.ElaborateDrops.before.mir?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -19,10 +19,10 @@ fn main() -> () {\n         StorageLive(_1);                 // scope 0 at $DIR/box_expr.rs:7:9: 7:10\n         _2 = SizeOf(S);                  // scope 2 at $DIR/box_expr.rs:7:13: 7:25\n         _3 = AlignOf(S);                 // scope 2 at $DIR/box_expr.rs:7:13: 7:25\n-        _4 = alloc::alloc::exchange_malloc(move _2, move _3) -> bb1; // scope 2 at $DIR/box_expr.rs:7:13: 7:25\n+        _4 = : unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}(move _2, move _3) -> bb1; // scope 2 at $DIR/box_expr.rs:7:13: 7:25\n                                          // mir::Constant\n                                          // + span: $DIR/box_expr.rs:7:13: 7:25\n-                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(Scalar(<ZST>)) }\n+                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(ValTree::Branch(..)) }\n     }\n \n     bb1: {"}, {"sha": "e2acd610b80530cf6c0e4909d089c7cd33455a19", "filename": "src/test/mir-opt/const_allocation2.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -21,44 +21,44 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc28\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc22\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc28 (size: 72, align: 8) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc22 (size: 72, align: 8) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc26\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc20\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n-alloc13 (size: 0, align: 8) {}\n+alloc9 (size: 0, align: 8) {}\n \n-alloc18 (size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc16\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc17\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc14 (size: 16, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc16 (size: 1, align: 1) {\n+alloc12 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc17 (size: 1, align: 1) {\n+alloc13 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc26 (size: 24, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc22+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc23\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc25+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc20 (size: 24, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc17+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc19+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc22 (size: 4, align: 1) {\n+alloc17 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc23 (size: 1, align: 1) {\n+alloc18 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc25 (size: 4, align: 1) {\n+alloc19 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "6a490e48b8ed34c6e42fd5af27ce4cbbf3129a47", "filename": "src/test/mir-opt/const_prop/boxes.main.ConstProp.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.main.ConstProp.diff?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -22,13 +22,13 @@\n           StorageLive(_3);                 // scope 0 at $DIR/boxes.rs:12:14: 12:22\n -         _4 = SizeOf(i32);                // scope 2 at $DIR/boxes.rs:12:14: 12:22\n -         _5 = AlignOf(i32);               // scope 2 at $DIR/boxes.rs:12:14: 12:22\n--         _6 = alloc::alloc::exchange_malloc(move _4, move _5) -> bb1; // scope 2 at $DIR/boxes.rs:12:14: 12:22\n+-         _6 = : unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}(move _4, move _5) -> bb1; // scope 2 at $DIR/boxes.rs:12:14: 12:22\n +         _4 = const 4_usize;              // scope 2 at $DIR/boxes.rs:12:14: 12:22\n +         _5 = const 4_usize;              // scope 2 at $DIR/boxes.rs:12:14: 12:22\n-+         _6 = alloc::alloc::exchange_malloc(const 4_usize, const 4_usize) -> bb1; // scope 2 at $DIR/boxes.rs:12:14: 12:22\n++         _6 = : unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}(const 4_usize, const 4_usize) -> bb1; // scope 2 at $DIR/boxes.rs:12:14: 12:22\n                                            // mir::Constant\n                                            // + span: $DIR/boxes.rs:12:14: 12:22\n-                                           // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(Scalar(<ZST>)) }\n+                                           // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(ValTree::Branch(..)) }\n       }\n   \n       bb1: {"}, {"sha": "832a773777707066ab713af9810239c1c05decd8", "filename": "src/test/mir-opt/derefer_inline_test.main.Derefer.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fderefer_inline_test.main.Derefer.diff", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fderefer_inline_test.main.Derefer.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fderefer_inline_test.main.Derefer.diff?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -16,10 +16,10 @@\n           StorageLive(_1);                 // scope 0 at $DIR/derefer_inline_test.rs:10:5: 10:12\n           _2 = SizeOf(std::boxed::Box<u32>); // scope 1 at $DIR/derefer_inline_test.rs:10:5: 10:12\n           _3 = AlignOf(std::boxed::Box<u32>); // scope 1 at $DIR/derefer_inline_test.rs:10:5: 10:12\n-          _4 = alloc::alloc::exchange_malloc(move _2, move _3) -> bb1; // scope 1 at $DIR/derefer_inline_test.rs:10:5: 10:12\n+          _4 = : unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}(move _2, move _3) -> bb1; // scope 1 at $DIR/derefer_inline_test.rs:10:5: 10:12\n                                            // mir::Constant\n                                            // + span: $DIR/derefer_inline_test.rs:10:5: 10:12\n-                                           // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(Scalar(<ZST>)) }\n+                                           // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(ValTree::Branch(..)) }\n       }\n   \n       bb1: {\n@@ -56,10 +56,10 @@\n       }\n   \n       bb7 (cleanup): {\n-          _6 = alloc::alloc::box_free::<Box<u32>, std::alloc::Global>(move (_5.0: std::ptr::Unique<std::boxed::Box<u32>>), move (_5.1: std::alloc::Global)) -> bb6; // scope 0 at $DIR/derefer_inline_test.rs:10:11: 10:12\n+          _6 = : unsafe fn(Unique::<Box<u32>>, std::alloc::Global) {alloc::alloc::box_free::<Box<u32>, std::alloc::Global>}(move (_5.0: std::ptr::Unique<std::boxed::Box<u32>>), move (_5.1: std::alloc::Global)) -> bb6; // scope 0 at $DIR/derefer_inline_test.rs:10:11: 10:12\n                                            // mir::Constant\n                                            // + span: $DIR/derefer_inline_test.rs:10:11: 10:12\n-                                           // + literal: Const { ty: unsafe fn(Unique<Box<u32>>, std::alloc::Global) {alloc::alloc::box_free::<Box<u32>, std::alloc::Global>}, val: Value(Scalar(<ZST>)) }\n+                                           // + literal: Const { ty: unsafe fn(Unique<Box<u32>>, std::alloc::Global) {alloc::alloc::box_free::<Box<u32>, std::alloc::Global>}, val: Value(ValTree::Branch(..)) }\n       }\n   \n       bb8 (cleanup): {"}, {"sha": "806e7b269e249a376743d8ae77cd54ed90f2d1ff", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.64bit.diff", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -23,10 +23,10 @@\n           StorageLive(_1);                 // scope 0 at $DIR/inline-into-box-place.rs:8:9: 8:11\n           _2 = SizeOf(std::vec::Vec<u32>); // scope 2 at $DIR/inline-into-box-place.rs:8:29: 8:43\n           _3 = AlignOf(std::vec::Vec<u32>); // scope 2 at $DIR/inline-into-box-place.rs:8:29: 8:43\n-          _4 = alloc::alloc::exchange_malloc(move _2, move _3) -> bb1; // scope 2 at $DIR/inline-into-box-place.rs:8:29: 8:43\n+          _4 = : unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}(move _2, move _3) -> bb1; // scope 2 at $DIR/inline-into-box-place.rs:8:29: 8:43\n                                            // mir::Constant\n                                            // + span: $DIR/inline-into-box-place.rs:8:29: 8:43\n-                                           // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(Scalar(<ZST>)) }\n+                                           // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(ValTree::Branch(..)) }\n       }\n   \n       bb1: {\n@@ -36,7 +36,7 @@\n +         StorageLive(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         _7 = &mut (*_5);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         StorageLive(_8);                 // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         _8 = const alloc::raw_vec::RawVec::<u32> { ptr: Unique::<u32> { pointer: NonNull::<u32> { pointer: {0x4 as *const u32} }, _marker: PhantomData::<u32> }, cap: 0_usize, alloc: std::alloc::Global }; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         _8 = const alloc::raw_vec::RawVec::<u32>::NEW; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n                                            // mir::Constant\n -                                          // + span: $DIR/inline-into-box-place.rs:8:33: 8:41\n -                                          // + user_ty: UserType(1)\n@@ -46,7 +46,7 @@\n -     bb2: {\n +                                          // + span: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +                                          // + user_ty: UserType(0)\n-+                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Value(ByRef(..)) }\n++                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Unevaluated(alloc::raw_vec::RawVec::<T>::NEW, [u32], None) }\n +         Deinit((*_7));                   // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +         ((*_7).0: alloc::raw_vec::RawVec<u32>) = move _8; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +         ((*_7).1: usize) = const 0_usize; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n@@ -71,10 +71,10 @@\n -     }\n - \n -     bb5 (cleanup): {\n--         _6 = alloc::alloc::box_free::<Vec<u32>, std::alloc::Global>(move (_5.0: std::ptr::Unique<std::vec::Vec<u32>>), move (_5.1: std::alloc::Global)) -> bb4; // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n+-         _6 = : unsafe fn(Unique::<Vec<u32>>, std::alloc::Global) {alloc::alloc::box_free::<Vec<u32>, std::alloc::Global>}(move (_5.0: std::ptr::Unique<std::vec::Vec<u32>>), move (_5.1: std::alloc::Global)) -> bb4; // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n -                                          // mir::Constant\n -                                          // + span: $DIR/inline-into-box-place.rs:8:42: 8:43\n--                                          // + literal: Const { ty: unsafe fn(Unique<Vec<u32>>, std::alloc::Global) {alloc::alloc::box_free::<Vec<u32>, std::alloc::Global>}, val: Value(Scalar(<ZST>)) }\n+-                                          // + literal: Const { ty: unsafe fn(Unique<Vec<u32>>, std::alloc::Global) {alloc::alloc::box_free::<Vec<u32>, std::alloc::Global>}, val: Value(ValTree::Branch(..)) }\n       }\n   }\n   "}, {"sha": "0a18710b2cc6f2c3b31744f949a77f630687ab5b", "filename": "src/test/mir-opt/issue_62289.test.ElaborateDrops.before.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -31,10 +31,10 @@ fn test() -> Option<Box<u32>> {\n         StorageLive(_1);                 // scope 0 at $DIR/issue-62289.rs:9:10: 9:21\n         _2 = SizeOf(u32);                // scope 1 at $DIR/issue-62289.rs:9:10: 9:21\n         _3 = AlignOf(u32);               // scope 1 at $DIR/issue-62289.rs:9:10: 9:21\n-        _4 = alloc::alloc::exchange_malloc(move _2, move _3) -> bb1; // scope 1 at $DIR/issue-62289.rs:9:10: 9:21\n+        _4 = : unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}(move _2, move _3) -> bb1; // scope 1 at $DIR/issue-62289.rs:9:10: 9:21\n                                          // mir::Constant\n                                          // + span: $DIR/issue-62289.rs:9:10: 9:21\n-                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(Scalar(<ZST>)) }\n+                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(ValTree::Branch(..)) }\n     }\n \n     bb1: {"}, {"sha": "c555e0441f42325c4e8654b8f387c360d6e89eaf", "filename": "src/test/mir-opt/nll/region_subtyping_basic.main.nll.0.64bit.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.64bit.mir?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -23,7 +23,7 @@\n |\n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/region-subtyping-basic.rs:16:11: 16:11\n-    let mut _1: [usize; Const { ty: usize, kind: Value(Scalar(0x0000000000000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+    let mut _1: [usize; Const { ty: usize, kind: Value(Leaf(0x0000000000000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n     let _3: usize;                       // in scope 0 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n     let mut _4: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n     let mut _5: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n@@ -63,7 +63,7 @@ fn main() -> () {\n         FakeRead(ForLet(None), _6);      // bb1[4]: scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n         StorageLive(_7);                 // bb1[5]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n         _7 = const ConstValue(Scalar(0x01): bool); // bb1[6]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n-        switchInt(move _7) -> [Const(Value(Scalar(0x00)): bool): bb4, otherwise: bb2]; // bb1[7]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+        switchInt(move _7) -> [ConstValue(Scalar(0x00): bool): bb4, otherwise: bb2]; // bb1[7]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n     }\n \n     bb2: {"}, {"sha": "8ae79b660446270068eb55b0645443c5a577c4b4", "filename": "src/test/mir-opt/retag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -8,10 +8,10 @@ fn std::ptr::drop_in_place(_1: *mut Test) -> () {\n     bb0: {\n         Retag([raw] _1);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n         _2 = &mut (*_1);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        _3 = <Test as Drop>::drop(move _2) -> bb1; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+        _3 = : for<'r> fn(&'r mut Test) {<Test as Drop>::drop}(move _2) -> bb1; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                                         // + literal: Const { ty: for<'r> fn(&'r mut Test) {<Test as Drop>::drop}, val: Value(Scalar(<ZST>)) }\n+                                         // + literal: Const { ty: for<'r> fn(&'r mut Test) {<Test as Drop>::drop}, val: Value(ValTree::Branch(..)) }\n     }\n \n     bb1: {"}, {"sha": "3b241264aacfaa7e6f647900e6f9b90cfa6c552f", "filename": "src/test/mir-opt/uniform_array_move_out.move_out_by_subslice.mir_map.0.mir", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_by_subslice.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_by_subslice.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_by_subslice.mir_map.0.mir?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -30,10 +30,10 @@ fn move_out_by_subslice() -> () {\n         StorageLive(_2);                 // scope 0 at $DIR/uniform_array_move_out.rs:11:14: 11:19\n         _3 = SizeOf(i32);                // scope 2 at $DIR/uniform_array_move_out.rs:11:14: 11:19\n         _4 = AlignOf(i32);               // scope 2 at $DIR/uniform_array_move_out.rs:11:14: 11:19\n-        _5 = alloc::alloc::exchange_malloc(move _3, move _4) -> [return: bb1, unwind: bb12]; // scope 2 at $DIR/uniform_array_move_out.rs:11:14: 11:19\n+        _5 = : unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}(move _3, move _4) -> [return: bb1, unwind: bb12]; // scope 2 at $DIR/uniform_array_move_out.rs:11:14: 11:19\n                                          // mir::Constant\n                                          // + span: $DIR/uniform_array_move_out.rs:11:14: 11:19\n-                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(Scalar(<ZST>)) }\n+                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(ValTree::Branch(..)) }\n     }\n \n     bb1: {\n@@ -49,10 +49,10 @@ fn move_out_by_subslice() -> () {\n         StorageLive(_7);                 // scope 0 at $DIR/uniform_array_move_out.rs:11:21: 11:26\n         _8 = SizeOf(i32);                // scope 3 at $DIR/uniform_array_move_out.rs:11:21: 11:26\n         _9 = AlignOf(i32);               // scope 3 at $DIR/uniform_array_move_out.rs:11:21: 11:26\n-        _10 = alloc::alloc::exchange_malloc(move _8, move _9) -> [return: bb3, unwind: bb11]; // scope 3 at $DIR/uniform_array_move_out.rs:11:21: 11:26\n+        _10 = : unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}(move _8, move _9) -> [return: bb3, unwind: bb11]; // scope 3 at $DIR/uniform_array_move_out.rs:11:21: 11:26\n                                          // mir::Constant\n                                          // + span: $DIR/uniform_array_move_out.rs:11:21: 11:26\n-                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(Scalar(<ZST>)) }\n+                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(ValTree::Branch(..)) }\n     }\n \n     bb3: {"}, {"sha": "c59e92dc8292748af51191b68711f285199856ef", "filename": "src/test/mir-opt/uniform_array_move_out.move_out_from_end.mir_map.0.mir", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_from_end.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_from_end.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_from_end.mir_map.0.mir?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -30,10 +30,10 @@ fn move_out_from_end() -> () {\n         StorageLive(_2);                 // scope 0 at $DIR/uniform_array_move_out.rs:5:14: 5:19\n         _3 = SizeOf(i32);                // scope 2 at $DIR/uniform_array_move_out.rs:5:14: 5:19\n         _4 = AlignOf(i32);               // scope 2 at $DIR/uniform_array_move_out.rs:5:14: 5:19\n-        _5 = alloc::alloc::exchange_malloc(move _3, move _4) -> [return: bb1, unwind: bb12]; // scope 2 at $DIR/uniform_array_move_out.rs:5:14: 5:19\n+        _5 = : unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}(move _3, move _4) -> [return: bb1, unwind: bb12]; // scope 2 at $DIR/uniform_array_move_out.rs:5:14: 5:19\n                                          // mir::Constant\n                                          // + span: $DIR/uniform_array_move_out.rs:5:14: 5:19\n-                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(Scalar(<ZST>)) }\n+                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(ValTree::Branch(..)) }\n     }\n \n     bb1: {\n@@ -49,10 +49,10 @@ fn move_out_from_end() -> () {\n         StorageLive(_7);                 // scope 0 at $DIR/uniform_array_move_out.rs:5:21: 5:26\n         _8 = SizeOf(i32);                // scope 3 at $DIR/uniform_array_move_out.rs:5:21: 5:26\n         _9 = AlignOf(i32);               // scope 3 at $DIR/uniform_array_move_out.rs:5:21: 5:26\n-        _10 = alloc::alloc::exchange_malloc(move _8, move _9) -> [return: bb3, unwind: bb11]; // scope 3 at $DIR/uniform_array_move_out.rs:5:21: 5:26\n+        _10 = : unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}(move _8, move _9) -> [return: bb3, unwind: bb11]; // scope 3 at $DIR/uniform_array_move_out.rs:5:21: 5:26\n                                          // mir::Constant\n                                          // + span: $DIR/uniform_array_move_out.rs:5:21: 5:26\n-                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(Scalar(<ZST>)) }\n+                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(ValTree::Branch(..)) }\n     }\n \n     bb3: {"}, {"sha": "3aa95cd3f105f0a4caeed297ef4878f12b3ea2f0", "filename": "src/test/mir-opt/unusual_item_types.core.ptr-drop_in_place.Vec_i32_.AddMovesForPackedDrops.before.64bit.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Funusual_item_types.core.ptr-drop_in_place.Vec_i32_.AddMovesForPackedDrops.before.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fmir-opt%2Funusual_item_types.core.ptr-drop_in_place.Vec_i32_.AddMovesForPackedDrops.before.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funusual_item_types.core.ptr-drop_in_place.Vec_i32_.AddMovesForPackedDrops.before.64bit.mir?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -31,9 +31,9 @@ fn std::ptr::drop_in_place(_1: *mut Vec<i32>) -> () {\n \n     bb6: {\n         _2 = &mut (*_1);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        _3 = <Vec<i32> as Drop>::drop(move _2) -> [return: bb5, unwind: bb4]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+        _3 = : for<'r> fn(&'r mut Vec::<i32>) {<Vec<i32> as Drop>::drop}(move _2) -> [return: bb5, unwind: bb4]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                                         // + literal: Const { ty: for<'r> fn(&'r mut Vec<i32>) {<Vec<i32> as Drop>::drop}, val: Value(Scalar(<ZST>)) }\n+                                         // + literal: Const { ty: for<'r> fn(&'r mut Vec<i32>) {<Vec<i32> as Drop>::drop}, val: Value(ValTree::Branch(..)) }\n     }\n }"}, {"sha": "a1c6840a0f1b364e3f80035f1ce6212e94854f7d", "filename": "src/test/ui/associated-consts/defaults-cyclic-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-cyclic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-cyclic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-cyclic-fail.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,9 +1,9 @@\n // build-fail\n-//~^ ERROR cycle detected when normalizing `<() as Tr>::A` [E0391]\n \n // Cyclic assoc. const defaults don't error unless *used*\n trait Tr {\n     const A: u8 = Self::B;\n+    //~^ cycle detected when const-evaluating + checking `Tr::A`\n \n     const B: u8 = Self::A;\n }"}, {"sha": "550897790e9ff1fd8396a4b9f297f95490bef4e2", "filename": "src/test/ui/associated-consts/defaults-cyclic-fail.stderr", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-cyclic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-cyclic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-cyclic-fail.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,37 +1,15 @@\n-error[E0391]: cycle detected when normalizing `<() as Tr>::A`\n-   |\n-note: ...which requires simplifying constant for the type system `Tr::A`...\n-  --> $DIR/defaults-cyclic-fail.rs:6:5\n-   |\n-LL |     const A: u8 = Self::B;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `Tr::A`...\n-  --> $DIR/defaults-cyclic-fail.rs:6:5\n-   |\n-LL |     const A: u8 = Self::B;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires const-evaluating + checking `Tr::A`...\n-  --> $DIR/defaults-cyclic-fail.rs:6:5\n+error[E0391]: cycle detected when const-evaluating + checking `Tr::A`\n+  --> $DIR/defaults-cyclic-fail.rs:5:5\n    |\n LL |     const A: u8 = Self::B;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `<() as Tr>::B`...\n-note: ...which requires simplifying constant for the type system `Tr::B`...\n-  --> $DIR/defaults-cyclic-fail.rs:8:5\n    |\n-LL |     const B: u8 = Self::A;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `Tr::B`...\n-  --> $DIR/defaults-cyclic-fail.rs:8:5\n-   |\n-LL |     const B: u8 = Self::A;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `Tr::B`...\n   --> $DIR/defaults-cyclic-fail.rs:8:5\n    |\n LL |     const B: u8 = Self::A;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires normalizing `<() as Tr>::A`, completing the cycle\n+   = note: ...which again requires const-evaluating + checking `Tr::A`, completing the cycle\n note: cycle used when const-evaluating + checking `main::promoted[1]`\n   --> $DIR/defaults-cyclic-fail.rs:14:1\n    |"}, {"sha": "8c85fadf6001425401fe4ce03adf4b98f85b2e67", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-impl.stderr", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -4,13 +4,7 @@ error[E0391]: cycle detected when elaborating drops for `<impl at $DIR/issue-249\n LL |     const BAR: u32 = IMPL_REF_BAR;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: ...which requires normalizing `IMPL_REF_BAR`...\n-note: ...which requires simplifying constant for the type system `IMPL_REF_BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:7:1\n-   |\n-LL | const IMPL_REF_BAR: u32 = GlobalImplRef::BAR;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `IMPL_REF_BAR`...\n+note: ...which requires const-evaluating + checking `IMPL_REF_BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:7:1\n    |\n LL | const IMPL_REF_BAR: u32 = GlobalImplRef::BAR;\n@@ -20,17 +14,6 @@ note: ...which requires const-evaluating + checking `IMPL_REF_BAR`...\n    |\n LL | const IMPL_REF_BAR: u32 = GlobalImplRef::BAR;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `<impl at $DIR/issue-24949-assoc-const-static-recursion-impl.rs:11:1: 13:2>::BAR`...\n-note: ...which requires simplifying constant for the type system `<impl at $DIR/issue-24949-assoc-const-static-recursion-impl.rs:11:1: 13:2>::BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:12:5\n-   |\n-LL |     const BAR: u32 = IMPL_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `<impl at $DIR/issue-24949-assoc-const-static-recursion-impl.rs:11:1: 13:2>::BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:12:5\n-   |\n-LL |     const BAR: u32 = IMPL_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `<impl at $DIR/issue-24949-assoc-const-static-recursion-impl.rs:11:1: 13:2>::BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:12:5\n    |"}, {"sha": "251a69aeabaa2d31ed5d167a3eb9a968a8942ad6", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-trait-default.stderr", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -4,13 +4,7 @@ error[E0391]: cycle detected when elaborating drops for `FooDefault::BAR`\n LL |     const BAR: u32 = DEFAULT_REF_BAR;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: ...which requires normalizing `DEFAULT_REF_BAR`...\n-note: ...which requires simplifying constant for the type system `DEFAULT_REF_BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:11:1\n-   |\n-LL | const DEFAULT_REF_BAR: u32 = <GlobalDefaultRef>::BAR;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `DEFAULT_REF_BAR`...\n+note: ...which requires const-evaluating + checking `DEFAULT_REF_BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:11:1\n    |\n LL | const DEFAULT_REF_BAR: u32 = <GlobalDefaultRef>::BAR;\n@@ -20,17 +14,6 @@ note: ...which requires const-evaluating + checking `DEFAULT_REF_BAR`...\n    |\n LL | const DEFAULT_REF_BAR: u32 = <GlobalDefaultRef>::BAR;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `<GlobalDefaultRef as FooDefault>::BAR`...\n-note: ...which requires simplifying constant for the type system `FooDefault::BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:8:5\n-   |\n-LL |     const BAR: u32 = DEFAULT_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `FooDefault::BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:8:5\n-   |\n-LL |     const BAR: u32 = DEFAULT_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `FooDefault::BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:8:5\n    |"}, {"sha": "45e911d002912f57db4edbb2e1938115580ee758", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-trait.stderr", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -4,13 +4,7 @@ error[E0391]: cycle detected when elaborating drops for `<impl at $DIR/issue-249\n LL |     const BAR: u32 = TRAIT_REF_BAR;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: ...which requires normalizing `TRAIT_REF_BAR`...\n-note: ...which requires simplifying constant for the type system `TRAIT_REF_BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:7:1\n-   |\n-LL | const TRAIT_REF_BAR: u32 = <GlobalTraitRef>::BAR;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `TRAIT_REF_BAR`...\n+note: ...which requires const-evaluating + checking `TRAIT_REF_BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:7:1\n    |\n LL | const TRAIT_REF_BAR: u32 = <GlobalTraitRef>::BAR;\n@@ -20,17 +14,6 @@ note: ...which requires const-evaluating + checking `TRAIT_REF_BAR`...\n    |\n LL | const TRAIT_REF_BAR: u32 = <GlobalTraitRef>::BAR;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `<GlobalTraitRef as Foo>::BAR`...\n-note: ...which requires simplifying constant for the type system `<impl at $DIR/issue-24949-assoc-const-static-recursion-trait.rs:11:1: 13:2>::BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:12:5\n-   |\n-LL |     const BAR: u32 = TRAIT_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `<impl at $DIR/issue-24949-assoc-const-static-recursion-trait.rs:11:1: 13:2>::BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:12:5\n-   |\n-LL |     const BAR: u32 = TRAIT_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `<impl at $DIR/issue-24949-assoc-const-static-recursion-trait.rs:11:1: 13:2>::BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:12:5\n    |"}, {"sha": "9b60612037dd6e76d9792b3e58fe201d8cb592f6", "filename": "src/test/ui/borrowck/issue-81899.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -2,6 +2,8 @@\n // The `panic!()` below is important to trigger the fixed ICE.\n \n const _CONST: &[u8] = &f(&[], |_| {});\n+//~^ ERROR any use of this value\n+//~| WARNING this was previously\n \n const fn f<F>(_: &[u8], _: F) -> &[u8]\n where"}, {"sha": "92ebd5a220d904d0f88db711d9d60745ab9e44e4", "filename": "src/test/ui/borrowck/issue-81899.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,17 +1,29 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/issue-81899.rs:10:5\n+  --> $DIR/issue-81899.rs:12:5\n    |\n LL | const _CONST: &[u8] = &f(&[], |_| {});\n    |                        -------------- inside `_CONST` at $DIR/issue-81899.rs:4:24\n ...\n LL |     panic!()\n    |     ^^^^^^^^\n    |     |\n-   |     the evaluated program panicked at 'explicit panic', $DIR/issue-81899.rs:10:5\n+   |     the evaluated program panicked at 'explicit panic', $DIR/issue-81899.rs:12:5\n    |     inside `f::<[closure@$DIR/issue-81899.rs:4:31: 4:37]>` at $SRC_DIR/std/src/panic.rs:LL:COL\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error\n+error: any use of this value will cause an error\n+  --> $DIR/issue-81899.rs:4:23\n+   |\n+LL | const _CONST: &[u8] = &f(&[], |_| {});\n+   | ----------------------^^^^^^^^^^^^^^^-\n+   |                       |\n+   |                       referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "7618d001e86eecf3e4813714c05fd86d7f333cc8", "filename": "src/test/ui/borrowck/issue-88434-minimal-example.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,6 +1,8 @@\n // Regression test related to issue 88434\n \n const _CONST: &() = &f(&|_| {});\n+//~^ ERROR any use of this value\n+//~| WARNING this was previously\n \n const fn f<F>(_: &F)\n where"}, {"sha": "d46cd862e34aad2278e54e773e014f12917d28f8", "filename": "src/test/ui/borrowck/issue-88434-minimal-example.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,17 +1,29 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/issue-88434-minimal-example.rs:9:5\n+  --> $DIR/issue-88434-minimal-example.rs:11:5\n    |\n LL | const _CONST: &() = &f(&|_| {});\n    |                      ---------- inside `_CONST` at $DIR/issue-88434-minimal-example.rs:3:22\n ...\n LL |     panic!()\n    |     ^^^^^^^^\n    |     |\n-   |     the evaluated program panicked at 'explicit panic', $DIR/issue-88434-minimal-example.rs:9:5\n+   |     the evaluated program panicked at 'explicit panic', $DIR/issue-88434-minimal-example.rs:11:5\n    |     inside `f::<[closure@$DIR/issue-88434-minimal-example.rs:3:25: 3:31]>` at $SRC_DIR/std/src/panic.rs:LL:COL\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error\n+error: any use of this value will cause an error\n+  --> $DIR/issue-88434-minimal-example.rs:3:21\n+   |\n+LL | const _CONST: &() = &f(&|_| {});\n+   | --------------------^^^^^^^^^^^-\n+   |                     |\n+   |                     referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "b1fc1615ece7728e0c8eb4c76e18e9206a5b2cf3", "filename": "src/test/ui/borrowck/issue-88434-removal-index-should-be-less.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,6 +1,8 @@\n // Regression test for issue 88434\n \n const _CONST: &[u8] = &f(&[], |_| {});\n+//~^ ERROR any use of this value will cause an error\n+//~| WARNING this was previously\n \n const fn f<F>(_: &[u8], _: F) -> &[u8]\n where"}, {"sha": "e6b07aba74d426cdd7bc3c7705db522ae2fbc609", "filename": "src/test/ui/borrowck/issue-88434-removal-index-should-be-less.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,17 +1,29 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/issue-88434-removal-index-should-be-less.rs:9:5\n+  --> $DIR/issue-88434-removal-index-should-be-less.rs:11:5\n    |\n LL | const _CONST: &[u8] = &f(&[], |_| {});\n    |                        -------------- inside `_CONST` at $DIR/issue-88434-removal-index-should-be-less.rs:3:24\n ...\n LL |     panic!()\n    |     ^^^^^^^^\n    |     |\n-   |     the evaluated program panicked at 'explicit panic', $DIR/issue-88434-removal-index-should-be-less.rs:9:5\n+   |     the evaluated program panicked at 'explicit panic', $DIR/issue-88434-removal-index-should-be-less.rs:11:5\n    |     inside `f::<[closure@$DIR/issue-88434-removal-index-should-be-less.rs:3:31: 3:37]>` at $SRC_DIR/std/src/panic.rs:LL:COL\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error\n+error: any use of this value will cause an error\n+  --> $DIR/issue-88434-removal-index-should-be-less.rs:3:23\n+   |\n+LL | const _CONST: &[u8] = &f(&[], |_| {});\n+   | ----------------------^^^^^^^^^^^^^^^-\n+   |                       |\n+   |                       referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "f0b9035357d82fcfb9d49eb0883ff4f583e6e16b", "filename": "src/test/ui/const-generics/different_generic_args_array.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args_array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args_array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args_array.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/different_generic_args_array.rs:9:9\n    |\n LL |     x = Const::<{ [4] }> {};\n-   |         ^^^^^^^^^^^^^^^^^^^ expected `3_usize`, found `4_usize`\n+   |         ^^^^^^^^^^^^^^^^^^^ expected `[3_usize]`, found `[4_usize]`\n    |\n    = note: expected struct `Const<[3_usize]>`\n               found struct `Const<[4_usize]>`"}, {"sha": "98931a3936f52eb3fe2f4bab4715000d561d5ce8", "filename": "src/test/ui/const-generics/issues/issue-83765.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -10,7 +10,11 @@ note: ...which requires checking if `TensorDimension` fulfills its obligations..\n LL | trait TensorDimension {\n    | ^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which again requires resolving instance `<LazyUpdim<T, { T::DIM }, DIM> as TensorDimension>::DIM`, completing the cycle\n-   = note: cycle used when normalizing `<LazyUpdim<T, { T::DIM }, DIM> as TensorDimension>::DIM`\n+note: cycle used when checking if `TensorDimension` fulfills its obligations\n+  --> $DIR/issue-83765.rs:4:1\n+   |\n+LL | trait TensorDimension {\n+   | ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "52b173c4d04a8107dc522f71a8424386deb859db", "filename": "src/test/ui/const-ptr/out_of_bounds_read.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -4,7 +4,7 @@ error[E0080]: evaluation of constant value failed\n LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         memory access failed: alloc7 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   |         memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n   ::: $DIR/out_of_bounds_read.rs:12:33\n@@ -18,7 +18,7 @@ error[E0080]: evaluation of constant value failed\n LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         memory access failed: alloc7 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   |         memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n@@ -37,7 +37,7 @@ error[E0080]: evaluation of constant value failed\n LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         memory access failed: alloc7 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   |         memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL"}, {"sha": "c9460498951fda8a90aeacad17250685f733c2ef", "filename": "src/test/ui/consts/const-eval/const-eval-query-stack.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,5 +1,4 @@\n // compile-flags: -Ztreat-err-as-bug=2\n-//~^ ERROR 1:1: 1:1: ty::ConstKind::Error constructed but no error reported\n // build-fail\n // failure-status: 101\n // rustc-env:RUST_BACKTRACE=1\n@@ -23,5 +22,7 @@ const X: i32 = 1 / 0; //~WARN any use of this value will cause an error\n fn main() {\n     let x: &'static i32 = &X;\n     //~^ ERROR evaluation of constant value failed\n+    //~| ERROR erroneous constant used\n+    //~| WARNING this was previously accepted by the compiler\n     println!(\"x={}\", x);\n }"}, {"sha": "b74d5a2722bd8b2e75051d335e4941f0451cdddf", "filename": "src/test/ui/consts/const-eval/const-eval-query-stack.stderr", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,27 +1,37 @@\n warning: any use of this value will cause an error\n-  --> $DIR/const-eval-query-stack.rs:20:16\n+  --> $DIR/const-eval-query-stack.rs:19:16\n    |\n LL | const X: i32 = 1 / 0;\n    | ---------------^^^^^-\n    |                |\n    |                attempt to divide `1_i32` by zero\n    |\n note: the lint level is defined here\n-  --> $DIR/const-eval-query-stack.rs:19:8\n+  --> $DIR/const-eval-query-stack.rs:18:8\n    |\n LL | #[warn(const_err)]\n    |        ^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/const-eval-query-stack.rs:24:28\n+  --> $DIR/const-eval-query-stack.rs:23:28\n    |\n LL |     let x: &'static i32 = &X;\n    |                            ^ referenced constant has errors\n+\n+error: erroneous constant used\n+  --> $DIR/const-eval-query-stack.rs:23:27\n+   |\n+LL |     let x: &'static i32 = &X;\n+   |                           ^^ referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n query stack during panic:\n-#0 [try_normalize_mir_const_after_erasing_regions] normalizing `main::promoted[1]`\n-#1 [mir_drops_elaborated_and_const_checked] elaborating drops for `main`\n-#2 [optimized_mir] optimizing MIR for `main`\n-#3 [collect_and_partition_mono_items] collect_and_partition_mono_items\n+#0 [mir_drops_elaborated_and_const_checked] elaborating drops for `main`\n+#1 [optimized_mir] optimizing MIR for `main`\n+#2 [collect_and_partition_mono_items] collect_and_partition_mono_items\n end of query stack"}, {"sha": "b156ded4a6c2afc44a48ab82e1cccaff1ca17385", "filename": "src/test/ui/consts/const-float-bits-reject-conv.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -28,14 +28,22 @@ fn f32() {\n     const MASKED_NAN2: u32 = f32::NAN.to_bits() ^ 0x0055_5555;\n \n     const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+    //~^ ERROR any use of this value will cause an error\n+    //~| WARNING this was previously accepted\n     const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+    //~^ ERROR any use of this value will cause an error\n+    //~| WARNING this was previously accepted\n \n     // LLVM does not guarantee that loads and stores of NaNs preserve their exact bit pattern.\n     // In practice, this seems to only cause a problem on x86, since the most widely used calling\n     // convention mandates that floating point values are returned on the x87 FPU stack. See #73328.\n     if !cfg!(target_arch = \"x86\") {\n         const_assert!(f32::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+        //~^ ERROR any use of this value will cause an error\n+        //~| WARNING this was previously accepted\n         const_assert!(f32::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+        //~^ ERROR any use of this value will cause an error\n+        //~| WARNING this was previously accepted\n     }\n }\n \n@@ -47,12 +55,20 @@ fn f64() {\n     const MASKED_NAN2: u64 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n \n     const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+    //~^ ERROR any use of this value will cause an error\n+    //~| WARNING this was previously accepted\n     const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+    //~^ ERROR any use of this value will cause an error\n+    //~| WARNING this was previously accepted\n \n     // See comment above.\n     if !cfg!(target_arch = \"x86\") {\n         const_assert!(f64::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+        //~^ ERROR any use of this value will cause an error\n+        //~| WARNING this was previously accepted\n         const_assert!(f64::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+        //~^ ERROR any use of this value will cause an error\n+        //~| WARNING this was previously accepted\n     }\n }\n "}, {"sha": "f3fd098e848a20476875e5491fb41ed7f0eeb7c5", "filename": "src/test/ui/consts/const-float-bits-reject-conv.stderr", "status": "modified", "additions": 102, "deletions": 5, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -56,6 +56,55 @@ LL |     const MASKED_NAN2: u32 = f32::NAN.to_bits() ^ 0x0055_5555;\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:30:34\n+   |\n+LL |             const _: () = assert!($a);\n+   |             --------------------------\n+...\n+LL |     const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+   |                                  ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:33:34\n+   |\n+LL |             const _: () = assert!($a);\n+   |             --------------------------\n+...\n+LL |     const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+   |                                  ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:41:38\n+   |\n+LL |             const _: () = assert!($a == $b);\n+   |             --------------------------------\n+...\n+LL |         const_assert!(f32::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+   |                                      ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:44:38\n+   |\n+LL |             const _: () = assert!($a == $b);\n+   |             --------------------------------\n+...\n+LL |         const_assert!(f32::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+   |                                      ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/num/f64.rs:LL:COL\n    |\n@@ -78,10 +127,10 @@ LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n LL |     called_in_const.call_once(arg)\n    |     ------------------------------ inside `const_eval_select::<(f64,), fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64}, [closure@core::f64::<impl f64>::to_bits::{closure#0}], u64>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n    |\n-  ::: $DIR/const-float-bits-reject-conv.rs:46:30\n+  ::: $DIR/const-float-bits-reject-conv.rs:54:30\n    |\n LL |     const MASKED_NAN1: u64 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n-   |                              ------------------ inside `f64::MASKED_NAN1` at $DIR/const-float-bits-reject-conv.rs:46:30\n+   |                              ------------------ inside `f64::MASKED_NAN1` at $DIR/const-float-bits-reject-conv.rs:54:30\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n@@ -107,13 +156,61 @@ LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n LL |     called_in_const.call_once(arg)\n    |     ------------------------------ inside `const_eval_select::<(f64,), fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64}, [closure@core::f64::<impl f64>::to_bits::{closure#0}], u64>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n    |\n-  ::: $DIR/const-float-bits-reject-conv.rs:47:30\n+  ::: $DIR/const-float-bits-reject-conv.rs:55:30\n    |\n LL |     const MASKED_NAN2: u64 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n-   |                              ------------------ inside `f64::MASKED_NAN2` at $DIR/const-float-bits-reject-conv.rs:47:30\n+   |                              ------------------ inside `f64::MASKED_NAN2` at $DIR/const-float-bits-reject-conv.rs:55:30\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 4 previous errors\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:57:34\n+   |\n+LL |             const _: () = assert!($a);\n+   |             --------------------------\n+...\n+LL |     const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+   |                                  ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:60:34\n+   |\n+LL |             const _: () = assert!($a);\n+   |             --------------------------\n+...\n+LL |     const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+   |                                  ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:66:38\n+   |\n+LL |             const _: () = assert!($a == $b);\n+   |             --------------------------------\n+...\n+LL |         const_assert!(f64::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+   |                                      ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:69:38\n+   |\n+LL |             const _: () = assert!($a == $b);\n+   |             --------------------------------\n+...\n+LL |         const_assert!(f64::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+   |                                      ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: aborting due to 12 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "6924956bdf706f174ccc7a68c4ed529d30f2ad8c", "filename": "src/test/ui/consts/const-integer-bool-ops.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-integer-bool-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-integer-bool-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-integer-bool-ops.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -6,6 +6,7 @@ const X: usize = 42 && 39;\n //~| ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARR: [i32; X] = [99; 34];\n+//~^ ERROR evaluation of constant value failed\n \n const X1: usize = 42 || 39;\n //~^ ERROR mismatched types\n@@ -15,6 +16,7 @@ const X1: usize = 42 || 39;\n //~| ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARR1: [i32; X1] = [99; 47];\n+//~^ ERROR evaluation of constant value failed\n \n const X2: usize = -42 || -39;\n //~^ ERROR mismatched types\n@@ -24,6 +26,7 @@ const X2: usize = -42 || -39;\n //~| ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARR2: [i32; X2] = [99; 18446744073709551607];\n+//~^ ERROR evaluation of constant value failed\n \n const X3: usize = -42 && -39;\n //~^ ERROR mismatched types\n@@ -33,36 +36,43 @@ const X3: usize = -42 && -39;\n //~| ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARR3: [i32; X3] = [99; 6];\n+//~^ ERROR evaluation of constant value failed\n \n const Y: usize = 42.0 == 42.0;\n //~^ ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARRR: [i32; Y] = [99; 1];\n+//~^ ERROR evaluation of constant value failed\n \n const Y1: usize = 42.0 >= 42.0;\n //~^ ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARRR1: [i32; Y1] = [99; 1];\n+//~^ ERROR evaluation of constant value failed\n \n const Y2: usize = 42.0 <= 42.0;\n //~^ ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARRR2: [i32; Y2] = [99; 1];\n+//~^ ERROR evaluation of constant value failed\n \n const Y3: usize = 42.0 > 42.0;\n //~^ ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARRR3: [i32; Y3] = [99; 0];\n+//~^ ERROR evaluation of constant value failed\n \n const Y4: usize = 42.0 < 42.0;\n //~^ ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARRR4: [i32; Y4] = [99; 0];\n+//~^ ERROR evaluation of constant value failed\n \n const Y5: usize = 42.0 != 42.0;\n //~^ ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARRR5: [i32; Y5] = [99; 0];\n+//~^ ERROR evaluation of constant value failed\n \n fn main() {\n     let _ = ARR;"}, {"sha": "9001fefd1029f314bc95f9bae48efc75a5baf0cd", "filename": "src/test/ui/consts/const-integer-bool-ops.stderr", "status": "modified", "additions": 78, "deletions": 17, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-integer-bool-ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-integer-bool-ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-integer-bool-ops.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -16,96 +16,157 @@ error[E0308]: mismatched types\n LL | const X: usize = 42 && 39;\n    |                  ^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:8:18\n+   |\n+LL | const ARR: [i32; X] = [99; 34];\n+   |                  ^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:10:19\n+  --> $DIR/const-integer-bool-ops.rs:11:19\n    |\n LL | const X1: usize = 42 || 39;\n    |                   ^^ expected `bool`, found integer\n \n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:10:25\n+  --> $DIR/const-integer-bool-ops.rs:11:25\n    |\n LL | const X1: usize = 42 || 39;\n    |                         ^^ expected `bool`, found integer\n \n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:10:19\n+  --> $DIR/const-integer-bool-ops.rs:11:19\n    |\n LL | const X1: usize = 42 || 39;\n    |                   ^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:18:19\n+   |\n+LL | const ARR1: [i32; X1] = [99; 47];\n+   |                   ^^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:19:19\n+  --> $DIR/const-integer-bool-ops.rs:21:19\n    |\n LL | const X2: usize = -42 || -39;\n    |                   ^^^ expected `bool`, found integer\n \n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:19:26\n+  --> $DIR/const-integer-bool-ops.rs:21:26\n    |\n LL | const X2: usize = -42 || -39;\n    |                          ^^^ expected `bool`, found integer\n \n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:19:19\n+  --> $DIR/const-integer-bool-ops.rs:21:19\n    |\n LL | const X2: usize = -42 || -39;\n    |                   ^^^^^^^^^^ expected `usize`, found `bool`\n \n-error[E0308]: mismatched types\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/const-integer-bool-ops.rs:28:19\n    |\n+LL | const ARR2: [i32; X2] = [99; 18446744073709551607];\n+   |                   ^^ referenced constant has errors\n+\n+error[E0308]: mismatched types\n+  --> $DIR/const-integer-bool-ops.rs:31:19\n+   |\n LL | const X3: usize = -42 && -39;\n    |                   ^^^ expected `bool`, found integer\n \n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:28:26\n+  --> $DIR/const-integer-bool-ops.rs:31:26\n    |\n LL | const X3: usize = -42 && -39;\n    |                          ^^^ expected `bool`, found integer\n \n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:28:19\n+  --> $DIR/const-integer-bool-ops.rs:31:19\n    |\n LL | const X3: usize = -42 && -39;\n    |                   ^^^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:38:19\n+   |\n+LL | const ARR3: [i32; X3] = [99; 6];\n+   |                   ^^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:37:18\n+  --> $DIR/const-integer-bool-ops.rs:41:18\n    |\n LL | const Y: usize = 42.0 == 42.0;\n    |                  ^^^^^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:44:19\n+   |\n+LL | const ARRR: [i32; Y] = [99; 1];\n+   |                   ^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:42:19\n+  --> $DIR/const-integer-bool-ops.rs:47:19\n    |\n LL | const Y1: usize = 42.0 >= 42.0;\n    |                   ^^^^^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:50:20\n+   |\n+LL | const ARRR1: [i32; Y1] = [99; 1];\n+   |                    ^^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:47:19\n+  --> $DIR/const-integer-bool-ops.rs:53:19\n    |\n LL | const Y2: usize = 42.0 <= 42.0;\n    |                   ^^^^^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:56:20\n+   |\n+LL | const ARRR2: [i32; Y2] = [99; 1];\n+   |                    ^^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:52:19\n+  --> $DIR/const-integer-bool-ops.rs:59:19\n    |\n LL | const Y3: usize = 42.0 > 42.0;\n    |                   ^^^^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:62:20\n+   |\n+LL | const ARRR3: [i32; Y3] = [99; 0];\n+   |                    ^^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:57:19\n+  --> $DIR/const-integer-bool-ops.rs:65:19\n    |\n LL | const Y4: usize = 42.0 < 42.0;\n    |                   ^^^^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:68:20\n+   |\n+LL | const ARRR4: [i32; Y4] = [99; 0];\n+   |                    ^^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:62:19\n+  --> $DIR/const-integer-bool-ops.rs:71:19\n    |\n LL | const Y5: usize = 42.0 != 42.0;\n    |                   ^^^^^^^^^^^^ expected `usize`, found `bool`\n \n-error: aborting due to 18 previous errors\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:74:20\n+   |\n+LL | const ARRR5: [i32; Y5] = [99; 0];\n+   |                    ^^ referenced constant has errors\n+\n+error: aborting due to 28 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0080, E0308.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "0f420ae1b6b7cc6689dce73199da330bc194873f", "filename": "src/test/ui/consts/const-mut-refs/issue-76510.64bit.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.64bit.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -19,7 +19,13 @@ error[E0596]: cannot borrow data in a `&` reference as mutable\n LL | const S: &'static mut str = &mut \" hello \";\n    |                             ^^^^^^^^^^^^^^ cannot borrow as mutable\n \n-error: aborting due to 3 previous errors\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-76510.rs:11:70\n+   |\n+LL |         let s = transmute::<(*const u8, usize), &ManuallyDrop<str>>((S.as_ptr(), 3));\n+   |                                                                      ^ referenced constant has errors\n+\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0596, E0658, E0764.\n-For more information about an error, try `rustc --explain E0596`.\n+Some errors have detailed explanations: E0080, E0596, E0658, E0764.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "08cf64ee330db74af03b8bc009206907bd4462bf", "filename": "src/test/ui/consts/const-mut-refs/issue-76510.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -9,6 +9,7 @@ const S: &'static mut str = &mut \" hello \";\n \n const fn trigger() -> [(); unsafe {\n         let s = transmute::<(*const u8, usize), &ManuallyDrop<str>>((S.as_ptr(), 3));\n+        //~^ ERROR evaluation of constant value failed\n         0\n     }] {\n     [(); 0]"}, {"sha": "0772b1712c5e272dcd570f365725ea98ce32fe1f", "filename": "src/test/ui/consts/const-size_of-cycle.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `Foo::bytes::{constant#0}`\n+error[E0391]: cycle detected when evaluate type-level constant\n   --> $DIR/const-size_of-cycle.rs:4:17\n    |\n LL |     bytes: [u8; std::mem::size_of::<Foo>()]\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: ...which requires simplifying constant for the type system `Foo::bytes::{constant#0}`...\n+note: ...which requires const-evaluating + checking `Foo::bytes::{constant#0}`...\n   --> $DIR/const-size_of-cycle.rs:4:17\n    |\n LL |     bytes: [u8; std::mem::size_of::<Foo>()]\n@@ -17,7 +17,7 @@ LL |     bytes: [u8; std::mem::size_of::<Foo>()]\n    = note: ...which requires computing layout of `Foo`...\n    = note: ...which requires computing layout of `[u8; _]`...\n    = note: ...which requires normalizing `[u8; _]`...\n-   = note: ...which again requires simplifying constant for the type system `Foo::bytes::{constant#0}`, completing the cycle\n+   = note: ...which again requires evaluate type-level constant, completing the cycle\n note: cycle used when checking that `Foo` is well-formed\n   --> $DIR/const-size_of-cycle.rs:3:1\n    |"}, {"sha": "763263c6aeb4f9a86c81c99459d07590c6b06733", "filename": "src/test/ui/consts/const-tup-index-span.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-tup-index-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-tup-index-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-tup-index-span.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -4,6 +4,7 @@ const TUP: (usize,) = 5usize << 64;\n //~^ ERROR mismatched types\n //~| expected tuple, found `usize`\n const ARR: [i32; TUP.0] = [];\n+//~^ ERROR evaluation of constant value failed\n \n fn main() {\n }"}, {"sha": "b178e05e27a095b3c10102f6b0f63a3c7fb2b2a6", "filename": "src/test/ui/consts/const-tup-index-span.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-tup-index-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fconst-tup-index-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-tup-index-span.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -11,6 +11,13 @@ help: use a trailing comma to create a tuple with one element\n LL | const TUP: (usize,) = (5usize << 64,);\n    |                       +            ++\n \n-error: aborting due to previous error\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-tup-index-span.rs:6:18\n+   |\n+LL | const ARR: [i32; TUP.0] = [];\n+   |                  ^^^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0080, E0308.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "6bfa97a2fded7875aeed1c92e698265662037f8e", "filename": "src/test/ui/consts/invalid-union.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Finvalid-union.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Finvalid-union.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Finvalid-union.64bit.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -6,7 +6,7 @@ LL | fn main() {\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: erroneous constant used"}, {"sha": "9ac6c984cb0cdd8fedb3f9883455c20c40e68d65", "filename": "src/test/ui/consts/issue-36163.stderr", "status": "modified", "additions": 6, "deletions": 34, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fissue-36163.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fissue-36163.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-36163.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,48 +1,20 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `Foo::B::{constant#0}`\n+error[E0391]: cycle detected when const-evaluating + checking `Foo::B::{constant#0}`\n   --> $DIR/issue-36163.rs:4:9\n    |\n LL |     B = A,\n    |         ^\n    |\n-note: ...which requires simplifying constant for the type system `Foo::B::{constant#0}`...\n-  --> $DIR/issue-36163.rs:4:9\n-   |\n-LL |     B = A,\n-   |         ^\n-note: ...which requires const-evaluating + checking `Foo::B::{constant#0}`...\n-  --> $DIR/issue-36163.rs:4:9\n-   |\n-LL |     B = A,\n-   |         ^\n-   = note: ...which requires normalizing `A`...\n-note: ...which requires simplifying constant for the type system `A`...\n-  --> $DIR/issue-36163.rs:1:1\n-   |\n-LL | const A: isize = Foo::B as isize;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `A`...\n-  --> $DIR/issue-36163.rs:1:1\n-   |\n-LL | const A: isize = Foo::B as isize;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `A`...\n   --> $DIR/issue-36163.rs:1:1\n    |\n LL | const A: isize = Foo::B as isize;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `A`...\n-   = note: ...which again requires simplifying constant for the type system `Foo::B::{constant#0}`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/issue-36163.rs:1:1\n+   = note: ...which again requires const-evaluating + checking `Foo::B::{constant#0}`, completing the cycle\n+note: cycle used when simplifying constant for the type system `Foo::B::{constant#0}`\n+  --> $DIR/issue-36163.rs:4:9\n    |\n-LL | / const A: isize = Foo::B as isize;\n-LL | |\n-LL | | enum Foo {\n-LL | |     B = A,\n-LL | | }\n-LL | |\n-LL | | fn main() {}\n-   | |____________^\n+LL |     B = A,\n+   |         ^\n \n error: aborting due to previous error\n "}, {"sha": "79f415e6a2c10f27cc13dd1955793953f4ce4312", "filename": "src/test/ui/consts/issue-44415.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -4,7 +4,7 @@ use std::intrinsics;\n \n struct Foo {\n     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n-    //~^ ERROR cycle detected when simplifying constant for the type system\n+    //~^ ERROR cycle detected when evaluate type-level constant\n     x: usize,\n }\n "}, {"sha": "6641300fc9a87c571ddc583e6fb209089ccf8942", "filename": "src/test/ui/consts/issue-44415.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `Foo::bytes::{constant#0}`\n+error[E0391]: cycle detected when evaluate type-level constant\n   --> $DIR/issue-44415.rs:6:17\n    |\n LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n    |                 ^^^^^^\n    |\n-note: ...which requires simplifying constant for the type system `Foo::bytes::{constant#0}`...\n+note: ...which requires const-evaluating + checking `Foo::bytes::{constant#0}`...\n   --> $DIR/issue-44415.rs:6:17\n    |\n LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n@@ -17,7 +17,7 @@ LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n    = note: ...which requires computing layout of `Foo`...\n    = note: ...which requires computing layout of `[u8; _]`...\n    = note: ...which requires normalizing `[u8; _]`...\n-   = note: ...which again requires simplifying constant for the type system `Foo::bytes::{constant#0}`, completing the cycle\n+   = note: ...which again requires evaluate type-level constant, completing the cycle\n note: cycle used when checking that `Foo` is well-formed\n   --> $DIR/issue-44415.rs:5:1\n    |"}, {"sha": "7a00fe964ab08da4d7d7c51f24cdf0dc3bc6272b", "filename": "src/test/ui/consts/issue-77062-large-zst-array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fissue-77062-large-zst-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fconsts%2Fissue-77062-large-zst-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-77062-large-zst-array.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,4 +1,4 @@\n-// build-pass\n+// check-pass\n \n fn main() {\n     let _ = &[(); usize::MAX];"}, {"sha": "4856418ed600229d153ce311781e0b01196b158c", "filename": "src/test/ui/issues/issue-17252.stderr", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,21 +1,10 @@\n-error[E0391]: cycle detected when normalizing `FOO`\n-   |\n-note: ...which requires simplifying constant for the type system `FOO`...\n-  --> $DIR/issue-17252.rs:1:1\n-   |\n-LL | const FOO: usize = FOO;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `FOO`...\n+error[E0391]: cycle detected when const-evaluating + checking `FOO`\n   --> $DIR/issue-17252.rs:1:1\n    |\n LL | const FOO: usize = FOO;\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires const-evaluating + checking `FOO`...\n-  --> $DIR/issue-17252.rs:1:1\n    |\n-LL | const FOO: usize = FOO;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires normalizing `FOO`, completing the cycle\n+   = note: ...which immediately requires const-evaluating + checking `FOO` again\n note: cycle used when const-evaluating + checking `main::{constant#0}`\n   --> $DIR/issue-17252.rs:4:18\n    |"}, {"sha": "9366050d7ecdf86f1714a4592ea579f06f331112", "filename": "src/test/ui/issues/issue-23302-1.stderr", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,26 +1,15 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `X::A::{constant#0}`\n+error[E0391]: cycle detected when const-evaluating + checking `X::A::{constant#0}`\n   --> $DIR/issue-23302-1.rs:4:9\n    |\n LL |     A = X::A as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-note: ...which requires simplifying constant for the type system `X::A::{constant#0}`...\n+   = note: ...which immediately requires const-evaluating + checking `X::A::{constant#0}` again\n+note: cycle used when simplifying constant for the type system `X::A::{constant#0}`\n   --> $DIR/issue-23302-1.rs:4:9\n    |\n LL |     A = X::A as isize,\n    |         ^^^^^^^^^^^^^\n-note: ...which requires const-evaluating + checking `X::A::{constant#0}`...\n-  --> $DIR/issue-23302-1.rs:4:9\n-   |\n-LL |     A = X::A as isize,\n-   |         ^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `X::A as isize`...\n-   = note: ...which again requires simplifying constant for the type system `X::A::{constant#0}`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/issue-23302-1.rs:3:1\n-   |\n-LL | enum X {\n-   | ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b97ae287a47a976dba3119de24dbf178abd080fd", "filename": "src/test/ui/issues/issue-23302-2.stderr", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,26 +1,15 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `Y::A::{constant#0}`\n+error[E0391]: cycle detected when const-evaluating + checking `Y::A::{constant#0}`\n   --> $DIR/issue-23302-2.rs:4:9\n    |\n LL |     A = Y::B as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-note: ...which requires simplifying constant for the type system `Y::A::{constant#0}`...\n+   = note: ...which immediately requires const-evaluating + checking `Y::A::{constant#0}` again\n+note: cycle used when simplifying constant for the type system `Y::A::{constant#0}`\n   --> $DIR/issue-23302-2.rs:4:9\n    |\n LL |     A = Y::B as isize,\n    |         ^^^^^^^^^^^^^\n-note: ...which requires const-evaluating + checking `Y::A::{constant#0}`...\n-  --> $DIR/issue-23302-2.rs:4:9\n-   |\n-LL |     A = Y::B as isize,\n-   |         ^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `Y::B as isize`...\n-   = note: ...which again requires simplifying constant for the type system `Y::A::{constant#0}`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/issue-23302-2.rs:3:1\n-   |\n-LL | enum Y {\n-   | ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "1a07d4a95bcfacca5b69d2f7d3467b211118b8ff", "filename": "src/test/ui/issues/issue-23302-3.stderr", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,38 +1,20 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `A`\n+error[E0391]: cycle detected when const-evaluating + checking `A`\n   --> $DIR/issue-23302-3.rs:1:1\n    |\n LL | const A: i32 = B;\n    | ^^^^^^^^^^^^^^^^^\n    |\n-note: ...which requires simplifying constant for the type system `A`...\n-  --> $DIR/issue-23302-3.rs:1:1\n-   |\n-LL | const A: i32 = B;\n-   | ^^^^^^^^^^^^^^^^^\n-note: ...which requires const-evaluating + checking `A`...\n-  --> $DIR/issue-23302-3.rs:1:1\n-   |\n-LL | const A: i32 = B;\n-   | ^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `B`...\n-note: ...which requires simplifying constant for the type system `B`...\n-  --> $DIR/issue-23302-3.rs:3:1\n-   |\n-LL | const B: i32 = A;\n-   | ^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `B`...\n+note: ...which requires const-evaluating + checking `B`...\n   --> $DIR/issue-23302-3.rs:3:1\n    |\n LL | const B: i32 = A;\n    | ^^^^^^^^^^^^^^^^^\n-note: ...which requires const-evaluating + checking `B`...\n-  --> $DIR/issue-23302-3.rs:3:1\n+   = note: ...which again requires const-evaluating + checking `A`, completing the cycle\n+note: cycle used when simplifying constant for the type system `A`\n+  --> $DIR/issue-23302-3.rs:1:1\n    |\n-LL | const B: i32 = A;\n+LL | const A: i32 = B;\n    | ^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `A`...\n-   = note: ...which again requires simplifying constant for the type system `A`, completing the cycle\n-   = note: cycle used when running analysis passes on this crate\n \n error: aborting due to previous error\n "}, {"sha": "64873ac35a00213e78fc7479e75ba180f5029a34", "filename": "src/test/ui/issues/issue-41394.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-41394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-41394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41394.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -5,6 +5,7 @@ enum Foo {\n \n enum Bar {\n     A = Foo::A as isize\n+    //~^ ERROR evaluation of constant value failed\n }\n \n fn main() {}"}, {"sha": "47a24547d4533dcf333588d10315f2c42f942f7c", "filename": "src/test/ui/issues/issue-41394.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-41394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-41394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41394.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -6,6 +6,13 @@ LL |     A = \"\" + 1\n    |         |\n    |         &str\n \n-error: aborting due to previous error\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-41394.rs:7:9\n+   |\n+LL |     A = Foo::A as isize\n+   |         ^^^^^^^^^^^^^^^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0369`.\n+Some errors have detailed explanations: E0080, E0369.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "ddd391415414763bb38d0f06348458cea2ee85e6", "filename": "src/test/ui/issues/issue-54954.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-54954.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-54954.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54954.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -9,6 +9,8 @@ trait Tt {\n }\n \n fn f(z: [f32; ARR_LEN]) -> [f32; ARR_LEN] {\n+  //~^ ERROR evaluation of constant value failed\n+  //~| ERROR evaluation of constant value failed\n     z\n }\n "}, {"sha": "6e8d3cac9a7e4f365ea3b338c0d6f793157733cb", "filename": "src/test/ui/issues/issue-54954.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-54954.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-54954.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54954.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -12,7 +12,19 @@ LL | const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n    |\n    = note: cannot satisfy `_: Tt`\n \n-error: aborting due to 2 previous errors\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-54954.rs:11:15\n+   |\n+LL | fn f(z: [f32; ARR_LEN]) -> [f32; ARR_LEN] {\n+   |               ^^^^^^^ referenced constant has errors\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-54954.rs:11:34\n+   |\n+LL | fn f(z: [f32; ARR_LEN]) -> [f32; ARR_LEN] {\n+   |                                  ^^^^^^^ referenced constant has errors\n+\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0283, E0379.\n-For more information about an error, try `rustc --explain E0283`.\n+Some errors have detailed explanations: E0080, E0283, E0379.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "32f51d513d122086708ee0f37989a23274bb9a51", "filename": "src/test/ui/issues/issue-68010-large-zst-consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-68010-large-zst-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-68010-large-zst-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-68010-large-zst-consts.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -1,4 +1,4 @@\n-// build-pass\n+// check-pass\n \n fn main() {\n     println!(\"{}\", [(); usize::MAX].len());"}, {"sha": "6851b67cb3b3aa3cfa3ac81fe21e3c3af4d4f4b5", "filename": "src/test/ui/issues/issue-69602-type-err-during-codegen-ice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -19,4 +19,5 @@ impl TraitB for B { //~ ERROR not all trait items implemented, missing: `MyA`\n \n fn main() {\n     let _ = [0; B::VALUE];\n+    //~^ ERROR evaluation of constant value failed\n }"}, {"sha": "cb5b397849c06334fd95724b85d41571ea078e79", "filename": "src/test/ui/issues/issue-69602-type-err-during-codegen-ice.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -13,7 +13,13 @@ LL |     type MyA: TraitA;\n LL | impl TraitB for B {\n    | ^^^^^^^^^^^^^^^^^ missing `MyA` in implementation\n \n-error: aborting due to 2 previous errors\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-69602-type-err-during-codegen-ice.rs:21:17\n+   |\n+LL |     let _ = [0; B::VALUE];\n+   |                 ^^^^^^^^ referenced constant has errors\n+\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0046, E0437.\n+Some errors have detailed explanations: E0046, E0080, E0437.\n For more information about an error, try `rustc --explain E0046`."}, {"sha": "78a20cf8ebb05eab5f6d74fbc37b91bbeb28c38c", "filename": "src/test/ui/resolve/issue-50599.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -2,4 +2,5 @@ fn main() {\n     const N: u32 = 1_000;\n     const M: usize = (f64::from(N) * std::f64::LOG10_2) as usize; //~ ERROR cannot find value\n     let mut digits = [0u32; M];\n+    //~^ ERROR evaluation of constant value failed\n }"}, {"sha": "f0cb784f56c48037804dfbceb84655104f6b5bda", "filename": "src/test/ui/resolve/issue-50599.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -16,6 +16,13 @@ LL -     const M: usize = (f64::from(N) * std::f64::LOG10_2) as usize;\n LL +     const M: usize = (f64::from(N) * LOG10_2) as usize;\n    | \n \n-error: aborting due to previous error\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-50599.rs:4:29\n+   |\n+LL |     let mut digits = [0u32; M];\n+   |                             ^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0425`.\n+Some errors have detailed explanations: E0080, E0425.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "f37f093d9ede7b6f07aebfdaa310efb3a58b3493", "filename": "src/test/ui/type/type-dependent-def-issue-49241.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -2,4 +2,5 @@ fn main() {\n     let v = vec![0];\n     const l: usize = v.count(); //~ ERROR attempt to use a non-constant value in a constant\n     let s: [u32; l] = v.into_iter().collect();\n+    //~^ERROR evaluation of constant value failed\n }"}, {"sha": "02f267c6c8d73419c7cb6da9f6f5c78a8109051c", "filename": "src/test/ui/type/type-dependent-def-issue-49241.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.stderr?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -6,6 +6,13 @@ LL |     const l: usize = v.count();\n    |     |\n    |     help: consider using `let` instead of `const`: `let l`\n \n-error: aborting due to previous error\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/type-dependent-def-issue-49241.rs:4:18\n+   |\n+LL |     let s: [u32; l] = v.into_iter().collect();\n+   |                  ^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0435`.\n+Some errors have detailed explanations: E0080, E0435.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "5d687d06f6f46085485fecf44a8610143f2dd9c8", "filename": "src/tools/clippy/clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -48,10 +48,10 @@ impl<'tcx> LateLintPass<'tcx> for UnportableVariant {\n                     let mut ty = cx.tcx.type_of(def_id.to_def_id());\n                     let constant = cx\n                         .tcx\n-                        .const_eval_poly(def_id.to_def_id())\n+                        .const_eval_poly_for_typeck(def_id.to_def_id())\n                         .ok()\n-                        .map(|val| rustc_middle::ty::Const::from_value(cx.tcx, val, ty));\n-                    if let Some(Constant::Int(val)) = constant.and_then(miri_to_const) {\n+                        .and_then(|val| val.map(|valtree| rustc_middle::ty::Const::from_value(cx.tcx, valtree, ty)));\n+                    if let Some(Constant::Int(val)) = constant.and_then(|c| miri_to_const(cx.tcx, c)) {\n                         if let ty::Adt(adt, _) = ty.kind() {\n                             if adt.is_enum() {\n                                 ty = adt.repr().discr_type().to_ty(cx.tcx);"}, {"sha": "e10993ba7ddce0685ce140fc99547b72f2b9cd92", "filename": "src/tools/clippy/clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -3,7 +3,6 @@ use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, ConstKind};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -53,8 +52,8 @@ impl<'tcx> LateLintPass<'tcx> for LargeConstArrays {\n             if let ItemKind::Const(hir_ty, _) = &item.kind;\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             if let ty::Array(element_type, cst) = ty.kind();\n-            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.kind();\n-            if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n+            if let ConstKind::Value(ty::ValTree::Leaf(element_count)) = cst.kind();\n+            if let Ok(element_count) = element_count.try_to_machine_usize(cx.tcx);\n             if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;\n "}, {"sha": "0acbd81aec3438ab99989d2fda6c8960257045b6", "filename": "src/tools/clippy/clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -3,7 +3,6 @@ use clippy_utils::source::snippet;\n use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, ConstKind};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -43,8 +42,8 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n             if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind();\n-            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.kind();\n-            if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n+            if let ConstKind::Value(ty::ValTree::Leaf(element_count)) = cst.kind();\n+            if let Ok(element_count) = element_count.try_to_machine_usize(cx.tcx);\n             if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;\n             then {"}, {"sha": "afca7530556b2dcad330fa60391512fa8362158b", "filename": "src/tools/clippy/clippy_lints/src/matches/overlapping_arms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -34,11 +34,11 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                 if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n                     let lhs_const = match lhs {\n                         Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n-                        None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n+                        None => miri_to_const(cx.tcx, ty.numeric_min_val(cx.tcx)?)?,\n                     };\n                     let rhs_const = match rhs {\n                         Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n-                        None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n+                        None => miri_to_const(cx.tcx, ty.numeric_max_val(cx.tcx)?)?,\n                     };\n                     let lhs_val = lhs_const.int_value(cx, ty)?;\n                     let rhs_val = rhs_const.int_value(cx, ty)?;"}, {"sha": "9f6fca27b229591b441cb9ca312abdf0d76de2b2", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::{\n     BodyId, Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass, Lint};\n-use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n+use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::adjustment::Adjust;\n use rustc_middle::ty::{self, Const, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -133,7 +133,7 @@ fn is_unfrozen<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n \n fn is_value_unfrozen_raw<'tcx>(\n     cx: &LateContext<'tcx>,\n-    result: Result<ConstValue<'tcx>, ErrorHandled>,\n+    result: Result<Option<ty::ValTree<'tcx>>, ErrorHandled>,\n     ty: Ty<'tcx>,\n ) -> bool {\n     fn inner<'tcx>(cx: &LateContext<'tcx>, val: Const<'tcx>) -> bool {\n@@ -142,7 +142,7 @@ fn is_value_unfrozen_raw<'tcx>(\n             // leads us to the point checking `UnsafeCell` directly is the only option.\n             ty::Adt(ty_def, ..) if Some(ty_def.did()) == cx.tcx.lang_items().unsafe_cell_type() => true,\n             ty::Array(..) | ty::Adt(..) | ty::Tuple(..) => {\n-                let val = cx.tcx.destructure_const(cx.param_env.and(val));\n+                let val = cx.tcx.destructure_const(val);\n                 val.fields.iter().any(|field| inner(cx, *field))\n             },\n             _ => false,\n@@ -174,19 +174,19 @@ fn is_value_unfrozen_raw<'tcx>(\n             // I chose this way because unfrozen enums as assoc consts are rare (or, hopefully, none).\n             err == ErrorHandled::TooGeneric\n         },\n-        |val| inner(cx, Const::from_value(cx.tcx, val, ty)),\n+        |val| val.map_or(false, |val| inner(cx, Const::from_value(cx.tcx, val, ty))),\n     )\n }\n \n fn is_value_unfrozen_poly<'tcx>(cx: &LateContext<'tcx>, body_id: BodyId, ty: Ty<'tcx>) -> bool {\n-    let result = cx.tcx.const_eval_poly(body_id.hir_id.owner.to_def_id());\n+    let result = cx.tcx.const_eval_poly_for_typeck(body_id.hir_id.owner.to_def_id());\n     is_value_unfrozen_raw(cx, result, ty)\n }\n \n fn is_value_unfrozen_expr<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId, def_id: DefId, ty: Ty<'tcx>) -> bool {\n     let substs = cx.typeck_results().node_substs(hir_id);\n \n-    let result = cx.tcx.const_eval_resolve(\n+    let result = cx.tcx.const_eval_resolve_for_typeck(\n         cx.param_env,\n         ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs),\n         None,"}, {"sha": "c31c560f427f25ef3ec33c05078ffa7b1158e182", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 52, "deletions": 64, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705d818bd52a6324d5e7693cc4306457395eebc8/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=705d818bd52a6324d5e7693cc4306457395eebc8", "patch": "@@ -7,7 +7,6 @@ use rustc_data_structures::sync::Lrc;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, Item, ItemKind, Node, QPath, UnOp};\n use rustc_lint::LateContext;\n-use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::{self, EarlyBinder, FloatTy, ScalarInt, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug};\n@@ -423,14 +422,14 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 let result = self\n                     .lcx\n                     .tcx\n-                    .const_eval_resolve(\n+                    .const_eval_resolve_for_typeck(\n                         self.param_env,\n                         ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs),\n                         None,\n                     )\n                     .ok()\n-                    .map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty))?;\n-                let result = miri_to_const(result);\n+                    .and_then(|val| val.map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty)))?;\n+                let result = miri_to_const(self.lcx.tcx, result);\n                 if result.is_some() {\n                     self.needed_resolution = true;\n                 }\n@@ -580,80 +579,69 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n     }\n }\n \n-pub fn miri_to_const(result: ty::Const<'_>) -> Option<Constant> {\n-    use rustc_middle::mir::interpret::ConstValue;\n+pub fn miri_to_const<'tcx>(tcx: TyCtxt<'tcx>, result: ty::Const<'tcx>) -> Option<Constant> {\n     match result.kind() {\n-        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(int))) => {\n-            match result.ty().kind() {\n-                ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n-                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),\n-                ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n+        ty::ConstKind::Value(valtree) => {\n+            match (valtree, result.ty().kind()) {\n+                (ty::ValTree::Leaf(int), ty::Bool) => Some(Constant::Bool(int == ScalarInt::TRUE)),\n+                (ty::ValTree::Leaf(int), ty::Uint(_) | ty::Int(_)) => Some(Constant::Int(int.assert_bits(int.size()))),\n+                (ty::ValTree::Leaf(int), ty::Float(FloatTy::F32)) => Some(Constant::F32(f32::from_bits(\n                     int.try_into().expect(\"invalid f32 bit representation\"),\n                 ))),\n-                ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n+                (ty::ValTree::Leaf(int), ty::Float(FloatTy::F64)) => Some(Constant::F64(f64::from_bits(\n                     int.try_into().expect(\"invalid f64 bit representation\"),\n                 ))),\n-                ty::RawPtr(type_and_mut) => {\n+                (ty::ValTree::Leaf(int), ty::RawPtr(type_and_mut)) => {\n                     if let ty::Uint(_) = type_and_mut.ty.kind() {\n                         return Some(Constant::RawPtr(int.assert_bits(int.size())));\n                     }\n                     None\n                 },\n-                // FIXME: implement other conversions.\n-                _ => None,\n-            }\n-        },\n-        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty().kind() {\n-            ty::Ref(_, tam, _) => match tam.kind() {\n-                ty::Str => String::from_utf8(\n-                    data.inner()\n-                        .inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n-                        .to_owned(),\n-                )\n-                .ok()\n-                .map(Constant::Str),\n-                _ => None,\n-            },\n-            _ => None,\n-        },\n-        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty().kind() {\n-            ty::Array(sub_type, len) => match sub_type.kind() {\n-                ty::Float(FloatTy::F32) => match miri_to_const(*len) {\n-                    Some(Constant::Int(len)) => alloc\n-                        .inner()\n-                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n-                        .to_owned()\n-                        .chunks(4)\n-                        .map(|chunk| {\n-                            Some(Constant::F32(f32::from_le_bytes(\n-                                chunk.try_into().expect(\"this shouldn't happen\"),\n-                            )))\n-                        })\n-                        .collect::<Option<Vec<Constant>>>()\n-                        .map(Constant::Vec),\n-                    _ => None,\n-                },\n-                ty::Float(FloatTy::F64) => match miri_to_const(*len) {\n-                    Some(Constant::Int(len)) => alloc\n-                        .inner()\n-                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n-                        .to_owned()\n-                        .chunks(8)\n-                        .map(|chunk| {\n-                            Some(Constant::F64(f64::from_le_bytes(\n-                                chunk.try_into().expect(\"this shouldn't happen\"),\n-                            )))\n-                        })\n-                        .collect::<Option<Vec<Constant>>>()\n-                        .map(Constant::Vec),\n+                (ty::ValTree::Branch(_), ty::Ref(_, inner_ty, _)) if *inner_ty == tcx.types.str_ => valtree\n+                    .try_to_raw_bytes(tcx, result.ty())\n+                    .and_then(|bytes| String::from_utf8(bytes.to_owned()).ok().map(Constant::Str)),\n+                (ty::ValTree::Branch(_), ty::Array(arr_ty, len)) => match arr_ty.kind() {\n+                    ty::Float(float_ty) => {\n+                        let chunk_size = match float_ty {\n+                            FloatTy::F32 => 4,\n+                            FloatTy::F64 => 8,\n+                        };\n+\n+                        match miri_to_const(tcx, *len) {\n+                            Some(Constant::Int(_)) => valtree.try_to_raw_bytes(tcx, result.ty()).and_then(|bytes| {\n+                                bytes\n+                                    .to_owned()\n+                                    .chunks(chunk_size)\n+                                    .map(|chunk| match float_ty {\n+                                        FloatTy::F32 => {\n+                                            let float = f32::from_le_bytes(\n+                                                chunk\n+                                                    .try_into()\n+                                                    .expect(&format!(\"expected to construct f32 from {:?}\", chunk)),\n+                                            );\n+                                            Some(Constant::F32(float))\n+                                        },\n+                                        FloatTy::F64 => {\n+                                            let float = f64::from_le_bytes(\n+                                                chunk\n+                                                    .try_into()\n+                                                    .expect(&format!(\"expected to construct f64 from {:?}\", chunk)),\n+                                            );\n+                                            Some(Constant::F64(float))\n+                                        },\n+                                    })\n+                                    .collect::<Option<Vec<Constant>>>()\n+                                    .map(Constant::Vec)\n+                            }),\n+                            _ => None,\n+                        }\n+                    },\n                     _ => None,\n                 },\n-                // FIXME: implement other array type conversions.\n+                // FIXME: implement other conversions.\n                 _ => None,\n-            },\n-            _ => None,\n+            }\n         },\n-        // FIXME: implement other conversions.\n         _ => None,\n     }\n }"}]}