{"sha": "a68ff269a921b4a3d19256a0f53596e84776105a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2OGZmMjY5YTkyMWI0YTNkMTkyNTZhMGY1MzU5NmU4NDc3NjEwNWE=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-12-15T06:39:15Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-12-15T06:39:15Z"}, "message": "Expand statements for mbe in lowering", "tree": {"sha": "2e65ef55834dcc43f235edeb3d072bfc0df2b018", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e65ef55834dcc43f235edeb3d072bfc0df2b018"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a68ff269a921b4a3d19256a0f53596e84776105a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a68ff269a921b4a3d19256a0f53596e84776105a", "html_url": "https://github.com/rust-lang/rust/commit/a68ff269a921b4a3d19256a0f53596e84776105a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a68ff269a921b4a3d19256a0f53596e84776105a/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbd0cfba531c21de01af7b1a12ce9eb6b1271a5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbd0cfba531c21de01af7b1a12ce9eb6b1271a5d", "html_url": "https://github.com/rust-lang/rust/commit/dbd0cfba531c21de01af7b1a12ce9eb6b1271a5d"}], "stats": {"total": 222, "additions": 139, "deletions": 83}, "files": [{"sha": "6c0de3ee88be817360fc20b69a88f68e2192cb16", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 134, "deletions": 82, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/a68ff269a921b4a3d19256a0f53596e84776105a/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a68ff269a921b4a3d19256a0f53596e84776105a/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=a68ff269a921b4a3d19256a0f53596e84776105a", "patch": "@@ -548,62 +548,83 @@ impl ExprCollector<'_> {\n                 }\n             }\n             ast::Expr::MacroCall(e) => {\n-                if let Some(name) = e.is_macro_rules().map(|it| it.as_name()) {\n-                    let mac = MacroDefId {\n-                        krate: Some(self.expander.module.krate),\n-                        ast_id: Some(self.expander.ast_id(&e)),\n-                        kind: MacroDefKind::Declarative,\n-                        local_inner: false,\n-                    };\n-                    self.body.item_scope.define_legacy_macro(name, mac);\n-\n-                    // FIXME: do we still need to allocate this as missing ?\n-                    self.alloc_expr(Expr::Missing, syntax_ptr)\n-                } else {\n-                    // File containing the macro call. Expansion errors will be attached here.\n-                    let outer_file = self.expander.current_file_id;\n-\n-                    let macro_call = self.expander.to_source(AstPtr::new(&e));\n-                    let res = self.expander.enter_expand(self.db, Some(&self.body.item_scope), e);\n-\n-                    match res.err {\n-                        Some(ExpandError::UnresolvedProcMacro) => {\n-                            self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedProcMacro(\n-                                UnresolvedProcMacro {\n-                                    file: outer_file,\n-                                    node: syntax_ptr.clone().into(),\n-                                    precise_location: None,\n-                                    macro_name: None,\n-                                },\n-                            ));\n-                        }\n-                        Some(err) => {\n-                            self.source_map.diagnostics.push(BodyDiagnostic::MacroError(\n-                                MacroError {\n-                                    file: outer_file,\n-                                    node: syntax_ptr.clone().into(),\n-                                    message: err.to_string(),\n-                                },\n-                            ));\n-                        }\n-                        None => {}\n-                    }\n+                let mut ids = vec![];\n+                self.collect_macro_call(e, syntax_ptr.clone(), |this, expansion| {\n+                    ids.push(match expansion {\n+                        Some(it) => this.collect_expr(it),\n+                        None => this.alloc_expr(Expr::Missing, syntax_ptr.clone()),\n+                    })\n+                });\n+                ids[0]\n+            }\n+        }\n+    }\n \n-                    match res.value {\n-                        Some((mark, expansion)) => {\n-                            self.source_map\n-                                .expansions\n-                                .insert(macro_call, self.expander.current_file_id);\n-\n-                            let item_tree = self.db.item_tree(self.expander.current_file_id);\n-                            self.item_trees.insert(self.expander.current_file_id, item_tree);\n-                            let id = self.collect_expr(expansion);\n-                            self.expander.exit(self.db, mark);\n-                            id\n-                        }\n-                        None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+    fn collect_macro_call<F: FnMut(&mut Self, Option<T>), T: ast::AstNode>(\n+        &mut self,\n+        e: ast::MacroCall,\n+        syntax_ptr: AstPtr<ast::Expr>,\n+        mut collector: F,\n+    ) {\n+        if let Some(name) = e.is_macro_rules().map(|it| it.as_name()) {\n+            let mac = MacroDefId {\n+                krate: Some(self.expander.module.krate),\n+                ast_id: Some(self.expander.ast_id(&e)),\n+                kind: MacroDefKind::Declarative,\n+                local_inner: false,\n+            };\n+            self.body.item_scope.define_legacy_macro(name, mac);\n+\n+            // FIXME: do we still need to allocate this as missing ?\n+            collector(self, None);\n+        } else {\n+            // File containing the macro call. Expansion errors will be attached here.\n+            let outer_file = self.expander.current_file_id;\n+\n+            let macro_call = self.expander.to_source(AstPtr::new(&e));\n+            let res = self.expander.enter_expand(self.db, Some(&self.body.item_scope), e);\n+\n+            match &res.err {\n+                Some(ExpandError::UnresolvedProcMacro) => {\n+                    self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedProcMacro(\n+                        UnresolvedProcMacro {\n+                            file: outer_file,\n+                            node: syntax_ptr.into(),\n+                            precise_location: None,\n+                            macro_name: None,\n+                        },\n+                    ));\n+                }\n+                Some(err) => {\n+                    self.source_map.diagnostics.push(BodyDiagnostic::MacroError(MacroError {\n+                        file: outer_file,\n+                        node: syntax_ptr.into(),\n+                        message: err.to_string(),\n+                    }));\n+                }\n+                None => {}\n+            }\n+\n+            match res.value {\n+                Some((mark, expansion)) => {\n+                    // FIXME: Statements are too complicated to recover from error for now.\n+                    // It is because we don't have any hygenine for local variable expansion right now.\n+                    if T::can_cast(syntax::SyntaxKind::MACRO_STMTS) && res.err.is_some() {\n+                        self.expander.exit(self.db, mark);\n+                        collector(self, None);\n+                    } else {\n+                        self.source_map\n+                            .expansions\n+                            .insert(macro_call, self.expander.current_file_id);\n+\n+                        let item_tree = self.db.item_tree(self.expander.current_file_id);\n+                        self.item_trees.insert(self.expander.current_file_id, item_tree);\n+\n+                        collector(self, Some(expansion));\n+                        self.expander.exit(self.db, mark);\n                     }\n                 }\n+                None => collector(self, None),\n             }\n         }\n     }\n@@ -642,44 +663,75 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {\n-        let syntax_node_ptr = AstPtr::new(&block.clone().into());\n-        self.collect_block_items(&block);\n-        let statements = block\n-            .statements()\n-            .filter_map(|s| {\n-                let stmt = match s {\n-                    ast::Stmt::LetStmt(stmt) => {\n-                        self.check_cfg(&stmt)?;\n-\n-                        let pat = self.collect_pat_opt(stmt.pat());\n-                        let type_ref = stmt.ty().map(|it| TypeRef::from_ast(&self.ctx(), it));\n-                        let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                        Statement::Let { pat, type_ref, initializer }\n-                    }\n-                    ast::Stmt::ExprStmt(stmt) => {\n-                        self.check_cfg(&stmt)?;\n+    fn collect_stmt(&mut self, s: ast::Stmt) -> Option<Vec<Statement>> {\n+        let stmt =\n+            match s {\n+                ast::Stmt::LetStmt(stmt) => {\n+                    self.check_cfg(&stmt)?;\n \n-                        Statement::Expr(self.collect_expr_opt(stmt.expr()))\n-                    }\n-                    ast::Stmt::Item(item) => {\n-                        self.check_cfg(&item)?;\n+                    let pat = self.collect_pat_opt(stmt.pat());\n+                    let type_ref = stmt.ty().map(|it| TypeRef::from_ast(&self.ctx(), it));\n+                    let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n+                    vec![Statement::Let { pat, type_ref, initializer }]\n+                }\n+                ast::Stmt::ExprStmt(stmt) => {\n+                    self.check_cfg(&stmt)?;\n+\n+                    // Note that macro could be expended to multiple statements\n+                    if let Some(ast::Expr::MacroCall(m)) = stmt.expr() {\n+                        let syntax_ptr = AstPtr::new(&stmt.expr().unwrap());\n+                        let mut stmts = vec![];\n+\n+                        self.collect_macro_call(m, syntax_ptr.clone(), |this, expansion| {\n+                            match expansion {\n+                                Some(expansion) => {\n+                                    let statements: ast::MacroStmts = expansion;\n+                                    this.collect_stmts_items(statements.statements());\n \n-                        return None;\n+                                    statements.statements().for_each(|stmt| {\n+                                        if let Some(mut r) = this.collect_stmt(stmt) {\n+                                            stmts.append(&mut r);\n+                                        }\n+                                    });\n+                                    if let Some(expr) = statements.expr() {\n+                                        stmts.push(Statement::Expr(this.collect_expr(expr)));\n+                                    }\n+                                }\n+                                None => {\n+                                    stmts.push(Statement::Expr(\n+                                        this.alloc_expr(Expr::Missing, syntax_ptr.clone()),\n+                                    ));\n+                                }\n+                            }\n+                        });\n+                        stmts\n+                    } else {\n+                        vec![Statement::Expr(self.collect_expr_opt(stmt.expr()))]\n                     }\n-                };\n-                Some(stmt)\n-            })\n-            .collect();\n+                }\n+                ast::Stmt::Item(item) => {\n+                    self.check_cfg(&item)?;\n+\n+                    return None;\n+                }\n+            };\n+\n+        Some(stmt)\n+    }\n+\n+    fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {\n+        let syntax_node_ptr = AstPtr::new(&block.clone().into());\n+        self.collect_stmts_items(block.statements());\n+        let statements =\n+            block.statements().filter_map(|s| self.collect_stmt(s)).flatten().collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n         self.alloc_expr(Expr::Block { statements, tail, label: None }, syntax_node_ptr)\n     }\n \n-    fn collect_block_items(&mut self, block: &ast::BlockExpr) {\n+    fn collect_stmts_items(&mut self, stmts: ast::AstChildren<ast::Stmt>) {\n         let container = ContainerId::DefWithBodyId(self.def);\n \n-        let items = block\n-            .statements()\n+        let items = stmts\n             .filter_map(|stmt| match stmt {\n                 ast::Stmt::Item(it) => Some(it),\n                 ast::Stmt::LetStmt(_) | ast::Stmt::ExprStmt(_) => None,"}, {"sha": "864fad170fc7a8d7364f9a0b798bb7de1d1215ad", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a68ff269a921b4a3d19256a0f53596e84776105a/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a68ff269a921b4a3d19256a0f53596e84776105a/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=a68ff269a921b4a3d19256a0f53596e84776105a", "patch": "@@ -94,6 +94,9 @@ impl ItemTree {\n                 ast::MacroItems(items) => {\n                     ctx.lower_module_items(&items)\n                 },\n+                ast::MacroStmts(stmts) => {\n+                    ctx.lower_inner_items(stmts.syntax())\n+                },\n                 // Macros can expand to expressions. We return an empty item tree in this case, but\n                 // still need to collect inner items.\n                 ast::Expr(e) => {"}, {"sha": "7fc700e821be763f6103795baf4438d7e8b2588f", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a68ff269a921b4a3d19256a0f53596e84776105a/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a68ff269a921b4a3d19256a0f53596e84776105a/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=a68ff269a921b4a3d19256a0f53596e84776105a", "patch": "@@ -395,7 +395,8 @@ fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n             FragmentKind::Expr\n         }\n         // FIXME: Expand to statements in appropriate positions; HIR lowering needs to handle that\n-        EXPR_STMT | BLOCK_EXPR => FragmentKind::Expr,\n+        EXPR_STMT => FragmentKind::Statements,\n+        BLOCK_EXPR => FragmentKind::Expr,\n         ARG_LIST => FragmentKind::Expr,\n         TRY_EXPR => FragmentKind::Expr,\n         TUPLE_EXPR => FragmentKind::Expr,"}]}