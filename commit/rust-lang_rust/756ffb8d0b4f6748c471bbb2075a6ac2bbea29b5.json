{"sha": "756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5", "node_id": "C_kwDOAAsO6NoAKDc1NmZmYjhkMGI0ZjY3NDhjNDcxYmJiMjA3NWE2YWMyYmJlYTI5YjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-25T07:28:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-25T07:28:09Z"}, "message": "Auto merge of #95246 - ChrisDenton:command-args, r=joshtriplett\n\nWindows Command: Don't run batch files using verbatim paths\n\nFixes #95178\n\nNote that the first commit does some minor refactoring (moving command line argument building to args.rs). The actual changes are in the second.", "tree": {"sha": "46c1408cfe52c718d66dd40d446a574b9a02ad7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46c1408cfe52c718d66dd40d446a574b9a02ad7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5", "html_url": "https://github.com/rust-lang/rust/commit/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fedbe5dabc815bd710217221bfebad1ff9f37a43", "url": "https://api.github.com/repos/rust-lang/rust/commits/fedbe5dabc815bd710217221bfebad1ff9f37a43", "html_url": "https://github.com/rust-lang/rust/commit/fedbe5dabc815bd710217221bfebad1ff9f37a43"}, {"sha": "4a0ec50f0d6e719eb12aaa2966c5a93c238e2b57", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a0ec50f0d6e719eb12aaa2966c5a93c238e2b57", "html_url": "https://github.com/rust-lang/rust/commit/4a0ec50f0d6e719eb12aaa2966c5a93c238e2b57"}], "stats": {"total": 330, "additions": 226, "deletions": 104}, "files": [{"sha": "955ad68916c216ae5fc7493cbca3781309b1e6fe", "filename": "library/std/src/process/tests.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs?ref=756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5", "patch": "@@ -435,3 +435,24 @@ fn run_bat_script() {\n     assert!(output.status.success());\n     assert_eq!(String::from_utf8_lossy(&output.stdout).trim(), \"Hello, fellow Rustaceans!\");\n }\n+\n+// See issue #95178\n+#[test]\n+#[cfg(windows)]\n+fn run_canonical_bat_script() {\n+    let tempdir = crate::sys_common::io::test::tmpdir();\n+    let script_path = tempdir.join(\"hello.cmd\");\n+\n+    crate::fs::write(&script_path, \"@echo Hello, %~1!\").unwrap();\n+\n+    // Try using a canonical path\n+    let output = Command::new(&script_path.canonicalize().unwrap())\n+        .arg(\"fellow Rustaceans\")\n+        .stdout(crate::process::Stdio::piped())\n+        .spawn()\n+        .unwrap()\n+        .wait_with_output()\n+        .unwrap();\n+    assert!(output.status.success());\n+    assert_eq!(String::from_utf8_lossy(&output.stdout).trim(), \"Hello, fellow Rustaceans!\");\n+}"}, {"sha": "c5918103fec254eb9d7ed6a7e23019ce07711594", "filename": "library/std/src/sys/windows/args.rs", "status": "modified", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs?ref=756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5", "patch": "@@ -8,12 +8,14 @@ mod tests;\n \n use crate::ffi::OsString;\n use crate::fmt;\n+use crate::io;\n use crate::marker::PhantomData;\n use crate::num::NonZeroU16;\n use crate::os::windows::prelude::*;\n use crate::path::PathBuf;\n use crate::ptr::NonNull;\n use crate::sys::c;\n+use crate::sys::process::ensure_no_nuls;\n use crate::sys::windows::os::current_exe;\n use crate::vec;\n \n@@ -234,3 +236,160 @@ impl Iterator for WStrUnits<'_> {\n         }\n     }\n }\n+\n+#[derive(Debug)]\n+pub(crate) enum Arg {\n+    /// Add quotes (if needed)\n+    Regular(OsString),\n+    /// Append raw string without quoting\n+    Raw(OsString),\n+}\n+\n+enum Quote {\n+    // Every arg is quoted\n+    Always,\n+    // Whitespace and empty args are quoted\n+    Auto,\n+    // Arg appended without any changes (#29494)\n+    Never,\n+}\n+\n+pub(crate) fn append_arg(cmd: &mut Vec<u16>, arg: &Arg, force_quotes: bool) -> io::Result<()> {\n+    let (arg, quote) = match arg {\n+        Arg::Regular(arg) => (arg, if force_quotes { Quote::Always } else { Quote::Auto }),\n+        Arg::Raw(arg) => (arg, Quote::Never),\n+    };\n+\n+    // If an argument has 0 characters then we need to quote it to ensure\n+    // that it actually gets passed through on the command line or otherwise\n+    // it will be dropped entirely when parsed on the other end.\n+    ensure_no_nuls(arg)?;\n+    let arg_bytes = arg.bytes();\n+    let (quote, escape) = match quote {\n+        Quote::Always => (true, true),\n+        Quote::Auto => {\n+            (arg_bytes.iter().any(|c| *c == b' ' || *c == b'\\t') || arg_bytes.is_empty(), true)\n+        }\n+        Quote::Never => (false, false),\n+    };\n+    if quote {\n+        cmd.push('\"' as u16);\n+    }\n+\n+    let mut backslashes: usize = 0;\n+    for x in arg.encode_wide() {\n+        if escape {\n+            if x == '\\\\' as u16 {\n+                backslashes += 1;\n+            } else {\n+                if x == '\"' as u16 {\n+                    // Add n+1 backslashes to total 2n+1 before internal '\"'.\n+                    cmd.extend((0..=backslashes).map(|_| '\\\\' as u16));\n+                }\n+                backslashes = 0;\n+            }\n+        }\n+        cmd.push(x);\n+    }\n+\n+    if quote {\n+        // Add n backslashes to total 2n before ending '\"'.\n+        cmd.extend((0..backslashes).map(|_| '\\\\' as u16));\n+        cmd.push('\"' as u16);\n+    }\n+    Ok(())\n+}\n+\n+pub(crate) fn make_bat_command_line(\n+    script: &[u16],\n+    args: &[Arg],\n+    force_quotes: bool,\n+) -> io::Result<Vec<u16>> {\n+    // Set the start of the command line to `cmd.exe /c \"`\n+    // It is necessary to surround the command in an extra pair of quotes,\n+    // hence the trailing quote here. It will be closed after all arguments\n+    // have been added.\n+    let mut cmd: Vec<u16> = \"cmd.exe /c \\\"\".encode_utf16().collect();\n+\n+    // Push the script name surrounded by its quote pair.\n+    cmd.push(b'\"' as u16);\n+    // Windows file names cannot contain a `\"` character or end with `\\\\`.\n+    // If the script name does then return an error.\n+    if script.contains(&(b'\"' as u16)) || script.last() == Some(&(b'\\\\' as u16)) {\n+        return Err(io::const_io_error!(\n+            io::ErrorKind::InvalidInput,\n+            \"Windows file names may not contain `\\\"` or end with `\\\\`\"\n+        ));\n+    }\n+    cmd.extend_from_slice(script.strip_suffix(&[0]).unwrap_or(script));\n+    cmd.push(b'\"' as u16);\n+\n+    // Append the arguments.\n+    // FIXME: This needs tests to ensure that the arguments are properly\n+    // reconstructed by the batch script by default.\n+    for arg in args {\n+        cmd.push(' ' as u16);\n+        append_arg(&mut cmd, arg, force_quotes)?;\n+    }\n+\n+    // Close the quote we left opened earlier.\n+    cmd.push(b'\"' as u16);\n+\n+    Ok(cmd)\n+}\n+\n+/// Takes a path and tries to return a non-verbatim path.\n+///\n+/// This is necessary because cmd.exe does not support verbatim paths.\n+pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n+    use crate::ptr;\n+    use crate::sys::windows::fill_utf16_buf;\n+\n+    // UTF-16 encoded code points, used in parsing and building UTF-16 paths.\n+    // All of these are in the ASCII range so they can be cast directly to `u16`.\n+    const SEP: u16 = b'\\\\' as _;\n+    const QUERY: u16 = b'?' as _;\n+    const COLON: u16 = b':' as _;\n+    const U: u16 = b'U' as _;\n+    const N: u16 = b'N' as _;\n+    const C: u16 = b'C' as _;\n+\n+    // Early return if the path is too long to remove the verbatim prefix.\n+    const LEGACY_MAX_PATH: usize = 260;\n+    if path.len() > LEGACY_MAX_PATH {\n+        return Ok(path);\n+    }\n+\n+    match &path[..] {\n+        // `\\\\?\\C:\\...` => `C:\\...`\n+        [SEP, SEP, QUERY, SEP, _, COLON, SEP, ..] => unsafe {\n+            let lpfilename = path[4..].as_ptr();\n+            fill_utf16_buf(\n+                |buffer, size| c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut()),\n+                |full_path: &[u16]| {\n+                    if full_path == &path[4..path.len() - 1] { full_path.into() } else { path }\n+                },\n+            )\n+        },\n+        // `\\\\?\\UNC\\...` => `\\\\...`\n+        [SEP, SEP, QUERY, SEP, U, N, C, SEP, ..] => unsafe {\n+            // Change the `C` in `UNC\\` to `\\` so we can get a slice that starts with `\\\\`.\n+            path[6] = b'\\\\' as u16;\n+            let lpfilename = path[6..].as_ptr();\n+            fill_utf16_buf(\n+                |buffer, size| c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut()),\n+                |full_path: &[u16]| {\n+                    if full_path == &path[6..path.len() - 1] {\n+                        full_path.into()\n+                    } else {\n+                        // Restore the 'C' in \"UNC\".\n+                        path[6] = b'C' as u16;\n+                        path\n+                    }\n+                },\n+            )\n+        },\n+        // For everything else, leave the path unchanged.\n+        _ => Ok(path),\n+    }\n+}"}, {"sha": "e6f01df2627305aec41b859888a560bca566b2a6", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 30, "deletions": 86, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5", "patch": "@@ -17,6 +17,7 @@ use crate::os::windows::ffi::{OsStrExt, OsStringExt};\n use crate::os::windows::io::{AsRawHandle, FromRawHandle, IntoRawHandle};\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n+use crate::sys::args::{self, Arg};\n use crate::sys::c;\n use crate::sys::c::NonZeroDWORD;\n use crate::sys::cvt;\n@@ -27,7 +28,7 @@ use crate::sys::pipe::{self, AnonPipe};\n use crate::sys::stdio;\n use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::process::{CommandEnv, CommandEnvs};\n-use crate::sys_common::{AsInner, IntoInner};\n+use crate::sys_common::IntoInner;\n \n use libc::{c_void, EXIT_FAILURE, EXIT_SUCCESS};\n \n@@ -147,7 +148,7 @@ impl AsRef<OsStr> for EnvKey {\n     }\n }\n \n-fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n+pub(crate) fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n     if str.as_ref().encode_wide().any(|b| b == 0) {\n         Err(io::const_io_error!(ErrorKind::InvalidInput, \"nul byte found in provided data\"))\n     } else {\n@@ -182,14 +183,6 @@ pub struct StdioPipes {\n     pub stderr: Option<AnonPipe>,\n }\n \n-#[derive(Debug)]\n-enum Arg {\n-    /// Add quotes (if needed)\n-    Regular(OsString),\n-    /// Append raw string without quoting\n-    Raw(OsString),\n-}\n-\n impl Command {\n     pub fn new(program: &OsStr) -> Command {\n         Command {\n@@ -275,8 +268,19 @@ impl Command {\n             program.len().checked_sub(5).and_then(|i| program.get(i..)),\n             Some([46, 98 | 66, 97 | 65, 116 | 84, 0] | [46, 99 | 67, 109 | 77, 100 | 68, 0])\n         );\n-        let mut cmd_str =\n-            make_command_line(&program, &self.args, self.force_quotes_enabled, is_batch_file)?;\n+        let (program, mut cmd_str) = if is_batch_file {\n+            (\n+                command_prompt()?,\n+                args::make_bat_command_line(\n+                    &args::to_user_path(program)?,\n+                    &self.args,\n+                    self.force_quotes_enabled,\n+                )?,\n+            )\n+        } else {\n+            let cmd_str = make_command_line(&self.program, &self.args, self.force_quotes_enabled)?;\n+            (program, cmd_str)\n+        };\n         cmd_str.push(0); // add null terminator\n \n         // stolen from the libuv code.\n@@ -730,96 +734,36 @@ fn zeroed_process_information() -> c::PROCESS_INFORMATION {\n     }\n }\n \n-enum Quote {\n-    // Every arg is quoted\n-    Always,\n-    // Whitespace and empty args are quoted\n-    Auto,\n-    // Arg appended without any changes (#29494)\n-    Never,\n-}\n-\n // Produces a wide string *without terminating null*; returns an error if\n // `prog` or any of the `args` contain a nul.\n-fn make_command_line(\n-    prog: &[u16],\n-    args: &[Arg],\n-    force_quotes: bool,\n-    is_batch_file: bool,\n-) -> io::Result<Vec<u16>> {\n+fn make_command_line(argv0: &OsStr, args: &[Arg], force_quotes: bool) -> io::Result<Vec<u16>> {\n     // Encode the command and arguments in a command line string such\n     // that the spawned process may recover them using CommandLineToArgvW.\n     let mut cmd: Vec<u16> = Vec::new();\n \n-    // CreateFileW has special handling for .bat and .cmd files, which means we\n-    // need to add an extra pair of quotes surrounding the whole command line\n-    // so they are properly passed on to the script.\n-    // See issue #91991.\n-    if is_batch_file {\n-        cmd.push(b'\"' as u16);\n-    }\n-\n     // Always quote the program name so CreateProcess to avoid ambiguity when\n     // the child process parses its arguments.\n     // Note that quotes aren't escaped here because they can't be used in arg0.\n     // But that's ok because file paths can't contain quotes.\n     cmd.push(b'\"' as u16);\n-    cmd.extend_from_slice(prog.strip_suffix(&[0]).unwrap_or(prog));\n+    cmd.extend(argv0.encode_wide());\n     cmd.push(b'\"' as u16);\n \n     for arg in args {\n         cmd.push(' ' as u16);\n-        let (arg, quote) = match arg {\n-            Arg::Regular(arg) => (arg, if force_quotes { Quote::Always } else { Quote::Auto }),\n-            Arg::Raw(arg) => (arg, Quote::Never),\n-        };\n-        append_arg(&mut cmd, arg, quote)?;\n-    }\n-    if is_batch_file {\n-        cmd.push(b'\"' as u16);\n-    }\n-    return Ok(cmd);\n-\n-    fn append_arg(cmd: &mut Vec<u16>, arg: &OsStr, quote: Quote) -> io::Result<()> {\n-        // If an argument has 0 characters then we need to quote it to ensure\n-        // that it actually gets passed through on the command line or otherwise\n-        // it will be dropped entirely when parsed on the other end.\n-        ensure_no_nuls(arg)?;\n-        let arg_bytes = &arg.as_inner().inner.as_inner();\n-        let (quote, escape) = match quote {\n-            Quote::Always => (true, true),\n-            Quote::Auto => {\n-                (arg_bytes.iter().any(|c| *c == b' ' || *c == b'\\t') || arg_bytes.is_empty(), true)\n-            }\n-            Quote::Never => (false, false),\n-        };\n-        if quote {\n-            cmd.push('\"' as u16);\n-        }\n-\n-        let mut backslashes: usize = 0;\n-        for x in arg.encode_wide() {\n-            if escape {\n-                if x == '\\\\' as u16 {\n-                    backslashes += 1;\n-                } else {\n-                    if x == '\"' as u16 {\n-                        // Add n+1 backslashes to total 2n+1 before internal '\"'.\n-                        cmd.extend((0..=backslashes).map(|_| '\\\\' as u16));\n-                    }\n-                    backslashes = 0;\n-                }\n-            }\n-            cmd.push(x);\n-        }\n-\n-        if quote {\n-            // Add n backslashes to total 2n before ending '\"'.\n-            cmd.extend((0..backslashes).map(|_| '\\\\' as u16));\n-            cmd.push('\"' as u16);\n-        }\n-        Ok(())\n+        args::append_arg(&mut cmd, arg, force_quotes)?;\n     }\n+    Ok(cmd)\n+}\n+\n+// Get `cmd.exe` for use with bat scripts, encoded as a UTF-16 string.\n+fn command_prompt() -> io::Result<Vec<u16>> {\n+    let mut system: Vec<u16> = super::fill_utf16_buf(\n+        |buf, size| unsafe { c::GetSystemDirectoryW(buf, size) },\n+        |buf| buf.into(),\n+    )?;\n+    system.extend(\"\\\\cmd.exe\".encode_utf16().chain([0]));\n+    Ok(system)\n }\n \n fn make_envp(maybe_env: Option<BTreeMap<EnvKey, OsString>>) -> io::Result<(*mut c_void, Vec<u16>)> {"}, {"sha": "be3a0f4ed52a981ae13d23b25ad81af8d27665a0", "filename": "library/std/src/sys/windows/process/tests.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs?ref=756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5", "patch": "@@ -3,12 +3,11 @@ use super::Arg;\n use crate::env;\n use crate::ffi::{OsStr, OsString};\n use crate::process::Command;\n-use crate::sys::to_u16s;\n \n #[test]\n fn test_raw_args() {\n     let command_line = &make_command_line(\n-        &to_u16s(\"quoted exe\").unwrap(),\n+        OsStr::new(\"quoted exe\"),\n         &[\n             Arg::Regular(OsString::from(\"quote me\")),\n             Arg::Raw(OsString::from(\"quote me *not*\")),\n@@ -17,7 +16,6 @@ fn test_raw_args() {\n             Arg::Regular(OsString::from(\"optional-quotes\")),\n         ],\n         false,\n-        false,\n     )\n     .unwrap();\n     assert_eq!(\n@@ -30,10 +28,9 @@ fn test_raw_args() {\n fn test_make_command_line() {\n     fn test_wrapper(prog: &str, args: &[&str], force_quotes: bool) -> String {\n         let command_line = &make_command_line(\n-            &to_u16s(prog).unwrap(),\n+            OsStr::new(prog),\n             &args.iter().map(|a| Arg::Regular(OsString::from(a))).collect::<Vec<_>>(),\n             force_quotes,\n-            false,\n         )\n         .unwrap();\n         String::from_utf16(command_line).unwrap()"}, {"sha": "064472f5785a1f80823eca178058754472deaf48", "filename": "src/test/ui-fulldeps/issue-15149.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5/src%2Ftest%2Fui-fulldeps%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5/src%2Ftest%2Fui-fulldeps%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-15149.rs?ref=756ffb8d0b4f6748c471bbb2075a6ac2bbea29b5", "patch": "@@ -5,10 +5,11 @@\n // ignore-cross-compile\n \n use std::env;\n+use std::ffi::OsStr;\n use std::fs;\n+use std::path::PathBuf;\n use std::process;\n use std::str;\n-use std::path::PathBuf;\n \n fn main() {\n     // If we're the child, make sure we were invoked correctly\n@@ -18,8 +19,8 @@ fn main() {\n         // checking that it ends_with the executable name. This\n         // is needed because of Windows, which has a different behavior.\n         // See #15149 for more info.\n-        return assert!(args[0].ends_with(&format!(\"mytest{}\",\n-                                                  env::consts::EXE_SUFFIX)));\n+        let my_path = env::current_exe().unwrap();\n+        return assert_eq!(my_path.file_stem(), Some(OsStr::new(\"mytest\")));\n     }\n \n     test();\n@@ -28,14 +29,13 @@ fn main() {\n fn test() {\n     // If we're the parent, copy our own binary to a new directory.\n     let my_path = env::current_exe().unwrap();\n-    let my_dir  = my_path.parent().unwrap();\n+    let my_dir = my_path.parent().unwrap();\n \n     let child_dir = PathBuf::from(env::var_os(\"RUST_TEST_TMPDIR\").unwrap());\n     let child_dir = child_dir.join(\"issue-15140-child\");\n     fs::create_dir_all(&child_dir).unwrap();\n \n-    let child_path = child_dir.join(&format!(\"mytest{}\",\n-                                             env::consts::EXE_SUFFIX));\n+    let child_path = child_dir.join(&format!(\"mytest{}\", env::consts::EXE_SUFFIX));\n     fs::copy(&my_path, &child_path).unwrap();\n \n     // Append the new directory to our own PATH.\n@@ -45,12 +45,13 @@ fn test() {\n         env::join_paths(paths).unwrap()\n     };\n \n-    let child_output = process::Command::new(\"mytest\").env(\"PATH\", &path)\n-                                                      .arg(\"child\")\n-                                                      .output().unwrap();\n+    let child_output =\n+        process::Command::new(\"mytest\").env(\"PATH\", &path).arg(\"child\").output().unwrap();\n \n-    assert!(child_output.status.success(),\n-            \"child assertion failed\\n child stdout:\\n {}\\n child stderr:\\n {}\",\n-            str::from_utf8(&child_output.stdout).unwrap(),\n-            str::from_utf8(&child_output.stderr).unwrap());\n+    assert!(\n+        child_output.status.success(),\n+        \"child assertion failed\\n child stdout:\\n {}\\n child stderr:\\n {}\",\n+        str::from_utf8(&child_output.stdout).unwrap(),\n+        str::from_utf8(&child_output.stderr).unwrap()\n+    );\n }"}]}