{"sha": "1a1fdf34b165e25c6eca9a2729500a5805fa0c40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMWZkZjM0YjE2NWUyNWM2ZWNhOWEyNzI5NTAwYTU4MDVmYTBjNDA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-12-18T10:02:35Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-12-18T10:02:35Z"}, "message": "rt: Add lots of documentation to __morestack", "tree": {"sha": "633db68dba320d47bed96cd994770c146244f07a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/633db68dba320d47bed96cd994770c146244f07a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a1fdf34b165e25c6eca9a2729500a5805fa0c40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a1fdf34b165e25c6eca9a2729500a5805fa0c40", "html_url": "https://github.com/rust-lang/rust/commit/1a1fdf34b165e25c6eca9a2729500a5805fa0c40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a1fdf34b165e25c6eca9a2729500a5805fa0c40/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7359fa422b9c30d3aaf08e52cad795778f824f36", "url": "https://api.github.com/repos/rust-lang/rust/commits/7359fa422b9c30d3aaf08e52cad795778f824f36", "html_url": "https://github.com/rust-lang/rust/commit/7359fa422b9c30d3aaf08e52cad795778f824f36"}], "stats": {"total": 181, "additions": 139, "deletions": 42}, "files": [{"sha": "3c4e95e3ac13c3ea184fe0dd3defe084ceaaac05", "filename": "src/rt/arch/i386/morestack.S", "status": "modified", "additions": 116, "deletions": 19, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/1a1fdf34b165e25c6eca9a2729500a5805fa0c40/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/1a1fdf34b165e25c6eca9a2729500a5805fa0c40/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fmorestack.S?ref=1a1fdf34b165e25c6eca9a2729500a5805fa0c40", "patch": "@@ -1,9 +1,70 @@\n-    .text\n-\n-// __morestack\n-//\n-// LLVM generates a call to this to allocate more stack space in a function\n-// prolog when we run out.\n+/*\n+\t__morestack\n+\n+\tThis function implements stack growth using the mechanism\n+\tdevised by Ian Lance Taylor for gccgo, described here:\n+\n+\thttp://gcc.gnu.org/wiki/SplitStacks\n+\n+\tThe Rust stack is composed of a linked list of stack segments,\n+\tand each stack segment contains two parts: the work area,\n+\twhere Rust functions are allowed to execute; and the red zone,\n+\twhere no Rust code can execute, but where short runtime\n+\tfunctions (including __morestack), the dynamic linker, signal\n+\thandlers, and the unwinder can run.\n+\n+\tEach Rust function contains an LLVM-generated prologue that\n+\tcompares the stack space required for the current function to\n+\tthe space space remaining in the current stack segment,\n+\tmaintained in a platform-specific TLS slot.  The stack limit\n+\tis strategically maintained by the Rust runtime so that it is\n+\talways in place whenever a Rust function is running.\n+\n+\tWhen there is not enough room to run the function, the function\n+\tprologue makes a call to __morestack to allocate a new stack\n+\tsegment, copy any stack-based arguments to it, switch stacks,\n+\tthen resume execution of the original function.\n+\n+\t-- The __morestack calling convention --\n+\n+\tFor reasons of efficiency the __morestack calling convention\n+\tis bizarre. The calling function does not attempt to align the\n+\tstack for the call, and on x86_64 the arguments to __morestack\n+\tare passed in scratch registers in order to preserve the\n+\toriginal function's arguments.\n+\n+\tOnce __morestack has switched to the new stack, instead of\n+\treturning, it then calls into the original function, resuming\n+\texecution at the instruction following the call to\n+\t__morestack. Thus, when the original function returns it\n+\tactually returns to __morestack, which then deallocates the\n+\tstack and returns again to the original function's caller.\n+\n+\t-- Unwinding --\n+\n+\tAll this trickery causes hell when it comes time for the\n+\tunwinder to navigate it's way through this function. What\n+\twill happen is the original function will be unwound first\n+\twithout any special effort, then the unwinder encounters\n+\tthe __morestack frame, which is sitting just above a\n+\ttiny fraction of a frame (containing just a return pointer\n+\tand, on 32-bit, the arguments to __morestack).\n+\n+\tWe deal with this by claiming that that little bit of stack\n+\tis actually part of the __morestack frame, encoded as\n+\tDWARF call frame instructions (CFI) by .cfi assembler\n+\tpseudo-ops.\n+\n+\tOne final complication (that took me a week to figure out)\n+\tis that OS X 10.6+ uses its own 'compact unwind info',\n+\tan undocumented format generated by the linker from\n+\tthe DWARF CFI. This compact unwind info doesn't correctly\n+\tcapture the nuance of the __morestack frame, and as a\n+\tresult all of our linking on OS X uses the -no_compact_unwind\n+\tflag.\n+*/\n+\n+.text\n \n #if defined(__APPLE__)\n #define RUST_GET_TASK           L_rust_get_task$stub\n@@ -51,13 +112,31 @@ MORESTACK:\n \t.cfi_startproc\n #endif\n \n+\t// This base pointer setup differs from most in that we are\n+\t// telling the unwinder to consider the Canonical Frame\n+\t// Address (CFA) for this frame to be the value of the stack\n+\t// pointer prior to entry to the original function, whereas\n+\t// the CFA would typically be the the value of the stack\n+\t// pointer prior to entry to this function. This will allow\n+\t// the unwinder to understand how to skip the tiny partial\n+\t// frame that the original function created by calling\n+\t// __morestack.\n+\n+\t// In practical terms, our CFA is 12 bytes greater than it\n+\t// would normally be, accounting for the two arguments to\n+\t// __morestack, and an extra return address.\n+\n \tpushl %ebp\n #if defined(__linux__) || defined(__APPLE__)\n+\t// The CFA is 20 bytes above the register that it is\n+\t// associated with for this frame (which will be %ebp)\n \t.cfi_def_cfa_offset 20\n+\t// %ebp is -20 bytes from the CFA\n \t.cfi_offset %ebp, -20\n #endif\n \tmovl %esp, %ebp\n #if defined(__linux__) || defined(__APPLE__)\n+\t// Calculate the CFA as an offset from %ebp\n \t.cfi_def_cfa_register %ebp\n #endif\n \n@@ -81,17 +160,25 @@ MORESTACK:\n \n \t// Save the the correct %esp value for our grandparent frame,\n \t// for the unwinder\n+\t// FIXME: This isn't used\n \tleal 20(%ebp), %eax\n \tmovl %eax, -4(%ebp)\n \n-\t// The arguments to rust_new_stack2\n-\tmovl 56(%esp),%eax  // Size of stack arguments\n+\t// The arguments to upcall_new_stack\n+\n+\t// The size of the stack arguments to copy to the new stack,\n+\t// ane of the the arguments to __morestack\n+\tmovl 56(%esp),%eax\n \tmovl %eax,20(%esp)\n-\tleal 64(%esp),%eax // Address of stack arguments\n+\t// The address of the stack arguments to the original function\n+\tleal 64(%esp),%eax\n \tmovl %eax,16(%esp)\n+\t// The amount of stack needed for the original function,\n+\t// the other argument to __morestack\n \tmovl 52(%esp),%eax // The amount of stack needed\n \tmovl %eax,12(%esp)\n-\tmovl $0, 8(%esp)   // Out pointer\n+\t// Out pointer to the new stack\n+\tmovl $0, 8(%esp)\n \n #ifdef __APPLE__\n \tcall 1f\n@@ -106,18 +193,22 @@ MORESTACK:\n \tmovl %eax,(%esp)\n \tcall UPCALL_CALL_C\n \n-\tmovl 48(%esp),%eax          // Grab the return pointer.\n-\tinc  %eax    // Skip past the ret instruction in the parent fn\n+\t// Grab the __morestack return pointer\n+\tmovl 48(%esp),%eax\n+\t// Skip past the ret instruction in the parent fn\n+\tinc  %eax\n \n-\t// Restore fastcc arguments\n+\t// Restore the fastcc arguments to the original function\n \tmovl 28(%esp), %ecx\n \tmovl 24(%esp), %edx\n \n-\tmovl 8(%esp),%esp          // Switch stacks.\n-\tcall *%eax                 // Re-enter the function that called us.\n+        // Switch stacks\n+\tmovl 8(%esp),%esp\n+        // Re-enter the function that called us\n+\tcall *%eax\n \n-\t// Now the function that called us has returned, so we need to delete the\n-\t// old stack space.\n+\t// Now the function that called us has returned, so we need to\n+\t// delete the old stack space\n \n \t// Switch back to the rust stack\n \tmovl %ebp, %esp\n@@ -127,8 +218,8 @@ MORESTACK:\n \tsubl $4, %esp\n \n \t// Now that we're on the return path we want to avoid\n-\t// stomping on %eax. FIXME: Need to save and restore\n-\t// eax to actually preserve it across the call to delete the stack\n+\t// stomping on %eax. FIXME: Need to save and restore %eax to\n+\t// actually preserve it across the call to delete the stack\n #ifdef __APPLE__\n \tcall 1f\n 1:\tpopl %ecx\n@@ -144,8 +235,14 @@ MORESTACK:\n \taddl $12,%esp\n \n \tpopl %ebp\n+\n+\t// FIXME: I don't think these rules are necessary\n+\t// since the unwinder should never encounter an instruction\n+\t// pointer pointing here.\n #if defined(__linux__) || defined(__APPLE__)\n+\t// Restore the rule for how to find %ebp\n \t.cfi_restore %ebp\n+\t// Tell the unwinder how to find the CFA in terms of %esp\n \t.cfi_def_cfa %esp, 16\n #endif\n \tretl $8"}, {"sha": "9cd37d656ac661c35f177c16b7d59a084731241a", "filename": "src/rt/arch/x86_64/morestack.S", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1a1fdf34b165e25c6eca9a2729500a5805fa0c40/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/1a1fdf34b165e25c6eca9a2729500a5805fa0c40/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S?ref=1a1fdf34b165e25c6eca9a2729500a5805fa0c40", "patch": "@@ -1,9 +1,10 @@\n-    .text\n+/*\n+\t__morestack\n \n-// __morestack\n-//\n-// LLVM generates a call to this to allocate more stack space in a functiono\n-// prolog when we run out.\n+\tSee i386/morestack.S for the lengthy, general explanation.\n+*/\n+\n+.text\n \n #if defined(__APPLE__) || defined(_WIN32)\n #define UPCALL_NEW_STACK        _upcall_new_stack\n@@ -15,27 +16,13 @@\n #define UPCALL_DEL_STACK        upcall_del_stack\n #define UPCALL_CALL_C           upcall_call_shim_on_c_stack\n #define MORESTACK               __morestack\n-#endif\n-\n-        // Naturally, nobody can agree as to\n-        // which arguments should go in which\n-        // registers:\n-#if defined(_WIN32)\n-#  define ARG0 %rcx\n-#  define ARG1 %rdx\n-#  define ARG2 %r8\n-#else\n-#  define ARG0 %rdi\n-#  define ARG1 %rsi\n-#  define ARG2 %rdx\n #endif\n \n .globl UPCALL_NEW_STACK\n .globl UPCALL_DEL_STACK\n .globl UPCALL_CALL_C\n .globl MORESTACK\n \n-// FIXME: What about _WIN32?\t\n #if defined(__linux__)\n \t.hidden MORESTACK\n #else\n@@ -48,24 +35,31 @@\n \t.type MORESTACK,@function\n #endif\n \n+\n #if defined(__linux__) || defined(__APPLE__)\n MORESTACK:\n \t.cfi_startproc\n-\t\n-\t// Set up a normal backtrace\n+\n \tpushq %rbp\n+\t// The CFA is 24 bytes above the register that it will\n+\t// be associated with for this frame (%rbp). That is 8\n+\t// bytes greater than a normal frame, to allow the unwinder\n+\t// to skip the partial frame of the original function.\n \t.cfi_def_cfa_offset 24\n+\t// %rbp is -24 bytes from the CFA\n \t.cfi_offset %rbp, -24\n \tmovq %rsp, %rbp\n+\t// Calculate the CFA as on offset from %ebp\n \t.cfi_def_cfa_register %rbp\n \n \t// Save the grandparent stack pointer for the unwinder\n+\t// FIXME: This isn't used\n \tleaq 24(%rbp), %rax\n \tpushq %rax\n \n \t// FIXME: libgcc also saves rax. not sure if we need to\n \n-\t// Save argument registers\n+\t// Save argument registers of the original function\n \tpushq\t%rdi\n \tpushq\t%rsi\n \tpushq\t%rdx\n@@ -79,6 +73,8 @@ MORESTACK:\n \tmovq %rbp, %rcx\n \taddq $24, %rcx  // Base pointer, return address x2\n \n+\t// The arguments to __morestack are passed in %r10 & %r11\n+\n \tpushq %r11 // Size of stack arguments\n \tpushq %rcx // Address of stack arguments\n \tpushq %r10 // The amount of stack needed\n@@ -119,7 +115,8 @@ MORESTACK:\n \n \t// Align the stack again\n \tpushq $0\n-\t\n+\n+\t// FIXME: Should preserve %rax here\n \tmovq UPCALL_DEL_STACK@GOTPCREL(%rip), %rsi\n \tmovq $0, %rdi\n #ifdef __APPLE__\n@@ -131,6 +128,9 @@ MORESTACK:\n \n \taddq $8, %rsp\n \tpopq %rbp\n+\t// FIXME: I don't think these rules are necessary\n+\t// since the unwinder should never encounter an instruction\n+\t// pointer pointing here.\n \t.cfi_restore %rbp\n \t.cfi_def_cfa %rsp, 16\n \tret"}]}