{"sha": "c902eafa14803ca9fcb0b59ce852bdabca826c6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MDJlYWZhMTQ4MDNjYTlmY2IwYjU5Y2U4NTJiZGFiY2E4MjZjNmY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-04-06T18:01:43Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-04-06T18:38:23Z"}, "message": "Convert old-style for loops to new-style\n\nMost could use the each method, but because of the hack used to\ndisambiguate old- and new-style loops, some had to use vec::each.\n\n(This hack will go away soon.)\n\nIssue #1619", "tree": {"sha": "2e282ea67adaca64dd813a78d94a6cd3766a5dac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e282ea67adaca64dd813a78d94a6cd3766a5dac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c902eafa14803ca9fcb0b59ce852bdabca826c6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c902eafa14803ca9fcb0b59ce852bdabca826c6f", "html_url": "https://github.com/rust-lang/rust/commit/c902eafa14803ca9fcb0b59ce852bdabca826c6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c902eafa14803ca9fcb0b59ce852bdabca826c6f/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c88e5ef5a7e9c8db4ac56d53ba48c454b8b2010", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c88e5ef5a7e9c8db4ac56d53ba48c454b8b2010", "html_url": "https://github.com/rust-lang/rust/commit/9c88e5ef5a7e9c8db4ac56d53ba48c454b8b2010"}], "stats": {"total": 1248, "additions": 623, "deletions": 625}, "files": [{"sha": "5c135423b8b45411fc21c2ec919fa678aac6dd74", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -93,7 +93,7 @@ fn load_link(mis: [@ast::meta_item]) -> (option<str>,\n     let mut name = none;\n     let mut vers = none;\n     let mut uuid = none;\n-    for a: @ast::meta_item in mis {\n+    for mis.each {|a|\n         alt a.node {\n             ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) {\n                 alt v {\n@@ -128,7 +128,7 @@ fn load_pkg(filename: str) -> option<pkg> {\n     let mut sigs = none;\n     let mut crate_type = none;\n \n-    for a in c.node.attrs {\n+    for c.node.attrs.each {|a|\n         alt a.node.value.node {\n             ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) {\n                 alt v {\n@@ -273,7 +273,7 @@ fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n     let mut tags = [];\n     alt p.find(\"tags\") {\n         some(json::list(js)) {\n-            for j in js {\n+            for js.each {|j|\n                 alt j {\n                     json::string(_j) { vec::grow(tags, 1u, _j); }\n                     _ { }\n@@ -313,7 +313,7 @@ fn load_source_packages(&c: cargo, &src: source) {\n     let pkgstr = io::read_whole_file_str(pkgfile);\n     alt json::from_str(result::get(pkgstr)) {\n         ok(json::list(js)) {\n-            for _j: json::json in js {\n+            for js.each {|_j|\n                 alt _j {\n                     json::dict(_p) {\n                         load_one_source_package(src, _p);\n@@ -423,7 +423,7 @@ fn configure(opts: options) -> cargo {\n \n fn for_each_package(c: cargo, b: fn(source, package)) {\n     c.sources.values({ |v|\n-        for p in copy v.packages {\n+        for vec::each(copy v.packages) {|p|\n             b(v, p);\n         }\n     })\n@@ -432,7 +432,7 @@ fn for_each_package(c: cargo, b: fn(source, package)) {\n // Runs all programs in directory <buildpath>\n fn run_programs(buildpath: str) {\n     let newv = os::list_dir_path(buildpath);\n-    for ct: str in newv {\n+    for newv.each {|ct|\n         run::run_program(ct, []);\n     }\n }\n@@ -470,7 +470,7 @@ fn install_one_crate(c: cargo, path: str, cf: str) {\n     };\n     let newv = os::list_dir_path(buildpath);\n     let exec_suffix = os::exe_suffix();\n-    for ct: str in newv {\n+    for newv.each {|ct|\n         if (exec_suffix != \"\" && str::ends_with(ct, exec_suffix)) ||\n             (exec_suffix == \"\" && !str::starts_with(path::basename(ct),\n                                                     \"lib\")) {\n@@ -528,7 +528,7 @@ fn install_source(c: cargo, path: str) {\n         fail \"This doesn't look like a rust package (no .rc files).\";\n     }\n \n-    for cf: str in cratefiles {\n+    for cratefiles.each {|cf|\n         let p = load_pkg(cf);\n         alt p {\n             none { cont; }\n@@ -618,7 +618,8 @@ fn install_uuid(c: cargo, wd: str, uuid: str) {\n         ret;\n     }\n     error(\"Found multiple packages:\");\n-    for (s,p) in ps {\n+    for ps.each {|elt|\n+        let (s,p) = elt;\n         info(\"  \" + s.name + \"/\" + p.uuid + \" (\" + p.name + \")\");\n     }\n }\n@@ -639,7 +640,8 @@ fn install_named(c: cargo, wd: str, name: str) {\n         ret;\n     }\n     error(\"Found multiple packages:\");\n-    for (s,p) in ps {\n+    for ps.each {|elt|\n+        let (s,p) = elt;\n         info(\"  \" + s.name + \"/\" + p.uuid + \" (\" + p.name + \")\");\n     }\n }"}, {"sha": "1dcb3b3fe5add38b0e1fdd173ecc76d5223417ad", "filename": "src/cargo/pgp.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Fcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Fcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fpgp.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -89,10 +89,9 @@ fn verify(root: str, data: str, sig: str, keyfp: str) -> bool {\n     let p = gpg([\"--homedir\", path, \"--with-fingerprint\", \"--verify\", sig,\n                  data]);\n     let res = \"Primary key fingerprint: \" + keyfp;\n-    for line in str::split_char(p.err, '\\n') {\n-        if line == res {\n-            ret true;\n-        }\n+    let mut rslt = false;\n+    for str::split_char(p.err, '\\n').each {|line|\n+        if line == res { rslt = true; }\n     }\n-    ret false;\n+    ret rslt;\n }"}, {"sha": "079fba0ba652d7393de93e828b78166ee5579b91", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -135,7 +135,7 @@ fn test_opts(config: config) -> test::test_opts {\n fn make_tests(config: config) -> [test::test_desc] {\n     #debug(\"making tests from %s\", config.src_base);\n     let mut tests = [];\n-    for file: str in os::list_dir_path(config.src_base) {\n+    for os::list_dir_path(config.src_base).each {|file|\n         let file = file;\n         #debug(\"inspecting file %s\", file);\n         if is_test(config, file) {\n@@ -154,11 +154,11 @@ fn is_test(config: config, testfile: str) -> bool {\n \n     let mut valid = false;\n \n-    for ext in valid_extensions {\n+    for valid_extensions.each {|ext|\n         if str::ends_with(name, ext) { valid = true; }\n     }\n \n-    for pre in invalid_prefixes {\n+    for invalid_prefixes.each {|pre|\n         if str::starts_with(name, pre) { valid = false; }\n     }\n "}, {"sha": "24644a6d3755b5ef270d7030381c7d9d69c6784e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -196,7 +196,7 @@ fn check_error_patterns(props: test_props,\n \n     let mut next_err_idx = 0u;\n     let mut next_err_pat = props.error_patterns[next_err_idx];\n-    for line: str in str::split_char(procres.stderr, '\\n') {\n+    for str::split_char(procres.stderr, '\\n').each {|line|\n         if str::contains(line, next_err_pat) {\n             #debug(\"found error pattern %s\", next_err_pat);\n             next_err_idx += 1u;\n@@ -215,7 +215,7 @@ fn check_error_patterns(props: test_props,\n         fatal_procres(#fmt[\"error pattern '%s' not found!\",\n                            missing_patterns[0]], procres);\n     } else {\n-        for pattern: str in missing_patterns {\n+        for missing_patterns.each {|pattern|\n             error(#fmt[\"error pattern '%s' not found!\", pattern]);\n         }\n         fatal_procres(\"multiple error patterns not found\", procres);\n@@ -244,7 +244,7 @@ fn check_expected_errors(expected_errors: [errors::expected_error],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for line: str in str::split_char(procres.stderr, '\\n') {\n+    for str::split_char(procres.stderr, '\\n').each {|line|\n         let mut was_expected = false;\n         for vec::eachi(expected_errors) {|i, ee|\n             if !found_flags[i] {"}, {"sha": "3c34bc9b42f3d534af311cdcd9ac4f7ca58a1736", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -25,7 +25,7 @@ fn find_rust_files(&files: [str], path: str) {\n     } else if os::path_is_dir(path)\n         && !contains(path, \"compile-fail\")\n         && !contains(path, \"build\") {\n-        for p in os::list_dir_path(path) {\n+        for os::list_dir_path(path).each {|p|\n             find_rust_files(files, p);\n         }\n     }\n@@ -439,15 +439,15 @@ fn content_is_dangerous_to_run(code: str) -> bool {\n          \"unsafe\",\n          \"log\"];    // python --> rust pipe deadlock?\n \n-    for p: str in dangerous_patterns { if contains(code, p) { ret true; } }\n+    for dangerous_patterns.each {|p| if contains(code, p) { ret true; } }\n     ret false;\n }\n \n fn content_is_dangerous_to_compile(code: str) -> bool {\n     let dangerous_patterns =\n         [\"xfail-test\"];\n \n-    for p: str in dangerous_patterns { if contains(code, p) { ret true; } }\n+    for dangerous_patterns.each {|p| if contains(code, p) { ret true; } }\n     ret false;\n }\n \n@@ -462,7 +462,7 @@ fn content_might_not_converge(code: str) -> bool {\n          \"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n         ];\n \n-    for p: str in confusing_patterns { if contains(code, p) { ret true; } }\n+    for confusing_patterns.each {|p| if contains(code, p) { ret true; } }\n     ret false;\n }\n \n@@ -475,7 +475,7 @@ fn file_might_not_converge(filename: str) -> bool {\n     ];\n \n \n-    for f in confusing_files { if contains(filename, f) { ret true; } }\n+    for confusing_files.each {|f| if contains(filename, f) { ret true; } }\n \n     ret false;\n }\n@@ -509,7 +509,7 @@ fn check_roundtrip_convergence(code: @str, maxIters: uint) {\n \n fn check_convergence(files: [str]) {\n     #error(\"pp convergence tests: %u files\", vec::len(files));\n-    for file in files {\n+    for files.each {|file|\n         if !file_might_not_converge(file) {\n             let s = @result::get(io::read_whole_file_str(file));\n             if !content_might_not_converge(*s) {\n@@ -522,7 +522,7 @@ fn check_convergence(files: [str]) {\n }\n \n fn check_variants(files: [str], cx: context) {\n-    for file in files {\n+    for files.each {|file|\n         if cx.mode == tm_converge && file_might_not_converge(file) {\n             #error(\"Skipping convergence test based on file_might_not_converge\");\n             cont;"}, {"sha": "96bdf9b77c931bfa451bb4f24fc757663b4902e6", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -62,7 +62,7 @@ export zip;\n export swap;\n export reverse;\n export reversed;\n-export iter, each, eachi;\n+export iter, iter_between, each, eachi;\n export iter2;\n export iteri;\n export riter;"}, {"sha": "63c46b63341eb628b837f97c70777549a79c5b8a", "filename": "src/librustsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast_util.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -142,11 +142,11 @@ fn float_ty_to_str(t: float_ty) -> str {\n fn is_exported(i: ident, m: _mod) -> bool {\n     let mut local = false;\n     let mut parent_enum : option<ident> = none;\n-    for it: @item in m.items {\n+    for m.items.each {|it|\n         if it.ident == i { local = true; }\n         alt it.node {\n           item_enum(variants, _) {\n-            for v: variant in variants {\n+            for variants.each {|v|\n                 if v.node.name == i {\n                    local = true;\n                    parent_enum = some(it.ident);\n@@ -158,11 +158,11 @@ fn is_exported(i: ident, m: _mod) -> bool {\n         if local { break; }\n     }\n     let mut has_explicit_exports = false;\n-    for vi: @view_item in m.view_items {\n+    for m.view_items.each {|vi|\n         alt vi.node {\n           view_item_export(vps) {\n             has_explicit_exports = true;\n-            for vp in vps {\n+            for vps.each {|vp|\n                 alt vp.node {\n                   ast::view_path_simple(id, _, _) {\n                     if id == i { ret true; }\n@@ -177,7 +177,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n                   ast::view_path_list(path, ids, _) {\n                     if vec::len(*path) == 1u {\n                         if i == path[0] { ret true; }\n-                        for id in ids {\n+                        for ids.each {|id|\n                             if id.node.name == i { ret true; }\n                         }\n                     } else {\n@@ -278,14 +278,14 @@ fn public_methods(ms: [@method]) -> [@method] {\n \n fn split_class_items(cs: [@class_member]) -> ([ivar], [@method]) {\n     let mut vs = [], ms = [];\n-    for c in cs {\n+    for cs.each {|c|\n       alt c.node {\n         instance_var(i, t, cm, id, privacy) {\n           vs += [{ident: i, ty: t, cm: cm, id: id, privacy: privacy}];\n         }\n         class_method(m) { ms += [m]; }\n       }\n-    }\n+    };\n     (vs, ms)\n }\n "}, {"sha": "861e86ec0ee233567dd2ed38e3bf0db1737663ea", "filename": "src/librustsyntax/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fattr.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -46,7 +46,7 @@ fn find_linkage_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n \n fn find_linkage_attrs(attrs: [ast::attribute]) -> [ast::attribute] {\n     let mut found = [];\n-    for attr: ast::attribute in find_attrs_by_name(attrs, \"link\") {\n+    for find_attrs_by_name(attrs, \"link\").each {|attr|\n         alt attr.node.value.node {\n           ast::meta_list(_, _) { found += [attr] }\n           _ { #debug(\"ignoring link attribute that has incorrect type\"); }\n@@ -150,7 +150,7 @@ fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n // Get the meta_items from inside a vector of attributes\n fn attr_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n     let mut mitems = [];\n-    for a: ast::attribute in attrs { mitems += [attr_meta(a)]; }\n+    for attrs.each {|a| mitems += [attr_meta(a)]; }\n     ret mitems;\n }\n \n@@ -178,7 +178,7 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n fn contains(haystack: [@ast::meta_item], needle: @ast::meta_item) -> bool {\n     #debug(\"looking for %s\",\n            print::pprust::meta_item_to_str(*needle));\n-    for item: @ast::meta_item in haystack {\n+    for haystack.each {|item|\n         #debug(\"looking in %s\",\n                print::pprust::meta_item_to_str(*item));\n         if eq(item, needle) { #debug(\"found it!\"); ret true; }\n@@ -207,12 +207,12 @@ fn sort_meta_items(items: [@ast::meta_item]) -> [@ast::meta_item] {\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n     let mut v: [mut @ast::meta_item] = [mut];\n-    for mi: @ast::meta_item in items { v += [mut mi]; }\n+    for items.each {|mi| v += [mut mi]; }\n \n     std::sort::quick_sort(lteq, v);\n \n     let mut v2: [@ast::meta_item] = [];\n-    for mi: @ast::meta_item in v { v2 += [mi]; }\n+    for v.each {|mi| v2 += [mi]; }\n     ret v2;\n }\n \n@@ -231,7 +231,7 @@ fn remove_meta_items_by_name(items: [@ast::meta_item], name: str) ->\n fn require_unique_names(diagnostic: span_handler,\n                         metas: [@ast::meta_item]) {\n     let map = map::str_hash();\n-    for meta: @ast::meta_item in metas {\n+    for metas.each {|meta|\n         let name = get_meta_item_name(meta);\n         if map.contains_key(name) {\n             diagnostic.span_fatal(meta.span,"}, {"sha": "8e034690167dc41403ae46e87be71c9efc80bcc4", "filename": "src/librustsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fcodemap.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -187,7 +187,7 @@ fn get_snippet(cm: codemap::codemap, fidx: uint, lo: uint, hi: uint) -> str\n }\n \n fn get_filemap(cm: codemap, filename: str) -> filemap {\n-    for fm: filemap in cm.files { if fm.name == filename { ret fm; } }\n+    for cm.files.each {|fm| if fm.name == filename { ret fm; } }\n     //XXjdm the following triggers a mismatched type bug\n     //      (or expected function, found _|_)\n     fail; // (\"asking for \" + filename + \" which we don't know about\");"}, {"sha": "be4905333c372cfc9db98826a27692cda0502ae8", "filename": "src/librustsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fdiagnostic.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -201,7 +201,7 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n         elided = true;\n     }\n     // Print the offending lines\n-    for line: uint in display_lines {\n+    for display_lines.each {|line|\n         io::stderr().write_str(#fmt[\"%s:%u \", fm.name, line + 1u]);\n         let s = codemap::get_line(fm, line as int) + \"\\n\";\n         io::stderr().write_str(s);"}, {"sha": "a3b7f2ebbbb37f249dd703e013df0e71c46b36c4", "filename": "src/librustsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fbuild.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -68,7 +68,7 @@ fn mk_rec_e(cx: ext_ctxt, sp: span,\n             fields: [{ident: ast::ident, ex: @ast::expr}]) ->\n     @ast::expr {\n     let mut astfields: [ast::field] = [];\n-    for field: {ident: ast::ident, ex: @ast::expr} in fields {\n+    for fields.each {|field|\n         let ident = field.ident;\n         let val = field.ex;\n         let astfield ="}, {"sha": "58577eb2e08d5d1c16c650dd6ec88ef6d469201e", "filename": "src/librustsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fconcat_idents.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -11,7 +11,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n           }\n         };\n     let mut res: ast::ident = \"\";\n-    for e: @ast::expr in args {\n+    for args.each {|e|\n         res += expr_to_ident(cx, e, \"expected an ident\");\n     }\n "}, {"sha": "6b00059080e3ae6af3855171c0a821f7c0820906", "filename": "src/librustsyntax/ext/fmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Ffmt.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -57,7 +57,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n     fn make_rt_conv_expr(cx: ext_ctxt, sp: span, cnv: conv) -> @ast::expr {\n         fn make_flags(cx: ext_ctxt, sp: span, flags: [flag]) -> @ast::expr {\n             let mut flagexprs: [@ast::expr] = [];\n-            for f: flag in flags {\n+            for flags.each {|f|\n                 let mut fstr;\n                 alt f {\n                   flag_left_justify { fstr = \"flag_left_justify\"; }\n@@ -141,7 +141,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n           option::none { }\n           _ { cx.span_unimpl(sp, unsupported); }\n         }\n-        for f: flag in cnv.flags {\n+        for cnv.flags.each {|f|\n             alt f {\n               flag_left_justify { }\n               flag_sign_always {\n@@ -197,7 +197,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n           some(p) { log(debug, \"param: \" + int::to_str(p, 10u)); }\n           _ { #debug(\"param: none\"); }\n         }\n-        for f: flag in c.flags {\n+        for c.flags.each {|f|\n             alt f {\n               flag_left_justify { #debug(\"flag: left justify\"); }\n               flag_left_zero_pad { #debug(\"flag: left zero pad\"); }\n@@ -252,7 +252,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n     let mut n = 0u;\n     let mut tmp_expr = mk_str(cx, sp, \"\");\n     let nargs = vec::len::<@ast::expr>(args);\n-    for pc: piece in pieces {\n+    for pieces.each {|pc|\n         alt pc {\n           piece_string(s) {\n             let s_expr = mk_str(cx, fmt_sp, s);"}, {"sha": "eb031cfaf542e644e9c12653e0fda633b498d385", "filename": "src/librustsyntax/ext/simplext.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fsimplext.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -73,7 +73,7 @@ fn elts_to_ell(cx: ext_ctxt, elts: [@expr]) ->\n    {pre: [@expr], rep: option<@expr>, post: [@expr]} {\n     let mut idx: uint = 0u;\n     let mut res = none;\n-    for elt: @expr in elts {\n+    for elts.each {|elt|\n         alt elt.node {\n           expr_mac(m) {\n             alt m.node {\n@@ -102,7 +102,7 @@ fn elts_to_ell(cx: ext_ctxt, elts: [@expr]) ->\n fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option<U>, v: [T]) ->\n    option<[U]> {\n     let mut res = [];\n-    for elem: T in v {\n+    for v.each {|elem|\n         alt f(elem) { none { ret none; } some(fv) { res += [fv]; } }\n     }\n     ret some(res);\n@@ -163,7 +163,7 @@ selectors. */\n fn use_selectors_to_bind(b: binders, e: @expr) -> option<bindings> {\n     let res = str_hash::<arb_depth<matchable>>();\n     //need to do this first, to check vec lengths.\n-    for sel: selector in b.literal_ast_matchers {\n+    for b.literal_ast_matchers.each {|sel|\n         alt sel(match_expr(e)) { none { ret none; } _ { } }\n     }\n     let mut never_mind: bool = false;\n@@ -209,7 +209,7 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n fn follow(m: arb_depth<matchable>, idx_path: @mut [uint]) ->\n    arb_depth<matchable> {\n     let mut res: arb_depth<matchable> = m;\n-    for idx: uint in *idx_path {\n+    for vec::each(*idx_path) {|idx|\n         alt res {\n           leaf(_) { ret res;/* end of the line */ }\n           seq(new_ms, _) { res = new_ms[idx]; }\n@@ -677,7 +677,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n \n     let mut macro_name: option<str> = none;\n     let mut clauses: [@clause] = [];\n-    for arg: @expr in args {\n+    for args.each {|arg|\n         alt arg.node {\n           expr_vec(elts, mutbl) {\n             if vec::len(elts) != 2u {\n@@ -753,7 +753,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     fn generic_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                          _body: ast::mac_body, clauses: [@clause]) -> @expr {\n         let arg = get_mac_arg(cx,sp,arg);\n-        for c: @clause in clauses {\n+        for clauses.each {|c|\n             alt use_selectors_to_bind(c.params, arg) {\n               some(bindings) { ret transcribe(cx, bindings, c.body); }\n               none { cont; }"}, {"sha": "ca690c55ade668a80d55f8564a7a6bed8fc42677", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -338,7 +338,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           }\n           pat_rec(fields, etc) {\n             let mut fs = [];\n-            for f: ast::field_pat in fields {\n+            for fields.each {|f|\n                 fs += [{ident: f.ident, pat: fld.fold_pat(f.pat)}];\n             }\n             pat_rec(fs, etc)"}, {"sha": "d01667d10292277f00e7d87843aaa496fbbfc4c2", "filename": "src/librustsyntax/parse/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Feval.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -13,7 +13,7 @@ type ctx =\n fn eval_crate_directives(cx: ctx, cdirs: [@ast::crate_directive], prefix: str,\n                          &view_items: [@ast::view_item],\n                          &items: [@ast::item]) {\n-    for sub_cdir: @ast::crate_directive in cdirs {\n+    for cdirs.each {|sub_cdir|\n         eval_crate_directive(cx, sub_cdir, prefix, view_items, items);\n     }\n }"}, {"sha": "c48d7b3c5677a44409d52563972d33fadcecb5ff", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -143,12 +143,13 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader,\n // interpreted as a specific kind of statement, which would be confusing.\n fn bad_expr_word_table() -> hashmap<str, ()> {\n     let words = str_hash();\n-    for word in [\"alt\", \"assert\", \"be\", \"break\", \"check\", \"claim\",\n-                 \"class\", \"const\", \"cont\", \"copy\", \"crust\", \"do\", \"else\",\n-                 \"enum\", \"export\", \"fail\", \"fn\", \"for\", \"if\",  \"iface\",\n-                 \"impl\", \"import\", \"let\", \"log\", \"loop\", \"mod\", \"mut\",\n-                 \"mut\", \"native\", \"pure\", \"resource\", \"ret\", \"trait\",\n-                 \"type\", \"unchecked\", \"unsafe\", \"while\", \"new\"] {\n+    let keys = [\"alt\", \"assert\", \"be\", \"break\", \"check\", \"claim\",\n+                \"class\", \"const\", \"cont\", \"copy\", \"crust\", \"do\", \"else\",\n+                \"enum\", \"export\", \"fail\", \"fn\", \"for\", \"if\",  \"iface\",\n+                \"impl\", \"import\", \"let\", \"log\", \"loop\", \"mod\", \"mut\",\n+                \"mut\", \"native\", \"pure\", \"resource\", \"ret\", \"trait\",\n+                \"type\", \"unchecked\", \"unsafe\", \"while\", \"new\"];\n+    for keys.each {|word|\n         words.insert(word, ());\n     }\n     words\n@@ -312,7 +313,7 @@ fn parse_ty_field(p: parser) -> ast::ty_field {\n // otherwise, fail\n fn ident_index(p: parser, args: [ast::arg], i: ast::ident) -> uint {\n     let mut j = 0u;\n-    for a: ast::arg in args { if a.ident == i { ret j; } j += 1u; }\n+    for args.each {|a| if a.ident == i { ret j; } j += 1u; }\n     p.fatal(\"unbound variable `\" + i + \"` in constraint arg\");\n }\n \n@@ -1230,7 +1231,7 @@ fn parse_more_binops(p: parser, plhs: pexpr, min_prec: int) ->\n     let peeked = p.token;\n     if peeked == token::BINOP(token::OR) &&\n        p.restriction == RESTRICT_NO_BAR_OP { ret lhs; }\n-    for cur: op_spec in *p.precs {\n+    for vec::each(*p.precs) {|cur|\n         if cur.prec > min_prec && cur.tok == peeked {\n             p.bump();\n             let expr = parse_prefix_expr(p);\n@@ -1414,7 +1415,7 @@ fn parse_for_expr(p: parser) -> @ast::expr {\n       _ { false }\n     };\n     if new_style {\n-        let call = parse_expr(p);\n+        let call = parse_expr_res(p, RESTRICT_STMT_EXPR);\n         alt call.node {\n           ast::expr_call(f, args, true) {\n             let b_arg = vec::last(args);\n@@ -1428,6 +1429,7 @@ fn parse_for_expr(p: parser) -> @ast::expr {\n           }\n         }\n     } else {\n+        p.warn(\"old-style for\");\n         let decl = parse_local(p, false, false);\n         expect_word(p, \"in\");\n         let seq = parse_expr(p);\n@@ -2328,7 +2330,7 @@ fn parse_item_enum(p: parser, attrs: [ast::attribute]) -> @ast::item {\n             let arg_tys = parse_seq(token::LPAREN, token::RPAREN,\n                                     seq_sep(token::COMMA),\n                                     {|p| parse_ty(p, false)}, p);\n-            for ty in arg_tys.node {\n+            for arg_tys.node.each {|ty|\n                 args += [{ty: ty, id: p.get_id()}];\n             }\n         } else if eat(p, token::EQ) {"}, {"sha": "ef0e512bbfe83dabca42a0ee09b74ca666b857de", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -269,7 +269,7 @@ fn synth_comment(s: ps, text: str) {\n fn commasep<IN>(s: ps, b: breaks, elts: [IN], op: fn(ps, IN)) {\n     box(s, 0u, b);\n     let mut first = true;\n-    for elt: IN in elts {\n+    for elts.each {|elt|\n         if first { first = false; } else { word_space(s, \",\"); }\n         op(s, elt);\n     }\n@@ -282,7 +282,7 @@ fn commasep_cmnt<IN>(s: ps, b: breaks, elts: [IN], op: fn(ps, IN),\n     box(s, 0u, b);\n     let len = vec::len::<IN>(elts);\n     let mut i = 0u;\n-    for elt: IN in elts {\n+    for elts.each {|elt|\n         maybe_print_comment(s, get_span(elt).hi);\n         op(s, elt);\n         i += 1u;\n@@ -303,18 +303,18 @@ fn commasep_exprs(s: ps, b: breaks, exprs: [@ast::expr]) {\n \n fn print_mod(s: ps, _mod: ast::_mod, attrs: [ast::attribute]) {\n     print_inner_attributes(s, attrs);\n-    for vitem: @ast::view_item in _mod.view_items {\n+    for _mod.view_items.each {|vitem|\n         print_view_item(s, vitem);\n     }\n-    for item: @ast::item in _mod.items { print_item(s, item); }\n+    for _mod.items.each {|item| print_item(s, item); }\n }\n \n fn print_native_mod(s: ps, nmod: ast::native_mod, attrs: [ast::attribute]) {\n     print_inner_attributes(s, attrs);\n-    for vitem: @ast::view_item in nmod.view_items {\n+    for nmod.view_items.each {|vitem|\n         print_view_item(s, vitem);\n     }\n-    for item: @ast::native_item in nmod.items { print_native_item(s, item); }\n+    for nmod.items.each {|item| print_native_item(s, item); }\n }\n \n fn print_region(s: ps, region: ast::region) {\n@@ -476,7 +476,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n             end(s);\n         } else {\n             bopen(s);\n-            for v: ast::variant in variants {\n+            for variants.each {|v|\n                 space_if_not_bol(s);\n                 maybe_print_comment(s, v.span.lo);\n                 print_outer_attributes(s, v.node.attrs);\n@@ -500,7 +500,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n           print_fn_args_and_ret(s, ctor.node.dec);\n           space(s.s);\n           print_block(s, ctor.node.body);\n-          for ci in items {\n+          for items.each {|ci|\n                   /*\n                      FIXME: collect all private items and print them\n                      in a single \"priv\" section\n@@ -556,7 +556,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         print_type(s, ty);\n         space(s.s);\n         bopen(s);\n-        for meth in methods {\n+        for methods.each {|meth|\n            print_method(s, meth);\n         }\n         bclose(s, item.span);\n@@ -567,7 +567,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         print_type_params(s, tps);\n         word(s.s, \" \");\n         bopen(s);\n-        for meth in methods { print_ty_method(s, meth); }\n+        for methods.each {|meth| print_ty_method(s, meth); }\n         bclose(s, item.span);\n       }\n       ast::item_res(decl, tps, body, dt_id, ct_id) {\n@@ -629,7 +629,7 @@ fn print_method(s: ps, meth: @ast::method) {\n \n fn print_outer_attributes(s: ps, attrs: [ast::attribute]) {\n     let mut count = 0;\n-    for attr: ast::attribute in attrs {\n+    for attrs.each {|attr|\n         alt attr.node.style {\n           ast::attr_outer { print_attribute(s, attr); count += 1; }\n           _ {/* fallthrough */ }\n@@ -640,7 +640,7 @@ fn print_outer_attributes(s: ps, attrs: [ast::attribute]) {\n \n fn print_inner_attributes(s: ps, attrs: [ast::attribute]) {\n     let mut count = 0;\n-    for attr: ast::attribute in attrs {\n+    for attrs.each {|attr|\n         alt attr.node.style {\n           ast::attr_inner {\n             print_attribute(s, attr);\n@@ -716,8 +716,8 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n \n     print_inner_attributes(s, attrs);\n \n-    for vi in blk.node.view_items { print_view_item(s, vi); }\n-    for st: @ast::stmt in blk.node.stmts {\n+    for blk.node.view_items.each {|vi| print_view_item(s, vi); }\n+    for blk.node.stmts.each {|st|\n         print_stmt(s, *st);\n     }\n     alt blk.node.expr {\n@@ -957,12 +957,12 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         print_maybe_parens_discrim(s, expr);\n         space(s.s);\n         bopen(s);\n-        for arm: ast::arm in arms {\n+        for arms.each {|arm|\n             space(s.s);\n             cbox(s, alt_indent_unit);\n             ibox(s, 0u);\n             let mut first = true;\n-            for p: @ast::pat in arm.pats {\n+            for arm.pats.each {|p|\n                 if first {\n                     first = false;\n                 } else { space(s.s); word_space(s, \"|\"); }\n@@ -1189,7 +1189,7 @@ fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n     if path.node.global { word(s.s, \"::\"); }\n     let mut first = true;\n-    for id: ast::ident in path.node.idents {\n+    for path.node.idents.each {|id|\n         if first { first = false; } else { word(s.s, \"::\"); }\n         word(s.s, id);\n     }\n@@ -1359,7 +1359,7 @@ fn print_arg_mode(s: ps, m: ast::mode) {\n fn print_bounds(s: ps, bounds: @[ast::ty_param_bound]) {\n     if vec::len(*bounds) > 0u {\n         word(s.s, \":\");\n-        for bound in *bounds {\n+        for vec::each(*bounds) {|bound|\n             nbsp(s);\n             alt bound {\n               ast::bound_copy { word(s.s, \"copy\"); }\n@@ -1403,7 +1403,7 @@ fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n \n fn print_simple_path(s: ps, path: ast::simple_path) {\n     let mut first = true;\n-    for id in path {\n+    for path.each {|id|\n         if first { first = false; } else { word(s.s, \"::\"); }\n         word(s.s, id);\n     }\n@@ -1472,7 +1472,7 @@ fn print_view_item(s: ps, item: @ast::view_item) {\n // FIXME: The fact that this builds up the table anew for every call is\n // not good. Eventually, table should be a const.\n fn operator_prec(op: ast::binop) -> int {\n-    for spec: parse::parser::op_spec in *parse::parser::prec_table() {\n+    for vec::each(*parse::parser::prec_table()) {|spec|\n         if spec.op == op { ret spec.prec; }\n     }\n     core::unreachable();\n@@ -1667,7 +1667,7 @@ fn print_comment(s: ps, cmnt: lexer::cmnt) {\n       }\n       lexer::isolated {\n         pprust::hardbreak_if_not_bol(s);\n-        for line: str in cmnt.lines {\n+        for cmnt.lines.each {|line|\n             // Don't print empty lines because they will end up as trailing\n             // whitespace\n             if str::is_not_empty(line) { word(s.s, line); }\n@@ -1681,7 +1681,7 @@ fn print_comment(s: ps, cmnt: lexer::cmnt) {\n             hardbreak(s.s);\n         } else {\n             ibox(s, 0u);\n-            for line: str in cmnt.lines {\n+            for cmnt.lines.each {|line|\n                 if str::is_not_empty(line) { word(s.s, line); }\n                 hardbreak(s.s);\n             }\n@@ -1752,7 +1752,7 @@ fn constr_args_to_str<T>(f: fn@(T) -> str, args: [@ast::sp_constr_arg<T>]) ->\n    str {\n     let mut comma = false;\n     let mut s = \"(\";\n-    for a: @ast::sp_constr_arg<T> in args {\n+    for args.each {|a|\n         if comma { s += \", \"; } else { comma = true; }\n         s += constr_arg_to_str::<T>(f, a.node);\n     }\n@@ -1795,7 +1795,7 @@ fn ty_constr_to_str(&&c: @ast::ty_constr) -> str {\n \n fn constrs_str<T>(constrs: [T], elt: fn(T) -> str) -> str {\n     let mut s = \"\", colon = true;\n-    for c in constrs {\n+    for constrs.each {|c|\n         if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += elt(c);\n     }"}, {"sha": "fbeae7bc5a918fd3a1aef6da20701000740deb3a", "filename": "src/librustsyntax/visit.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibrustsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fvisit.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -84,7 +84,7 @@ fn visit_crate_directive<E>(cd: @crate_directive, e: E, v: vt<E>) {\n     alt cd.node {\n       cdir_src_mod(_, _) { }\n       cdir_dir_mod(_, cdirs, _) {\n-        for cdir: @crate_directive in cdirs {\n+        for cdirs.each {|cdir|\n             visit_crate_directive(cdir, e, v);\n         }\n       }\n@@ -94,8 +94,8 @@ fn visit_crate_directive<E>(cd: @crate_directive, e: E, v: vt<E>) {\n }\n \n fn visit_mod<E>(m: _mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n-    for vi: @view_item in m.view_items { v.visit_view_item(vi, e, v); }\n-    for i: @item in m.items { v.visit_item(i, e, v); }\n+    for m.view_items.each {|vi| v.visit_view_item(vi, e, v); }\n+    for m.items.each {|i| v.visit_item(i, e, v); }\n }\n \n fn visit_view_item<E>(_vi: @view_item, _e: E, _v: vt<E>) { }\n@@ -114,8 +114,8 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       }\n       item_mod(m) { v.visit_mod(m, i.span, i.id, e, v); }\n       item_native_mod(nm) {\n-        for vi: @view_item in nm.view_items { v.visit_view_item(vi, e, v); }\n-        for ni: @native_item in nm.items { v.visit_native_item(ni, e, v); }\n+        for nm.view_items.each {|vi| v.visit_view_item(vi, e, v); }\n+        for nm.items.each {|ni| v.visit_native_item(ni, e, v); }\n       }\n       item_ty(t, tps) { v.visit_ty(t, e, v); v.visit_ty_params(tps, e, v); }\n       item_res(decl, tps, body, dtor_id, _) {\n@@ -124,21 +124,21 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       }\n       item_enum(variants, tps) {\n         v.visit_ty_params(tps, e, v);\n-        for vr: variant in variants {\n-            for va: variant_arg in vr.node.args { v.visit_ty(va.ty, e, v); }\n+        for variants.each {|vr|\n+            for vr.node.args.each {|va| v.visit_ty(va.ty, e, v); }\n         }\n       }\n       item_impl(tps, ifce, ty, methods) {\n         v.visit_ty_params(tps, e, v);\n         alt ifce { some(ty) { v.visit_ty(ty, e, v); } none {} }\n         v.visit_ty(ty, e, v);\n-        for m in methods {\n+        for methods.each {|m|\n             visit_method_helper(m, e, v)\n         }\n       }\n       item_class(tps, members, ctor) {\n           v.visit_ty_params(tps, e, v);\n-          for m in members {\n+          for members.each {|m|\n              v.visit_class_item(m, e, v);\n           }\n           // make up a fake fn so as to call visit_fn on the ctor\n@@ -147,8 +147,8 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       }\n       item_iface(tps, methods) {\n         v.visit_ty_params(tps, e, v);\n-        for m in methods {\n-            for a in m.decl.inputs { v.visit_ty(a.ty, e, v); }\n+        for methods.each {|m|\n+            for m.decl.inputs.each {|a| v.visit_ty(a.ty, e, v); }\n             v.visit_ty(m.decl.output, e, v);\n         }\n       }\n@@ -176,20 +176,20 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n       ty_ptr(mt) { v.visit_ty(mt.ty, e, v); }\n       ty_rptr(_, mt) { v.visit_ty(mt.ty, e, v); }\n       ty_rec(flds) {\n-        for f: ty_field in flds { v.visit_ty(f.node.mt.ty, e, v); }\n+        for flds.each {|f| v.visit_ty(f.node.mt.ty, e, v); }\n       }\n-      ty_tup(ts) { for tt in ts { v.visit_ty(tt, e, v); } }\n+      ty_tup(ts) { for ts.each {|tt| v.visit_ty(tt, e, v); } }\n       ty_fn(_, decl) {\n-        for a in decl.inputs { v.visit_ty(a.ty, e, v); }\n-        for c: @constr in decl.constraints {\n+        for decl.inputs.each {|a| v.visit_ty(a.ty, e, v); }\n+        for decl.constraints.each {|c|\n             v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n         }\n         v.visit_ty(decl.output, e, v);\n       }\n       ty_path(p, _) { visit_path(p, e, v); }\n       ty_constr(t, cs) {\n         v.visit_ty(t, e, v);\n-        for tc: @spanned<constr_general_<@path, node_id>> in cs {\n+        for cs.each {|tc|\n             v.visit_constr(tc.node.path, tc.span, tc.node.id, e, v);\n         }\n       }\n@@ -207,19 +207,19 @@ fn visit_constr<E>(_operator: @path, _sp: span, _id: node_id, _e: E,\n }\n \n fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n-    for tp: @ty in p.node.types { v.visit_ty(tp, e, v); }\n+    for p.node.types.each {|tp| v.visit_ty(tp, e, v); }\n }\n \n fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     alt p.node {\n       pat_enum(path, children) {\n         visit_path(path, e, v);\n-        for child: @pat in children { v.visit_pat(child, e, v); }\n+        for children.each {|child| v.visit_pat(child, e, v); }\n       }\n       pat_rec(fields, _) {\n-        for f: field_pat in fields { v.visit_pat(f.pat, e, v); }\n+        for fields.each {|f| v.visit_pat(f.pat, e, v); }\n       }\n-      pat_tup(elts) { for elt in elts { v.visit_pat(elt, e, v); } }\n+      pat_tup(elts) { for elts.each {|elt| v.visit_pat(elt, e, v); } }\n       pat_box(inner) | pat_uniq(inner) {\n         v.visit_pat(inner, e, v);\n       }\n@@ -243,8 +243,8 @@ fn visit_native_item<E>(ni: @native_item, e: E, v: vt<E>) {\n }\n \n fn visit_ty_params<E>(tps: [ty_param], e: E, v: vt<E>) {\n-    for tp in tps {\n-        for bound in *tp.bounds {\n+    for tps.each {|tp|\n+        for vec::each(*tp.bounds) {|bound|\n             alt bound {\n               bound_iface(t) { v.visit_ty(t, e, v); }\n               bound_copy | bound_send { }\n@@ -254,8 +254,8 @@ fn visit_ty_params<E>(tps: [ty_param], e: E, v: vt<E>) {\n }\n \n fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n-    for a: arg in fd.inputs { v.visit_ty(a.ty, e, v); }\n-    for c: @constr in fd.constraints {\n+    for fd.inputs.each {|a| v.visit_ty(a.ty, e, v); }\n+    for fd.constraints.each {|c|\n         v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n     }\n     v.visit_ty(fd.output, e, v);\n@@ -278,8 +278,8 @@ fn visit_fn<E>(fk: fn_kind, decl: fn_decl, body: blk, _sp: span,\n }\n \n fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n-    for vi in b.node.view_items { v.visit_view_item(vi, e, v); }\n-    for s in b.node.stmts { v.visit_stmt(s, e, v); }\n+    for b.node.view_items.each {|vi| v.visit_view_item(vi, e, v); }\n+    for b.node.stmts.each {|s| v.visit_stmt(s, e, v); }\n     visit_expr_opt(b.node.expr, e, v);\n }\n \n@@ -294,7 +294,7 @@ fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n     alt d.node {\n       decl_local(locs) {\n-        for loc in locs { v.visit_local(loc, e, v); }\n+        for locs.each {|loc| v.visit_local(loc, e, v); }\n       }\n       decl_item(it) { v.visit_item(it, e, v); }\n     }\n@@ -305,7 +305,7 @@ fn visit_expr_opt<E>(eo: option<@expr>, e: E, v: vt<E>) {\n }\n \n fn visit_exprs<E>(exprs: [@expr], e: E, v: vt<E>) {\n-    for ex: @expr in exprs { v.visit_expr(ex, e, v); }\n+    for exprs.each {|ex| v.visit_expr(ex, e, v); }\n }\n \n fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n@@ -328,17 +328,17 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       }\n       expr_vec(es, _) { visit_exprs(es, e, v); }\n       expr_rec(flds, base) {\n-        for f: field in flds { v.visit_expr(f.node.expr, e, v); }\n+        for flds.each {|f| v.visit_expr(f.node.expr, e, v); }\n         visit_expr_opt(base, e, v);\n       }\n-      expr_tup(elts) { for el in elts { v.visit_expr(el, e, v); } }\n+      expr_tup(elts) { for elts.each {|el| v.visit_expr(el, e, v); } }\n       expr_call(callee, args, _) {\n         visit_exprs(args, e, v);\n         v.visit_expr(callee, e, v);\n       }\n       expr_bind(callee, args) {\n         v.visit_expr(callee, e, v);\n-        for eo: option<@expr> in args { visit_expr_opt(eo, e, v); }\n+        for args.each {|eo| visit_expr_opt(eo, e, v); }\n       }\n       expr_binary(_, a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_addr_of(_, x) | expr_unary(_, x) | expr_loop_body(x) |\n@@ -367,7 +367,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       expr_do_while(b, x) { v.visit_block(b, e, v); v.visit_expr(x, e, v); }\n       expr_alt(x, arms, _) {\n         v.visit_expr(x, e, v);\n-        for a: arm in arms { v.visit_arm(a, e, v); }\n+        for arms.each {|a| v.visit_arm(a, e, v); }\n       }\n       expr_fn(proto, decl, body, _) {\n         v.visit_fn(fk_anon(proto), decl, body, ex.span, ex.id, e, v);\n@@ -386,7 +386,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       }\n       expr_field(x, _, tys) {\n         v.visit_expr(x, e, v);\n-        for tp in tys { v.visit_ty(tp, e, v); }\n+        for tys.each {|tp| v.visit_ty(tp, e, v); }\n       }\n       expr_index(a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_path(p) { visit_path(p, e, v); }\n@@ -404,7 +404,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n }\n \n fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n-    for p: @pat in a.pats { v.visit_pat(p, e, v); }\n+    for a.pats.each {|p| v.visit_pat(p, e, v); }\n     visit_expr_opt(a.guard, e, v);\n     v.visit_block(a.body, e, v);\n }"}, {"sha": "d5e59ead1f2aa9a4767b0bf1327f00ed5b0ca7d4", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -67,7 +67,7 @@ fn max_key<T: copy>(m: smallintmap<T>) -> uint {\n impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     fn size() -> uint {\n         let mut sz = 0u;\n-        for item in self.v {\n+        for vec::each(self.v) {|item|\n             alt item { some(_) { sz += 1u; } _ {} }\n         }\n         sz\n@@ -90,28 +90,26 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     fn find(&&key: uint) -> option<V> { find(self, key) }\n     fn rehash() { fail }\n     fn items(it: fn(&&uint, V)) {\n-        let mut idx = 0u;\n-        for item in self.v {\n-            alt item {\n+        let mut idx = 0u, l = self.v.len();\n+        while idx < l {\n+            alt self.v[idx] {\n               some(elt) {\n-                it(idx, elt);\n+                it(idx, copy elt);\n               }\n               none { }\n             }\n             idx += 1u;\n         }\n     }\n     fn keys(it: fn(&&uint)) {\n-        let mut idx = 0u;\n-        for item in self.v {\n-            if item != none { it(idx); }\n+        let mut idx = 0u, l = self.v.len();\n+        while idx < l {\n+            if self.v[idx] != none { it(idx); }\n             idx += 1u;\n         }\n     }\n     fn values(it: fn(V)) {\n-        for item in self.v {\n-            alt item { some(elt) { it(elt); } _ {} }\n-        }\n+        self.items({|_i, v| it(v)});\n     }\n }\n "}, {"sha": "33c39c33a9bdf10c949e16838c70665daa2dfe03", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -303,7 +303,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n         let mut cmh_items: [@ast::meta_item] = [];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n-        for meta: @ast::meta_item in linkage_metas {\n+        for linkage_metas.each {|meta|\n             if attr::get_meta_item_name(meta) == \"name\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { name = some(v); }\n@@ -334,7 +334,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n         let cmh_items = attr::sort_meta_items(metas.cmh_items);\n \n         sha.reset();\n-        for m_: @ast::meta_item in cmh_items {\n+        for cmh_items.each {|m_|\n             let m = m_;\n             alt m.node {\n               ast::meta_name_value(key, value) {\n@@ -349,7 +349,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n             }\n         }\n \n-        for dh in dep_hashes {\n+        for dep_hashes.each {|dh|\n             sha.input_str(len_and_str(dh));\n         }\n \n@@ -475,7 +475,7 @@ fn mangle(ss: path) -> str {\n \n     let mut n = \"_ZN\"; // Begin name-sequence.\n \n-    for s in ss {\n+    for ss.each {|s|\n         alt s { path_name(s) | path_mod(s) {\n           let sani = sanitize(s);\n           n += #fmt[\"%u%s\", str::len(sani), sani];\n@@ -583,7 +583,7 @@ fn link_binary(sess: session,\n     } else { lib_cmd = \"-shared\"; }\n \n     let cstore = sess.cstore;\n-    for cratepath: str in cstore::get_used_crate_files(cstore) {\n+    for cstore::get_used_crate_files(cstore).each {|cratepath|\n         if str::ends_with(cratepath, \".rlib\") {\n             cc_args += [cratepath];\n             cont;\n@@ -596,10 +596,10 @@ fn link_binary(sess: session,\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for arg: str in ula { cc_args += [arg]; }\n+    for ula.each {|arg| cc_args += [arg]; }\n \n     let used_libs = cstore::get_used_libraries(cstore);\n-    for l: str in used_libs { cc_args += [\"-l\" + l]; }\n+    for used_libs.each {|l| cc_args += [\"-l\" + l]; }\n \n     if sess.building_library {\n         cc_args += [lib_cmd];"}, {"sha": "a52482d11d24b0bdffecc23432ff952969362b8c", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -55,7 +55,7 @@ fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n     #debug(\"sysroot: %s\", sysroot);\n     #debug(\"output: %s\", output);\n     #debug(\"libs:\");\n-    for libpath in libs {\n+    for libs.each {|libpath|\n         #debug(\"    %s\", libpath);\n     }\n     #debug(\"target_triple: %s\", target_triple);\n@@ -74,7 +74,7 @@ fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n \n     fn log_rpaths(desc: str, rpaths: [str]) {\n         #debug(\"%s rpaths:\", desc);\n-        for rpath in rpaths {\n+        for rpaths.each {|rpath|\n             #debug(\"    %s\", rpath);\n         }\n     }\n@@ -179,7 +179,7 @@ fn get_install_prefix_rpath(cwd: path::path, target_triple: str) -> str {\n fn minimize_rpaths(rpaths: [str]) -> [str] {\n     let set = map::str_hash::<()>();\n     let mut minimized = [];\n-    for rpath in rpaths {\n+    for rpaths.each {|rpath|\n         if !set.contains_key(rpath) {\n             minimized += [rpath];\n             set.insert(rpath, ());"}, {"sha": "b1b60c3b127e5f3346d34740b714f988e6636f92", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -35,7 +35,7 @@ fn declare_upcalls(targ_cfg: @session::config,\n             tys: [TypeRef], rv: TypeRef) ->\n        ValueRef {\n         let mut arg_tys: [TypeRef] = [];\n-        for t: TypeRef in tys { arg_tys += [t]; }\n+        for tys.each {|t| arg_tys += [t]; }\n         let fn_ty = T_fn(arg_tys, rv);\n         ret base::decl_cdecl_fn(llmod, prefix + name, fn_ty);\n     }"}, {"sha": "8a5a88d91fa9a178345d7e9277a3fb8f03f3ff7c", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -67,7 +67,7 @@ fn parse_cfgspecs(cfgspecs: [str]) -> ast::crate_cfg {\n     // FIXME: It would be nice to use the parser to parse all varieties of\n     // meta_item here. At the moment we just support the meta_word variant.\n     let mut words = [];\n-    for s: str in cfgspecs { words += [attr::mk_word_item(s)]; }\n+    for cfgspecs.each {|s| words += [attr::mk_word_item(s)]; }\n     ret words;\n }\n "}, {"sha": "aee5347f07f73c631c2d52bff8e6172412cd16f3", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -118,7 +118,7 @@ fn metas_in_cfg(cfg: ast::crate_cfg, metas: [@ast::meta_item]) -> bool {\n     let has_cfg_metas = vec::len(cfg_metas) > 0u;\n     if !has_cfg_metas { ret true; }\n \n-    for cfg_mi: @ast::meta_item in cfg_metas {\n+    for cfg_metas.each {|cfg_mi|\n         if attr::contains(cfg, cfg_mi) { ret true; }\n     }\n "}, {"sha": "aa1090cb2ae178ad943d8335c411651c9a0d5bf0", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -268,7 +268,7 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n     #debug(\"building test vector from %u tests\", vec::len(cx.testfns));\n     let mut descs = [];\n-    for test: test in cx.testfns {\n+    for cx.testfns.each {|test|\n         let test_ = test; // Satisfy alias analysis\n         descs += [mk_test_desc_rec(cx, test_)];\n     }"}, {"sha": "0d9e91bf1f08a5707754c50ec901d48b0d8ca735", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -967,7 +967,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n     fn tys_str(names: type_names, outer: [TypeRef], tys: [TypeRef]) -> str {\n         let mut s: str = \"\";\n         let mut first: bool = true;\n-        for t: TypeRef in tys {\n+        for tys.each {|t|\n             if first { first = false; } else { s += \", \"; }\n             s += type_to_str_inner(names, outer, t);\n         }\n@@ -1019,7 +1019,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n       }\n       12 {\n         let mut i: uint = 0u;\n-        for tout: TypeRef in outer0 {\n+        for outer0.each {|tout|\n             i += 1u;\n             if tout as int == ty as int {\n                 let n: uint = vec::len::<TypeRef>(outer0) - i;"}, {"sha": "48d242f04dd3fc649724557b5c69239e3a40fe7e", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -142,7 +142,7 @@ fn visit_ids(item: ast::inlined_item, vfn: fn@(ast::node_id)) {\n             vfn(i.id);\n             alt i.node {\n               ast::item_res(_, _, _, d_id, c_id) { vfn(d_id); vfn(c_id); }\n-              ast::item_enum(vs, _) { for v in vs { vfn(v.node.id); } }\n+              ast::item_enum(vs, _) { for vs.each {|v| vfn(v.node.id); } }\n               _ {}\n             }\n         },"}, {"sha": "4d534efea35b4be52faa543af2bf79ddd1a63640", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -111,7 +111,7 @@ fn hash_node_id(&&node_id: int) -> uint { ret 177573u ^ (node_id as uint); }\n \n fn hash_path(&&s: str) -> uint {\n     let mut h = 5381u;\n-    for ch: u8 in str::bytes(s) { h = (h << 5u) + h ^ (ch as uint); }\n+    for str::each(s) {|ch| h = (h << 5u) + h ^ (ch as uint); }\n     ret h;\n }\n "}, {"sha": "4b53fc758a7ffe03438495b134e9e588431033d3", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -117,7 +117,7 @@ fn visit_item(e: env, i: @ast::item) {\n             e.sess.span_fatal(i.span, \"library '\" + native_name +\n                               \"' already added: can't specify link_args.\");\n         }\n-        for a: ast::attribute in link_args {\n+        for link_args.each {|a|\n             alt attr::get_meta_item_value_str(attr::attr_meta(a)) {\n               some(linkarg) {\n                 cstore::add_used_link_args(cstore, linkarg);\n@@ -153,11 +153,11 @@ fn metadata_matches(extern_metas: [@ast::meta_item],\n            vec::len(local_metas), vec::len(extern_metas));\n \n     #debug(\"crate metadata:\");\n-    for have: @ast::meta_item in extern_metas {\n+    for extern_metas.each {|have|\n         #debug(\"  %s\", pprust::meta_item_to_str(*have));\n     }\n \n-    for needed: @ast::meta_item in local_metas {\n+    for local_metas.each {|needed|\n         #debug(\"looking for %s\", pprust::meta_item_to_str(*needed));\n         if !attr::contains(extern_metas, needed) {\n             #debug(\"missing %s\", pprust::meta_item_to_str(*needed));\n@@ -375,7 +375,7 @@ fn resolve_crate_deps(e: env, cdata: @[u8]) -> cstore::cnum_map {\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     let cnum_map = int_hash::<ast::crate_num>();\n-    for dep: decoder::crate_dep in decoder::get_crate_deps(cdata) {\n+    for decoder::get_crate_deps(cdata).each {|dep|\n         let extrn_cnum = dep.cnum;\n         let cname = dep.ident;\n         // FIXME: We really need to know the linkage metas of our transitive"}, {"sha": "504f5890638290d9374754809960123693d09e32", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -41,7 +41,8 @@ fn lookup_defs(cstore: cstore::cstore, cnum: ast::crate_num,\n                path: [ast::ident]) -> [ast::def] {\n     let mut result = [];\n     #debug(\"lookup_defs: path = %? cnum = %?\", path, cnum);\n-    for (c, data, def) in resolve_path(cstore, cnum, path) {\n+    for resolve_path(cstore, cnum, path).each {|elt|\n+        let (c, data, def) = elt;\n         result += [decoder::lookup_def(c, data, def)];\n     }\n     ret result;\n@@ -64,7 +65,7 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n     #debug(\"resolve_path %s in crates[%d]:%s\",\n            str::connect(path, \"::\"), cnum, cm.name);\n     let mut result = [];\n-    for def in decoder::resolve_path(path, cm.data) {\n+    for decoder::resolve_path(path, cm.data).each {|def|\n         if def.crate == ast::local_crate {\n             result += [(cnum, cm.data, def)];\n         } else {"}, {"sha": "7af5447ba0e921697785b2fa73e520361a430be2", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -154,7 +154,7 @@ fn get_dep_hashes(cstore: cstore) -> [str] {\n     }\n     let sorted = std::sort::merge_sort(lteq, result);\n     #debug(\"sorted:\");\n-    for x in sorted {\n+    for sorted.each {|x|\n         #debug(\"  hash[%s]: %s\", x.name, x.hash);\n     }\n     fn mapper(ch: crate_hash) -> str { ret ch.hash; }"}, {"sha": "321bd16df4495cb049c9b01eaf07f95597a1aba3", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -204,7 +204,7 @@ fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n     let eqer = bind eq_item(_, s);\n     let mut result: [ast::def_id] = [];\n     #debug(\"resolve_path: looking up %s\", s);\n-    for doc: ebml::doc in lookup_hash(paths, eqer, hash_path(s)) {\n+    for lookup_hash(paths, eqer, hash_path(s)).each {|doc|\n         let did_doc = ebml::get_doc(doc, tag_def_id);\n         result += [parse_def_id(ebml::doc_data(did_doc))];\n     }\n@@ -359,15 +359,15 @@ fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     let mut infos: [ty::variant_info] = [];\n     let variant_ids = enum_variant_ids(item, cdata);\n     let mut disr_val = 0;\n-    for did: ast::def_id in variant_ids {\n+    for variant_ids.each {|did|\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type({crate: cdata.cnum, node: id}, item,\n                                 tcx, cdata);\n         let name = item_name(item);\n         let mut arg_tys: [ty::t] = [];\n         alt ty::get(ctor_ty).struct {\n           ty::ty_fn(f) {\n-            for a: ty::arg in f.inputs { arg_tys += [a.ty]; }\n+            for f.inputs.each {|a| arg_tys += [a.ty]; }\n           }\n           _ { /* Nullary enum variant. */ }\n         }\n@@ -560,15 +560,15 @@ fn get_attributes(md: ebml::doc) -> [ast::attribute] {\n }\n \n fn list_meta_items(meta_items: ebml::doc, out: io::writer) {\n-    for mi: @ast::meta_item in get_meta_items(meta_items) {\n+    for get_meta_items(meta_items).each {|mi|\n         out.write_str(#fmt[\"%s\\n\", pprust::meta_item_to_str(*mi)]);\n     }\n }\n \n fn list_crate_attributes(md: ebml::doc, hash: str, out: io::writer) {\n     out.write_str(#fmt(\"=Crate Attributes (%s)=\\n\", hash));\n \n-    for attr: ast::attribute in get_attributes(md) {\n+    for get_attributes(md).each {|attr|\n         out.write_str(#fmt[\"%s\\n\", pprust::attribute_to_str(attr)]);\n     }\n \n@@ -597,7 +597,7 @@ fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n fn list_crate_deps(data: @[u8], out: io::writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n-    for dep: crate_dep in get_crate_deps(data) {\n+    for get_crate_deps(data).each {|dep|\n         out.write_str(#fmt[\"%d %s\\n\", dep.cnum, dep.ident]);\n     }\n "}, {"sha": "5a8f26c6d8d29e31b3d7700dc094fcf1cfadbcc8", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -58,7 +58,7 @@ type entry<T> = {val: T, pos: uint};\n \n fn encode_enum_variant_paths(ebml_w: ebml::writer, variants: [variant],\n                             path: [str], &index: [entry<str>]) {\n-    for variant: variant in variants {\n+    for variants.each {|variant|\n         add_to_index(ebml_w, path, index, variant.node.name);\n         ebml_w.wr_tag(tag_paths_data_item) {||\n             encode_name(ebml_w, variant.node.name);\n@@ -76,15 +76,15 @@ fn add_to_index(ebml_w: ebml::writer, path: [str], &index: [entry<str>],\n \n fn encode_native_module_item_paths(ebml_w: ebml::writer, nmod: native_mod,\n                                    path: [str], &index: [entry<str>]) {\n-    for nitem: @native_item in nmod.items {\n+    for nmod.items.each {|nitem|\n         add_to_index(ebml_w, path, index, nitem.ident);\n         encode_named_def_id(ebml_w, nitem.ident, local_def(nitem.id));\n     }\n }\n \n fn encode_class_item_paths(ebml_w: ebml::writer,\n      items: [@class_member], path: [str], &index: [entry<str>]) {\n-    for it in items {\n+    for items.each {|it|\n      alt ast_util::class_member_privacy(it) {\n           priv { cont; }\n           pub {\n@@ -102,7 +102,7 @@ fn encode_class_item_paths(ebml_w: ebml::writer,\n fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                             module: _mod, path: [str], &index: [entry<str>]) {\n     // FIXME factor out add_to_index/start/encode_name/encode_def_id/end ops\n-    for it: @item in module.items {\n+    for module.items.each {|it|\n         if !ecx.ccx.reachable.contains_key(it.id) ||\n            !ast_util::is_exported(it.ident, module) { cont; }\n         alt it.node {\n@@ -200,7 +200,7 @@ fn encode_reexport_paths(ebml_w: ebml::writer,\n                          ecx: @encode_ctxt, &index: [entry<str>]) {\n     let tcx = ecx.ccx.tcx;\n     ecx.ccx.exp_map.items {|exp_id, defs|\n-        for def in defs {\n+        for defs.each {|def|\n             if !def.reexp { cont; }\n             let path = alt check tcx.items.get(exp_id) {\n               ast_map::node_export(_, path) { ast_map::path_to_str(*path) }\n@@ -230,7 +230,7 @@ fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                         tcx: ecx.ccx.tcx,\n                         reachable: ecx.ccx.reachable,\n                         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n-    for param in params {\n+    for params.each {|param|\n         ebml_w.start_tag(tag_items_data_item_ty_param_bounds);\n         let bs = ecx.ccx.tcx.ty_param_bounds.get(param.id);\n         tyencode::enc_bounds(ebml_w.writer, ty_str_ctxt, bs);\n@@ -295,7 +295,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     let mut disr_val = 0;\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.ccx.tcx, {crate: local_crate, node: id});\n-    for variant: variant in variants {\n+    for variants.each {|variant|\n         *index += [{val: variant.node.id, pos: ebml_w.writer.tell()}];\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n@@ -347,7 +347,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     encode_name(ebml_w, name);\n     alt ecx.ccx.maps.impl_map.get(id) {\n       list::cons(impls, @list::nil) {\n-        for i in *impls {\n+        for vec::each(*impls) {|i|\n             if ast_util::is_exported(i.ident, md) {\n                 ebml_w.wr_tagged_str(tag_mod_impl, def_to_str(i.did));\n             }\n@@ -373,7 +373,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n  -> [entry<int>] {\n     let index = @mut [];\n     let tcx = ecx.ccx.tcx;\n-    for ci in items {\n+    for items.each {|ci|\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n       alt ci.node {\n@@ -409,7 +409,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n           }\n         }\n       }\n-    }\n+    };\n     *index\n }\n \n@@ -548,7 +548,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n-        for v: variant in variants {\n+        for variants.each {|v|\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n         astencode::encode_inlined_item(ecx, ebml_w, path, ii_item(item));\n@@ -579,14 +579,14 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n          for methods, write all the stuff get_iface_method\n         needs to know*/\n         let (fs,ms) = ast_util::split_class_items(items);\n-        for f in fs {\n+        for fs.each {|f|\n            ebml_w.start_tag(tag_item_field);\n            encode_privacy(ebml_w, f.privacy);\n            encode_name(ebml_w, f.ident);\n            encode_def_id(ebml_w, local_def(f.id));\n            ebml_w.end_tag();\n         }\n-        for m in ms {\n+        for ms.each {|m|\n            alt m.privacy {\n               priv { /* do nothing */ }\n               pub {\n@@ -637,7 +637,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n-        for m in methods {\n+        for methods.each {|m|\n             ebml_w.start_tag(tag_item_method);\n             ebml_w.writer.write(str::bytes(def_to_str(local_def(m.id))));\n             ebml_w.end_tag();\n@@ -657,7 +657,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml_w.end_tag();\n \n         let impl_path = path + [ast_map::path_name(item.ident)];\n-        for m in methods {\n+        for methods.each {|m|\n             *index += [{val: m.id, pos: ebml_w.writer.tell()}];\n             encode_info_for_method(ecx, ebml_w, impl_path,\n                    should_inline(m.attrs), item.id, m, tps + m.tps);\n@@ -672,7 +672,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         let mut i = 0u;\n-        for mty in *ty::iface_methods(tcx, local_def(item.id)) {\n+        for vec::each(*ty::iface_methods(tcx, local_def(item.id))) {|mty|\n             ebml_w.start_tag(tag_item_method);\n             encode_name(ebml_w, mty.ident);\n             encode_type_param_bounds(ebml_w, ecx, ms[i].tps);\n@@ -765,13 +765,13 @@ fn create_index<T: copy>(index: [entry<T>], hash_fn: fn@(T) -> uint) ->\n    [@[entry<T>]] {\n     let mut buckets: [@mut [entry<T>]] = [];\n     uint::range(0u, 256u) {|_i| buckets += [@mut []]; };\n-    for elt: entry<T> in index {\n+    for index.each {|elt|\n         let h = hash_fn(elt.val);\n         *buckets[h % 256u] += [elt];\n     }\n \n     let mut buckets_frozen = [];\n-    for bucket: @mut [entry<T>] in buckets {\n+    for buckets.each {|bucket|\n         buckets_frozen += [@*bucket];\n     }\n     ret buckets_frozen;\n@@ -783,10 +783,10 @@ fn encode_index<T>(ebml_w: ebml::writer, buckets: [@[entry<T>]],\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs: [uint] = [];\n     ebml_w.start_tag(tag_index_buckets);\n-    for bucket: @[entry<T>] in buckets {\n+    for buckets.each {|bucket|\n         bucket_locs += [ebml_w.writer.tell()];\n         ebml_w.start_tag(tag_index_buckets_bucket);\n-        for elt: entry<T> in *bucket {\n+        for vec::each(*bucket) {|elt|\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             writer.write_be_uint(elt.pos, 4u);\n             write_fn(writer, elt.val);\n@@ -796,7 +796,7 @@ fn encode_index<T>(ebml_w: ebml::writer, buckets: [@[entry<T>]],\n     }\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_index_table);\n-    for pos: uint in bucket_locs { writer.write_be_uint(pos, 4u); }\n+    for bucket_locs.each {|pos| writer.write_be_uint(pos, 4u); }\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n@@ -836,7 +836,7 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n         ebml_w.start_tag(tag_meta_item_name);\n         ebml_w.writer.write(str::bytes(name));\n         ebml_w.end_tag();\n-        for inner_item: @meta_item in items {\n+        for items.each {|inner_item|\n             encode_meta_item(ebml_w, *inner_item);\n         }\n         ebml_w.end_tag();\n@@ -846,7 +846,7 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n \n fn encode_attributes(ebml_w: ebml::writer, attrs: [attribute]) {\n     ebml_w.start_tag(tag_attributes);\n-    for attr: attribute in attrs {\n+    for attrs.each {|attr|\n         ebml_w.start_tag(tag_attribute);\n         encode_meta_item(ebml_w, attr.node.value);\n         ebml_w.end_tag();\n@@ -885,7 +885,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> [attribute] {\n \n     let mut attrs: [attribute] = [];\n     let mut found_link_attr = false;\n-    for attr: attribute in crate.node.attrs {\n+    for crate.node.attrs.each {|attr|\n         attrs +=\n             if attr::get_attr_name(attr) != \"link\" {\n                 [attr]\n@@ -923,7 +923,7 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n-        for n: numname in pairs {\n+        for pairs.each {|n|\n             assert (n.crate == expected_cnum);\n             expected_cnum += 1;\n         }\n@@ -940,7 +940,7 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n     // FIXME: This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     ebml_w.start_tag(tag_crate_deps);\n-    for cname: str in get_ordered_names(cstore) {\n+    for get_ordered_names(cstore).each {|cname|\n         ebml_w.start_tag(tag_crate_dep);\n         ebml_w.writer.write(str::bytes(cname));\n         ebml_w.end_tag();"}, {"sha": "7d8fd31d635bdbbf66be2856cdae7017153022a5", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -392,25 +392,20 @@ fn parse_def_id(buf: [u8]) -> ast::def_id {\n         #error(\"didn't find ':' when parsing def id\");\n         fail;\n     }\n-    let crate_part = vec::slice::<u8>(buf, 0u, colon_idx);\n-    let def_part = vec::slice::<u8>(buf, colon_idx + 1u, len);\n+    let crate_part = vec::slice(buf, 0u, colon_idx);\n+    let def_part = vec::slice(buf, colon_idx + 1u, len);\n \n-    let mut crate_part_vec = [];\n-    let mut def_part_vec = [];\n-    for b: u8 in crate_part { crate_part_vec += [b]; }\n-    for b: u8 in def_part { def_part_vec += [b]; }\n-\n-    let crate_num = alt uint::parse_buf(crate_part_vec, 10u) {\n+    let crate_num = alt uint::parse_buf(crate_part, 10u) {\n        some(cn) { cn as int }\n        none { fail (#fmt(\"internal error: parse_def_id: error parsing %? \\\n                          as crate\",\n-                         crate_part_vec)); }\n+                         crate_part)); }\n     };\n-    let def_num = alt uint::parse_buf(def_part_vec, 10u) {\n+    let def_num = alt uint::parse_buf(def_part, 10u) {\n        some(dn) { dn as int }\n        none { fail (#fmt(\"internal error: parse_def_id: error parsing %? \\\n                          as id\",\n-                         def_part_vec)); }\n+                         def_part)); }\n     };\n     ret {crate: crate_num, node: def_num};\n }"}, {"sha": "fb0a84b603fb399fc004321c2dd5b3daa480aef7", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -181,19 +181,19 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_str(\"t[\");\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n-        for t: ty::t in tys { enc_ty(w, cx, t); }\n+        for tys.each {|t| enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_iface(def, tys) {\n         w.write_str(\"x[\");\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n-        for t: ty::t in tys { enc_ty(w, cx, t); }\n+        for tys.each {|t| enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_tup(ts) {\n         w.write_str(\"T[\");\n-        for t in ts { enc_ty(w, cx, t); }\n+        for ts.each {|t| enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_box(mt) { w.write_char('@'); enc_mt(w, cx, mt); }\n@@ -207,7 +207,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_vec(mt) { w.write_char('I'); enc_mt(w, cx, mt); }\n       ty::ty_rec(fields) {\n         w.write_str(\"R[\");\n-        for field: ty::field in fields {\n+        for fields.each {|field|\n             w.write_str(field.ident);\n             w.write_char('=');\n             enc_mt(w, cx, field.mt);\n@@ -223,7 +223,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n         enc_ty(w, cx, ty);\n-        for t: ty::t in tps { enc_ty(w, cx, t); }\n+        for tps.each {|t| enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_var(id) {\n@@ -238,7 +238,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       }\n       ty::ty_self(tps) {\n         w.write_str(\"s[\");\n-        for t in tps { enc_ty(w, cx, t); }\n+        for tps.each {|t| enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_type { w.write_char('Y'); }\n@@ -248,7 +248,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_constr(ty, cs) {\n         w.write_str(\"A[\");\n         enc_ty(w, cx, ty);\n-        for tc: @ty::type_constr in cs { enc_ty_constr(w, cx, tc); }\n+        for cs.each {|tc| enc_ty_constr(w, cx, tc); }\n         w.write_char(']');\n       }\n       ty::ty_opaque_box { w.write_char('B'); }\n@@ -260,7 +260,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n           w.write_str(s);\n           #debug(\"~~~~ %s\", \"|\");\n           w.write_str(\"|\");\n-          for t: ty::t in tys { enc_ty(w, cx, t); }\n+          for tys.each {|t| enc_ty(w, cx, t); }\n           #debug(\"~~~~ %s\", \"]\");\n           w.write_char(']');\n       }\n@@ -288,13 +288,13 @@ fn enc_mode(w: io::writer, cx: @ctxt, m: mode) {\n \n fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n     w.write_char('[');\n-    for arg: ty::arg in ft.inputs {\n+    for ft.inputs.each {|arg|\n         enc_mode(w, cx, arg.mode);\n         enc_ty(w, cx, arg.ty);\n     }\n     w.write_char(']');\n     let mut colon = true;\n-    for c: @ty::constr in ft.constraints {\n+    for ft.constraints.each {|c|\n         if colon {\n             w.write_char(':');\n             colon = false;\n@@ -314,7 +314,7 @@ fn enc_constr(w: io::writer, cx: @ctxt, c: @ty::constr) {\n     w.write_str(cx.ds(c.node.id));\n     w.write_char('|');\n     let mut semi = false;\n-    for a: @constr_arg in c.node.args {\n+    for c.node.args.each {|a|\n         if semi { w.write_char(';'); } else { semi = true; }\n         alt a.node {\n           carg_base { w.write_char('*'); }\n@@ -331,7 +331,7 @@ fn enc_ty_constr(w: io::writer, cx: @ctxt, c: @ty::type_constr) {\n     w.write_str(cx.ds(c.node.id));\n     w.write_char('|');\n     let mut semi = false;\n-    for a: @ty::ty_constr_arg in c.node.args {\n+    for c.node.args.each {|a|\n         if semi { w.write_char(';'); } else { semi = true; }\n         alt a.node {\n           carg_base { w.write_char('*'); }\n@@ -343,7 +343,7 @@ fn enc_ty_constr(w: io::writer, cx: @ctxt, c: @ty::type_constr) {\n }\n \n fn enc_bounds(w: io::writer, cx: @ctxt, bs: @[ty::param_bound]) {\n-    for bound in *bs {\n+    for vec::each(*bs) {|bound|\n         alt bound {\n           ty::bound_send { w.write_char('S'); }\n           ty::bound_copy { w.write_char('C'); }"}, {"sha": "d1d0e522f61c19f17bdbb027c9bf51c1ab5102d2", "filename": "src/rustc/middle/alias.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -136,13 +136,13 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n \n fn visit_block(cx: @ctx, b: ast::blk, sc: scope, v: vt<scope>) {\n     let sc = sc;\n-    for stmt in b.node.stmts {\n+    for b.node.stmts.each {|stmt|\n         alt stmt.node {\n           ast::stmt_decl(@{node: ast::decl_item(it), _}, _) {\n             v.visit_item(it, sc, v);\n           }\n           ast::stmt_decl(@{node: ast::decl_local(locs), _}, _) {\n-            for loc in locs {\n+            for locs.each {|loc|\n                 alt loc.node.init {\n                   some(init) {\n                     if init.op == ast::init_move {\n@@ -245,11 +245,11 @@ fn check_call(cx: @ctx, sc: scope, f: @ast::expr, args: [@ast::expr],\n     };\n     if f_may_close {\n         let mut i = 0u;\n-        for b in bindings {\n+        for bindings.each {|b|\n             let mut unsfe = vec::len(b.unsafe_tys) > 0u;\n             alt b.root_var {\n               some(rid) {\n-                for o in sc.bs {\n+                for sc.bs.each {|o|\n                     if o.node_id == rid && vec::len(o.unsafe_tys) > 0u {\n                         unsfe = true; break;\n                     }\n@@ -265,8 +265,8 @@ fn check_call(cx: @ctx, sc: scope, f: @ast::expr, args: [@ast::expr],\n         }\n     }\n     let mut j = 0u;\n-    for b in bindings {\n-        for unsafe_ty in b.unsafe_tys {\n+    for bindings.each {|b|\n+        for b.unsafe_tys.each {|unsafe_ty|\n             vec::iteri(arg_ts) {|i, arg_t|\n                 let mut_alias =\n                     (ast::by_mutbl_ref == ty::arg_mode(cx.tcx, arg_t));\n@@ -288,13 +288,13 @@ fn check_call(cx: @ctx, sc: scope, f: @ast::expr, args: [@ast::expr],\n     }\n \n     // Ensure we're not passing a root by mut alias.\n-    for {node: node, arg: arg} in mut_roots {\n-        for b in bindings {\n-            if b.node_id != arg.id {\n+    for mut_roots.each {|mroot|\n+        for bindings.each {|b|\n+            if b.node_id != mroot.arg.id {\n                 alt b.root_var {\n                   some(root) {\n-                    if node == root && cant_copy(*cx, b) {\n-                        err(*cx, arg.span,\n+                    if mroot.node == root && cant_copy(*cx, b) {\n+                        err(*cx, mroot.arg.span,\n                             \"passing a mut reference to a \\\n                              variable that roots another reference\");\n                         break;\n@@ -308,14 +308,14 @@ fn check_call(cx: @ctx, sc: scope, f: @ast::expr, args: [@ast::expr],\n     // Check the bodies of block arguments against the current scope\n     if blocks.len() > 0u {\n         let inner_sc = {bs: bindings + sc.bs, invalid: sc.invalid};\n-        for blk in blocks {\n+        for blocks.each {|blk|\n             alt check blk.node {\n               ast::expr_fn_block(_, body) {\n                 v.visit_block(body, inner_sc, v);\n               }\n             }\n         }\n-        for binding in bindings {\n+        for bindings.each {|binding|\n             test_scope(*cx, sc, binding, none);\n         }\n     }\n@@ -327,7 +327,7 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n     let orig_invalid = *sc.invalid;\n     let mut all_invalid = orig_invalid;\n     let root = expr_root(cx, input, true);\n-    for a: ast::arm in arms {\n+    for arms.each {|a|\n         let mut new_bs = sc.bs;\n         let root_var = path_def_id(cx, root.ex);\n         let pat_id_map = pat_util::pat_id_map(cx.tcx.def_map, a.pats[0]);\n@@ -336,8 +336,8 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n             mut unsafe_tys: [unsafe_ty],\n             span: span};\n         let mut binding_info: [info] = [];\n-        for pat in a.pats {\n-            for proot in pattern_roots(cx.tcx, root.mutbl, pat) {\n+        for a.pats.each {|pat|\n+            for pattern_roots(cx.tcx, root.mutbl, pat).each {|proot|\n                 let canon_id = pat_id_map.get(proot.name);\n                 alt vec::find(binding_info, {|x| x.id == canon_id}) {\n                   some(s) { s.unsafe_tys += unsafe_set(proot.mutbl); }\n@@ -350,14 +350,14 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n                 }\n             }\n         }\n-        for info in binding_info {\n+        for binding_info.each {|info|\n             new_bs += [mk_binding(cx, info.id, info.span, root_var,\n                                   copy info.unsafe_tys)];\n-        }\n+        };\n         *sc.invalid = orig_invalid;\n         visit::visit_arm(a, {bs: new_bs with sc}, v);\n         all_invalid = join_invalid(all_invalid, *sc.invalid);\n-    }\n+    };\n     *sc.invalid = all_invalid;\n }\n \n@@ -378,7 +378,7 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n     }\n     let root_var = path_def_id(cx, root.ex);\n     let mut new_bs = sc.bs;\n-    for proot in pattern_roots(cx.tcx, cur_mutbl, local.node.pat) {\n+    for pattern_roots(cx.tcx, cur_mutbl, local.node.pat).each {|proot|\n         new_bs += [mk_binding(cx, proot.id, proot.span, root_var,\n                               unsafe_set(proot.mutbl))];\n     }\n@@ -392,10 +392,10 @@ fn check_var(cx: ctx, ex: @ast::expr, p: @ast::path, id: ast::node_id,\n     let my_defnum = ast_util::def_id_of_def(def).node;\n     let my_local_id = local_id_of_node(cx, my_defnum);\n     let var_t = ty::expr_ty(cx.tcx, ex);\n-    for b in sc.bs {\n+    for sc.bs.each {|b|\n         // excludes variables introduced since the alias was made\n         if my_local_id < b.local_id {\n-            for unsafe_ty in b.unsafe_tys {\n+            for b.unsafe_tys.each {|unsafe_ty|\n                 if ty_can_unsafely_include(cx, unsafe_ty, var_t, assign) {\n                     let inv = @{reason: val_taken, node_id: b.node_id,\n                                 sp: ex.span, path: p};\n@@ -413,7 +413,7 @@ fn check_lval(cx: @ctx, dest: @ast::expr, sc: scope, v: vt<scope>) {\n       ast::expr_path(p) {\n         let def = cx.tcx.def_map.get(dest.id);\n         let dnum = ast_util::def_id_of_def(def).node;\n-        for b in sc.bs {\n+        for sc.bs.each {|b|\n             if b.root_var == some(dnum) {\n                 let inv = @{reason: overwritten, node_id: b.node_id,\n                             sp: dest.span, path: p};\n@@ -454,7 +454,7 @@ fn test_scope(cx: ctx, sc: scope, b: binding, p: option<@ast::path>) {\n     let mut prob = find_invalid(b.node_id, *sc.invalid);\n     alt b.root_var {\n       some(dn) {\n-        for other in sc.bs {\n+        for sc.bs.each {|other|\n             if !is_none(prob) { break; }\n             if other.node_id == dn {\n                 prob = find_invalid(other.node_id, *sc.invalid);\n@@ -507,7 +507,7 @@ fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n         } { ret true; }\n         alt ty::get(haystack).struct {\n           ty::ty_enum(_, ts) {\n-            for t: ty::t in ts {\n+            for ts.each {|t|\n                 if helper(tcx, needle, t, mutbl) { ret true; }\n             }\n             ret false;\n@@ -516,15 +516,15 @@ fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n             ret helper(tcx, needle, mt.ty, get_mutbl(mutbl, mt));\n           }\n           ty::ty_rec(fields) {\n-            for f: ty::field in fields {\n+            for fields.each {|f|\n                 if helper(tcx, needle, f.mt.ty, get_mutbl(mutbl, f.mt)) {\n                     ret true;\n                 }\n             }\n             ret false;\n           }\n           ty::ty_tup(ts) {\n-            for t in ts { if helper(tcx, needle, t, mutbl) { ret true; } }\n+            for ts.each {|t| if helper(tcx, needle, t, mutbl) { ret true; } }\n             ret false;\n           }\n           ty::ty_fn({proto: ast::proto_bare, _}) { ret false; }\n@@ -571,12 +571,12 @@ fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n           ty::ty_uniq(mt) { 1u + score_ty(tcx, mt.ty) }\n           ty::ty_enum(_, ts) | ty::ty_tup(ts) {\n             let mut sum = 0u;\n-            for t in ts { sum += score_ty(tcx, t); }\n+            for ts.each {|t| sum += score_ty(tcx, t); }\n             sum\n           }\n           ty::ty_rec(fs) {\n             let mut sum = 0u;\n-            for f in fs { sum += score_ty(tcx, f.mt.ty); }\n+            for fs.each {|f| sum += score_ty(tcx, f.mt.ty); }\n             sum\n           }\n           _ {\n@@ -608,11 +608,11 @@ fn pattern_roots(tcx: ty::ctxt, mutbl: option<unsafe_ty>, pat: @ast::pat)\n           ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) |\n           ast::pat_ident(_, _) {}\n           ast::pat_enum(_, ps) | ast::pat_tup(ps) {\n-            for p in ps { walk(tcx, mutbl, p, set); }\n+            for ps.each {|p| walk(tcx, mutbl, p, set); }\n           }\n           ast::pat_rec(fs, _) {\n             let ty = ty::node_id_to_type(tcx, pat.id);\n-            for f in fs {\n+            for fs.each {|f|\n                 let m = ty::get_field(ty, f.ident).mt.mutbl != ast::m_imm,\n                     c = if m { some(contains(ty)) } else { mutbl };\n                 walk(tcx, c, f.pat, set);\n@@ -649,7 +649,7 @@ fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool)\n     -> {ex: @ast::expr, mutbl: option<unsafe_ty>} {\n     let base_root = mutbl::expr_root_(cx.tcx, none, ex, autoderef);\n     let mut unsafe_ty = none;\n-    for d in *base_root.ds {\n+    for vec::each(*base_root.ds) {|d|\n         if d.mutbl { unsafe_ty = some(contains(d.outer_t)); break; }\n     }\n     ret {ex: base_root.ex, mutbl: unsafe_ty};"}, {"sha": "46709abaa408a8f2d2725195611a6cde1d3b1d84", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -115,7 +115,7 @@ fn map_decoded_item(sess: session, map: map, path: path, ii: inlined_item) {\n \n fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n           sp: codemap::span, id: node_id, cx: ctx, v: vt) {\n-    for a in decl.inputs {\n+    for decl.inputs.each {|a|\n         cx.map.insert(a.id, node_arg(a, cx.local_id));\n         cx.local_id += 1u;\n     }\n@@ -162,7 +162,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     alt i.node {\n       item_impl(_, _, _, ms) {\n         let impl_did = ast_util::local_def(i.id);\n-        for m in ms {\n+        for ms.each {|m|\n             map_method(impl_did, extend(cx, i.ident), m, cx);\n         }\n       }\n@@ -171,7 +171,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         cx.map.insert(dtor_id, node_item(i, item_path));\n       }\n       item_enum(vs, _) {\n-        for v in vs {\n+        for vs.each {|v|\n             cx.map.insert(v.node.id, node_variant(\n                 v, i, extend(cx, i.ident)));\n         }\n@@ -181,15 +181,15 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n           either::left(msg) { cx.sess.span_fatal(i.span, msg); }\n           either::right(abi) { abi }\n         };\n-        for nitem in nm.items {\n+        for nm.items.each {|nitem|\n             cx.map.insert(nitem.id, node_native_item(nitem, abi, @cx.path));\n         }\n       }\n       item_class(_, items, ctor) {\n           cx.map.insert(ctor.node.id, node_ctor(i, item_path));\n           let d_id = ast_util::local_def(i.id);\n           let p = extend(cx, i.ident);\n-          for ci in items {\n+          for items.each {|ci|\n            // only need to handle methods\n            alt ci.node {\n              class_method(m) { map_method(d_id, p, m, cx); }\n@@ -212,7 +212,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n     alt vi.node {\n       view_item_export(vps) {\n-        for vp in vps {\n+        for vps.each {|vp|\n             let (id, name) = alt vp.node {\n               view_path_simple(nm, _, id) { (id, nm) }\n               view_path_glob(pth, id) | view_path_list(pth, _, id) {"}, {"sha": "d79568a5c5ddba93b2bd949d2a011851d9d8cf09", "filename": "src/rustc/middle/block_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fblock_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fblock_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fblock_use.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -27,7 +27,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         cx.allow_block = true;\n         v.visit_expr(f, cx, v);\n         let mut i = 0u;\n-        for arg_t in ty::ty_fn_args(ty::expr_ty(cx.tcx, f)) {\n+        for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).each {|arg_t|\n             cx.allow_block = (ty::arg_mode(cx.tcx, arg_t) == by_ref);\n             v.visit_expr(args[i], cx, v);\n             i += 1u;"}, {"sha": "6d5491a09eeb99cc7a0a8cafec9df6a6e529127d", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -37,13 +37,13 @@ fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n fn check_arms(tcx: ty::ctxt, arms: [arm]) {\n     let mut i = 0;\n     /* Check for unreachable patterns */\n-    for arm: arm in arms {\n-        for arm_pat: @pat in arm.pats {\n+    for arms.each {|arm|\n+        for arm.pats.each {|arm_pat|\n             let mut reachable = true;\n             let mut j = 0;\n             while j < i {\n                 if option::is_none(arms[j].guard) {\n-                    for prev_pat: @pat in arms[j].pats {\n+                    for vec::each(arms[j].pats) {|prev_pat|\n                         if pattern_supersedes(tcx, prev_pat, arm_pat) {\n                             reachable = false;\n                         }\n@@ -72,7 +72,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]) {\n         ret;\n     }\n     // If there a non-refutable pattern in the set, we're okay.\n-    for pat in pats { if !is_refutable(tcx, pat) { ret; } }\n+    for pats.each {|pat| if !is_refutable(tcx, pat) { ret; } }\n \n     alt ty::get(ty::node_id_to_type(tcx, pats[0].id)).struct {\n       ty::ty_enum(id, _) {\n@@ -90,7 +90,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]) {\n       }\n       ty::ty_tup(ts) {\n         let cols = vec::to_mut(vec::from_elem(ts.len(), []));\n-        for p in pats {\n+        for pats.each {|p|\n             alt raw_pat(p).node {\n               pat_tup(sub) {\n                 vec::iteri(sub) {|i, sp| cols[i] += [sp];}\n@@ -103,7 +103,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]) {\n       ty::ty_rec(fs) {\n         let cols = vec::from_elem(fs.len(), {mut wild: false,\n                                             mut pats: []});\n-        for p in pats {\n+        for pats.each {|p|\n             alt raw_pat(p).node {\n               pat_rec(sub, _) {\n                 vec::iteri(fs) {|i, field|\n@@ -122,7 +122,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]) {\n       }\n       ty::ty_bool {\n         let mut saw_true = false, saw_false = false;\n-        for p in pats {\n+        for pats.each {|p|\n             alt raw_pat(p).node {\n               pat_lit(@{node: expr_lit(@{node: lit_bool(b), _}), _}) {\n                 if b { saw_true = true; }\n@@ -160,7 +160,7 @@ fn check_exhaustive_enum(tcx: ty::ctxt, enum_id: def_id, sp: span,\n          cols: vec::to_mut(vec::from_elem(v.args.len(), []))}\n     });\n \n-    for pat in pats {\n+    for pats.each {|pat|\n         let pat = raw_pat(pat);\n         alt tcx.def_map.get(pat.id) {\n           def_variant(_, id) {\n@@ -193,7 +193,7 @@ fn check_exhaustive_enum(tcx: ty::ctxt, enum_id: def_id, sp: span,\n fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n     fn patterns_supersede(tcx: ty::ctxt, as: [@pat], bs: [@pat]) -> bool {\n         let mut i = 0;\n-        for a: @pat in as {\n+        for as.each {|a|\n             if !pattern_supersedes(tcx, a, bs[i]) { ret false; }\n             i += 1;\n         }\n@@ -202,9 +202,9 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n     fn field_patterns_supersede(tcx: ty::ctxt, fas: [field_pat],\n                                 fbs: [field_pat]) -> bool {\n         let wild = @{id: 0, node: pat_wild, span: dummy_sp()};\n-        for fa: field_pat in fas {\n+        for fas.each {|fa|\n             let mut pb = wild;\n-            for fb: field_pat in fbs {\n+            for fbs.each {|fb|\n                 if fa.ident == fb.ident { pb = fb.pat; }\n             }\n             if !pattern_supersedes(tcx, fa.pat, pb) { ret false; }\n@@ -301,17 +301,17 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n       pat_wild | pat_ident(_, none) { false }\n       pat_lit(_) | pat_range(_, _) { true }\n       pat_rec(fields, _) {\n-        for it: field_pat in fields {\n+        for fields.each {|it|\n             if is_refutable(tcx, it.pat) { ret true; }\n         }\n         false\n       }\n       pat_tup(elts) {\n-        for elt in elts { if is_refutable(tcx, elt) { ret true; } }\n+        for elts.each {|elt| if is_refutable(tcx, elt) { ret true; } }\n         false\n       }\n       pat_enum(_, args) {\n-        for p: @pat in args { if is_refutable(tcx, p) { ret true; } }\n+        for args.each {|p| if is_refutable(tcx, p) { ret true; } }\n         false\n       }\n     }"}, {"sha": "509839beb79719569afe732c408c7d9980f5a53b", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -23,7 +23,7 @@ fn check_item(sess: session, ast_map: ast_map::map, def_map: resolve::def_map,\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n       item_enum(vs, _) {\n-        for var in vs {\n+        for vs.each {|var|\n             option::with_option_do(var.node.disr_expr) {|ex|\n                 v.visit_expr(ex, true, v);\n             }"}, {"sha": "6d710db5f2a63e0575e5659cb65d8b40defcf2ba", "filename": "src/rustc/middle/fn_usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ffn_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ffn_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffn_usage.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -59,7 +59,7 @@ fn fn_usage_expr(expr: @ast::expr,\n \n         let args_ctx = {unsafe_fn_legal: false,\n                         generic_bare_fn_legal: false with ctx};\n-        for arg in args {\n+        for args.each {|arg|\n             visit::visit_expr_opt(arg, args_ctx, v);\n         }\n       }"}, {"sha": "42369d9f28ec8dc0933c5d36fec0ce4e661549ee", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -622,7 +622,7 @@ impl unify_methods for infer_ctxt {\n         let actual_arg_len = vec::len(actual_constr.node.args);\n         if expected_arg_len != actual_arg_len { ret err_res; }\n         let mut i = 0u;\n-        for a in expected.node.args {\n+        for expected.node.args.each {|a|\n             let actual = actual_constr.node.args[i];\n             alt a.node {\n               ast::carg_base {"}, {"sha": "836e1644da93a74e7008a20831b6963796cb21bb", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -85,8 +85,8 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n     // the common flow point for all functions that appear in the AST.\n \n     with_appropriate_checker(cx, fn_id) { |checker|\n-        for @{def, span} in *freevars::get_freevars(cx.tcx, fn_id) {\n-            let id = ast_util::def_id_of_def(def).node;\n+        for vec::each(*freevars::get_freevars(cx.tcx, fn_id)) {|fv|\n+            let id = ast_util::def_id_of_def(fv.def).node;\n             if checker == check_copy {\n                 let last_uses = alt check cx.last_uses.find(fn_id) {\n                   some(last_use::closes_over(vars)) { vars }\n@@ -96,7 +96,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n                     vec::position_elem(last_uses, id)) { cont; }\n             }\n             let ty = ty::node_id_to_type(cx.tcx, id);\n-            checker(cx, ty, span);\n+            checker(cx, ty, fv.span);\n         }\n     }\n \n@@ -146,7 +146,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       // Vector add copies.\n       expr_binary(add, ls, rs) { maybe_copy(cx, ls); maybe_copy(cx, rs); }\n       expr_rec(fields, def) {\n-        for field in fields { maybe_copy(cx, field.node.expr); }\n+        for fields.each {|field| maybe_copy(cx, field.node.expr); }\n         alt def {\n           some(ex) {\n             // All noncopyable fields must be overridden\n@@ -155,7 +155,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n               ty::ty_rec(f) { f }\n               _ { cx.tcx.sess.span_bug(ex.span, \"bad expr type in record\"); }\n             };\n-            for tf in ty_fields {\n+            for ty_fields.each {|tf|\n                 if !vec::any(fields, {|f| f.node.ident == tf.ident}) &&\n                     !ty::kind_can_be_copied(ty::type_kind(cx.tcx, tf.mt.ty)) {\n                     cx.tcx.sess.span_err(ex.span,\n@@ -167,14 +167,14 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         }\n       }\n       expr_tup(exprs) | expr_vec(exprs, _) {\n-        for expr in exprs { maybe_copy(cx, expr); }\n+        for exprs.each {|expr| maybe_copy(cx, expr); }\n       }\n       expr_bind(_, args) {\n-        for a in args { alt a { some(ex) { maybe_copy(cx, ex); } _ {} } }\n+        for args.each {|a| alt a { some(ex) { maybe_copy(cx, ex); } _ {} } }\n       }\n       expr_call(f, args, _) {\n         let mut i = 0u;\n-        for arg_t in ty::ty_fn_args(ty::expr_ty(cx.tcx, f)) {\n+        for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).each {|arg_t|\n             alt ty::arg_mode(cx.tcx, arg_t) {\n               by_copy { maybe_copy(cx, args[i]); }\n               by_ref | by_val | by_mutbl_ref | by_move { }\n@@ -236,7 +236,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n     alt stmt.node {\n       stmt_decl(@{node: decl_local(locals), _}, _) {\n-        for local in locals {\n+        for locals.each {|local|\n             alt local.node.init {\n               some({op: init_assign, expr}) { maybe_copy(cx, expr); }\n               _ {}"}, {"sha": "9089fcac7d6b6411276704bfd9e104febd46e568", "filename": "src/rustc/middle/last_use.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flast_use.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -114,7 +114,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         v.visit_expr(input, cx, v);\n         let before = cx.current;\n         let mut sets = [];\n-        for arm in arms {\n+        for arms.each {|arm|\n             cx.current = before;\n             v.visit_arm(arm, cx, v);\n             sets += [cx.current];\n@@ -185,7 +185,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n               }\n             }\n         }\n-        for f in fns { v.visit_expr(f, cx, v); }\n+        for fns.each {|f| v.visit_expr(f, cx, v); }\n         vec::iter2(args, arg_ts) {|arg, arg_t|\n             alt arg.node {\n               expr_path(_) {\n@@ -213,7 +213,7 @@ fn visit_stmt(s: @stmt, cx: ctx, v: visit::vt<ctx>) {\n       stmt_decl(@{node: decl_local(ls), _}, _) {\n         shadow_in_current(cx, {|id|\n             let mut rslt = false;\n-            for local in ls {\n+            for ls.each {|local|\n                 let mut found = false;\n                 pat_util::pat_bindings(cx.tcx.def_map, local.node.pat,\n                                        {|pid, _a, _b|\n@@ -246,7 +246,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n       proto_box | proto_uniq | proto_bare {\n         alt cx.tcx.freevars.find(id) {\n           some(vars) {\n-            for v in *vars {\n+            for vec::each(*vars) {|v|\n                 option::with_option_do(def_is_owned_local(cx, v.def)) {|nid|\n                     clear_in_current(cx, nid, false);\n                     cx.current += [{def: nid,\n@@ -304,34 +304,34 @@ fn add_block_exit(cx: ctx, tp: block_type) -> bool {\n fn join_branches(branches: [set]) -> set {\n     let mut found: set = [], i = 0u;\n     let l = vec::len(branches);\n-    for set in branches {\n+    for branches.each {|set|\n         i += 1u;\n-        for {def, uses} in set {\n-            if !vec::any(found, {|v| v.def == def}) {\n-                let mut j = i, nne = uses;\n+        for set.each {|elt|\n+            if !vec::any(found, {|v| v.def == elt.def}) {\n+                let mut j = i, nne = elt.uses;\n                 while j < l {\n-                    for {def: d2, uses} in branches[j] {\n-                        if d2 == def {\n-                            list::iter(uses) {|e|\n+                    for vec::each(branches[j]) {|elt2|\n+                        if elt2.def == elt.def {\n+                            list::iter(elt2.uses) {|e|\n                                 if !list::has(nne, e) { nne = cons(e, @nne); }\n                             }\n                         }\n                     }\n                     j += 1u;\n                 }\n-                found += [{def: def, uses: nne}];\n+                found += [{def: elt.def, uses: nne}];\n             }\n         }\n     }\n     ret found;\n }\n \n fn leave_fn(cx: ctx) {\n-    for {def, uses} in cx.current {\n-        list::iter(uses) {|use|\n+    for cx.current.each {|elt|\n+        list::iter(elt.uses) {|use|\n             let key = alt use {\n               var_use(pth_id) { path(pth_id) }\n-              close_over(fn_id) { close(fn_id, def) }\n+              close_over(fn_id) { close(fn_id, elt.def) }\n             };\n             if !cx.last_uses.contains_key(key) {\n                 cx.last_uses.insert(key, true);\n@@ -343,16 +343,16 @@ fn leave_fn(cx: ctx) {\n fn shadow_in_current(cx: ctx, p: fn(node_id) -> bool) {\n     let mut out = [];\n     cx.current <-> out;\n-    for e in out { if !p(e.def) { cx.current += [e]; } }\n+    for out.each {|e| if !p(e.def) { cx.current += [e]; } }\n }\n \n fn clear_in_current(cx: ctx, my_def: node_id, to: bool) {\n-    for {def, uses} in cx.current {\n-        if def == my_def {\n-            list::iter(uses) {|use|\n+    for cx.current.each {|elt|\n+        if elt.def == my_def {\n+            list::iter(elt.uses) {|use|\n                 let key = alt use {\n                   var_use(pth_id) { path(pth_id) }\n-                  close_over(fn_id) { close(fn_id, def) }\n+                  close_over(fn_id) { close(fn_id, elt.def) }\n                 };\n                 if !to || !cx.last_uses.contains_key(key) {\n                     cx.last_uses.insert(key, to);"}, {"sha": "ea244ef77569912463aaf99d56c92bf629fadcc6", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -60,7 +60,8 @@ fn merge_opts(attrs: [ast::attribute], cmd_opts: [(option, bool)]) ->\n     }\n \n     fn contains(xs: [(option, bool)], x: option) -> bool {\n-        for (o, _) in xs {\n+        for xs.each {|c|\n+            let (o, _) = c;\n             if o == x { ret true; }\n         }\n         ret false;\n@@ -85,7 +86,8 @@ fn merge_opts(attrs: [ast::attribute], cmd_opts: [(option, bool)]) ->\n         }\n     };\n \n-    for (o, v) in default() {\n+    for default().each {|c|\n+        let (o, v) = c;\n         if !contains(result, o) {\n             result += [(o, v)];\n         }\n@@ -97,7 +99,7 @@ fn merge_opts(attrs: [ast::attribute], cmd_opts: [(option, bool)]) ->\n fn check_ctypes(tcx: ty::ctxt, crate: @ast::crate) {\n     fn check_native_fn(tcx: ty::ctxt, decl: ast::fn_decl) {\n         let tys = vec::map(decl.inputs) {|a| a.ty };\n-        for ty in (tys + [decl.output]) {\n+        for vec::each(tys + [decl.output]) {|ty|\n             alt ty.node {\n               ast::ty_path(_, id) {\n                 alt tcx.def_map.get(id) {\n@@ -125,7 +127,7 @@ fn check_ctypes(tcx: ty::ctxt, crate: @ast::crate) {\n         alt it.node {\n           ast::item_native_mod(nmod) if attr::native_abi(it.attrs) !=\n               either::right(ast::native_abi_rust_intrinsic) {\n-            for ni in nmod.items {\n+            for nmod.items.each {|ni|\n                 alt ni.node {\n                   ast::native_item_fn(decl, tps) {\n                     check_native_fn(tcx, decl);\n@@ -148,7 +150,8 @@ fn check_ctypes(tcx: ty::ctxt, crate: @ast::crate) {\n fn check_crate(tcx: ty::ctxt, crate: @ast::crate,\n                opts: [(option, bool)], time: bool) {\n     let lint_opts = lint::merge_opts(crate.node.attrs, opts);\n-    for (lopt, switch) in lint_opts {\n+    for lint_opts.each {|opt|\n+        let (lopt, switch) = opt;\n         if switch == true {\n             lopt.run(tcx, crate, time);\n         }"}, {"sha": "633960f935156f03372550183f070712fc4e7243", "filename": "src/rustc/middle/mutbl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fmutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fmutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmutbl.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -56,7 +56,7 @@ fn expr_root_(tcx: ty::ctxt, ctor_self: option<node_id>,\n             let mut is_mutbl = false;\n             alt ty::get(auto_unbox.t).struct {\n               ty::ty_rec(fields) {\n-                for fld: ty::field in fields {\n+                for fields.each {|fld|\n                     if str::eq(ident, fld.ident) {\n                         is_mutbl = fld.mt.mutbl == m_mutbl;\n                         break;\n@@ -74,7 +74,7 @@ fn expr_root_(tcx: ty::ctxt, ctor_self: option<node_id>,\n                           }\n                           none { false }\n                   };\n-                  for fld: ty::field_ty in ty::lookup_class_fields(tcx, did) {\n+                  for ty::lookup_class_fields(tcx, did).each {|fld|\n                     if str::eq(ident, fld.ident) {\n                         is_mutbl = fld.mutability == class_mutable\n                             || in_self; // all fields can be mutated\n@@ -169,7 +169,7 @@ fn visit_decl(d: @decl, &&cx: @ctx, v: visit::vt<@ctx>) {\n     visit::visit_decl(d, cx, v);\n     alt d.node {\n       decl_local(locs) {\n-        for loc in locs {\n+        for locs.each {|loc|\n             alt loc.node.init {\n               some(init) {\n                 if init.op == init_move { check_move_rhs(cx, init.expr); }\n@@ -198,7 +198,7 @@ fn visit_expr(ex: @expr, &&cx: @ctx, v: visit::vt<@ctx>) {\n         check_lval(cx, dest, msg_assign);\n       }\n       expr_fn(_, _, _, cap) {\n-        for moved in cap.moves {\n+        for cap.moves.each {|moved|\n             let def = cx.tcx.def_map.get(moved.id);\n             alt is_illegal_to_modify_def(cx, def, msg_move_out) {\n               some(name) { mk_err(cx, moved.span, msg_move_out, moved.name); }\n@@ -281,7 +281,7 @@ fn check_move_rhs(cx: @ctx, src: @expr) {\n fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n     let arg_ts = ty::ty_fn_args(ty::expr_ty(cx.tcx, f));\n     let mut i = 0u;\n-    for arg_t: ty::arg in arg_ts {\n+    for arg_ts.each {|arg_t|\n         alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n           by_mutbl_ref { check_lval(cx, args[i], msg_mutbl_ref); }\n           by_move { check_lval(cx, args[i], msg_move_out); }\n@@ -294,7 +294,7 @@ fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n fn check_bind(cx: @ctx, f: @expr, args: [option<@expr>]) {\n     let arg_ts = ty::ty_fn_args(ty::expr_ty(cx.tcx, f));\n     let mut i = 0u;\n-    for arg in args {\n+    for args.each {|arg|\n         alt arg {\n           some(expr) {\n             let o_msg = alt ty::resolved_mode(cx.tcx, arg_ts[i].mode) {"}, {"sha": "ebcbbb2359b66c370cb66b66de74ec0de053174c", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -55,8 +55,8 @@ fn walk_pat(pat: @pat, it: fn(@pat)) {\n     it(pat);\n     alt pat.node {\n       pat_ident(pth, some(p)) { walk_pat(p, it); }\n-      pat_rec(fields, _) { for f in fields { walk_pat(f.pat, it); } }\n-      pat_enum(_, s) | pat_tup(s) { for p in s { walk_pat(p, it); } }\n+      pat_rec(fields, _) { for fields.each {|f| walk_pat(f.pat, it); } }\n+      pat_enum(_, s) | pat_tup(s) { for s.each {|p| walk_pat(p, it); } }\n       pat_box(s) | pat_uniq(s) { walk_pat(s, it); }\n       pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, none) {}\n     }"}, {"sha": "c66f09f8836065b1dae1859bd5bd8216a93bbd5c", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -440,7 +440,7 @@ fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n     record_parent(cx, blk.node.id);\n \n     // Resolve queued locals to this block.\n-    for local_id in cx.queued_locals {\n+    for cx.queued_locals.each {|local_id|\n         cx.region_map.local_blocks.insert(local_id, blk.node.id);\n     }\n "}, {"sha": "fdcf6e44dfb0aee477e33aaa33f7e2c0b2631f1a", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -187,7 +187,7 @@ fn create_env(sess: session, amap: ast_map::map) -> @env {\n fn iter_export_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n     alt vi.node {\n       ast::view_item_export(vps) {\n-        for vp in vps {\n+        for vps.each {|vp|\n             f(vp);\n         }\n       }\n@@ -198,9 +198,7 @@ fn iter_export_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n fn iter_import_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n     alt vi.node {\n       ast::view_item_import(vps) {\n-        for vp in vps {\n-            f(vp);\n-        }\n+        for vps.each {|vp| f(vp);}\n       }\n       _ {}\n     }\n@@ -237,7 +235,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n                 e.imports.insert(id, is_glob(path, sc, vp.span));\n               }\n               ast::view_path_list(mod_path, idents, _) {\n-                for ident in idents {\n+                for idents.each {|ident|\n                     let t = todo(ident.node.name,\n                                  @(*mod_path + [ident.node.name]),\n                                  ident.span, sc);\n@@ -438,9 +436,9 @@ fn resolve_names(e: @env, c: @ast::crate) {\n     fn walk_tps(e: @env, tps: [ast::ty_param], sc: scopes, v: vt<scopes>) {\n         let outer_current_tp = e.current_tp;\n         let mut current = 0u;\n-        for tp in tps {\n+        for tps.each {|tp|\n             e.current_tp = some(current);\n-            for bound in *tp.bounds {\n+            for vec::each(*tp.bounds) {|bound|\n                 alt bound {\n                   bound_iface(t) { v.visit_ty(t, sc, v); }\n                   _ {}\n@@ -504,7 +502,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n         visit::visit_ty_params(tps, sc, v);\n         alt ifce { some(ty) { v.visit_ty(ty, sc, v); } _ {} }\n         v.visit_ty(sty, sc, v);\n-        for m in methods {\n+        for methods.each {|m|\n             v.visit_ty_params(m.tps, sc, v);\n             let msc = cons(scope_method(m.self_id, tps + m.tps), @sc);\n             v.visit_fn(visit::fk_method(m.ident, [], m),\n@@ -513,9 +511,9 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n       }\n       ast::item_iface(tps, methods) {\n         visit::visit_ty_params(tps, sc, v);\n-        for m in methods {\n+        for methods.each {|m|\n             let msc = cons(scope_method(i.id, tps + m.tps), @sc);\n-            for a in m.decl.inputs { v.visit_ty(a.ty, msc, v); }\n+            for m.decl.inputs.each {|a| v.visit_ty(a.ty, msc, v); }\n             v.visit_ty(m.decl.output, msc, v);\n         }\n       }\n@@ -530,7 +528,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n                             ctor.node.body, ctor.span, ctor.node.id,\n                             ctor_scope, v);\n         /* visit the items */\n-        for cm in members {\n+        for members.each {|cm|\n             alt cm.node {\n               class_method(m) {\n                   let msc = cons(scope_method(m.self_id, tps + m.tps),\n@@ -571,7 +569,7 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n \n     // here's where we need to set up the mapping\n     // for f's constrs in the table.\n-    for c: @ast::constr in decl.constraints { resolve_constr(e, c, sc, v); }\n+    for decl.constraints.each {|c| resolve_constr(e, c, sc, v); }\n     let scope = alt fk {\n       visit::fk_item_fn(_, tps) | visit::fk_res(_, tps) |\n       visit::fk_method(_, tps, _) | visit::fk_ctor(_, tps)\n@@ -586,8 +584,8 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n fn visit_block_with_scope(b: ast::blk, sc: scopes, v: vt<scopes>) {\n     let pos = @mut 0u, loc = @mut 0u;\n     let block_sc = cons(scope_block(b, pos, loc), @sc);\n-    for vi in b.node.view_items { v.visit_view_item(vi, block_sc, v); }\n-    for stmt in b.node.stmts {\n+    for b.node.view_items.each {|vi| v.visit_view_item(vi, block_sc, v); }\n+    for b.node.stmts.each {|stmt|\n         v.visit_stmt(stmt, block_sc, v);;\n         *pos += 1u;;\n         *loc = 0u;\n@@ -602,14 +600,14 @@ fn visit_decl_with_scope(d: @decl, sc: scopes, v: vt<scopes>) {\n     };\n     alt d.node {\n       decl_local(locs) {\n-        for loc in locs { v.visit_local(loc, sc, v);; *loc_pos += 1u; }\n+        for locs.each {|loc| v.visit_local(loc, sc, v);; *loc_pos += 1u; }\n       }\n       decl_item(it) { v.visit_item(it, sc, v); }\n     }\n }\n \n fn visit_arm_with_scope(a: ast::arm, sc: scopes, v: vt<scopes>) {\n-    for p: @pat in a.pats { v.visit_pat(p, sc, v); }\n+    for a.pats.each {|p| v.visit_pat(p, sc, v); }\n     let sc_inner = cons(scope_arm(a), @sc);\n     visit::visit_expr_opt(a.guard, sc_inner, v);\n     v.visit_block(a.body, sc_inner, v);\n@@ -717,7 +715,7 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n     fn find_imports_after(e: env, id: node_id, sc: scopes) -> [node_id] {\n         fn lst(my_id: node_id, vis: [@view_item]) -> [node_id] {\n             let mut imports = [], found = false;\n-            for vi in vis {\n+            for vis.each {|vi|\n                 iter_effective_import_paths(*vi) {|vp|\n                     alt vp.node {\n                       view_path_simple(_, _, id)\n@@ -726,7 +724,7 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n                         if found { imports += [id]; }\n                       }\n                       view_path_list(_, ids, _) {\n-                        for id in ids {\n+                        for ids.each {|id|\n                             if id.node.id == my_id { found = true; }\n                             if found { imports += [id.node.id]; }\n                         }\n@@ -844,7 +842,7 @@ fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n       in_scope(sc) {\n         alt find_fn_or_mod_scope(sc) {\n           some(err_scope) {\n-            for rs: {ident: str, sc: scope} in e.reported {\n+            for e.reported.each {|rs|\n                 if str::eq(rs.ident, name) && err_scope == rs.sc { ret; }\n             }\n             e.reported += [{ident: name, sc: err_scope}];\n@@ -1115,7 +1113,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace,\n fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n     -> option<def> {\n     let mut n = 0u;\n-    for tp: ast::ty_param in ty_params {\n+    for ty_params.each {|tp|\n         if str::eq(tp.ident, name) && alt e.current_tp {\n             some(cur) { n < cur } none { true }\n         } { ret some(ast::def_ty_param(local_def(tp.id), n)); }\n@@ -1139,7 +1137,7 @@ fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n                 ns: namespace) -> option<def> {\n     alt ns {\n       ns_val {\n-        for a: ast::arg in decl.inputs {\n+        for decl.inputs.each {|a|\n             if str::eq(a.ident, name) {\n                 ret some(ast::def_arg(a.id, a.mode));\n             }\n@@ -1189,7 +1187,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                     } else {\n                         alt ns {\n                            ns_val {\n-                               for v: ast::variant in variants {\n+                               for variants.each {|v|\n                                   if str::eq(v.node.name, name) {\n                                      let i = v.node.id;\n                                      ret some(ast::def_variant\n@@ -1216,8 +1214,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n           _ { }\n         }\n     }\n-    for vi in b.view_items {\n-\n+    for b.view_items.each {|vi|\n         let mut is_import = false;\n         alt vi.node {\n           ast::view_item_import(_) { is_import = true; }\n@@ -1227,7 +1224,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n         alt vi.node {\n \n           ast::view_item_import(vps) | ast::view_item_export(vps) {\n-            for vp in vps {\n+            for vps.each {|vp|\n                 alt vp.node {\n                   ast::view_path_simple(ident, _, id) {\n                     if is_import && name == ident {\n@@ -1236,7 +1233,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                   }\n \n                   ast::view_path_list(path, idents, _) {\n-                    for ident in idents {\n+                    for idents.each {|ident|\n                         if name == ident.node.name {\n                             ret lookup_import(e, ident.node.id, ns);\n                         }\n@@ -1467,7 +1464,7 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n     else if vec::len(matches) == 1u {\n         ret some(matches[0].def);\n     } else {\n-        for match: glob_imp_def in matches {\n+        for matches.each {|match|\n             let sp = match.path.span;\n             e.sess.span_note(sp, #fmt[\"'%s' is imported here\", id]);\n         }\n@@ -1546,7 +1543,7 @@ fn add_to_index(index: hashmap<ident, list<mod_index_entry>>, id: ident,\n \n fn index_view_items(view_items: [@ast::view_item],\n                     index: hashmap<ident, list<mod_index_entry>>) {\n-    for vi in view_items {\n+    for view_items.each {|vi|\n         alt vi.node {\n           ast::view_item_use(ident, _, id) {\n            add_to_index(index, ident, mie_view_item(ident, id, vi.span));\n@@ -1560,7 +1557,7 @@ fn index_view_items(view_items: [@ast::view_item],\n                 add_to_index(index, ident, mie_import_ident(id, vp.span));\n               }\n               ast::view_path_list(_, idents, _) {\n-                for ident in idents {\n+                for idents.each {|ident|\n                     add_to_index(index, ident.node.name,\n                                  mie_import_ident(ident.node.id,\n                                                   ident.span));\n@@ -1579,7 +1576,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n \n     index_view_items(md.view_items, index);\n \n-    for it: @ast::item in md.items {\n+    for md.items.each {|it|\n         alt it.node {\n           ast::item_const(_, _) | ast::item_fn(_, _, _) | ast::item_mod(_) |\n           ast::item_native_mod(_) | ast::item_ty(_, _) |\n@@ -1590,7 +1587,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n           ast::item_enum(variants, _) {\n             add_to_index(index, it.ident, mie_item(it));\n             let mut variant_idx: uint = 0u;\n-            for v: ast::variant in variants {\n+            for variants.each {|v|\n                 add_to_index(index, v.node.name,\n                              mie_enum_variant(variant_idx, variants,\n                                              it.id, it.span));\n@@ -1619,7 +1616,7 @@ fn index_nmod(md: ast::native_mod) -> mod_index {\n \n     index_view_items(md.view_items, index);\n \n-    for it: @ast::native_item in md.items {\n+    for md.items.each {|it|\n         add_to_index(index, it.ident, mie_native_item(it));\n     }\n     ret index;\n@@ -1649,11 +1646,12 @@ fn ns_ok(wanted:namespace, actual:namespace) -> bool {\n \n fn lookup_external(e: env, cnum: int, ids: [ident], ns: namespace) ->\n    option<def> {\n-    for d: def in csearch::lookup_defs(e.sess.cstore, cnum, ids) {\n+    let mut result = none;\n+    for csearch::lookup_defs(e.sess.cstore, cnum, ids).each {|d|\n         e.ext_map.insert(def_id_of_def(d), ids);\n-        if ns_ok(ns, ns_for_def(d)) { ret some(d); }\n+        if ns_ok(ns, ns_for_def(d)) { result = some(d); }\n     }\n-    ret none;\n+    ret result;\n }\n \n \n@@ -1720,7 +1718,7 @@ fn mie_span(mie: mod_index_entry) -> span {\n fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n     fn typaram_names(tps: [ast::ty_param]) -> [ident] {\n         let mut x: [ast::ident] = [];\n-        for tp: ast::ty_param in tps { x += [tp.ident]; }\n+        for tps.each {|tp| x += [tp.ident]; }\n         ret x;\n     }\n     visit::visit_item(i, x, v);\n@@ -1769,7 +1767,7 @@ fn check_arm(e: @env, a: ast::arm, &&x: (), v: vt<()>) {\n             e.sess.span_err(a.pats[i].span,\n                             \"inconsistent number of bindings\");\n         } else {\n-            for name: ident in ch.seen {\n+            for ch.seen.each {|name|\n                 if is_none(vec::find(seen0, bind str::eq(name, _))) {\n                     // Fight the alias checker\n                     let name_ = name;\n@@ -1787,13 +1785,13 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n     let values = checker(*e, \"value\");\n     let types = checker(*e, \"type\");\n     let mods = checker(*e, \"module\");\n-    for st: @ast::stmt in b.node.stmts {\n+    for b.node.stmts.each {|st|\n         alt st.node {\n           ast::stmt_decl(d, _) {\n             alt d.node {\n               ast::decl_local(locs) {\n                 let local_values = checker(*e, \"value\");\n-                for loc in locs {\n+                for locs.each {|loc|\n                      pat_util::pat_bindings(e.def_map, loc.node.pat)\n                          {|_i, p_sp, n|\n                          let ident = path_to_ident(n);\n@@ -1806,7 +1804,7 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n                 alt it.node {\n                   ast::item_enum(variants, _) {\n                     add_name(types, it.span, it.ident);\n-                    for v: ast::variant in variants {\n+                    for variants.each {|v|\n                         add_name(values, v.span, v.node.name);\n                     }\n                   }\n@@ -1868,7 +1866,7 @@ fn checker(e: env, kind: str) -> checker {\n }\n \n fn check_name(ch: checker, sp: span, name: ident) {\n-    for s: ident in ch.seen {\n+    for ch.seen.each {|s|\n         if str::eq(s, name) {\n             ch.sess.span_fatal(sp, \"duplicate \" + ch.kind + \" name: \" + name);\n         }\n@@ -1882,7 +1880,7 @@ fn add_name(ch: checker, sp: span, name: ident) {\n fn ensure_unique<T>(e: env, sp: span, elts: [T], id: fn(T) -> ident,\n                     kind: str) {\n     let ch = checker(e, kind);\n-    for elt: T in elts { add_name(ch, sp, id(elt)); }\n+    for elts.each {|elt| add_name(ch, sp, id(elt)); }\n }\n \n fn check_exports(e: @env) {\n@@ -1908,7 +1906,7 @@ fn check_exports(e: @env) {\n                             [ found_def_item(item, ns_val),\n                              found_def_item(item, ns_type),\n                              found_def_item(item, ns_module) ];\n-                        for d in defs {\n+                        for defs.each {|d|\n                             alt d {\n                               some(def) {\n                                 f(ident, def);\n@@ -2015,7 +2013,7 @@ fn check_exports(e: @env) {\n                               ids: [ast::path_list_ident]) {\n         let parent_id = check_enum_ok(e, span, id, _mod);\n         add_export(e, export_id, local_def(parent_id), false);\n-        for variant_id in ids {\n+        for ids.each {|variant_id|\n             let mut found = false;\n             alt _mod.index.find(variant_id.node.name) {\n               some(ms) {\n@@ -2048,7 +2046,7 @@ fn check_exports(e: @env) {\n           some(m) {\n             let glob_is_re_exported = int_hash();\n \n-            for vi in m.view_items {\n+            for m.view_items.each {|vi|\n                 iter_export_paths(*vi) { |vp|\n                     alt vp.node {\n                       ast::view_path_simple(ident, _, id) {\n@@ -2071,7 +2069,7 @@ fn check_exports(e: @env) {\n             }\n             // Now follow the export-glob links and fill in the\n             // globbed_exports and exp_map lists.\n-            for glob in _mod.glob_imports {\n+            for _mod.glob_imports.each {|glob|\n                 let id = alt check glob.path.node {\n                   ast::view_path_glob(_, node_id) { node_id }\n                 };\n@@ -2127,7 +2125,7 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n                 option::with_option_do(sc) {|sc|\n                     list::iter(sc) {|level|\n                         if vec::len(found) == 0u {\n-                            for imp in *level {\n+                            for vec::each(*level) {|imp|\n                                 if imp.ident == pt[0] {\n                                     found += [@{ident: name with *imp}];\n                                 }\n@@ -2138,13 +2136,15 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n                 }\n             } else {\n                 lookup_imported_impls(e, id) {|is|\n-                    for i in *is { impls += [@{ident: name with *i}]; }\n+                    for vec::each(*is) {|i|\n+                        impls += [@{ident: name with *i}];\n+                    }\n                 }\n             }\n           }\n \n           ast::view_path_list(base, names, _) {\n-            for nm in names {\n+            for names.each {|nm|\n                 lookup_imported_impls(e, nm.node.id) {|is| impls += *is; }\n             }\n           }\n@@ -2198,10 +2198,10 @@ fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: [@_impl],\n             let mut tmp = [];\n             let mi = e.mod_map.get(defid.node);\n             let md = option::get(mi.m);\n-            for vi in md.view_items {\n+            for md.view_items.each {|vi|\n                 find_impls_in_view_item(e, vi, tmp, none);\n             }\n-            for i in md.items {\n+            for md.items.each {|i|\n                 find_impls_in_item(e, i, tmp, none, none);\n             }\n             @vec::filter(tmp) {|i| is_exported(e, i.ident, mi)}\n@@ -2213,7 +2213,7 @@ fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: [@_impl],\n     }\n     alt name {\n       some(n) {\n-        for im in *cached {\n+        for vec::each(*cached) {|im|\n             if n == im.ident { impls += [im]; }\n         }\n       }\n@@ -2234,10 +2234,10 @@ fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n                                v: vt<iscopes>) {\n     let mut impls = [];\n-    for vi in b.node.view_items {\n+    for b.node.view_items.each {|vi|\n         find_impls_in_view_item(*e, vi, impls, some(sc));\n     }\n-    for st in b.node.stmts {\n+    for b.node.stmts.each {|st|\n         alt st.node {\n           ast::stmt_decl(@{node: ast::decl_item(i), _}, _) {\n             find_impls_in_item(*e, i, impls, none, none);\n@@ -2252,10 +2252,10 @@ fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, id: node_id,\n                              sc: iscopes, v: vt<iscopes>) {\n     let mut impls = [];\n-    for vi in m.view_items {\n+    for m.view_items.each {|vi|\n         find_impls_in_view_item(*e, vi, impls, some(sc));\n     }\n-    for i in m.items { find_impls_in_item(*e, i, impls, none, none); }\n+    for m.items.each {|i| find_impls_in_item(*e, i, impls, none, none); }\n     let impls = @impls;\n     visit::visit_mod(m, s, id, if vec::len(*impls) > 0u {\n                                    cons(impls, @sc)"}, {"sha": "3180084d2394ad28b9bdd098888e05c7b450ec60", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -2788,7 +2788,7 @@ fn need_invoke(bcx: block) -> bool {\n     loop {\n         alt cur.kind {\n           block_scope(info) {\n-            for cleanup in info.cleanups {\n+            for info.cleanups.each {|cleanup|\n                 alt cleanup {\n                   clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) {\n                     if cleanup_type == normal_exit_and_unwind {\n@@ -2925,7 +2925,7 @@ fn trans_rec(bcx: block, fields: [ast::field],\n     let ty_fields = alt check ty::get(t).struct { ty::ty_rec(f) { f } };\n \n     let mut temp_cleanups = [];\n-    for fld in fields {\n+    for fields.each {|fld|\n         let ix = option::get(vec::position(ty_fields, {|ft|\n             str::eq(fld.node.ident, ft.ident)\n         }));\n@@ -2940,7 +2940,7 @@ fn trans_rec(bcx: block, fields: [ast::field],\n         let mut i = 0;\n         bcx = cx;\n         // Copy over inherited fields\n-        for tf in ty_fields {\n+        for ty_fields.each {|tf|\n             if !vec::any(fields, {|f| str::eq(f.node.ident, tf.ident)}) {\n                 let dst = GEPi(bcx, addr, [0, i]);\n                 let base = GEPi(bcx, base_val, [0, i]);\n@@ -2955,7 +2955,7 @@ fn trans_rec(bcx: block, fields: [ast::field],\n \n     // Now revoke the cleanups as we pass responsibility for the data\n     // structure on to the caller\n-    for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n+    for temp_cleanups.each {|cleanup| revoke_clean(bcx, cleanup); }\n     ret bcx;\n }\n \n@@ -3707,15 +3707,16 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n     let _icx = bcx.insn_ctxt(\"cleanup_and_leave\");\n     let mut cur = bcx, bcx = bcx;\n     let is_lpad = leave == none;\n+    let mut done = false;\n     loop {\n         alt cur.kind {\n           block_scope(info) if info.cleanups.len() > 0u {\n-            for cp in info.cleanup_paths {\n-                if cp.target == leave {\n-                    Br(bcx, cp.dest);\n-                    ret;\n-                }\n+            option::with_option_do(vec::find(info.cleanup_paths,\n+                                             {|cp| cp.target == leave})) {|cp|\n+                Br(bcx, cp.dest);\n+                done = true;\n             }\n+            if done { ret; }\n             let sub_cx = sub_block(bcx, \"cleanup\");\n             Br(bcx, sub_cx.llbb);\n             info.cleanup_paths += [{target: leave, dest: sub_cx.llbb}];\n@@ -4318,7 +4319,7 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n   let mut bcx = bcx_top;\n   // Initialize fields to zero so init assignments can validly\n   // drop their LHS\n-  for field in fields {\n+  for fields.each {|field|\n      let ix = field_idx_strict(bcx.tcx(), sp, field.ident, fields);\n      bcx = zero_alloca(bcx, GEPi(bcx, selfptr, [0, ix]),\n                        field.mt.ty);"}, {"sha": "c0fc05356d5dcd968aa66c5a85e4ac4ff7f90096", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -280,19 +280,13 @@ fn add_clean_free(cx: block, ptr: ValueRef, shared: bool) {\n // drop glue checks whether it is zero.\n fn revoke_clean(cx: block, val: ValueRef) {\n     in_scope_cx(cx) {|info|\n-        let mut i = 0u;\n-        for cu in info.cleanups {\n-            alt cu {\n-              clean_temp(v, _, _) if v == val {\n-                info.cleanups =\n-                    vec::slice(info.cleanups, 0u, i) +\n-                    vec::slice(info.cleanups, i + 1u, info.cleanups.len());\n-                scope_clean_changed(info);\n-                break;\n-              }\n-              _ {}\n-            }\n-            i += 1u;\n+        option::with_option_do(vec::position(info.cleanups, {|cu|\n+            alt cu { clean_temp(v, _, _) if v == val { true } _ { false } }\n+        })) {|i|\n+            info.cleanups =\n+                vec::slice(info.cleanups, 0u, i) +\n+                vec::slice(info.cleanups, i + 1u, info.cleanups.len());\n+            scope_clean_changed(info);\n         }\n     }\n }"}, {"sha": "42f762ac1b535469fac830efeb4ecca8e9b0e133", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -152,7 +152,7 @@ fn cached_metadata<T: copy>(cache: metadata_cache, mdtag: int,\n                            eq: fn(md: T) -> bool) -> option<T> unsafe {\n     if cache.contains_key(mdtag) {\n         let items = cache.get(mdtag);\n-        for item in items {\n+        for items.each {|item|\n             let md: T = md_from_metadata::<T>(item);\n             if eq(md) {\n                 ret option::some(md);\n@@ -421,7 +421,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n                                option::get(cx.dbg_cx).names(\"rec\"),\n                                line_from_span(cx.sess.codemap,\n                                               span) as int);\n-    for field in fields {\n+    for fields.each {|field|\n         let field_t = ty::get_field(t, field.node.ident).mt.ty;\n         let ty_md = create_ty(cx, field_t, field.node.mt.ty);\n         let (size, align) = size_and_align_of(cx, field_t);"}, {"sha": "5460b4c8f28744fd3603ef0cb498ff7d8aa99e11", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -372,7 +372,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n       ty::ty_class(did, ts) {\n         // same as records\n         let mut s = [shape_struct], sub = [];\n-        for f:field in ty::class_items_as_fields(ccx.tcx, did, ts) {\n+        for ty::class_items_as_fields(ccx.tcx, did, ts).each {|f|\n             sub += shape_of(ccx, f.mt.ty, ty_param_map);\n         }\n         add_substr(s, sub);\n@@ -465,7 +465,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let data_sz = vec::len(data) as u16;\n \n     let mut info_sz = 0u16;\n-    for did_ in ccx.shape_cx.tag_order {\n+    for ccx.shape_cx.tag_order.each {|did_|\n         let did = did_; // Satisfy alias checker.\n         let num_variants = vec::len(*ty::enum_variants(ccx.tcx, did)) as u16;\n         add_u16(header, header_sz + info_sz);\n@@ -478,7 +478,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n \n     let mut lv_table = [];\n     i = 0u;\n-    for did_ in ccx.shape_cx.tag_order {\n+    for ccx.shape_cx.tag_order.each {|did_|\n         let did = did_; // Satisfy alias checker.\n         let variants = ty::enum_variants(ccx.tcx, did);\n         add_u16(info, vec::len(*variants) as u16);"}, {"sha": "c2677e184c46def2efbbb3c4611136d172f2a751", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -38,7 +38,7 @@ fn node_ids_in_fn(tcx: ty::ctxt, body: blk, rs: @mut [node_id]) {\n }\n \n fn init_vecs(ccx: crate_ctxt, node_ids: [node_id], len: uint) {\n-    for i: node_id in node_ids {\n+    for node_ids.each {|i|\n         log(debug, int::str(i) + \" |-> \" + uint::str(len));\n         add_node(ccx, i, empty_ann(len));\n     }"}, {"sha": "7f97aed65bcda33ce570aaeac7ab0c81bc4e5baa", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -37,7 +37,7 @@ fn def_id_to_str(d: def_id) -> str {\n fn comma_str(args: [@constr_arg_use]) -> str {\n     let mut rslt = \"\";\n     let mut comma = false;\n-    for a: @constr_arg_use in args {\n+    for args.each {|a|\n         if comma { rslt += \", \"; } else { comma = true; }\n         alt a.node {\n           carg_base { rslt += \"*\"; }\n@@ -66,7 +66,7 @@ fn constraint_to_str(tcx: ty::ctxt, c: sp_constr) -> str {\n fn tritv_to_str(fcx: fn_ctxt, v: tritv::t) -> str {\n     let mut s = \"\";\n     let mut comma = false;\n-    for p: norm_constraint in constraints(fcx) {\n+    for constraints(fcx).each {|p|\n         alt tritv_get(v, p.bit_num) {\n           dont_care { }\n           tt {\n@@ -86,11 +86,12 @@ fn log_tritv(fcx: fn_ctxt, v: tritv::t) {\n \n fn first_difference_string(fcx: fn_ctxt, expected: tritv::t, actual: tritv::t)\n    -> str {\n-    let s: str = \"\";\n-    for c: norm_constraint in constraints(fcx) {\n+    let mut s = \"\";\n+    for constraints(fcx).each {|c|\n         if tritv_get(expected, c.bit_num) == ttrue &&\n                tritv_get(actual, c.bit_num) != ttrue {\n-            ret constraint_to_str(fcx.ccx.tcx, c.c);\n+            s = constraint_to_str(fcx.ccx.tcx, c.c);\n+            break;\n         }\n     }\n     ret s;\n@@ -102,7 +103,7 @@ fn log_tritv_err(fcx: fn_ctxt, v: tritv::t) {\n \n fn tos(v: [uint]) -> str {\n     let mut rslt = \"\";\n-    for i: uint in v {\n+    for v.each {|i|\n         if i == 0u {\n             rslt += \"0\";\n         } else if i == 1u { rslt += \"1\"; } else { rslt += \"?\"; }\n@@ -539,7 +540,7 @@ fn norm_a_constraint(id: def_id, c: constraint) -> [norm_constraint] {\n       }\n       cpred(p, descs) {\n         let mut rslt: [norm_constraint] = [];\n-        for pd: pred_args in *descs {\n+        for vec::each(*descs) {|pd|\n             rslt +=\n                 [{bit_num: pd.node.bit_num,\n                   c: respan(pd.span, npred(p, id, pd.node.args))}];\n@@ -567,7 +568,7 @@ fn match_args(fcx: fn_ctxt, occs: @mut [pred_args],\n               occ: [@constr_arg_use]) -> uint {\n     #debug(\"match_args: looking at %s\",\n            constr_args_to_str(fn@(i: inst) -> str { ret i.ident; }, occ));\n-    for pd: pred_args in *occs {\n+    for vec::each(*occs) {|pd|\n         log(debug,\n                  \"match_args: candidate \" + pred_args_to_str(pd));\n         fn eq(p: inst, q: inst) -> bool { ret p.node == q.node; }\n@@ -619,7 +620,7 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: @expr) -> @constr_arg_use {\n fn exprs_to_constr_args(tcx: ty::ctxt, args: [@expr]) -> [@constr_arg_use] {\n     let f = bind expr_to_constr_arg(tcx, _);\n     let mut rslt: [@constr_arg_use] = [];\n-    for e: @expr in args { rslt += [f(e)]; }\n+    for args.each {|e| rslt += [f(e)]; }\n     rslt\n }\n \n@@ -653,7 +654,7 @@ fn pred_args_to_str(p: pred_args) -> str {\n fn substitute_constr_args(cx: ty::ctxt, actuals: [@expr], c: @ty::constr) ->\n    tsconstr {\n     let mut rslt: [@constr_arg_use] = [];\n-    for a: @constr_arg in c.node.args {\n+    for c.node.args.each {|a|\n         rslt += [substitute_arg(cx, actuals, a)];\n     }\n     ret npred(c.node.path, c.node.id, rslt);\n@@ -678,7 +679,7 @@ fn substitute_arg(cx: ty::ctxt, actuals: [@expr], a: @constr_arg) ->\n fn pred_args_matches(pattern: [constr_arg_general_<inst>], desc: pred_args) ->\n    bool {\n     let mut i = 0u;\n-    for c: @constr_arg_use in desc.node.args {\n+    for desc.node.args.each {|c|\n         let n = pattern[i];\n         alt c.node {\n           carg_ident(p) {\n@@ -702,7 +703,7 @@ fn pred_args_matches(pattern: [constr_arg_general_<inst>], desc: pred_args) ->\n \n fn find_instance_(pattern: [constr_arg_general_<inst>], descs: [pred_args]) ->\n    option<uint> {\n-    for d: pred_args in descs {\n+    for descs.each {|d|\n         if pred_args_matches(pattern, d) { ret some(d.node.bit_num); }\n     }\n     ret none;\n@@ -720,7 +721,7 @@ fn find_instances(_fcx: fn_ctxt, subst: subst, c: constraint) ->\n     alt c {\n       cinit(_, _, _) {/* this is dealt with separately */ }\n       cpred(p, descs) {\n-        for d: pred_args in *descs {\n+        for vec::each(copy *descs) {|d|\n             if args_mention(d.node.args, find_in_subst_bool, subst) {\n                 let old_bit_num = d.node.bit_num;\n                 let newv = replace(subst, d);\n@@ -736,7 +737,7 @@ fn find_instances(_fcx: fn_ctxt, subst: subst, c: constraint) ->\n }\n \n fn find_in_subst(id: node_id, s: subst) -> option<inst> {\n-    for p: {from: inst, to: inst} in s {\n+    for s.each {|p|\n         if id == p.from.node { ret some(p.to); }\n     }\n     ret none;\n@@ -748,7 +749,7 @@ fn find_in_subst_bool(s: subst, id: node_id) -> bool {\n \n fn insts_to_str(stuff: [constr_arg_general_<inst>]) -> str {\n     let mut rslt = \"<\";\n-    for i: constr_arg_general_<inst> in stuff {\n+    for stuff.each {|i|\n         rslt +=\n             \" \" +\n                 alt i {\n@@ -763,7 +764,7 @@ fn insts_to_str(stuff: [constr_arg_general_<inst>]) -> str {\n \n fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>] {\n     let mut rslt: [constr_arg_general_<inst>] = [];\n-    for c: @constr_arg_use in d.node.args {\n+    for d.node.args.each {|c|\n         alt c.node {\n           carg_ident(p) {\n             alt find_in_subst(p.node, subst) {\n@@ -872,7 +873,7 @@ fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n         // replace any occurrences of the src def_id with the\n         // dest def_id\n         let insts = find_instances(fcx, subst, val);\n-        for p: {from: uint, to: uint} in insts {\n+        for insts.each {|p|\n             if promises_(p.from, src_post) {\n                 set_in_poststate_(p.to, target_post);\n             }\n@@ -887,7 +888,7 @@ fn forget_in_postcond(fcx: fn_ctxt, parent_exp: node_id, dead_v: node_id) {\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n     alt d {\n       some(d_id) {\n-        for c: norm_constraint in constraints(fcx) {\n+        for constraints(fcx).each {|c|\n             if constraint_mentions(fcx, c, d_id) {\n                 #debug(\"clearing constraint %u %s\",\n                        c.bit_num,\n@@ -909,7 +910,7 @@ fn forget_in_postcond_still_init(fcx: fn_ctxt, parent_exp: node_id,\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n     alt d {\n       some(d_id) {\n-        for c: norm_constraint in constraints(fcx) {\n+        for constraints(fcx).each {|c|\n             if non_init_constraint_mentions(fcx, c, d_id) {\n                 clear_in_postcond(c.bit_num,\n                                   node_id_to_ts_ann(fcx.ccx,\n@@ -928,7 +929,7 @@ fn forget_in_poststate(fcx: fn_ctxt, p: poststate, dead_v: node_id) -> bool {\n     let mut changed = false;\n     alt d {\n       some(d_id) {\n-        for c: norm_constraint in constraints(fcx) {\n+        for constraints(fcx).each {|c|\n             if constraint_mentions(fcx, c, d_id) {\n                 changed |= clear_in_poststate_(c.bit_num, p);\n             }\n@@ -947,7 +948,7 @@ fn forget_in_poststate_still_init(fcx: fn_ctxt, p: poststate, dead_v: node_id)\n     let mut changed = false;\n     alt d {\n       some(d_id) {\n-        for c: norm_constraint in constraints(fcx) {\n+        for constraints(fcx).each {|c|\n             if non_init_constraint_mentions(fcx, c, d_id) {\n                 changed |= clear_in_poststate_(c.bit_num, p);\n             }\n@@ -959,7 +960,7 @@ fn forget_in_poststate_still_init(fcx: fn_ctxt, p: poststate, dead_v: node_id)\n }\n \n fn any_eq(v: [node_id], d: node_id) -> bool {\n-    for i: node_id in v { if i == d { ret true; } }\n+    for v.each {|i| if i == d { ret true; } }\n     false\n }\n \n@@ -1000,7 +1001,7 @@ fn args_mention<T>(args: [@constr_arg_use],\n     ret vec::any(bind mentions(s,q,_), args);\n     */\n \n-    for a: @constr_arg_use in args {\n+    for args.each {|a|\n         alt a.node { carg_ident(p1) { if q(s, p1.node) { ret true; } } _ { } }\n     }\n     ret false;\n@@ -1010,7 +1011,7 @@ fn use_var(fcx: fn_ctxt, v: node_id) { *fcx.enclosing.used_vars += [v]; }\n \n // FIXME: This should be a function in vec::.\n fn vec_contains(v: @mut [node_id], i: node_id) -> bool {\n-    for d: node_id in *v { if d == i { ret true; } }\n+    for vec::each(*v) {|d| if d == i { ret true; } }\n     ret false;\n }\n \n@@ -1029,7 +1030,7 @@ fn args_to_constr_args(tcx: ty::ctxt, args: [arg],\n                        indices: [@sp_constr_arg<uint>]) -> [@constr_arg_use] {\n     let mut actuals: [@constr_arg_use] = [];\n     let num_args = vec::len(args);\n-    for a: @sp_constr_arg<uint> in indices {\n+    for indices.each {|a|\n         actuals +=\n             [@respan(a.span,\n                      alt a.node {\n@@ -1075,7 +1076,7 @@ fn local_to_bindings(tcx: ty::ctxt, loc: @local) -> binding {\n \n fn locals_to_bindings(tcx: ty::ctxt, locals: [@local]) -> [binding] {\n     let mut rslt = [];\n-    for loc in locals { rslt += [local_to_bindings(tcx, loc)]; }\n+    for locals.each {|loc| rslt += [local_to_bindings(tcx, loc)]; }\n     ret rslt;\n }\n \n@@ -1085,7 +1086,7 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [mode] {\n     alt ty::get(ty).struct {\n       ty::ty_fn({inputs: args, _}) {\n         let mut modes = [];\n-        for arg: ty::arg in args { modes += [arg.mode]; }\n+        for args.each {|arg| modes += [arg.mode]; }\n         ret modes;\n       }\n       _ {\n@@ -1108,7 +1109,7 @@ fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> [init_op] {\n fn anon_bindings(ops: [init_op], es: [@expr]) -> [binding] {\n     let mut bindings: [binding] = [];\n     let mut i = 0;\n-    for op: init_op in ops {\n+    for ops.each {|op|\n         bindings += [{lhs: [], rhs: some({op: op, expr: es[i]})}];\n         i += 1;\n     }"}, {"sha": "ee2a159371ec754a7d22ef407051bb3a607b5d36", "filename": "src/rustc/middle/tstate/bitvectors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -67,7 +67,7 @@ fn seq_postconds(fcx: fn_ctxt, ps: [postcond]) -> postcond {\n     let sz = vec::len(ps);\n     if sz >= 1u {\n         let prev = tritv_clone(ps[0]);\n-        for p: postcond in vec::slice(ps, 1u, sz) { seq_tritv(prev, p); }\n+        vec::iter_between(ps, 1u, sz) {|p| seq_tritv(prev, p); }\n         ret prev;\n     } else { ret ann::empty_poststate(num_constraints(fcx.enclosing)); }\n }"}, {"sha": "decf1af6401cbc3da562ee9324b6690ff3d2608a", "filename": "src/rustc/middle/tstate/ck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -19,7 +19,7 @@ import std::map::hashmap;\n fn check_unused_vars(fcx: fn_ctxt) {\n \n     // FIXME: could be more efficient\n-    for c: norm_constraint in constraints(fcx) {\n+    for constraints(fcx).each {|c|\n         alt c.c.node {\n           ninit(id, v) {\n             if !vec_contains(fcx.enclosing.used_vars, id) && v[0] != '_' as u8"}, {"sha": "b6f1de95984b6582d7b44b2a75d2021fb3d331b4", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -27,7 +27,7 @@ fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n       // If it's a call, generate appropriate instances of the\n       // call's constraints.\n       expr_call(operator, operands, _) {\n-        for c: @ty::constr in constraints_expr(cx.tcx, operator) {\n+        for constraints_expr(cx.tcx, operator).each {|c|\n             let ct: sp_constr =\n                 respan(c.span,\n                        aux::substitute_constr_args(cx.tcx, operands, c));\n@@ -105,20 +105,21 @@ fn mk_fn_info(ccx: crate_ctxt,\n     /* now we have to add bit nums for both the constraints\n        and the variables... */\n \n-    for c: sp_constr in { *cx.cs } {\n-        next = add_constraint(cx.tcx, c, next, res_map);\n+    let mut i = 0u, l = vec::len(*cx.cs);\n+    while i < l {\n+        next = add_constraint(cx.tcx, cx.cs[i], next, res_map);\n+        i += 1u;\n     }\n     /* if this function has any constraints, instantiate them to the\n        argument names and add them */\n-    let mut sc;\n-    for c: @constr in f_decl.constraints {\n-        sc = ast_constr_to_sp_constr(cx.tcx, f_decl.inputs, c);\n+    for f_decl.constraints.each {|c|\n+        let sc = ast_constr_to_sp_constr(cx.tcx, f_decl.inputs, c);\n         next = add_constraint(cx.tcx, sc, next, res_map);\n     }\n \n     /* Need to add constraints for args too, b/c they\n     can be deinitialized */\n-    for a: arg in f_decl.inputs {\n+    for f_decl.inputs.each {|a|\n         next = add_constraint(\n             cx.tcx,\n             respan(f_sp, ninit(a.id, a.ident)),"}, {"sha": "b9ed39dfce8035bfb9f10ecdde8637b79fcd7d93", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -60,7 +60,9 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n       item_class(_,_,_) {\n           fail \"find_pre_post_item: implement item_class\";\n       }\n-      item_impl(_, _, _, ms) { for m in ms { find_pre_post_method(ccx, m); } }\n+      item_impl(_, _, _, ms) {\n+        for ms.each {|m| find_pre_post_method(ccx, m); }\n+      }\n     }\n }\n \n@@ -75,7 +77,7 @@ fn find_pre_post_exprs(fcx: fn_ctxt, args: [@expr], id: node_id) {\n         log_expr(*args[0]);\n     }\n     fn do_one(fcx: fn_ctxt, e: @expr) { find_pre_post_expr(fcx, e); }\n-    for e: @expr in args { do_one(fcx, e); }\n+    for args.each {|e| do_one(fcx, e); }\n \n     fn get_pp(ccx: crate_ctxt, &&e: @expr) -> pre_and_post {\n         ret expr_pp(ccx, e);\n@@ -282,7 +284,7 @@ fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: [mode],\n fn find_pre_post_expr_fn_upvars(fcx: fn_ctxt, e: @expr) {\n     let rslt = expr_pp(fcx.ccx, e);\n     clear_pp(rslt);\n-    for def in *freevars::get_freevars(fcx.ccx.tcx, e.id) {\n+    for vec::each(*freevars::get_freevars(fcx.ccx.tcx, e.id)) {|def|\n         log(debug, (\"handle_var_def: def=\", def));\n         handle_var_def(fcx, rslt, def.def, \"upvar\");\n     }\n@@ -304,7 +306,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n \n         find_pre_post_exprs(fcx, args, e.id);\n         /* see if the call has any constraints on its type */\n-        for c: @ty::constr in constraints_expr(fcx.ccx.tcx, operator) {\n+        for constraints_expr(fcx.ccx.tcx, operator).each {|c|\n             let i =\n                 bit_num(fcx, substitute_constr_args(fcx.ccx.tcx, args, c));\n             require(i, expr_pp(fcx.ccx, e));\n@@ -466,7 +468,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n             ret block_pp(fcx.ccx, an_alt.body);\n         }\n         let mut alt_pps = [];\n-        for a: arm in alts { alt_pps += [do_an_alt(fcx, a)]; }\n+        for alts.each {|a| alt_pps += [do_an_alt(fcx, a)]; }\n         fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, &&pp: pre_and_post,\n                       &&next: pre_and_post) -> pre_and_post {\n             union(pp.precondition, seq_preconds(fcx, [antec, next]));\n@@ -517,7 +519,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         let mut cmodes = callee_modes(fcx, operator.id);\n         let mut modes = [];\n         let mut i = 0;\n-        for expr_opt: option<@expr> in maybe_args {\n+        for maybe_args.each {|expr_opt|\n             alt expr_opt {\n               none {/* no-op */ }\n               some(expr) { modes += [cmodes[i]]; args += [expr]; }\n@@ -541,9 +543,8 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n       stmt_decl(adecl, id) {\n         alt adecl.node {\n           decl_local(alocals) {\n-            let mut e_pp;\n             let prev_pp = empty_pre_post(num_constraints(fcx.enclosing));\n-            for alocal in alocals {\n+            for alocals.each {|alocal|\n                 alt alocal.node.init {\n                   some(an_init) {\n                     /* LHS always becomes initialized,\n@@ -586,7 +587,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n \n                     /* Clear out anything that the previous initializer\n                     guaranteed */\n-                    e_pp = expr_pp(fcx.ccx, an_init.expr);\n+                    let e_pp = expr_pp(fcx.ccx, an_init.expr);\n                     tritv_copy(prev_pp.precondition,\n                                seq_preconds(fcx, [prev_pp, e_pp]));\n                     /* Include the LHSs too, since those aren't in the\n@@ -650,13 +651,13 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n                 log_pp_err(stmt_pp(fcx.ccx, *s));\n         */\n     }\n-    for s: @stmt in b.node.stmts { do_one_(fcx, s); }\n+    for b.node.stmts.each {|s| do_one_(fcx, s); }\n     fn do_inner_(fcx: fn_ctxt, &&e: @expr) { find_pre_post_expr(fcx, e); }\n     let do_inner = bind do_inner_(fcx, _);\n     option::map::<@expr, ()>(b.node.expr, do_inner);\n \n     let mut pps: [pre_and_post] = [];\n-    for s: @stmt in b.node.stmts { pps += [stmt_pp(fcx.ccx, *s)]; }\n+    for b.node.stmts.each {|s| pps += [stmt_pp(fcx.ccx, *s)]; }\n     alt b.node.expr {\n       none {/* no-op */ }\n       some(e) { pps += [expr_pp(fcx.ccx, e)]; }\n@@ -665,7 +666,7 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n     let block_precond = seq_preconds(fcx, pps);\n \n     let mut postconds = [];\n-    for pp: pre_and_post in pps { postconds += [get_post(pp)]; }\n+    for pps.each {|pp| postconds += [get_post(pp)]; }\n \n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */"}, {"sha": "7b137b4b63a569b2bcdf32cae5f5cd8ae09bfe7e", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -67,14 +67,14 @@ fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: [binding]) ->\n    {changed: bool, post: poststate} {\n     let mut changed = false;\n     let mut post = tritv_clone(pres);\n-    for b: binding in bindings {\n+    for bindings.each {|b|\n         alt b.rhs {\n           some(an_init) {\n             // an expression, with or without a destination\n             changed |=\n                 find_pre_post_state_expr(fcx, post, an_init.expr) || changed;\n             post = tritv_clone(expr_poststate(fcx.ccx, an_init.expr));\n-            for i: inst in b.lhs {\n+            for b.lhs.each {|i|\n                 alt an_init.expr.node {\n                   expr_path(p) {\n                     handle_move_or_copy(fcx, post, p, an_init.expr.id, i,\n@@ -91,7 +91,7 @@ fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: [binding]) ->\n             }\n           }\n           none {\n-            for i: inst in b.lhs {\n+            for b.lhs.each {|i|\n                 // variables w/o an initializer\n                 clear_in_poststate_ident_(fcx, i.node, i.ident, post);\n             }\n@@ -375,7 +375,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         let callee_ops = callee_arg_init_ops(fcx, operator.id);\n         let mut ops = [];\n         let mut i = 0;\n-        for a_opt: option<@expr> in maybe_args {\n+        for maybe_args.each {|a_opt|\n             alt a_opt {\n               none {/* no-op */ }\n               some(a) { ops += [callee_ops[i]]; args += [a]; }\n@@ -575,7 +575,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         let mut a_post;\n         if vec::len(alts) > 0u {\n             a_post = false_postcond(num_constrs);\n-            for an_alt: arm in alts {\n+            for alts.each {|an_alt|\n                 alt an_alt.guard {\n                   some(e) {\n                     changed |= find_pre_post_state_expr(fcx, e_post, e);\n@@ -702,7 +702,7 @@ fn find_pre_post_state_block(fcx: fn_ctxt, pres0: prestate, b: blk) -> bool {\n      initializes.  Then <pres> becomes the new poststate. */\n \n     let mut changed = false;\n-    for s: @stmt in b.node.stmts {\n+    for b.node.stmts.each {|s|\n         changed |= find_pre_post_state_stmt(fcx, pres, s);\n         pres = stmt_poststate(fcx.ccx, *s);\n     }\n@@ -745,12 +745,12 @@ fn find_pre_post_state_fn(fcx: fn_ctxt,\n \n     // Arguments start out initialized\n     let block_pre = block_prestate(fcx.ccx, f_body);\n-    for a: arg in f_decl.inputs {\n+    for f_decl.inputs.each {|a|\n         set_in_prestate_constr(fcx, ninit(a.id, a.ident), block_pre);\n     }\n \n     // Instantiate any constraints on the arguments so we can use them\n-    for c: @constr in f_decl.constraints {\n+    for f_decl.constraints.each {|c|\n         let tsc = ast_constr_to_ts_constr(fcx.ccx.tcx, f_decl.inputs, c);\n         set_in_prestate_constr(fcx, tsc, block_pre);\n     }"}, {"sha": "6bcd9317f54f051c2f271604a1b0871c0e41c896", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 53, "deletions": 46, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -372,7 +372,7 @@ impl of vid for region_vid {\n \n fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n     let mut kind = kind_noncopyable;\n-    for bound in *bounds {\n+    for vec::each(*bounds) {|bound|\n         alt bound {\n           bound_copy {\n             if kind != kind_sendable { kind = kind_copyable; }\n@@ -464,7 +464,9 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       ty_param(_, _) { has_params = true; }\n       ty_var(_) | ty_self(_) { has_vars = true; }\n       ty_enum(_, tys) | ty_iface(_, tys) | ty_class(_, tys) {\n-        for tt in tys { derive_flags(has_params, has_vars, has_rptrs, tt); }\n+        for tys.each {|tt|\n+            derive_flags(has_params, has_vars, has_rptrs, tt);\n+        }\n       }\n       ty_box(m) | ty_uniq(m) | ty_vec(m) | ty_ptr(m) {\n         derive_flags(has_params, has_vars, has_rptrs, m.ty);\n@@ -478,22 +480,24 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n         derive_flags(has_params, has_vars, has_rptrs, m.ty);\n       }\n       ty_rec(flds) {\n-        for f in flds {\n+        for flds.each {|f|\n           derive_flags(has_params, has_vars, has_rptrs, f.mt.ty);\n         }\n       }\n       ty_tup(ts) {\n-        for tt in ts { derive_flags(has_params, has_vars, has_rptrs, tt); }\n+        for ts.each {|tt| derive_flags(has_params, has_vars, has_rptrs, tt); }\n       }\n       ty_fn(f) {\n-        for a in f.inputs {\n+        for f.inputs.each {|a|\n           derive_flags(has_params, has_vars, has_rptrs, a.ty);\n         }\n         derive_flags(has_params, has_vars, has_rptrs, f.output);\n       }\n       ty_res(_, tt, tps) {\n         derive_flags(has_params, has_vars, has_rptrs, tt);\n-        for tt in tps { derive_flags(has_params, has_vars, has_rptrs, tt); }\n+        for tps.each {|tt|\n+            derive_flags(has_params, has_vars, has_rptrs, tt);\n+        }\n       }\n       ty_constr(tt, _) {\n         derive_flags(has_params, has_vars, has_rptrs, tt);\n@@ -633,19 +637,19 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n       }\n       ty_enum(_, subtys) | ty_iface(_, subtys) | ty_class(_, subtys)\n        | ty_self(subtys) {\n-        for subty: t in subtys { maybe_walk_ty(subty, f); }\n+        for subtys.each {|subty| maybe_walk_ty(subty, f); }\n       }\n       ty_rec(fields) {\n-        for fl: field in fields { maybe_walk_ty(fl.mt.ty, f); }\n+        for fields.each {|fl| maybe_walk_ty(fl.mt.ty, f); }\n       }\n-      ty_tup(ts) { for tt in ts { maybe_walk_ty(tt, f); } }\n+      ty_tup(ts) { for ts.each {|tt| maybe_walk_ty(tt, f); } }\n       ty_fn(ft) {\n-        for a: arg in ft.inputs { maybe_walk_ty(a.ty, f); }\n+        for ft.inputs.each {|a| maybe_walk_ty(a.ty, f); }\n         maybe_walk_ty(ft.output, f);\n       }\n       ty_res(_, sub, tps) {\n         maybe_walk_ty(sub, f);\n-        for tp: t in tps { maybe_walk_ty(tp, f); }\n+        for tps.each {|tp| maybe_walk_ty(tp, f); }\n       }\n       ty_constr(sub, _) { maybe_walk_ty(sub, f); }\n       ty_uniq(tm) { maybe_walk_ty(tm.ty, f); }\n@@ -895,23 +899,24 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_type | ty_ptr(_) | ty_rptr(_, _) { false }\n       ty_rec(flds) {\n-        for f in flds { if type_needs_drop(cx, f.mt.ty) { accum = true; } }\n+        for flds.each {|f| if type_needs_drop(cx, f.mt.ty) { accum = true; } }\n         accum\n       }\n       ty_class(did, ts) {\n-          for f in ty::class_items_as_fields(cx, did, ts)\n-          { if type_needs_drop(cx, f.mt.ty) { accum = true; } }\n+        for vec::each(ty::class_items_as_fields(cx, did, ts)) {|f|\n+            if type_needs_drop(cx, f.mt.ty) { accum = true; }\n+        }\n         accum\n       }\n \n       ty_tup(elts) {\n-        for m in elts { if type_needs_drop(cx, m) { accum = true; } }\n+        for elts.each {|m| if type_needs_drop(cx, m) { accum = true; } }\n         accum\n       }\n       ty_enum(did, tps) {\n         let variants = enum_variants(cx, did);\n-        for variant in *variants {\n-            for aty in variant.args {\n+        for vec::each(*variants) {|variant|\n+            for variant.args.each {|aty|\n                 // Perform any type parameter substitutions.\n                 let arg_ty = substitute_type_params(cx, tps, aty);\n                 if type_needs_drop(cx, arg_ty) { accum = true; }\n@@ -968,8 +973,8 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n             true\n           }\n           ty_enum(did, tps) {\n-            for v in *enum_variants(cx, did) {\n-                for aty in v.args {\n+            for vec::each(*enum_variants(cx, did)) {|v|\n+                for v.args.each {|aty|\n                     let t = substitute_type_params(cx, tps, aty);\n                     needs_unwind_cleanup |=\n                         type_needs_unwind_cleanup_(cx, t, tycache,\n@@ -1068,13 +1073,15 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n         let mut lowest = kind_sendable;\n-        for f in flds { lowest = lower_kind(lowest, type_kind(cx, f.mt.ty)); }\n+        for flds.each {|f|\n+            lowest = lower_kind(lowest, type_kind(cx, f.mt.ty));\n+        }\n         lowest\n       }\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n         let mut lowest = kind_sendable;\n-        for ty in tys { lowest = lower_kind(lowest, type_kind(cx, ty)); }\n+        for tys.each {|ty| lowest = lower_kind(lowest, type_kind(cx, ty)); }\n         lowest\n       }\n       // Enums lower to the lowest of their variants.\n@@ -1084,8 +1091,8 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         if vec::len(*variants) == 0u {\n             lowest = kind_noncopyable;\n         } else {\n-            for variant in *variants {\n-                for aty in variant.args {\n+            for vec::each(*variants) {|variant|\n+                for variant.args.each {|aty|\n                     // Perform any type parameter substitutions.\n                     let arg_ty = substitute_type_params(cx, tps, aty);\n                     lowest = lower_kind(lowest, type_kind(cx, arg_ty));\n@@ -1246,22 +1253,22 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n     if test(sty) { ret true; }\n     alt sty {\n       ty_enum(did, tps) {\n-        for variant in *enum_variants(cx, did) {\n-            for aty in variant.args {\n+        for vec::each(*enum_variants(cx, did)) {|variant|\n+            for variant.args.each {|aty|\n                 let sty = substitute_type_params(cx, tps, aty);\n                 if type_structurally_contains(cx, sty, test) { ret true; }\n             }\n         }\n         ret false;\n       }\n       ty_rec(fields) {\n-        for field in fields {\n+        for fields.each {|field|\n             if type_structurally_contains(cx, field.mt.ty, test) { ret true; }\n         }\n         ret false;\n       }\n       ty_tup(ts) {\n-        for tt in ts {\n+        for ts.each {|tt|\n             if type_structurally_contains(cx, tt, test) { ret true; }\n         }\n         ret false;\n@@ -1342,7 +1349,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       // Structural types\n       ty_enum(did, tps) {\n         let variants = enum_variants(cx, did);\n-        for variant: variant_info in *variants {\n+        for vec::each(*variants) {|variant|\n             let tup_ty = mk_tup(cx, variant.args);\n \n             // Perform any type parameter substitutions.\n@@ -1351,12 +1358,12 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         }\n       }\n       ty_rec(flds) {\n-        for f: field in flds {\n+        for flds.each {|f|\n             if !type_is_pod(cx, f.mt.ty) { result = false; }\n         }\n       }\n       ty_tup(elts) {\n-        for elt in elts { if !type_is_pod(cx, elt) { result = false; } }\n+        for elts.each {|elt| if !type_is_pod(cx, elt) { result = false; } }\n       }\n       ty_res(_, inner, tps) {\n         result = type_is_pod(cx, substitute_type_params(cx, tps, inner));\n@@ -1452,14 +1459,14 @@ fn hash_type_structure(st: sty) -> uint {\n     fn hash_subty(id: uint, subty: t) -> uint { (id << 2u) + type_id(subty) }\n     fn hash_subtys(id: uint, subtys: [t]) -> uint {\n         let mut h = id;\n-        for s in subtys { h = (h << 2u) + type_id(s) }\n+        for subtys.each {|s| h = (h << 2u) + type_id(s) }\n         h\n     }\n     fn hash_type_constr(id: uint, c: @type_constr) -> uint {\n         let mut h = id;\n         h = (h << 2u) + hash_def(h, c.node.id);\n         // FIXME this makes little sense\n-        for a in c.node.args {\n+        for c.node.args.each {|a|\n             alt a.node {\n               carg_base { h += h << 2u; }\n               carg_lit(_) { fail \"lit args not implemented yet\"; }\n@@ -1499,27 +1506,27 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_str { 17u }\n       ty_enum(did, tys) {\n         let mut h = hash_def(18u, did);\n-        for typ: t in tys { h = hash_subty(h, typ); }\n+        for tys.each {|typ| h = hash_subty(h, typ); }\n         h\n       }\n       ty_box(mt) { hash_subty(19u, mt.ty) }\n       ty_vec(mt) { hash_subty(21u, mt.ty) }\n       ty_rec(fields) {\n         let mut h = 26u;\n-        for f in fields { h = hash_subty(h, f.mt.ty); }\n+        for fields.each {|f| h = hash_subty(h, f.mt.ty); }\n         h\n       }\n       ty_tup(ts) { hash_subtys(25u, ts) }\n       ty_fn(f) {\n         let mut h = 27u;\n-        for a in f.inputs { h = hash_subty(h, a.ty); }\n+        for f.inputs.each {|a| h = hash_subty(h, a.ty); }\n         hash_subty(h, f.output)\n       }\n       ty_var(v) { hash_uint(30u, v.to_uint()) }\n       ty_param(pid, did) { hash_def(hash_uint(31u, pid), did) }\n       ty_self(ts) {\n         let mut h = 28u;\n-        for t in ts { h = hash_subty(h, t); }\n+        for ts.each {|t| h = hash_subty(h, t); }\n         h\n       }\n       ty_type { 32u }\n@@ -1535,13 +1542,13 @@ fn hash_type_structure(st: sty) -> uint {\n       }\n       ty_constr(t, cs) {\n         let mut h = hash_subty(36u, t);\n-        for c in cs { h = (h << 2u) + hash_type_constr(h, c); }\n+        for cs.each {|c| h = (h << 2u) + hash_type_constr(h, c); }\n         h\n       }\n       ty_uniq(mt) { hash_subty(37u, mt.ty) }\n       ty_iface(did, tys) {\n         let mut h = hash_def(40u, did);\n-        for typ: t in tys { h = hash_subty(h, typ); }\n+        for tys.each {|typ| h = hash_subty(h, typ); }\n         h\n       }\n       ty_opaque_closure_ptr(ck_block) { 41u }\n@@ -1550,7 +1557,7 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_opaque_box { 44u }\n       ty_class(did, tys) {\n           let mut h = hash_def(45u, did);\n-          for typ: t in tys { h = hash_subty(h, typ); }\n+          for tys.each {|typ| h = hash_subty(h, typ); }\n           h\n       }\n     }\n@@ -1579,7 +1586,7 @@ fn args_eq<T>(eq: fn(T, T) -> bool,\n               a: [@sp_constr_arg<T>],\n               b: [@sp_constr_arg<T>]) -> bool {\n     let mut i: uint = 0u;\n-    for arg: @sp_constr_arg<T> in a {\n+    for a.each {|arg|\n         if !arg_eq(eq, arg, b[i]) { ret false; }\n         i += 1u;\n     }\n@@ -1596,7 +1603,7 @@ fn constr_eq(c: @constr, d: @constr) -> bool {\n fn constrs_eq(cs: [@constr], ds: [@constr]) -> bool {\n     if vec::len(cs) != vec::len(ds) { ret false; }\n     let mut i = 0u;\n-    for c: @constr in cs { if !constr_eq(c, ds[i]) { ret false; } i += 1u; }\n+    for cs.each {|c| if !constr_eq(c, ds[i]) { ret false; } i += 1u; }\n     ret true;\n }\n \n@@ -1721,7 +1728,7 @@ fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n \n fn field_idx(id: ast::ident, fields: [field]) -> option<uint> {\n     let mut i = 0u;\n-    for f in fields { if f.ident == id { ret some(i); } i += 1u; }\n+    for fields.each {|f| if f.ident == id { ret some(i); } i += 1u; }\n     ret none;\n }\n \n@@ -1739,7 +1746,7 @@ fn get_fields(rec_ty:t) -> [field] {\n \n fn method_idx(id: ast::ident, meths: [method]) -> option<uint> {\n     let mut i = 0u;\n-    for m in meths { if m.ident == id { ret some(i); } i += 1u; }\n+    for meths.each {|m| if m.ident == id { ret some(i); } i += 1u; }\n     ret none;\n }\n \n@@ -2214,7 +2221,7 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n                                sp: span) -> def_id {\n     if check is_local(did) {\n        let ms = lookup_class_method_ids(cx, did);\n-       for m in ms {\n+       for ms.each {|m|\n          if m.name == name {\n              ret ast_util::local_def(m.id);\n          }\n@@ -2229,7 +2236,7 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n \n fn class_field_tys(items: [@class_member]) -> [field_ty] {\n     let mut rslt = [];\n-    for it in items {\n+    for items.each {|it|\n        alt it.node {\n           instance_var(nm, _, cm, id, privacy) {\n               rslt += [{ident: nm, id: ast_util::local_def(id),\n@@ -2247,7 +2254,7 @@ fn class_field_tys(items: [@class_member]) -> [field_ty] {\n fn class_items_as_fields(cx:ctxt, did: ast::def_id, substs: [ty::t])\n     -> [field] {\n     let mut rslt = [];\n-    for f in lookup_class_fields(cx, did) {\n+    for lookup_class_fields(cx, did).each {|f|\n        // consider all instance vars mut, because the\n        // constructor may mutate all vars\n        rslt += [{ident: f.ident, mt:"}, {"sha": "6b602e45fc3171ff0a6a147adcd2ab3dd61f43aa", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 47, "deletions": 52, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -317,7 +317,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n             tcx.sess.span_fatal(sp, \"wrong number of type arguments for a \\\n                                      polymorphic type\");\n         }\n-        for ast_ty: @ast::ty in args {\n+        for args.each {|ast_ty|\n             param_bindings += [do_ast_ty_to_ty(tcx, mode, ast_ty)];\n         }\n         #debug(\"substituting(%s into %s)\",\n@@ -379,7 +379,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n           }\n           ast::ty_rec(fields) {\n             let mut flds: [field] = [];\n-            for f: ast::ty_field in fields {\n+            for fields.each {|f|\n                 let tm = ast_mt_to_mt(tcx, mode, f.node.mt);\n                 flds += [{ident: f.node.ident, mt: tm}];\n             }\n@@ -436,7 +436,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n           }\n           ast::ty_constr(t, cs) {\n             let mut out_cs = [];\n-            for constr: @ast::ty_constr in cs {\n+            for cs.each {|constr|\n                 out_cs += [ty::ast_constr_to_constr(tcx, constr)];\n             }\n             ty::mk_constr(tcx, do_ast_ty_to_ty(tcx, mode, t), out_cs)\n@@ -699,12 +699,12 @@ fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n     -> @[ty::param_bounds] {\n     let mut result = [];\n-    for param in params {\n+    for params.each {|param|\n         result += [alt tcx.ty_param_bounds.find(param.id) {\n           some(bs) { bs }\n           none {\n             let mut bounds = [];\n-            for b in *param.bounds {\n+            for vec::each(*param.bounds) {|b|\n                 bounds += [alt b {\n                   ast::bound_send { ty::bound_send }\n                   ast::bound_copy { ty::bound_copy }\n@@ -994,7 +994,7 @@ mod collect {\n                               variants: [ast::variant],\n                               ty_params: [ast::ty_param]) {\n         // Create a set of parameter types shared among all the variants.\n-        for variant in variants {\n+        for variants.each {|variant|\n             // Nullary enum constructors get turned into constants; n-ary enum\n             // constructors get turned into functions.\n             let result_ty = if vec::len(variant.node.args) == 0u {\n@@ -1003,7 +1003,7 @@ mod collect {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n                 let mut args: [arg] = [];\n-                for va: ast::variant_arg in variant.node.args {\n+                for variant.node.args.each {|va|\n                     let arg_ty = {\n                         // NDM We need BOUNDS here.  It should be that this\n                         // yields a type like \"foo &anon\".  Basically every\n@@ -1061,7 +1061,7 @@ mod collect {\n         i_bounds: @[ty::param_bounds], maybe_self: option<ty::t>)\n         -> [{mty: ty::method, id: ast::node_id, span: span}] {\n         let mut my_methods = [];\n-        for m in ms {\n+        for ms.each {|m|\n            alt maybe_self {\n               some(selfty) {\n                 write_ty_to_tcx(tcx, m.self_id, selfty);\n@@ -1086,7 +1086,7 @@ mod collect {\n           ast::item_native_mod(m) {\n             if syntax::attr::native_abi(it.attrs) ==\n                either::right(ast::native_abi_rust_intrinsic) {\n-                for item in m.items { check_intrinsic_type(tcx, item); }\n+                for m.items.each {|item| check_intrinsic_type(tcx, item); }\n             }\n           }\n           ast::item_enum(variants, ty_params) {\n@@ -1115,7 +1115,7 @@ mod collect {\n                     if did.crate == ast::local_crate {\n                         ensure_iface_methods(tcx, did.node);\n                     }\n-                    for if_m in *ty::iface_methods(tcx, did) {\n+                    for vec::each(*ty::iface_methods(tcx, did)) {|if_m|\n                         alt vec::find(my_methods,\n                                       {|m| if_m.ident == m.mty.ident}) {\n                           some({mty: m, id, span}) {\n@@ -1195,7 +1195,7 @@ mod collect {\n               /* FIXME: check for proper public/privateness */\n               // Write the type of each of the members\n               let (fields, methods) = split_class_items(members);\n-              for f in fields {\n+              for fields.each {|f|\n                  convert_class_item(tcx, f);\n               }\n               // The selfty is just the class type\n@@ -1346,7 +1346,7 @@ mod demand {\n \n         let mut ty_param_substs: [mut ty::t] = [mut];\n         let mut ty_param_subst_var_ids: [ty_vid] = [];\n-        for ty_param_subst: ty::t in ty_param_substs_0 {\n+        for ty_param_substs_0.each {|ty_param_subst|\n             // Generate a type variable and unify it with the type parameter\n             // substitution. We will then pull out these type variables.\n             let t_0 = next_ty_var(fcx);\n@@ -1359,7 +1359,7 @@ mod demand {\n                      ty_param_subst_var_ids: [ty_vid]) ->\n            ty_param_substs_and_ty {\n             let mut result_ty_param_substs: [ty::t] = [];\n-            for var_id in ty_param_subst_var_ids {\n+            for ty_param_subst_var_ids.each {|var_id|\n                 let tp_subst = ty::mk_var(fcx.ccx.tcx, var_id);\n                 result_ty_param_substs += [tp_subst];\n             }\n@@ -1405,7 +1405,7 @@ fn variant_arg_types(ccx: @crate_ctxt, _sp: span, vid: ast::def_id,\n     alt ty::get(tpt.ty).struct {\n       ty::ty_fn(f) {\n         // N-ary variant.\n-        for arg: ty::arg in f.inputs {\n+        for f.inputs.each {|arg|\n             let arg_ty =\n                 ty::substitute_type_params(ccx.tcx, enum_ty_params, arg.ty);\n             result += [arg_ty];\n@@ -1463,7 +1463,7 @@ mod writeback {\n             alt fcx.opt_node_ty_substs(id) {\n               some(substs) {\n                 let mut new_substs = [];\n-                for subst: ty::t in substs {\n+                for substs.each {|subst|\n                     alt resolve_type_vars_in_type(fcx, sp, subst) {\n                       some(t) { new_substs += [t]; }\n                       none { wbcx.success = false; ret none; }\n@@ -1602,7 +1602,7 @@ mod writeback {\n                            visit_local: visit_local\n                               with *visit::default_visitor()});\n         visit.visit_block(blk, wbcx, visit);\n-        for arg in decl.inputs {\n+        for decl.inputs.each {|arg|\n             resolve_type_vars_for_node(wbcx, arg.ty.span, arg.id);\n         }\n         ret wbcx.success;\n@@ -1986,7 +1986,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         fn matches(name: str, f: ty::field) -> bool {\n             ret str::eq(name, f.ident);\n         }\n-        for f: ast::field_pat in fields {\n+        for fields.each {|f|\n             alt vec::find(ex_fields, bind matches(f.ident, _)) {\n               some(field) {\n                 check_pat(pcx, f.pat, field.mt.ty);\n@@ -2019,7 +2019,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                       fields\", vec::len(ex_elts), e_count]);\n         }\n         let mut i = 0u;\n-        for elt in elts {\n+        for elts.each {|elt|\n             check_pat(pcx, elt, ex_elts[i]);\n             i += 1u;\n         }\n@@ -2209,7 +2209,7 @@ fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n         origin: method_origin, self_sub: option<self_subst>}> {\n     #debug(\"lookup_method_inner_: %? %? %s\", ms, parent, name);\n     let mut i = 0u;\n-    for m in ms  {\n+    for ms.each {|m|\n        if m.ident == name {\n           let fty = ty::mk_fn(tcx, {proto: ast::proto_box with m.fty});\n           if ty::type_has_vars(fty) {\n@@ -2261,7 +2261,7 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n     alt ty::get(ty).struct {\n       ty::ty_param(n, did) {\n         let mut bound_n = 0u;\n-        for bound in *tcx.ty_param_bounds.get(did.node) {\n+        for vec::each(*tcx.ty_param_bounds.get(did.node)) {|bound|\n             alt bound {\n               ty::bound_iface(t) {\n                 let (iid, tps) = alt check ty::get(t).struct {\n@@ -2326,10 +2326,10 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n     let mut result = none, complained = false;\n     std::list::iter(fcx.ccx.impl_map.get(expr.id)) {|impls|\n         if option::is_none(result) {\n-            for @{did, methods, _} in *impls {\n-                alt vec::find(methods, {|m| m.ident == name}) {\n+            for vec::each(*impls) {|im|\n+                alt vec::find(im.methods, {|m| m.ident == name}) {\n                   some(m) {\n-                    let mut {n_tps, ty: self_ty} = impl_self_ty(tcx, did);\n+                    let mut {n_tps, ty: self_ty} = impl_self_ty(tcx, im.did);\n                     let mut {vars, ty: self_ty} = if n_tps > 0u {\n                         bind_params(fcx, self_ty, n_tps)\n                     } else {\n@@ -2536,7 +2536,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let check_args = fn@(check_blocks: bool) -> bool {\n             let mut i = 0u;\n             let mut bot = false;\n-            for a_opt in args {\n+            for args.each {|a_opt|\n                 alt a_opt {\n                   some(a) {\n                     let is_block = alt a.node {\n@@ -2574,7 +2574,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     fn check_call(fcx: @fn_ctxt, sp: span, f: @ast::expr, args: [@ast::expr])\n         -> {fty: ty::t, bot: bool} {\n         let mut args_opt_0: [option<@ast::expr>] = [];\n-        for arg: @ast::expr in args {\n+        for args.each {|arg|\n             args_opt_0 += [some::<@ast::expr>(arg)];\n         }\n \n@@ -2994,7 +2994,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n         //let pattern_ty = fcx.expr_ty(discrim);\n-        for arm: ast::arm in arms {\n+        for arms.each {|arm|\n             let pcx = {\n                 fcx: fcx,\n                 map: pat_util::pat_id_map(tcx.def_map, arm.pats[0]),\n@@ -3003,14 +3003,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                 pat_region: ty::re_scope(parent_block)\n             };\n \n-            for p: @ast::pat in arm.pats {\n-                check_pat(pcx, p, pattern_ty);\n-            }\n+            for arm.pats.each {|p| check_pat(pcx, p, pattern_ty);}\n         }\n         // Now typecheck the blocks.\n         let mut result_ty = next_ty_var(fcx);\n         let mut arm_non_bot = false;\n-        for arm: ast::arm in arms {\n+        for arms.each {|arm|\n             alt arm.guard {\n               some(e) { check_expr_with(fcx, e, ty::mk_bool(tcx)); }\n               none { }\n@@ -3169,14 +3167,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_vec(args, mutbl) {\n         let t: ty::t = next_ty_var(fcx);\n-        for e: @ast::expr in args { bot |= check_expr_with(fcx, e, t); }\n+        for args.each {|e| bot |= check_expr_with(fcx, e, t); }\n         let typ = ty::mk_vec(tcx, {ty: t, mutbl: mutbl});\n         fcx.write_ty(id, typ);\n       }\n       ast::expr_tup(elts) {\n         let mut elt_ts = [];\n         vec::reserve(elt_ts, vec::len(elts));\n-        for e in elts {\n+        for elts.each {|e|\n             check_expr(fcx, e);\n             let ety = fcx.expr_ty(e);\n             elt_ts += [ety];\n@@ -3212,9 +3210,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               }\n             }\n             fcx.write_ty(id, bexpr_t);\n-            for f: spanned<ty::field> in fields_t {\n+            for fields_t.each {|f|\n                 let mut found = false;\n-                for bf: ty::field in base_fields {\n+                for base_fields.each {|bf|\n                     if str::eq(f.node.ident, bf.ident) {\n                         demand::simple(fcx, f.span, bf.mt.ty, f.node.mt.ty);\n                         found = true;\n@@ -3465,7 +3463,7 @@ fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n         node_id = id;\n         alt decl.node {\n           ast::decl_local(ls) {\n-            for l in ls { bot |= check_decl_local(fcx, l); }\n+            for ls.each {|l| bot |= check_decl_local(fcx, l); }\n           }\n           ast::decl_item(_) {/* ignore for now */ }\n         }\n@@ -3501,7 +3499,7 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n     };\n     let mut bot = false;\n     let mut warned = false;\n-    for s: @ast::stmt in blk.node.stmts {\n+    for blk.node.stmts.each {|s|\n         if bot && !warned &&\n                alt s.node {\n                  ast::stmt_decl(@{node: ast::decl_local(_), _}, _) |\n@@ -3588,7 +3586,7 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n           ccx: ccx};\n     let mut disr_vals: [int] = [];\n     let mut disr_val = 0;\n-    for v in vs {\n+    for vs.each {|v|\n         alt v.node.disr_expr {\n           some(e) {\n             check_expr(fcx, e);\n@@ -3666,7 +3664,7 @@ fn check_pred_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n                                              in constraint\");\n               }\n             }\n-            for operand: @ast::expr in operands {\n+            for operands.each {|operand|\n                 if !ast_util::is_constraint_arg(operand) {\n                     let s =\n                         \"constraint args must be slot variables or literals\";\n@@ -3687,11 +3685,10 @@ fn check_pred_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n }\n \n fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n-    let mut c_args;\n     let num_args = vec::len(args);\n-    for c: @ast::constr in cs {\n-        c_args = [];\n-        for a: @spanned<ast::fn_constr_arg> in c.node.args {\n+    for cs.each {|c|\n+        let mut c_args = [];\n+        for c.node.args.each {|a|\n             c_args += [\n                  // \"base\" should not occur in a fn type thing, as of\n                  // yet, b/c we don't allow constraints on the return type\n@@ -3858,7 +3855,7 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method, self_ty: ty::t) {\n \n fn class_types(ccx: @crate_ctxt, members: [@ast::class_member]) -> class_map {\n     let rslt = int_hash::<ty::t>();\n-    for m in members {\n+    for members.each {|m|\n       alt m.node {\n          ast::instance_var(_,t,_,id,_) {\n            rslt.insert(id, ast_ty_to_ty(ccx.tcx, m_collect, t));\n@@ -3897,9 +3894,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         let self_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n         let self_region = ty::re_free(it.id, ty::br_self);\n         let self_ty = replace_self_region(ccx.tcx, self_region, self_ty);\n-        for m in ms {\n-            check_method(ccx, m, self_ty);\n-        }\n+        for ms.each {|m| check_method(ccx, m, self_ty);}\n       }\n       ast::item_class(tps, members, ctor) {\n           let cid = some(it.id);\n@@ -3915,7 +3910,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n                         some(class_t));\n \n           // typecheck the members\n-          for m in members { check_class_member(class_ccx, class_t, m); }\n+          for members.each {|m| check_class_member(class_ccx, class_t, m); }\n       }\n       _ {/* nothing to do */ }\n     }\n@@ -3995,8 +3990,8 @@ mod vtable {\n                       allow_unsafe: bool) -> vtable_res {\n         let tcx = fcx.ccx.tcx;\n         let mut result = [], i = 0u;\n-        for ty in tys {\n-            for bound in *bounds[i] {\n+        for tys.each {|ty|\n+            for vec::each(*bounds[i]) {|bound|\n                 alt bound {\n                   ty::bound_iface(i_ty) {\n                     let i_ty = ty::substitute_type_params(tcx, tys, i_ty);\n@@ -4022,7 +4017,7 @@ mod vtable {\n         alt ty::get(ty).struct {\n           ty::ty_param(n, did) {\n             let mut n_bound = 0u;\n-            for bound in *tcx.ty_param_bounds.get(did.node) {\n+            for vec::each(*tcx.ty_param_bounds.get(did.node)) {|bound|\n                 alt bound {\n                   ty::bound_iface(ity) {\n                     alt check ty::get(ity).struct {\n@@ -4038,7 +4033,7 @@ mod vtable {\n           }\n           ty::ty_iface(did, tps) if iface_id == did {\n             if !allow_unsafe {\n-                for m in *ty::iface_methods(tcx, did) {\n+                for vec::each(*ty::iface_methods(tcx, did)) {|m|\n                     if ty::type_has_vars(ty::mk_fn(tcx, m.fty)) {\n                         tcx.sess.span_err(\n                             sp, \"a boxed iface with self types may not be \\\n@@ -4057,7 +4052,7 @@ mod vtable {\n             let mut found = none;\n             std::list::iter(isc) {|impls|\n                 if option::is_none(found) {\n-                    for im in *impls {\n+                    for vec::each(*impls) {|im|\n                         let match = alt ty::impl_iface(tcx, im.did) {\n                           some(ity) {\n                             alt check ty::get(ity).struct {"}, {"sha": "537517491904cf0fb5970a27d6bfa8d551d285c6", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -46,7 +46,7 @@ fn field_expr(f: ast::field) -> @ast::expr { ret f.node.expr; }\n \n fn field_exprs(fields: [ast::field]) -> [@ast::expr] {\n     let mut es = [];\n-    for f: ast::field in fields { es += [f.node.expr]; }\n+    for fields.each {|f| es += [f.node.expr]; }\n     ret es;\n }\n "}, {"sha": "f2e5419d325042d405a5899c82784d4423d47482", "filename": "src/rustc/util/filesearch.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Ffilesearch.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -67,20 +67,23 @@ fn mk_filesearch(maybe_sysroot: option<path>,\n \n // FIXME #1001: This can't be an obj method\n fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> option<T> {\n-    for lib_search_path in filesearch.lib_search_paths() {\n+    let mut rslt = none;\n+    for filesearch.lib_search_paths().each {|lib_search_path|\n         #debug(\"searching %s\", lib_search_path);\n-        for path in os::list_dir_path(lib_search_path) {\n+        for os::list_dir_path(lib_search_path).each {|path|\n             #debug(\"testing %s\", path);\n             let maybe_picked = pick(path);\n             if option::is_some(maybe_picked) {\n                 #debug(\"picked %s\", path);\n-                ret maybe_picked;\n+                rslt = maybe_picked;\n+                break;\n             } else {\n                 #debug(\"rejected %s\", path);\n             }\n         }\n+        if option::is_some(rslt) { break; }\n     }\n-    ret option::none;\n+    ret rslt;\n }\n \n fn relative_target_lib_path(target_triple: str) -> [path] {"}, {"sha": "6be2f415c2ce822b7664e6625a891403430d5cd5", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -73,7 +73,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         alt ident { some(i) { s += \" \"; s += i; } _ { } }\n         s += \"(\";\n         let mut strs = [];\n-        for a: arg in inputs { strs += [fn_input_to_str(cx, a)]; }\n+        for inputs.each {|a| strs += [fn_input_to_str(cx, a)]; }\n         s += str::connect(strs, \", \");\n         s += \")\";\n         if ty::get(output).struct != ty_nil {\n@@ -139,12 +139,12 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       ty_type { \"type\" }\n       ty_rec(elems) {\n         let mut strs: [str] = [];\n-        for fld: field in elems { strs += [field_to_str(cx, fld)]; }\n+        for elems.each {|fld| strs += [field_to_str(cx, fld)]; }\n         \"{\" + str::connect(strs, \",\") + \"}\"\n       }\n       ty_tup(elems) {\n         let mut strs = [];\n-        for elem in elems { strs += [ty_to_str(cx, elem)]; }\n+        for elems.each {|elem| strs += [ty_to_str(cx, elem)]; }\n         \"(\" + str::connect(strs, \",\") + \")\"\n       }\n       ty_fn(f) {\n@@ -179,7 +179,7 @@ fn constr_to_str(c: @constr) -> str {\n fn constrs_str(constrs: [@constr]) -> str {\n     let mut s = \"\";\n     let mut colon = true;\n-    for c: @constr in constrs {\n+    for constrs.each {|c|\n         if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += constr_to_str(c);\n     }"}, {"sha": "04282bfecf5ad808da53975341c2624b3b94f2ae", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -59,7 +59,7 @@ fn usage() {\n \n     println(\"Usage: rustdoc [options] <cratefile>\\n\");\n     println(\"Options:\\n\");\n-    for opt in opts() {\n+    for opts().each {|opt|\n         println(#fmt(\"    %s\", tuple::second(opt)));\n     }\n     println(\"\");"}, {"sha": "7057dc67e65c46e53ed5d34f172da9b97b0beb66", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -328,7 +328,7 @@ fn write_mod_contents(\n         write_index(ctxt, option::get(doc.index));\n     }\n \n-    for itemtag in doc.items {\n+    for doc.items.each {|itemtag|\n         write_item(ctxt, itemtag);\n     }\n }\n@@ -381,7 +381,7 @@ fn write_index(ctxt: ctxt, index: doc::index) {\n         ret;\n     }\n \n-    for entry in index.entries {\n+    for index.entries.each {|entry|\n         let header = header_text_(entry.kind, entry.name);\n         let id = entry.link;\n         if option::is_some(entry.brief) {\n@@ -431,7 +431,7 @@ fn write_nmod(ctxt: ctxt, doc: doc::nmoddoc) {\n         write_index(ctxt, option::get(doc.index));\n     }\n \n-    for fndoc in doc.fns {\n+    for doc.fns.each {|fndoc|\n         write_item_header(ctxt, doc::fntag(fndoc));\n         write_fn(ctxt, fndoc);\n     }"}, {"sha": "1ab6edcf5ec61d6427de481d69d9c1f1a16a42c2", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -82,13 +82,13 @@ fn build_reexport_def_set(srv: astsrv::srv) -> def_set {\n     let assoc_list = astsrv::exec(srv) {|ctxt|\n         let def_set = common::new_def_hash();\n         ctxt.exp_map.items {|_id, defs|\n-            for def in defs {\n+            for defs.each {|def|\n                 if def.reexp {\n                     def_set.insert(def.id, ());\n                 }\n             }\n         }\n-        for def in find_reexport_impls(ctxt) {\n+        for find_reexport_impls(ctxt).each {|def|\n             def_set.insert(def, ());\n         }\n         to_assoc_list(def_set)\n@@ -137,7 +137,7 @@ fn build_reexport_def_map(\n     fn fold_mod(fold: fold::fold<ctxt>, doc: doc::moddoc) -> doc::moddoc {\n         let doc = fold::default_seq_fold_mod(fold, doc);\n \n-        for item in doc.items {\n+        for doc.items.each {|item|\n             let def_id = ast_util::local_def(item.id());\n             if fold.ctxt.def_set.contains_key(def_id) {\n                 fold.ctxt.def_map.insert(def_id, item);\n@@ -150,7 +150,7 @@ fn build_reexport_def_map(\n     fn fold_nmod(fold: fold::fold<ctxt>, doc: doc::nmoddoc) -> doc::nmoddoc {\n         let doc = fold::default_seq_fold_nmod(fold, doc);\n \n-        for fndoc in doc.fns {\n+        for doc.fns.each {|fndoc|\n             let def_id = ast_util::local_def(fndoc.id());\n             if fold.ctxt.def_set.contains_key(def_id) {\n                 fold.ctxt.def_map.insert(def_id, doc::fntag(fndoc));\n@@ -184,7 +184,7 @@ fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n             let modpath = ast_map::path_to_str(vec::init(*path));\n \n             let mut reexportdocs = [];\n-            for def in defs {\n+            for defs.each {|def|\n                 if !def.reexp { cont; }\n                 alt def_map.find(def.id) {\n                   some(itemtag) {\n@@ -206,7 +206,8 @@ fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n             }\n         }\n \n-        for (path, doc) in find_reexport_impl_docs(ctxt, def_map) {\n+        for find_reexport_impl_docs(ctxt, def_map).each {|elt|\n+            let (path, doc) = elt;\n             let docs = alt path_map.find(path) {\n               some(docs) { docs + [(doc)] }\n               none { [doc] }\n@@ -272,7 +273,7 @@ fn for_each_reexported_impl(\n         let all_impls = all_impls(m);\n         alt check ctxt.impl_map.get(mod_id) {\n           list::cons(impls, @list::nil) {\n-            for i in *impls {\n+            for vec::each(*impls) {|i|\n                 // This impl is not an item in the current mod\n                 if !all_impls.contains_key(i.did) {\n                     // Ignore external impls because I don't\n@@ -289,7 +290,7 @@ fn for_each_reexported_impl(\n \n fn all_impls(m: ast::_mod) -> map::set<ast::def_id> {\n     let all_impls = common::new_def_hash();\n-    for item in m.items {\n+    for m.items.each {|item|\n         alt item.node {\n           ast::item_impl(_, _, _, _) {\n             all_impls.insert(ast_util::local_def(item.id), ());"}, {"sha": "f7929062c6d06a9e9b68c5b345465679837dd6ca", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -94,7 +94,7 @@ fn sectionalize(desc: option<str>) -> (option<str>, [doc::section]) {\n     let mut current_section = none;\n     let mut sections = [];\n \n-    for line in lines {\n+    for lines.each {|line|\n         alt parse_header(line) {\n           some(header) {\n             if option::is_some(current_section) {"}, {"sha": "9c26221960ca1a4f764cb9948ea25a4b54a008e6", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -6,7 +6,7 @@ fn alist_add<A: copy, B: copy>(lst: alist<A,B>, k: A, v: B) {\n \n fn alist_get<A: copy, B: copy>(lst: alist<A,B>, k: A) -> B {\n     let eq_fn = lst.eq_fn;\n-    for pair in lst.data {\n+    for lst.data.each {|pair|\n         let (ki, vi) = pair; // copy req'd for alias analysis\n         if eq_fn(k, ki) { ret vi; }\n     }"}, {"sha": "9b2fcadd2c5d7515093c935535170b16c38db52f", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -25,7 +25,7 @@ type aminoacids = {ch: char, prob: u32};\n fn make_cumulative(aa: [aminoacids]) -> [aminoacids] {\n     let mut cp: u32 = 0u32;\n     let mut ans: [aminoacids] = [];\n-    for a: aminoacids in aa { cp += a.prob; ans += [{ch: a.ch, prob: cp}]; }\n+    for aa.each {|a| cp += a.prob; ans += [{ch: a.ch, prob: cp}]; }\n     ret ans;\n }\n "}, {"sha": "12f9ab94cf37304f2989346ae5282cf7649e9327", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -75,7 +75,7 @@ fn stress(num_tasks: int) {\n         results += [task::future_result(builder)];\n         task::run(builder) {|| stress_task(i); }\n     }\n-    for r in results { future::get(r); }\n+    for results.each {|r| future::get(r); }\n }\n \n fn main(argv: [str]) {"}, {"sha": "d2820f32ff9b653986f3414d276c67c955edba83", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -77,7 +77,7 @@ mod map_reduce {\n                          ctrl: chan<ctrl_proto<K2, V>>, inputs: [K1]) ->\n        [joinable_task] {\n         let tasks = [];\n-        for i in inputs {\n+        for inputs.each {|i|\n             let m = map, c = ctrl, ii = i;\n             tasks += [task::spawn_joinable {|| map_task(m, c, ii)}];\n         }\n@@ -201,7 +201,7 @@ mod map_reduce {\n         }\n         treemap::traverse(reducers, finish);\n \n-        for t in tasks { task::join(t); }\n+        for tasks.each {|t| task::join(t); }\n     }\n }\n \n@@ -218,7 +218,7 @@ fn main(argv: [str]) {\n     }\n \n     let iargs = [];\n-    for a in vec::slice(argv, 1u, vec::len(argv)) {\n+    vec::iter_between(argv, 1u, vec::len(argv)) {|a|\n         iargs += [str::bytes(a)];\n     }\n "}, {"sha": "75afbe33569c256f72796df6f6127456840f4775", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -61,7 +61,7 @@ mod map_reduce {\n     fn start_mappers(ctrl: chan<ctrl_proto>, -inputs: [str]) ->\n        [future::future<task::task_result>] {\n         let mut results = [];\n-        for i: str in inputs {\n+        for inputs.each {|i|\n             let builder = task::builder();\n             results += [task::future_result(builder)];\n             task::run(builder) {|| map_task(ctrl, i)}\n@@ -174,7 +174,7 @@ mod map_reduce {\n \n         reducers.values {|v| send(v, done); }\n \n-        for r in results { future::get(r); }\n+        for results.each {|r| future::get(r); }\n     }\n }\n "}, {"sha": "c9f933012780d3afa5d08e83cda855368e74ece1", "filename": "src/test/compile-fail/block-must-not-have-result-for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -1,7 +1,7 @@\n // error-pattern:mismatched types: expected `()` but found `bool`\n \n fn main() {\n-    for i in [0] {\n+    for vec::iter([0]) {|_i|\n         true\n     }\n }\n\\ No newline at end of file"}, {"sha": "73f8eb90963d9f12a829c2eaa46269fe06ad9294", "filename": "src/test/compile-fail/unsafe-for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -2,5 +2,5 @@\n \n fn main() {\n     let v: [mut {mut x: int}] = [mut {mut x: 1}];\n-    for x in v { v[0] = {mut x: 2}; log(debug, x); }\n+    for v.each {|x| v[0] = {mut x: 2}; log(debug, x); }\n }"}, {"sha": "2bb39d057bba9a7a21d4fdfd8f5c63cf40e8641f", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -2,7 +2,7 @@ fn concat<T: copy>(v: [const [const T]]) -> [T] {\n     let mut r = [];\n \n     // Earlier versions of our type checker accepted this:\n-    for inner: [T] in v {\n+    for v.each {|inner|\n         //!^ ERROR found `[const 'a]` (values differ in mutability)\n         r += inner;\n     }"}, {"sha": "f0a7681acfe8470a2306b1d540becb7c9be8869e", "filename": "src/test/run-pass/argv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fargv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fargv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargv.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -1,5 +1,5 @@\n fn main(args: [str]) {\n     let vs: [str] = [\"hi\", \"there\", \"this\", \"is\", \"a\", \"vec\"];\n     let vvs: [[str]] = [args, vs];\n-    for vs: [str] in vvs { for s: str in vs { log(debug, s); } }\n+    for vvs.each {|vs| for vs.each {|s| log(debug, s); } }\n }"}, {"sha": "223aca32bcbe278b321c78ed034e8d29ceb6b338", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let mut sum = 0;\n-    for x in [1, 2, 3, 4, 5] { sum += x; }\n+    for vec::each([1, 2, 3, 4, 5]) {|x| sum += x; }\n     assert (sum == 15);\n }"}, {"sha": "8e868a186122881cbc5681f0ec41ce5d1c27122d", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -1,4 +1,4 @@\n-fn iter_vec<T>(v: [T], f: fn(T)) { for x: T in v { f(x); } }\n+fn iter_vec<T>(v: [T], f: fn(T)) { for v.each {|x| f(x); } }\n \n fn main() {\n     let v = [1, 2, 3, 4, 5, 6, 7];"}, {"sha": "bcb1ea761516f114fb735295ae1aaead449416ee", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -1,4 +1,4 @@\n-fn iter_vec<T>(v: [T], f: fn(T)) { for x: T in v { f(x); } }\n+fn iter_vec<T>(v: [T], f: fn(T)) { for v.each {|x| f(x); } }\n \n fn main() {\n     let v = [1, 2, 3, 4, 5];"}, {"sha": "9f0d1028e6a8e864b0bff11c2554be172e03b7c3", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -6,12 +6,14 @@ fn main() {\n     assert (i == 10);\n     do  { i += 1; if i == 20 { break; } } while i < 30\n     assert (i == 20);\n-    for x: int in [1, 2, 3, 4, 5, 6] { if x == 3 { break; } assert (x <= 3); }\n+    for vec::each([1, 2, 3, 4, 5, 6]) {|x|\n+        if x == 3 { break; } assert (x <= 3);\n+    }\n     i = 0;\n     while i < 10 { i += 1; if i % 2 == 0 { cont; } assert (i % 2 != 0); }\n     i = 0;\n     do  { i += 1; if i % 2 == 0 { cont; } assert (i % 2 != 0); } while i < 10\n-    for x: int in [1, 2, 3, 4, 5, 6] {\n+    for vec::each([1, 2, 3, 4, 5, 6]) {|x|\n         if x % 2 == 0 { cont; }\n         assert (x % 2 != 0);\n     }"}, {"sha": "71480c47a7551d3cd43c9127a97fafd337b0854f", "filename": "src/test/run-pass/for-destruct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Ffor-destruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Ffor-destruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-destruct.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    for {x: x, y: y}: {x: int, y: int} in [{x: 10, y: 20}, {x: 30, y: 0}] {\n-        assert (x + y == 30);\n+    for vec::each([{x: 10, y: 20}, {x: 30, y: 0}]) {|elt|\n+        assert (elt.x + elt.y == 30);\n     }\n }"}, {"sha": "572556370a7a26bd52ef4f6484f0cbc6d467ad45", "filename": "src/test/run-pass/for-implicit-copy.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c88e5ef5a7e9c8db4ac56d53ba48c454b8b2010/src%2Ftest%2Frun-pass%2Ffor-implicit-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c88e5ef5a7e9c8db4ac56d53ba48c454b8b2010/src%2Ftest%2Frun-pass%2Ffor-implicit-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-implicit-copy.rs?ref=9c88e5ef5a7e9c8db4ac56d53ba48c454b8b2010", "patch": "@@ -1,8 +0,0 @@\n-fn main() {\n-    let x = [@{mut a: @10, b: @20}];\n-    for @{a, b} in x {\n-        assert *a == 10;\n-        (*x[0]).a = @30;\n-        assert *a == 10;\n-    }\n-}"}, {"sha": "177fd1f5c541aae107900feba80dc55d958c70e8", "filename": "src/test/run-pass/for-loop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -1 +1 @@\n-fn main() { let x: [int] = []; for i: int in x { fail \"moop\"; } }\n+fn main() { let x: [int] = []; for x.each {|_i| fail \"moop\"; } }"}, {"sha": "197fda5c2f4dab622141b08b50908a3cba306ebe", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -34,7 +34,7 @@ mod map_reduce {\n     enum ctrl_proto { find_reducer([u8], chan<int>), mapper_done, }\n \n     fn start_mappers(ctrl: chan<ctrl_proto>, inputs: [str]) {\n-        for i: str in inputs {\n+        for inputs.each {|i|\n             task::spawn {|| map_task(ctrl, i); };\n         }\n     }"}, {"sha": "5ad911d553e3a65cb7f2231b294364e95da82110", "filename": "src/test/run-pass/iface-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fiface-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fiface-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiface-generic.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -17,7 +17,7 @@ iface map<T> {\n impl <T> of map<T> for [T] {\n     fn map<U>(f: fn(T) -> U) -> [U] {\n         let mut r = [];\n-        for x in self { r += [f(x)]; }\n+        for self.each {|x| r += [f(x)]; }\n         r\n     }\n }"}, {"sha": "f106e8c8a45b4be21f9b7a6bd9b2b8359cecc872", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -3,12 +3,12 @@\n fn main() {\n     let x = [1, 2, 3];\n     let mut y = 0;\n-    for i: int in x { log(debug, i); y += i; }\n+    for x.each {|i| log(debug, i); y += i; }\n     log(debug, y);\n     assert (y == 6);\n     let s = \"hello there\";\n     let mut i: int = 0;\n-    for c: u8 in s {\n+    for str::each(s) {|c|\n         if i == 0 { assert (c == 'h' as u8); }\n         if i == 1 { assert (c == 'e' as u8); }\n         if i == 2 { assert (c == 'l' as u8); }"}, {"sha": "3fe01a229ee18fbaf740cfa056e16e8e2aabbf76", "filename": "src/test/run-pass/loop-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Floop-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Floop-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-scope.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let x = [10, 20, 30];\n     let mut sum = 0;\n-    for x in x { sum += x; }\n+    for x.each {|x| sum += x; }\n     assert (sum == 60);\n }"}, {"sha": "8db233508551a4378441c66b336db90301453f12", "filename": "src/test/run-pass/main-ivec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fmain-ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fmain-ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmain-ivec.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -1 +1 @@\n-fn main(args: [str]) { for s in args { log(debug, s); } }\n+fn main(args: [str]) { for args.each {|s| log(debug, s); } }"}, {"sha": "8c9d63922a6f011a6f8923a1053a6d3a6b67ba28", "filename": "src/test/run-pass/maybe-mutable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n fn len(v: [const int]) -> uint {\n     let mut i = 0u;\n-    for x: int in v { i += 1u; }\n+    for v.each {|x| i += 1u; }\n     ret i;\n }\n "}, {"sha": "8779cef04704b7a23750abd409360ac099f1f9d4", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -5,7 +5,7 @@ iface monad<A> {\n impl <A> of monad<A> for [A] {\n     fn bind<B>(f: fn(A) -> [B]) -> [B] {\n         let mut r = [];\n-        for elt in self { r += f(elt); }\n+        for self.each {|elt| r += f(elt); }\n         r\n     }\n }"}, {"sha": "461be434b0a01597edecca2d2fde34d5d8dd87f1", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -58,7 +58,7 @@ fn main() {\n         calllink10\n     ];\n     let rng = rand::rng();\n-    for f in fns {\n+    for fns.each {|f|\n         let sz = rng.next() % 256u32 + 256u32;\n         let frame_backoff = rng.next() % 10u32 + 1u32;\n         task::try {|| runtest(f, frame_backoff) };"}, {"sha": "5ec60b38c109e6abe259fc93b1a6dce906c16c02", "filename": "src/test/run-pass/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshadow.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -6,7 +6,7 @@ fn foo(c: [int]) {\n \n     alt none::<int> {\n       some::<int>(_) {\n-        for i: int in c {\n+        for c.each {|i|\n             log(debug, a);\n             let a = 17;\n             b += [a];"}, {"sha": "10a67b9217ce272fb49273cd35953480d9850c96", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -19,10 +19,10 @@ impl util for uint {\n \n impl util<T> for [T] {\n     fn length_() -> uint { vec::len(self) }\n-    fn iter_(f: fn(T)) { for x in self { f(x); } }\n+    fn iter_(f: fn(T)) { for self.each {|x| f(x); } }\n     fn map_<U>(f: fn(T) -> U) -> [U] {\n         let mut r = [];\n-        for elt in self { r += [f(elt)]; }\n+        for self.each {|elt| r += [f(elt)]; }\n         r\n     }\n }"}, {"sha": "0d8fbc735d4aa9ce75db3296a7fab9f7a18f4eaf", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -42,7 +42,7 @@ fn test00() {\n \n     // Read from spawned tasks...\n     let mut sum = 0;\n-    for r in results {\n+    for results.each {|r|\n         i = 0;\n         while i < number_of_messages {\n             let value = recv(po);\n@@ -52,7 +52,7 @@ fn test00() {\n     }\n \n     // Join spawned tasks...\n-    for r in results { future::get(r); }\n+    for results.each {|r| future::get(r); }\n \n     #debug(\"Completed: Final number is: \");\n     log(error, sum);"}, {"sha": "0d282fb69676a899f30dce8d00d029efa55ea74e", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -46,12 +46,12 @@ fn test00() {\n         task::run(builder) {|| test00_start(ch, i, number_of_messages);}\n     }\n     let mut sum: int = 0;\n-    for r in results {\n+    for results.each {|r|\n         i = 0;\n         while i < number_of_messages { sum += recv(po); i = i + 1; }\n     }\n \n-    for r in results { future::get(r); }\n+    for results.each {|r| future::get(r); }\n \n     #debug(\"Completed: Final number is: \");\n     assert (sum ==\n@@ -132,7 +132,7 @@ fn test06() {\n     }\n \n \n-    for r in results { future::get(r); }\n+    for results.each {|r| future::get(r); }\n }\n \n "}, {"sha": "2ba0f47eee4b4e98ed48c689871c85db596ba50a", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c902eafa14803ca9fcb0b59ce852bdabca826c6f/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=c902eafa14803ca9fcb0b59ce852bdabca826c6f", "patch": "@@ -31,7 +31,7 @@ fn main() {\n \n     fn check_str_eq(a: str, b: str) {\n         let mut i: int = 0;\n-        for ab: u8 in a {\n+        for str::each(a) {|ab|\n             log(debug, i);\n             log(debug, ab);\n             let bb: u8 = b[i];"}]}