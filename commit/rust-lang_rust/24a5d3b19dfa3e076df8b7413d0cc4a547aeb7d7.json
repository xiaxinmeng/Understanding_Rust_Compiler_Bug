{"sha": "24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YTVkM2IxOWRmYTNlMDc2ZGY4Yjc0MTNkMGNjNGE1NDdhZWI3ZDc=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-03T21:55:21Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-08T21:59:20Z"}, "message": "Fix the completion labels and tests", "tree": {"sha": "bb49da53786891e9bfd7d063f863416753265d11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb49da53786891e9bfd7d063f863416753265d11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7", "html_url": "https://github.com/rust-lang/rust/commit/24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33c83e72b9b48177a6171fd06a26676679963a4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/33c83e72b9b48177a6171fd06a26676679963a4d", "html_url": "https://github.com/rust-lang/rust/commit/33c83e72b9b48177a6171fd06a26676679963a4d"}], "stats": {"total": 181, "additions": 116, "deletions": 65}, "files": [{"sha": "c5b3c9e277579f0ff44f0684dee2905a72d44280", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7", "patch": "@@ -144,7 +144,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n             .filter_map(|import| {\n                 render_resolution_with_import(\n                     RenderContext::new(ctx),\n-                    ImportEdit { import, import_scope: import_scope.clone() },\n+                    ImportEdit { import, scope: import_scope.clone() },\n                 )\n             }),\n     );\n@@ -690,8 +690,8 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                fn weird_function() (dep::test_mod::TestTrait) -> () DEPRECATED\n                 ct SPECIAL_CONST (dep::test_mod::TestTrait) DEPRECATED\n+                fn weird_function() (dep::test_mod::TestTrait) -> () DEPRECATED\n             \"#]],\n         );\n     }\n@@ -807,7 +807,12 @@ fn main() {\n     bar::baz::Ite$0\n }\"#;\n \n-        check(fixture, expect![[\"st Item (foo::bar::baz::Item)\"]]);\n+        check(\n+            fixture,\n+            expect![[r#\"\n+        st foo::bar::baz::Item\n+        \"#]],\n+        );\n \n         check_edit(\n             \"Item\",\n@@ -825,8 +830,7 @@ fn main() {\n \n         fn main() {\n             bar::baz::Item\n-        }\n-        \"#,\n+        }\"#,\n         );\n     }\n \n@@ -845,7 +849,12 @@ fn main() {\n     Item::TEST_A$0\n }\"#;\n \n-        check(fixture, expect![[\"ct TEST_ASSOC (foo::bar::baz::Item)\"]]);\n+        check(\n+            fixture,\n+            expect![[r#\"\n+        ct TEST_ASSOC (foo::Item)\n+        \"#]],\n+        );\n \n         check_edit(\n             \"TEST_ASSOC\",\n@@ -863,8 +872,7 @@ mod foo {\n \n fn main() {\n     Item::TEST_ASSOC\n-}\n-\"#,\n+}\"#,\n         );\n     }\n \n@@ -885,7 +893,12 @@ fn main() {\n     bar::Item::TEST_A$0\n }\"#;\n \n-        check(fixture, expect![[\"ct TEST_ASSOC (foo::bar::baz::Item)\"]]);\n+        check(\n+            fixture,\n+            expect![[r#\"\n+        ct TEST_ASSOC (foo::bar::Item)\n+    \"#]],\n+        );\n \n         check_edit(\n             \"TEST_ASSOC\",\n@@ -905,8 +918,7 @@ mod foo {\n \n fn main() {\n     bar::Item::TEST_ASSOC\n-}\n-\"#,\n+}\"#,\n         );\n     }\n }"}, {"sha": "44e4a6dfd8a02786347566adb637b34ee6e05d00", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7", "patch": "@@ -11,7 +11,7 @@ use ide_db::{\n     },\n     SymbolKind,\n };\n-use stdx::{impl_from, never};\n+use stdx::{format_to, impl_from, never};\n use syntax::{algo, TextRange};\n use text_edit::TextEdit;\n \n@@ -274,7 +274,7 @@ impl CompletionItem {\n #[derive(Debug, Clone)]\n pub struct ImportEdit {\n     pub import: LocatedImport,\n-    pub import_scope: ImportScope,\n+    pub scope: ImportScope,\n }\n \n impl ImportEdit {\n@@ -284,7 +284,7 @@ impl ImportEdit {\n         let _p = profile::span(\"ImportEdit::to_text_edit\");\n \n         let rewriter = insert_use::insert_use(\n-            &self.import_scope,\n+            &self.scope,\n             mod_path_to_ast(&self.import.import_path),\n             cfg,\n         );\n@@ -302,7 +302,6 @@ impl ImportEdit {\n pub(crate) struct Builder {\n     source_range: TextRange,\n     completion_kind: CompletionKind,\n-    // TODO kb also add a db here, to resolve the completion label?\n     import_to_add: Option<ImportEdit>,\n     label: String,\n     insert_text: Option<String>,\n@@ -322,22 +321,24 @@ impl Builder {\n     pub(crate) fn build(self) -> CompletionItem {\n         let _p = profile::span(\"item::Builder::build\");\n \n-        let label = self.label;\n-        let lookup = self.lookup;\n-        let insert_text = self.insert_text;\n-\n-        if let Some(_import_to_add) = self.import_to_add.as_ref() {\n-            todo!(\"todo kb\")\n-            // let import = &import_to_add.import;\n-            // let item_to_import = import.item_to_import();\n-            // lookup = lookup.or_else(|| Some(label.clone()));\n-            // insert_text = insert_text.or_else(|| Some(label.clone()));\n-            // let display_path = import_to_add.import.display_path();\n-            // if import_to_add.import {\n-            //     label = format!(\"{} ({})\", label, display_path);\n-            // } else {\n-            //     label = display_path.to_string();\n-            // }\n+        let mut label = self.label;\n+        let mut lookup = self.lookup;\n+        let mut insert_text = self.insert_text;\n+\n+        if let Some(original_path) = self\n+            .import_to_add\n+            .as_ref()\n+            .and_then(|import_edit| import_edit.import.original_path.as_ref())\n+        {\n+            lookup = lookup.or_else(|| Some(label.clone()));\n+            insert_text = insert_text.or_else(|| Some(label.clone()));\n+\n+            let original_path_label = original_path.to_string();\n+            if original_path_label.ends_with(&label) {\n+                label = original_path_label;\n+            } else {\n+                format_to!(label, \" ({})\", original_path)\n+            }\n         }\n \n         let text_edit = match self.text_edit {"}, {"sha": "5470914fbfbdf82d561aa292645242e527dfa084", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7", "patch": "@@ -144,7 +144,7 @@ pub fn resolve_completion_edits(\n ) -> Option<Vec<TextEdit>> {\n     let ctx = CompletionContext::new(db, position, config)?;\n     let position_for_import = position_for_import(&ctx, None)?;\n-    let import_scope = ImportScope::find_insert_use_container(position_for_import, &ctx.sema)?;\n+    let scope = ImportScope::find_insert_use_container(position_for_import, &ctx.sema)?;\n \n     let current_module = ctx.sema.scope(position_for_import).module()?;\n     let current_crate = current_module.krate();\n@@ -158,9 +158,10 @@ pub fn resolve_completion_edits(\n                     .zip(Some(candidate))\n             })\n             .find(|(mod_path, _)| mod_path.to_string() == full_import_path)?;\n-    let import = LocatedImport::new(import_path, item_to_import, item_to_import);\n+    let import =\n+        LocatedImport::new(import_path.clone(), item_to_import, item_to_import, Some(import_path));\n \n-    ImportEdit { import, import_scope }.to_text_edit(config.insert_use).map(|edit| vec![edit])\n+    ImportEdit { import, scope }.to_text_edit(config.insert_use).map(|edit| vec![edit])\n }\n \n #[cfg(test)]"}, {"sha": "b3e90717a55413eda7c8bff357b5ea0c2898c39c", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 68, "deletions": 31, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=24a5d3b19dfa3e076df8b7413d0cc4a547aeb7d7", "patch": "@@ -132,11 +132,17 @@ pub struct LocatedImport {\n     pub import_path: ModPath,\n     pub item_to_import: ItemInNs,\n     pub original_item: ItemInNs,\n+    pub original_path: Option<ModPath>,\n }\n \n impl LocatedImport {\n-    pub fn new(import_path: ModPath, item_to_import: ItemInNs, original_item: ItemInNs) -> Self {\n-        Self { import_path, item_to_import, original_item }\n+    pub fn new(\n+        import_path: ModPath,\n+        item_to_import: ItemInNs,\n+        original_item: ItemInNs,\n+        original_path: Option<ModPath>,\n+    ) -> Self {\n+        Self { import_path, item_to_import, original_item, original_path }\n     }\n \n     pub fn original_item_name(&self, db: &RootDatabase) -> Option<Name> {\n@@ -238,7 +244,9 @@ impl<'a> ImportAssets<'a> {\n         let _p = profile::span(\"import_assets::applicable_defs\");\n         let current_crate = self.module_with_candidate.krate();\n \n-        let mod_path = |item| get_mod_path(db, item, &self.module_with_candidate, prefixed);\n+        let mod_path = |item| {\n+            get_mod_path(db, item_for_path_search(db, item)?, &self.module_with_candidate, prefixed)\n+        };\n \n         match &self.import_candidate {\n             ImportCandidate::Path(path_candidate) => {\n@@ -276,7 +284,9 @@ fn path_applicable_imports(\n         Qualifier::Absent => {\n             return items_with_candidate_name\n                 .into_iter()\n-                .filter_map(|item| Some(LocatedImport::new(mod_path(item)?, item, item)))\n+                .filter_map(|item| {\n+                    Some(LocatedImport::new(mod_path(item)?, item, item, mod_path(item)))\n+                })\n                 .collect();\n         }\n         Qualifier::FirstSegmentUnresolved(first_segment, qualifier) => {\n@@ -300,46 +310,69 @@ fn import_for_item(\n     original_item: ItemInNs,\n ) -> Option<LocatedImport> {\n     let _p = profile::span(\"import_assets::import_for_item\");\n-    let (item_candidate, trait_to_import) = match original_item.as_module_def_id() {\n-        Some(module_def_id) => {\n-            match ModuleDef::from(module_def_id).as_assoc_item(db).map(|assoc| assoc.container(db))\n-            {\n-                Some(AssocItemContainer::Trait(trait_)) => {\n-                    let trait_item = ItemInNs::from(ModuleDef::from(trait_));\n-                    (trait_item, Some(trait_item))\n-                }\n-                Some(AssocItemContainer::Impl(impl_)) => {\n-                    (ItemInNs::from(ModuleDef::from(impl_.target_ty(db).as_adt()?)), None)\n-                }\n-                None => (original_item, None),\n-            }\n-        }\n-        None => (original_item, None),\n-    };\n-    let import_path_candidate = mod_path(item_candidate)?;\n \n+    let original_item_candidate = item_for_path_search(db, original_item)?;\n+    let import_path_candidate = mod_path(original_item_candidate)?;\n     let import_path_string = import_path_candidate.to_string();\n+\n     if !import_path_string.contains(unresolved_first_segment)\n         || !import_path_string.contains(unresolved_qualifier)\n     {\n         return None;\n     }\n \n-    let segment_import = find_import_for_segment(db, item_candidate, &unresolved_first_segment)?;\n-    Some(match (segment_import == item_candidate, trait_to_import) {\n+    let segment_import =\n+        find_import_for_segment(db, original_item_candidate, &unresolved_first_segment)?;\n+    let trait_item_to_import = original_item\n+        .as_module_def_id()\n+        .and_then(|module_def_id| {\n+            ModuleDef::from(module_def_id).as_assoc_item(db)?.containing_trait(db)\n+        })\n+        .map(|trait_| ItemInNs::from(ModuleDef::from(trait_)));\n+    Some(match (segment_import == original_item_candidate, trait_item_to_import) {\n         (true, Some(_)) => {\n             // FIXME we should be able to import both the trait and the segment,\n             // but it's unclear what to do with overlapping edits (merge imports?)\n             // especially in case of lazy completion edit resolutions.\n             return None;\n         }\n-        (false, Some(trait_to_import)) => {\n-            LocatedImport::new(mod_path(trait_to_import)?, trait_to_import, original_item)\n-        }\n-        (true, None) => LocatedImport::new(import_path_candidate, item_candidate, original_item),\n-        (false, None) => {\n-            LocatedImport::new(mod_path(segment_import)?, segment_import, original_item)\n+        (false, Some(trait_to_import)) => LocatedImport::new(\n+            mod_path(trait_to_import)?,\n+            trait_to_import,\n+            original_item,\n+            mod_path(original_item),\n+        ),\n+        (true, None) => LocatedImport::new(\n+            import_path_candidate,\n+            original_item_candidate,\n+            original_item,\n+            mod_path(original_item),\n+        ),\n+        (false, None) => LocatedImport::new(\n+            mod_path(segment_import)?,\n+            segment_import,\n+            original_item,\n+            mod_path(original_item),\n+        ),\n+    })\n+}\n+\n+fn item_for_path_search(db: &RootDatabase, item: ItemInNs) -> Option<ItemInNs> {\n+    Some(match item {\n+        ItemInNs::Types(module_def_id) | ItemInNs::Values(module_def_id) => {\n+            let module_def = ModuleDef::from(module_def_id);\n+\n+            match module_def.as_assoc_item(db) {\n+                Some(assoc_item) => match assoc_item.container(db) {\n+                    AssocItemContainer::Trait(trait_) => ItemInNs::from(ModuleDef::from(trait_)),\n+                    AssocItemContainer::Impl(impl_) => {\n+                        ItemInNs::from(ModuleDef::from(impl_.target_ty(db).as_adt()?))\n+                    }\n+                },\n+                None => item,\n+            }\n         }\n+        ItemInNs::Macros(_) => item,\n     })\n }\n \n@@ -420,10 +453,12 @@ fn trait_applicable_items(\n                     }\n \n                     let item = ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?));\n+                    let original_item = assoc_to_item(assoc);\n                     located_imports.insert(LocatedImport::new(\n                         mod_path(item)?,\n                         item,\n-                        assoc_to_item(assoc),\n+                        original_item,\n+                        mod_path(original_item),\n                     ));\n                 }\n                 None::<()>\n@@ -439,10 +474,12 @@ fn trait_applicable_items(\n                 let assoc = function.as_assoc_item(db)?;\n                 if required_assoc_items.contains(&assoc) {\n                     let item = ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?));\n+                    let original_item = assoc_to_item(assoc);\n                     located_imports.insert(LocatedImport::new(\n                         mod_path(item)?,\n                         item,\n-                        assoc_to_item(assoc),\n+                        original_item,\n+                        mod_path(original_item),\n                     ));\n                 }\n                 None::<()>"}]}