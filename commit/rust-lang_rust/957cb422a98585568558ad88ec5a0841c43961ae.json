{"sha": "957cb422a98585568558ad88ec5a0841c43961ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1N2NiNDIyYTk4NTg1NTY4NTU4YWQ4OGVjNWEwODQxYzQzOTYxYWU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-21T22:23:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-21T22:23:06Z"}, "message": "rollup merge of #24439: alexcrichton/fix-archive-assembler\n\nWhen linking an archive statically to an rlib, the compiler will extract all\ncontents of the archive and add them all to the rlib being generated. The\ncurrent method of extraction is to run `ar x`, dumping all files into a\ntemporary directory. Object archives, however, are allowed to have multiple\nentries with the same file name, so there is no method for them to extract their\ncontents into a directory in a lossless fashion.\n\nThis commit adds iterator support to the `ArchiveRO` structure which hooks into\nLLVM's support for reading object archives. This iterator is then used to\ninspect each object in turn and extract it to a unique location for later\nassembly.", "tree": {"sha": "29b2e737d63c21a3c070a308ad5c0cee6fe274d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29b2e737d63c21a3c070a308ad5c0cee6fe274d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/957cb422a98585568558ad88ec5a0841c43961ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/957cb422a98585568558ad88ec5a0841c43961ae", "html_url": "https://github.com/rust-lang/rust/commit/957cb422a98585568558ad88ec5a0841c43961ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/957cb422a98585568558ad88ec5a0841c43961ae/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fc2e12687ba7e48aef1c1d8efc6588a90e24010", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fc2e12687ba7e48aef1c1d8efc6588a90e24010", "html_url": "https://github.com/rust-lang/rust/commit/2fc2e12687ba7e48aef1c1d8efc6588a90e24010"}, {"sha": "9ab0475d940342a670ad323c151db565e6318e08", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ab0475d940342a670ad323c151db565e6318e08", "html_url": "https://github.com/rust-lang/rust/commit/9ab0475d940342a670ad323c151db565e6318e08"}], "stats": {"total": 348, "additions": 264, "deletions": 84}, "files": [{"sha": "bbb2452ca29ee84d7334c1962b52e224859b849e", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/957cb422a98585568558ad88ec5a0841c43961ae/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957cb422a98585568558ad88ec5a0841c43961ae/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=957cb422a98585568558ad88ec5a0841c43961ae", "patch": "@@ -692,11 +692,16 @@ pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n \n impl ArchiveMetadata {\n     fn new(ar: ArchiveRO) -> Option<ArchiveMetadata> {\n-        let data = match ar.read(METADATA_FILENAME) {\n-            Some(data) => data as *const [u8],\n-            None => {\n-                debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n-                return None;\n+        let data = {\n+            let section = ar.iter().find(|sect| {\n+                sect.name() == Some(METADATA_FILENAME)\n+            });\n+            match section {\n+                Some(s) => s.data() as *const [u8],\n+                None => {\n+                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n+                    return None;\n+                }\n             }\n         };\n "}, {"sha": "37d784692fd0e48faf035d1168f6a78cba8e6b11", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/957cb422a98585568558ad88ec5a0841c43961ae/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957cb422a98585568558ad88ec5a0841c43961ae/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=957cb422a98585568558ad88ec5a0841c43961ae", "patch": "@@ -11,13 +11,14 @@\n //! A helper class for dealing with static archives\n \n use std::env;\n-use std::fs;\n+use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Output, Stdio};\n use std::str;\n use syntax::diagnostic::Handler as ErrorHandler;\n+use rustc_llvm::archive_ro::ArchiveRO;\n \n use tempdir::TempDir;\n \n@@ -282,45 +283,61 @@ impl<'a> ArchiveBuilder<'a> {\n                       mut skip: F) -> io::Result<()>\n         where F: FnMut(&str) -> bool,\n     {\n-        let loc = TempDir::new(\"rsar\").unwrap();\n-\n-        // First, extract the contents of the archive to a temporary directory.\n-        // We don't unpack directly into `self.work_dir` due to the possibility\n-        // of filename collisions.\n-        let archive = env::current_dir().unwrap().join(archive);\n-        run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-               \"x\", Some(loc.path()), &[&archive]);\n+        let archive = match ArchiveRO::open(archive) {\n+            Some(ar) => ar,\n+            None => return Err(io::Error::new(io::ErrorKind::Other,\n+                                              \"failed to open archive\")),\n+        };\n \n         // Next, we must rename all of the inputs to \"guaranteed unique names\".\n-        // We move each file into `self.work_dir` under its new unique name.\n+        // We write each file into `self.work_dir` under its new unique name.\n         // The reason for this renaming is that archives are keyed off the name\n         // of the files, so if two files have the same name they will override\n         // one another in the archive (bad).\n         //\n         // We skip any files explicitly desired for skipping, and we also skip\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n-        let files = try!(fs::read_dir(loc.path()));\n-        for file in files {\n-            let file = try!(file).path();\n-            let filename = file.file_name().unwrap().to_str().unwrap();\n-            if skip(filename) { continue }\n+        for file in archive.iter() {\n+            let filename = match file.name() {\n+                Some(s) => s,\n+                None => continue,\n+            };\n             if filename.contains(\".SYMDEF\") { continue }\n+            if skip(filename) { continue }\n \n-            let filename = format!(\"r-{}-{}\", name, filename);\n-            // LLDB (as mentioned in back::link) crashes on filenames of exactly\n-            // 16 bytes in length. If we're including an object file with\n-            // exactly 16-bytes of characters, give it some prefix so that it's\n-            // not 16 bytes.\n-            let filename = if filename.len() == 16 {\n-                format!(\"lldb-fix-{}\", filename)\n-            } else {\n-                filename\n-            };\n-            let new_filename = self.work_dir.path().join(&filename[..]);\n-            try!(fs::rename(&file, &new_filename));\n-            self.members.push(PathBuf::from(filename));\n+            // An archive can contain files of the same name multiple times, so\n+            // we need to be sure to not have them overwrite one another when we\n+            // extract them. Consequently we need to find a truly unique file\n+            // name for us!\n+            let mut new_filename = String::new();\n+            for n in 0.. {\n+                let n = if n == 0 {String::new()} else {format!(\"-{}\", n)};\n+                new_filename = format!(\"r{}-{}-{}\", n, name, filename);\n+\n+                // LLDB (as mentioned in back::link) crashes on filenames of\n+                // exactly\n+                // 16 bytes in length. If we're including an object file with\n+                //    exactly 16-bytes of characters, give it some prefix so\n+                //    that it's not 16 bytes.\n+                new_filename = if new_filename.len() == 16 {\n+                    format!(\"lldb-fix-{}\", new_filename)\n+                } else {\n+                    new_filename\n+                };\n+\n+                let present = self.members.iter().filter_map(|p| {\n+                    p.file_name().and_then(|f| f.to_str())\n+                }).any(|s| s == new_filename);\n+                if !present {\n+                    break\n+                }\n+            }\n+            let dst = self.work_dir.path().join(&new_filename);\n+            try!(try!(File::create(&dst)).write_all(file.data()));\n+            self.members.push(PathBuf::from(new_filename));\n         }\n+\n         Ok(())\n     }\n }"}, {"sha": "22dea4757ed662a8942c198ab7ac0e7b5a38b655", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/957cb422a98585568558ad88ec5a0841c43961ae/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957cb422a98585568558ad88ec5a0841c43961ae/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=957cb422a98585568558ad88ec5a0841c43961ae", "patch": "@@ -46,6 +46,7 @@\n extern crate syntax;\n extern crate libc;\n extern crate serialize;\n+extern crate rustc_llvm;\n #[macro_use] extern crate log;\n \n pub mod abi;"}, {"sha": "c8f3e204c4e10d0488d7e89cac812dd6c8f6ac9c", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/957cb422a98585568558ad88ec5a0841c43961ae/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957cb422a98585568558ad88ec5a0841c43961ae/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=957cb422a98585568558ad88ec5a0841c43961ae", "patch": "@@ -10,15 +10,23 @@\n \n //! A wrapper around LLVM's archive (.a) code\n \n-use libc;\n use ArchiveRef;\n \n use std::ffi::CString;\n-use std::slice;\n use std::path::Path;\n+use std::slice;\n+use std::str;\n \n-pub struct ArchiveRO {\n-    ptr: ArchiveRef,\n+pub struct ArchiveRO { ptr: ArchiveRef }\n+\n+pub struct Iter<'a> {\n+    archive: &'a ArchiveRO,\n+    ptr: ::ArchiveIteratorRef,\n+}\n+\n+pub struct Child<'a> {\n+    name: Option<&'a str>,\n+    data: &'a [u8],\n }\n \n impl ArchiveRO {\n@@ -52,18 +60,9 @@ impl ArchiveRO {\n         }\n     }\n \n-    /// Reads a file in the archive\n-    pub fn read<'a>(&'a self, file: &str) -> Option<&'a [u8]> {\n+    pub fn iter(&self) -> Iter {\n         unsafe {\n-            let mut size = 0 as libc::size_t;\n-            let file = CString::new(file).unwrap();\n-            let ptr = ::LLVMRustArchiveReadSection(self.ptr, file.as_ptr(),\n-                                                   &mut size);\n-            if ptr.is_null() {\n-                None\n-            } else {\n-                Some(slice::from_raw_parts(ptr as *const u8, size as usize))\n-            }\n+            Iter { ptr: ::LLVMRustArchiveIteratorNew(self.ptr), archive: self }\n         }\n     }\n }\n@@ -75,3 +74,47 @@ impl Drop for ArchiveRO {\n         }\n     }\n }\n+\n+impl<'a> Iterator for Iter<'a> {\n+    type Item = Child<'a>;\n+\n+    fn next(&mut self) -> Option<Child<'a>> {\n+        unsafe {\n+            let ptr = ::LLVMRustArchiveIteratorCurrent(self.ptr);\n+            if ptr.is_null() {\n+                return None\n+            }\n+            let mut name_len = 0;\n+            let name_ptr = ::LLVMRustArchiveChildName(ptr, &mut name_len);\n+            let mut data_len = 0;\n+            let data_ptr = ::LLVMRustArchiveChildData(ptr, &mut data_len);\n+            let child = Child {\n+                name: if name_ptr.is_null() {\n+                    None\n+                } else {\n+                    let name = slice::from_raw_parts(name_ptr as *const u8,\n+                                                     name_len as usize);\n+                    str::from_utf8(name).ok().map(|s| s.trim())\n+                },\n+                data: slice::from_raw_parts(data_ptr as *const u8,\n+                                            data_len as usize),\n+            };\n+            ::LLVMRustArchiveIteratorNext(self.ptr);\n+            Some(child)\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for Iter<'a> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            ::LLVMRustArchiveIteratorFree(self.ptr);\n+        }\n+    }\n+}\n+\n+impl<'a> Child<'a> {\n+    pub fn name(&self) -> Option<&'a str> { self.name }\n+    pub fn data(&self) -> &'a [u8] { self.data }\n+}"}, {"sha": "104fc6700cca960c4af524acbe25baa937bec67c", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/957cb422a98585568558ad88ec5a0841c43961ae/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957cb422a98585568558ad88ec5a0841c43961ae/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=957cb422a98585568558ad88ec5a0841c43961ae", "patch": "@@ -30,6 +30,7 @@\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(staged_api)]\n+#![feature(unsafe_destructor)]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n@@ -488,9 +489,12 @@ pub type PassRef = *mut Pass_opaque;\n #[allow(missing_copy_implementations)]\n pub enum TargetMachine_opaque {}\n pub type TargetMachineRef = *mut TargetMachine_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum Archive_opaque {}\n pub type ArchiveRef = *mut Archive_opaque;\n+pub enum ArchiveIterator_opaque {}\n+pub type ArchiveIteratorRef = *mut ArchiveIterator_opaque;\n+pub enum ArchiveChild_opaque {}\n+pub type ArchiveChildRef = *mut ArchiveChild_opaque;\n #[allow(missing_copy_implementations)]\n pub enum Twine_opaque {}\n pub type TwineRef = *mut Twine_opaque;\n@@ -2051,8 +2055,14 @@ extern {\n     pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n \n     pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n-    pub fn LLVMRustArchiveReadSection(AR: ArchiveRef, name: *const c_char,\n-                                      out_len: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveIteratorNew(AR: ArchiveRef) -> ArchiveIteratorRef;\n+    pub fn LLVMRustArchiveIteratorNext(AIR: ArchiveIteratorRef);\n+    pub fn LLVMRustArchiveIteratorCurrent(AIR: ArchiveIteratorRef) -> ArchiveChildRef;\n+    pub fn LLVMRustArchiveChildName(ACR: ArchiveChildRef,\n+                                    size: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveChildData(ACR: ArchiveChildRef,\n+                                    size: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveIteratorFree(AIR: ArchiveIteratorRef);\n     pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n \n     pub fn LLVMRustSetDLLExportStorageClass(V: ValueRef);"}, {"sha": "e06a7b882e6560eb759e0f60e91337d16c3c5ad0", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/957cb422a98585568558ad88ec5a0841c43961ae/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957cb422a98585568558ad88ec5a0841c43961ae/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=957cb422a98585568558ad88ec5a0841c43961ae", "patch": "@@ -63,13 +63,13 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         let file = &file[3..file.len() - 5]; // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n         for i in 0.. {\n-            let bc_encoded = time(sess.time_passes(),\n-                                  &format!(\"check for {}.{}.bytecode.deflate\", name, i),\n-                                  (),\n-                                  |_| {\n-                                      archive.read(&format!(\"{}.{}.bytecode.deflate\",\n-                                                           file, i))\n-                                  });\n+            let filename = format!(\"{}.{}.bytecode.deflate\", file, i);\n+            let msg = format!(\"check for {}\", filename);\n+            let bc_encoded = time(sess.time_passes(), &msg, (), |_| {\n+                archive.iter().find(|section| {\n+                    section.name() == Some(&filename[..])\n+                })\n+            });\n             let bc_encoded = match bc_encoded {\n                 Some(data) => data,\n                 None => {\n@@ -79,9 +79,10 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                                            path.display()));\n                     }\n                     // No more bitcode files to read.\n-                    break;\n-                },\n+                    break\n+                }\n             };\n+            let bc_encoded = bc_encoded.data();\n \n             let bc_decoded = if is_versioned_bytecode_format(bc_encoded) {\n                 time(sess.time_passes(), &format!(\"decode {}.{}.bc\", file, i), (), |_| {"}, {"sha": "492993ec9a96566d6a5e1ee37f358d0a22e5bcca", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 55, "deletions": 24, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/957cb422a98585568558ad88ec5a0841c43961ae/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/957cb422a98585568558ad88ec5a0841c43961ae/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=957cb422a98585568558ad88ec5a0841c43961ae", "patch": "@@ -770,37 +770,68 @@ LLVMRustOpenArchive(char *path) {\n     return ret;\n }\n \n-extern \"C\" const char*\n #if LLVM_VERSION_MINOR >= 6\n-LLVMRustArchiveReadSection(OwningBinary<Archive> *ob, char *name, size_t *size) {\n-\n-    Archive *ar = ob->getBinary();\n+typedef OwningBinary<Archive> RustArchive;\n+#define GET_ARCHIVE(a) ((a)->getBinary())\n #else\n-LLVMRustArchiveReadSection(Archive *ar, char *name, size_t *size) {\n+typedef Archive RustArchive;\n+#define GET_ARCHIVE(a) (a)\n #endif\n \n-    Archive::child_iterator child = ar->child_begin(),\n-                              end = ar->child_end();\n-    for (; child != end; ++child) {\n-        ErrorOr<StringRef> name_or_err = child->getName();\n-        if (name_or_err.getError()) continue;\n-        StringRef sect_name = name_or_err.get();\n-        if (sect_name.trim(\" \") == name) {\n-            StringRef buf = child->getBuffer();\n-            *size = buf.size();\n-            return buf.data();\n-        }\n-    }\n-    return NULL;\n+extern \"C\" void\n+LLVMRustDestroyArchive(RustArchive *ar) {\n+    delete ar;\n+}\n+\n+struct RustArchiveIterator {\n+    Archive::child_iterator cur;\n+    Archive::child_iterator end;\n+};\n+\n+extern \"C\" RustArchiveIterator*\n+LLVMRustArchiveIteratorNew(RustArchive *ra) {\n+    Archive *ar = GET_ARCHIVE(ra);\n+    RustArchiveIterator *rai = new RustArchiveIterator();\n+    rai->cur = ar->child_begin();\n+    rai->end = ar->child_end();\n+    return rai;\n+}\n+\n+extern \"C\" const Archive::Child*\n+LLVMRustArchiveIteratorCurrent(RustArchiveIterator *rai) {\n+    if (rai->cur == rai->end)\n+        return NULL;\n+    const Archive::Child &ret = *rai->cur;\n+    return &ret;\n }\n \n extern \"C\" void\n-#if LLVM_VERSION_MINOR >= 6\n-LLVMRustDestroyArchive(OwningBinary<Archive> *ar) {\n-#else\n-LLVMRustDestroyArchive(Archive *ar) {\n-#endif\n-    delete ar;\n+LLVMRustArchiveIteratorNext(RustArchiveIterator *rai) {\n+    if (rai->cur == rai->end)\n+        return;\n+    ++rai->cur;\n+}\n+\n+extern \"C\" void\n+LLVMRustArchiveIteratorFree(RustArchiveIterator *rai) {\n+    delete rai;\n+}\n+\n+extern \"C\" const char*\n+LLVMRustArchiveChildName(const Archive::Child *child, size_t *size) {\n+    ErrorOr<StringRef> name_or_err = child->getName();\n+    if (name_or_err.getError())\n+        return NULL;\n+    StringRef name = name_or_err.get();\n+    *size = name.size();\n+    return name.data();\n+}\n+\n+extern \"C\" const char*\n+LLVMRustArchiveChildData(Archive::Child *child, size_t *size) {\n+    StringRef buf = child->getBuffer();\n+    *size = buf.size();\n+    return buf.data();\n }\n \n extern \"C\" void"}, {"sha": "72c2d389e2aac7cf9beb1426568f50d33b88b002", "filename": "src/test/run-make/archive-duplicate-names/Makefile", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/957cb422a98585568558ad88ec5a0841c43961ae/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/957cb422a98585568558ad88ec5a0841c43961ae/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2FMakefile?ref=957cb422a98585568558ad88ec5a0841c43961ae", "patch": "@@ -0,0 +1,11 @@\n+-include ../tools.mk\n+\n+all:\n+\tmkdir $(TMPDIR)/a\n+\tmkdir $(TMPDIR)/b\n+\t$(CC) -c -o $(TMPDIR)/a/foo.o foo.c\n+\t$(CC) -c -o $(TMPDIR)/b/foo.o bar.c\n+\tar crus $(TMPDIR)/libfoo.a $(TMPDIR)/a/foo.o $(TMPDIR)/b/foo.o\n+\t$(RUSTC) foo.rs\n+\t$(RUSTC) bar.rs\n+\t$(call RUN,bar)"}, {"sha": "a25fa10f4d3ee51dabea7ba2efd91f8bf5846d1a", "filename": "src/test/run-make/archive-duplicate-names/bar.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/957cb422a98585568558ad88ec5a0841c43961ae/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Fbar.c", "raw_url": "https://github.com/rust-lang/rust/raw/957cb422a98585568558ad88ec5a0841c43961ae/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Fbar.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Fbar.c?ref=957cb422a98585568558ad88ec5a0841c43961ae", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+void bar() {}"}, {"sha": "1200a6de8e2e063302cd4b4caa8f84091f1cd6c8", "filename": "src/test/run-make/archive-duplicate-names/bar.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/957cb422a98585568558ad88ec5a0841c43961ae/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957cb422a98585568558ad88ec5a0841c43961ae/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Fbar.rs?ref=957cb422a98585568558ad88ec5a0841c43961ae", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate foo;\n+\n+fn main() {\n+    foo::baz();\n+}"}, {"sha": "61d5d15407891a0a497a36c4a38dd7ab2b3526dc", "filename": "src/test/run-make/archive-duplicate-names/foo.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/957cb422a98585568558ad88ec5a0841c43961ae/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Ffoo.c", "raw_url": "https://github.com/rust-lang/rust/raw/957cb422a98585568558ad88ec5a0841c43961ae/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Ffoo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Ffoo.c?ref=957cb422a98585568558ad88ec5a0841c43961ae", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+void foo() {}"}, {"sha": "24b4734f2cd334fb6d10cbe6100913d868e97512", "filename": "src/test/run-make/archive-duplicate-names/foo.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/957cb422a98585568558ad88ec5a0841c43961ae/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957cb422a98585568558ad88ec5a0841c43961ae/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Ffoo.rs?ref=957cb422a98585568558ad88ec5a0841c43961ae", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+\n+#[link(name = \"foo\", kind = \"static\")]\n+extern {\n+    fn foo();\n+    fn bar();\n+}\n+\n+pub fn baz() {\n+    unsafe {\n+        foo();\n+        bar();\n+    }\n+}"}]}