{"sha": "95dc353006c23a4493b3d08ba33680e51c2107c8", "node_id": "C_kwDOAAsO6NoAKDk1ZGMzNTMwMDZjMjNhNDQ5M2IzZDA4YmEzMzY4MGU1MWMyMTA3Yzg", "commit": {"author": {"name": "jmaargh", "email": "jmaargh@gmail.com", "date": "2022-04-09T15:42:26Z"}, "committer": {"name": "jmaargh", "email": "jmaargh@gmail.com", "date": "2022-06-19T19:46:49Z"}, "message": "Fix documentation for with_capacity and reserve families of methods\n\nDocumentation for the following methods\n\n    with_capacity\n    with_capacity_in\n    with_capacity_and_hasher\n    reserve\n    reserve_exact\n    try_reserve\n    try_reserve_exact\n\nwas inconsistent and often not entirely correct where they existed on the following types\n\n    Vec\n    VecDeque\n    String\n    OsString\n    PathBuf\n    BinaryHeap\n    HashSet\n    HashMap\n    BufWriter\n    LineWriter\n\nsince the allocator is allowed to allocate more than the requested capacity in all such cases, and will frequently \"allocate\" much more in the case of zero-sized types (I also checked BufReader, but there the docs appear to be accurate as it appears to actually allocate the exact capacity).\n\nSome effort was made to make the documentation more consistent between types as well.\n\nFix with_capacity* methods for Vec\n\nFix *reserve*  methods for Vec\n\nFix docs for *reserve* methods of VecDeque\n\nFix docs for String::with_capacity\n\nFix docs for *reserve* methods of String\n\nFix docs for OsString::with_capacity\n\nFix docs for *reserve* methods on OsString\n\nFix docs for with_capacity* methods on HashSet\n\nFix docs for *reserve methods of HashSet\n\nFix docs for with_capacity* methods of HashMap\n\nFix docs for *reserve methods on HashMap\n\nFix expect messages about OOM in doctests\n\nFix docs for BinaryHeap::with_capacity\n\nFix docs for *reserve* methods of BinaryHeap\n\nFix typos\n\nFix docs for with_capacity on BufWriter and LineWriter\n\nFix consistent use of `hasher` between `HashMap` and `HashSet`\n\nFix warning in doc test\n\nAdd test for capacity of vec with ZST\n\nFix doc test error", "tree": {"sha": "138406c26d52c5519fc9988eba85d25dc88b3858", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/138406c26d52c5519fc9988eba85d25dc88b3858"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95dc353006c23a4493b3d08ba33680e51c2107c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95dc353006c23a4493b3d08ba33680e51c2107c8", "html_url": "https://github.com/rust-lang/rust/commit/95dc353006c23a4493b3d08ba33680e51c2107c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95dc353006c23a4493b3d08ba33680e51c2107c8/comments", "author": {"login": "jmaargh", "id": 11151181, "node_id": "MDQ6VXNlcjExMTUxMTgx", "avatar_url": "https://avatars.githubusercontent.com/u/11151181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jmaargh", "html_url": "https://github.com/jmaargh", "followers_url": "https://api.github.com/users/jmaargh/followers", "following_url": "https://api.github.com/users/jmaargh/following{/other_user}", "gists_url": "https://api.github.com/users/jmaargh/gists{/gist_id}", "starred_url": "https://api.github.com/users/jmaargh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jmaargh/subscriptions", "organizations_url": "https://api.github.com/users/jmaargh/orgs", "repos_url": "https://api.github.com/users/jmaargh/repos", "events_url": "https://api.github.com/users/jmaargh/events{/privacy}", "received_events_url": "https://api.github.com/users/jmaargh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jmaargh", "id": 11151181, "node_id": "MDQ6VXNlcjExMTUxMTgx", "avatar_url": "https://avatars.githubusercontent.com/u/11151181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jmaargh", "html_url": "https://github.com/jmaargh", "followers_url": "https://api.github.com/users/jmaargh/followers", "following_url": "https://api.github.com/users/jmaargh/following{/other_user}", "gists_url": "https://api.github.com/users/jmaargh/gists{/gist_id}", "starred_url": "https://api.github.com/users/jmaargh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jmaargh/subscriptions", "organizations_url": "https://api.github.com/users/jmaargh/orgs", "repos_url": "https://api.github.com/users/jmaargh/repos", "events_url": "https://api.github.com/users/jmaargh/events{/privacy}", "received_events_url": "https://api.github.com/users/jmaargh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68d0b29098ed75f50dabc7d07b96c70caab5c182", "url": "https://api.github.com/repos/rust-lang/rust/commits/68d0b29098ed75f50dabc7d07b96c70caab5c182", "html_url": "https://github.com/rust-lang/rust/commit/68d0b29098ed75f50dabc7d07b96c70caab5c182"}], "stats": {"total": 321, "additions": 191, "deletions": 130}, "files": [{"sha": "197e7aaaccf3d34d59d180582ee54426ef6c0e1b", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=95dc353006c23a4493b3d08ba33680e51c2107c8", "patch": "@@ -374,10 +374,11 @@ impl<T: Ord> BinaryHeap<T> {\n         BinaryHeap { data: vec![] }\n     }\n \n-    /// Creates an empty `BinaryHeap` with a specific capacity.\n-    /// This preallocates enough memory for `capacity` elements,\n-    /// so that the `BinaryHeap` does not have to be reallocated\n-    /// until it contains at least that many values.\n+    /// Creates an empty `BinaryHeap` with at least the specified capacity.\n+    ///\n+    /// The binary heap will be able to hold at least `capacity` elements without\n+    /// reallocating. This method is allowed to allocate for more elements than\n+    /// `capacity`. If `capacity` is 0, the binary heap will not allocate.\n     ///\n     /// # Examples\n     ///\n@@ -906,16 +907,18 @@ impl<T> BinaryHeap<T> {\n         self.data.capacity()\n     }\n \n-    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n-    /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n+    /// Reserves the minimum capacity for at least `additional` elements more than\n+    /// the current length. Unlike [`reserve`], this will not\n+    /// deliberately over-allocate to speculatively avoid frequent allocations.\n+    /// After calling `reserve_exact`, capacity will be greater than or equal to\n+    /// `self.len() + additional`. Does nothing if the capacity is already\n+    /// sufficient.\n     ///\n-    /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer [`reserve`] if future\n-    /// insertions are expected.\n+    /// [`reserve`]: BinaryHeap::reserve\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `usize`.\n+    /// Panics if the new capacity overflows [`usize`].\n     ///\n     /// # Examples\n     ///\n@@ -935,12 +938,15 @@ impl<T> BinaryHeap<T> {\n         self.data.reserve_exact(additional);\n     }\n \n-    /// Reserves capacity for at least `additional` more elements to be inserted in the\n-    /// `BinaryHeap`. The collection may reserve more space to avoid frequent reallocations.\n+    /// Reserves capacity for at least `additional` elements more than the\n+    /// current length. The allocator may reserve more space to speculatively\n+    /// avoid frequent allocations. After calling `reserve`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if capacity is already sufficient.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `usize`.\n+    /// Panics if the new capacity overflows [`usize`].\n     ///\n     /// # Examples\n     ///\n@@ -958,10 +964,11 @@ impl<T> BinaryHeap<T> {\n         self.data.reserve(additional);\n     }\n \n-    /// Tries to reserve the minimum capacity for exactly `additional`\n-    /// elements to be inserted in the given `BinaryHeap<T>`. After calling\n-    /// `try_reserve_exact`, capacity will be greater than or equal to\n-    /// `self.len() + additional` if it returns `Ok(())`.\n+    /// Tries to reserve the minimum capacity for at least `additional` elements\n+    /// more than the current length. Unlike [`try_reserve`], this will not\n+    /// deliberately over-allocate to speculatively avoid frequent allocations.\n+    /// After calling `try_reserve_exact`, capacity will be greater than or\n+    /// equal to `self.len() + additional` if it returns `Ok(())`.\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n@@ -999,11 +1006,11 @@ impl<T> BinaryHeap<T> {\n         self.data.try_reserve_exact(additional)\n     }\n \n-    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n-    /// in the given `BinaryHeap<T>`. The collection may reserve more space to avoid\n-    /// frequent reallocations. After calling `try_reserve`, capacity will be\n-    /// greater than or equal to `self.len() + additional`. Does nothing if\n-    /// capacity is already sufficient.\n+    /// Tries to reserve capacity for at least `additional` elements more than the\n+    /// current length. The allocator may reserve more space to speculatively\n+    /// avoid frequent allocations. After calling `try_reserve`, capacity will be\n+    /// greater than or equal to `self.len() + additional` if it returns\n+    /// `Ok(())`. Does nothing if capacity is already sufficient.\n     ///\n     /// # Errors\n     ///"}, {"sha": "4d895d83745b219951368e91196794cc97cdd249", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=95dc353006c23a4493b3d08ba33680e51c2107c8", "patch": "@@ -688,7 +688,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.cap() - 1\n     }\n \n-    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n+    /// Reserves the minimum capacity for at least `additional` more elements to be inserted in the\n     /// given deque. Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n@@ -716,7 +716,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted in the given\n-    /// deque. The collection may reserve more space to avoid frequent reallocations.\n+    /// deque. The collection may reserve more space to speculatively avoid frequent reallocations.\n     ///\n     /// # Panics\n     ///\n@@ -748,10 +748,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Tries to reserve the minimum capacity for exactly `additional` more elements to\n+    /// Tries to reserve the minimum capacity for at least `additional` more elements to\n     /// be inserted in the given deque. After calling `try_reserve_exact`,\n-    /// capacity will be greater than or equal to `self.len() + additional`.\n-    /// Does nothing if the capacity is already sufficient.\n+    /// capacity will be greater than or equal to `self.len() + additional` if\n+    /// it returns `Ok(())`. Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n     /// requests. Therefore, capacity can not be relied upon to be precisely\n@@ -791,10 +791,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     }\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n-    /// in the given deque. The collection may reserve more space to avoid\n+    /// in the given deque. The collection may reserve more space to speculatively avoid\n     /// frequent reallocations. After calling `try_reserve`, capacity will be\n-    /// greater than or equal to `self.len() + additional`. Does nothing if\n-    /// capacity is already sufficient.\n+    /// greater than or equal to `self.len() + additional` if it returns\n+    /// `Ok(())`. Does nothing if capacity is already sufficient.\n     ///\n     /// # Errors\n     ///"}, {"sha": "8883880726594f29fbbfc9296642001a90971db1", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=95dc353006c23a4493b3d08ba33680e51c2107c8", "patch": "@@ -455,13 +455,13 @@ impl String {\n         String { vec: Vec::new() }\n     }\n \n-    /// Creates a new empty `String` with a particular capacity.\n+    /// Creates a new empty `String` with at least the specified capacity.\n     ///\n     /// `String`s have an internal buffer to hold their data. The capacity is\n     /// the length of that buffer, and can be queried with the [`capacity`]\n     /// method. This method creates an empty `String`, but one with an initial\n-    /// buffer that can hold `capacity` bytes. This is useful when you may be\n-    /// appending a bunch of data to the `String`, reducing the number of\n+    /// buffer that can hold at least `capacity` bytes. This is useful when you\n+    /// may be appending a bunch of data to the `String`, reducing the number of\n     /// reallocations it needs to do.\n     ///\n     /// [`capacity`]: String::capacity\n@@ -979,21 +979,16 @@ impl String {\n         self.vec.capacity()\n     }\n \n-    /// Ensures that this `String`'s capacity is at least `additional` bytes\n-    /// larger than its length.\n-    ///\n-    /// The capacity may be increased by more than `additional` bytes if it\n-    /// chooses, to prevent frequent reallocations.\n-    ///\n-    /// If you do not want this \"at least\" behavior, see the [`reserve_exact`]\n-    /// method.\n+    /// Reserves capacity for at least `additional` bytes more than the\n+    /// current length. The allocator may reserve more space to speculatively\n+    /// avoid frequent allocations. After calling `reserve`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if capacity is already sufficient.\n     ///\n     /// # Panics\n     ///\n     /// Panics if the new capacity overflows [`usize`].\n     ///\n-    /// [`reserve_exact`]: String::reserve_exact\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1013,15 +1008,16 @@ impl String {\n     /// s.push('a');\n     /// s.push('b');\n     ///\n-    /// // s now has a length of 2 and a capacity of 10\n+    /// // s now has a length of 2 and a capacity of at least 10\n+    /// let capacity = s.capacity();\n     /// assert_eq!(2, s.len());\n-    /// assert_eq!(10, s.capacity());\n+    /// assert!(capacity >= 10);\n     ///\n-    /// // Since we already have an extra 8 capacity, calling this...\n+    /// // Since we already have at least an extra 8 capacity, calling this...\n     /// s.reserve(8);\n     ///\n     /// // ... doesn't actually increase.\n-    /// assert_eq!(10, s.capacity());\n+    /// assert_eq!(capacity, s.capacity());\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n     #[inline]\n@@ -1030,17 +1026,18 @@ impl String {\n         self.vec.reserve(additional)\n     }\n \n-    /// Ensures that this `String`'s capacity is `additional` bytes\n-    /// larger than its length.\n-    ///\n-    /// Consider using the [`reserve`] method unless you absolutely know\n-    /// better than the allocator.\n+    /// Reserves the minimum capacity for at least `additional` bytes more than\n+    /// the current length. Unlike [`reserve`], this will not\n+    /// deliberately over-allocate to speculatively avoid frequent allocations.\n+    /// After calling `reserve_exact`, capacity will be greater than or equal to\n+    /// `self.len() + additional`. Does nothing if the capacity is already\n+    /// sufficient.\n     ///\n     /// [`reserve`]: String::reserve\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `usize`.\n+    /// Panics if the new capacity overflows [`usize`].\n     ///\n     /// # Examples\n     ///\n@@ -1061,15 +1058,16 @@ impl String {\n     /// s.push('a');\n     /// s.push('b');\n     ///\n-    /// // s now has a length of 2 and a capacity of 10\n+    /// // s now has a length of 2 and a capacity of at least 10\n+    /// let capacity = s.capacity();\n     /// assert_eq!(2, s.len());\n-    /// assert_eq!(10, s.capacity());\n+    /// assert!(capacity >= 10);\n     ///\n-    /// // Since we already have an extra 8 capacity, calling this...\n+    /// // Since we already have at least an extra 8 capacity, calling this...\n     /// s.reserve_exact(8);\n     ///\n     /// // ... doesn't actually increase.\n-    /// assert_eq!(10, s.capacity());\n+    /// assert_eq!(capacity, s.capacity());\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n     #[inline]\n@@ -1078,11 +1076,11 @@ impl String {\n         self.vec.reserve_exact(additional)\n     }\n \n-    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n-    /// in the given `String`. The collection may reserve more space to avoid\n-    /// frequent reallocations. After calling `reserve`, capacity will be\n-    /// greater than or equal to `self.len() + additional`. Does nothing if\n-    /// capacity is already sufficient.\n+    /// Tries to reserve capacity for at least `additional` bytes more than the\n+    /// current length. The allocator may reserve more space to speculatively\n+    /// avoid frequent allocations. After calling `try_reserve`, capacity will be\n+    /// greater than or equal to `self.len() + additional` if it returns\n+    /// `Ok(())`. Does nothing if capacity is already sufficient.\n     ///\n     /// # Errors\n     ///\n@@ -1112,9 +1110,11 @@ impl String {\n         self.vec.try_reserve(additional)\n     }\n \n-    /// Tries to reserve the minimum capacity for exactly `additional` more elements to\n-    /// be inserted in the given `String`. After calling `try_reserve_exact`,\n-    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Tries to reserve the minimum capacity for at least `additional` bytes\n+    /// more than the current length. Unlike [`try_reserve`], this will not\n+    /// deliberately over-allocate to speculatively avoid frequent allocations.\n+    /// After calling `try_reserve_exact`, capacity will be greater than or\n+    /// equal to `self.len() + additional` if it returns `Ok(())`.\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it"}, {"sha": "e25f98d8aa69570079f4c5eed15c9f6a01c4e7d1", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 57, "deletions": 28, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=95dc353006c23a4493b3d08ba33680e51c2107c8", "patch": "@@ -425,17 +425,25 @@ impl<T> Vec<T> {\n         Vec { buf: RawVec::NEW, len: 0 }\n     }\n \n-    /// Constructs a new, empty `Vec<T>` with the specified capacity.\n+    /// Constructs a new, empty `Vec<T>` with at least the specified capacity.\n     ///\n-    /// The vector will be able to hold exactly `capacity` elements without\n-    /// reallocating. If `capacity` is 0, the vector will not allocate.\n+    /// The vector will be able to hold at least `capacity` elements without\n+    /// reallocating. This method is allowed to allocate for more elements than\n+    /// `capacity`. If `capacity` is 0, the vector will not allocate.\n     ///\n     /// It is important to note that although the returned vector has the\n-    /// *capacity* specified, the vector will have a zero *length*. For an\n-    /// explanation of the difference between length and capacity, see\n+    /// minimum *capacity* specified, the vector will have a zero *length*. For\n+    /// an explanation of the difference between length and capacity, see\n     /// *[Capacity and reallocation]*.\n     ///\n+    /// If it is imporant to know the exact allocated capacity of a `Vec`,\n+    /// always use the [`capacity`] method after construction.\n+    ///\n+    /// For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n+    /// and the capacity will always be `usize::MAX`.\n+    ///\n     /// [Capacity and reallocation]: #capacity-and-reallocation\n+    /// [`capacity`]: Vec::capacity\n     ///\n     /// # Panics\n     ///\n@@ -448,19 +456,24 @@ impl<T> Vec<T> {\n     ///\n     /// // The vector contains no items, even though it has capacity for more\n     /// assert_eq!(vec.len(), 0);\n-    /// assert_eq!(vec.capacity(), 10);\n+    /// assert!(vec.capacity() >= 10);\n     ///\n     /// // These are all done without reallocating...\n     /// for i in 0..10 {\n     ///     vec.push(i);\n     /// }\n     /// assert_eq!(vec.len(), 10);\n-    /// assert_eq!(vec.capacity(), 10);\n+    /// assert!(vec.capacity() >= 10);\n     ///\n     /// // ...but this may make the vector reallocate\n     /// vec.push(11);\n     /// assert_eq!(vec.len(), 11);\n     /// assert!(vec.capacity() >= 11);\n+    ///\n+    /// // A vector of a zero-sized type will always over-allocate, since no\n+    /// // allocation is necessary\n+    /// let vec_units = Vec::<()>::with_capacity(10);\n+    /// assert_eq!(vec_units.capacity(), usize::MAX);\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n     #[inline]\n@@ -566,18 +579,26 @@ impl<T, A: Allocator> Vec<T, A> {\n         Vec { buf: RawVec::new_in(alloc), len: 0 }\n     }\n \n-    /// Constructs a new, empty `Vec<T, A>` with the specified capacity with the provided\n-    /// allocator.\n+    /// Constructs a new, empty `Vec<T, A>` with at least the specified capacity\n+    /// with the provided allocator.\n     ///\n-    /// The vector will be able to hold exactly `capacity` elements without\n-    /// reallocating. If `capacity` is 0, the vector will not allocate.\n+    /// The vector will be able to hold at least `capacity` elements without\n+    /// reallocating. This method is allowed to allocate for more elements than\n+    /// `capacity`. If `capacity` is 0, the vector will not allocate.\n     ///\n     /// It is important to note that although the returned vector has the\n-    /// *capacity* specified, the vector will have a zero *length*. For an\n-    /// explanation of the difference between length and capacity, see\n+    /// minimum *capacity* specified, the vector will have a zero *length*. For\n+    /// an explanation of the difference between length and capacity, see\n     /// *[Capacity and reallocation]*.\n     ///\n+    /// If it is imporant to know the exact allocated capacity of a `Vec`,\n+    /// always use the [`capacity`] method after construction.\n+    ///\n+    /// For `Vec<T, A>` where `T` is a zero-sized type, there will be no allocation\n+    /// and the capacity will always be `usize::MAX`.\n+    ///\n     /// [Capacity and reallocation]: #capacity-and-reallocation\n+    /// [`capacity`]: Vec::capacity\n     ///\n     /// # Panics\n     ///\n@@ -607,6 +628,11 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// vec.push(11);\n     /// assert_eq!(vec.len(), 11);\n     /// assert!(vec.capacity() >= 11);\n+    ///\n+    /// // A vector of a zero-sized type will always over-allocate, since no\n+    /// // allocation is necessary\n+    /// let vec_units = Vec::<(), System>::with_capacity_in(10, System);\n+    /// assert_eq!(vec_units.capacity(), usize::MAX);\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n     #[inline]\n@@ -793,10 +819,10 @@ impl<T, A: Allocator> Vec<T, A> {\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted\n-    /// in the given `Vec<T>`. The collection may reserve more space to avoid\n-    /// frequent reallocations. After calling `reserve`, capacity will be\n-    /// greater than or equal to `self.len() + additional`. Does nothing if\n-    /// capacity is already sufficient.\n+    /// in the given `Vec<T>`. The collection may reserve more space to\n+    /// speculatively avoid frequent reallocations. After calling `reserve`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if capacity is already sufficient.\n     ///\n     /// # Panics\n     ///\n@@ -815,10 +841,12 @@ impl<T, A: Allocator> Vec<T, A> {\n         self.buf.reserve(self.len, additional);\n     }\n \n-    /// Reserves the minimum capacity for exactly `additional` more elements to\n-    /// be inserted in the given `Vec<T>`. After calling `reserve_exact`,\n-    /// capacity will be greater than or equal to `self.len() + additional`.\n-    /// Does nothing if the capacity is already sufficient.\n+    /// Reserves the minimum capacity for at least `additional` more elements to\n+    /// be inserted in the given `Vec<T>`. Unlike [`reserve`], this will not\n+    /// deliberately over-allocate to speculatively avoid frequent allocations.\n+    /// After calling `reserve_exact`, capacity will be greater than or equal to\n+    /// `self.len() + additional`. Does nothing if the capacity is already\n+    /// sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n     /// requests. Therefore, capacity can not be relied upon to be precisely\n@@ -844,10 +872,10 @@ impl<T, A: Allocator> Vec<T, A> {\n     }\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n-    /// in the given `Vec<T>`. The collection may reserve more space to avoid\n+    /// in the given `Vec<T>`. The collection may reserve more space to speculatively avoid\n     /// frequent reallocations. After calling `try_reserve`, capacity will be\n-    /// greater than or equal to `self.len() + additional`. Does nothing if\n-    /// capacity is already sufficient.\n+    /// greater than or equal to `self.len() + additional` if it returns\n+    /// `Ok(())`. Does nothing if capacity is already sufficient.\n     ///\n     /// # Errors\n     ///\n@@ -879,10 +907,11 @@ impl<T, A: Allocator> Vec<T, A> {\n         self.buf.try_reserve(self.len, additional)\n     }\n \n-    /// Tries to reserve the minimum capacity for exactly `additional`\n-    /// elements to be inserted in the given `Vec<T>`. After calling\n-    /// `try_reserve_exact`, capacity will be greater than or equal to\n-    /// `self.len() + additional` if it returns `Ok(())`.\n+    /// Tries to reserve the minimum capacity for at least `additional`\n+    /// elements to be inserted in the given `Vec<T>`. Unlike [`try_reserve`],\n+    /// this will not deliberately over-allocate to speculatively avoid frequent\n+    /// allocations. After calling `try_reserve_exact`, capacity will be greater\n+    /// than or equal to `self.len() + additional` if it returns `Ok(())`.\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it"}, {"sha": "5520f6ebf19045d4232eb413dc09034d8cd3a466", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=95dc353006c23a4493b3d08ba33680e51c2107c8", "patch": "@@ -2128,6 +2128,15 @@ fn test_vec_cycle_wrapped() {\n     c3.refs.v[1].set(Some(&c2));\n }\n \n+#[test]\n+fn test_zero_sized_capacity() {\n+    for len in [0, 1, 2, 4, 8, 16, 32, 64, 128, 256] {\n+        let v = Vec::<()>::with_capacity(len);\n+        assert_eq!(v.len(), 0);\n+        assert_eq!(v.capacity(), usize::MAX);\n+    }\n+}\n+\n #[test]\n fn test_zero_sized_vec_push() {\n     const N: usize = 8;"}, {"sha": "499c997a36ab2db9d921a5f9a77659fe0d078a61", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=95dc353006c23a4493b3d08ba33680e51c2107c8", "patch": "@@ -233,10 +233,11 @@ impl<K, V> HashMap<K, V, RandomState> {\n         Default::default()\n     }\n \n-    /// Creates an empty `HashMap` with the specified capacity.\n+    /// Creates an empty `HashMap` with at least the specified capacity.\n     ///\n     /// The hash map will be able to hold at least `capacity` elements without\n-    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n+    /// reallocating. This method is allowed to allocate for more elements than\n+    /// `capacity`. If `capacity` is 0, the hash set will not allocate.\n     ///\n     /// # Examples\n     ///\n@@ -282,18 +283,19 @@ impl<K, V, S> HashMap<K, V, S> {\n         HashMap { base: base::HashMap::with_hasher(hash_builder) }\n     }\n \n-    /// Creates an empty `HashMap` with the specified capacity, using `hash_builder`\n-    /// to hash the keys.\n+    /// Creates an empty `HashMap` with at least the specified capacity, using\n+    /// `hasher` to hash the keys.\n     ///\n     /// The hash map will be able to hold at least `capacity` elements without\n-    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n+    /// reallocating. This method is allowed to allocate for more elements than\n+    /// `capacity`. If `capacity` is 0, the hash map will not allocate.\n     ///\n-    /// Warning: `hash_builder` is normally randomly generated, and\n+    /// Warning: `hasher` is normally randomly generated, and\n     /// is designed to allow HashMaps to be resistant to attacks that\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n     ///\n-    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n+    /// The `hasher` passed should implement the [`BuildHasher`] trait for\n     /// the HashMap to be useful, see its documentation for details.\n     ///\n     /// # Examples\n@@ -308,8 +310,8 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n-    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> {\n-        HashMap { base: base::HashMap::with_capacity_and_hasher(capacity, hash_builder) }\n+    pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashMap<K, V, S> {\n+        HashMap { base: base::HashMap::with_capacity_and_hasher(capacity, hasher) }\n     }\n \n     /// Returns the number of elements the map can hold without reallocating.\n@@ -731,8 +733,10 @@ where\n     S: BuildHasher,\n {\n     /// Reserves capacity for at least `additional` more elements to be inserted\n-    /// in the `HashMap`. The collection may reserve more space to avoid\n-    /// frequent reallocations.\n+    /// in the `HashMap`. The collection may reserve more space to speculatively\n+    /// avoid frequent reallocations. After calling `reserve`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if capacity is already sufficient.\n     ///\n     /// # Panics\n     ///\n@@ -752,8 +756,11 @@ where\n     }\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n-    /// in the given `HashMap<K, V>`. The collection may reserve more space to avoid\n-    /// frequent reallocations.\n+    /// in the `HashMap`. The collection may reserve more space to speculatively\n+    /// avoid frequent reallocations. After calling `reserve`,\n+    /// capacity will be greater than or equal to `self.len() + additional` if\n+    /// it returns `Ok(())`.\n+    /// Does nothing if capacity is already sufficient.\n     ///\n     /// # Errors\n     ///\n@@ -766,7 +773,7 @@ where\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<&str, isize> = HashMap::new();\n-    /// map.try_reserve(10).expect(\"why is the test harness OOMing on 10 bytes?\");\n+    /// map.try_reserve(10).expect(\"why is the test harness OOMing on a handful of bytes?\");\n     /// ```\n     #[inline]\n     #[stable(feature = \"try_reserve\", since = \"1.57.0\")]"}, {"sha": "abff82788a38dc55d9a8cfbb3b5900c5ea9ac53d", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=95dc353006c23a4493b3d08ba33680e51c2107c8", "patch": "@@ -133,10 +133,11 @@ impl<T> HashSet<T, RandomState> {\n         Default::default()\n     }\n \n-    /// Creates an empty `HashSet` with the specified capacity.\n+    /// Creates an empty `HashSet` with at least the specified capacity.\n     ///\n     /// The hash set will be able to hold at least `capacity` elements without\n-    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n+    /// reallocating. This method is allowed to allocate for more elements than\n+    /// `capacity`. If `capacity` is 0, the hash set will not allocate.\n     ///\n     /// # Examples\n     ///\n@@ -379,11 +380,12 @@ impl<T, S> HashSet<T, S> {\n         HashSet { base: base::HashSet::with_hasher(hasher) }\n     }\n \n-    /// Creates an empty `HashSet` with the specified capacity, using\n+    /// Creates an empty `HashSet` with at least the specified capacity, using\n     /// `hasher` to hash the keys.\n     ///\n     /// The hash set will be able to hold at least `capacity` elements without\n-    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n+    /// reallocating. This method is allowed to allocate for more elements than\n+    /// `capacity`. If `capacity` is 0, the hash set will not allocate.\n     ///\n     /// Warning: `hasher` is normally randomly generated, and\n     /// is designed to allow `HashSet`s to be resistant to attacks that\n@@ -434,8 +436,10 @@ where\n     S: BuildHasher,\n {\n     /// Reserves capacity for at least `additional` more elements to be inserted\n-    /// in the `HashSet`. The collection may reserve more space to avoid\n-    /// frequent reallocations.\n+    /// in the `HashSet`. The collection may reserve more space to speculatively\n+    /// avoid frequent reallocations. After calling `reserve`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if capacity is already sufficient.\n     ///\n     /// # Panics\n     ///\n@@ -456,8 +460,11 @@ where\n     }\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n-    /// in the given `HashSet<K, V>`. The collection may reserve more space to avoid\n-    /// frequent reallocations.\n+    /// in the `HashSet`. The collection may reserve more space to speculatively\n+    /// avoid frequent reallocations. After calling `reserve`,\n+    /// capacity will be greater than or equal to `self.len() + additional` if\n+    /// it returns `Ok(())`.\n+    /// Does nothing if capacity is already sufficient.\n     ///\n     /// # Errors\n     ///\n@@ -469,7 +476,7 @@ where\n     /// ```\n     /// use std::collections::HashSet;\n     /// let mut set: HashSet<i32> = HashSet::new();\n-    /// set.try_reserve(10).expect(\"why is the test harness OOMing on 10 bytes?\");\n+    /// set.try_reserve(10).expect(\"why is the test harness OOMing on a handful of bytes?\");\n     /// ```\n     #[inline]\n     #[stable(feature = \"try_reserve\", since = \"1.57.0\")]"}, {"sha": "f2bbcc85cecda0c793e3988a0e90cd05cf84cbf2", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=95dc353006c23a4493b3d08ba33680e51c2107c8", "patch": "@@ -196,10 +196,11 @@ impl OsString {\n         self.inner.push_slice(&s.as_ref().inner)\n     }\n \n-    /// Creates a new `OsString` with the given capacity.\n+    /// Creates a new `OsString` with at least the given capacity.\n     ///\n-    /// The string will be able to hold exactly `capacity` length units of other\n-    /// OS strings without reallocating. If `capacity` is 0, the string will not\n+    /// The string will be able to hold at least `capacity` length units of other\n+    /// OS strings without reallocating. This method is allowed to allocate for\n+    /// more units than `capacity`. If `capacity` is 0, the string will not\n     /// allocate.\n     ///\n     /// See the main `OsString` documentation information about encoding and capacity units.\n@@ -263,9 +264,10 @@ impl OsString {\n     }\n \n     /// Reserves capacity for at least `additional` more capacity to be inserted\n-    /// in the given `OsString`.\n+    /// in the given `OsString`. Does nothing if the capacity is\n+    /// already sufficient.\n     ///\n-    /// The collection may reserve more space to avoid frequent reallocations.\n+    /// The collection may reserve more space to speculatively avoid frequent reallocations.\n     ///\n     /// See the main `OsString` documentation information about encoding and capacity units.\n     ///\n@@ -285,10 +287,10 @@ impl OsString {\n     }\n \n     /// Tries to reserve capacity for at least `additional` more length units\n-    /// in the given `OsString`. The string may reserve more space to avoid\n+    /// in the given `OsString`. The string may reserve more space to speculatively avoid\n     /// frequent reallocations. After calling `try_reserve`, capacity will be\n-    /// greater than or equal to `self.len() + additional`. Does nothing if\n-    /// capacity is already sufficient.\n+    /// greater than or equal to `self.len() + additional` if it returns `Ok(())`.\n+    /// Does nothing if capacity is already sufficient.\n     ///\n     /// See the main `OsString` documentation information about encoding and capacity units.\n     ///\n@@ -322,7 +324,7 @@ impl OsString {\n         self.inner.try_reserve(additional)\n     }\n \n-    /// Reserves the minimum capacity for exactly `additional` more capacity to\n+    /// Reserves the minimum capacity for at least `additional` more capacity to\n     /// be inserted in the given `OsString`. Does nothing if the capacity is\n     /// already sufficient.\n     ///\n@@ -349,7 +351,7 @@ impl OsString {\n         self.inner.reserve_exact(additional)\n     }\n \n-    /// Tries to reserve the minimum capacity for exactly `additional`\n+    /// Tries to reserve the minimum capacity for at least `additional`\n     /// more length units in the given `OsString`. After calling\n     /// `try_reserve_exact`, capacity will be greater than or equal to\n     /// `self.len() + additional` if it returns `Ok(())`."}, {"sha": "6acb937e78479e404757ce77eda9c3adda4d4157", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=95dc353006c23a4493b3d08ba33680e51c2107c8", "patch": "@@ -97,11 +97,11 @@ impl<W: Write> BufWriter<W> {\n         BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n     }\n \n-    /// Creates a new `BufWriter<W>` with the specified buffer capacity.\n+    /// Creates a new `BufWriter<W>` with at least the specified buffer capacity.\n     ///\n     /// # Examples\n     ///\n-    /// Creating a buffer with a buffer of a hundred bytes.\n+    /// Creating a buffer with a buffer of at least a hundred bytes.\n     ///\n     /// ```no_run\n     /// use std::io::BufWriter;"}, {"sha": "a26a4ab330e7a5ae6307a1d81f7975f13d82989e", "filename": "library/std/src/io/buffered/linewriter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dc353006c23a4493b3d08ba33680e51c2107c8/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs?ref=95dc353006c23a4493b3d08ba33680e51c2107c8", "patch": "@@ -89,8 +89,8 @@ impl<W: Write> LineWriter<W> {\n         LineWriter::with_capacity(1024, inner)\n     }\n \n-    /// Creates a new `LineWriter` with a specified capacity for the internal\n-    /// buffer.\n+    /// Creates a new `LineWriter` with at least the specified capacity for the\n+    /// internal buffer.\n     ///\n     /// # Examples\n     ///"}]}