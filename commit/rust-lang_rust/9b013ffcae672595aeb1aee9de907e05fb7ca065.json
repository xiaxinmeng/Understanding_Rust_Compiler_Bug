{"sha": "9b013ffcae672595aeb1aee9de907e05fb7ca065", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMDEzZmZjYWU2NzI1OTVhZWIxYWVlOWRlOTA3ZTA1ZmI3Y2EwNjU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-17T19:22:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-17T19:22:48Z"}, "message": "Merge #9318\n\n9318: feat: Complete `repr` attribute parameters r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "1109efae3338b65e703b82b218035023569abdf9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1109efae3338b65e703b82b218035023569abdf9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b013ffcae672595aeb1aee9de907e05fb7ca065", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgy6EICRBK7hj4Ov3rIwAAvTsIAKzBL6hprbM/n+RRZGRfggzB\nDQbhaSEanEEjx4XmrOcHIi48byPMAsxnziVRpS0StTdlk/PGCiBOwqhURrobbryF\nan7t6VvqP8OSozguHKloxmhJ1toO6Gy2a0rbftMP32iD4LVNW/65CePNtnPyNZMR\nuqAC4vAkjP1hTU8DqVAD+9+Lx+bHci7Vh/Rk5UofYjN1BdnjsvQA0iTNAzN6dt+a\ntx+5rzmMAqBNSnGHsJDeZzwEAfJjczkOxocRgoBvzwQvvYmstzxpNex3rXyIpFoR\neyvPKWeLCqKIzkKY9Tcwjdza3TSZ5tFe+ksChAeUMKt6n4tXzBMuVczrS2WD2+s=\n=Aaiz\n-----END PGP SIGNATURE-----\n", "payload": "tree 1109efae3338b65e703b82b218035023569abdf9\nparent 84507a0b9c2e8f6e632ad9ec649cd1f21a7e0887\nparent c1bf1f88ad4199e48d2615dbf9479e602b5e9eff\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623957768 +0000\ncommitter GitHub <noreply@github.com> 1623957768 +0000\n\nMerge #9318\n\n9318: feat: Complete `repr` attribute parameters r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b013ffcae672595aeb1aee9de907e05fb7ca065", "html_url": "https://github.com/rust-lang/rust/commit/9b013ffcae672595aeb1aee9de907e05fb7ca065", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b013ffcae672595aeb1aee9de907e05fb7ca065/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84507a0b9c2e8f6e632ad9ec649cd1f21a7e0887", "url": "https://api.github.com/repos/rust-lang/rust/commits/84507a0b9c2e8f6e632ad9ec649cd1f21a7e0887", "html_url": "https://github.com/rust-lang/rust/commit/84507a0b9c2e8f6e632ad9ec649cd1f21a7e0887"}, {"sha": "c1bf1f88ad4199e48d2615dbf9479e602b5e9eff", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1bf1f88ad4199e48d2615dbf9479e602b5e9eff", "html_url": "https://github.com/rust-lang/rust/commit/c1bf1f88ad4199e48d2615dbf9479e602b5e9eff"}], "stats": {"total": 204, "additions": 202, "deletions": 2}, "files": [{"sha": "9780d01aefef37333d6eca4dcfe851874b7622b8", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b013ffcae672595aeb1aee9de907e05fb7ca065/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b013ffcae672595aeb1aee9de907e05fb7ca065/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=9b013ffcae672595aeb1aee9de907e05fb7ca065", "patch": "@@ -17,12 +17,14 @@ use crate::{\n \n mod derive;\n mod lint;\n+mod repr;\n \n pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n     let attribute = ctx.attribute_under_caret.as_ref()?;\n     match (attribute.path().and_then(|p| p.as_single_name_ref()), attribute.token_tree()) {\n         (Some(path), Some(token_tree)) => match path.text().as_str() {\n             \"derive\" => derive::complete_derive(acc, ctx, token_tree),\n+            \"repr\" => repr::complete_repr(acc, ctx, token_tree),\n             \"feature\" => lint::complete_lint(acc, ctx, token_tree, FEATURES),\n             \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n                 lint::complete_lint(acc, ctx, token_tree.clone(), DEFAULT_LINTS);"}, {"sha": "92a262a43f92152a9452283dc81f753175ebb87c", "filename": "crates/ide_completion/src/completions/attribute/repr.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/9b013ffcae672595aeb1aee9de907e05fb7ca065/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b013ffcae672595aeb1aee9de907e05fb7ca065/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs?ref=9b013ffcae672595aeb1aee9de907e05fb7ca065", "patch": "@@ -0,0 +1,199 @@\n+//! Completion for representations.\n+\n+use syntax::ast;\n+\n+use crate::{\n+    context::CompletionContext,\n+    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    Completions,\n+};\n+\n+pub(super) fn complete_repr(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    derive_input: ast::TokenTree,\n+) {\n+    if let Some(existing_reprs) = super::parse_comma_sep_input(derive_input) {\n+        for repr_completion in REPR_COMPLETIONS {\n+            if existing_reprs\n+                .iter()\n+                .any(|it| repr_completion.label == it || repr_completion.collides.contains(&&**it))\n+            {\n+                continue;\n+            }\n+            let mut item = CompletionItem::new(\n+                CompletionKind::Attribute,\n+                ctx.source_range(),\n+                repr_completion.label,\n+            );\n+            item.kind(CompletionItemKind::Attribute);\n+            if let Some(lookup) = repr_completion.lookup {\n+                item.lookup_by(lookup);\n+            }\n+            if let Some((snippet, cap)) = repr_completion.snippet.zip(ctx.config.snippet_cap) {\n+                item.insert_snippet(cap, snippet);\n+            }\n+            item.add_to(acc);\n+        }\n+    }\n+}\n+\n+struct ReprCompletion {\n+    label: &'static str,\n+    snippet: Option<&'static str>,\n+    lookup: Option<&'static str>,\n+    collides: &'static [&'static str],\n+}\n+\n+const fn attr(label: &'static str, collides: &'static [&'static str]) -> ReprCompletion {\n+    ReprCompletion { label, snippet: None, lookup: None, collides }\n+}\n+\n+#[rustfmt::skip]\n+const REPR_COMPLETIONS: &[ReprCompletion] = &[\n+    ReprCompletion { label: \"align($0)\", snippet: Some(\"align($0)\"), lookup: Some(\"align\"), collides: &[\"transparent\", \"packed\"] },\n+    attr(\"packed\", &[\"transparent\", \"align\"]),\n+    attr(\"transparent\", &[\"C\", \"u8\", \"u16\", \"u32\", \"u64\", \"u128\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"i128\", \"isize\"]),\n+    attr(\"C\", &[\"transparent\"]),\n+    attr(\"u8\",     &[\"transparent\", \"u16\", \"u32\", \"u64\", \"u128\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"i128\", \"isize\"]),\n+    attr(\"u16\",    &[\"transparent\", \"u8\", \"u32\", \"u64\", \"u128\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"i128\", \"isize\"]),\n+    attr(\"u32\",    &[\"transparent\", \"u8\", \"u16\", \"u64\", \"u128\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"i128\", \"isize\"]),\n+    attr(\"u64\",    &[\"transparent\", \"u8\", \"u16\", \"u32\", \"u128\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"i128\", \"isize\"]),\n+    attr(\"u128\",   &[\"transparent\", \"u8\", \"u16\", \"u32\", \"u64\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"i128\", \"isize\"]),\n+    attr(\"usize\",  &[\"transparent\", \"u8\", \"u16\", \"u32\", \"u64\", \"u128\", \"i8\", \"i16\", \"i32\", \"i64\", \"i128\", \"isize\"]),\n+    attr(\"i8\",     &[\"transparent\", \"u8\", \"u16\", \"u32\", \"u64\", \"u128\", \"usize\", \"i16\", \"i32\", \"i64\", \"i128\", \"isize\"]),\n+    attr(\"i16\",    &[\"transparent\", \"u8\", \"u16\", \"u32\", \"u64\", \"u128\", \"usize\", \"i8\", \"i32\", \"i64\", \"i128\", \"isize\"]),\n+    attr(\"i32\",    &[\"transparent\", \"u8\", \"u16\", \"u32\", \"u64\", \"u128\", \"usize\", \"i8\", \"i16\", \"i64\", \"i128\", \"isize\"]),\n+    attr(\"i64\",    &[\"transparent\", \"u8\", \"u16\", \"u32\", \"u64\", \"u128\", \"usize\", \"i8\", \"i16\", \"i32\", \"i128\", \"isize\"]),\n+    attr(\"i28\",    &[\"transparent\", \"u8\", \"u16\", \"u32\", \"u64\", \"u128\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"isize\"]),\n+    attr(\"isize\",  &[\"transparent\", \"u8\", \"u16\", \"u32\", \"u64\", \"u128\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"i128\"]),\n+];\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::{expect, Expect};\n+\n+    use crate::tests::completion_list;\n+\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let actual = completion_list(ra_fixture);\n+        expect.assert_eq(&actual);\n+    }\n+\n+    #[test]\n+    fn no_completion_for_incorrect_repr() {\n+        check(r#\"#[repr{$0)] struct Test;\"#, expect![[]])\n+    }\n+\n+    #[test]\n+    fn empty() {\n+        check(\n+            r#\"#[repr($0)] struct Test;\"#,\n+            expect![[r#\"\n+                at align($0)\n+                at packed\n+                at transparent\n+                at C\n+                at u8\n+                at u16\n+                at u32\n+                at u64\n+                at u128\n+                at usize\n+                at i8\n+                at i16\n+                at i32\n+                at i64\n+                at i28\n+                at isize\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn transparent() {\n+        check(r#\"#[repr(transparent, $0)] struct Test;\"#, expect![[r#\"\"#]]);\n+    }\n+\n+    #[test]\n+    fn align() {\n+        check(\n+            r#\"#[repr(align(1), $0)] struct Test;\"#,\n+            expect![[r#\"\n+                at align($0)\n+                at transparent\n+                at C\n+                at u8\n+                at u16\n+                at u32\n+                at u64\n+                at u128\n+                at usize\n+                at i8\n+                at i16\n+                at i32\n+                at i64\n+                at i28\n+                at isize\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn packed() {\n+        check(\n+            r#\"#[repr(packed, $0)] struct Test;\"#,\n+            expect![[r#\"\n+                at transparent\n+                at C\n+                at u8\n+                at u16\n+                at u32\n+                at u64\n+                at u128\n+                at usize\n+                at i8\n+                at i16\n+                at i32\n+                at i64\n+                at i28\n+                at isize\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn c() {\n+        check(\n+            r#\"#[repr(C, $0)] struct Test;\"#,\n+            expect![[r#\"\n+                at align($0)\n+                at packed\n+                at u8\n+                at u16\n+                at u32\n+                at u64\n+                at u128\n+                at usize\n+                at i8\n+                at i16\n+                at i32\n+                at i64\n+                at i28\n+                at isize\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn prim() {\n+        check(\n+            r#\"#[repr(usize, $0)] struct Test;\"#,\n+            expect![[r#\"\n+                at align($0)\n+                at packed\n+                at C\n+            \"#]],\n+        );\n+    }\n+}"}, {"sha": "5a78675fb4fbaeadb34bf382b41e5dfdedeade66", "filename": "crates/parser/src/grammar/params.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b013ffcae672595aeb1aee9de907e05fb7ca065/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b013ffcae672595aeb1aee9de907e05fb7ca065/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs?ref=9b013ffcae672595aeb1aee9de907e05fb7ca065", "patch": "@@ -184,8 +184,7 @@ fn opt_self_param(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n         if !matches!(\n             (p.current(), la1, la2, la3),\n             (T![&], T![self], _, _)\n-                | (T![&], T![mut], T![self], _)\n-                | (T![&], LIFETIME_IDENT, T![self], _)\n+                | (T![&], T![mut] | LIFETIME_IDENT, T![self], _)\n                 | (T![&], LIFETIME_IDENT, T![mut], T![self])\n         ) {\n             return Err(m);"}]}