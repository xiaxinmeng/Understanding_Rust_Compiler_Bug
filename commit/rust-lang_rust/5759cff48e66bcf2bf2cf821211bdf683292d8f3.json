{"sha": "5759cff48e66bcf2bf2cf821211bdf683292d8f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NTljZmY0OGU2NmJjZjJiZjJjZjgyMTIxMWJkZjY4MzI5MmQ4ZjM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T22:37:38Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-19T07:35:52Z"}, "message": "std: Lower abstractions for thread_local/at_exit\n\nThe current implementations use `std::sync` primitives, but these primitives\ncurrently end up relying on `thread_info` and a local `Thread` being available\n(mainly for checking the panicking flag).\n\nTo get around this, this commit lowers the abstractions used by the windows\nthread_local implementation as well as the at_exit_imp module. Both of these\nmodules now use a `sys::Mutex` and a `static mut` and manage the\nallocation/locking manually.", "tree": {"sha": "4532178a8794666d1d62300b42981a9ccdf3a49d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4532178a8794666d1d62300b42981a9ccdf3a49d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5759cff48e66bcf2bf2cf821211bdf683292d8f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5759cff48e66bcf2bf2cf821211bdf683292d8f3", "html_url": "https://github.com/rust-lang/rust/commit/5759cff48e66bcf2bf2cf821211bdf683292d8f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5759cff48e66bcf2bf2cf821211bdf683292d8f3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a27fbac86849e07a0a6c746869d8f78319bd3a16", "url": "https://api.github.com/repos/rust-lang/rust/commits/a27fbac86849e07a0a6c746869d8f78319bd3a16", "html_url": "https://github.com/rust-lang/rust/commit/a27fbac86849e07a0a6c746869d8f78319bd3a16"}], "stats": {"total": 124, "additions": 78, "deletions": 46}, "files": [{"sha": "5823f8453d84a3ffc8f87d7f2efe137db6786932", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5759cff48e66bcf2bf2cf821211bdf683292d8f3/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5759cff48e66bcf2bf2cf821211bdf683292d8f3/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=5759cff48e66bcf2bf2cf821211bdf683292d8f3", "patch": "@@ -16,50 +16,60 @@ use core::prelude::*;\n \n use boxed::Box;\n use vec::Vec;\n-use sync::{Mutex, atomic, Once, ONCE_INIT};\n use mem;\n use thunk::Thunk;\n+use sys_common::mutex::{Mutex, MUTEX_INIT};\n \n-type Queue = Mutex<Vec<Thunk>>;\n+type Queue = Vec<Thunk>;\n \n-static INIT: Once = ONCE_INIT;\n-static QUEUE: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+// NB these are specifically not types from `std::sync` as they currently rely\n+// on poisoning and this module needs to operate at a lower level than requiring\n+// the thread infrastructure to be in place (useful on the borders of\n+// initialization/destruction).\n+static LOCK: Mutex = MUTEX_INIT;\n+static mut QUEUE: *mut Queue = 0 as *mut Queue;\n \n-fn init() {\n-    let state: Box<Queue> = box Mutex::new(Vec::new());\n-    unsafe {\n-        QUEUE.store(mem::transmute(state), atomic::SeqCst);\n-\n-        // FIXME: switch this to use atexit as below. Currently this\n-        // segfaults (the queue's memory is mysteriously gone), so\n-        // instead the cleanup is tied to the `std::rt` entry point.\n-        //\n-        // ::libc::atexit(cleanup);\n+unsafe fn init() {\n+    if QUEUE.is_null() {\n+        let state: Box<Queue> = box Vec::new();\n+        QUEUE = mem::transmute(state);\n+    } else {\n+        // can't re-init after a cleanup\n+        rtassert!(QUEUE as uint != 1);\n     }\n+\n+    // FIXME: switch this to use atexit as below. Currently this\n+    // segfaults (the queue's memory is mysteriously gone), so\n+    // instead the cleanup is tied to the `std::rt` entry point.\n+    //\n+    // ::libc::atexit(cleanup);\n }\n \n pub fn cleanup() {\n     unsafe {\n-        let queue = QUEUE.swap(0, atomic::SeqCst);\n-        if queue != 0 {\n+        LOCK.lock();\n+        let queue = QUEUE;\n+        QUEUE = 1 as *mut _;\n+        LOCK.unlock();\n+\n+        // make sure we're not recursively cleaning up\n+        rtassert!(queue as uint != 1);\n+\n+        // If we never called init, not need to cleanup!\n+        if queue as uint != 0 {\n             let queue: Box<Queue> = mem::transmute(queue);\n-            let v = mem::replace(&mut *queue.lock(), Vec::new());\n-            for to_run in v.into_iter() {\n+            for to_run in queue.into_iter() {\n                 to_run.invoke(());\n             }\n         }\n     }\n }\n \n pub fn push(f: Thunk) {\n-    INIT.doit(init);\n     unsafe {\n-        // Note that the check against 0 for the queue pointer is not atomic at\n-        // all with respect to `run`, meaning that this could theoretically be a\n-        // use-after-free. There's not much we can do to protect against that,\n-        // however. Let's just assume a well-behaved runtime and go from there!\n-        let queue = QUEUE.load(atomic::SeqCst);\n-        rtassert!(queue != 0);\n-        (*(queue as *const Queue)).lock().push(f);\n+        LOCK.lock();\n+        init();\n+        (*QUEUE).push(f);\n+        LOCK.unlock();\n     }\n }"}, {"sha": "60b0d584db3a7a6936fa8c1f160c19109739d331", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5759cff48e66bcf2bf2cf821211bdf683292d8f3/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5759cff48e66bcf2bf2cf821211bdf683292d8f3/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=5759cff48e66bcf2bf2cf821211bdf683292d8f3", "patch": "@@ -14,7 +14,7 @@ use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n \n use mem;\n use rt;\n-use sync::{ONCE_INIT, Once, Mutex};\n+use sys_common::mutex::{MUTEX_INIT, Mutex};\n \n pub type Key = DWORD;\n pub type Dtor = unsafe extern fn(*mut u8);\n@@ -53,8 +53,12 @@ pub type Dtor = unsafe extern fn(*mut u8);\n // [2]: https://github.com/ChromiumWebApps/chromium/blob/master/base\n //                        /threading/thread_local_storage_win.cc#L42\n \n-static INIT_DTORS: Once = ONCE_INIT;\n-static mut DTORS: *mut Mutex<Vec<(Key, Dtor)>> = 0 as *mut _;\n+// NB these are specifically not types from `std::sync` as they currently rely\n+// on poisoning and this module needs to operate at a lower level than requiring\n+// the thread infrastructure to be in place (useful on the borders of\n+// initialization/destruction).\n+static DTOR_LOCK: Mutex = MUTEX_INIT;\n+static mut DTORS: *mut Vec<(Key, Dtor)> = 0 as *mut _;\n \n // -------------------------------------------------------------------------\n // Native bindings\n@@ -124,30 +128,40 @@ extern \"system\" {\n //\n // FIXME: This could probably be at least a little faster with a BTree.\n \n-fn init_dtors() {\n-    let dtors = box Mutex::new(Vec::<(Key, Dtor)>::new());\n-    unsafe {\n-        DTORS = mem::transmute(dtors);\n-    }\n+unsafe fn init_dtors() {\n+    if !DTORS.is_null() { return }\n+\n+    let dtors = box Vec::<(Key, Dtor)>::new();\n+    DTORS = mem::transmute(dtors);\n \n-    rt::at_exit(move|| unsafe {\n-        mem::transmute::<_, Box<Mutex<Vec<(Key, Dtor)>>>>(DTORS);\n+    rt::at_exit(move|| {\n+        DTOR_LOCK.lock();\n+        let dtors = DTORS;\n         DTORS = 0 as *mut _;\n+        mem::transmute::<_, Box<Vec<(Key, Dtor)>>>(dtors);\n+        assert!(DTORS.is_null()); // can't re-init after destructing\n+        DTOR_LOCK.unlock();\n     });\n }\n \n unsafe fn register_dtor(key: Key, dtor: Dtor) {\n-    INIT_DTORS.doit(init_dtors);\n-    let mut dtors = (*DTORS).lock();\n-    dtors.push((key, dtor));\n+    DTOR_LOCK.lock();\n+    init_dtors();\n+    (*DTORS).push((key, dtor));\n+    DTOR_LOCK.unlock();\n }\n \n unsafe fn unregister_dtor(key: Key) -> bool {\n-    if DTORS.is_null() { return false }\n-    let mut dtors = (*DTORS).lock();\n-    let before = dtors.len();\n-    dtors.retain(|&(k, _)| k != key);\n-    dtors.len() != before\n+    DTOR_LOCK.lock();\n+    init_dtors();\n+    let ret = {\n+        let dtors = &mut *DTORS;\n+        let before = dtors.len();\n+        dtors.retain(|&(k, _)| k != key);\n+        dtors.len() != before\n+    };\n+    DTOR_LOCK.unlock();\n+    ret\n }\n \n // -------------------------------------------------------------------------\n@@ -219,12 +233,20 @@ unsafe extern \"system\" fn on_tls_callback(h: LPVOID,\n }\n \n unsafe fn run_dtors() {\n-    if DTORS.is_null() { return }\n     let mut any_run = true;\n     for _ in range(0, 5i) {\n         if !any_run { break }\n         any_run = false;\n-        let dtors = (*DTORS).lock().iter().map(|p| *p).collect::<Vec<_>>();\n+        let dtors = {\n+            DTOR_LOCK.lock();\n+            let ret = if DTORS.is_null() {\n+                Vec::new()\n+            } else {\n+                (*DTORS).iter().map(|s| *s).collect()\n+            };\n+            DTOR_LOCK.unlock();\n+            ret\n+        };\n         for &(key, dtor) in dtors.iter() {\n             let ptr = TlsGetValue(key);\n             if !ptr.is_null() {"}]}