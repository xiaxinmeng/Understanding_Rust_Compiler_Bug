{"sha": "f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYzFmOTJkMGM1NTVkNmUzOGFkMWNhYzU1OTI2ZDZkOWM5YjA5MGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-02T17:52:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-02T17:52:50Z"}, "message": "auto merge of #8221 : brson/rust/single-threaded, r=graydon\n\nThis is the last major runtime feature needed for the transition to the new scheduler.", "tree": {"sha": "cfb40dd05237ea583f0f11d30ac8e27d9ceef736", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfb40dd05237ea583f0f11d30ac8e27d9ceef736"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f", "html_url": "https://github.com/rust-lang/rust/commit/f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc571820d1f41b63ec11436f24dc61a22f33dcd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc571820d1f41b63ec11436f24dc61a22f33dcd9", "html_url": "https://github.com/rust-lang/rust/commit/fc571820d1f41b63ec11436f24dc61a22f33dcd9"}, {"sha": "c3fa411459cdcc70c5893e44209320762cdc26d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3fa411459cdcc70c5893e44209320762cdc26d1", "html_url": "https://github.com/rust-lang/rust/commit/c3fa411459cdcc70c5893e44209320762cdc26d1"}], "stats": {"total": 123, "additions": 107, "deletions": 16}, "files": [{"sha": "5c9b142c052f5115ed87f465c22dc23e82f90fcd", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f", "patch": "@@ -39,14 +39,14 @@ use cell::Cell;\n pub struct Scheduler {\n     /// A queue of available work. Under a work-stealing policy there\n     /// is one per Scheduler.\n-    priv work_queue: WorkQueue<~Task>,\n+    work_queue: WorkQueue<~Task>,\n     /// The queue of incoming messages from other schedulers.\n     /// These are enqueued by SchedHandles after which a remote callback\n     /// is triggered to handle the message.\n     priv message_queue: MessageQueue<SchedMessage>,\n     /// A shared list of sleeping schedulers. We'll use this to wake\n     /// up schedulers when pushing work onto the work queue.\n-    priv sleeper_list: SleeperList,\n+    sleeper_list: SleeperList,\n     /// Indicates that we have previously pushed a handle onto the\n     /// SleeperList but have not yet received the Wake message.\n     /// Being `true` does not necessarily mean that the scheduler is\n@@ -158,6 +158,9 @@ impl Scheduler {\n         // scheduler. Grab it out of TLS - performing the scheduler\n         // action will have given it away.\n         let sched = Local::take::<Scheduler>();\n+\n+        rtdebug!(\"starting scheduler %u\", sched.sched_id());\n+\n         sched.run();\n \n         // Now that we are done with the scheduler, clean up the\n@@ -166,6 +169,9 @@ impl Scheduler {\n         // task.run() on the scheduler task we never get through all\n         // the cleanup code it runs.\n         let mut stask = Local::take::<Task>();\n+\n+        rtdebug!(\"stopping scheduler %u\", stask.sched.get_ref().sched_id());\n+\n         stask.destroyed = true;\n     }\n \n@@ -484,7 +490,7 @@ impl Scheduler {\n             return None;\n         } else if !homed && !this.run_anything {\n             // the task isn't homed, but it can't be run here\n-            this.enqueue_task(task);\n+            this.send_to_friend(task);\n             return Some(this);\n         } else {\n             // task isn't home, so don't run it here, send it home"}, {"sha": "19acedb56dd278939bddeb02c4113b4b27c65d66", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f", "patch": "@@ -971,16 +971,29 @@ fn test_try_fail() {\n     }\n }\n \n+#[cfg(test)]\n+fn get_sched_id() -> int {\n+    if context() == OldTaskContext {\n+        unsafe {\n+            rt::rust_get_sched_id() as int\n+        }\n+    } else {\n+        do Local::borrow::<::rt::sched::Scheduler, int> |sched| {\n+            sched.sched_id() as int\n+        }\n+    }\n+}\n+\n #[test]\n fn test_spawn_sched() {\n     let (po, ch) = stream::<()>();\n     let ch = SharedChan::new(ch);\n \n     fn f(i: int, ch: SharedChan<()>) {\n-        let parent_sched_id = unsafe { rt::rust_get_sched_id() };\n+        let parent_sched_id = get_sched_id();\n \n         do spawn_sched(SingleThreaded) {\n-            let child_sched_id = unsafe { rt::rust_get_sched_id() };\n+            let child_sched_id = get_sched_id();\n             assert!(parent_sched_id != child_sched_id);\n \n             if (i == 0) {\n@@ -1000,15 +1013,15 @@ fn test_spawn_sched_childs_on_default_sched() {\n     let (po, ch) = stream();\n \n     // Assuming tests run on the default scheduler\n-    let default_id = unsafe { rt::rust_get_sched_id() };\n+    let default_id = get_sched_id();\n \n     let ch = Cell::new(ch);\n     do spawn_sched(SingleThreaded) {\n-        let parent_sched_id = unsafe { rt::rust_get_sched_id() };\n+        let parent_sched_id = get_sched_id();\n         let ch = Cell::new(ch.take());\n         do spawn {\n             let ch = ch.take();\n-            let child_sched_id = unsafe { rt::rust_get_sched_id() };\n+            let child_sched_id = get_sched_id();\n             assert!(parent_sched_id != child_sched_id);\n             assert_eq!(child_sched_id, default_id);\n             ch.send(());"}, {"sha": "e6f115958fd40fd843f35b7614fae60ce5a89f20", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 80, "deletions": 8, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f", "patch": "@@ -78,13 +78,13 @@ use cast::transmute;\n use cast;\n use cell::Cell;\n use container::MutableMap;\n-use comm::{Chan, GenericChan};\n+use comm::{Chan, GenericChan, oneshot};\n use hashmap::{HashSet, HashSetConsumeIterator};\n use local_data;\n use task::local_data_priv::{local_get, local_set, OldHandle};\n use task::rt::rust_task;\n use task::rt;\n-use task::{Failure};\n+use task::{Failure, SingleThreaded};\n use task::{Success, TaskOpts, TaskResult};\n use task::unkillable;\n use to_bytes::IterBytes;\n@@ -93,9 +93,11 @@ use util;\n use unstable::sync::Exclusive;\n use rt::{OldTaskContext, TaskContext, SchedulerContext, GlobalContext, context};\n use rt::local::Local;\n-use rt::task::Task;\n+use rt::task::{Task, Sched};\n use rt::kill::KillHandle;\n use rt::sched::Scheduler;\n+use rt::uv::uvio::UvEventLoop;\n+use rt::thread::Thread;\n \n #[cfg(test)] use task::default_task_opts;\n #[cfg(test)] use comm;\n@@ -694,11 +696,81 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n         }\n     };\n \n-    let mut task = if opts.watched {\n-        Task::build_child(child_wrapper)\n-    } else {\n-        // An unwatched task is a new root in the exit-code propagation tree\n-        Task::build_root(child_wrapper)\n+    let mut task = unsafe {\n+        if opts.sched.mode != SingleThreaded {\n+            if opts.watched {\n+                Task::build_child(child_wrapper)\n+            } else {\n+                Task::build_root(child_wrapper)\n+            }\n+        } else {\n+            // Creating a 1:1 task:thread ...\n+            let sched = Local::unsafe_borrow::<Scheduler>();\n+            let sched_handle = (*sched).make_handle();\n+\n+            // Create a new scheduler to hold the new task\n+            let new_loop = ~UvEventLoop::new();\n+            let mut new_sched = ~Scheduler::new_special(new_loop,\n+                                                        (*sched).work_queue.clone(),\n+                                                        (*sched).sleeper_list.clone(),\n+                                                        false,\n+                                                        Some(sched_handle));\n+            let mut new_sched_handle = new_sched.make_handle();\n+\n+            // Allow the scheduler to exit when the pinned task exits\n+            new_sched_handle.send(Shutdown);\n+\n+            // Pin the new task to the new scheduler\n+            let new_task = if opts.watched {\n+                Task::build_homed_child(child_wrapper, Sched(new_sched_handle))\n+            } else {\n+                Task::build_homed_root(child_wrapper, Sched(new_sched_handle))\n+            };\n+\n+            // Create a task that will later be used to join with the new scheduler\n+            // thread when it is ready to terminate\n+            let (thread_port, thread_chan) = oneshot();\n+            let thread_port_cell = Cell::new(thread_port);\n+            let join_task = do Task::build_child() {\n+                rtdebug!(\"running join task\");\n+                let thread_port = thread_port_cell.take();\n+                let thread: Thread = thread_port.recv();\n+                thread.join();\n+            };\n+\n+            // Put the scheduler into another thread\n+            let new_sched_cell = Cell::new(new_sched);\n+            let orig_sched_handle_cell = Cell::new((*sched).make_handle());\n+            let join_task_cell = Cell::new(join_task);\n+\n+            let thread = do Thread::start {\n+                let mut new_sched = new_sched_cell.take();\n+                let mut orig_sched_handle = orig_sched_handle_cell.take();\n+                let join_task = join_task_cell.take();\n+\n+                let bootstrap_task = ~do Task::new_root(&mut new_sched.stack_pool) || {\n+                    rtdebug!(\"boostraping a 1:1 scheduler\");\n+                };\n+                new_sched.bootstrap(bootstrap_task);\n+\n+                rtdebug!(\"enqueing join_task\");\n+                // Now tell the original scheduler to join with this thread\n+                // by scheduling a thread-joining task on the original scheduler\n+                orig_sched_handle.send(TaskFromFriend(join_task));\n+\n+                // NB: We can't simply send a message from here to another task\n+                // because this code isn't running in a task and message passing doesn't\n+                // work outside of tasks. Hence we're sending a scheduler message\n+                // to execute a new task directly to a scheduler.\n+            };\n+\n+            // Give the thread handle to the join task\n+            thread_chan.send(thread);\n+\n+            // When this task is enqueued on the current scheduler it will then get\n+            // forwarded to the scheduler to which it is pinned\n+            new_task\n+        }\n     };\n \n     if opts.notify_chan.is_some() {"}]}