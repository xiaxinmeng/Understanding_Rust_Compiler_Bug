{"sha": "cdba212e7299f6bda752abbb9f887c51d96f7586", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYmEyMTJlNzI5OWY2YmRhNzUyYWJiYjlmODg3YzUxZDk2Zjc1ODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-07T17:32:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-07T17:32:20Z"}, "message": "auto merge of #8326 : thestinger/rust/iterator, r=alexcrichton\n\nThe `extra::iter` module wasn't actually included in `extra.rs` when it was moved from `std`... I assume no one is going to miss it.", "tree": {"sha": "9d2ab6bb31a5b472120010e55fe439de4b94f3af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d2ab6bb31a5b472120010e55fe439de4b94f3af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdba212e7299f6bda752abbb9f887c51d96f7586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdba212e7299f6bda752abbb9f887c51d96f7586", "html_url": "https://github.com/rust-lang/rust/commit/cdba212e7299f6bda752abbb9f887c51d96f7586", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdba212e7299f6bda752abbb9f887c51d96f7586/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29ffbbaaa850d3f8fe1b35e3a63defe9206a3eb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/29ffbbaaa850d3f8fe1b35e3a63defe9206a3eb7", "html_url": "https://github.com/rust-lang/rust/commit/29ffbbaaa850d3f8fe1b35e3a63defe9206a3eb7"}, {"sha": "55f3d04101c214a13f7d47fbdb140c5c1126c41b", "url": "https://api.github.com/repos/rust-lang/rust/commits/55f3d04101c214a13f7d47fbdb140c5c1126c41b", "html_url": "https://github.com/rust-lang/rust/commit/55f3d04101c214a13f7d47fbdb140c5c1126c41b"}], "stats": {"total": 509, "additions": 128, "deletions": 381}, "files": [{"sha": "b5677a261c45bffd12d1d80907e3df7ed035f45f", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -544,7 +544,7 @@ an intermediate generation has already exited:\n ~~~\n # use std::task;\n # fn sleep_forever() { loop { task::yield() } }\n-# fn wait_for_a_while() { do 1000.times { task::yield() } }\n+# fn wait_for_a_while() { for _ in range(0, 1000u) { task::yield() } }\n # do task::try::<int> {\n do task::spawn_supervised {\n     do task::spawn_supervised {\n@@ -563,7 +563,7 @@ other at all, using `task::spawn_unlinked` for _isolated failure_.\n ~~~\n # use std::task;\n # fn random() -> uint { 100 }\n-# fn sleep_for(i: uint) { do i.times { task::yield() } }\n+# fn sleep_for(i: uint) { for _ in range(0, i) { task::yield() } }\n # do task::try::<()> {\n let (time1, time2) = (random(), random());\n do task::spawn_unlinked {"}, {"sha": "6e6b804aa9d3408123dffe40f2a70c5f2a85a702", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -1894,7 +1894,7 @@ struct TimeBomb {\n \n impl Drop for TimeBomb {\n     fn drop(&self) {\n-        do self.explosivity.times {\n+        for _ in range(0, self.explosivity) {\n             println(\"blam!\");\n         }\n     }"}, {"sha": "7fd47fdbd3999a7f336e837e0c67e008381b15d4", "filename": "src/libextra/iter.rs", "status": "removed", "additions": 0, "deletions": 331, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/29ffbbaaa850d3f8fe1b35e3a63defe9206a3eb7/src%2Flibextra%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ffbbaaa850d3f8fe1b35e3a63defe9206a3eb7/src%2Flibextra%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fiter.rs?ref=29ffbbaaa850d3f8fe1b35e3a63defe9206a3eb7", "patch": "@@ -1,331 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*! Composable internal iterators\n-\n-Internal iterators are functions implementing the protocol used by the `for` loop.\n-\n-An internal iterator takes `fn(...) -> bool` as a parameter, with returning `false` used to signal\n-breaking out of iteration. The adaptors in the module work with any such iterator, not just ones\n-tied to specific traits. For example:\n-\n-~~~ {.rust}\n-println(iter::to_vec(|f| uint::range(0, 20, f)).to_str());\n-~~~\n-\n-An external iterator object implementing the interface in the `iterator` module can be used as an\n-internal iterator by calling the `advance` method. For example:\n-\n-~~~ {.rust}\n-let xs = [0u, 1, 2, 3, 4, 5];\n-let ys = [30, 40, 50, 60];\n-let mut it = xs.iter().chain(ys.iter());\n-for &x: &uint in it {\n-    println(x.to_str());\n-}\n-~~~\n-\n-Internal iterators provide a subset of the functionality of an external iterator. It's not possible\n-to interleave them to implement algorithms like `zip`, `union` and `merge`. However, they're often\n-much easier to implement.\n-\n-*/\n-\n-use std::vec;\n-use std::cmp::Ord;\n-use std::option::{Option, Some, None};\n-use std::num::{One, Zero};\n-use std::ops::{Add, Mul};\n-\n-#[allow(missing_doc)]\n-pub trait FromIter<T> {\n-    /// Build a container with elements from an internal iterator.\n-    ///\n-    /// # Example:\n-    ///\n-    /// ~~~ {.rust}\n-    /// let xs = ~[1, 2, 3];\n-    /// let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n-    /// assert_eq!(xs, ys);\n-    /// ~~~\n-    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> Self;\n-}\n-\n-/**\n- * Return true if `predicate` is true for any values yielded by an internal iterator.\n- *\n- * Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[1u, 2, 3, 4, 5];\n- * assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n- * assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n- * ~~~\n- */\n-#[inline]\n-pub fn any<T>(predicate: &fn(T) -> bool,\n-              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n-    do iter |x| {\n-        predicate(x)\n-    }\n-}\n-\n-/**\n- * Return true if `predicate` is true for all values yielded by an internal iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * assert!(all(|&x: &uint| x < 6, |f| uint::range(1, 6, f)));\n- * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n- * ~~~\n- */\n-#[inline]\n-pub fn all<T>(predicate: &fn(T) -> bool,\n-              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n-    // If we ever break, iter will return false, so this will only return true\n-    // if predicate returns true for everything.\n-    iter(|x| predicate(x))\n-}\n-\n-/**\n- * Return the first element where `predicate` returns `true`. Return `None` if no element is found.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[1u, 2, 3, 4, 5, 6];\n- * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n- * ~~~\n- */\n-#[inline]\n-pub fn find<T>(predicate: &fn(&T) -> bool,\n-               iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut ret = None;\n-    do iter |x| {\n-        if predicate(&x) {\n-            ret = Some(x);\n-            false\n-        } else { true }\n-    };\n-    ret\n-}\n-\n-/**\n- * Return the largest item yielded by an iterator. Return `None` if the iterator is empty.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n- * ~~~\n- */\n-#[inline]\n-pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut result = None;\n-    do iter |x| {\n-        match result {\n-            Some(ref mut y) => {\n-                if x > *y {\n-                    *y = x;\n-                }\n-            }\n-            None => result = Some(x)\n-        }\n-        true\n-    };\n-    result\n-}\n-\n-/**\n- * Return the smallest item yielded by an iterator. Return `None` if the iterator is empty.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &-5);\n- * ~~~\n- */\n-#[inline]\n-pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut result = None;\n-    do iter |x| {\n-        match result {\n-            Some(ref mut y) => {\n-                if x < *y {\n-                    *y = x;\n-                }\n-            }\n-            None => result = Some(x)\n-        }\n-        true\n-    };\n-    result\n-}\n-\n-/**\n- * Reduce an iterator to an accumulated value.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n- * ~~~\n- */\n-#[inline]\n-pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {\n-    let mut result = start;\n-    do iter |x| {\n-        f(&mut result, x);\n-        true\n-    };\n-    result\n-}\n-\n-/**\n- * Reduce an iterator to an accumulated value.\n- *\n- * `fold_ref` is usable in some generic functions where `fold` is too lenient to type-check, but it\n- * forces the iterator to yield borrowed pointers.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n- *     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n- * }\n- * ~~~\n- */\n-#[inline]\n-pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&mut T, &U)) -> T {\n-    let mut result = start;\n-    do iter |x| {\n-        f(&mut result, x);\n-        true\n-    };\n-    result\n-}\n-\n-/**\n- * Return the sum of the items yielding by an iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n- * ~~~\n- */\n-#[inline]\n-pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n-    fold_ref(Zero::zero::<T>(), iter, |a, x| *a = a.add(x))\n-}\n-\n-/**\n- * Return the product of the items yielded by an iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n- * ~~~\n- */\n-#[inline]\n-pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n-    fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n-}\n-\n-impl<T> FromIter<T> for ~[T]{\n-    #[inline]\n-    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n-        let mut v = ~[];\n-        do iter |x| { v.push(x); true };\n-        v\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use prelude::*;\n-\n-    use int;\n-    use uint;\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = ~[1, 2, 3];\n-        let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n-        assert_eq!(xs, ys);\n-    }\n-\n-    #[test]\n-    fn test_any() {\n-        let xs = ~[1u, 2, 3, 4, 5];\n-        assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n-        assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n-    }\n-\n-    #[test]\n-    fn test_all() {\n-        assert!(all(|x: uint| x < 6, |f| uint::range(1, 6, f)));\n-        assert!(!all(|x: uint| x < 5, |f| uint::range(1, 6, f)));\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        let xs = ~[1u, 2, 3, 4, 5, 6];\n-        assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n-    }\n-\n-    #[test]\n-    fn test_max() {\n-        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n-    }\n-\n-    #[test]\n-    fn test_min() {\n-        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(min(|f| xs.iter().advance(f)).unwrap(), &-5);\n-    }\n-\n-    #[test]\n-    fn test_fold() {\n-        assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n-    }\n-\n-    #[test]\n-    fn test_sum() {\n-        let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n-    }\n-\n-    #[test]\n-    fn test_empty_sum() {\n-        let xs: ~[int] = ~[];\n-        assert_eq!(do sum |f| { xs.iter().advance(f) }, 0);\n-    }\n-\n-    #[test]\n-    fn test_product() {\n-        let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n-    }\n-\n-    #[test]\n-    fn test_empty_product() {\n-        let xs: ~[int] = ~[];\n-        assert_eq!(do product |f| { xs.iter().advance(f) }, 1);\n-    }\n-}"}, {"sha": "da8089250b34587a24cd3191031c87c286b40f1d", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -696,7 +696,7 @@ mod tests {\n         let u: ~[int] = deq.iter().transform(|&x| x).collect();\n         assert_eq!(u, v);\n \n-        let mut seq = iterator::Counter::new(0u, 2).take_(256);\n+        let mut seq = iterator::count(0u, 2).take_(256);\n         let deq: RingBuf<uint> = seq.collect();\n         for (i, &x) in deq.iter().enumerate() {\n             assert_eq!(2*i, x);"}, {"sha": "b1e600b9d7376f5466d53ba06a500a948fe8e90d", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -888,6 +888,11 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let offset = get_param(decl, first_real_arg + 1);\n             Ret(bcx, GEP(bcx, ptr, [offset]));\n         }\n+        \"offset_inbounds\" => {\n+            let ptr = get_param(decl, first_real_arg);\n+            let offset = get_param(decl, first_real_arg + 1);\n+            Ret(bcx, InBoundsGEP(bcx, ptr, [offset]));\n+        }\n         \"memcpy32\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i32\", substs.tys[0], 32),\n         \"memcpy64\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i64\", substs.tys[0], 64),\n         \"memmove32\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i32\", substs.tys[0], 32),"}, {"sha": "ad83286c8c1d75a60353ab2a36c2f248f0665f26", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -148,7 +148,8 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n                     \"visit_tydesc\"  | \"forget\" | \"frame_address\" |\n                     \"morestack_addr\" => 0,\n \n-                    \"offset\" | \"memcpy32\" | \"memcpy64\" | \"memmove32\" | \"memmove64\" |\n+                    \"offset\" | \"offset_inbounds\" |\n+                    \"memcpy32\" | \"memcpy64\" | \"memmove32\" | \"memmove64\" |\n                     \"memset32\" | \"memset64\" => use_repr,\n \n                     \"sqrtf32\" | \"sqrtf64\" | \"powif32\" | \"powif64\" |"}, {"sha": "8623ee546d6603a0c6cb2ff52b7e31afb299a16e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -3481,6 +3481,20 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                    mutbl: ast::m_imm\n                }))\n             }\n+            \"offset_inbounds\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_imm\n+                  }),\n+                  ty::mk_int()\n+               ],\n+               ty::mk_ptr(tcx, ty::mt {\n+                   ty: param(ccx, 0),\n+                   mutbl: ast::m_imm\n+               }))\n+            }\n             \"memcpy32\" => {\n               (1,\n                ~["}, {"sha": "f05c59083f40f49f5288e1348b6a2a126c4a366e", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -637,7 +637,7 @@ mod test {\n         let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n         write_markdown(doc, writer_factory);\n         // We expect two pages to have been written\n-        do 2.times {\n+        for _ in range(0, 2u) {\n             po.recv();\n         }\n     }\n@@ -649,7 +649,7 @@ mod test {\n             ~\"#[link(name = \\\"core\\\")]; mod a { }\");\n         let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n         write_markdown(doc, writer_factory);\n-        do 2.times {\n+        for _ in range(0, 2u) {\n             let (page, markdown) = po.recv();\n             match page {\n                 doc::CratePage(_) => {"}, {"sha": "1be398966bbeba7281775a4929559dec9fba2ba7", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -313,7 +313,7 @@ pub trait IteratorUtil<A> {\n     /// ~~~ {.rust}\n     /// let xs = [2u, 3];\n     /// let ys = [0u, 1, 0, 1, 2];\n-    /// let mut it = xs.iter().flat_map_(|&x| Counter::new(0u, 1).take_(x));\n+    /// let mut it = xs.iter().flat_map_(|&x| count(0u, 1).take_(x));\n     /// // Check that `it` has the same elements as `ys`\n     /// let mut i = 0;\n     /// for x: uint in it {\n@@ -351,7 +351,7 @@ pub trait IteratorUtil<A> {\n     /// ~~~ {.rust}\n     /// use std::iterator::Counter;\n     ///\n-    /// for i in Counter::new(0, 10) {\n+    /// for i in count(0, 10) {\n     ///     printfln!(\"%d\", i);\n     /// }\n     /// ~~~\n@@ -723,7 +723,7 @@ pub trait MultiplicativeIterator<A> {\n     /// use std::iterator::Counter;\n     ///\n     /// fn factorial(n: uint) -> uint {\n-    ///     Counter::new(1u, 1).take_while(|&i| i <= n).product()\n+    ///     count(1u, 1).take_while(|&i| i <= n).product()\n     /// }\n     /// assert!(factorial(0) == 1);\n     /// assert!(factorial(1) == 1);\n@@ -790,7 +790,7 @@ pub trait ClonableIterator {\n     /// # Example\n     ///\n     /// ~~~ {.rust}\n-    /// let a = Counter::new(1,1).take_(1);\n+    /// let a = count(1,1).take_(1);\n     /// let mut cy = a.cycle();\n     /// assert_eq!(cy.next(), Some(1));\n     /// assert_eq!(cy.next(), Some(1));\n@@ -1300,10 +1300,9 @@ pub struct Take<T> {\n impl<A, T: Iterator<A>> Iterator<A> for Take<T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        let next = self.iter.next();\n         if self.n != 0 {\n             self.n -= 1;\n-            next\n+            self.iter.next()\n         } else {\n             None\n         }\n@@ -1512,12 +1511,10 @@ pub struct Counter<A> {\n     step: A\n }\n \n-impl<A> Counter<A> {\n-    /// Creates a new counter with the specified start/step\n-    #[inline]\n-    pub fn new(start: A, step: A) -> Counter<A> {\n-        Counter{state: start, step: step}\n-    }\n+/// Creates a new counter with the specified start/step\n+#[inline]\n+pub fn count<A>(start: A, step: A) -> Counter<A> {\n+    Counter{state: start, step: step}\n }\n \n /// A range of numbers from [0, N)\n@@ -1604,7 +1601,7 @@ mod tests {\n \n     #[test]\n     fn test_counter_from_iter() {\n-        let mut it = Counter::new(0, 5).take_(10);\n+        let mut it = count(0, 5).take_(10);\n         let xs: ~[int] = FromIterator::from_iterator(&mut it);\n         assert_eq!(xs, ~[0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n     }\n@@ -1622,7 +1619,7 @@ mod tests {\n         }\n         assert_eq!(i, expected.len());\n \n-        let ys = Counter::new(30u, 10).take_(4);\n+        let ys = count(30u, 10).take_(4);\n         let mut it = xs.iter().transform(|&x| x).chain_(ys);\n         let mut i = 0;\n         for x in it {\n@@ -1634,7 +1631,7 @@ mod tests {\n \n     #[test]\n     fn test_filter_map() {\n-        let mut it = Counter::new(0u, 1u).take_(10)\n+        let mut it = count(0u, 1u).take_(10)\n             .filter_map(|x| if x.is_even() { Some(x*x) } else { None });\n         assert_eq!(it.collect::<~[uint]>(), ~[0*0, 2*2, 4*4, 6*6, 8*8]);\n     }\n@@ -1723,7 +1720,7 @@ mod tests {\n     fn test_iterator_flat_map() {\n         let xs = [0u, 3, 6];\n         let ys = [0u, 1, 2, 3, 4, 5, 6, 7, 8];\n-        let mut it = xs.iter().flat_map_(|&x| Counter::new(x, 1).take_(3));\n+        let mut it = xs.iter().flat_map_(|&x| count(x, 1).take_(3));\n         let mut i = 0;\n         for x in it {\n             assert_eq!(x, ys[i]);\n@@ -1770,13 +1767,13 @@ mod tests {\n     #[test]\n     fn test_cycle() {\n         let cycle_len = 3;\n-        let it = Counter::new(0u, 1).take_(cycle_len).cycle();\n+        let it = count(0u, 1).take_(cycle_len).cycle();\n         assert_eq!(it.size_hint(), (uint::max_value, None));\n         for (i, x) in it.take_(100).enumerate() {\n             assert_eq!(i % cycle_len, x);\n         }\n \n-        let mut it = Counter::new(0u, 1).take_(0).cycle();\n+        let mut it = count(0u, 1).take_(0).cycle();\n         assert_eq!(it.size_hint(), (0, Some(0)));\n         assert_eq!(it.next(), None);\n     }\n@@ -1838,7 +1835,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator_size_hint() {\n-        let c = Counter::new(0, 1);\n+        let c = count(0, 1);\n         let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n         let v2 = &[10, 11, 12];\n         let vi = v.iter();"}, {"sha": "65db55297b3b70e673146e74b19f2c58d3121d52", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -49,6 +49,7 @@ pub use char::Char;\n pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n pub use hash::Hash;\n pub use iter::Times;\n+pub use iterator::Extendable;\n pub use iterator::{Iterator, IteratorUtil, DoubleEndedIterator, DoubleEndedIteratorUtil};\n pub use iterator::{ClonableIterator, OrdIterator};\n pub use num::{Num, NumCast};\n@@ -64,7 +65,7 @@ pub use path::WindowsPath;\n pub use ptr::RawPtr;\n pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, ToBytesConsume};\n pub use str::{Str, StrVector, StrSlice, OwnedStr, NullTerminatedStr};\n-pub use from_str::{FromStr};\n+pub use from_str::FromStr;\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, ToStrConsume};\n pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};"}, {"sha": "5a2bd0c4de9cea8e88cd256c87100c1eb42650d0", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -272,6 +272,7 @@ pub trait RawPtr<T> {\n     fn is_not_null(&self) -> bool;\n     unsafe fn to_option(&self) -> Option<&T>;\n     fn offset(&self, count: int) -> Self;\n+    unsafe fn offset_inbounds(self, count: int) -> Self;\n }\n \n /// Extension methods for immutable pointers\n@@ -304,6 +305,22 @@ impl<T> RawPtr<T> for *T {\n     /// Calculates the offset from a pointer.\n     #[inline]\n     fn offset(&self, count: int) -> *T { offset(*self, count) }\n+\n+    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n+    /// the object, or one-byte-past-the-end.\n+    #[inline]\n+    #[cfg(stage0)]\n+    unsafe fn offset_inbounds(self, count: int) -> *T {\n+        intrinsics::offset(self, count)\n+    }\n+\n+    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n+    /// the object, or one-byte-past-the-end.\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    unsafe fn offset_inbounds(self, count: int) -> *T {\n+        intrinsics::offset_inbounds(self, count)\n+    }\n }\n \n /// Extension methods for mutable pointers\n@@ -336,6 +353,30 @@ impl<T> RawPtr<T> for *mut T {\n     /// Calculates the offset from a mutable pointer.\n     #[inline]\n     fn offset(&self, count: int) -> *mut T { mut_offset(*self, count) }\n+\n+    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n+    /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n+    /// undefined behaviour.\n+    ///\n+    /// This method should be preferred over `offset` when the guarantee can be\n+    /// satisfied, to enable better optimization.\n+    #[inline]\n+    #[cfg(stage0)]\n+    unsafe fn offset_inbounds(self, count: int) -> *mut T {\n+        intrinsics::offset(self as *T, count) as *mut T\n+    }\n+\n+    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n+    /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n+    /// undefined behaviour.\n+    ///\n+    /// This method should be preferred over `offset` when the guarantee can be\n+    /// satisfied, to enable better optimization.\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    unsafe fn offset_inbounds(self, count: int) -> *mut T {\n+        intrinsics::offset_inbounds(self as *T, count) as *mut T\n+    }\n }\n \n // Equality for pointers"}, {"sha": "c60edad3dbd5683e6ec69cae281376a950089a6c", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -317,12 +317,21 @@ extern \"rust-intrinsic\" {\n     /// Get the address of the `__morestack` stack growth function.\n     pub fn morestack_addr() -> *();\n \n-    /// Adjust a pointer by an offset.\n+    /// Calculates the offset from a pointer.\n     ///\n     /// This is implemented as an intrinsic to avoid converting to and from an\n     /// integer, since the conversion would throw away aliasing information.\n     pub fn offset<T>(dst: *T, offset: int) -> *T;\n \n+    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n+    /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n+    /// undefined behaviour.\n+    ///\n+    /// This intrinsic should be preferred over `offset` when the guarantee can\n+    /// be satisfied, to enable better optimization.\n+    #[cfg(not(stage0))]\n+    pub fn offset_inbounds<T>(dst: *T, offset: int) -> *T;\n+\n     /// Equivalent to the `llvm.memcpy.p0i8.0i8.i32` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n     pub fn memcpy32<T>(dst: *mut T, src: *T, count: u32);"}, {"sha": "36201dc5e82665ab4a6c2abc2b03306cb594147a", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -849,10 +849,15 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn iter(self) -> VecIterator<'self, T> {\n         unsafe {\n             let p = vec::raw::to_ptr(self);\n-            VecIterator{ptr: p,\n-                        end: (p as uint + self.len() *\n-                              sys::nonzero_size_of::<T>()) as *T,\n-                        lifetime: cast::transmute(p)}\n+            if sys::size_of::<T>() == 0 {\n+                VecIterator{ptr: p,\n+                            end: (p as uint + self.len()) as *T,\n+                            lifetime: cast::transmute(p)}\n+            } else {\n+                VecIterator{ptr: p,\n+                            end: p.offset_inbounds(self.len() as int),\n+                            lifetime: cast::transmute(p)}\n+            }\n         }\n     }\n \n@@ -1826,10 +1831,15 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     fn mut_iter(self) -> VecMutIterator<'self, T> {\n         unsafe {\n             let p = vec::raw::to_mut_ptr(self);\n-            VecMutIterator{ptr: p,\n-                           end: (p as uint + self.len() *\n-                                 sys::nonzero_size_of::<T>()) as *mut T,\n-                           lifetime: cast::transmute(p)}\n+            if sys::size_of::<T>() == 0 {\n+                VecMutIterator{ptr: p,\n+                               end: (p as uint + self.len()) as *mut T,\n+                               lifetime: cast::transmute(p)}\n+            } else {\n+                VecMutIterator{ptr: p,\n+                               end: p.offset_inbounds(self.len() as int),\n+                               lifetime: cast::transmute(p)}\n+            }\n         }\n     }\n \n@@ -2183,7 +2193,7 @@ macro_rules! iterator {\n                             // same pointer.\n                             cast::transmute(self.ptr as uint + 1)\n                         } else {\n-                            self.ptr.offset(1)\n+                            self.ptr.offset_inbounds(1)\n                         };\n \n                         Some(cast::transmute(old))\n@@ -2215,7 +2225,7 @@ macro_rules! double_ended_iterator {\n                             // See above for why 'ptr.offset' isn't used\n                             cast::transmute(self.end as uint - 1)\n                         } else {\n-                            self.end.offset(-1)\n+                            self.end.offset_inbounds(-1)\n                         };\n                         Some(cast::transmute(self.end))\n                     }"}, {"sha": "70fe6f706f79a763683fdc6556f09c765e2a86f0", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -59,7 +59,7 @@ impl Results {\n         {\n             let mut set = f();\n             do timed(&mut self.random_ints) {\n-                do num_keys.times {\n+                for _ in range(0, num_keys) {\n                     set.insert((rng.next() as uint) % rand_cap);\n                 }\n             }\n@@ -103,7 +103,7 @@ impl Results {\n         {\n             let mut set = f();\n             do timed(&mut self.random_strings) {\n-                do num_keys.times {\n+                for _ in range(0, num_keys) {\n                     let s = uint::to_str(rng.next() as uint);\n                     set.insert(s);\n                 }"}, {"sha": "8503b188b2f25a27dd7d21bc6d01e5d991373abd", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -105,7 +105,7 @@ fn main() {\n     let symbols = [\" \", \"\u2591\", \"\u2592\", \"\u2593\", \"\u2588\", \"\u2588\"];\n     let mut pixels = [0f32, ..256*256];\n     let n2d = ~Noise2DContext::new();\n-    do 100.times {\n+    for _ in range(0, 100u) {\n         for y in range(0, 256) {\n             for x in range(0, 256) {\n                 let v = n2d.get("}, {"sha": "2b177ccb98fcc194a0dbf743619ac82764b6a447", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -169,7 +169,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n     let mut creatures_met = 0;\n \n     // set up meetings...\n-    do nn.times {\n+    for _ in range(0, nn) {\n         let fst_creature: CreatureInfo = from_creatures.recv();\n         let snd_creature: CreatureInfo = from_creatures.recv();\n "}, {"sha": "44b1a28c12b30f6134729c413ad587797beb7ce0", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -164,7 +164,7 @@ impl RandomFasta {\n             let chars_left = n % LINE_LEN;\n             let mut buf = [0, ..LINE_LEN + 1];\n \n-            do lines.times {\n+            for _ in range(0, lines) {\n                 for i in range(0u, LINE_LEN) {\n                     buf[i] = self.nextc();\n                 }"}, {"sha": "2b5b4ded94774690913cd7136db00954f26a387d", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -54,7 +54,7 @@ impl Code {\n     fn unpack(&self, frame: i32) -> ~str {\n         let mut key = **self;\n         let mut result = ~[];\n-        do (frame as uint).times {\n+        for _ in range(0, frame) {\n             result.push(unpack_symbol((key as u8) & 3));\n             key >>= 2;\n         }\n@@ -251,7 +251,7 @@ fn generate_frequencies(frequencies: &mut Table,\n     let mut code = Code(0);\n \n     // Pull first frame.\n-    do (frame as uint).times {\n+    for _ in range(0, frame) {\n         code = code.push_char(input[0]);\n         input = next_char(input);\n     }"}, {"sha": "6a9c5ea89e4fc6a196fff097ae1ac76eef0edc84", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -79,7 +79,7 @@ struct Planet {\n \n fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: i32) {\n     let mut d = [ 0.0, ..3 ];\n-    do (steps as uint).times {\n+    for _ in range(0, steps) {\n         for i in range(0u, N_BODIES) {\n             for j in range(i + 1, N_BODIES) {\n                 d[0] = bodies[i].x[0] - bodies[j].x[0];"}, {"sha": "ecf54bf16473e8833ad074be023b8f3fc80c3d2f", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -56,7 +56,7 @@ fn main() {\n     let mut u = vec::from_elem(n, 1f64);\n     let mut v = u.clone();\n     let mut tmp = u.clone();\n-    do 8.times {\n+    for _ in range(0, 8u) {\n         mult_AtAv(u, v, tmp);\n         mult_AtAv(v, u, tmp);\n     }"}, {"sha": "114c7e997a24f67cd22b4195ae6d4221c126d776", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -32,7 +32,7 @@ fn main() {\n }\n \n fn run(repeat: int, depth: int) {\n-    do (repeat as uint).times {\n+    for _ in range(0, repeat) {\n         info!(\"starting %.4f\", precise_time_s());\n         do task::try {\n             recurse_or_fail(depth, None)"}, {"sha": "15808427f4a8b55c08d2c442c48ab8e4acc50cfb", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdba212e7299f6bda752abbb9f887c51d96f7586/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=cdba212e7299f6bda752abbb9f887c51d96f7586", "patch": "@@ -32,7 +32,7 @@ fn grandchild_group(num_tasks: uint) {\n     let (po, ch) = stream();\n     let ch = SharedChan::new(ch);\n \n-    do num_tasks.times {\n+    for _ in range(0, num_tasks) {\n         let ch = ch.clone();\n         do task::spawn { // linked\n             ch.send(());\n@@ -41,7 +41,7 @@ fn grandchild_group(num_tasks: uint) {\n         }\n     }\n     error!(\"Grandchild group getting started\");\n-    do num_tasks.times {\n+    for _ in range(0, num_tasks) {\n         // Make sure all above children are fully spawned; i.e., enlisted in\n         // their ancestor groups.\n         po.recv();"}]}