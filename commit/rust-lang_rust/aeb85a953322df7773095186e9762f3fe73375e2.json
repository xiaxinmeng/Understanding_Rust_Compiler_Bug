{"sha": "aeb85a953322df7773095186e9762f3fe73375e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYjg1YTk1MzMyMmRmNzc3MzA5NTE4NmU5NzYyZjNmZTczMzc1ZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-11T12:38:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-11T12:38:04Z"}, "message": "Auto merge of #32133 - alexcrichton:linkchecker, r=brson\n\nAdd a link validator to rustbuild\n\nThis commit was originally targeted at just adding a link checking script to the rustbuild system. This ended up snowballing a bit to extend rustbuild to be amenable to various tools we have as part of the build system in general.\n\nThere's a new `src/tools` directory which has a number of scripts/programs that are purely intended to be used as part of the build system and CI of this repository. This is currently inhabited by rustbook, the error index generator, and a new linkchecker script added as part of this PR. I suspect that more tools like compiletest, tidy scripts, snapshot scripts, etc will migrate their way into this directory over time.\n\nThe commit which adds the error index generator shows the steps necessary to add new tools to the build system, namely:\n\n1. New steps are defined for building the tool and running the tool\n2. The dependencies are configured\n3. The steps are implemented\n\nIn terms of the link checker, these commits do a few things:\n\n* A new `src/tools/linkchecker` script is added. This will read an entire documentation tree looking for broken relative links (HTTP links aren't followed yet).\n* A large number of broken links throughout the documentation were fixed. Many of these were just broken when viewed from core as opposed to std, but were easily fixed.\n* A few rustdoc bugs here and there were fixed", "tree": {"sha": "81ea15e110932e2a990351a9bea602599c23cb6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81ea15e110932e2a990351a9bea602599c23cb6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aeb85a953322df7773095186e9762f3fe73375e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aeb85a953322df7773095186e9762f3fe73375e2", "html_url": "https://github.com/rust-lang/rust/commit/aeb85a953322df7773095186e9762f3fe73375e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aeb85a953322df7773095186e9762f3fe73375e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40c85cd8aec5de06140252610ad4bdc352324e2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/40c85cd8aec5de06140252610ad4bdc352324e2c", "html_url": "https://github.com/rust-lang/rust/commit/40c85cd8aec5de06140252610ad4bdc352324e2c"}, {"sha": "3e6fed3a7a3f783bf967f6c73455743848f31167", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e6fed3a7a3f783bf967f6c73455743848f31167", "html_url": "https://github.com/rust-lang/rust/commit/3e6fed3a7a3f783bf967f6c73455743848f31167"}], "stats": {"total": 1114, "additions": 813, "deletions": 301}, "files": [{"sha": "d8e0390504b975fd8ee1706c8eb32108f3014109", "filename": "mk/crates.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -126,8 +126,8 @@ TOOL_DEPS_error_index_generator := rustdoc syntax serialize\n TOOL_SOURCE_compiletest := $(S)src/compiletest/compiletest.rs\n TOOL_SOURCE_rustdoc := $(S)src/driver/driver.rs\n TOOL_SOURCE_rustc := $(S)src/driver/driver.rs\n-TOOL_SOURCE_rustbook := $(S)src/rustbook/main.rs\n-TOOL_SOURCE_error_index_generator := $(S)src/error_index_generator/main.rs\n+TOOL_SOURCE_rustbook := $(S)src/tools/rustbook/main.rs\n+TOOL_SOURCE_error_index_generator := $(S)src/tools/error_index_generator/main.rs\n \n ONLY_RLIB_core := 1\n ONLY_RLIB_libc := 1"}, {"sha": "0d334219b4fe924db73224b89768444f8a4a17ba", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -15,6 +15,10 @@ path = \"main.rs\"\n name = \"rustc\"\n path = \"rustc.rs\"\n \n+[[bin]]\n+name = \"rustdoc\"\n+path = \"rustdoc.rs\"\n+\n [dependencies]\n build_helper = { path = \"../build_helper\" }\n cmake = \"0.1.10\""}, {"sha": "19293e80217e34b402c32242e93023edf2634cb5", "filename": "src/bootstrap/build/check.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fbuild%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fbuild%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcheck.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::process::Command;\n+\n+use build::{Build, Compiler};\n+\n+pub fn linkcheck(build: &Build, stage: u32, host: &str) {\n+    println!(\"Linkcheck stage{} ({})\", stage, host);\n+    let compiler = Compiler::new(stage, host);\n+    let linkchecker = build.tool(&compiler, \"linkchecker\");\n+    build.run(Command::new(&linkchecker)\n+                     .arg(build.out.join(host).join(\"doc\")));\n+}"}, {"sha": "0a293579cf67d814e0b16bf83c087ad9b2c7f83d", "filename": "src/bootstrap/build/compile.rs", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcompile.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -16,7 +16,7 @@ use std::process::Command;\n use build_helper::output;\n \n use build::util::{exe, staticlib, libdir, mtime, is_dylib};\n-use build::{Build, Compiler};\n+use build::{Build, Compiler, Mode};\n \n /// Build the standard library.\n ///\n@@ -39,9 +39,10 @@ pub fn std<'a>(build: &'a Build, stage: u32, target: &str,\n \n     build_startup_objects(build, target, &libdir);\n \n-    let out_dir = build.cargo_out(stage, &host, true, target);\n+    let out_dir = build.cargo_out(stage, &host, Mode::Libstd, target);\n     build.clear_if_dirty(&out_dir, &build.compiler_path(compiler));\n-    let mut cargo = build.cargo(stage, compiler, true, target, \"build\");\n+    let mut cargo = build.cargo(stage, compiler, Mode::Libstd, Some(target),\n+                                \"build\");\n     cargo.arg(\"--features\").arg(build.std_features())\n          .arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/std_shim/Cargo.toml\"));\n@@ -71,7 +72,7 @@ pub fn std_link(build: &Build,\n                 compiler: &Compiler,\n                 host: &str) {\n     let libdir = build.sysroot_libdir(stage, host, target);\n-    let out_dir = build.cargo_out(stage, compiler.host, true, target);\n+    let out_dir = build.cargo_out(stage, compiler.host, Mode::Libstd, target);\n \n     // If we're linking one compiler host's output into another, then we weren't\n     // called from the `std` method above. In that case we clean out what's\n@@ -135,19 +136,15 @@ pub fn rustc<'a>(build: &'a Build, stage: u32, target: &str,\n     println!(\"Building stage{} compiler artifacts ({} -> {})\", stage,\n              host, target);\n \n-    let out_dir = build.cargo_out(stage, &host, false, target);\n+    let out_dir = build.cargo_out(stage, &host, Mode::Librustc, target);\n     build.clear_if_dirty(&out_dir, &libstd_shim(build, stage, &host, target));\n \n-    let mut cargo = build.cargo(stage, compiler, false, target, \"build\");\n-    cargo.arg(\"--features\").arg(build.rustc_features(stage))\n+    let mut cargo = build.cargo(stage, compiler, Mode::Librustc, Some(target),\n+                                \"build\");\n+    cargo.arg(\"--features\").arg(build.rustc_features())\n          .arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/Cargo.toml\"));\n \n-    // In stage0 we may not need to build as many executables\n-    if stage == 0 {\n-        cargo.arg(\"--bin\").arg(\"rustc\");\n-    }\n-\n     // Set some configuration variables picked up by build scripts and\n     // the compiler alike\n     cargo.env(\"CFG_RELEASE\", &build.release)\n@@ -200,14 +197,14 @@ pub fn rustc_link(build: &Build,\n                   compiler: &Compiler,\n                   host: &str) {\n     let libdir = build.sysroot_libdir(stage, host, target);\n-    let out_dir = build.cargo_out(stage, compiler.host, false, target);\n+    let out_dir = build.cargo_out(stage, compiler.host, Mode::Librustc, target);\n     add_to_sysroot(&out_dir, &libdir);\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n fn libstd_shim(build: &Build, stage: u32, host: &str, target: &str) -> PathBuf {\n-    build.cargo_out(stage, host, true, target).join(\"libstd_shim.rlib\")\n+    build.cargo_out(stage, host, Mode::Libstd, target).join(\"libstd_shim.rlib\")\n }\n \n fn compiler_file(compiler: &Path, file: &str) -> String {\n@@ -239,7 +236,8 @@ pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n         }\n     }\n \n-    let out_dir = build.cargo_out(stage - 1, &build.config.build, false, host);\n+    let out_dir = build.cargo_out(stage - 1, &build.config.build,\n+                                  Mode::Librustc, host);\n \n     // Link the compiler binary itself into place\n     let rustc = out_dir.join(exe(\"rustc\", host));\n@@ -298,3 +296,27 @@ fn add_to_sysroot(out_dir: &Path, sysroot_dst: &Path) {\n                          sysroot_dst.join(path.file_name().unwrap())));\n     }\n }\n+\n+/// Build a tool in `src/tools`\n+///\n+/// This will build the specified tool with the specified `host` compiler in\n+/// `stage` into the normal cargo output directory.\n+pub fn tool(build: &Build, stage: u32, host: &str, tool: &str) {\n+    println!(\"Building stage{} tool {} ({})\", stage, tool, host);\n+\n+    let compiler = Compiler::new(stage, host);\n+\n+    // FIXME: need to clear out previous tool and ideally deps, may require\n+    //        isolating output directories or require a pseudo shim step to\n+    //        clear out all the info.\n+    //\n+    //        Maybe when libstd is compiled it should clear out the rustc of the\n+    //        corresponding stage?\n+    // let out_dir = build.cargo_out(stage, &host, Mode::Librustc, target);\n+    // build.clear_if_dirty(&out_dir, &libstd_shim(build, stage, &host, target));\n+\n+    let mut cargo = build.cargo(stage, &compiler, Mode::Tool, None, \"build\");\n+    cargo.arg(\"--manifest-path\")\n+         .arg(build.src.join(format!(\"src/tools/{}/Cargo.toml\", tool)));\n+    build.run(&mut cargo);\n+}"}, {"sha": "51bf752e06d342452455a7d3b2f0c9d2e2a5839d", "filename": "src/bootstrap/build/doc.rs", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fbuild%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fbuild%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fdoc.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::path::Path;\n use std::fs::{self, File};\n use std::io::prelude::*;\n+use std::path::Path;\n+use std::process::Command;\n \n-use build::{Build, Compiler};\n-use build::util::up_to_date;\n+use build::{Build, Compiler, Mode};\n+use build::util::{up_to_date, cp_r};\n \n pub fn rustbook(build: &Build, stage: u32, host: &str, name: &str, out: &Path) {\n     t!(fs::create_dir_all(out));\n@@ -69,7 +70,7 @@ pub fn standalone(build: &Build, stage: u32, host: &str, out: &Path) {\n         }\n \n         let html = out.join(filename).with_extension(\"html\");\n-        let rustdoc = build.tool(&compiler, \"rustdoc\");\n+        let rustdoc = build.rustdoc(&compiler);\n         if up_to_date(&path, &html) &&\n            up_to_date(&footer, &html) &&\n            up_to_date(&favicon, &html) &&\n@@ -79,7 +80,7 @@ pub fn standalone(build: &Build, stage: u32, host: &str, out: &Path) {\n             continue\n         }\n \n-        let mut cmd = build.tool_cmd(&compiler, \"rustdoc\");\n+        let mut cmd = Command::new(&rustdoc);\n         cmd.arg(\"--html-after-content\").arg(&footer)\n            .arg(\"--html-before-content\").arg(&version_info)\n            .arg(\"--html-in-header\").arg(&favicon)\n@@ -102,3 +103,52 @@ pub fn standalone(build: &Build, stage: u32, host: &str, out: &Path) {\n         build.run(&mut cmd);\n     }\n }\n+\n+pub fn std(build: &Build, stage: u32, host: &str, out: &Path) {\n+    println!(\"Documenting stage{} std ({})\", stage, host);\n+    let compiler = Compiler::new(stage, host);\n+    let out_dir = build.stage_out(stage, host, Mode::Libstd)\n+                       .join(host).join(\"doc\");\n+    let rustdoc = build.rustdoc(&compiler);\n+\n+    build.clear_if_dirty(&out_dir, &rustdoc);\n+\n+    let mut cargo = build.cargo(stage, &compiler, Mode::Libstd, Some(host),\n+                                \"doc\");\n+    cargo.arg(\"--manifest-path\")\n+         .arg(build.src.join(\"src/rustc/std_shim/Cargo.toml\"))\n+         .arg(\"--features\").arg(build.std_features());\n+    build.run(&mut cargo);\n+    cp_r(&out_dir, out)\n+}\n+\n+pub fn rustc(build: &Build, stage: u32, host: &str, out: &Path) {\n+    println!(\"Documenting stage{} compiler ({})\", stage, host);\n+    let compiler = Compiler::new(stage, host);\n+    let out_dir = build.stage_out(stage, host, Mode::Librustc)\n+                       .join(host).join(\"doc\");\n+    let rustdoc = build.rustdoc(&compiler);\n+    if !up_to_date(&rustdoc, &out_dir.join(\"rustc/index.html\")) {\n+        t!(fs::remove_dir_all(&out_dir));\n+    }\n+    let mut cargo = build.cargo(stage, &compiler, Mode::Librustc, Some(host),\n+                                \"doc\");\n+    cargo.arg(\"--manifest-path\")\n+         .arg(build.src.join(\"src/rustc/Cargo.toml\"))\n+         .arg(\"--features\").arg(build.rustc_features());\n+    build.run(&mut cargo);\n+    cp_r(&out_dir, out)\n+}\n+\n+pub fn error_index(build: &Build, stage: u32, host: &str, out: &Path) {\n+    println!(\"Documenting stage{} error index ({})\", stage, host);\n+    let compiler = Compiler::new(stage, host);\n+    let mut index = Command::new(build.tool(&compiler, \"error_index_generator\"));\n+    index.arg(\"html\");\n+    index.arg(out.join(\"error-index.html\"));\n+\n+    // FIXME: shouldn't have to pass this env var\n+    index.env(\"CFG_BUILD\", &build.config.build);\n+\n+    build.run(&mut index);\n+}"}, {"sha": "058f27c33f60799d7f4fc767fa7d9462ae7cbf83", "filename": "src/bootstrap/build/mod.rs", "status": "modified", "additions": 89, "deletions": 44, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fmod.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -30,6 +30,7 @@ macro_rules! t {\n \n mod cc;\n mod channel;\n+mod check;\n mod clean;\n mod compile;\n mod config;\n@@ -83,6 +84,12 @@ pub struct Build {\n     compiler_rt_built: RefCell<HashMap<String, PathBuf>>,\n }\n \n+pub enum Mode {\n+    Libstd,\n+    Librustc,\n+    Tool,\n+}\n+\n impl Build {\n     pub fn new(flags: Flags, config: Config) -> Build {\n         let cwd = t!(env::current_dir());\n@@ -165,6 +172,16 @@ impl Build {\n                 Rustc { stage } => {\n                     compile::assemble_rustc(self, stage, target.target);\n                 }\n+                ToolLinkchecker { stage } => {\n+                    compile::tool(self, stage, target.target, \"linkchecker\");\n+                }\n+                ToolRustbook { stage } => {\n+                    compile::tool(self, stage, target.target, \"rustbook\");\n+                }\n+                ToolErrorIndex { stage } => {\n+                    compile::tool(self, stage, target.target,\n+                                  \"error_index_generator\");\n+                }\n                 DocBook { stage } => {\n                     doc::rustbook(self, stage, target.target, \"book\", &doc_out);\n                 }\n@@ -179,7 +196,22 @@ impl Build {\n                 DocStandalone { stage } => {\n                     doc::standalone(self, stage, target.target, &doc_out);\n                 }\n-                Doc { .. } => {} // pseudo-step\n+                DocStd { stage } => {\n+                    doc::std(self, stage, target.target, &doc_out);\n+                }\n+                DocRustc { stage } => {\n+                    doc::rustc(self, stage, target.target, &doc_out);\n+                }\n+                DocErrorIndex { stage } => {\n+                    doc::error_index(self, stage, target.target, &doc_out);\n+                }\n+\n+                CheckLinkcheck { stage } => {\n+                    check::linkcheck(self, stage, target.target);\n+                }\n+\n+                Doc { .. } | // pseudo-steps\n+                Check { .. } => {}\n             }\n         }\n     }\n@@ -230,14 +262,17 @@ impl Build {\n     /// Cargo for the specified stage, whether or not the standard library is\n     /// being built, and using the specified compiler targeting `target`.\n     // FIXME: aren't stage/compiler duplicated?\n-    fn cargo(&self, stage: u32, compiler: &Compiler, is_std: bool,\n-             target: &str, cmd: &str) -> Command {\n+    fn cargo(&self,\n+             stage: u32,\n+             compiler: &Compiler,\n+             mode: Mode,\n+             target: Option<&str>,\n+             cmd: &str) -> Command {\n         let mut cargo = Command::new(&self.cargo);\n         let host = compiler.host;\n-        let out_dir = self.stage_out(stage, host, is_std);\n+        let out_dir = self.stage_out(stage, host, mode);\n         cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n              .arg(cmd)\n-             .arg(\"--target\").arg(target)\n              .arg(\"-j\").arg(self.jobs().to_string());\n \n         // Customize the compiler we're running. Specify the compiler to cargo\n@@ -254,24 +289,29 @@ impl Build {\n              .env(\"RUSTC_SNAPSHOT\", &self.rustc)\n              .env(\"RUSTC_SYSROOT\", self.sysroot(stage, host))\n              .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir())\n-             .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"))\n              .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n-             .env(\"RUSTDOC\", self.tool(compiler, \"rustdoc\"));\n-\n-        // Specify some variuos options for build scripts used throughout the\n-        // build.\n-        //\n-        // FIXME: the guard against msvc shouldn't need to be here\n-        if !target.contains(\"msvc\") {\n-            cargo.env(format!(\"CC_{}\", target), self.cc(target))\n-                 .env(format!(\"AR_{}\", target), self.ar(target))\n-                 .env(format!(\"CFLAGS_{}\", target), self.cflags(target));\n-        }\n+             .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n+             .env(\"RUSTDOC_REAL\", self.rustdoc(compiler));\n+\n+        if let Some(target) = target {\n+             cargo.env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n+             cargo.arg(\"--target\").arg(target);\n+\n+            // Specify some various options for build scripts used throughout\n+            // the build.\n+            //\n+            // FIXME: the guard against msvc shouldn't need to be here\n+            if !target.contains(\"msvc\") {\n+                cargo.env(format!(\"CC_{}\", target), self.cc(target))\n+                     .env(format!(\"AR_{}\", target), self.ar(target))\n+                     .env(format!(\"CFLAGS_{}\", target), self.cflags(target));\n+            }\n \n-        // Environment variables *required* needed throughout the build\n-        //\n-        // FIXME: should update code to not require this env vars\n-        cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n+            // Environment variables *required* needed throughout the build\n+            //\n+            // FIXME: should update code to not require this env vars\n+            cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n+        }\n \n         if self.config.verbose || self.flags.verbose {\n             cargo.arg(\"-v\");\n@@ -293,17 +333,24 @@ impl Build {\n         }\n     }\n \n-    /// Get the specified tool next to the specified compiler\n+    /// Get the specified tool built by the specified compiler\n     fn tool(&self, compiler: &Compiler, tool: &str) -> PathBuf {\n-        if compiler.is_snapshot(self) {\n-            assert!(tool == \"rustdoc\", \"no tools other than rustdoc in stage0\");\n+        self.stage_out(compiler.stage, compiler.host, Mode::Tool)\n+            .join(self.cargo_dir())\n+            .join(exe(tool, compiler.host))\n+    }\n+\n+    /// Get the `rustdoc` executable next to the specified compiler\n+    fn rustdoc(&self, compiler: &Compiler) -> PathBuf {\n+        let root = if compiler.is_snapshot(self) {\n             let mut rustdoc = self.rustc.clone();\n             rustdoc.pop();\n-            rustdoc.push(exe(\"rustdoc\", &self.config.build));\n-            return rustdoc\n-        }\n-        let (stage, host) = (compiler.stage, compiler.host);\n-        self.cargo_out(stage - 1, host, false, host).join(exe(tool, host))\n+            rustdoc\n+        } else {\n+            let (stage, host) = (compiler.stage, compiler.host);\n+            self.cargo_out(stage - 1, host, Mode::Librustc, host)\n+        };\n+        root.join(exe(\"rustdoc\", compiler.host))\n     }\n \n     /// Get a `Command` which is ready to run `tool` in `stage` built for\n@@ -314,8 +361,8 @@ impl Build {\n         let host = compiler.host;\n         let stage = compiler.stage;\n         let paths = vec![\n-            self.cargo_out(stage - 1, host, true, host).join(\"deps\"),\n-            self.cargo_out(stage - 1, host, false, host).join(\"deps\"),\n+            self.cargo_out(stage, host, Mode::Libstd, host).join(\"deps\"),\n+            self.cargo_out(stage, host, Mode::Librustc, host).join(\"deps\"),\n         ];\n         add_lib_path(paths, &mut cmd);\n         return cmd\n@@ -339,15 +386,11 @@ impl Build {\n     }\n \n     /// Get the space-separated set of activated features for the compiler.\n-    fn rustc_features(&self, stage: u32) -> String {\n+    fn rustc_features(&self) -> String {\n         let mut features = String::new();\n         if self.config.use_jemalloc {\n             features.push_str(\" jemalloc\");\n         }\n-        if stage > 0 {\n-            features.push_str(\" rustdoc\");\n-            features.push_str(\" rustbook\");\n-        }\n         return features\n     }\n \n@@ -359,7 +402,7 @@ impl Build {\n \n     fn sysroot(&self, stage: u32, host: &str) -> PathBuf {\n         if stage == 0 {\n-            self.stage_out(stage, host, false)\n+            self.stage_out(stage, host, Mode::Librustc)\n         } else {\n             self.out.join(host).join(format!(\"stage{}\", stage))\n         }\n@@ -373,19 +416,21 @@ impl Build {\n     /// Returns the root directory for all output generated in a particular\n     /// stage when running with a particular host compiler.\n     ///\n-    /// The `is_std` flag indicates whether the root directory is for the\n-    /// bootstrap of the standard library or for the compiler.\n-    fn stage_out(&self, stage: u32, host: &str, is_std: bool) -> PathBuf {\n-        self.out.join(host)\n-            .join(format!(\"stage{}{}\", stage, if is_std {\"-std\"} else {\"-rustc\"}))\n+    /// The mode indicates what the root directory is for.\n+    fn stage_out(&self, stage: u32, host: &str, mode: Mode) -> PathBuf {\n+        let suffix = match mode {\n+            Mode::Libstd => \"-std\",\n+            _ => \"-rustc\",\n+        };\n+        self.out.join(host).join(format!(\"stage{}{}\", stage, suffix))\n     }\n \n     /// Returns the root output directory for all Cargo output in a given stage,\n     /// running a particular comipler, wehther or not we're building the\n     /// standard library, and targeting the specified architecture.\n-    fn cargo_out(&self, stage: u32, host: &str, is_std: bool,\n+    fn cargo_out(&self, stage: u32, host: &str, mode: Mode,\n                  target: &str) -> PathBuf {\n-        self.stage_out(stage, host, is_std).join(target).join(self.cargo_dir())\n+        self.stage_out(stage, host, mode).join(target).join(self.cargo_dir())\n     }\n \n     /// Root output directory for LLVM compiled for `target`"}, {"sha": "720ba4fd2094dc63d58ae010713139afbfe3a822", "filename": "src/bootstrap/build/step.rs", "status": "modified", "additions": 75, "deletions": 19, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fbuild%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fbuild%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fstep.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -45,6 +45,11 @@ macro_rules! targets {\n                 host: &'a str\n             }),\n \n+            // Various tools that we can build as part of the build.\n+            (tool_linkchecker, ToolLinkchecker { stage: u32 }),\n+            (tool_rustbook, ToolRustbook { stage: u32 }),\n+            (tool_error_index, ToolErrorIndex { stage: u32 }),\n+\n             // Steps for long-running native builds. Ideally these wouldn't\n             // actually exist and would be part of build scripts, but for now\n             // these are here.\n@@ -53,11 +58,23 @@ macro_rules! targets {\n             // with braces are unstable so we just pick something that works.\n             (llvm, Llvm { _dummy: () }),\n             (compiler_rt, CompilerRt { _dummy: () }),\n+\n+            // Steps for various pieces of documentation that we can generate,\n+            // the 'doc' step is just a pseudo target to depend on a bunch of\n+            // others.\n             (doc, Doc { stage: u32 }),\n             (doc_book, DocBook { stage: u32 }),\n             (doc_nomicon, DocNomicon { stage: u32 }),\n             (doc_style, DocStyle { stage: u32 }),\n             (doc_standalone, DocStandalone { stage: u32 }),\n+            (doc_std, DocStd { stage: u32 }),\n+            (doc_rustc, DocRustc { stage: u32 }),\n+            (doc_error_index, DocErrorIndex { stage: u32 }),\n+\n+            // Steps for running tests. The 'check' target is just a pseudo\n+            // target to depend on a bunch of others.\n+            (check, Check { stage: u32, compiler: Compiler<'a> }),\n+            (check_linkcheck, CheckLinkcheck { stage: u32 }),\n         }\n     }\n }\n@@ -158,25 +175,37 @@ fn add_steps<'a>(build: &'a Build,\n                  host: &Step<'a>,\n                  target: &Step<'a>,\n                  targets: &mut Vec<Step<'a>>) {\n+    struct Context<'a> {\n+        stage: u32,\n+        compiler: Compiler<'a>,\n+        _dummy: (),\n+        host: &'a str,\n+    }\n     for step in build.flags.step.iter() {\n-        let compiler = host.target(&build.config.build).compiler(stage);\n-        match &step[..] {\n-            \"libstd\" => targets.push(target.libstd(stage, compiler)),\n-            \"librustc\" => targets.push(target.librustc(stage, compiler)),\n-            \"libstd-link\" => targets.push(target.libstd_link(stage, compiler,\n-                                                             host.target)),\n-            \"librustc-link\" => targets.push(target.librustc_link(stage, compiler,\n-                                                                 host.target)),\n-            \"rustc\" => targets.push(host.rustc(stage)),\n-            \"llvm\" => targets.push(target.llvm(())),\n-            \"compiler-rt\" => targets.push(target.compiler_rt(())),\n-            \"doc-style\" => targets.push(host.doc_style(stage)),\n-            \"doc-standalone\" => targets.push(host.doc_standalone(stage)),\n-            \"doc-nomicon\" => targets.push(host.doc_nomicon(stage)),\n-            \"doc-book\" => targets.push(host.doc_book(stage)),\n-            \"doc\" => targets.push(host.doc(stage)),\n-            _ => panic!(\"unknown build target: `{}`\", step),\n+\n+        // The macro below insists on hygienic access to all local variables, so\n+        // we shove them all in a struct and subvert hygiene by accessing struct\n+        // fields instead,\n+        let cx = Context {\n+            stage: stage,\n+            compiler: host.target(&build.config.build).compiler(stage),\n+            _dummy: (),\n+            host: host.target,\n+        };\n+        macro_rules! add_step {\n+            ($(($short:ident, $name:ident { $($arg:ident: $t:ty),* }),)*) => ({$(\n+                let name = stringify!($short).replace(\"_\", \"-\");\n+                if &step[..] == &name[..] {\n+                    targets.push(target.$short($(cx.$arg),*));\n+                    continue\n+                }\n+                drop(name);\n+            )*})\n         }\n+\n+        targets!(add_step);\n+\n+        panic!(\"unknown step: {}\", step);\n     }\n }\n \n@@ -230,15 +259,42 @@ impl<'a> Step<'a> {\n                 vec![self.llvm(()).target(&build.config.build)]\n             }\n             Source::Llvm { _dummy } => Vec::new(),\n+            Source::DocStd { stage } => {\n+                vec![self.libstd(stage, self.compiler(stage))]\n+            }\n             Source::DocBook { stage } |\n             Source::DocNomicon { stage } |\n-            Source::DocStyle { stage } |\n+            Source::DocStyle { stage } => {\n+                vec![self.tool_rustbook(stage)]\n+            }\n+            Source::DocErrorIndex { stage } => {\n+                vec![self.tool_error_index(stage)]\n+            }\n             Source::DocStandalone { stage } => {\n                 vec![self.rustc(stage)]\n             }\n+            Source::DocRustc { stage } => {\n+                vec![self.doc_std(stage)]\n+            }\n             Source::Doc { stage } => {\n                 vec![self.doc_book(stage), self.doc_nomicon(stage),\n-                     self.doc_style(stage), self.doc_standalone(stage)]\n+                     self.doc_style(stage), self.doc_standalone(stage),\n+                     self.doc_std(stage),\n+                     self.doc_error_index(stage)]\n+            }\n+            Source::Check { stage, compiler: _ } => {\n+                vec![self.check_linkcheck(stage)]\n+            }\n+            Source::CheckLinkcheck { stage } => {\n+                vec![self.tool_linkchecker(stage), self.doc(stage)]\n+            }\n+\n+            Source::ToolLinkchecker { stage } => {\n+                vec![self.libstd(stage, self.compiler(stage))]\n+            }\n+            Source::ToolErrorIndex { stage } |\n+            Source::ToolRustbook { stage } => {\n+                vec![self.librustc(stage, self.compiler(stage))]\n             }\n         }\n     }"}, {"sha": "35d22ee5d2658ecedd01abc92cc22b11b4f8a7f1", "filename": "src/bootstrap/build/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fbuild%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fbuild%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Futil.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -30,7 +30,6 @@ pub fn mtime(path: &Path) -> FileTime {\n     }).unwrap_or(FileTime::zero())\n }\n \n-#[allow(dead_code)] // this will be used soon\n pub fn cp_r(src: &Path, dst: &Path) {\n     for f in t!(fs::read_dir(src)) {\n         let f = t!(f);"}, {"sha": "7d7930021498bb25677890d4c69782ecee36aa00", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -36,3 +36,5 @@ book:\n \t$(Q)$(BOOTSTRAP) --step doc-book\n standalone-docs:\n \t$(Q)$(BOOTSTRAP) --step doc-standalone\n+check:\n+\t$(Q)$(BOOTSTRAP) --step check"}, {"sha": "d403d76bb1400469a289b3e8bcba592c4238f9b0", "filename": "src/bootstrap/rustc.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frustc.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -8,6 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Shim which is passed to Cargo as \"rustc\" when running the bootstrap.\n+//!\n+//! This shim will take care of some various tasks that our build process\n+//! requires that Cargo can't quite do through normal configuration:\n+//!\n+//! 1. When compiling build scripts and build dependencies, we need a guaranteed\n+//!    full standard library available. The only compiler which actually has\n+//!    this is the snapshot, so we detect this situation and always compile with\n+//!    the snapshot compiler.\n+//! 2. We pass a bunch of `--cfg` and other flags based on what we're compiling\n+//!    (and this slightly differs based on a whether we're using a snapshot or\n+//!    not), so we do that all here.\n+//!\n+//! This may one day be replaced by RUSTFLAGS, but the dynamic nature of\n+//! switching compilers for the bootstrap and for build scripts will probably\n+//! never get replaced.\n+\n extern crate bootstrap;\n \n use std::env;"}, {"sha": "8c618196113baf7cc255e098f4c257ff191aaf77", "filename": "src/bootstrap/rustdoc.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fbootstrap%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frustdoc.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Shim which is passed to Cargo as \"rustdoc\" when running the bootstrap.\n+//!\n+//! See comments in `src/bootstrap/rustc.rs` for more information.\n+\n+use std::env;\n+use std::process::Command;\n+\n+fn main() {\n+    let args = env::args_os().skip(1).collect::<Vec<_>>();\n+    let rustdoc = env::var_os(\"RUSTDOC_REAL\").unwrap();\n+\n+    let mut cmd = Command::new(rustdoc);\n+    cmd.args(&args)\n+       .arg(\"--cfg\").arg(format!(\"stage{}\", env::var(\"RUSTC_STAGE\").unwrap()))\n+       .arg(\"--cfg\").arg(\"dox\");\n+    std::process::exit(match cmd.status() {\n+        Ok(s) => s.code().unwrap_or(1),\n+        Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),\n+    })\n+}\n+"}, {"sha": "50350213074bf3a2cd2368db61d0d7acce5c7a23", "filename": "src/doc/book/choosing-your-guarantees.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -204,7 +204,7 @@ borrow checker. Generally we know that such mutations won't happen in a nested f\n to check.\n \n For large, complicated programs, it becomes useful to put some things in `RefCell`s to make things\n-simpler. For example, a lot of the maps in [the `ctxt` struct][ctxt] in the Rust compiler internals\n+simpler. For example, a lot of the maps in the `ctxt` struct in the Rust compiler internals\n are inside this wrapper. These are only modified once (during creation, which is not right after\n initialization) or a couple of times in well-separated places. However, since this struct is\n pervasively used everywhere, juggling mutable and immutable pointers would be hard (perhaps\n@@ -235,7 +235,6 @@ At runtime each borrow causes a modification/check of the refcount.\n [cell-mod]: ../std/cell/\n [cell]: ../std/cell/struct.Cell.html\n [refcell]: ../std/cell/struct.RefCell.html\n-[ctxt]: ../rustc/middle/ty/struct.ctxt.html\n \n # Synchronous types\n "}, {"sha": "1af05bfea19a210001ee73542036168f6e997fb9", "filename": "src/doc/book/compiler-plugins.md", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcompiler-plugins.md?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -8,12 +8,12 @@ extend the compiler's behavior with new syntax extensions, lint checks, etc.\n A plugin is a dynamic library crate with a designated *registrar* function that\n registers extensions with `rustc`. Other crates can load these extensions using\n the crate attribute `#![plugin(...)]`.  See the\n-[`rustc_plugin`](../rustc_plugin/index.html) documentation for more about the\n+`rustc_plugin` documentation for more about the\n mechanics of defining and loading a plugin.\n \n If present, arguments passed as `#![plugin(foo(... args ...))]` are not\n interpreted by rustc itself.  They are provided to the plugin through the\n-`Registry`'s [`args` method](../rustc_plugin/registry/struct.Registry.html#method.args).\n+`Registry`'s `args` method.\n \n In the vast majority of cases, a plugin should *only* be used through\n `#![plugin]` and not through an `extern crate` item.  Linking a plugin would\n@@ -30,7 +30,7 @@ of a library.\n Plugins can extend Rust's syntax in various ways. One kind of syntax extension\n is the procedural macro. These are invoked the same way as [ordinary\n macros](macros.html), but the expansion is performed by arbitrary Rust\n-code that manipulates [syntax trees](../syntax/ast/index.html) at\n+code that manipulates syntax trees at\n compile time.\n \n Let's write a plugin\n@@ -120,19 +120,16 @@ The advantages over a simple `fn(&str) -> u32` are:\n \n In addition to procedural macros, you can define new\n [`derive`](../reference.html#derive)-like attributes and other kinds of\n-extensions.  See\n-[`Registry::register_syntax_extension`](../rustc_plugin/registry/struct.Registry.html#method.register_syntax_extension)\n-and the [`SyntaxExtension`\n-enum](https://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html).  For\n-a more involved macro example, see\n+extensions.  See `Registry::register_syntax_extension` and the `SyntaxExtension`\n+enum.  For a more involved macro example, see\n [`regex_macros`](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).\n \n \n ## Tips and tricks\n \n Some of the [macro debugging tips](macros.html#debugging-macro-code) are applicable.\n \n-You can use [`syntax::parse`](../syntax/parse/index.html) to turn token trees into\n+You can use `syntax::parse` to turn token trees into\n higher-level syntax elements like expressions:\n \n ```ignore\n@@ -148,30 +145,21 @@ Looking through [`libsyntax` parser\n code](https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs)\n will give you a feel for how the parsing infrastructure works.\n \n-Keep the [`Span`s](../syntax/codemap/struct.Span.html) of\n-everything you parse, for better error reporting. You can wrap\n-[`Spanned`](../syntax/codemap/struct.Spanned.html) around\n-your custom data structures.\n-\n-Calling\n-[`ExtCtxt::span_fatal`](../syntax/ext/base/struct.ExtCtxt.html#method.span_fatal)\n-will immediately abort compilation. It's better to instead call\n-[`ExtCtxt::span_err`](../syntax/ext/base/struct.ExtCtxt.html#method.span_err)\n-and return\n-[`DummyResult`](../syntax/ext/base/struct.DummyResult.html),\n-so that the compiler can continue and find further errors.\n-\n-To print syntax fragments for debugging, you can use\n-[`span_note`](../syntax/ext/base/struct.ExtCtxt.html#method.span_note) together\n-with\n-[`syntax::print::pprust::*_to_string`](https://doc.rust-lang.org/syntax/print/pprust/index.html#functions).\n-\n-The example above produced an integer literal using\n-[`AstBuilder::expr_usize`](../syntax/ext/build/trait.AstBuilder.html#tymethod.expr_usize).\n+Keep the `Span`s of everything you parse, for better error reporting. You can\n+wrap `Spanned` around your custom data structures.\n+\n+Calling `ExtCtxt::span_fatal` will immediately abort compilation. It's better to\n+instead call `ExtCtxt::span_err` and return `DummyResult` so that the compiler\n+can continue and find further errors.\n+\n+To print syntax fragments for debugging, you can use `span_note` together with\n+`syntax::print::pprust::*_to_string`.\n+\n+The example above produced an integer literal using `AstBuilder::expr_usize`.\n As an alternative to the `AstBuilder` trait, `libsyntax` provides a set of\n-[quasiquote macros](../syntax/ext/quote/index.html).  They are undocumented and\n-very rough around the edges.  However, the implementation may be a good\n-starting point for an improved quasiquote as an ordinary plugin library.\n+quasiquote macros. They are undocumented and very rough around the edges.\n+However, the implementation may be a good starting point for an improved\n+quasiquote as an ordinary plugin library.\n \n \n # Lint plugins\n@@ -239,12 +227,11 @@ foo.rs:4 fn lintme() { }\n \n The components of a lint plugin are:\n \n-* one or more `declare_lint!` invocations, which define static\n-  [`Lint`](../rustc/lint/struct.Lint.html) structs;\n+* one or more `declare_lint!` invocations, which define static `Lint` structs;\n \n * a struct holding any state needed by the lint pass (here, none);\n \n-* a [`LintPass`](../rustc/lint/trait.LintPass.html)\n+* a `LintPass`\n   implementation defining how to check each syntax element. A single\n   `LintPass` may call `span_lint` for several different `Lint`s, but should\n   register them all through the `get_lints` method."}, {"sha": "742433b99ac5f56e42704782b5e4e2a6697287d5", "filename": "src/doc/guide-plugins.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fdoc%2Fguide-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fdoc%2Fguide-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-plugins.md?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -1,4 +1,4 @@\n % The (old) Rust Compiler Plugins Guide\n \n This content has moved into\n-[the Rust Programming Language book](book/plugins.html).\n+[the Rust Programming Language book](book/compiler-plugins.html)."}, {"sha": "8d837d1a1a9165b653e8019c8333c2608d3b8584", "filename": "src/doc/style/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fdoc%2Fstyle%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fdoc%2Fstyle%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2FREADME.md?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -53,7 +53,7 @@ This document is broken into four parts:\n   cross-cutting topic, starting with\n   [Ownership and resources](ownership/README.md).\n \n-* **[APIs for a changing Rust](changing/README.md)**\n+* **APIs for a changing Rust**\n   discusses the forward-compatibility hazards, especially those that interact\n   with the pre-1.0 library stabilization process.\n "}, {"sha": "9b243bc72ef7125e6540151a70838c3e7fe78464", "filename": "src/doc/style/features/functions-and-methods/input.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Finput.md", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Finput.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Finput.md?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -76,7 +76,7 @@ needs to make about its arguments.\n On the other hand, generics can make it more difficult to read and understand a\n function's signature. Aim for \"natural\" parameter types that a neither overly\n concrete nor overly abstract. See the discussion on\n-[traits](../../traits/README.md) for more guidance.\n+[traits](../traits/README.md) for more guidance.\n \n \n #### Minimizing ownership assumptions:"}, {"sha": "2106f32fafade8fdcc54320064b4353f1708aafc", "filename": "src/doc/style/style/naming/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2FREADME.md?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -101,7 +101,7 @@ The convention for a field `foo: T` is:\n   here may take `&T` or some other type, depending on the context.)\n \n Note that this convention is about getters/setters on ordinary data types, *not*\n-on [builder objects](../ownership/builders.html).\n+on [builder objects](../../ownership/builders.html).\n \n ### Escape hatches [FIXME]\n "}, {"sha": "23e0af8113bf11f95d5dd8445e04b39b9562283d", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -34,8 +34,8 @@ use Bound;\n /// to any other item, as determined by the [`Ord`] trait, changes while it is in the set. This is\n /// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n ///\n-/// [`BTreeMap`]: ../struct.BTreeMap.html\n-/// [`Ord`]: ../../core/cmp/trait.Ord.html\n+/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`Ord`]: ../../std/cmp/trait.Ord.html\n /// [`Cell`]: ../../std/cell/struct.Cell.html\n /// [`RefCell`]: ../../std/cell/struct.RefCell.html\n ///"}, {"sha": "cef6edf68ee8d5c11bc496f8fc257f760878210f", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -71,13 +71,21 @@ extern crate std;\n #[cfg(test)]\n extern crate test;\n \n+#[doc(no_inline)]\n pub use binary_heap::BinaryHeap;\n+#[doc(no_inline)]\n pub use btree_map::BTreeMap;\n+#[doc(no_inline)]\n pub use btree_set::BTreeSet;\n+#[doc(no_inline)]\n pub use linked_list::LinkedList;\n+#[doc(no_inline)]\n pub use enum_set::EnumSet;\n+#[doc(no_inline)]\n pub use vec_deque::VecDeque;\n+#[doc(no_inline)]\n pub use string::String;\n+#[doc(no_inline)]\n pub use vec::Vec;\n \n // Needed for the vec! macro"}, {"sha": "69a9899d82bc6b5f353abc770a48ec4f38518e66", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -78,7 +78,7 @@\n //! * Further methods that return iterators are `.split()`, `.splitn()`,\n //!   `.chunks()`, `.windows()` and more.\n //!\n-//! *[See also the slice primitive type](../primitive.slice.html).*\n+//! *[See also the slice primitive type](../../std/primitive.slice.html).*\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n // Many of the usings in this module are only used in the test configuration."}, {"sha": "9798e323a6140c782c6cb8606e3686fe339d1dff", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -10,7 +10,7 @@\n \n //! Unicode string slices.\n //!\n-//! *[See also the `str` primitive type](../primitive.str.html).*\n+//! *[See also the `str` primitive type](../../std/primitive.str.html).*\n \n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "02190d11b421fe8ef50443c3f56fe985cc6aaaef", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -79,7 +79,7 @@ use boxed::Box;\n /// contents of the string. It has a close relationship with its borrowed\n /// counterpart, the primitive [`str`].\n ///\n-/// [`str`]: ../primitive.str.html\n+/// [`str`]: ../../std/primitive.str.html\n ///\n /// # Examples\n ///\n@@ -99,7 +99,7 @@ use boxed::Box;\n /// hello.push_str(\"orld!\");\n /// ```\n ///\n-/// [`char`]: ../primitive.char.html\n+/// [`char`]: ../../std/primitive.char.html\n /// [`push()`]: #method.push\n /// [`push_str()`]: #method.push_str\n ///\n@@ -131,7 +131,7 @@ use boxed::Box;\n /// println!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n /// ```\n ///\n-/// [`OsString`]: ../ffi/struct.OsString.html\n+/// [`OsString`]: ../../std/ffi/struct.OsString.html\n ///\n /// Indexing is intended to be a constant-time operation, but UTF-8 encoding\n /// does not allow us to do this. Furtheremore, it's not clear what sort of\n@@ -156,8 +156,8 @@ use boxed::Box;\n /// takes_str(&s);\n /// ```\n ///\n-/// [`&str`]: ../primitive.str.html\n-/// [`Deref`]: ../ops/trait.Deref.html\n+/// [`&str`]: ../../std/primitive.str.html\n+/// [`Deref`]: ../../std/ops/trait.Deref.html\n ///\n /// This will create a [`&str`] from the `String` and pass it in. This\n /// conversion is very inexpensive, and so generally, functions will accept\n@@ -280,10 +280,10 @@ pub struct String {\n /// an analogue to `FromUtf8Error`, and you can get one from a `FromUtf8Error`\n /// through the [`utf8_error()`] method.\n ///\n-/// [`Utf8Error`]: ../str/struct.Utf8Error.html\n-/// [`std::str`]: ../str/index.html\n-/// [`u8`]: ../primitive.u8.html\n-/// [`&str`]: ../primitive.str.html\n+/// [`Utf8Error`]: ../../std/str/struct.Utf8Error.html\n+/// [`std::str`]: ../../std/str/index.html\n+/// [`u8`]: ../../std/primitive.u8.html\n+/// [`&str`]: ../../std/primitive.str.html\n /// [`utf8_error()`]: #method.utf8_error\n ///\n /// # Examples\n@@ -414,9 +414,9 @@ impl String {\n     /// requires that it is valid UTF-8. `from_utf8()` checks to ensure that\n     /// the bytes are valid UTF-8, and then does the conversion.\n     ///\n-    /// [`&str`]: ../primitive.str.html\n-    /// [`u8`]: ../primitive.u8.html\n-    /// [`Vec<u8>`]: ../vec/struct.Vec.html\n+    /// [`&str`]: ../../std/primitive.str.html\n+    /// [`u8`]: ../../std/primitive.u8.html\n+    /// [`Vec<u8>`]: ../../std/vec/struct.Vec.html\n     ///\n     /// If you are sure that the byte slice is valid UTF-8, and you don't want\n     /// to incur the overhead of the validity check, there is an unsafe version\n@@ -431,7 +431,7 @@ impl String {\n     /// If you need a `&str` instead of a `String`, consider\n     /// [`str::from_utf8()`].\n     ///\n-    /// [`str::from_utf8()`]: ../str/fn.from_utf8.html\n+    /// [`str::from_utf8()`]: ../../std/str/fn.from_utf8.html\n     ///\n     /// # Errors\n     ///\n@@ -488,8 +488,8 @@ impl String {\n     /// `from_utf8_lossy()` will replace any invalid UTF-8 sequences with\n     /// `U+FFFD REPLACEMENT CHARACTER`, which looks like this: \ufffd\n     ///\n-    /// [`u8`]: ../primitive.u8.html\n-    /// [byteslice]: ../primitive.slice.html\n+    /// [`u8`]: ../../std/primitive.u8.html\n+    /// [byteslice]: ../../std/primitive.slice.html\n     ///\n     /// If you are sure that the byte slice is valid UTF-8, and you don't want\n     /// to incur the overhead of the conversion, there is an unsafe version\n@@ -504,7 +504,7 @@ impl String {\n     /// it's already valid UTF-8, we don't need a new allocation. This return\n     /// type allows us to handle both cases.\n     ///\n-    /// [`Cow<'a, str>`]: ../borrow/enum.Cow.html\n+    /// [`Cow<'a, str>`]: ../../std/borrow/enum.Cow.html\n     ///\n     /// # Examples\n     ///\n@@ -1014,7 +1014,7 @@ impl String {\n     /// Panics if `new_len` > current length, or if `new_len` does not lie on a\n     /// [`char`] boundary.\n     ///\n-    /// [`char`]: ../primitive.char.html\n+    /// [`char`]: ../../std/primitive.char.html\n     ///\n     /// # Examples\n     ///\n@@ -1076,7 +1076,7 @@ impl String {\n     /// Panics if `idx` is larger than or equal to the `String`'s length,\n     /// or if it does not lie on a [`char`] boundary.\n     ///\n-    /// [`char`]: ../primitive.char.html\n+    /// [`char`]: ../../std/primitive.char.html\n     ///\n     /// # Examples\n     ///\n@@ -1116,7 +1116,7 @@ impl String {\n     /// Panics if `idx` is larger than the `String`'s length, or if it does not\n     /// lie on a [`char`] boundary.\n     ///\n-    /// [`char`]: ../primitive.char.html\n+    /// [`char`]: ../../std/primitive.char.html\n     ///\n     /// # Examples\n     ///\n@@ -1255,7 +1255,7 @@ impl String {\n     /// Panics if the starting point or end point do not lie on a [`char`]\n     /// boundary, or if they're out of bounds.\n     ///\n-    /// [`char`]: ../primitive.char.html\n+    /// [`char`]: ../../std/primitive.char.html\n     ///\n     /// # Examples\n     ///\n@@ -1353,10 +1353,10 @@ impl FromUtf8Error {\n     /// an analogue to `FromUtf8Error`. See its documentation for more details\n     /// on using it.\n     ///\n-    /// [`Utf8Error`]: ../str/struct.Utf8Error.html\n-    /// [`std::str`]: ../str/index.html\n-    /// [`u8`]: ../primitive.u8.html\n-    /// [`&str`]: ../primitive.str.html\n+    /// [`Utf8Error`]: ../../std/str/struct.Utf8Error.html\n+    /// [`std::str`]: ../../std/str/index.html\n+    /// [`u8`]: ../../std/primitive.u8.html\n+    /// [`&str`]: ../../std/primitive.str.html\n     ///\n     /// # Examples\n     ///\n@@ -1695,9 +1695,9 @@ impl ops::DerefMut for String {\n /// [`String`] without error, this type will never actually be returned. As\n /// such, it is only here to satisfy said signature, and is useless otherwise.\n ///\n-/// [`FromStr`]: ../str/trait.FromStr.html\n+/// [`FromStr`]: ../../std/str/trait.FromStr.html\n /// [`String`]: struct.String.html\n-/// [`from_str()`]: ../str/trait.FromStr.html#tymethod.from_str\n+/// [`from_str()`]: ../../std/str/trait.FromStr.html#tymethod.from_str\n #[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n #[derive(Copy)]\n pub enum ParseError {}\n@@ -1749,7 +1749,7 @@ impl Eq for ParseError {}\n /// [`Display`] should be implemented instead, and you get the `ToString`\n /// implementation for free.\n ///\n-/// [`Display`]: ../fmt/trait.Display.html\n+/// [`Display`]: ../../std/fmt/trait.Display.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ToString {\n     /// Converts the given value to a `String`."}, {"sha": "dfd2ba9154d53eceb71ec17fbb6ddf46c84a55f6", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -22,7 +22,7 @@\n //! Note that &Any is limited to testing whether a value is of a specified\n //! concrete type, and cannot be used to test whether a type implements a trait.\n //!\n-//! [`Box`]: ../boxed/struct.Box.html\n+//! [`Box`]: ../../std/boxed/struct.Box.html\n //!\n //! # Examples\n //!"}, {"sha": "a23b303f4bab1db9c731c5e2556f782e09889e77", "filename": "src/libcore/char.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -69,7 +69,7 @@ const MAX_THREE_B: u32 =  0x10000;\n /// Point], but only ones within a certain range. `MAX` is the highest valid\n /// code point that's a valid [Unicode Scalar Value].\n ///\n-/// [`char`]: ../primitive.char.html\n+/// [`char`]: ../../std/primitive.char.html\n /// [Unicode Scalar Value]: http://www.unicode.org/glossary/#unicode_scalar_value\n /// [Code Point]: http://www.unicode.org/glossary/#code_point\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -91,8 +91,8 @@ pub const MAX: char = '\\u{10ffff}';\n /// [`char`]s. `from_u32()` will return `None` if the input is not a valid value\n /// for a [`char`].\n ///\n-/// [`char`]: ../primitive.char.html\n-/// [`u32`]: ../primitive.u32.html\n+/// [`char`]: ../../std/primitive.char.html\n+/// [`u32`]: ../../std/primitive.u32.html\n /// [`as`]: ../../book/casting-between-types.html#as\n ///\n /// For an unsafe version of this function which ignores these checks, see\n@@ -148,8 +148,8 @@ pub fn from_u32(i: u32) -> Option<char> {\n /// [`char`]s. `from_u32_unchecked()` will ignore this, and blindly cast to\n /// [`char`], possibly creating an invalid one.\n ///\n-/// [`char`]: ../primitive.char.html\n-/// [`u32`]: ../primitive.u32.html\n+/// [`char`]: ../../std/primitive.char.html\n+/// [`u32`]: ../../std/primitive.u32.html\n /// [`as`]: ../../book/casting-between-types.html#as\n ///\n /// # Safety\n@@ -414,8 +414,8 @@ pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> {\n /// This `struct` is created by the [`escape_unicode()`] method on [`char`]. See\n /// its documentation for more.\n ///\n-/// [`escape_unicode()`]: ../primitive.char.html#method.escape_unicode\n-/// [`char`]: ../primitive.char.html\n+/// [`escape_unicode()`]: ../../std/primitive.char.html#method.escape_unicode\n+/// [`char`]: ../../std/primitive.char.html\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeUnicode {\n@@ -494,8 +494,8 @@ impl Iterator for EscapeUnicode {\n /// This `struct` is created by the [`escape_default()`] method on [`char`]. See\n /// its documentation for more.\n ///\n-/// [`escape_default()`]: ../primitive.char.html#method.escape_default\n-/// [`char`]: ../primitive.char.html\n+/// [`escape_default()`]: ../../std/primitive.char.html#method.escape_default\n+/// [`char`]: ../../std/primitive.char.html\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeDefault {"}, {"sha": "7927b3380447169e061d1c78a14a4660d39c770b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -22,7 +22,19 @@ use ops::Deref;\n use result;\n use slice;\n use str;\n-use self::rt::v1::Alignment;\n+\n+#[unstable(feature = \"fmt_flags_align\", issue = \"27726\")]\n+/// Possible alignments returned by `Formatter::align`\n+pub enum Alignment {\n+    /// Indication that contents should be left-aligned.\n+    Left,\n+    /// Indication that contents should be right-aligned.\n+    Right,\n+    /// Indication that contents should be center-aligned.\n+    Center,\n+    /// No alignment was requested.\n+    Unknown,\n+}\n \n #[unstable(feature = \"fmt_radix\", issue = \"27728\")]\n #[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n@@ -780,7 +792,7 @@ pub fn write(output: &mut Write, args: Arguments) -> Result {\n         width: None,\n         precision: None,\n         buf: output,\n-        align: Alignment::Unknown,\n+        align: rt::v1::Alignment::Unknown,\n         fill: ' ',\n         args: args.args,\n         curarg: args.args.iter(),\n@@ -920,13 +932,13 @@ impl<'a> Formatter<'a> {\n             Some(min) if self.sign_aware_zero_pad() => {\n                 self.fill = '0';\n                 try!(write_prefix(self));\n-                self.with_padding(min - width, Alignment::Right, |f| {\n+                self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n                     f.buf.write_str(buf)\n                 })\n             }\n             // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {\n-                self.with_padding(min - width, Alignment::Right, |f| {\n+                self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n                     try!(write_prefix(f)); f.buf.write_str(buf)\n                 })\n             }\n@@ -973,7 +985,8 @@ impl<'a> Formatter<'a> {\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n-                self.with_padding(width - s.chars().count(), Alignment::Left, |me| {\n+                let align = rt::v1::Alignment::Left;\n+                self.with_padding(width - s.chars().count(), align, |me| {\n                     me.buf.write_str(s)\n                 })\n             }\n@@ -982,20 +995,21 @@ impl<'a> Formatter<'a> {\n \n     /// Runs a callback, emitting the correct padding either before or\n     /// afterwards depending on whether right or left alignment is requested.\n-    fn with_padding<F>(&mut self, padding: usize, default: Alignment,\n+    fn with_padding<F>(&mut self, padding: usize, default: rt::v1::Alignment,\n                        f: F) -> Result\n         where F: FnOnce(&mut Formatter) -> Result,\n     {\n         use char::CharExt;\n         let align = match self.align {\n-            Alignment::Unknown => default,\n+            rt::v1::Alignment::Unknown => default,\n             _ => self.align\n         };\n \n         let (pre_pad, post_pad) = match align {\n-            Alignment::Left => (0, padding),\n-            Alignment::Right | Alignment::Unknown => (padding, 0),\n-            Alignment::Center => (padding / 2, (padding + 1) / 2),\n+            rt::v1::Alignment::Left => (0, padding),\n+            rt::v1::Alignment::Right |\n+            rt::v1::Alignment::Unknown => (padding, 0),\n+            rt::v1::Alignment::Center => (padding / 2, (padding + 1) / 2),\n         };\n \n         let mut fill = [0; 4];\n@@ -1033,7 +1047,7 @@ impl<'a> Formatter<'a> {\n                 // remove the sign from the formatted parts\n                 formatted.sign = b\"\";\n                 width = if width < sign.len() { 0 } else { width - sign.len() };\n-                align = Alignment::Right;\n+                align = rt::v1::Alignment::Right;\n                 self.fill = '0';\n             }\n \n@@ -1116,7 +1130,14 @@ impl<'a> Formatter<'a> {\n     /// Flag indicating what form of alignment was requested\n     #[unstable(feature = \"fmt_flags_align\", reason = \"method was just created\",\n                issue = \"27726\")]\n-    pub fn align(&self) -> Alignment { self.align }\n+    pub fn align(&self) -> Alignment {\n+        match self.align {\n+            rt::v1::Alignment::Left => Alignment::Left,\n+            rt::v1::Alignment::Right => Alignment::Right,\n+            rt::v1::Alignment::Center => Alignment::Center,\n+            rt::v1::Alignment::Unknown => Alignment::Unknown,\n+        }\n+    }\n \n     /// Optionally specified integer width that the output should be\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]"}, {"sha": "06821ff94f71209228e4641ea0cedce9a0f29013", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -65,7 +65,7 @@\n //!\n //! [`Iterator`]: trait.Iterator.html\n //! [`next()`]: trait.Iterator.html#tymethod.next\n-//! [`Option`]: ../option/enum.Option.html\n+//! [`Option`]: ../../std/option/enum.Option.html\n //!\n //! # The three forms of iteration\n //!\n@@ -804,7 +804,7 @@ pub trait Iterator {\n     /// closure returns `None`, it will try again, and call the closure on the\n     /// next element, seeing if it will return `Some`.\n     ///\n-    /// [`Option<T>`]: ../option/enum.Option.html\n+    /// [`Option<T>`]: ../../std/option/enum.Option.html\n     ///\n     /// Why `filter_map()` and not just [`filter()`].[`map()`]? The key is in this\n     /// part:\n@@ -866,7 +866,7 @@ pub trait Iterator {\n     /// different sized integer, the [`zip()`] function provides similar\n     /// functionality.\n     ///\n-    /// [`usize`]: ../primitive.usize.html\n+    /// [`usize`]: ../../std/primitive.usize.html\n     /// [`zip()`]: #method.zip\n     ///\n     /// # Overflow Behavior\n@@ -875,7 +875,7 @@ pub trait Iterator {\n     /// [`usize::MAX`] elements either produces the wrong result or panics. If\n     /// debug assertions are enabled, a panic is guaranteed.\n     ///\n-    /// [`usize::MAX`]: ../usize/constant.MAX.html\n+    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n     ///\n     /// # Panics\n     ///\n@@ -1151,7 +1151,7 @@ pub trait Iterator {\n     /// iterator and the return value from the closure, an [`Option`], is\n     /// yielded by the iterator.\n     ///\n-    /// [`Option`]: ../option/enum.Option.html\n+    /// [`Option`]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///\n@@ -1385,9 +1385,9 @@ pub trait Iterator {\n     /// be thought of as single `Result<Collection<T>, E>`. See the examples\n     /// below for more.\n     ///\n-    /// [`String`]: ../string/struct.String.html\n-    /// [`Result<T, E>`]: ../result/enum.Result.html\n-    /// [`char`]: ../primitive.char.html\n+    /// [`String`]: ../../std/string/struct.String.html\n+    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+    /// [`char`]: ../../std/primitive.char.html\n     ///\n     /// Because `collect()` is so general, it can cause problems with type\n     /// inference. As such, `collect()` is one of the few times you'll see\n@@ -1412,7 +1412,7 @@ pub trait Iterator {\n     /// Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n     /// we could collect into, for example, a [`VecDeque<T>`] instead:\n     ///\n-    /// [`VecDeque<T>`]: ../collections/struct.VecDeque.html\n+    /// [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n     ///\n     /// ```\n     /// use std::collections::VecDeque;"}, {"sha": "f923668688b8c2ef18b3266318d45bb8f14b76eb", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -206,8 +206,8 @@ macro_rules! try {\n ///\n /// See [`std::fmt`][fmt] for more information on format syntax.\n ///\n-/// [fmt]: fmt/index.html\n-/// [write]: io/trait.Write.html\n+/// [fmt]: ../std/fmt/index.html\n+/// [write]: ../std/io/trait.Write.html\n ///\n /// # Examples\n ///\n@@ -232,8 +232,8 @@ macro_rules! write {\n ///\n /// See [`std::fmt`][fmt] for more information on format syntax.\n ///\n-/// [fmt]: fmt/index.html\n-/// [write]: io/trait.Write.html\n+/// [fmt]: ../std/fmt/index.html\n+/// [write]: ../std/io/trait.Write.html\n ///\n /// # Examples\n ///"}, {"sha": "0b306c810b1954f520dfb0bb96135554c2143878", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -2179,8 +2179,8 @@ impl usize {\n /// This `enum` is used as the return type for [`f32::classify()`] and [`f64::classify()`]. See\n /// their documentation for more.\n ///\n-/// [`f32::classify()`]: ../primitive.f32.html#method.classify\n-/// [`f64::classify()`]: ../primitive.f64.html#method.classify\n+/// [`f32::classify()`]: ../../std/primitive.f32.html#method.classify\n+/// [`f64::classify()`]: ../../std/primitive.f64.html#method.classify\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum FpCategory {\n@@ -2411,7 +2411,7 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n /// This error is used as the error type for the `from_str_radix()` functions\n /// on the primitive integer types, such as [`i8::from_str_radix()`].\n ///\n-/// [`i8::from_str_radix()`]: ../std/primitive.i8.html#method.from_str_radix\n+/// [`i8::from_str_radix()`]: ../../std/primitive.i8.html#method.from_str_radix\n #[derive(Debug, Clone, PartialEq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseIntError { kind: IntErrorKind }"}, {"sha": "e59e8567d5b6273e589d1ca14644ab1ea08a40fb", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -908,6 +908,7 @@ impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An internal abstraction over the splitting iterators, so that\n /// splitn, splitn_mut etc can be implemented once.\n+#[doc(hidden)]\n trait SplitIter: DoubleEndedIterator {\n     /// Mark the underlying iterator as complete, extracting the remaining\n     /// portion of the slice."}, {"sha": "dee13bf3d3db13f30e8ef37af25eeadbe3ce11e2", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -42,8 +42,8 @@ pub mod pattern;\n /// [`str`]'s [`parse()`] method. See [`parse()`]'s documentation for examples.\n ///\n /// [`from_str()`]: #tymethod.from_str\n-/// [`str`]: ../primitive.str.html\n-/// [`parse()`]: ../primitive.str.html#method.parse\n+/// [`str`]: ../../std/primitive.str.html\n+/// [`parse()`]: ../../std/primitive.str.html#method.parse\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait FromStr: Sized {\n     /// The associated error which can be returned from parsing.\n@@ -60,7 +60,7 @@ pub trait FromStr: Sized {\n     ///\n     /// Basic usage with [`i32`][ithirtytwo], a type that implements `FromStr`:\n     ///\n-    /// [ithirtytwo]: ../primitive.i32.html\n+    /// [ithirtytwo]: ../../std/primitive.i32.html\n     ///\n     /// ```\n     /// use std::str::FromStr;\n@@ -182,7 +182,7 @@ impl Utf8Error {\n /// If you need a `String` instead of a `&str`, consider\n /// [`String::from_utf8()`][string].\n ///\n-/// [string]: ../string/struct.String.html#method.from_utf8\n+/// [string]: ../../std/string/struct.String.html#method.from_utf8\n ///\n /// Because you can stack-allocate a `[u8; N]`, and you can take a `&[u8]` of\n /// it, this function is one way to have a stack-allocated string. There is\n@@ -322,7 +322,7 @@ Section: Iterators\n ///\n /// Created with the method [`chars()`].\n ///\n-/// [`chars()`]: ../primitive.str.html#method.chars\n+/// [`chars()`]: ../../std/primitive.str.html#method.chars\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chars<'a> {\n@@ -531,7 +531,7 @@ impl<'a> CharIndices<'a> {\n ///\n /// Created with the method [`bytes()`].\n ///\n-/// [`bytes()`]: ../primitive.str.html#method.bytes\n+/// [`bytes()`]: ../../std/primitive.str.html#method.bytes\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Bytes<'a>(Cloned<slice::Iter<'a, u8>>);\n@@ -816,12 +816,12 @@ generate_pattern_iterators! {\n     forward:\n         /// Created with the method [`split()`].\n         ///\n-        /// [`split()`]: ../primitive.str.html#method.split\n+        /// [`split()`]: ../../std/primitive.str.html#method.split\n         struct Split;\n     reverse:\n         /// Created with the method [`rsplit()`].\n         ///\n-        /// [`rsplit()`]: ../primitive.str.html#method.rsplit\n+        /// [`rsplit()`]: ../../std/primitive.str.html#method.rsplit\n         struct RSplit;\n     stability:\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -834,12 +834,12 @@ generate_pattern_iterators! {\n     forward:\n         /// Created with the method [`split_terminator()`].\n         ///\n-        /// [`split_terminator()`]: ../primitive.str.html#method.split_terminator\n+        /// [`split_terminator()`]: ../../std/primitive.str.html#method.split_terminator\n         struct SplitTerminator;\n     reverse:\n         /// Created with the method [`rsplit_terminator()`].\n         ///\n-        /// [`rsplit_terminator()`]: ../primitive.str.html#method.rsplit_terminator\n+        /// [`rsplit_terminator()`]: ../../std/primitive.str.html#method.rsplit_terminator\n         struct RSplitTerminator;\n     stability:\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -884,12 +884,12 @@ generate_pattern_iterators! {\n     forward:\n         /// Created with the method [`splitn()`].\n         ///\n-        /// [`splitn()`]: ../primitive.str.html#method.splitn\n+        /// [`splitn()`]: ../../std/primitive.str.html#method.splitn\n         struct SplitN;\n     reverse:\n         /// Created with the method [`rsplitn()`].\n         ///\n-        /// [`rsplitn()`]: ../primitive.str.html#method.rsplitn\n+        /// [`rsplitn()`]: ../../std/primitive.str.html#method.rsplitn\n         struct RSplitN;\n     stability:\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -926,12 +926,12 @@ generate_pattern_iterators! {\n     forward:\n         /// Created with the method [`match_indices()`].\n         ///\n-        /// [`match_indices()`]: ../primitive.str.html#method.match_indices\n+        /// [`match_indices()`]: ../../std/primitive.str.html#method.match_indices\n         struct MatchIndices;\n     reverse:\n         /// Created with the method [`rmatch_indices()`].\n         ///\n-        /// [`rmatch_indices()`]: ../primitive.str.html#method.rmatch_indices\n+        /// [`rmatch_indices()`]: ../../std/primitive.str.html#method.rmatch_indices\n         struct RMatchIndices;\n     stability:\n         #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n@@ -970,12 +970,12 @@ generate_pattern_iterators! {\n     forward:\n         /// Created with the method [`matches()`].\n         ///\n-        /// [`matches()`]: ../primitive.str.html#method.matches\n+        /// [`matches()`]: ../../std/primitive.str.html#method.matches\n         struct Matches;\n     reverse:\n         /// Created with the method [`rmatches()`].\n         ///\n-        /// [`rmatches()`]: ../primitive.str.html#method.rmatches\n+        /// [`rmatches()`]: ../../std/primitive.str.html#method.rmatches\n         struct RMatches;\n     stability:\n         #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n@@ -986,7 +986,7 @@ generate_pattern_iterators! {\n \n /// Created with the method [`lines()`].\n ///\n-/// [`lines()`]: ../primitive.str.html#method.lines\n+/// [`lines()`]: ../../std/primitive.str.html#method.lines\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Lines<'a>(Map<SplitTerminator<'a, char>, LinesAnyMap>);\n@@ -1016,7 +1016,7 @@ impl<'a> DoubleEndedIterator for Lines<'a> {\n \n /// Created with the method [`lines_any()`].\n ///\n-/// [`lines_any()`]: ../primitive.str.html#method.lines_any\n+/// [`lines_any()`]: ../../std/primitive.str.html#method.lines_any\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(since = \"1.4.0\", reason = \"use lines()/Lines instead now\")]\n #[derive(Clone)]"}, {"sha": "07fae35b23be3efb0ed773ae62ad1b6dae4bdcbd", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -67,6 +67,7 @@ mod rand_impls;\n // needed by librand; this is necessary because librand doesn't\n // depend on libstd.  This will go away when librand is integrated\n // into libstd.\n+#[doc(hidden)]\n trait FloatMath : Sized {\n     fn exp(self) -> Self;\n     fn ln(self) -> Self;"}, {"sha": "5bc5c78616093912268c01c905e6660cf1414563", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -19,7 +19,7 @@\n //! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n //!\n //! This module exists for technical reasons, the primary documentation for\n-//! `char` is directly on [the `char` primitive type](../primitive.char.html)\n+//! `char` is directly on [the `char` primitive type](../../std/primitive.char.html)\n //! itself.\n //!\n //! This module is the home of the iterator implementations for the iterators\n@@ -46,8 +46,8 @@ pub use tables::UNICODE_VERSION;\n /// This `struct` is created by the [`to_lowercase()`] method on [`char`]. See\n /// its documentation for more.\n ///\n-/// [`to_lowercase()`]: ../primitive.char.html#method.to_lowercase\n-/// [`char`]: ../primitive.char.html\n+/// [`to_lowercase()`]: ../../std/primitive.char.html#method.to_lowercase\n+/// [`char`]: ../../std/primitive.char.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ToLowercase(CaseMappingIter);\n \n@@ -64,8 +64,8 @@ impl Iterator for ToLowercase {\n /// This `struct` is created by the [`to_uppercase()`] method on [`char`]. See\n /// its documentation for more.\n ///\n-/// [`to_uppercase()`]: ../primitive.char.html#method.to_uppercase\n-/// [`char`]: ../primitive.char.html\n+/// [`to_uppercase()`]: ../../std/primitive.char.html#method.to_uppercase\n+/// [`char`]: ../../std/primitive.char.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ToUppercase(CaseMappingIter);\n \n@@ -968,6 +968,6 @@ impl<I: Iterator<Item=u16>> Iterator for DecodeUtf16<I> {\n \n /// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a decoding error.\n /// It can occur, for example, when giving ill-formed UTF-8 bytes to\n-/// [`String::from_utf8_lossy`](../string/struct.String.html#method.from_utf8_lossy).\n+/// [`String::from_utf8_lossy`](../../std/string/struct.String.html#method.from_utf8_lossy).\n #[unstable(feature = \"decode_utf16\", reason = \"recently added\", issue = \"27830\")]\n pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';"}, {"sha": "061047cbd2f6d9c6c34c86a534b5eea65f7add85", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -222,7 +222,8 @@ fn build_type(cx: &DocContext, tcx: &TyCtxt, did: DefId) -> clean::ItemEnum {\n     }, false)\n }\n \n-pub fn build_impls(cx: &DocContext, tcx: &TyCtxt,\n+pub fn build_impls(cx: &DocContext,\n+                   tcx: &TyCtxt,\n                    did: DefId) -> Vec<clean::Item> {\n     tcx.populate_inherent_implementations_for_type_if_necessary(did);\n     let mut impls = Vec::new();\n@@ -241,10 +242,12 @@ pub fn build_impls(cx: &DocContext, tcx: &TyCtxt,\n     // Primarily, the impls will be used to populate the documentation for this\n     // type being inlined, but impls can also be used when generating\n     // documentation for primitives (no way to find those specifically).\n-    if cx.populated_crate_impls.borrow_mut().insert(did.krate) {\n+    if !cx.all_crate_impls.borrow_mut().contains_key(&did.krate) {\n+        let mut impls = Vec::new();\n         for item in tcx.sess.cstore.crate_top_level_items(did.krate) {\n             populate_impls(cx, tcx, item.def, &mut impls);\n         }\n+        cx.all_crate_impls.borrow_mut().insert(did.krate, impls);\n \n         fn populate_impls(cx: &DocContext, tcx: &TyCtxt,\n                           def: cstore::DefLike,\n@@ -266,6 +269,20 @@ pub fn build_impls(cx: &DocContext, tcx: &TyCtxt,\n         }\n     }\n \n+    let mut candidates = cx.all_crate_impls.borrow_mut();\n+    let candidates = candidates.get_mut(&did.krate).unwrap();\n+    for i in (0..candidates.len()).rev() {\n+        let remove = match candidates[i].inner {\n+            clean::ImplItem(ref i) => {\n+                i.for_.def_id() == Some(did) || i.for_.primitive_type().is_some()\n+            }\n+            _ => continue,\n+        };\n+        if remove {\n+            impls.push(candidates.swap_remove(i));\n+        }\n+    }\n+\n     return impls;\n }\n "}, {"sha": "a4b8c9bf5f7db4aae9fb74b5e3ae6271c32c7a39", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -1499,6 +1499,13 @@ impl Type {\n             _ => None,\n         }\n     }\n+\n+    fn def_id(&self) -> Option<DefId> {\n+        match *self {\n+            ResolvedPath { did, .. } => Some(did),\n+            _ => None,\n+        }\n+    }\n }\n \n impl PrimitiveType {"}, {"sha": "c30fd39616c448079f084acbb1cbe12603841566", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -56,7 +56,7 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     pub external_traits: RefCell<Option<HashMap<DefId, clean::Trait>>>,\n     pub external_typarams: RefCell<Option<HashMap<DefId, String>>>,\n     pub inlined: RefCell<Option<HashSet<DefId>>>,\n-    pub populated_crate_impls: RefCell<HashSet<ast::CrateNum>>,\n+    pub all_crate_impls: RefCell<HashMap<ast::CrateNum, Vec<clean::Item>>>,\n     pub deref_trait_did: Cell<Option<DefId>>,\n }\n \n@@ -179,7 +179,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n             external_typarams: RefCell::new(Some(HashMap::new())),\n             external_paths: RefCell::new(Some(HashMap::new())),\n             inlined: RefCell::new(Some(HashSet::new())),\n-            populated_crate_impls: RefCell::new(HashSet::new()),\n+            all_crate_impls: RefCell::new(HashMap::new()),\n             deref_trait_did: Cell::new(None),\n         };\n         debug!(\"crate: {:?}\", ctxt.map.krate());"}, {"sha": "d873c9ec340c08f47a0c270c44866ce516990dd0", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -11,7 +11,7 @@\n #![allow(deprecated)]\n \n use std::cell::{RefCell, Cell};\n-use std::collections::{HashSet, HashMap};\n+use std::collections::HashMap;\n use std::dynamic_lib::DynamicLibrary;\n use std::env;\n use std::ffi::OsString;\n@@ -114,7 +114,7 @@ pub fn run(input: &str,\n         external_traits: RefCell::new(None),\n         external_typarams: RefCell::new(None),\n         inlined: RefCell::new(None),\n-        populated_crate_impls: RefCell::new(HashSet::new()),\n+        all_crate_impls: RefCell::new(HashMap::new()),\n         deref_trait_did: Cell::new(None),\n     };\n "}, {"sha": "3705302592432cc192e610571d8caadf4f8856a2", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -262,7 +262,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n-    /// [floating-point]: ../../../../../reference.html#machine-types\n+    /// [floating-point]: ../reference.html#machine-types\n     #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n                issue = \"27752\")]\n     #[inline]"}, {"sha": "446e22a20ad7d576dc8cd18cb75b06cc0a69d92d", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -206,7 +206,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n-    /// [floating-point]: ../../../../../reference.html#machine-types\n+    /// [floating-point]: ../reference.html#machine-types\n     #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n                issue = \"27752\")]\n     #[inline]"}, {"sha": "65ed879c4ada462bbd627c15a8ff2417c43728ce", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -27,11 +27,11 @@\n /// assert!(!bool_val);\n /// ```\n ///\n-/// [`assert!`]: std/macro.assert!.html\n-/// [`if` conditionals]: ../../book/if.html\n-/// [`BitAnd`]: ../ops/trait.BitAnd.html\n-/// [`BitOr`]: ../ops/trait.BitOr.html\n-/// [`Not`]: ../ops/trait.Not.html\n+/// [`assert!`]: macro.assert!.html\n+/// [`if` conditionals]: ../book/if.html\n+/// [`BitAnd`]: ops/trait.BitAnd.html\n+/// [`BitOr`]: ops/trait.BitOr.html\n+/// [`Not`]: ops/trait.Not.html\n ///\n /// # Examples\n ///\n@@ -54,7 +54,7 @@\n /// }\n /// ```\n ///\n-/// Also, since `bool` implements the [`Copy`](../marker/trait.Copy.html) trait, we don't\n+/// Also, since `bool` implements the [`Copy`](marker/trait.Copy.html) trait, we don't\n /// have to worry about the move semantics (just like the integer and float primitives).\n mod prim_bool { }\n \n@@ -421,7 +421,7 @@ mod prim_str { }\n /// assert_eq!(tuple.2, 'c');\n /// ```\n ///\n-/// For more about tuples, see [the book](../../book/primitive-types.html#tuples).\n+/// For more about tuples, see [the book](../book/primitive-types.html#tuples).\n ///\n /// # Trait implementations\n ///\n@@ -437,14 +437,14 @@ mod prim_str { }\n /// * [`Default`]\n /// * [`Hash`]\n ///\n-/// [`Clone`]: ../clone/trait.Clone.html\n-/// [`PartialEq`]: ../cmp/trait.PartialEq.html\n-/// [`Eq`]: ../cmp/trait.Eq.html\n-/// [`PartialOrd`]: ../cmp/trait.PartialOrd.html\n-/// [`Ord`]: ../cmp/trait.Ord.html\n-/// [`Debug`]: ../fmt/trait.Debug.html\n-/// [`Default`]: ../default/trait.Default.html\n-/// [`Hash`]: ../hash/trait.Hash.html\n+/// [`Clone`]: clone/trait.Clone.html\n+/// [`PartialEq`]: cmp/trait.PartialEq.html\n+/// [`Eq`]: cmp/trait.Eq.html\n+/// [`PartialOrd`]: cmp/trait.PartialOrd.html\n+/// [`Ord`]: cmp/trait.Ord.html\n+/// [`Debug`]: fmt/trait.Debug.html\n+/// [`Default`]: default/trait.Default.html\n+/// [`Hash`]: hash/trait.Hash.html\n ///\n /// Due to a temporary restriction in Rust's type system, these traits are only\n /// implemented on tuples of arity 32 or less. In the future, this may change."}, {"sha": "c684c474efa9e3e067781c6a30adaaaa8d6151e6", "filename": "src/rustbook/Cargo.toml", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/40c85cd8aec5de06140252610ad4bdc352324e2c/src%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/40c85cd8aec5de06140252610ad4bdc352324e2c/src%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2FCargo.toml?ref=40c85cd8aec5de06140252610ad4bdc352324e2c", "patch": "@@ -1,13 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rustbook\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"rustbook\"\n-path = \"main.rs\"\n-crate-type = [\"dylib\"]\n-\n-[dependencies]\n-rustc_back = { path = \"../librustc_back\" }\n-rustdoc = { path = \"../librustdoc\" }"}, {"sha": "a27183516404388e13f50f84e102022500a40ec8", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -2,7 +2,6 @@\n name = \"rustc-main\"\n version = \"0.0.0\"\n dependencies = [\n- \"rustbook 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_driver 0.0.0\",\n  \"rustdoc 0.0.0\",\n@@ -66,14 +65,6 @@ dependencies = [\n  \"serialize 0.0.0\",\n ]\n \n-[[package]]\n-name = \"rustbook\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"rustc_back 0.0.0\",\n- \"rustdoc 0.0.0\",\n-]\n-\n [[package]]\n name = \"rustc\"\n version = \"0.0.0\""}, {"sha": "7431c35efba01752e01dc51b9e9f6d22f9caf62c", "filename": "src/rustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.toml?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -11,10 +11,6 @@ path = \"rustc.rs\"\n name = \"rustdoc\"\n path = \"rustdoc.rs\"\n \n-[[bin]]\n-name = \"rustbook\"\n-path = \"rustbook.rs\"\n-\n [profile.release]\n opt-level = 2\n \n@@ -27,10 +23,9 @@ debug-assertions = false\n # All optional dependencies so the features passed to this Cargo.toml select\n # what should actually be built.\n [dependencies]\n-rustbook = { path = \"../rustbook\", optional = true }\n rustc_back = { path = \"../librustc_back\" }\n rustc_driver = { path = \"../librustc_driver\" }\n-rustdoc = { path = \"../librustdoc\", optional = true }\n+rustdoc = { path = \"../librustdoc\" }\n \n [features]\n jemalloc = [\"rustc_back/jemalloc\"]"}, {"sha": "6f78f78bc55a61f9fddf98a6503ccda3a11663ca", "filename": "src/rustc/rustbook.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40c85cd8aec5de06140252610ad4bdc352324e2c/src%2Frustc%2Frustbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c85cd8aec5de06140252610ad4bdc352324e2c/src%2Frustc%2Frustbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustbook.rs?ref=40c85cd8aec5de06140252610ad4bdc352324e2c", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate rustbook;\n-\n-fn main() { rustbook::main() }\n-"}, {"sha": "b7d2cfcaaa1a8c04f58b697beb60ff6385a15906", "filename": "src/tools/error_index_generator/Cargo.lock", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Ferror_index_generator%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Ferror_index_generator%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2FCargo.lock?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -0,0 +1,4 @@\n+[root]\n+name = \"error_index_generator\"\n+version = \"0.0.0\"\n+"}, {"sha": "5c5ca273e9ca39f931988c49b5f83b6537e46dd0", "filename": "src/tools/error_index_generator/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Ferror_index_generator%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Ferror_index_generator%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2FCargo.toml?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"error_index_generator\"\n+version = \"0.0.0\"\n+\n+[[bin]]\n+name = \"error_index_generator\"\n+path = \"main.rs\""}, {"sha": "4343aef00a9081a548743f1390c38588ad28e5fd", "filename": "src/tools/error_index_generator/main.rs", "status": "renamed", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -15,11 +15,12 @@ extern crate rustdoc;\n extern crate serialize as rustc_serialize;\n \n use std::collections::BTreeMap;\n+use std::env;\n+use std::error::Error;\n use std::fs::{read_dir, File};\n use std::io::{Read, Write};\n-use std::env;\n use std::path::Path;\n-use std::error::Error;\n+use std::path::PathBuf;\n \n use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap, ErrorMetadata};\n \n@@ -173,31 +174,35 @@ fn render_error_page<T: Formatter>(err_map: &ErrorMetadataMap, output_path: &Pat\n     formatter.footer(&mut output_file)\n }\n \n-fn main_with_result(format: OutputFormat) -> Result<(), Box<Error>> {\n+fn main_with_result(format: OutputFormat, dst: &Path) -> Result<(), Box<Error>> {\n     let build_arch = try!(env::var(\"CFG_BUILD\"));\n     let metadata_dir = get_metadata_dir(&build_arch);\n     let err_map = try!(load_all_errors(&metadata_dir));\n     match format {\n         OutputFormat::Unknown(s)  => panic!(\"Unknown output format: {}\", s),\n-        OutputFormat::HTML(h)     => try!(render_error_page(&err_map,\n-                                                            Path::new(\"doc/error-index.html\"),\n-                                                            h)),\n-        OutputFormat::Markdown(m) => try!(render_error_page(&err_map,\n-                                                            Path::new(\"doc/error-index.md\"),\n-                                                            m)),\n+        OutputFormat::HTML(h)     => try!(render_error_page(&err_map, dst, h)),\n+        OutputFormat::Markdown(m) => try!(render_error_page(&err_map, dst, m)),\n     }\n     Ok(())\n }\n \n-fn parse_args() -> OutputFormat {\n-    for arg in env::args().skip(1) {\n-        return OutputFormat::from(&arg);\n-    }\n-    OutputFormat::from(\"html\")\n+fn parse_args() -> (OutputFormat, PathBuf) {\n+    let mut args = env::args().skip(1);\n+    let format = args.next().map(|a| OutputFormat::from(&a))\n+                            .unwrap_or(OutputFormat::from(\"html\"));\n+    let dst = args.next().map(PathBuf::from).unwrap_or_else(|| {\n+        match format {\n+            OutputFormat::HTML(..) => PathBuf::from(\"doc/error-index.html\"),\n+            OutputFormat::Markdown(..) => PathBuf::from(\"doc/error-index.md\"),\n+            OutputFormat::Unknown(..) => PathBuf::from(\"<nul>\"),\n+        }\n+    });\n+    (format, dst)\n }\n \n fn main() {\n-    if let Err(e) = main_with_result(parse_args()) {\n+    let (format, dst) = parse_args();\n+    if let Err(e) = main_with_result(format, &dst) {\n         panic!(\"{}\", e.description());\n     }\n }", "previous_filename": "src/error_index_generator/main.rs"}, {"sha": "8e94137d2139b0394e6f126360707aade318acea", "filename": "src/tools/linkchecker/Cargo.lock", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Flinkchecker%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Flinkchecker%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2FCargo.lock?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -0,0 +1,64 @@\n+[root]\n+name = \"linkchecker\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"url 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"matches\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"rand\"\n+version = \"0.3.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rustc-serialize\"\n+version = \"0.3.18\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"unicode-bidi\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"matches 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"unicode-normalization\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"url\"\n+version = \"0.5.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"matches 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-bidi 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-normalization 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"uuid 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"uuid\"\n+version = \"0.1.18\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+"}, {"sha": "29fc78a65e9168e042987fbe59184fdc254b0fae", "filename": "src/tools/linkchecker/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Flinkchecker%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Flinkchecker%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2FCargo.toml?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -0,0 +1,11 @@\n+[package]\n+name = \"linkchecker\"\n+version = \"0.1.0\"\n+authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n+\n+[dependencies]\n+url = \"0.5\"\n+\n+[[bin]]\n+name = \"linkchecker\"\n+path = \"main.rs\""}, {"sha": "e5e88081bc43ed23e91b11f8cd92c05dbfb5671b", "filename": "src/tools/linkchecker/main.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -0,0 +1,161 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Script to check the validity of `href` links in our HTML documentation.\n+//!\n+//! In the past we've been quite error prone to writing in broken links as most\n+//! of them are manually rather than automatically added. As files move over\n+//! time or apis change old links become stale or broken. The purpose of this\n+//! script is to check all relative links in our documentation to make sure they\n+//! actually point to a valid place.\n+//!\n+//! Currently this doesn't actually do any HTML parsing or anything fancy like\n+//! that, it just has a simple \"regex\" to search for `href` tags. These values\n+//! are then translated to file URLs if possible and then the destination is\n+//! asserted to exist.\n+//!\n+//! A few whitelisted exceptions are allowed as there's known bugs in rustdoc,\n+//! but this should catch the majority of \"broken link\" cases.\n+\n+extern crate url;\n+\n+use std::env;\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::path::Path;\n+\n+use url::{Url, UrlParser};\n+\n+macro_rules! t {\n+    ($e:expr) => (match $e {\n+        Ok(e) => e,\n+        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+    })\n+}\n+\n+fn main() {\n+    let docs = env::args().nth(1).unwrap();\n+    let docs = env::current_dir().unwrap().join(docs);\n+    let mut url = Url::from_file_path(&docs).unwrap();\n+    let mut errors = false;\n+    walk(&docs, &docs, &mut url, &mut errors);\n+    if errors {\n+        panic!(\"found some broken links\");\n+    }\n+}\n+\n+fn walk(root: &Path, dir: &Path, url: &mut Url, errors: &mut bool) {\n+    for entry in t!(dir.read_dir()).map(|e| t!(e)) {\n+        let path = entry.path();\n+        let kind = t!(entry.file_type());\n+        url.path_mut().unwrap().push(entry.file_name().into_string().unwrap());\n+        if kind.is_dir() {\n+            walk(root, &path, url, errors);\n+        } else {\n+            check(root, &path, url, errors);\n+        }\n+        url.path_mut().unwrap().pop();\n+    }\n+}\n+\n+fn check(root: &Path, file: &Path, base: &Url, errors: &mut bool) {\n+    // ignore js files as they are not prone to errors as the rest of the\n+    // documentation is and they otherwise bring up false positives.\n+    if file.extension().and_then(|s| s.to_str()) == Some(\"js\") {\n+        return\n+    }\n+\n+    let pretty_file = file.strip_prefix(root).unwrap_or(file);\n+\n+    // Unfortunately we're not 100% full of valid links today to we need a few\n+    // whitelists to get this past `make check` today.\n+    if let Some(path) = pretty_file.to_str() {\n+        // FIXME(#32129)\n+        if path == \"std/string/struct.String.html\" {\n+            return\n+        }\n+        // FIXME(#32130)\n+        if path.contains(\"btree_set/struct.BTreeSet.html\") ||\n+           path == \"collections/struct.BTreeSet.html\" {\n+            return\n+        }\n+        // FIXME(#31948)\n+        if path.contains(\"ParseFloatError\") {\n+            return\n+        }\n+\n+        // currently\n+        if path == \"std/sys/ext/index.html\" {\n+            return\n+        }\n+\n+        // weird reexports, but this module is on its way out, so chalk it up to\n+        // \"rustdoc weirdness\" and move on from there\n+        if path.contains(\"scoped_tls\") {\n+            return\n+        }\n+    }\n+\n+    let mut parser = UrlParser::new();\n+    parser.base_url(base);\n+    let mut contents = String::new();\n+    if t!(File::open(file)).read_to_string(&mut contents).is_err() {\n+        return\n+    }\n+\n+    for (i, mut line) in contents.lines().enumerate() {\n+        // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n+        while let Some(j) = line.find(\" href\") {\n+            let rest = &line[j + 5..];\n+            line = rest;\n+            let pos_equals = match rest.find(\"=\") {\n+                Some(i) => i,\n+                None => continue,\n+            };\n+            if rest[..pos_equals].trim_left_matches(\" \") != \"\" {\n+                continue\n+            }\n+            let rest = &rest[pos_equals + 1..];\n+            let pos_quote = match rest.find(\"\\\"\").or_else(|| rest.find(\"'\")) {\n+                Some(i) => i,\n+                None => continue,\n+            };\n+            if rest[..pos_quote].trim_left_matches(\" \") != \"\" {\n+                continue\n+            }\n+            let rest = &rest[pos_quote + 1..];\n+            let url = match rest.find(\"\\\"\").or_else(|| rest.find(\"'\")) {\n+                Some(i) => &rest[..i],\n+                None => continue,\n+            };\n+\n+            // Once we've plucked out the URL, parse it using our base url and\n+            // then try to extract a file path. If either if these fail then we\n+            // just keep going.\n+            let parsed_url = match parser.parse(url) {\n+                Ok(url) => url,\n+                Err(..) => continue,\n+            };\n+            let path = match parsed_url.to_file_path() {\n+                Ok(path) => path,\n+                Err(..) => continue,\n+            };\n+\n+            // Alright, if we've found a file name then this file had better\n+            // exist! If it doesn't then we register and print an error.\n+            if !path.exists() {\n+                *errors = true;\n+                print!(\"{}:{}: broken link - \", pretty_file.display(), i + 1);\n+                let pretty_path = path.strip_prefix(root).unwrap_or(&path);\n+                println!(\"{}\", pretty_path.display());\n+            }\n+        }\n+    }\n+}"}, {"sha": "e541ce4b2b807ed41d91e4626714230797931329", "filename": "src/tools/rustbook/Cargo.lock", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.lock?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -0,0 +1,4 @@\n+[root]\n+name = \"rustbook\"\n+version = \"0.0.0\"\n+"}, {"sha": "956392ca540cd64c8efcd0c6b31b4af92cb2af40", "filename": "src/tools/rustbook/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.toml?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustbook\"\n+version = \"0.0.0\"\n+\n+[[bin]]\n+name = \"rustbook\"\n+path = \"main.rs\""}, {"sha": "36a37dba1fa0f7cf4df405b9d520aa7057551805", "filename": "src/tools/rustbook/book.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fbook.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "previous_filename": "src/rustbook/book.rs"}, {"sha": "70ed98519f97209a991ed2e42cf485ef6e1bbdde", "filename": "src/tools/rustbook/build.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fbuild.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "patch": "@@ -160,7 +160,7 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n \n     // Copy js for playpen\n     let mut playpen = try!(File::create(tgt.join(\"playpen.js\")));\n-    let js = include_bytes!(\"../librustdoc/html/static/playpen.js\");\n+    let js = include_bytes!(\"../../librustdoc/html/static/playpen.js\");\n     try!(playpen.write_all(js));\n     Ok(())\n }", "previous_filename": "src/rustbook/build.rs"}, {"sha": "e896dee27919e1c4121e2be47b7c5c334e8ffa1f", "filename": "src/tools/rustbook/error.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Ferror.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "previous_filename": "src/rustbook/error.rs"}, {"sha": "c90c2b936092a4b643483d20b26d37851139d929", "filename": "src/tools/rustbook/help.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fhelp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fhelp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fhelp.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "previous_filename": "src/rustbook/help.rs"}, {"sha": "bd4fc8992930e99715c243ae7829e524219166bc", "filename": "src/tools/rustbook/main.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fmain.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "previous_filename": "src/rustbook/main.rs"}, {"sha": "2fa7b7eed7b05d77a8bd6f58ea0b29c7a4f7bc48", "filename": "src/tools/rustbook/serve.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fserve.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "previous_filename": "src/rustbook/serve.rs"}, {"sha": "ba0151fa2ed4773116c06a94773cdb844806331b", "filename": "src/tools/rustbook/static/rustbook.css", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fstatic%2Frustbook.css", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fstatic%2Frustbook.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fstatic%2Frustbook.css?ref=aeb85a953322df7773095186e9762f3fe73375e2", "previous_filename": "src/rustbook/static/rustbook.css"}, {"sha": "d8ab15260edb47448d08f0290f1695979201ec29", "filename": "src/tools/rustbook/static/rustbook.js", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fstatic%2Frustbook.js", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fstatic%2Frustbook.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fstatic%2Frustbook.js?ref=aeb85a953322df7773095186e9762f3fe73375e2", "previous_filename": "src/rustbook/static/rustbook.js"}, {"sha": "a66c2b4f3024dda9bc90bd6c194b876df9555d53", "filename": "src/tools/rustbook/subcommand.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fsubcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fsubcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fsubcommand.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "previous_filename": "src/rustbook/subcommand.rs"}, {"sha": "cdd25e67c8ff13274da1928c75296862c8c958af", "filename": "src/tools/rustbook/term.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fterm.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "previous_filename": "src/rustbook/term.rs"}, {"sha": "72df0768e7b9b5c70972123ec3c2425db87bbafe", "filename": "src/tools/rustbook/test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb85a953322df7773095186e9762f3fe73375e2/src%2Ftools%2Frustbook%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Ftest.rs?ref=aeb85a953322df7773095186e9762f3fe73375e2", "previous_filename": "src/rustbook/test.rs"}]}