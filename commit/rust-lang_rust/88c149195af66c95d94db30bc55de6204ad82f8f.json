{"sha": "88c149195af66c95d94db30bc55de6204ad82f8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4YzE0OTE5NWFmNjZjOTVkOTRkYjMwYmM1NWRlNjIwNGFkODJmOGY=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-12T18:24:05Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-15T00:52:55Z"}, "message": "std: Replace map_vec, map_vec2, iter_vec2 in std::result\n\nReplace these with three functions based on iterators: collect, fold,\nand fold_. The mapping part is replaced by iterator .map(), so the part\nthat these functions do is to accumulate the final Result<,> value.\n\n* `result::collect` gathers `Iterator<Result<V, U>>` to `Result<~[V], U>`\n* `result::fold` folds `Iterator<Result<T, E>>` to `Result<V, E>`\n* `result::fold_` folds `Iterator<Result<T, E>>` to `Result<(), E>`", "tree": {"sha": "0897911f80a422957e06462a2f213db9202068c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0897911f80a422957e06462a2f213db9202068c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88c149195af66c95d94db30bc55de6204ad82f8f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88c149195af66c95d94db30bc55de6204ad82f8f", "html_url": "https://github.com/rust-lang/rust/commit/88c149195af66c95d94db30bc55de6204ad82f8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88c149195af66c95d94db30bc55de6204ad82f8f/comments", "author": null, "committer": null, "parents": [{"sha": "6fe4c871f1010053092a908d75ae8e4c4fb46599", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fe4c871f1010053092a908d75ae8e4c4fb46599", "html_url": "https://github.com/rust-lang/rust/commit/6fe4c871f1010053092a908d75ae8e4c4fb46599"}], "stats": {"total": 155, "additions": 93, "deletions": 62}, "files": [{"sha": "161d96d828b47c8830c1fd0f3406bb76cf7d1b28", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/88c149195af66c95d94db30bc55de6204ad82f8f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c149195af66c95d94db30bc55de6204ad82f8f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=88c149195af66c95d94db30bc55de6204ad82f8f", "patch": "@@ -68,7 +68,7 @@ use middle::typeck::infer::{InferCtxt, cres, ures};\n use middle::typeck::infer::{TypeTrace};\n use util::common::indent;\n \n-use std::result::{iter_vec2, map_vec2};\n+use std::result;\n use std::vec;\n use syntax::ast::{Onceness, purity};\n use syntax::ast;\n@@ -275,9 +275,9 @@ pub fn super_tps<C:Combine>(\n     // variance.\n \n     if vec::same_length(as_, bs) {\n-        iter_vec2(as_, bs, |a, b| {\n-            eq_tys(this, *a, *b)\n-        }).then(|| Ok(as_.to_owned()) )\n+        result::fold_(as_.iter().zip(bs.iter())\n+                      .map(|(a, b)| eq_tys(this, *a, *b)))\n+            .then(|| Ok(as_.to_owned()))\n     } else {\n         Err(ty::terr_ty_param_size(\n             expected_found(this, as_.len(), bs.len())))\n@@ -427,7 +427,8 @@ pub fn super_fn_sigs<C:Combine>(\n {\n     fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<~[ty::t]> {\n         if vec::same_length(a_args, b_args) {\n-            map_vec2(a_args, b_args, |a, b| this.args(*a, *b))\n+            result::collect(a_args.iter().zip(b_args.iter())\n+                            .map(|(a, b)| this.args(*a, *b)))\n         } else {\n             Err(ty::terr_arg_count)\n         }\n@@ -586,8 +587,9 @@ pub fn super_tys<C:Combine>(\n \n       (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {\n         if as_.len() == bs.len() {\n-            map_vec2(*as_, *bs, |a, b| this.tys(*a, *b) )\n-                .chain(|ts| Ok(ty::mk_tup(tcx, ts)) )\n+            result::collect(as_.iter().zip(bs.iter())\n+                            .map(|(a, b)| this.tys(*a, *b)))\n+                    .chain(|ts| Ok(ty::mk_tup(tcx, ts)) )\n         } else {\n             Err(ty::terr_tuple_size(\n                 expected_found(this, as_.len(), bs.len())))"}, {"sha": "9ae901d60bc46ee755f13a98c8495b9b9d3a51e5", "filename": "src/libstd/result.rs", "status": "modified", "additions": 84, "deletions": 55, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/88c149195af66c95d94db30bc55de6204ad82f8f/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c149195af66c95d94db30bc55de6204ad82f8f/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=88c149195af66c95d94db30bc55de6204ad82f8f", "patch": "@@ -18,8 +18,7 @@ use either;\n use iterator::Iterator;\n use option::{None, Option, Some, OptionIterator};\n use vec;\n-use vec::{OwnedVector, ImmutableVector};\n-use container::Container;\n+use vec::OwnedVector;\n use to_str::ToStr;\n use str::StrSlice;\n \n@@ -269,86 +268,76 @@ pub fn map_opt<T, U: ToStr, V>(o_t: &Option<T>,\n     }\n }\n \n-// FIXME: #8228 Replaceable by an external iterator?\n-/// Maps each element in the vector `ts` using the operation `op`.  Should an\n-/// error occur, no further mappings are performed and the error is returned.\n-/// Should no error occur, a vector containing the result of each map is\n-/// returned.\n+/// Takes each element in the iterator: if it is an error, no further\n+/// elements are taken, and the error is returned.\n+/// Should no error occur, a vector containing the values of each Result\n+/// is returned.\n ///\n /// Here is an example which increments every integer in a vector,\n /// checking for overflow:\n ///\n-///     fn inc_conditionally(x: uint) -> result<uint,str> {\n+///     fn inc_conditionally(x: uint) -> Result<uint, &'static str> {\n ///         if x == uint::max_value { return Err(\"overflow\"); }\n ///         else { return Ok(x+1u); }\n ///     }\n-///     map(~[1u, 2u, 3u], inc_conditionally).chain {|incd|\n-///         assert!(incd == ~[2u, 3u, 4u]);\n-///     }\n+///     let v = [1u, 2, 3];\n+///     let res = collect(v.iter().map(|&x| inc_conditionally(x)));\n+///     assert!(res == Ok(~[2u, 3, 4]));\n #[inline]\n-pub fn map_vec<T,U,V>(ts: &[T], op: &fn(&T) -> Result<V,U>)\n-                      -> Result<~[V],U> {\n-    let mut vs: ~[V] = vec::with_capacity(ts.len());\n-    for t in ts.iter() {\n-        match op(t) {\n-          Ok(v) => vs.push(v),\n-          Err(u) => return Err(u)\n+pub fn collect<T, E, Iter: Iterator<Result<T, E>>>(mut iterator: Iter)\n+    -> Result<~[T], E> {\n+    let (lower, _) = iterator.size_hint();\n+    let mut vs: ~[T] = vec::with_capacity(lower);\n+    for t in iterator {\n+        match t {\n+            Ok(v) => vs.push(v),\n+            Err(u) => return Err(u)\n         }\n     }\n-    return Ok(vs);\n+    Ok(vs)\n }\n \n-// FIXME: #8228 Replaceable by an external iterator?\n-/// Same as map, but it operates over two parallel vectors.\n+/// Perform a fold operation over the result values from an iterator.\n ///\n-/// A precondition is used here to ensure that the vectors are the same\n-/// length.  While we do not often use preconditions in the standard\n-/// library, a precondition is used here because result::t is generally\n-/// used in 'careful' code contexts where it is both appropriate and easy\n-/// to accommodate an error like the vectors being of different lengths.\n+/// If an `Err` is encountered, it is immediately returned.\n+/// Otherwise, the folded value is returned.\n #[inline]\n-pub fn map_vec2<S, T, U: ToStr, V>(ss: &[S], ts: &[T],\n-                                   op: &fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n-    assert!(vec::same_length(ss, ts));\n-    let n = ts.len();\n-    let mut vs = vec::with_capacity(n);\n-    let mut i = 0u;\n-    while i < n {\n-        match op(&ss[i],&ts[i]) {\n-          Ok(v) => vs.push(v),\n-          Err(u) => return Err(u)\n+pub fn fold<T, V, E,\n+            Iter: Iterator<Result<T, E>>>(\n+            mut iterator: Iter,\n+            mut init: V,\n+            f: &fn(V, T) -> V)\n+         -> Result<V, E> {\n+    for t in iterator {\n+        match t {\n+            Ok(v) => init = f(init, v),\n+            Err(u) => return Err(u)\n         }\n-        i += 1u;\n     }\n-    return Ok(vs);\n+    Ok(init)\n }\n \n-// FIXME: #8228 Replaceable by an external iterator?\n-/// Applies op to the pairwise elements from `ss` and `ts`, aborting on\n-/// error.  This could be implemented using `map_zip()` but it is more efficient\n-/// on its own as no result vector is built.\n+/// Perform a trivial fold operation over the result values\n+/// from an iterator.\n+///\n+/// If an `Err` is encountered, it is immediately returned.\n+/// Otherwise, a simple `Ok(())` is returned.\n #[inline]\n-pub fn iter_vec2<S, T, U: ToStr>(ss: &[S], ts: &[T],\n-                                 op: &fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n-    assert!(vec::same_length(ss, ts));\n-    let n = ts.len();\n-    let mut i = 0u;\n-    while i < n {\n-        match op(&ss[i],&ts[i]) {\n-          Ok(()) => (),\n-          Err(u) => return Err(u)\n-        }\n-        i += 1u;\n-    }\n-    return Ok(());\n+pub fn fold_<T, E, Iter: Iterator<Result<T, E>>>(\n+             iterator: Iter)\n+          -> Result<(), E> {\n+    fold(iterator, (), |_, _| ())\n }\n \n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n \n     use either;\n+    use iterator::range;\n     use str::OwnedStr;\n+    use vec::ImmutableVector;\n \n     pub fn op1() -> Result<int, ~str> { Ok(666) }\n \n@@ -431,4 +420,44 @@ mod tests {\n         assert_eq!(r.to_either(), either::Right(100));\n         assert_eq!(err.to_either(), either::Left(404));\n     }\n+\n+    #[test]\n+    fn test_collect() {\n+        assert_eq!(collect(range(0, 0)\n+                           .map(|_| Ok::<int, ()>(0))),\n+                   Ok(~[]));\n+        assert_eq!(collect(range(0, 3)\n+                           .map(|x| Ok::<int, ()>(x))),\n+                   Ok(~[0, 1, 2]));\n+        assert_eq!(collect(range(0, 3)\n+                           .map(|x| if x > 1 { Err(x) } else { Ok(x) })),\n+                   Err(2));\n+\n+        // test that it does not take more elements than it needs\n+        let functions = [|| Ok(()), || Err(1), || fail!()];\n+\n+        assert_eq!(collect(functions.iter().map(|f| (*f)())),\n+                   Err(1));\n+    }\n+\n+    #[test]\n+    fn test_fold() {\n+        assert_eq!(fold_(range(0, 0)\n+                        .map(|_| Ok::<(), ()>(()))),\n+                   Ok(()));\n+        assert_eq!(fold(range(0, 3)\n+                        .map(|x| Ok::<int, ()>(x)),\n+                        0, |a, b| a + b),\n+                   Ok(3));\n+        assert_eq!(fold_(range(0, 3)\n+                        .map(|x| if x > 1 { Err(x) } else { Ok(()) })),\n+                   Err(2));\n+\n+        // test that it does not take more elements than it needs\n+        let functions = [|| Ok(()), || Err(1), || fail!()];\n+\n+        assert_eq!(fold_(functions.iter()\n+                        .map(|f| (*f)())),\n+                   Err(1));\n+    }\n }"}]}