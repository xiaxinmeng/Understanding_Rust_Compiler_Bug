{"sha": "cc5ecaf76589a83e40136e31d211246204767465", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNWVjYWY3NjU4OWE4M2U0MDEzNmUzMWQyMTEyNDYyMDQ3Njc0NjU=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-02T14:12:27Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-02T17:07:04Z"}, "message": "merge `*SliceExt` traits, use assoc types in `SliceExt`, `Raw[Mut]Ptr`", "tree": {"sha": "70c3ba43371986723515da2d87b6f415dcb402eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70c3ba43371986723515da2d87b6f415dcb402eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc5ecaf76589a83e40136e31d211246204767465", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc5ecaf76589a83e40136e31d211246204767465", "html_url": "https://github.com/rust-lang/rust/commit/cc5ecaf76589a83e40136e31d211246204767465", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc5ecaf76589a83e40136e31d211246204767465/comments", "author": null, "committer": null, "parents": [{"sha": "167683da230c9685d31b9e6155b18740f9fe858e", "url": "https://api.github.com/repos/rust-lang/rust/commits/167683da230c9685d31b9e6155b18740f9fe858e", "html_url": "https://github.com/rust-lang/rust/commit/167683da230c9685d31b9e6155b18740f9fe858e"}], "stats": {"total": 885, "additions": 440, "deletions": 445}, "files": [{"sha": "09cff4bc5ad51b518ea42947e943ad06edd56f77", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -25,6 +25,7 @@\n #![feature(macro_rules, default_type_params, phase, globs)]\n #![feature(unsafe_destructor, slicing_syntax)]\n #![feature(unboxed_closures)]\n+#![feature(associated_types)]\n #![no_std]\n \n #[phase(plugin, link)] extern crate core;\n@@ -120,7 +121,6 @@ mod prelude {\n     pub use core::result::Result::{Ok, Err};\n \n     // in core and collections (may differ).\n-    pub use slice::{PartialEqSliceExt, OrdSliceExt};\n     pub use slice::{AsSlice, SliceExt};\n     pub use str::{from_str, Str, StrExt};\n \n@@ -129,7 +129,7 @@ mod prelude {\n     pub use unicode::char::UnicodeChar;\n \n     // from collections.\n-    pub use slice::{CloneSliceExt, SliceConcatExt};\n+    pub use slice::SliceConcatExt;\n     pub use str::IntoMaybeOwned;\n     pub use string::{String, ToString};\n     pub use vec::Vec;"}, {"sha": "ac271e75ea1141ead2216788bfdd9cb1f8688433", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 261, "deletions": 238, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -96,15 +96,15 @@ use core::mem::size_of;\n use core::mem;\n use core::ops::{FnMut,SliceMut};\n use core::prelude::{Clone, Greater, Iterator, IteratorExt, Less, None, Option};\n-use core::prelude::{Ord, Ordering, PtrExt, Some, range, IteratorCloneExt, Result};\n+use core::prelude::{Ord, Ordering, PartialEq, PtrExt, Some, range, IteratorCloneExt, Result};\n use core::ptr;\n use core::slice as core_slice;\n use self::Direction::*;\n \n use vec::Vec;\n \n pub use core::slice::{Chunks, AsSlice, Windows};\n-pub use core::slice::{Iter, IterMut, PartialEqSliceExt};\n+pub use core::slice::{Iter, IterMut};\n pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n@@ -122,7 +122,9 @@ pub type MutItems<'a, T:'a> = IterMut<'a, T>;\n \n /// Allocating extension methods for slices.\n #[unstable = \"needs associated types, may merge with other traits\"]\n-pub trait SliceExt<T> for Sized? {\n+pub trait SliceExt for Sized? {\n+    type Item;\n+\n     /// Sorts the slice, in place, using `compare` to compare\n     /// elements.\n     ///\n@@ -141,7 +143,7 @@ pub trait SliceExt<T> for Sized? {\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n     #[stable]\n-    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering;\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n \n     /// Consumes `src` and moves as many elements as it can into `self`\n     /// from the range [start,end).\n@@ -165,7 +167,7 @@ pub trait SliceExt<T> for Sized? {\n     /// assert!(a == [6i, 7, 8, 4, 5]);\n     /// ```\n     #[experimental = \"uncertain about this API approach\"]\n-    fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n+    fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n \n     /// Returns a subslice spanning the interval [`start`, `end`).\n     ///\n@@ -174,23 +176,23 @@ pub trait SliceExt<T> for Sized? {\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice(&self, start: uint, end: uint) -> &[T];\n+    fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n \n     /// Returns a subslice from `start` to the end of the slice.\n     ///\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_from(&self, start: uint) -> &[T];\n+    fn slice_from(&self, start: uint) -> &[Self::Item];\n \n     /// Returns a subslice from the start of the slice to `end`.\n     ///\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_to(&self, end: uint) -> &[T];\n+    fn slice_to(&self, end: uint) -> &[Self::Item];\n \n     /// Divides one slice into two at an index.\n     ///\n@@ -200,32 +202,32 @@ pub trait SliceExt<T> for Sized? {\n     ///\n     /// Panics if `mid > len`.\n     #[stable]\n-    fn split_at(&self, mid: uint) -> (&[T], &[T]);\n+    fn split_at(&self, mid: uint) -> (&[Self::Item], &[Self::Item]);\n \n     /// Returns an iterator over the slice\n     #[stable]\n-    fn iter(&self) -> Iter<T>;\n+    fn iter(&self) -> Iter<Self::Item>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n     #[stable]\n-    fn split<F>(&self, pred: F) -> Split<T, F>\n-                where F: FnMut(&T) -> bool;\n+    fn split<F>(&self, pred: F) -> Split<Self::Item, F>\n+                where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[stable]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<T, F>\n-                 where F: FnMut(&T) -> bool;\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<Self::Item, F>\n+                 where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[stable]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<T, F>\n-                  where F: FnMut(&T) -> bool;\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<Self::Item, F>\n+                  where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over all contiguous windows of length\n     /// `size`. The windows overlap. If the slice is shorter than\n@@ -247,7 +249,7 @@ pub trait SliceExt<T> for Sized? {\n     /// }\n     /// ```\n     #[stable]\n-    fn windows(&self, size: uint) -> Windows<T>;\n+    fn windows(&self, size: uint) -> Windows<Self::Item>;\n \n     /// Returns an iterator over `size` elements of the slice at a\n     /// time. The chunks do not overlap. If `size` does not divide the\n@@ -270,41 +272,41 @@ pub trait SliceExt<T> for Sized? {\n     /// }\n     /// ```\n     #[stable]\n-    fn chunks(&self, size: uint) -> Chunks<T>;\n+    fn chunks(&self, size: uint) -> Chunks<Self::Item>;\n \n     /// Returns the element of a slice at the given index, or `None` if the\n     /// index is out of bounds.\n     #[stable]\n-    fn get(&self, index: uint) -> Option<&T>;\n+    fn get(&self, index: uint) -> Option<&Self::Item>;\n \n     /// Returns the first element of a slice, or `None` if it is empty.\n     #[stable]\n-    fn first(&self) -> Option<&T>;\n+    fn first(&self) -> Option<&Self::Item>;\n \n     /// Deprecated: renamed to `first`.\n     #[deprecated = \"renamed to `first`\"]\n-    fn head(&self) -> Option<&T> { self.first() }\n+    fn head(&self) -> Option<&Self::Item> { self.first() }\n \n     /// Returns all but the first element of a slice.\n     #[experimental = \"likely to be renamed\"]\n-    fn tail(&self) -> &[T];\n+    fn tail(&self) -> &[Self::Item];\n \n     /// Returns all but the last element of a slice.\n     #[experimental = \"likely to be renamed\"]\n-    fn init(&self) -> &[T];\n+    fn init(&self) -> &[Self::Item];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n     #[stable]\n-    fn last(&self) -> Option<&T>;\n+    fn last(&self) -> Option<&Self::Item>;\n \n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     #[stable]\n-    unsafe fn get_unchecked(&self, index: uint) -> &T;\n+    unsafe fn get_unchecked(&self, index: uint) -> &Self::Item;\n \n     /// Deprecated: renamed to `get_unchecked`.\n     #[deprecated = \"renamed to get_unchecked\"]\n-    unsafe fn unsafe_get(&self, index: uint) -> &T {\n+    unsafe fn unsafe_get(&self, index: uint) -> &Self::Item {\n         self.get_unchecked(index)\n     }\n \n@@ -316,7 +318,7 @@ pub trait SliceExt<T> for Sized? {\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n     #[stable]\n-    fn as_ptr(&self) -> *const T;\n+    fn as_ptr(&self) -> *const Self::Item;\n \n     /// Binary search a sorted slice with a comparator function.\n     ///\n@@ -352,7 +354,7 @@ pub trait SliceExt<T> for Sized? {\n     /// ```\n     #[stable]\n     fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n-        F: FnMut(&T) -> Ordering;\n+        F: FnMut(&Self::Item) -> Ordering;\n \n     /// Return the number of elements in the slice\n     ///\n@@ -379,12 +381,12 @@ pub trait SliceExt<T> for Sized? {\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n     #[stable]\n-    fn get_mut(&mut self, index: uint) -> Option<&mut T>;\n+    fn get_mut(&mut self, index: uint) -> Option<&mut Self::Item>;\n \n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T; N].\n     #[stable]\n-    fn as_mut_slice(&mut self) -> &mut [T];\n+    fn as_mut_slice(&mut self) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice spanning the interval [`start`, `end`).\n     ///\n@@ -393,70 +395,70 @@ pub trait SliceExt<T> for Sized? {\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T];\n+    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice from `start` to the end of the slice.\n     ///\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_from_mut(&mut self, start: uint) -> &mut [T];\n+    fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice from the start of the slice to `end`.\n     ///\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_to_mut(&mut self, end: uint) -> &mut [T];\n+    fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n     #[stable]\n-    fn iter_mut(&mut self) -> IterMut<T>;\n+    fn iter_mut(&mut self) -> IterMut<Self::Item>;\n \n     /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n     #[stable]\n-    fn first_mut(&mut self) -> Option<&mut T>;\n+    fn first_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Depreated: renamed to `first_mut`.\n     #[deprecated = \"renamed to first_mut\"]\n-    fn head_mut(&mut self) -> Option<&mut T> {\n+    fn head_mut(&mut self) -> Option<&mut Self::Item> {\n         self.first_mut()\n     }\n \n     /// Returns all but the first element of a mutable slice\n     #[experimental = \"likely to be renamed or removed\"]\n-    fn tail_mut(&mut self) -> &mut [T];\n+    fn tail_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns all but the last element of a mutable slice\n     #[experimental = \"likely to be renamed or removed\"]\n-    fn init_mut(&mut self) -> &mut [T];\n+    fn init_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns a mutable pointer to the last item in the slice.\n     #[stable]\n-    fn last_mut(&mut self) -> Option<&mut T>;\n+    fn last_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n     #[stable]\n-    fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n-                    where F: FnMut(&T) -> bool;\n+    fn split_mut<F>(&mut self, pred: F) -> SplitMut<Self::Item, F>\n+                    where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[stable]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<T, F>\n-                     where F: FnMut(&T) -> bool;\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<Self::Item, F>\n+                     where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[stable]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<T, F>\n-                      where F: FnMut(&T) -> bool;\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<Self::Item, F>\n+                      where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable and do not overlap. If `chunk_size` does\n@@ -467,7 +469,7 @@ pub trait SliceExt<T> for Sized? {\n     ///\n     /// Panics if `chunk_size` is 0.\n     #[stable]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<T>;\n+    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<Self::Item>;\n \n     /// Swaps two elements in a slice.\n     ///\n@@ -525,7 +527,7 @@ pub trait SliceExt<T> for Sized? {\n     /// }\n     /// ```\n     #[stable]\n-    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]);\n+    fn split_at_mut(&mut self, mid: uint) -> (&mut [Self::Item], &mut [Self::Item]);\n \n     /// Reverse the order of elements in a slice, in place.\n     ///\n@@ -541,11 +543,11 @@ pub trait SliceExt<T> for Sized? {\n \n     /// Returns an unsafe mutable pointer to the element in index\n     #[stable]\n-    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut T;\n+    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut Self::Item;\n \n     /// Deprecated: renamed to `get_unchecked_mut`.\n     #[deprecated = \"renamed to get_unchecked_mut\"]\n-    unsafe fn unchecked_mut(&mut self, index: uint) -> &mut T {\n+    unsafe fn unchecked_mut(&mut self, index: uint) -> &mut Self::Item {\n         self.get_unchecked_mut(index)\n     }\n \n@@ -558,11 +560,179 @@ pub trait SliceExt<T> for Sized? {\n     /// would also make any pointers to it invalid.\n     #[inline]\n     #[stable]\n-    fn as_mut_ptr(&mut self) -> *mut T;\n+    fn as_mut_ptr(&mut self) -> *mut Self::Item;\n+\n+    /// Copies `self` into a new `Vec`.\n+    #[stable]\n+    fn to_vec(&self) -> Vec<Self::Item> where Self::Item: Clone;\n+\n+    /// Deprecated: use `iter().cloned().partition(f)` instead.\n+    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n+    fn partitioned<F>(&self, f: F) -> (Vec<Self::Item>, Vec<Self::Item>) where\n+        Self::Item: Clone,\n+        F: FnMut(&Self::Item) -> bool;\n+\n+    /// Creates an iterator that yields every possible permutation of the\n+    /// vector in succession.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let v = [1i, 2, 3];\n+    /// let mut perms = v.permutations();\n+    ///\n+    /// for p in perms {\n+    ///   println!(\"{}\", p);\n+    /// }\n+    /// ```\n+    ///\n+    /// Iterating through permutations one by one.\n+    ///\n+    /// ```rust\n+    /// let v = [1i, 2, 3];\n+    /// let mut perms = v.permutations();\n+    ///\n+    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n+    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n+    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n+    /// ```\n+    #[unstable]\n+    fn permutations(&self) -> Permutations<Self::Item> where Self::Item: Clone;\n+\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut dst = [0i, 0, 0];\n+    /// let src = [1i, 2];\n+    ///\n+    /// assert!(dst.clone_from_slice(&src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n+    ///\n+    /// let src2 = [3i, 4, 5, 6];\n+    /// assert!(dst.clone_from_slice(&src2) == 3);\n+    /// assert!(dst == [3i, 4, 5]);\n+    /// ```\n+    #[experimental]\n+    fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n+\n+    /// Sorts the slice, in place.\n+    ///\n+    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut v = [-5i, 4, 1, -3, 2];\n+    ///\n+    /// v.sort();\n+    /// assert!(v == [-5i, -3, 1, 2, 4]);\n+    /// ```\n+    #[stable]\n+    fn sort(&mut self) where Self::Item: Ord;\n+\n+    /// Binary search a sorted slice for a given element.\n+    ///\n+    /// If the value is found then `Ok` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n+    ///\n+    /// ```rust\n+    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n+    ///\n+    /// assert_eq!(s.binary_search(&13),  Ok(9));\n+    /// assert_eq!(s.binary_search(&4),   Err(7));\n+    /// assert_eq!(s.binary_search(&100), Err(13));\n+    /// let r = s.binary_search(&1);\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n+    /// ```\n+    #[stable]\n+    fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n+\n+    /// Deprecated: use `binary_search` instead.\n+    #[deprecated = \"use binary_search instead\"]\n+    fn binary_search_elem(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord {\n+        self.binary_search(x)\n+    }\n+\n+    /// Mutates the slice to the next lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// last-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [0i, 1, 2];\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [1i, 0, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n+\n+    /// Mutates the slice to the previous lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// first-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [1i, 0, 2];\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 1, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n+\n+    /// Find the first index containing a matching value.\n+    #[experimental]\n+    fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+\n+    /// Find the last index containing a matching value.\n+    #[experimental]\n+    fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+\n+    /// Return true if the slice contains an element with the given value.\n+    #[stable]\n+    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n+\n+    /// Returns true if `needle` is a prefix of the slice.\n+    #[stable]\n+    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n+\n+    /// Returns true if `needle` is a suffix of the slice.\n+    #[stable]\n+    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n+\n+    /// Convert `self` into a vector without clones or allocation.\n+    #[experimental]\n+    fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<T> SliceExt<T> for [T] {\n+impl<T> SliceExt for [T] {\n+    type Item = T;\n+\n     #[inline]\n     fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n         merge_sort(self, compare)\n@@ -777,229 +947,82 @@ impl<T> SliceExt<T> for [T] {\n     fn as_mut_ptr(&mut self) -> *mut T {\n         core_slice::SliceExt::as_mut_ptr(self)\n     }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Extension traits for slices over specifc kinds of data\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Extension methods for boxed slices.\n-#[experimental = \"likely to merge into SliceExt if it survives\"]\n-pub trait BoxedSliceExt<T> {\n-    /// Convert `self` into a vector without clones or allocation.\n-    #[experimental]\n-    fn into_vec(self) -> Vec<T>;\n-}\n-\n-#[experimental = \"trait is experimental\"]\n-impl<T> BoxedSliceExt<T> for Box<[T]> {\n-    fn into_vec(mut self) -> Vec<T> {\n-        unsafe {\n-            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n-            mem::forget(self);\n-            xs\n-        }\n-    }\n-}\n-\n-/// Allocating extension methods for slices containing `Clone` elements.\n-#[unstable = \"likely to be merged into SliceExt\"]\n-pub trait CloneSliceExt<T> for Sized? {\n-    /// Copies `self` into a new `Vec`.\n-    #[stable]\n-    fn to_vec(&self) -> Vec<T>;\n-\n-    /// Deprecated: use `iter().cloned().partition(f)` instead.\n-    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n-    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool;\n-\n-    /// Creates an iterator that yields every possible permutation of the\n-    /// vector in succession.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n-    ///\n-    /// for p in perms {\n-    ///   println!(\"{}\", p);\n-    /// }\n-    /// ```\n-    ///\n-    /// Iterating through permutations one by one.\n-    ///\n-    /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n-    ///\n-    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n-    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n-    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n-    /// ```\n-    #[unstable]\n-    fn permutations(&self) -> Permutations<T>;\n-\n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut dst = [0i, 0, 0];\n-    /// let src = [1i, 2];\n-    ///\n-    /// assert!(dst.clone_from_slice(&src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n-    ///\n-    /// let src2 = [3i, 4, 5, 6];\n-    /// assert!(dst.clone_from_slice(&src2) == 3);\n-    /// assert!(dst == [3i, 4, 5]);\n-    /// ```\n-    #[experimental]\n-    fn clone_from_slice(&mut self, &[T]) -> uint;\n-}\n-\n \n-#[unstable = \"trait is unstable\"]\n-impl<T: Clone> CloneSliceExt<T> for [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n-    fn to_vec(&self) -> Vec<T> {\n+    fn to_vec(&self) -> Vec<T> where T: Clone {\n         let mut vector = Vec::with_capacity(self.len());\n         vector.push_all(self);\n         vector\n     }\n \n \n     #[inline]\n-    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool, T: Clone {\n         self.iter().cloned().partition(f)\n     }\n \n     /// Returns an iterator over all permutations of a vector.\n-    fn permutations(&self) -> Permutations<T> {\n+    fn permutations(&self) -> Permutations<T> where T: Clone {\n         Permutations{\n             swaps: ElementSwaps::new(self.len()),\n             v: self.to_vec(),\n         }\n     }\n \n-    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n-        core_slice::CloneSliceExt::clone_from_slice(self, src)\n+    fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n+        core_slice::SliceExt::clone_from_slice(self, src)\n     }\n-}\n \n-/// Allocating extension methods for slices on Ord values.\n-#[unstable = \"likely to merge with SliceExt\"]\n-pub trait OrdSliceExt<T> for Sized? {\n-    /// Sorts the slice, in place.\n-    ///\n-    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut v = [-5i, 4, 1, -3, 2];\n-    ///\n-    /// v.sort();\n-    /// assert!(v == [-5i, -3, 1, 2, 4]);\n-    /// ```\n-    #[stable]\n-    fn sort(&mut self);\n+    #[inline]\n+    fn sort(&mut self) where T: Ord {\n+        self.sort_by(|a, b| a.cmp(b))\n+    }\n \n-    /// Binary search a sorted slice for a given element.\n-    ///\n-    /// If the value is found then `Ok` is returned, containing the\n-    /// index of the matching element; if the value is not found then\n-    /// `Err` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Example\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n-    ///\n-    /// ```rust\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n-    ///\n-    /// assert_eq!(s.binary_search(&13),  Ok(9));\n-    /// assert_eq!(s.binary_search(&4),   Err(7));\n-    /// assert_eq!(s.binary_search(&100), Err(13));\n-    /// let r = s.binary_search(&1);\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n-    /// ```\n-    #[stable]\n-    fn binary_search(&self, x: &T) -> Result<uint, uint>;\n+    fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n+        core_slice::SliceExt::binary_search(self, x)\n+    }\n \n-    /// Deprecated: use `binary_search` instead.\n-    #[deprecated = \"use binary_search instead\"]\n-    fn binary_search_elem(&self, x: &T) -> Result<uint, uint> {\n-        self.binary_search(x)\n+    fn next_permutation(&mut self) -> bool where T: Ord {\n+        core_slice::SliceExt::next_permutation(self)\n     }\n \n-    /// Mutates the slice to the next lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// last-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [0i, 1, 2];\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [1i, 0, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n-    fn next_permutation(&mut self) -> bool;\n+    fn prev_permutation(&mut self) -> bool where T: Ord {\n+        core_slice::SliceExt::prev_permutation(self)\n+    }\n \n-    /// Mutates the slice to the previous lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// first-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [1i, 0, 2];\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 1, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n-    fn prev_permutation(&mut self) -> bool;\n-}\n+    fn position_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n+        core_slice::SliceExt::position_elem(self, t)\n+    }\n \n-#[unstable = \"trait is unstable\"]\n-impl<T: Ord> OrdSliceExt<T> for [T] {\n-    #[inline]\n-    fn sort(&mut self) {\n-        self.sort_by(|a, b| a.cmp(b))\n+    fn rposition_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n+        core_slice::SliceExt::rposition_elem(self, t)\n     }\n \n-    fn binary_search(&self, x: &T) -> Result<uint, uint> {\n-        core_slice::OrdSliceExt::binary_search(self, x)\n+    fn contains(&self, x: &T) -> bool where T: PartialEq {\n+        core_slice::SliceExt::contains(self, x)\n     }\n \n-    fn next_permutation(&mut self) -> bool {\n-        core_slice::OrdSliceExt::next_permutation(self)\n+    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+        core_slice::SliceExt::starts_with(self, needle)\n     }\n \n-    fn prev_permutation(&mut self) -> bool {\n-        core_slice::OrdSliceExt::prev_permutation(self)\n+    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+        core_slice::SliceExt::ends_with(self, needle)\n+    }\n+\n+    fn into_vec(mut self: Box<Self>) -> Vec<T> {\n+        unsafe {\n+            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n+            mem::forget(self);\n+            xs\n+        }\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Extension traits for slices over specifc kinds of data\n+////////////////////////////////////////////////////////////////////////////////\n #[unstable = \"U should be an associated type\"]\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<Sized? T, U> for Sized? {\n@@ -1419,7 +1442,7 @@ mod tests {\n     use std::boxed::Box;\n     use prelude::{Some, None, range, Vec, ToString, Clone, Greater, Less, Equal};\n     use prelude::{SliceExt, Iterator, IteratorExt, DoubleEndedIteratorExt};\n-    use prelude::{OrdSliceExt, CloneSliceExt, PartialEqSliceExt, AsSlice};\n+    use prelude::AsSlice;\n     use prelude::{RandomAccessIterator, Ord, SliceConcatExt};\n     use core::cell::Cell;\n     use core::default::Default;"}, {"sha": "b69db8b00b57a8953afba986ef4341bbaa646128", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -27,7 +27,6 @@ use core::raw::Slice as RawSlice;\n use unicode::str as unicode_str;\n use unicode::str::Utf16Item;\n \n-use slice::CloneSliceExt;\n use str::{mod, CharRange, FromStr, Utf8Error};\n use vec::{DerefVec, Vec, as_vec};\n \n@@ -94,7 +93,7 @@ impl String {\n     #[inline]\n     #[experimental = \"needs investigation to see if to_string() can match perf\"]\n     pub fn from_str(string: &str) -> String {\n-        String { vec: string.as_bytes().to_vec() }\n+        String { vec: ::slice::SliceExt::to_vec(string.as_bytes()) }\n     }\n \n     /// Returns the vector as a string buffer, if possible, taking care not to"}, {"sha": "ce0519a2395c2f79f86ed0c2c718fb0895ccd03b", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -63,8 +63,6 @@ use core::ptr;\n use core::raw::Slice as RawSlice;\n use core::uint;\n \n-use slice::CloneSliceExt;\n-\n /// A growable list type, written `Vec<T>` but pronounced 'vector.'\n ///\n /// # Examples\n@@ -1218,7 +1216,7 @@ unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n \n #[unstable]\n impl<T:Clone> Clone for Vec<T> {\n-    fn clone(&self) -> Vec<T> { self.as_slice().to_vec() }\n+    fn clone(&self) -> Vec<T> { ::slice::SliceExt::to_vec(self.as_slice()) }\n \n     fn clone_from(&mut self, other: &Vec<T>) {\n         // drop anything in self that will not be overwritten"}, {"sha": "19301cc2d9e32f69fcea76632c6d28acb3c173c9", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -64,5 +64,4 @@ pub use str::{Str, StrExt};\n pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n-pub use slice::{PartialEqSliceExt, OrdSliceExt};\n pub use slice::{AsSlice, SliceExt};"}, {"sha": "09c78d4bc2a4657a245f77d875d342083c0361d4", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -243,7 +243,9 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n \n /// Methods on raw pointers\n #[stable]\n-pub trait PtrExt<T> {\n+pub trait PtrExt {\n+    type Target;\n+\n     /// Returns the null pointer.\n     #[deprecated = \"call ptr::null instead\"]\n     fn null() -> Self;\n@@ -271,7 +273,7 @@ pub trait PtrExt<T> {\n     /// memory.\n     #[unstable = \"Option is not clearly the right return type, and we may want \\\n                   to tie the return lifetime to a borrow of the raw pointer\"]\n-    unsafe fn as_ref<'a>(&self) -> Option<&'a T>;\n+    unsafe fn as_ref<'a>(&self) -> Option<&'a Self::Target>;\n \n     /// Calculates the offset from a pointer. `count` is in units of T; e.g. a\n     /// `count` of 3 represents a pointer offset of `3 * sizeof::<T>()` bytes.\n@@ -287,7 +289,9 @@ pub trait PtrExt<T> {\n \n /// Methods on mutable raw pointers\n #[stable]\n-pub trait MutPtrExt<T>{\n+pub trait MutPtrExt {\n+    type Target;\n+\n     /// Returns `None` if the pointer is null, or else returns a mutable\n     /// reference to the value wrapped in `Some`.\n     ///\n@@ -297,11 +301,13 @@ pub trait MutPtrExt<T>{\n     /// of the returned pointer.\n     #[unstable = \"Option is not clearly the right return type, and we may want \\\n                   to tie the return lifetime to a borrow of the raw pointer\"]\n-    unsafe fn as_mut<'a>(&self) -> Option<&'a mut T>;\n+    unsafe fn as_mut<'a>(&self) -> Option<&'a mut Self::Target>;\n }\n \n #[stable]\n-impl<T> PtrExt<T> for *const T {\n+impl<T> PtrExt for *const T {\n+    type Target = T;\n+\n     #[inline]\n     #[deprecated = \"call ptr::null instead\"]\n     fn null() -> *const T { null() }\n@@ -333,7 +339,9 @@ impl<T> PtrExt<T> for *const T {\n }\n \n #[stable]\n-impl<T> PtrExt<T> for *mut T {\n+impl<T> PtrExt for *mut T {\n+    type Target = T;\n+\n     #[inline]\n     #[deprecated = \"call ptr::null instead\"]\n     fn null() -> *mut T { null_mut() }\n@@ -365,7 +373,9 @@ impl<T> PtrExt<T> for *mut T {\n }\n \n #[stable]\n-impl<T> MutPtrExt<T> for *mut T {\n+impl<T> MutPtrExt for *mut T {\n+    type Target = T;\n+\n     #[inline]\n     #[unstable = \"return value does not necessarily convey all possible \\\n                   information\"]"}, {"sha": "07addf7a56969cd75af39cf38ac68b9dd2698384", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 145, "deletions": 174, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -64,57 +64,77 @@ use raw::Slice as RawSlice;\n \n /// Extension methods for slices.\n #[allow(missing_docs)] // docs in libcollections\n-pub trait SliceExt<T> for Sized? {\n-    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T];\n-    fn slice_from<'a>(&'a self, start: uint) -> &'a [T];\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a [T];\n-    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]);\n-    fn iter<'a>(&'a self) -> Iter<'a, T>;\n-    fn split<'a, P>(&'a self, pred: P) -> Split<'a, T, P>\n-                    where P: FnMut(&T) -> bool;\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, T, P>\n-                     where P: FnMut(&T) -> bool;\n-    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> RSplitN<'a, T, P>\n-                      where P: FnMut(&T) -> bool;\n-    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T>;\n-    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T>;\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a T>;\n-    fn first<'a>(&'a self) -> Option<&'a T>;\n-    fn tail<'a>(&'a self) -> &'a [T];\n-    fn init<'a>(&'a self) -> &'a [T];\n-    fn last<'a>(&'a self) -> Option<&'a T>;\n-    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a T;\n-    fn as_ptr(&self) -> *const T;\n+pub trait SliceExt for Sized? {\n+    type Item;\n+\n+    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [Self::Item];\n+    fn slice_from<'a>(&'a self, start: uint) -> &'a [Self::Item];\n+    fn slice_to<'a>(&'a self, end: uint) -> &'a [Self::Item];\n+    fn split_at<'a>(&'a self, mid: uint) -> (&'a [Self::Item], &'a [Self::Item]);\n+    fn iter<'a>(&'a self) -> Iter<'a, Self::Item>;\n+    fn split<'a, P>(&'a self, pred: P) -> Split<'a, Self::Item, P>\n+                    where P: FnMut(&Self::Item) -> bool;\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, Self::Item, P>\n+                     where P: FnMut(&Self::Item) -> bool;\n+    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> RSplitN<'a, Self::Item, P>\n+                      where P: FnMut(&Self::Item) -> bool;\n+    fn windows<'a>(&'a self, size: uint) -> Windows<'a, Self::Item>;\n+    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, Self::Item>;\n+    fn get<'a>(&'a self, index: uint) -> Option<&'a Self::Item>;\n+    fn first<'a>(&'a self) -> Option<&'a Self::Item>;\n+    fn tail<'a>(&'a self) -> &'a [Self::Item];\n+    fn init<'a>(&'a self) -> &'a [Self::Item];\n+    fn last<'a>(&'a self) -> Option<&'a Self::Item>;\n+    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a Self::Item;\n+    fn as_ptr(&self) -> *const Self::Item;\n     fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n-        F: FnMut(&T) -> Ordering;\n+        F: FnMut(&Self::Item) -> Ordering;\n     fn len(&self) -> uint;\n     fn is_empty(&self) -> bool { self.len() == 0 }\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T>;\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T];\n-    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T];\n-    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T];\n-    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T];\n-    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T>;\n-    fn first_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n-    fn tail_mut<'a>(&'a mut self) -> &'a mut [T];\n-    fn init_mut<'a>(&'a mut self) -> &'a mut [T];\n-    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n-    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, T, P>\n-                        where P: FnMut(&T) -> bool;\n-    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitNMut<T, P>\n-                     where P: FnMut(&T) -> bool;\n-    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> RSplitNMut<T, P>\n-                      where P: FnMut(&T) -> bool;\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, T>;\n+    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut Self::Item>;\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [Self::Item];\n+    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [Self::Item];\n+    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [Self::Item];\n+    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [Self::Item];\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;\n+    fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n+    fn tail_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n+    fn init_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n+    fn last_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, Self::Item, P>\n+                        where P: FnMut(&Self::Item) -> bool;\n+    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitNMut<Self::Item, P>\n+                     where P: FnMut(&Self::Item) -> bool;\n+    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> RSplitNMut<Self::Item, P>\n+                      where P: FnMut(&Self::Item) -> bool;\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, Self::Item>;\n     fn swap(&mut self, a: uint, b: uint);\n-    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n+    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [Self::Item], &'a mut [Self::Item]);\n     fn reverse(&mut self);\n-    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut T;\n-    fn as_mut_ptr(&mut self) -> *mut T;\n+    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut Self::Item;\n+    fn as_mut_ptr(&mut self) -> *mut Self::Item;\n+\n+    fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+\n+    fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+\n+    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n+\n+    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n+\n+    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n+\n+    fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n+    fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n+    fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n+\n+    fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n }\n \n #[unstable]\n-impl<T> SliceExt<T> for [T] {\n+impl<T> SliceExt for [T] {\n+    type Item = T;\n+\n     #[inline]\n     fn slice(&self, start: uint, end: uint) -> &[T] {\n         assert!(start <= end);\n@@ -404,153 +424,41 @@ impl<T> SliceExt<T> for [T] {\n     fn as_mut_ptr(&mut self) -> *mut T {\n         self.repr().data as *mut T\n     }\n-}\n-\n-impl<T> ops::Index<uint, T> for [T] {\n-    fn index(&self, &index: &uint) -> &T {\n-        assert!(index < self.len());\n-\n-        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n-    }\n-}\n-\n-impl<T> ops::IndexMut<uint, T> for [T] {\n-    fn index_mut(&mut self, &index: &uint) -> &mut T {\n-        assert!(index < self.len());\n-\n-        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n-    }\n-}\n-\n-impl<T> ops::Slice<uint, [T]> for [T] {\n-    #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a [T] {\n-        self\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.slice_or_fail(start, &self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.slice_or_fail(&0, end)\n-    }\n-    #[inline]\n-    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n-                })\n-        }\n-    }\n-}\n-\n-impl<T> ops::SliceMut<uint, [T]> for [T] {\n-    #[inline]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n-        self\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        let len = &self.len();\n-        self.slice_or_fail_mut(start, len)\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.slice_or_fail_mut(&0, end)\n-    }\n-    #[inline]\n-    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n-                })\n-        }\n-    }\n-}\n-\n-/// Extension methods for slices containing `PartialEq` elements.\n-#[unstable = \"may merge with SliceExt\"]\n-pub trait PartialEqSliceExt<T: PartialEq> for Sized? {\n-    /// Find the first index containing a matching value.\n-    #[experimental]\n-    fn position_elem(&self, t: &T) -> Option<uint>;\n-\n-    /// Find the last index containing a matching value.\n-    #[experimental]\n-    fn rposition_elem(&self, t: &T) -> Option<uint>;\n-\n-    /// Return true if the slice contains an element with the given value.\n-    #[stable]\n-    fn contains(&self, x: &T) -> bool;\n-\n-    /// Returns true if `needle` is a prefix of the slice.\n-    #[stable]\n-    fn starts_with(&self, needle: &[T]) -> bool;\n-\n-    /// Returns true if `needle` is a suffix of the slice.\n-    #[stable]\n-    fn ends_with(&self, needle: &[T]) -> bool;\n-}\n \n-#[unstable = \"trait is unstable\"]\n-impl<T: PartialEq> PartialEqSliceExt<T> for [T] {\n     #[inline]\n-    fn position_elem(&self, x: &T) -> Option<uint> {\n+    fn position_elem(&self, x: &T) -> Option<uint> where T: PartialEq {\n         self.iter().position(|y| *x == *y)\n     }\n \n     #[inline]\n-    fn rposition_elem(&self, t: &T) -> Option<uint> {\n+    fn rposition_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n         self.iter().rposition(|x| *x == *t)\n     }\n \n     #[inline]\n-    fn contains(&self, x: &T) -> bool {\n+    fn contains(&self, x: &T) -> bool where T: PartialEq {\n         self.iter().any(|elt| *x == *elt)\n     }\n \n     #[inline]\n-    fn starts_with(&self, needle: &[T]) -> bool {\n+    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let n = needle.len();\n         self.len() >= n && needle == self[..n]\n     }\n \n     #[inline]\n-    fn ends_with(&self, needle: &[T]) -> bool {\n+    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let (m, n) = (self.len(), needle.len());\n         m >= n && needle == self[m-n..]\n     }\n-}\n \n-/// Extension methods for slices containing `Ord` elements.\n-#[unstable = \"may merge with other traits\"]\n-#[allow(missing_docs)] // docs in libcollections\n-pub trait OrdSliceExt<T: Ord> for Sized? {\n-    fn binary_search(&self, x: &T) -> Result<uint, uint>;\n-    fn next_permutation(&mut self) -> bool;\n-    fn prev_permutation(&mut self) -> bool;\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[unstable]\n-    fn binary_search(&self, x: &T) -> Result<uint, uint> {\n+    fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n     #[experimental]\n-    fn next_permutation(&mut self) -> bool {\n+    fn next_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n \n@@ -581,7 +489,7 @@ impl<T: Ord> OrdSliceExt<T> for [T] {\n     }\n \n     #[experimental]\n-    fn prev_permutation(&mut self) -> bool {\n+    fn prev_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n \n@@ -610,19 +518,9 @@ impl<T: Ord> OrdSliceExt<T> for [T] {\n \n         true\n     }\n-}\n \n-/// Extension methods for slices on Clone elements\n-#[unstable = \"may merge with other traits\"]\n-#[allow(missing_docs)] // docs in libcollections\n-pub trait CloneSliceExt<T> for Sized? {\n-    fn clone_from_slice(&mut self, &[T]) -> uint;\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T: Clone> CloneSliceExt<T> for [T] {\n     #[inline]\n-    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n+    fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n         let min = cmp::min(self.len(), src.len());\n         let dst = self.slice_to_mut(min);\n         let src = src.slice_to(min);\n@@ -633,6 +531,79 @@ impl<T: Clone> CloneSliceExt<T> for [T] {\n     }\n }\n \n+impl<T> ops::Index<uint, T> for [T] {\n+    fn index(&self, &index: &uint) -> &T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+    }\n+}\n+\n+impl<T> ops::IndexMut<uint, T> for [T] {\n+    fn index_mut(&mut self, &index: &uint) -> &mut T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+    }\n+}\n+\n+impl<T> ops::Slice<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_slice_<'a>(&'a self) -> &'a [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n+        self.slice_or_fail(start, &self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n+        self.slice_or_fail(&0, end)\n+    }\n+    #[inline]\n+    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+\n+impl<T> ops::SliceMut<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        let len = &self.len();\n+        self.slice_or_fail_mut(start, len)\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.slice_or_fail_mut(&0, end)\n+    }\n+    #[inline]\n+    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Common traits\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "a11a4408019c153663d0606715c162fc3657cb1e", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -539,7 +539,7 @@ pub unsafe fn from_c_multistring<F>(buf: *const libc::c_char,\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use prelude::{spawn, Some, None, Option, FnOnce, ToString, CloneSliceExt};\n+    use prelude::{spawn, Some, None, Option, FnOnce, ToString};\n     use prelude::{Clone, PtrExt, Iterator, SliceExt, StrExt};\n     use ptr;\n     use thread::Thread;"}, {"sha": "dda37765b4a66aef0c2159898295637123c831ba", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -14,7 +14,7 @@ use comm::{Sender, Receiver};\n use io;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n-use slice::{bytes, CloneSliceExt, SliceExt};\n+use slice::{bytes, SliceExt};\n use super::{Buffer, Reader, Writer, IoResult};\n use vec::Vec;\n "}, {"sha": "af5d1630ca6f99cbf9065e7741b6d54f8ed48df3", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -401,7 +401,7 @@ mod test {\n     extern crate \"test\" as test_crate;\n     use super::*;\n     use io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek};\n-    use prelude::{Ok, Err, range,  Vec, Buffer,  AsSlice, SliceExt, IteratorExt, CloneSliceExt};\n+    use prelude::{Ok, Err, range,  Vec, Buffer,  AsSlice, SliceExt, IteratorExt};\n     use io;\n     use self::test_crate::Bencher;\n "}, {"sha": "d01840b6da0fcc9a7f07e4cfc8cc4a48ac015f13", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -1919,7 +1919,7 @@ impl fmt::Show for FilePermission {\n mod tests {\n     use self::BadReaderBehavior::*;\n     use super::{IoResult, Reader, MemReader, NoProgress, InvalidInput, Writer};\n-    use prelude::{Ok, Vec, Buffer, CloneSliceExt};\n+    use prelude::{Ok, Vec, Buffer, SliceExt};\n     use uint;\n \n     #[deriving(Clone, PartialEq, Show)]"}, {"sha": "78d8ac307c28d1621d28efefae1987d617f795d0", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -25,7 +25,7 @@ use ops::FnOnce;\n use option::Option;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n-use slice::{CloneSliceExt, SliceExt};\n+use slice::SliceExt;\n use str::{FromStr, StrExt};\n use vec::Vec;\n "}, {"sha": "654096ce49d5e9406eae15c35bcb25050283e0b3", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -107,6 +107,7 @@\n #![feature(macro_rules, globs, linkage, thread_local, asm)]\n #![feature(default_type_params, phase, lang_items, unsafe_destructor)]\n #![feature(slicing_syntax, unboxed_closures)]\n+#![feature(associated_types)]\n \n // Don't link to std. We are std.\n #![no_std]"}, {"sha": "34693be39b39bf103c3b661b51b9dc00854fce8c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -317,9 +317,8 @@ macro_rules! try {\n #[macro_export]\n macro_rules! vec {\n     ($($x:expr),*) => ({\n-        use std::slice::BoxedSliceExt;\n         let xs: ::std::boxed::Box<[_]> = box [$($x),*];\n-        xs.into_vec()\n+        ::std::slice::SliceExt::into_vec(xs)\n     });\n     ($($x:expr,)*) => (vec![$($x),*])\n }"}, {"sha": "6c64251091a31d945ef7862928b433648bf7502c", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -20,7 +20,7 @@ use char::{mod, Char};\n use num::{mod, Int, Float, ToPrimitive};\n use num::FpCategory as Fp;\n use ops::FnMut;\n-use slice::{SliceExt, CloneSliceExt};\n+use slice::SliceExt;\n use str::StrExt;\n use string::String;\n use vec::Vec;"}, {"sha": "7aea83a069ad282ed9c0a02585f7187035b56f84", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -52,7 +52,6 @@ use ptr;\n use result::Result;\n use result::Result::{Err, Ok};\n use slice::{AsSlice, SliceExt};\n-use slice::CloneSliceExt;\n use str::{Str, StrExt};\n use string::{String, ToString};\n use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};"}, {"sha": "fae90e8d3938ceeaa13dc28f8dd12eeccc10b057", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -71,8 +71,7 @@ use option::Option::{None, Some};\n use str;\n use str::{CowString, MaybeOwned, Str, StrExt};\n use string::String;\n-use slice::{AsSlice, CloneSliceExt};\n-use slice::{PartialEqSliceExt, SliceExt};\n+use slice::{AsSlice, SliceExt};\n use vec::Vec;\n \n /// Typedef for POSIX file paths."}, {"sha": "8718d509f001c1670ed7048185c05ac12d07c7a4", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -22,8 +22,7 @@ use option::Option::{None, Some};\n use kinds::Sized;\n use str::{FromStr, Str};\n use str;\n-use slice::{CloneSliceExt, Split, AsSlice, SliceConcatExt,\n-            PartialEqSliceExt, SliceExt};\n+use slice::{Split, AsSlice, SliceConcatExt, SliceExt};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n@@ -449,7 +448,7 @@ static dot_dot_static: &'static [u8] = b\"..\";\n mod tests {\n     use super::*;\n     use prelude::Option::{mod, Some, None};\n-    use prelude::{Vec, Clone, AsSlice, SliceExt, CloneSliceExt, IteratorExt};\n+    use prelude::{Vec, Clone, AsSlice, SliceExt, IteratorExt};\n     use prelude::{DoubleEndedIteratorExt, Str, StrExt, ToString, GenericPath};\n     use str;\n "}, {"sha": "10f4adbfe560bd97f01c66df5662c65dc59e82fa", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -1121,7 +1121,7 @@ fn prefix_len(p: Option<PathPrefix>) -> uint {\n mod tests {\n     use super::*;\n     use prelude::Option::{mod, Some, None};\n-    use prelude::{Vec, Clone, AsSlice, SliceExt, CloneSliceExt, IteratorExt};\n+    use prelude::{Vec, Clone, AsSlice, SliceExt, IteratorExt};\n     use prelude::{DoubleEndedIteratorExt, Str, ToString, GenericPath};\n     use super::PathPrefix::*;\n     use super::parse_prefix;"}, {"sha": "95b82959562c1efff3404765f71a3582a4067e64", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5ecaf76589a83e40136e31d211246204767465/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=cc5ecaf76589a83e40136e31d211246204767465", "patch": "@@ -82,9 +82,7 @@\n #[doc(no_inline)] pub use core::prelude::{Tuple9, Tuple10, Tuple11, Tuple12};\n #[doc(no_inline)] pub use str::{Str, StrExt};\n #[doc(no_inline)] pub use slice::AsSlice;\n-#[doc(no_inline)] pub use slice::{SliceConcatExt, PartialEqSliceExt};\n-#[doc(no_inline)] pub use slice::{CloneSliceExt, OrdSliceExt, SliceExt};\n-#[doc(no_inline)] pub use slice::{BoxedSliceExt};\n+#[doc(no_inline)] pub use slice::{SliceConcatExt, SliceExt};\n #[doc(no_inline)] pub use string::{IntoString, String, ToString};\n #[doc(no_inline)] pub use vec::Vec;\n "}]}