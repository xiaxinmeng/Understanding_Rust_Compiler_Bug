{"sha": "816d765716f25b0008049d89a0e41f0a48d03c78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNmQ3NjU3MTZmMjViMDAwODA0OWQ4OWEwZTQxZjBhNDhkMDNjNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-20T02:00:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-20T02:00:13Z"}, "message": "Auto merge of #46919 - michaelwoerister:new-leb128, r=sfackler\n\nSpeed up leb128 encoding and decoding for unsigned values.\n\nMake the implementation for some leb128 functions potentially faster.\n\n@Mark-Simulacrum, could you please trigger a perf.rlo run?", "tree": {"sha": "545dd75c238acec892d50d555a989650a05fe11c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/545dd75c238acec892d50d555a989650a05fe11c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/816d765716f25b0008049d89a0e41f0a48d03c78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/816d765716f25b0008049d89a0e41f0a48d03c78", "html_url": "https://github.com/rust-lang/rust/commit/816d765716f25b0008049d89a0e41f0a48d03c78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/816d765716f25b0008049d89a0e41f0a48d03c78/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5965b790142eff7a8546e947914e7a8e00c61575", "url": "https://api.github.com/repos/rust-lang/rust/commits/5965b790142eff7a8546e947914e7a8e00c61575", "html_url": "https://github.com/rust-lang/rust/commit/5965b790142eff7a8546e947914e7a8e00c61575"}, {"sha": "53c2f447ffcbaab282764bff5dbd299ac34c3fc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/53c2f447ffcbaab282764bff5dbd299ac34c3fc1", "html_url": "https://github.com/rust-lang/rust/commit/53c2f447ffcbaab282764bff5dbd299ac34c3fc1"}], "stats": {"total": 225, "additions": 144, "deletions": 81}, "files": [{"sha": "1786e2960825dfb7b6340c8c8a84872fc2c21a2c", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 102, "deletions": 62, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/816d765716f25b0008049d89a0e41f0a48d03c78/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816d765716f25b0008049d89a0e41f0a48d03c78/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=816d765716f25b0008049d89a0e41f0a48d03c78", "patch": "@@ -9,64 +9,94 @@\n // except according to those terms.\n \n #[inline]\n-fn write_to_vec(vec: &mut Vec<u8>, position: usize, byte: u8) {\n+pub fn write_to_vec(vec: &mut Vec<u8>, position: usize, byte: u8) {\n     if position == vec.len() {\n         vec.push(byte);\n     } else {\n         vec[position] = byte;\n     }\n }\n \n-#[inline]\n-/// encodes an integer using unsigned leb128 encoding and stores\n-/// the result using a callback function.\n-///\n-/// The callback `write` is called once for each position\n-/// that is to be written to with the byte to be encoded\n-/// at that position.\n-pub fn write_unsigned_leb128_to<W>(mut value: u128, mut write: W) -> usize\n-    where W: FnMut(usize, u8)\n-{\n-    let mut position = 0;\n-    loop {\n-        let mut byte = (value & 0x7F) as u8;\n-        value >>= 7;\n-        if value != 0 {\n-            byte |= 0x80;\n-        }\n-\n-        write(position, byte);\n-        position += 1;\n+#[cfg(target_pointer_width = \"32\")]\n+const USIZE_LEB128_SIZE: usize = 5;\n+#[cfg(target_pointer_width = \"64\")]\n+const USIZE_LEB128_SIZE: usize = 10;\n+\n+macro_rules! leb128_size {\n+    (u16) => (3);\n+    (u32) => (5);\n+    (u64) => (10);\n+    (u128) => (19);\n+    (usize) => (USIZE_LEB128_SIZE);\n+}\n \n-        if value == 0 {\n-            break;\n+macro_rules! impl_write_unsigned_leb128 {\n+    ($fn_name:ident, $int_ty:ident) => (\n+        #[inline]\n+        pub fn $fn_name(out: &mut Vec<u8>, start_position: usize, mut value: $int_ty) -> usize {\n+            let mut position = start_position;\n+            for _ in 0 .. leb128_size!($int_ty) {\n+                let mut byte = (value & 0x7F) as u8;\n+                value >>= 7;\n+                if value != 0 {\n+                    byte |= 0x80;\n+                }\n+\n+                write_to_vec(out, position, byte);\n+                position += 1;\n+\n+                if value == 0 {\n+                    break;\n+                }\n+            }\n+\n+            position - start_position\n         }\n-    }\n-\n-    position\n+    )\n }\n \n-pub fn write_unsigned_leb128(out: &mut Vec<u8>, start_position: usize, value: u128) -> usize {\n-    write_unsigned_leb128_to(value, |i, v| write_to_vec(out, start_position+i, v))\n+impl_write_unsigned_leb128!(write_u16_leb128, u16);\n+impl_write_unsigned_leb128!(write_u32_leb128, u32);\n+impl_write_unsigned_leb128!(write_u64_leb128, u64);\n+impl_write_unsigned_leb128!(write_u128_leb128, u128);\n+impl_write_unsigned_leb128!(write_usize_leb128, usize);\n+\n+\n+macro_rules! impl_read_unsigned_leb128 {\n+    ($fn_name:ident, $int_ty:ident) => (\n+        #[inline]\n+        pub fn $fn_name(slice: &[u8]) -> ($int_ty, usize) {\n+            let mut result: $int_ty = 0;\n+            let mut shift = 0;\n+            let mut position = 0;\n+\n+            for _ in 0 .. leb128_size!($int_ty) {\n+                let byte = unsafe {\n+                    *slice.get_unchecked(position)\n+                };\n+                position += 1;\n+                result |= ((byte & 0x7F) as $int_ty) << shift;\n+                if (byte & 0x80) == 0 {\n+                    break;\n+                }\n+                shift += 7;\n+            }\n+\n+            // Do a single bounds check at the end instead of for every byte.\n+            assert!(position <= slice.len());\n+\n+            (result, position)\n+        }\n+    )\n }\n \n-#[inline]\n-pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u128, usize) {\n-    let mut result = 0;\n-    let mut shift = 0;\n-    let mut position = start_position;\n-    loop {\n-        let byte = data[position];\n-        position += 1;\n-        result |= ((byte & 0x7F) as u128) << shift;\n-        if (byte & 0x80) == 0 {\n-            break;\n-        }\n-        shift += 7;\n-    }\n+impl_read_unsigned_leb128!(read_u16_leb128, u16);\n+impl_read_unsigned_leb128!(read_u32_leb128, u32);\n+impl_read_unsigned_leb128!(read_u64_leb128, u64);\n+impl_read_unsigned_leb128!(read_u128_leb128, u128);\n+impl_read_unsigned_leb128!(read_usize_leb128, usize);\n+\n \n-    (result, position - start_position)\n-}\n \n #[inline]\n /// encodes an integer using signed leb128 encoding and stores\n@@ -130,26 +160,36 @@ pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i128, usize) {\n     (result, position - start_position)\n }\n \n-#[test]\n-fn test_unsigned_leb128() {\n-    let mut stream = Vec::with_capacity(10000);\n-\n-    for x in 0..62 {\n-        let pos = stream.len();\n-        let bytes_written = write_unsigned_leb128(&mut stream, pos, 3 << x);\n-        assert_eq!(stream.len(), pos + bytes_written);\n-    }\n-\n-    let mut position = 0;\n-    for x in 0..62 {\n-        let expected = 3 << x;\n-        let (actual, bytes_read) = read_unsigned_leb128(&stream, position);\n-        assert_eq!(expected, actual);\n-        position += bytes_read;\n-    }\n-    assert_eq!(stream.len(), position);\n+macro_rules! impl_test_unsigned_leb128 {\n+    ($test_name:ident, $write_fn_name:ident, $read_fn_name:ident, $int_ty:ident) => (\n+        #[test]\n+        fn $test_name() {\n+            let mut stream = Vec::new();\n+\n+            for x in 0..62 {\n+                let pos = stream.len();\n+                let bytes_written = $write_fn_name(&mut stream, pos, (3u64 << x) as $int_ty);\n+                assert_eq!(stream.len(), pos + bytes_written);\n+            }\n+\n+            let mut position = 0;\n+            for x in 0..62 {\n+                let expected = (3u64 << x) as $int_ty;\n+                let (actual, bytes_read) = $read_fn_name(&stream[position ..]);\n+                assert_eq!(expected, actual);\n+                position += bytes_read;\n+            }\n+            assert_eq!(stream.len(), position);\n+        }\n+    )\n }\n \n+impl_test_unsigned_leb128!(test_u16_leb128, write_u16_leb128, read_u16_leb128, u16);\n+impl_test_unsigned_leb128!(test_u32_leb128, write_u32_leb128, read_u32_leb128, u32);\n+impl_test_unsigned_leb128!(test_u64_leb128, write_u64_leb128, read_u64_leb128, u64);\n+impl_test_unsigned_leb128!(test_u128_leb128, write_u128_leb128, read_u128_leb128, u128);\n+impl_test_unsigned_leb128!(test_usize_leb128, write_usize_leb128, read_usize_leb128, usize);\n+\n #[test]\n fn test_signed_leb128() {\n     let values: Vec<_> = (-500..500).map(|i| i * 0x12345789ABCDEF).collect();"}, {"sha": "077efadd60af88823876634ce0524ee0311f060a", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/816d765716f25b0008049d89a0e41f0a48d03c78/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816d765716f25b0008049d89a0e41f0a48d03c78/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=816d765716f25b0008049d89a0e41f0a48d03c78", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use leb128::{read_signed_leb128, read_unsigned_leb128, write_signed_leb128, write_unsigned_leb128};\n+use leb128::{self, read_signed_leb128, write_signed_leb128};\n use std::borrow::Cow;\n use std::io::{self, Write};\n use serialize;\n@@ -35,9 +35,9 @@ impl<'a> Encoder<'a> {\n \n \n macro_rules! write_uleb128 {\n-    ($enc:expr, $value:expr) => {{\n+    ($enc:expr, $value:expr, $fun:ident) => {{\n         let pos = $enc.cursor.position() as usize;\n-        let bytes_written = write_unsigned_leb128($enc.cursor.get_mut(), pos, $value as u128);\n+        let bytes_written = leb128::$fun($enc.cursor.get_mut(), pos, $value);\n         $enc.cursor.set_position((pos + bytes_written) as u64);\n         Ok(())\n     }}\n@@ -55,61 +55,76 @@ macro_rules! write_sleb128 {\n impl<'a> serialize::Encoder for Encoder<'a> {\n     type Error = io::Error;\n \n+    #[inline]\n     fn emit_nil(&mut self) -> EncodeResult {\n         Ok(())\n     }\n \n+    #[inline]\n     fn emit_usize(&mut self, v: usize) -> EncodeResult {\n-        write_uleb128!(self, v)\n+        write_uleb128!(self, v, write_usize_leb128)\n     }\n \n+    #[inline]\n     fn emit_u128(&mut self, v: u128) -> EncodeResult {\n-        write_uleb128!(self, v)\n+        write_uleb128!(self, v, write_u128_leb128)\n     }\n \n+    #[inline]\n     fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-        write_uleb128!(self, v)\n+        write_uleb128!(self, v, write_u64_leb128)\n     }\n \n+    #[inline]\n     fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-        write_uleb128!(self, v)\n+        write_uleb128!(self, v, write_u32_leb128)\n     }\n \n+    #[inline]\n     fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-        write_uleb128!(self, v)\n+        write_uleb128!(self, v, write_u16_leb128)\n     }\n \n+    #[inline]\n     fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-        let _ = self.cursor.write_all(&[v]);\n+        let pos = self.cursor.position() as usize;\n+        leb128::write_to_vec(self.cursor.get_mut(), pos, v);\n+        self.cursor.set_position((pos + 1) as u64);\n         Ok(())\n     }\n \n+    #[inline]\n     fn emit_isize(&mut self, v: isize) -> EncodeResult {\n         write_sleb128!(self, v)\n     }\n \n+    #[inline]\n     fn emit_i128(&mut self, v: i128) -> EncodeResult {\n         write_sleb128!(self, v)\n     }\n \n+    #[inline]\n     fn emit_i64(&mut self, v: i64) -> EncodeResult {\n         write_sleb128!(self, v)\n     }\n \n+    #[inline]\n     fn emit_i32(&mut self, v: i32) -> EncodeResult {\n         write_sleb128!(self, v)\n     }\n \n+    #[inline]\n     fn emit_i16(&mut self, v: i16) -> EncodeResult {\n         write_sleb128!(self, v)\n     }\n \n+    #[inline]\n     fn emit_i8(&mut self, v: i8) -> EncodeResult {\n         let as_u8: u8 = unsafe { ::std::mem::transmute(v) };\n-        let _ = self.cursor.write_all(&[as_u8]);\n-        Ok(())\n+        self.emit_u8(as_u8)\n     }\n \n+    #[inline]\n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n         self.emit_u8(if v {\n             1\n@@ -118,20 +133,24 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         })\n     }\n \n+    #[inline]\n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n         let as_u64: u64 = unsafe { ::std::mem::transmute(v) };\n         self.emit_u64(as_u64)\n     }\n \n+    #[inline]\n     fn emit_f32(&mut self, v: f32) -> EncodeResult {\n         let as_u32: u32 = unsafe { ::std::mem::transmute(v) };\n         self.emit_u32(as_u32)\n     }\n \n+    #[inline]\n     fn emit_char(&mut self, v: char) -> EncodeResult {\n         self.emit_u32(v as u32)\n     }\n \n+    #[inline]\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n         self.emit_usize(v.len())?;\n         let _ = self.cursor.write_all(v.as_bytes());\n@@ -140,6 +159,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n }\n \n impl<'a> Encoder<'a> {\n+    #[inline]\n     pub fn position(&self) -> usize {\n         self.cursor.position() as usize\n     }\n@@ -162,14 +182,17 @@ impl<'a> Decoder<'a> {\n         }\n     }\n \n+    #[inline]\n     pub fn position(&self) -> usize {\n         self.position\n     }\n \n+    #[inline]\n     pub fn set_position(&mut self, pos: usize) {\n         self.position = pos\n     }\n \n+    #[inline]\n     pub fn advance(&mut self, bytes: usize) {\n         self.position += bytes;\n     }\n@@ -187,10 +210,10 @@ impl<'a> Decoder<'a> {\n }\n \n macro_rules! read_uleb128 {\n-    ($dec:expr, $t:ty) => ({\n-        let (value, bytes_read) = read_unsigned_leb128($dec.data, $dec.position);\n+    ($dec:expr, $t:ty, $fun:ident) => ({\n+        let (value, bytes_read) = leb128::$fun(&$dec.data[$dec.position ..]);\n         $dec.position += bytes_read;\n-        Ok(value as $t)\n+        Ok(value)\n     })\n }\n \n@@ -213,22 +236,22 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n \n     #[inline]\n     fn read_u128(&mut self) -> Result<u128, Self::Error> {\n-        read_uleb128!(self, u128)\n+        read_uleb128!(self, u128, read_u128_leb128)\n     }\n \n     #[inline]\n     fn read_u64(&mut self) -> Result<u64, Self::Error> {\n-        read_uleb128!(self, u64)\n+        read_uleb128!(self, u64, read_u64_leb128)\n     }\n \n     #[inline]\n     fn read_u32(&mut self) -> Result<u32, Self::Error> {\n-        read_uleb128!(self, u32)\n+        read_uleb128!(self, u32, read_u32_leb128)\n     }\n \n     #[inline]\n     fn read_u16(&mut self) -> Result<u16, Self::Error> {\n-        read_uleb128!(self, u16)\n+        read_uleb128!(self, u16, read_u16_leb128)\n     }\n \n     #[inline]\n@@ -240,7 +263,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n \n     #[inline]\n     fn read_usize(&mut self) -> Result<usize, Self::Error> {\n-        read_uleb128!(self, usize)\n+        read_uleb128!(self, usize, read_usize_leb128)\n     }\n \n     #[inline]"}]}