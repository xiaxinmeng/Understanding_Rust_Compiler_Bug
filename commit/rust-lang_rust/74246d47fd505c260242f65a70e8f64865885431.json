{"sha": "74246d47fd505c260242f65a70e8f64865885431", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MjQ2ZDQ3ZmQ1MDVjMjYwMjQyZjY1YTcwZThmNjQ4NjU4ODU0MzE=", "commit": {"author": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-05T02:35:03Z"}, "committer": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-05T02:35:03Z"}, "message": "Finish up tests, uncomment when ICE is fixed.", "tree": {"sha": "959512f7f0c9311eadaf4e0b13d0a8ea9ea17b6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/959512f7f0c9311eadaf4e0b13d0a8ea9ea17b6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74246d47fd505c260242f65a70e8f64865885431", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74246d47fd505c260242f65a70e8f64865885431", "html_url": "https://github.com/rust-lang/rust/commit/74246d47fd505c260242f65a70e8f64865885431", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74246d47fd505c260242f65a70e8f64865885431/comments", "author": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "committer": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bd48b92d951a72c40e472a14c6c83d733be1282", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bd48b92d951a72c40e472a14c6c83d733be1282", "html_url": "https://github.com/rust-lang/rust/commit/7bd48b92d951a72c40e472a14c6c83d733be1282"}], "stats": {"total": 164, "additions": 146, "deletions": 18}, "files": [{"sha": "a8fe79161019c0add4342bda5d44f78f4d5e118b", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 146, "deletions": 18, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/74246d47fd505c260242f65a70e8f64865885431/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74246d47fd505c260242f65a70e8f64865885431/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=74246d47fd505c260242f65a70e8f64865885431", "patch": "@@ -1045,27 +1045,34 @@ mod test_tim_sort {\n     }\n }\n \n+/*fn f<T: Ord>(array: &[mut T]) { array[0] <-> array[0] }\n+\n+fn ice_test() {\n+    let _s1 = &fn(arr: &[mut ~float]) { tim_sort(arr); };\n+}*/\n+\n //#[cfg(test)]\n-/*mod big_tests {\n+mod big_tests {\n \n-    #[test]\n+    //#[test]\n     fn sorts_test() {\n         let low = 5;\n         let high = 10;\n \n         //pure fn le(a: &~float, b: &~float) -> bool { *a <= *b }\n \n-        //let sorts = ~[\n-            //let s1 = fn(arr: &[mut ~float]) { tim_sort(arr); };\n-            //let s2 = fn(arr: &[mut ~float]) { quick_sort(arr, le); };\n-            //let s3 = fn(arr: &[mut ~float]) { quick_sort3(arr); };\n-            //let s4 = fn(arr: &[mut ~float]) { let rs = merge_sort(arr, le);\n-             //                        for rs.eachi |i, v| {arr[i] = *v}};\n-        //];\n-\n-        tabulate_unique(low, high);\n-        //tabulate_managed(low, high, tim_sort);\n-        //tabulate_linear(low, high, tim_sort);\n+        //let s1 = fn(arr: &[mut ~float]) { tim_sort(arr); };\n+        //let s2 = fn(arr: &[mut ~float]) { quick_sort(arr, le); };\n+        //let s3 = fn(arr: &[mut ~float]) { quick_sort3(arr); };\n+        //let s4 = fn(arr: &[mut ~float]) { let rs = merge_sort(arr, le);\n+        //                        for rs.eachi |i, v| {arr[i] = *v}};\n+\n+\n+        // Run tabulate_unique and tabulate_managed\n+        // with the other sorts at some point\n+        //tabulate_unique(low, high);\n+        //tabulate_managed(low, high);\n+        //tabulate_linear(low, high);\n     }\n \n     fn multiplyVec<T: Copy>(arr: &[const T], num: uint) -> ~[mut T] {\n@@ -1083,7 +1090,7 @@ mod test_tim_sort {\n         vec::append(two, one)\n     }\n \n-    fn tabulate_unique(lo: uint, hi: uint) {\n+    /*fn tabulate_unique(lo: uint, hi: uint) {\n         fn isSorted<T: Ord>(arr: &[const T]) {\n             for uint::range(0, arr.len()-1) |i| {\n                 if arr[i] > arr[i+1] {\n@@ -1153,16 +1160,137 @@ mod test_tim_sort {\n             tim_sort(arr); // !sort\n             isSorted(arr);\n         }\n-    }\n+    }*/\n+\n+    /*fn tabulate_managed(lo: uint, hi: uint) {\n+        fn isSorted<T: Ord>(arr: &[const @T], expected_refcount: uint) {\n+            for uint::range(0, arr.len()-1) |i| {\n+                if arr[i] > arr[i+1] {\n+                    fail ~\"Array not sorted\";\n+                }\n+                assert sys::refcount(arr[i]) == expected_refcount;\n+            }\n+        }\n+\n+        let rng = rand::Rng();\n+\n+        for uint::range(lo, hi) |i| {\n+            let n = 1 << i;\n+            let arr = do vec::from_fn(n) |_i| {\n+                @rng.gen_float()\n+            };\n+            let arr = vec::to_mut(arr);\n \n-    fn tabulate_managed(lo: uint, hi: uint, sort: fn(x: &[mut ~float])) {\n+            tim_sort(arr); // *sort\n+            isSorted(arr, 1);\n+\n+            vec::reverse(arr);\n+            tim_sort(arr); // \\sort\n+            isSorted(arr, 1);\n+\n+            tim_sort(arr); // /sort\n+            isSorted(arr, 1);\n+\n+            for 3.times {\n+                let i1 = rng.gen_uint_range(0, n);\n+                let i2 = rng.gen_uint_range(0, n);\n+                arr[i1] <-> arr[i2];\n+            }\n+            tim_sort(arr); // 3sort\n+            isSorted(arr, 1);\n+\n+            if n >= 10 {\n+                let size = arr.len();\n+                let mut idx = 1;\n+                while idx <= 10 {\n+                    arr[size-idx] = @rng.gen_float();\n+                    idx += 1;\n+                }\n+            }\n+            tim_sort(arr); // +sort\n+            isSorted(arr, 1);\n \n+            for (n/100).times {\n+                let idx = rng.gen_uint_range(0, n);\n+                arr[idx] = @rng.gen_float();\n+            }\n+            tim_sort(arr);\n+            isSorted(arr, 1);\n+\n+            let arr = if n > 4 {\n+                let part = vec::view(arr, 0, 4);\n+                multiplyVec(part, n)\n+            } else { arr };\n+            tim_sort(arr); // ~sort\n+            isSorted(arr, n/4+1);\n+\n+            let mut arr = vec::from_elem(n, @(-0.5));\n+            tim_sort(arr); // =sort\n+            isSorted(arr, n);\n+\n+            let half = n / 2;\n+            let mut arr = makeRange(half).map(|i| @(*i as float));\n+            tim_sort(arr); // !sort\n+            isSorted(arr, 2);\n+        }\n+    }\n+*/\n+/*\n+    struct LVal {\n+        val: uint,\n+        key: fn(@uint),\n+\n+        drop {\n+            let x = unsafe { task::local_data::local_data_get(self.key) };\n+            match x {\n+                Some(@y) => {\n+                    unsafe {\n+                        task::local_data::local_data_set(self.key, @(y+1));\n+                    }\n+                }\n+                _ => fail ~\"Expected key to work\",\n+            }\n+        }\n     }\n \n-    fn tabulate_linear(lo: uint, hi: uint, sort: fn(x: &[mut ~float])) {\n+    impl LVal: Ord {\n+        pure fn lt(other: &LVal) -> bool { self.val < other.val }\n+        pure fn le(other: &LVal) -> bool { self.val <= other.val }\n+        pure fn gt(other: &LVal) -> bool { self.val > other.val }\n+        pure fn ge(other: &LVal) -> bool { self.val >= other.val }\n+    }\n \n+    fn tabulate_linear(lo: uint, hi: uint) {\n+        fn key(+_x: @uint) { }\n+        fn isSorted<T: Ord>(arr: &[const T]) {\n+            for uint::range(0, arr.len()-1) |i| {\n+                if arr[i] > arr[i+1] {\n+                    fail ~\"Array not sorted\";\n+                }\n+            }\n+        }\n+\n+        let n = 1000;\n+        unsafe {\n+            task::local_data::local_data_set(key, @0u);\n+        }\n+\n+        {\n+            let mut arr = do vec::from_fn(n) |i| {\n+                LVal { val: i, key: key }\n+            };\n+            //tim_sort(arr);\n+            isSorted(arr);\n+        }\n+\n+        let @dropped = unsafe {\n+            task::local_data::local_data_get(key).get()\n+        };\n+\n+        assert n == dropped;\n     }\n-}*/\n+    */\n+}\n \n // Local Variables:\n // mode: rust;"}]}