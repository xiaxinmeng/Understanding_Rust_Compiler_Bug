{"sha": "82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyYjI0NTU5ZTZhYTA5MTRmOGE0OWUwYTlkYmZiM2NmMzUzNzI1MTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-01T19:52:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-01T19:52:29Z"}, "message": "auto merge of #8190 : thestinger/rust/for, r=thestinger", "tree": {"sha": "c2b0ff9b26400eac3f3405d78fe89dc07607c3ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2b0ff9b26400eac3f3405d78fe89dc07607c3ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "html_url": "https://github.com/rust-lang/rust/commit/82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "479809a267dbbcc3e2ec87da677c63430d3d229a", "url": "https://api.github.com/repos/rust-lang/rust/commits/479809a267dbbcc3e2ec87da677c63430d3d229a", "html_url": "https://github.com/rust-lang/rust/commit/479809a267dbbcc3e2ec87da677c63430d3d229a"}, {"sha": "94f1a5d6f8ecd30c6f59dfeaacdd5962f58bc44c", "url": "https://api.github.com/repos/rust-lang/rust/commits/94f1a5d6f8ecd30c6f59dfeaacdd5962f58bc44c", "html_url": "https://github.com/rust-lang/rust/commit/94f1a5d6f8ecd30c6f59dfeaacdd5962f58bc44c"}], "stats": {"total": 1059, "additions": 560, "deletions": 499}, "files": [{"sha": "08989be871be07a6267224046ee3be821f8f587b", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -548,7 +548,7 @@ an intermediate generation has already exited:\n ~~~\n # use std::task;\n # fn sleep_forever() { loop { task::yield() } }\n-# fn wait_for_a_while() { for 1000.times { task::yield() } }\n+# fn wait_for_a_while() { do 1000.times { task::yield() } }\n # do task::try::<int> {\n do task::spawn_supervised {\n     do task::spawn_supervised {\n@@ -567,7 +567,7 @@ other at all, using `task::spawn_unlinked` for _isolated failure_.\n ~~~\n # use std::task;\n # fn random() -> uint { 100 }\n-# fn sleep_for(i: uint) { for i.times { task::yield() } }\n+# fn sleep_for(i: uint) { do i.times { task::yield() } }\n # do task::try::<()> {\n let (time1, time2) = (random(), random());\n do task::spawn_unlinked {"}, {"sha": "c9f1dfcd5a390707c1c0dd28826a5b809097c304", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -1899,7 +1899,7 @@ struct TimeBomb {\n \n impl Drop for TimeBomb {\n     fn drop(&self) {\n-        for self.explosivity.times {\n+        do self.explosivity.times {\n             println(\"blam!\");\n         }\n     }"}, {"sha": "f235a3d2db31d719e58ec1ffd59d5f410ecceebc", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -23,7 +23,7 @@\n  * let numbers=vec::from_fn(100, |ind| (ind as float)*rand::random());\n  * let shared_numbers=arc::Arc::new(numbers);\n  *\n- *   for 10.times {\n+ *   do 10.times {\n  *       let (port, chan)  = stream();\n  *       chan.send(shared_numbers.clone());\n  *\n@@ -761,7 +761,7 @@ mod tests {\n \n         do task::spawn || {\n             do arc2.write |num| {\n-                for 10.times {\n+                do 10.times {\n                     let tmp = *num;\n                     *num = -1;\n                     task::yield();\n@@ -773,7 +773,7 @@ mod tests {\n \n         // Readers try to catch the writer in the act\n         let mut children = ~[];\n-        for 5.times {\n+        do 5.times {\n             let arc3 = (*arc).clone();\n             let mut builder = task::task();\n             builder.future_result(|r| children.push(r));\n@@ -807,7 +807,7 @@ mod tests {\n \n         // Reader tasks\n         let mut reader_convos = ~[];\n-        for 10.times {\n+        do 10.times {\n             let ((rp1,rc1),(rp2,rc2)) = (comm::stream(),comm::stream());\n             reader_convos.push((rc1, rp2));\n             let arcn = (*arc).clone();\n@@ -921,7 +921,7 @@ mod tests {\n             do read_mode.read |state| {\n                 // if writer mistakenly got in, make sure it mutates state\n                 // before we assert on it\n-                for 5.times { task::yield(); }\n+                do 5.times { task::yield(); }\n                 // make sure writer didn't get in.\n                 assert!(*state);\n             }\n@@ -933,6 +933,6 @@ mod tests {\n         // helped to expose the race nearly 100% of the time... but adding\n         // yields in the intuitively-right locations made it even less likely,\n         // and I wasn't sure why :( . This is a mediocre \"next best\" option.\n-        for 8.times { test_rw_write_cond_downgrade_read_race_helper() }\n+        do 8.times { test_rw_write_cond_downgrade_read_race_helper() }\n     }\n }"}, {"sha": "31acb5bd498739cb48889d6c243fec36e9bd83ba", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -72,11 +72,12 @@ impl Drop for Arena {\n     fn drop(&self) {\n         unsafe {\n             destroy_chunk(&self.head);\n-            for self.chunks.each |chunk| {\n+            do self.chunks.each |chunk| {\n                 if !chunk.is_pod {\n                     destroy_chunk(chunk);\n                 }\n-            }\n+                true\n+            };\n         }\n     }\n }"}, {"sha": "5d5311d232922a712777c39869ef97fa032d3cf4", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -358,9 +358,9 @@ mod test {\n         use std::rand::{task_rng, random, RngUtil};\n         use std::vec;\n \n-        for 1000.times {\n+        do 1000.times {\n             let v: ~[u8] = do vec::build |push| {\n-                for task_rng().gen_uint_range(1, 100).times {\n+                do task_rng().gen_uint_range(1, 100).times {\n                     push(random());\n                 }\n             };\n@@ -389,4 +389,4 @@ mod test {\n         bh.bytes = b.len() as u64;\n     }\n \n-}\n\\ No newline at end of file\n+}"}, {"sha": "570186b65a620b0c7daa205c55ab1c2aea6df3e2", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 109, "deletions": 82, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -12,7 +12,8 @@\n \n \n use std::cmp;\n-use std::iterator::{DoubleEndedIterator, RandomAccessIterator, Invert};\n+use std::iterator::RandomAccessIterator;\n+use std::iterator::{Invert, Enumerate};\n use std::num;\n use std::ops;\n use std::uint;\n@@ -164,7 +165,7 @@ impl BigBitv {\n     }\n \n     #[inline]\n-    pub fn negate(&mut self) { for self.each_storage |w| { *w = !*w } }\n+    pub fn negate(&mut self) { do self.each_storage |w| { *w = !*w; true }; }\n \n     #[inline]\n     pub fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n@@ -646,9 +647,10 @@ impl BitvSet {\n     /// Creates a new bit vector set from the given bit vector\n     pub fn from_bitv(bitv: Bitv) -> BitvSet {\n         let mut size = 0;\n-        for bitv.ones |_| {\n+        do bitv.ones |_| {\n             size += 1;\n-        }\n+            true\n+        };\n         let Bitv{rep, _} = bitv;\n         match rep {\n             Big(b) => BitvSet{ size: size, bitv: b },\n@@ -672,7 +674,7 @@ impl BitvSet {\n     fn other_op(&mut self, other: &BitvSet, f: &fn(uint, uint) -> uint) {\n         fn nbits(mut w: uint) -> uint {\n             let mut bits = 0;\n-            for uint::bits.times {\n+            for uint::range(0, uint::bits) |_| {\n                 if w == 0 {\n                     break;\n                 }\n@@ -715,19 +717,54 @@ impl BitvSet {\n     pub fn iter<'a>(&'a self) -> BitvSetIterator<'a> {\n         BitvSetIterator {set: self, next_idx: 0}\n     }\n+\n+    pub fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+        for self.common_iter(other).advance |(i, w1, w2)| {\n+            if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n+                return false;\n+            }\n+        }\n+        /* everything we have that they don't also shows up */\n+        self.outlier_iter(other).advance(|(mine, i, w)|\n+            !mine || iterate_bits(i, w, |b| f(&b))\n+        )\n+    }\n+\n+    pub fn symmetric_difference(&self, other: &BitvSet,\n+                            f: &fn(&uint) -> bool) -> bool {\n+        for self.common_iter(other).advance |(i, w1, w2)| {\n+            if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n+                return false;\n+            }\n+        }\n+        self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n+    }\n+\n+    pub fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+        self.common_iter(other).advance(|(i, w1, w2)| iterate_bits(i, w1 & w2, |b| f(&b)))\n+    }\n+\n+    pub fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+        for self.common_iter(other).advance |(i, w1, w2)| {\n+            if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n+                return false;\n+            }\n+        }\n+        self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n+    }\n }\n \n impl cmp::Eq for BitvSet {\n     fn eq(&self, other: &BitvSet) -> bool {\n         if self.size != other.size {\n             return false;\n         }\n-        for self.each_common(other) |_, w1, w2| {\n+        for self.common_iter(other).advance |(_, w1, w2)| {\n             if w1 != w2 {\n                 return false;\n             }\n         }\n-        for self.each_outlier(other) |_, _, w| {\n+        for self.outlier_iter(other).advance |(_, _, w)| {\n             if w != 0 {\n                 return false;\n             }\n@@ -745,7 +782,7 @@ impl Container for BitvSet {\n \n impl Mutable for BitvSet {\n     fn clear(&mut self) {\n-        for self.bitv.each_storage |w| { *w = 0; }\n+        do self.bitv.each_storage |w| { *w = 0; true };\n         self.size = 0;\n     }\n }\n@@ -756,22 +793,21 @@ impl Set<uint> for BitvSet {\n     }\n \n     fn is_disjoint(&self, other: &BitvSet) -> bool {\n-        for self.intersection(other) |_| {\n-            return false;\n+        do self.intersection(other) |_| {\n+            false\n         }\n-        return true;\n     }\n \n     fn is_subset(&self, other: &BitvSet) -> bool {\n-        for self.each_common(other) |_, w1, w2| {\n+        for self.common_iter(other).advance |(_, w1, w2)| {\n             if w1 & w2 != w1 {\n                 return false;\n             }\n         }\n         /* If anything is not ours, then everything is not ours so we're\n            definitely a subset in that case. Otherwise if there's any stray\n            ones that 'other' doesn't have, we're not a subset. */\n-        for self.each_outlier(other) |mine, _, w| {\n+        for self.outlier_iter(other).advance |(mine, _, w)| {\n             if !mine {\n                 return true;\n             } else if w != 0 {\n@@ -784,41 +820,6 @@ impl Set<uint> for BitvSet {\n     fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n-\n-    fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n-        for self.each_common(other) |i, w1, w2| {\n-            if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n-                return false;\n-            }\n-        }\n-        /* everything we have that they don't also shows up */\n-        self.each_outlier(other, |mine, i, w|\n-            !mine || iterate_bits(i, w, |b| f(&b))\n-        )\n-    }\n-\n-    fn symmetric_difference(&self, other: &BitvSet,\n-                            f: &fn(&uint) -> bool) -> bool {\n-        for self.each_common(other) |i, w1, w2| {\n-            if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n-                return false;\n-            }\n-        }\n-        self.each_outlier(other, |_, i, w| iterate_bits(i, w, |b| f(&b)))\n-    }\n-\n-    fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n-        self.each_common(other, |i, w1, w2| iterate_bits(i, w1 & w2, |b| f(&b)))\n-    }\n-\n-    fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n-        for self.each_common(other) |i, w1, w2| {\n-            if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n-                return false;\n-            }\n-        }\n-        self.each_outlier(other, |_, i, w| iterate_bits(i, w, |b| f(&b)))\n-    }\n }\n \n impl MutableSet<uint> for BitvSet {\n@@ -860,13 +861,14 @@ impl BitvSet {\n     /// both have in common. The three yielded arguments are (bit location,\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n-    fn each_common(&self, other: &BitvSet,\n-                   f: &fn(uint, uint, uint) -> bool) -> bool {\n+    fn common_iter<'a>(&'a self, other: &'a BitvSet)\n+        -> MapE<(uint,&uint),(uint,uint,uint), &'a ~[uint],Enumerate<vec::VecIterator<'a,uint>>> {\n         let min = num::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n-        self.bitv.storage.slice(0, min).iter().enumerate().advance(|(i, &w)| {\n-            f(i * uint::bits, w, other.bitv.storage[i])\n-        })\n+        MapE{iter: self.bitv.storage.slice(0, min).iter().enumerate(),\n+             env: &other.bitv.storage,\n+             f: |(i, &w): (uint, &uint), o_store| (i * uint::bits, w, o_store[i])\n+        }\n     }\n \n     /// Visits each word in self or other that extends beyond the other. This\n@@ -876,24 +878,45 @@ impl BitvSet {\n     /// The yielded arguments are a bool, the bit offset, and a word. The bool\n     /// is true if the word comes from 'self', and false if it comes from\n     /// 'other'.\n-    fn each_outlier(&self, other: &BitvSet,\n-                    f: &fn(bool, uint, uint) -> bool) -> bool {\n+    fn outlier_iter<'a>(&'a self, other: &'a BitvSet)\n+        -> MapE<(uint, &uint),(bool, uint, uint), uint, Enumerate<vec::VecIterator<'a, uint>>> {\n         let len1 = self.bitv.storage.len();\n         let len2 = other.bitv.storage.len();\n         let min = num::min(len1, len2);\n \n-        /* only one of these loops will execute and that's the point */\n-        foreach (i, &w) in self.bitv.storage.slice(min, len1).iter().enumerate() {\n-            if !f(true, (i + min) * uint::bits, w) {\n-                return false;\n+        if min < len1 {\n+            MapE{iter: self.bitv.storage.slice(min, len1).iter().enumerate(),\n+                 env: min,\n+                 f: |(i, &w): (uint, &uint), min| (true, (i + min) * uint::bits, w)\n             }\n-        }\n-        foreach (i, &w) in other.bitv.storage.slice(min, len2).iter().enumerate() {\n-            if !f(false, (i + min) * uint::bits, w) {\n-                return false;\n+        } else {\n+            MapE{iter: other.bitv.storage.slice(min, len2).iter().enumerate(),\n+                 env: min,\n+                 f: |(i, &w): (uint, &uint), min| (false, (i + min) * uint::bits, w)\n             }\n         }\n-        return true;\n+    }\n+}\n+\n+/// Like iterator::Map with explicit env capture\n+struct MapE<A, B, Env, I> {\n+    priv env: Env,\n+    priv f: &'static fn(A, Env) -> B,\n+    priv iter: I,\n+}\n+\n+impl<'self, A, B, Env: Clone, I: Iterator<A>> Iterator<B> for MapE<A, B, Env, I> {\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        match self.iter.next() {\n+            Some(elt) => Some((self.f)(elt, self.env.clone())),\n+            None => None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n     }\n }\n \n@@ -1354,18 +1377,18 @@ mod tests {\n     fn test_small_clear() {\n         let mut b = Bitv::new(14, true);\n         b.clear();\n-        for b.ones |i| {\n-            fail!(\"found 1 at %?\", i);\n-        }\n+        do b.ones |i| {\n+            fail!(\"found 1 at %?\", i)\n+        };\n     }\n \n     #[test]\n     fn test_big_clear() {\n         let mut b = Bitv::new(140, true);\n         b.clear();\n-        for b.ones |i| {\n-            fail!(\"found 1 at %?\", i);\n-        }\n+        do b.ones |i| {\n+            fail!(\"found 1 at %?\", i)\n+        };\n     }\n \n     #[test]\n@@ -1400,10 +1423,11 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n-        for a.intersection(&b) |x| {\n+        do a.intersection(&b) |x| {\n             assert_eq!(*x, expected[i]);\n-            i += 1\n-        }\n+            i += 1;\n+            true\n+        };\n         assert_eq!(i, expected.len());\n     }\n \n@@ -1423,10 +1447,11 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 5, 500];\n-        for a.difference(&b) |x| {\n+        do a.difference(&b) |x| {\n             assert_eq!(*x, expected[i]);\n-            i += 1\n-        }\n+            i += 1;\n+            true\n+        };\n         assert_eq!(i, expected.len());\n     }\n \n@@ -1448,10 +1473,11 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 5, 11, 14, 220];\n-        for a.symmetric_difference(&b) |x| {\n+        do a.symmetric_difference(&b) |x| {\n             assert_eq!(*x, expected[i]);\n-            i += 1\n-        }\n+            i += 1;\n+            true\n+        };\n         assert_eq!(i, expected.len());\n     }\n \n@@ -1476,10 +1502,11 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160];\n-        for a.union(&b) |x| {\n+        do a.union(&b) |x| {\n             assert_eq!(*x, expected[i]);\n-            i += 1\n-        }\n+            i += 1;\n+            true\n+        };\n         assert_eq!(i, expected.len());\n     }\n "}, {"sha": "b2b39d34ce2cd79f10ae7cc12ed17b63db0ed962", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -933,7 +933,7 @@ mod tests {\n \n     #[test]\n     fn test_fuzz() {\n-        for 25.times {\n+        do 25.times {\n             fuzz_test(3);\n             fuzz_test(16);\n             fuzz_test(189);"}, {"sha": "d330b0ea1639559ea7b77f16d22eb2acbd6c5252", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -90,13 +90,13 @@ mod tests {\n     fn test_flate_round_trip() {\n         let mut r = rand::rng();\n         let mut words = ~[];\n-        for 20.times {\n+        do 20.times {\n             let range = r.gen_uint_range(1, 10);\n             words.push(r.gen_bytes(range));\n         }\n-        for 20.times {\n+        do 20.times {\n             let mut input = ~[];\n-            for 2000.times {\n+            do 2000.times {\n                 input.push_all(r.choose(words));\n             }\n             debug!(\"de/inflate of %u bytes of random word-sequences\","}, {"sha": "31a73833e27ca6c8910165b6a9c0ce4d648ee422", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -662,7 +662,7 @@ pub mod groups {\n             // here we just need to indent the start of the description\n             let rowlen = row.len();\n             if rowlen < 24 {\n-                for (24 - rowlen).times {\n+                do (24 - rowlen).times {\n                     row.push_char(' ')\n                 }\n             } else {\n@@ -678,9 +678,10 @@ pub mod groups {\n \n             // FIXME: #5516\n             let mut desc_rows = ~[];\n-            for each_split_within(desc_normalized_whitespace, 54) |substr| {\n+            do each_split_within(desc_normalized_whitespace, 54) |substr| {\n                 desc_rows.push(substr.to_owned());\n-            }\n+                true\n+            };\n \n             // FIXME: #5516\n             // wrapped description\n@@ -780,7 +781,7 @@ pub mod groups {\n     priv fn test_split_within() {\n         fn t(s: &str, i: uint, u: &[~str]) {\n             let mut v = ~[];\n-            for each_split_within(s, i) |s| { v.push(s.to_owned()) }\n+            do each_split_within(s, i) |s| { v.push(s.to_owned()); true };\n             assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         t(\"\", 0, []);"}, {"sha": "720a525164a3256b3cb4e79d3e8f3427df549f57", "filename": "src/libextra/iter.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fiter.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -72,12 +72,9 @@ pub trait FromIter<T> {\n #[inline]\n pub fn any<T>(predicate: &fn(T) -> bool,\n               iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n-    for iter |x| {\n-        if predicate(x) {\n-            return true;\n-        }\n+    do iter |x| {\n+        predicate(x)\n     }\n-    return false;\n }\n \n /**\n@@ -111,12 +108,14 @@ pub fn all<T>(predicate: &fn(T) -> bool,\n #[inline]\n pub fn find<T>(predicate: &fn(&T) -> bool,\n                iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    for iter |x| {\n+    let mut ret = None;\n+    do iter |x| {\n         if predicate(&x) {\n-            return Some(x);\n-        }\n-    }\n-    None\n+            ret = Some(x);\n+            false\n+        } else { true }\n+    };\n+    ret\n }\n \n /**\n@@ -132,7 +131,7 @@ pub fn find<T>(predicate: &fn(&T) -> bool,\n #[inline]\n pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     let mut result = None;\n-    for iter |x| {\n+    do iter |x| {\n         match result {\n             Some(ref mut y) => {\n                 if x > *y {\n@@ -141,7 +140,8 @@ pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n             }\n             None => result = Some(x)\n         }\n-    }\n+        true\n+    };\n     result\n }\n \n@@ -158,7 +158,7 @@ pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n #[inline]\n pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     let mut result = None;\n-    for iter |x| {\n+    do iter |x| {\n         match result {\n             Some(ref mut y) => {\n                 if x < *y {\n@@ -167,7 +167,8 @@ pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n             }\n             None => result = Some(x)\n         }\n-    }\n+        true\n+    };\n     result\n }\n \n@@ -183,9 +184,10 @@ pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n #[inline]\n pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {\n     let mut result = start;\n-    for iter |x| {\n+    do iter |x| {\n         f(&mut result, x);\n-    }\n+        true\n+    };\n     result\n }\n \n@@ -206,9 +208,10 @@ pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T,\n #[inline]\n pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&mut T, &U)) -> T {\n     let mut result = start;\n-    for iter |x| {\n+    do iter |x| {\n         f(&mut result, x);\n-    }\n+        true\n+    };\n     result\n }\n \n@@ -246,7 +249,7 @@ impl<T> FromIter<T> for ~[T]{\n     #[inline]\n     pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n         let mut v = ~[];\n-        for iter |x| { v.push(x) }\n+        do iter |x| { v.push(x); true };\n         v\n     }\n }"}, {"sha": "a9f4276e79e701297cb57813fe19382ecaedf22e", "filename": "src/libextra/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -77,7 +77,7 @@ fn escape_str(s: &str) -> ~str {\n \n fn spaces(n: uint) -> ~str {\n     let mut ss = ~\"\";\n-    for n.times {\n+    do n.times {\n         ss.push_str(\" \");\n     }\n     return ss;"}, {"sha": "0e8c50ac873027a8df3c0ca648fb8aa54b001a5d", "filename": "src/libextra/list.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -70,10 +70,11 @@ pub fn find<T:Clone>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n \n /// Returns true if a list contains an element with the given value\n pub fn has<T:Eq>(ls: @List<T>, elt: T) -> bool {\n-    for each(ls) |e| {\n-        if *e == elt { return true; }\n-    }\n-    return false;\n+    let mut found = false;\n+    do each(ls) |e| {\n+        if *e == elt { found = true; false } else { true }\n+    };\n+    return found;\n }\n \n /// Returns true if the list is empty"}, {"sha": "9cb45a2ec7af96d44a778475574c5b5f11163eb6", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -509,7 +509,7 @@ mod tests {\n     fn bench_grow(b: &mut test::BenchHarness) {\n         let mut deq = RingBuf::new();\n         do b.iter {\n-            for 65.times {\n+            do 65.times {\n                 deq.push_front(1);\n             }\n         }"}, {"sha": "95f3af006e8cc52d8211edba18a8bd91673fb93c", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -784,11 +784,12 @@ impl<\n     fn encode(&self, e: &mut E) {\n         do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n-            for self.each |key, val| {\n+            do self.each |key, val| {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n-            }\n+                true\n+            };\n         }\n     }\n }\n@@ -814,10 +815,11 @@ impl<S: Encoder> Encodable<S> for TrieSet {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n-            for self.each |e| {\n+            do self.each |e| {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n-            }\n+                true\n+            };\n         }\n     }\n }"}, {"sha": "9832ff7396bcbcf00b31fa12b8a98f18f00003b4", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -1081,7 +1081,7 @@ mod big_tests {\n             tim_sort(arr); // /sort\n             isSorted(arr);\n \n-            for 3.times {\n+            do 3.times {\n                 let i1 = rng.gen_uint_range(0, n);\n                 let i2 = rng.gen_uint_range(0, n);\n                 arr.swap(i1, i2);\n@@ -1100,7 +1100,7 @@ mod big_tests {\n             tim_sort(arr); // +sort\n             isSorted(arr);\n \n-            for (n/100).times {\n+            do (n/100).times {\n                 let idx = rng.gen_uint_range(0, n);\n                 arr[idx] = rng.gen();\n             }\n@@ -1153,7 +1153,7 @@ mod big_tests {\n             tim_sort(arr); // /sort\n             isSorted(arr);\n \n-            for 3.times {\n+            do 3.times {\n                 let i1 = rng.gen_uint_range(0, n);\n                 let i2 = rng.gen_uint_range(0, n);\n                 arr.swap(i1, i2);\n@@ -1172,7 +1172,7 @@ mod big_tests {\n             tim_sort(arr); // +sort\n             isSorted(arr);\n \n-            for (n/100).times {\n+            do (n/100).times {\n                 let idx = rng.gen_uint_range(0, n);\n                 arr[idx] = @rng.gen();\n             }"}, {"sha": "e539b067edd1ce01c60600ae5ddbf004e8650cff", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -106,7 +106,7 @@ impl<Q:Send> Sem<Q> {\n                 }\n             }\n             // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n-            /* for 1000.times { task::yield(); } */\n+            /* do 1000.times { task::yield(); } */\n             // Need to wait outside the exclusive.\n             if waiter_nobe.is_some() {\n                 let _ = comm::recv_one(waiter_nobe.unwrap());\n@@ -143,7 +143,7 @@ impl Sem<~[WaitQueue]> {\n     fn new_and_signal(count: int, num_condvars: uint)\n         -> Sem<~[WaitQueue]> {\n         let mut queues = ~[];\n-        for num_condvars.times {\n+        do num_condvars.times {\n             queues.push(WaitQueue::new());\n         }\n         Sem::new(count, queues)\n@@ -826,11 +826,11 @@ mod tests {\n         let s2 = ~s.clone();\n         do task::spawn || {\n             do s2.access {\n-                for 5.times { task::yield(); }\n+                do 5.times { task::yield(); }\n             }\n         }\n         do s.access {\n-            for 5.times { task::yield(); }\n+            do 5.times { task::yield(); }\n         }\n     }\n     #[test]\n@@ -843,7 +843,7 @@ mod tests {\n             s2.acquire();\n             c.send(());\n         }\n-        for 5.times { task::yield(); }\n+        do 5.times { task::yield(); }\n         s.release();\n         let _ = p.recv();\n \n@@ -852,7 +852,7 @@ mod tests {\n         let s = ~Semaphore::new(0);\n         let s2 = ~s.clone();\n         do task::spawn || {\n-            for 5.times { task::yield(); }\n+            do 5.times { task::yield(); }\n             s2.release();\n             let _ = p.recv();\n         }\n@@ -895,7 +895,7 @@ mod tests {\n                     c.send(());\n                 }\n                 let _ = p.recv(); // wait for child to come alive\n-                for 5.times { task::yield(); } // let the child contend\n+                do 5.times { task::yield(); } // let the child contend\n             }\n             let _ = p.recv(); // wait for child to be done\n         }\n@@ -929,7 +929,7 @@ mod tests {\n         }\n \n         fn access_shared(sharedstate: &mut int, m: &Mutex, n: uint) {\n-            for n.times {\n+            do n.times {\n                 do m.lock {\n                     let oldval = *sharedstate;\n                     task::yield();\n@@ -975,7 +975,7 @@ mod tests {\n         let m = ~Mutex::new();\n         let mut ports = ~[];\n \n-        for num_waiters.times {\n+        do num_waiters.times {\n             let mi = ~m.clone();\n             let (port, chan) = comm::stream();\n             ports.push(port);\n@@ -1065,7 +1065,7 @@ mod tests {\n \n         let result: result::Result<(),()> = do task::try || {\n             let mut sibling_convos = ~[];\n-            for 2.times {\n+            do 2.times {\n                 let (p,c) = comm::stream();\n                 let c = Cell::new(c);\n                 sibling_convos.push(p);\n@@ -1212,7 +1212,7 @@ mod tests {\n \n         fn access_shared(sharedstate: &mut int, x: &RWLock, mode: RWLockMode,\n                          n: uint) {\n-            for n.times {\n+            do n.times {\n                 do lock_rwlock_in_mode(x, mode) {\n                     let oldval = *sharedstate;\n                     task::yield();\n@@ -1343,7 +1343,7 @@ mod tests {\n         let x = ~RWLock::new();\n         let mut ports = ~[];\n \n-        for num_waiters.times {\n+        do num_waiters.times {\n             let xi = (*x).clone();\n             let (port, chan) = comm::stream();\n             ports.push(port);"}, {"sha": "ddb3c31ec0576a24baad02b4769cebba9d16a0f4", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -102,7 +102,7 @@ fn test_task_pool() {\n         g\n     };\n     let mut pool = TaskPool::new(4, Some(SingleThreaded), f);\n-    for 8.times {\n+    do 8.times {\n         pool.execute(|i| printfln!(\"Hello from thread %u!\", *i));\n     }\n }"}, {"sha": "0a2f32375f812407e020cb09104a7aee307023de", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -14,12 +14,13 @@\n use std::os;\n use std::rand::RngUtil;\n use std::rand;\n+use std::uint;\n \n /// Attempts to make a temporary directory inside of `tmpdir` whose name will\n /// have the suffix `suffix`. If no directory can be created, None is returned.\n pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n     let mut r = rand::rng();\n-    for 1000.times {\n+    for uint::range(0, 1000) |_| {\n         let p = tmpdir.push(r.gen_str(16) + suffix);\n         if os::make_dir(&p, 0x1c0) { // 700\n             return Some(p);"}, {"sha": "9493a6fb0e0d0fe230ec6fa4d10940d3fe8e8fe6", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 51, "deletions": 47, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -16,6 +16,7 @@\n use std::num;\n use std::util::{swap, replace};\n use std::iterator::{FromIterator, Extendable};\n+use std::uint;\n \n // This is implemented as an AA tree, which is a simplified variation of\n // a red-black tree where red (horizontal) nodes can only be added\n@@ -47,7 +48,7 @@ impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n         } else {\n             let mut x = self.iter();\n             let mut y = other.iter();\n-            for self.len().times {\n+            for uint::range(0, self.len()) |_| {\n                 if x.next().unwrap() != y.next().unwrap() {\n                     return false\n                 }\n@@ -65,7 +66,7 @@ fn lt<K: Ord + TotalOrd, V: Ord>(a: &TreeMap<K, V>,\n     let mut y = b.iter();\n \n     let (a_len, b_len) = (a.len(), b.len());\n-    for num::min(a_len, b_len).times {\n+    for uint::range(0, num::min(a_len, b_len)) |_| {\n         let (key_a, value_a) = x.next().unwrap();\n         let (key_b, value_b) = y.next().unwrap();\n         if *key_a < *key_b { return true; }\n@@ -396,9 +397,40 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n         }\n         true\n     }\n+}\n+\n+impl<T: TotalOrd> MutableSet<T> for TreeSet<T> {\n+    /// Add a value to the set. Return true if the value was not already\n+    /// present in the set.\n+    #[inline]\n+    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+\n+    /// Remove a value from the set. Return true if the value was\n+    /// present in the set.\n+    #[inline]\n+    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+}\n+\n+impl<T: TotalOrd> TreeSet<T> {\n+    /// Create an empty TreeSet\n+    #[inline]\n+    pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n+\n+    /// Get a lazy iterator over the values in the set.\n+    /// Requires that it be frozen (immutable).\n+    #[inline]\n+    pub fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n+        TreeSetIterator{iter: self.map.iter()}\n+    }\n+\n+    /// Visit all values in reverse order\n+    #[inline]\n+    pub fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n+        self.map.each_key_reverse(f)\n+    }\n \n     /// Visit the values (in-order) representing the difference\n-    fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n+    pub fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -427,7 +459,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the symmetric difference\n-    fn symmetric_difference(&self, other: &TreeSet<T>,\n+    pub fn symmetric_difference(&self, other: &TreeSet<T>,\n                             f: &fn(&T) -> bool) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -461,7 +493,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the intersection\n-    fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n+    pub fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -487,7 +519,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the union\n-    fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n+    pub fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -519,37 +551,6 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n }\n \n-impl<T: TotalOrd> MutableSet<T> for TreeSet<T> {\n-    /// Add a value to the set. Return true if the value was not already\n-    /// present in the set.\n-    #[inline]\n-    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n-\n-    /// Remove a value from the set. Return true if the value was\n-    /// present in the set.\n-    #[inline]\n-    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n-}\n-\n-impl<T: TotalOrd> TreeSet<T> {\n-    /// Create an empty TreeSet\n-    #[inline]\n-    pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n-\n-    /// Get a lazy iterator over the values in the set.\n-    /// Requires that it be frozen (immutable).\n-    #[inline]\n-    pub fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n-        TreeSetIterator{iter: self.map.iter()}\n-    }\n-\n-    /// Visit all values in reverse order\n-    #[inline]\n-    pub fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n-        self.map.each_key_reverse(f)\n-    }\n-}\n-\n /// Lazy forward iterator over a set\n pub struct TreeSetIterator<'self, T> {\n     priv iter: TreeMapIterator<'self, T, ()>\n@@ -931,8 +932,8 @@ mod test_treemap {\n \n         let mut rng = rand::IsaacRng::new_seeded(&[42]);\n \n-        for 3.times {\n-            for 90.times {\n+        do 3.times {\n+            do 90.times {\n                 let k = rng.gen();\n                 let v = rng.gen();\n                 if !ctrl.iter().any(|x| x == &(k, v)) {\n@@ -943,7 +944,7 @@ mod test_treemap {\n                 }\n             }\n \n-            for 30.times {\n+            do 30.times {\n                 let r = rng.gen_uint_range(0, ctrl.len());\n                 let (key, _) = ctrl.remove(r);\n                 assert!(map.remove(&key));\n@@ -1001,11 +1002,12 @@ mod test_treemap {\n         assert!(m.insert(1, 2));\n \n         let mut n = 4;\n-        for m.each_reverse |k, v| {\n+        do m.each_reverse |k, v| {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n -= 1;\n-        }\n+            true\n+        };\n     }\n \n     #[test]\n@@ -1277,10 +1279,11 @@ mod test_set {\n         assert!(m.insert(1));\n \n         let mut n = 4;\n-        for m.each_reverse |x| {\n+        do m.each_reverse |x| {\n             assert_eq!(*x, n);\n-            n -= 1\n-        }\n+            n -= 1;\n+            true\n+        };\n     }\n \n     fn check(a: &[int], b: &[int], expected: &[int],\n@@ -1292,10 +1295,11 @@ mod test_set {\n         foreach y in b.iter() { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n-        for f(&set_a, &set_b) |x| {\n+        do f(&set_a, &set_b) |x| {\n             assert_eq!(*x, expected[i]);\n             i += 1;\n-        }\n+            true\n+        };\n         assert_eq!(i, expected.len());\n     }\n "}, {"sha": "e98a759d8a8d4a6954a116a788cfcf5ec20c93d7", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -189,7 +189,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         };\n         if expanded {\n             let entry = if self.oper.initial_value() { uint::max_value } else {0};\n-            for self.words_per_id.times {\n+            do self.words_per_id.times {\n                 self.gens.push(0);\n                 self.kills.push(0);\n                 self.on_entry.push(entry);"}, {"sha": "f972406ae11d8b9eddbbaa6f179fff19d454b7a5", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -74,6 +74,7 @@ pub enum lint {\n     unused_imports,\n     unnecessary_qualification,\n     while_true,\n+    deprecated_for_loop,\n     path_statement,\n     unrecognized_lint,\n     non_camel_case_types,\n@@ -165,6 +166,13 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: warn\n      }),\n \n+    (\"deprecated_for_loop\",\n+     LintSpec {\n+         lint: deprecated_for_loop,\n+         desc: \"recommend using `foreach` or `do` instead of `for`\",\n+         default: allow\n+     }),\n+\n     (\"path_statement\",\n      LintSpec {\n         lint: path_statement,\n@@ -451,7 +459,7 @@ impl Context {\n         if doc_hidden && self.doc_hidden {\n             self.doc_hidden = false;\n         }\n-        for pushed.times {\n+        do pushed.times {\n             let (lint, lvl, src) = self.lint_stack.pop();\n             self.set_level(lint, lvl, src);\n         }\n@@ -561,6 +569,24 @@ fn lint_while_true() -> visit::vt<@mut Context> {\n     })\n }\n \n+fn lint_deprecated_for_loop() -> visit::vt<@mut Context> {\n+    visit::mk_vt(@visit::Visitor {\n+        visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n+            match e.node {\n+                ast::expr_call(_, _, ast::ForSugar) |\n+                ast::expr_method_call(_, _, _, _, _, ast::ForSugar) => {\n+                    cx.span_lint(deprecated_for_loop, e.span,\n+                                \"`for` is deprecated; use `foreach <pat> in \\\n+                                 <iterator>` or `do`\")\n+                }\n+                _ => {}\n+            }\n+            visit::visit_expr(e, (cx, vt));\n+        },\n+        .. *visit::default_visitor()\n+    })\n+}\n+\n fn lint_type_limits() -> visit::vt<@mut Context> {\n     fn is_valid<T:cmp::Ord>(binop: ast::binop, v: T,\n             min: T, max: T) -> bool {\n@@ -1096,6 +1122,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::Crate) {\n \n     // Register each of the lint passes with the context\n     cx.add_lint(lint_while_true());\n+    cx.add_lint(lint_deprecated_for_loop());\n     cx.add_lint(lint_path_statement());\n     cx.add_lint(lint_heap());\n     cx.add_lint(lint_type_limits());"}, {"sha": "8b2171b59acd5472fdbb95c5eebf0336c3ac0d5f", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -340,7 +340,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n \n             visit::visit_mod(the_module, span, node_id, (method_map, visitor));\n \n-            for n_added.times {\n+            do n_added.times {\n                 ignore(privileged_items.pop());\n             }\n         },\n@@ -370,7 +370,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n \n             visit::visit_block(block, (method_map, visitor));\n \n-            for n_added.times {\n+            do n_added.times {\n                 ignore(privileged_items.pop());\n             }\n         },"}, {"sha": "40d0d77c16ecb11cfe39ddcc75bc86a059ba1823", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -188,7 +188,7 @@ pub fn const_expr(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n         Some(@ty::AutoDerefRef(ref adj)) => {\n             let mut ty = ety;\n             let mut maybe_ptr = None;\n-            for adj.autoderefs.times {\n+            do adj.autoderefs.times {\n                 let (dv, dt) = const_deref(cx, llconst, ty, false);\n                 maybe_ptr = Some(llconst);\n                 llconst = dv;"}, {"sha": "67fc60c4912c76baa68511abfca9b418bae34b3f", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -637,7 +637,7 @@ mod test {\n         let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n         write_markdown(doc, writer_factory);\n         // We expect two pages to have been written\n-        for 2.times {\n+        do 2.times {\n             po.recv();\n         }\n     }\n@@ -649,7 +649,7 @@ mod test {\n             ~\"#[link(name = \\\"core\\\")]; mod a { }\");\n         let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n         write_markdown(doc, writer_factory);\n-        for 2.times {\n+        do 2.times {\n             let (page, markdown) = po.recv();\n             match page {\n                 doc::CratePage(_) => {"}, {"sha": "24ca6fc23091da83f47a262e3490a629029014eb", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -94,42 +94,45 @@ pub unsafe fn annihilate() {\n     //\n     // In this pass, nothing gets freed, so it does not matter whether\n     // we read the next field before or after the callback.\n-    for each_live_alloc(true) |box, uniq| {\n+    do each_live_alloc(true) |box, uniq| {\n         stats.n_total_boxes += 1;\n         if uniq {\n             stats.n_unique_boxes += 1;\n         } else {\n             (*box).ref_count = managed::RC_IMMORTAL;\n         }\n-    }\n+        true\n+    };\n \n     // Pass 2: Drop all boxes.\n     //\n     // In this pass, unique-managed boxes may get freed, but not\n     // managed boxes, so we must read the `next` field *after* the\n     // callback, as the original value may have been freed.\n-    for each_live_alloc(false) |box, uniq| {\n+    do each_live_alloc(false) |box, uniq| {\n         if !uniq {\n             let tydesc = (*box).type_desc;\n             let data = &(*box).data as *();\n             ((*tydesc).drop_glue)(data as *i8);\n         }\n-    }\n+        true\n+    };\n \n     // Pass 3: Free all boxes.\n     //\n     // In this pass, managed boxes may get freed (but not\n     // unique-managed boxes, though I think that none of those are\n     // left), so we must read the `next` field before, since it will\n     // not be valid after.\n-    for each_live_alloc(true) |box, uniq| {\n+    do each_live_alloc(true) |box, uniq| {\n         if !uniq {\n             stats.n_bytes_freed +=\n                 (*((*box).type_desc)).size\n                 + sys::size_of::<raw::Box<()>>();\n             local_free(box as *i8);\n         }\n-    }\n+        true\n+    };\n \n     if debug_mem() {\n         // We do logging here w/o allocation."}, {"sha": "10f3fc6586f58329bf56d86b9de99c646b67036c", "filename": "src/libstd/container.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcontainer.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -87,17 +87,7 @@ pub trait Set<T>: Container {\n     /// Return true if the set is a superset of another\n     fn is_superset(&self, other: &Self) -> bool;\n \n-    /// Visit the values representing the difference\n-    fn difference(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n-\n-    /// Visit the values representing the symmetric difference\n-    fn symmetric_difference(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n-\n-    /// Visit the values representing the intersection\n-    fn intersection(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n-\n-    /// Visit the values representing the union\n-    fn union(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n+    // FIXME #8154: Add difference, sym. difference, intersection and union iterators\n }\n \n /// This trait represents actions which can be performed on sets to mutate"}, {"sha": "9a8db6990b65dedbef92bbe4214c56d1440df9fe", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 49, "deletions": 58, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -121,11 +121,11 @@ unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n     return None;\n }\n \n-type Visitor<'self> = &'self fn(root: **Word, tydesc: *TyDesc) -> bool;\n+type Visitor<'self> = &'self fn(root: **Word, tydesc: *TyDesc);\n \n // Walks the list of roots for the given safe point, and calls visitor\n // on each root.\n-unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n+unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n     let fp_bytes = fp as *u8;\n     let sp_meta = sp.sp_meta as *u32;\n \n@@ -151,7 +151,7 @@ unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n             } else {\n                 ptr::null()\n             };\n-            if !visitor(root, tydesc) { return false; }\n+            visitor(root, tydesc);\n         }\n         sri += 1;\n     }\n@@ -164,10 +164,9 @@ unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n         }\n         rri += 1;\n     }\n-    return true;\n }\n \n-unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n+unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n     _walk_safe_point(fp, sp, visitor)\n }\n \n@@ -223,15 +222,15 @@ static need_cleanup:    Memory = exchange_heap | stack;\n \n // Walks stack, searching for roots of the requested type, and passes\n // each root to the visitor.\n-unsafe fn _walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) -> bool {\n+unsafe fn _walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n     let mut segment = rustrt::rust_get_stack_segment();\n     let mut last_ret: *Word = ptr::null();\n     // To avoid collecting memory used by the GC itself, skip stack\n     // frames until past the root GC stack frame. The root GC stack\n     // frame is marked by a sentinel, which is a box pointer stored on\n     // the stack.\n     let mut reached_sentinel = ptr::is_null(sentinel);\n-    for walk_stack |frame| {\n+    do walk_stack |frame| {\n         let pc = last_ret;\n         let Segment {segment: next_segment, boundary: boundary} =\n             find_segment_for_frame(frame.fp, segment);\n@@ -248,53 +247,46 @@ unsafe fn _walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) -> boo\n         let ret_offset = if boundary { 4 } else { 1 };\n         last_ret = *ptr::offset(frame.fp, ret_offset as int) as *Word;\n \n-        if ptr::is_null(pc) {\n-            loop;\n-        }\n-\n-        let mut delay_reached_sentinel = reached_sentinel;\n-        let sp = is_safe_point(pc);\n-        match sp {\n-          Some(sp_info) => {\n-            for walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n-                // Skip roots until we see the sentinel.\n-                if !reached_sentinel {\n-                    if root == sentinel {\n-                        delay_reached_sentinel = true;\n-                    }\n-                    loop;\n-                }\n-\n-                // Skip null pointers, which can occur when a\n-                // unique pointer has already been freed.\n-                if ptr::is_null(*root) {\n-                    loop;\n-                }\n-\n-                if ptr::is_null(tydesc) {\n-                    // Root is a generic box.\n-                    let refcount = **root;\n-                    if mem | task_local_heap != 0 && refcount != -1 {\n-                        if !visitor(root, tydesc) { return false; }\n-                    } else if mem | exchange_heap != 0 && refcount == -1 {\n-                        if !visitor(root, tydesc) { return false; }\n-                    }\n-                } else {\n-                    // Root is a non-immediate.\n-                    if mem | stack != 0 {\n-                        if !visitor(root, tydesc) { return false; }\n+        if !ptr::is_null(pc) {\n+\n+            let mut delay_reached_sentinel = reached_sentinel;\n+            let sp = is_safe_point(pc);\n+            match sp {\n+                Some(sp_info) => {\n+                    do walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n+                        // Skip roots until we see the sentinel.\n+                        if !reached_sentinel && root == sentinel {\n+                            delay_reached_sentinel = true;\n+                        }\n+\n+                        // Skip null pointers, which can occur when a\n+                        // unique pointer has already been freed.\n+                        if reached_sentinel && !ptr::is_null(*root) {\n+                            if ptr::is_null(tydesc) {\n+                                // Root is a generic box.\n+                                let refcount = **root;\n+                                if mem | task_local_heap != 0 && refcount != -1 {\n+                                    visitor(root, tydesc);\n+                                } else if mem | exchange_heap != 0 && refcount == -1 {\n+                                    visitor(root, tydesc);\n+                                }\n+                            } else {\n+                                // Root is a non-immediate.\n+                                if mem | stack != 0 {\n+                                    visitor(root, tydesc);\n+                                }\n+                            }\n+                        }\n                     }\n                 }\n+                None => ()\n             }\n-          }\n-          None => ()\n+            reached_sentinel = delay_reached_sentinel;\n         }\n-        reached_sentinel = delay_reached_sentinel;\n     }\n-    return true;\n }\n \n-unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) -> bool {\n+unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n     _walk_gc_roots(mem, sentinel, visitor)\n }\n pub fn gc() {\n@@ -304,7 +296,7 @@ pub fn gc() {\n             return;\n         }\n \n-        for walk_gc_roots(task_local_heap, ptr::null()) |_root, _tydesc| {\n+        do walk_gc_roots(task_local_heap, ptr::null()) |_root, _tydesc| {\n             // FIXME(#2997): Walk roots and mark them.\n             io::stdout().write([46]); // .\n         }\n@@ -349,18 +341,17 @@ pub fn cleanup_stack_for_failure() {\n         };\n \n         let mut roots = HashSet::new();\n-        for walk_gc_roots(need_cleanup, sentinel) |root, tydesc| {\n+        do walk_gc_roots(need_cleanup, sentinel) |root, tydesc| {\n             // Track roots to avoid double frees.\n-            if roots.contains(&*root) {\n-                loop;\n-            }\n-            roots.insert(*root);\n+            if !roots.contains(&*root) {\n+                roots.insert(*root);\n \n-            if ptr::is_null(tydesc) {\n-                // FIXME #4420: Destroy this box\n-                // FIXME #4330: Destroy this box\n-            } else {\n-                ((*tydesc).drop_glue)(*root as *i8);\n+                if ptr::is_null(tydesc) {\n+                    // FIXME #4420: Destroy this box\n+                    // FIXME #4330: Destroy this box\n+                } else {\n+                    ((*tydesc).drop_glue)(*root as *i8);\n+                }\n             }\n         }\n     }"}, {"sha": "5d4b9b4e3f0ba89b965b2c18753a8c5b48680682", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -85,38 +85,44 @@ impl<A:IterBytes> Hash for A {\n     #[inline]\n     fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n         let mut s = State::new(k0, k1);\n-        for self.iter_bytes(true) |bytes| {\n+        do self.iter_bytes(true) |bytes| {\n             s.input(bytes);\n-        }\n+            true\n+        };\n         s.result_u64()\n     }\n }\n \n fn hash_keyed_2<A: IterBytes,\n                 B: IterBytes>(a: &A, b: &B, k0: u64, k1: u64) -> u64 {\n     let mut s = State::new(k0, k1);\n-    for a.iter_bytes(true) |bytes| {\n+    do a.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n-    for b.iter_bytes(true) |bytes| {\n+        true\n+    };\n+    do b.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n+        true\n+    };\n     s.result_u64()\n }\n \n fn hash_keyed_3<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes>(a: &A, b: &B, c: &C, k0: u64, k1: u64) -> u64 {\n     let mut s = State::new(k0, k1);\n-    for a.iter_bytes(true) |bytes| {\n+    do a.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n-    for b.iter_bytes(true) |bytes| {\n+        true\n+    };\n+    do b.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n-    for c.iter_bytes(true) |bytes| {\n+        true\n+    };\n+    do c.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n+        true\n+    };\n     s.result_u64()\n }\n \n@@ -132,18 +138,22 @@ fn hash_keyed_4<A: IterBytes,\n                 k1: u64)\n                 -> u64 {\n     let mut s = State::new(k0, k1);\n-    for a.iter_bytes(true) |bytes| {\n+    do a.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n-    for b.iter_bytes(true) |bytes| {\n+        true\n+    };\n+    do b.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n-    for c.iter_bytes(true) |bytes| {\n+        true\n+    };\n+    do c.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n-    for d.iter_bytes(true) |bytes| {\n+        true\n+    };\n+    do d.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n+        true\n+    };\n     s.result_u64()\n }\n \n@@ -161,21 +171,26 @@ fn hash_keyed_5<A: IterBytes,\n                 k1: u64)\n                 -> u64 {\n     let mut s = State::new(k0, k1);\n-    for a.iter_bytes(true) |bytes| {\n+    do a.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n-    for b.iter_bytes(true) |bytes| {\n+        true\n+    };\n+    do b.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n-    for c.iter_bytes(true) |bytes| {\n+        true\n+    };\n+    do c.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n-    for d.iter_bytes(true) |bytes| {\n+        true\n+    };\n+    do d.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n-    for e.iter_bytes(true) |bytes| {\n+        true\n+    };\n+    do e.iter_bytes(true) |bytes| {\n         s.input(bytes);\n-    }\n+        true\n+    };\n     s.result_u64()\n }\n "}, {"sha": "ca61f3e5ad80584bd4f4f6abd1e50f34bae16fe7", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 16, "deletions": 41, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -130,33 +130,35 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n                                 hash: uint,\n                                 k: &K)\n                              -> SearchResult {\n-        for self.bucket_sequence(hash) |i| {\n+        let mut ret = TableFull;\n+        do self.bucket_sequence(hash) |i| {\n             match self.buckets[i] {\n-                Some(ref bkt) => if bkt.hash == hash && *k == bkt.key {\n-                    return FoundEntry(i);\n+                Some(ref bkt) if bkt.hash == hash && *k == bkt.key => {\n+                    ret = FoundEntry(i); false\n                 },\n-                None => return FoundHole(i)\n+                None => { ret = FoundHole(i); false }\n+                _ => true,\n             }\n-        }\n-        TableFull\n+        };\n+        ret\n     }\n \n     #[inline]\n     fn bucket_for_key_with_hash_equiv<Q:Equiv<K>>(&self,\n                                                   hash: uint,\n                                                   k: &Q)\n                                                -> SearchResult {\n-        for self.bucket_sequence(hash) |i| {\n+        let mut ret = TableFull;\n+        do self.bucket_sequence(hash) |i| {\n             match self.buckets[i] {\n-                Some(ref bkt) => {\n-                    if bkt.hash == hash && k.equiv(&bkt.key) {\n-                        return FoundEntry(i);\n-                    }\n+                Some(ref bkt) if bkt.hash == hash && k.equiv(&bkt.key) => {\n+                    ret = FoundEntry(i); false\n                 },\n-                None => return FoundHole(i)\n+                None => { ret = FoundHole(i); false }\n+                _ => true,\n             }\n-        }\n-        TableFull\n+        };\n+        ret\n     }\n \n     /// Expand the capacity of the array to the next power of two\n@@ -272,11 +274,6 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n \n         value\n     }\n-\n-    fn search(&self, hash: uint,\n-              op: &fn(x: &Option<Bucket<K, V>>) -> bool) {\n-        let _ = self.bucket_sequence(hash, |i| op(&self.buckets[i]));\n-    }\n }\n \n impl<K:Hash + Eq,V> Container for HashMap<K, V> {\n@@ -675,28 +672,6 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     fn is_superset(&self, other: &HashSet<T>) -> bool {\n         other.is_subset(self)\n     }\n-\n-    /// Visit the values representing the difference\n-    fn difference(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n-        self.difference_iter(other).advance(f)\n-    }\n-\n-    /// Visit the values representing the symmetric difference\n-    fn symmetric_difference(&self,\n-                            other: &HashSet<T>,\n-                            f: &fn(&T) -> bool) -> bool {\n-        self.symmetric_difference_iter(other).advance(f)\n-    }\n-\n-    /// Visit the values representing the intersection\n-    fn intersection(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n-        self.intersection_iter(other).advance(f)\n-    }\n-\n-    /// Visit the values representing the union\n-    fn union(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n-        self.union_iter(other).advance(f)\n-    }\n }\n \n impl<T:Hash + Eq> MutableSet<T> for HashSet<T> {"}, {"sha": "153286a311a9c42b02231fd337607ea0a2ce14b2", "filename": "src/libstd/io.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -770,9 +770,10 @@ impl<T:Reader> ReaderUtil for T {\n \n     fn read_lines(&self) -> ~[~str] {\n         do vec::build |push| {\n-            for self.each_line |line| {\n+            do self.each_line |line| {\n                 push(line.to_owned());\n-            }\n+                true\n+            };\n         }\n     }\n \n@@ -1880,16 +1881,16 @@ mod tests {\n \n         {\n             let file = io::file_reader(&path).unwrap();\n-            for file.each_byte() |_| {\n-                fail!(\"must be empty\");\n-            }\n+            do file.each_byte() |_| {\n+                fail!(\"must be empty\")\n+            };\n         }\n \n         {\n             let file = io::file_reader(&path).unwrap();\n-            for file.each_char() |_| {\n-                fail!(\"must be empty\");\n-            }\n+            do file.each_char() |_| {\n+                fail!(\"must be empty\")\n+            };\n         }\n     }\n "}, {"sha": "ce528bc95225584a9b2bc1f4cdf27e93d0015c69", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -14,13 +14,13 @@\n use iter::Times;\n let ten = 10 as uint;\n let mut accum = 0;\n-for ten.times { accum += 1; }\n+do ten.times { accum += 1; }\n ~~~\n \n */\n \n #[allow(missing_doc)]\n pub trait Times {\n-    fn times(&self, it: &fn() -> bool) -> bool;\n+    fn times(&self, it: &fn());\n }\n "}, {"sha": "013901d57f80e4f83e095d56f92b033b1069878c", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -18,7 +18,6 @@ implementing the `Iterator` trait.\n */\n \n use cmp;\n-use iter::Times;\n use num::{Zero, One};\n use option::{Option, Some, None};\n use ops::{Add, Mul};\n@@ -1229,8 +1228,9 @@ impl<A, T: Iterator<A>> Iterator<A> for Skip<T> {\n         if self.n == 0 {\n             next\n         } else {\n-            let n = self.n;\n-            for n.times {\n+            let mut n = self.n;\n+            while n > 0 {\n+                n -= 1;\n                 match next {\n                     Some(_) => {\n                         next = self.iter.next();"}, {"sha": "275a72d6ecc051089a58c182dd099fd87e578769", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -97,22 +97,21 @@ pub fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n impl iter::Times for uint {\n     #[inline]\n     ///\n-    /// A convenience form for basic iteration. Given a uint `x`,\n-    /// `for x.times { ... }` executes the given block x times.\n+    /// A convenience form for basic repetition. Given a uint `x`,\n+    /// `do x.times { ... }` executes the given block x times.\n     ///\n     /// Equivalent to `for uint::range(0, x) |_| { ... }`.\n     ///\n     /// Not defined on all integer types to permit unambiguous\n     /// use with integer literals of inferred integer-type as\n-    /// the self-value (eg. `for 100.times { ... }`).\n+    /// the self-value (eg. `do 100.times { ... }`).\n     ///\n-    fn times(&self, it: &fn() -> bool) -> bool {\n+    fn times(&self, it: &fn()) {\n         let mut i = *self;\n         while i > 0 {\n-            if !it() { return false; }\n+            it();\n             i -= 1;\n         }\n-        return true;\n     }\n }\n \n@@ -190,6 +189,6 @@ pub fn test_times() {\n     use iter::Times;\n     let ten = 10 as uint;\n     let mut accum = 0;\n-    for ten.times { accum += 1; }\n+    do ten.times { accum += 1; }\n     assert!((accum == 10));\n }"}, {"sha": "1bfae8c40e16f90aa00b0bd3c16d70fecfd8972e", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -790,7 +790,7 @@ pub fn list_dir_path(p: &Path) -> ~[Path] {\n /// all its contents. Use carefully!\n pub fn remove_dir_recursive(p: &Path) -> bool {\n     let mut error_happened = false;\n-    for walk_dir(p) |inner| {\n+    do walk_dir(p) |inner| {\n         if !error_happened {\n             if path_is_dir(inner) {\n                 if !remove_dir_recursive(inner) {\n@@ -803,6 +803,7 @@ pub fn remove_dir_recursive(p: &Path) -> bool {\n                 }\n             }\n         }\n+        true\n     };\n     // Directory should now be empty\n     !error_happened && remove_dir(p)"}, {"sha": "9134d2da25785098ccdf86653538d0d203591d1b", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -695,7 +695,7 @@ impl IsaacRng {\n             }}\n         );\n \n-        for 4.times { mix!(); }\n+        do 4.times { mix!(); }\n \n         if use_rsl {\n             macro_rules! memloop (\n@@ -1092,15 +1092,15 @@ mod test {\n         }\n \n         // run against several seeds\n-        for 10.times {\n+        do 10.times {\n             unsafe {\n                 let seed = super::seed();\n                 let rt_rng = do seed.as_imm_buf |p, sz| {\n                     rustrt::rand_new_seeded(p, sz as size_t)\n                 };\n                 let mut rng = IsaacRng::new_seeded(seed);\n \n-                for 10000.times {\n+                do 10000.times {\n                     assert_eq!(rng.next(), rustrt::rand_next(rt_rng));\n                 }\n                 rustrt::rand_free(rt_rng);"}, {"sha": "79ee8405531ac820971da8f6473c0f559fc8cbcc", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -769,7 +769,7 @@ mod test {\n \n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n-        for stress_factor().times {\n+        do stress_factor().times {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n                 let port_cell = Cell::new(port);\n@@ -784,7 +784,7 @@ mod test {\n \n     #[test]\n     fn oneshot_multi_thread_send_close_stress() {\n-        for stress_factor().times {\n+        do stress_factor().times {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n                 let chan_cell = Cell::new(chan);\n@@ -804,7 +804,7 @@ mod test {\n \n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n-        for stress_factor().times {\n+        do stress_factor().times {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n                 let chan_cell = Cell::new(chan);\n@@ -830,7 +830,7 @@ mod test {\n \n     #[test]\n     fn oneshot_multi_thread_send_recv_stress() {\n-        for stress_factor().times {\n+        do stress_factor().times {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<~int>();\n                 let chan_cell = Cell::new(chan);\n@@ -849,7 +849,7 @@ mod test {\n \n     #[test]\n     fn stream_send_recv_stress() {\n-        for stress_factor().times {\n+        do stress_factor().times {\n             do run_in_mt_newsched_task {\n                 let (port, chan) = stream::<~int>();\n \n@@ -886,8 +886,8 @@ mod test {\n         // Regression test that we don't run out of stack in scheduler context\n         do run_in_newsched_task {\n             let (port, chan) = stream();\n-            for 10000.times { chan.send(()) }\n-            for 10000.times { port.recv() }\n+            do 10000.times { chan.send(()) }\n+            do 10000.times { port.recv() }\n         }\n     }\n \n@@ -897,14 +897,14 @@ mod test {\n             let (port, chan) = stream();\n             let chan = SharedChan::new(chan);\n             let total = stress_factor() + 100;\n-            for total.times {\n+            do total.times {\n                 let chan_clone = chan.clone();\n                 do spawntask_random {\n                     chan_clone.send(());\n                 }\n             }\n \n-            for total.times {\n+            do total.times {\n                 port.recv();\n             }\n         }\n@@ -919,7 +919,7 @@ mod test {\n             let end_chan = SharedChan::new(end_chan);\n             let port = SharedPort::new(port);\n             let total = stress_factor() + 100;\n-            for total.times {\n+            do total.times {\n                 let end_chan_clone = end_chan.clone();\n                 let port_clone = port.clone();\n                 do spawntask_random {\n@@ -928,11 +928,11 @@ mod test {\n                 }\n             }\n \n-            for total.times {\n+            do total.times {\n                 chan.send(());\n             }\n \n-            for total.times {\n+            do total.times {\n                 end_port.recv();\n             }\n         }\n@@ -959,7 +959,7 @@ mod test {\n             let send_total = 10;\n             let recv_total = 20;\n             do spawntask_random {\n-                for send_total.times {\n+                do send_total.times {\n                     let chan_clone = chan.clone();\n                     do spawntask_random {\n                         chan_clone.send(());\n@@ -968,7 +968,7 @@ mod test {\n             }\n             let end_chan_clone = end_chan.clone();\n             do spawntask_random {\n-                for recv_total.times {\n+                do recv_total.times {\n                     let port_clone = port.clone();\n                     let end_chan_clone = end_chan_clone.clone();\n                     do spawntask_random {\n@@ -979,7 +979,7 @@ mod test {\n             }\n \n             let mut recvd = 0;\n-            for recv_total.times {\n+            do recv_total.times {\n                 recvd += if end_port.recv() { 1 } else { 0 };\n             }\n \n@@ -998,23 +998,23 @@ mod test {\n             let pipe = megapipe();\n             let total = stress_factor() + 10;\n             let mut rng = rand::rng();\n-            for total.times {\n+            do total.times {\n                 let msgs = rng.gen_uint_range(0, 10);\n                 let pipe_clone = pipe.clone();\n                 let end_chan_clone = end_chan.clone();\n                 do spawntask_random {\n-                    for msgs.times {\n+                    do msgs.times {\n                         pipe_clone.send(());\n                     }\n-                    for msgs.times {\n+                    do msgs.times {\n                         pipe_clone.recv();\n                     }\n                 }\n \n                 end_chan_clone.send(());\n             }\n \n-            for total.times {\n+            do total.times {\n                 end_port.recv();\n             }\n         }"}, {"sha": "1d7dafc4302488eb4d702815b7c32d801bb1548c", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -371,7 +371,7 @@ mod test {\n \n             do spawntask_immediately {\n                 let mut listener = TcpListener::bind(addr);\n-                for max.times {\n+                do max.times {\n                     let mut stream = listener.accept();\n                     let mut buf = [0];\n                     stream.read(buf);\n@@ -380,7 +380,7 @@ mod test {\n             }\n \n             do spawntask_immediately {\n-                for max.times {\n+                do max.times {\n                     let mut stream = TcpStream::connect(addr);\n                     stream.write([99]);\n                 }\n@@ -396,7 +396,7 @@ mod test {\n \n             do spawntask_immediately {\n                 let mut listener = TcpListener::bind(addr);\n-                for max.times {\n+                do max.times {\n                     let mut stream = listener.accept();\n                     let mut buf = [0];\n                     stream.read(buf);\n@@ -405,7 +405,7 @@ mod test {\n             }\n \n             do spawntask_immediately {\n-                for max.times {\n+                do max.times {\n                     let mut stream = TcpStream::connect(addr);\n                     stream.write([99]);\n                 }"}, {"sha": "3bcf67878245916ba1405435c941aed029a66bea", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -255,7 +255,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     // sent the Shutdown message to terminate the schedulers.\n     let mut handles = ~[];\n \n-    for nscheds.times {\n+    do nscheds.times {\n         // Every scheduler is driven by an I/O event loop.\n         let loop_ = ~UvEventLoop::new();\n         let mut sched = ~Scheduler::new(loop_, work_queue.clone(), sleepers.clone());"}, {"sha": "ae4ca2b978357f12850da8dab8dd05dfa89625bb", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -1097,7 +1097,7 @@ mod test {\n \n         do run_in_mt_newsched_task {\n             let mut ports = ~[];\n-            for 10.times {\n+            do 10.times {\n                 let (port, chan) = oneshot();\n                 let chan_cell = Cell::new(chan);\n                 do spawntask_later {"}, {"sha": "b19357fa2219f5a32fc0078a094353d6d2b7156c", "filename": "src/libstd/rt/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -53,8 +53,8 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n     do sched.deschedule_running_task_and_then |sched, task| {\n         let task_handles = task.make_selectable(ports.len());\n \n-        for ports.mut_iter().zip(task_handles.consume_iter()).enumerate().advance\n-                |(index, (port, task_handle))| {\n+        foreach (index, (port, task_handle)) in\n+                ports.mut_iter().zip(task_handles.consume_iter()).enumerate() {\n             // If one of the ports has data by now, it will wake the handle.\n             if port.block_on(sched, task_handle) {\n                 ready_index = index;\n@@ -187,7 +187,7 @@ mod test {\n         do run_in_newsched_task {\n             let (ports, _) = unzip(from_fn(10, |_| stream()));\n             let (port, chan) = stream();\n-            for 10.times { chan.send(31337); }\n+            do 10.times { chan.send(31337); }\n             let mut ports = ports;\n             let mut port = Some(port);\n             let order = [5u,0,4,3,2,6,9,8,7,1];\n@@ -268,7 +268,7 @@ mod test {\n \n             do run_in_newsched_task {\n                 // A bit of stress, since ordinarily this is just smoke and mirrors.\n-                for 4.times {\n+                do 4.times {\n                     let send_on_chans = send_on_chans.clone();\n                     do task::spawn {\n                         let mut ports = ~[];"}, {"sha": "cc516fb559ea8babc701a824cdee94641073ef8f", "filename": "src/libstd/stackwalk.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstackwalk.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -25,7 +25,7 @@ pub fn Frame(fp: *Word) -> Frame {\n     }\n }\n \n-pub fn walk_stack(visit: &fn(Frame) -> bool) -> bool {\n+pub fn walk_stack(visit: &fn(Frame)) {\n \n     debug!(\"beginning stack walk\");\n \n@@ -51,12 +51,11 @@ pub fn walk_stack(visit: &fn(Frame) -> bool) -> bool {\n             }\n         }\n     }\n-    return true;\n }\n \n #[test]\n fn test_simple() {\n-    for walk_stack |_frame| {\n+    do walk_stack |_frame| {\n     }\n }\n \n@@ -65,7 +64,7 @@ fn test_simple_deep() {\n     fn run(i: int) {\n         if i == 0 { return }\n \n-        for walk_stack |_frame| {\n+        do walk_stack |_frame| {\n             // Would be nice to test something here...\n         }\n         run(i - 1);"}, {"sha": "f0c0595744c956f85df4571acffa889dbb52fff9", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -1828,7 +1828,7 @@ impl<'self> StrSlice<'self> for &'self str {\n                 do ret.as_mut_buf |rbuf, _len| {\n                     let mut rbuf = rbuf;\n \n-                    for nn.times {\n+                    do nn.times {\n                         ptr::copy_memory(rbuf, buf, len);\n                         rbuf = rbuf.offset(len as int);\n                     }"}, {"sha": "d0124407bd4a22efa1a1343ade8ab55d03455457", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -683,7 +683,7 @@ fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n         let ch = ch.clone();\n         do spawn_unlinked {\n             // Give middle task a chance to fail-but-not-kill-us.\n-            for 16.times { task::yield(); }\n+            do 16.times { task::yield(); }\n             ch.send(()); // If killed first, grandparent hangs.\n         }\n         fail!(); // Shouldn't kill either (grand)parent or (grand)child.\n@@ -698,7 +698,7 @@ fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n     do spawn_supervised { fail!(); }\n     // Give child a chance to fail-but-not-kill-us.\n-    for 16.times { task::yield(); }\n+    do 16.times { task::yield(); }\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_sup_fail_down() {\n@@ -760,7 +760,7 @@ fn test_spawn_failure_propagate_grandchild() {\n     do spawn_supervised {\n         do spawn_supervised { block_forever(); }\n     }\n-    for 16.times { task::yield(); }\n+    do 16.times { task::yield(); }\n     fail!();\n }\n \n@@ -770,7 +770,7 @@ fn test_spawn_failure_propagate_secondborn() {\n     do spawn_supervised {\n         do spawn { block_forever(); } // linked\n     }\n-    for 16.times { task::yield(); }\n+    do 16.times { task::yield(); }\n     fail!();\n }\n \n@@ -780,7 +780,7 @@ fn test_spawn_failure_propagate_nephew_or_niece() {\n     do spawn { // linked\n         do spawn_supervised { block_forever(); }\n     }\n-    for 16.times { task::yield(); }\n+    do 16.times { task::yield(); }\n     fail!();\n }\n \n@@ -790,7 +790,7 @@ fn test_spawn_linked_sup_propagate_sibling() {\n     do spawn { // linked\n         do spawn { block_forever(); } // linked\n     }\n-    for 16.times { task::yield(); }\n+    do 16.times { task::yield(); }\n     fail!();\n }\n \n@@ -970,7 +970,7 @@ fn test_spawn_sched_blocking() {\n \n         // Testing that a task in one scheduler can block in foreign code\n         // without affecting other schedulers\n-        for 20u.times {\n+        do 20u.times {\n             let (start_po, start_ch) = stream();\n             let (fin_po, fin_ch) = stream();\n \n@@ -1076,7 +1076,7 @@ fn test_unkillable() {\n \n     // We want to do this after failing\n     do spawn_unlinked {\n-        for 10.times { yield() }\n+        do 10.times { yield() }\n         ch.send(());\n     }\n \n@@ -1111,7 +1111,7 @@ fn test_unkillable_nested() {\n \n     // We want to do this after failing\n     do spawn_unlinked || {\n-        for 10.times { yield() }\n+        do 10.times { yield() }\n         ch.send(());\n     }\n "}, {"sha": "4558f8e32c1e1ed8b3cc497b4ef579a8b47d6612", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -372,8 +372,9 @@ impl Drop for Taskgroup {\n                 // with our own taskgroup, so long as both happen before we die.\n                 // We remove ourself from every ancestor we can, so no cleanup; no\n                 // break.\n-                for each_ancestor(&mut this.ancestors, |_| {}) |ancestor_group| {\n+                do each_ancestor(&mut this.ancestors, |_| {}) |ancestor_group| {\n                     leave_taskgroup(ancestor_group, &me, false);\n+                    true\n                 };\n             }\n         }"}, {"sha": "5ad7969c8d21facf3de7600b100d390dc1deb470", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -353,9 +353,10 @@ pub trait ToBytes {\n impl<A:IterBytes> ToBytes for A {\n     fn to_bytes(&self, lsb0: bool) -> ~[u8] {\n         do io::with_bytes_writer |wr| {\n-            for self.iter_bytes(lsb0) |bytes| {\n-                wr.write(bytes)\n-            }\n+            do self.iter_bytes(lsb0) |bytes| {\n+                wr.write(bytes);\n+                true\n+            };\n         }\n     }\n }"}, {"sha": "f60093ce48c6c9ac3ddf03f645028bbd293c4070", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -459,11 +459,12 @@ mod test_map {\n         assert!(m.insert(1, 2));\n \n         let mut n = 0;\n-        for m.each |k, v| {\n+        do m.each |k, v| {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n += 1;\n-        }\n+            true\n+        };\n     }\n \n     #[test]\n@@ -475,14 +476,16 @@ mod test_map {\n         }\n \n         let mut n = uint::max_value - 10000;\n-        for m.each |k, v| {\n-            if n == uint::max_value - 5000 { break }\n-            assert!(n < uint::max_value - 5000);\n-\n-            assert_eq!(*k, n);\n-            assert_eq!(*v, n / 2);\n-            n += 1;\n-        }\n+        do m.each |k, v| {\n+            if n == uint::max_value - 5000 { false } else {\n+                assert!(n < uint::max_value - 5000);\n+\n+                assert_eq!(*k, n);\n+                assert_eq!(*v, n / 2);\n+                n += 1;\n+                true\n+            }\n+        };\n     }\n \n     #[test]\n@@ -496,11 +499,12 @@ mod test_map {\n         assert!(m.insert(1, 2));\n \n         let mut n = 4;\n-        for m.each_reverse |k, v| {\n+        do m.each_reverse |k, v| {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n -= 1;\n-        }\n+            true\n+        };\n     }\n \n     #[test]\n@@ -512,14 +516,16 @@ mod test_map {\n         }\n \n         let mut n = uint::max_value - 1;\n-        for m.each_reverse |k, v| {\n-            if n == uint::max_value - 5000 { break }\n-            assert!(n > uint::max_value - 5000);\n-\n-            assert_eq!(*k, n);\n-            assert_eq!(*v, n / 2);\n-            n -= 1;\n-        }\n+        do m.each_reverse |k, v| {\n+            if n == uint::max_value - 5000 { false } else {\n+                assert!(n > uint::max_value - 5000);\n+\n+                assert_eq!(*k, n);\n+                assert_eq!(*v, n / 2);\n+                n -= 1;\n+                true\n+            }\n+        };\n     }\n \n     #[test]\n@@ -572,10 +578,11 @@ mod test_set {\n \n         let mut i = 0;\n \n-        for trie.each |x| {\n+        do trie.each |x| {\n             assert_eq!(expected[i], *x);\n             i += 1;\n-        }\n+            true\n+        };\n     }\n \n     #[test]"}, {"sha": "5417af50081318282126e2de2e624624b7149ca3", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -636,7 +636,7 @@ pub mod rt {\n                 buf.push_char(c);\n             }\n             buf.push_str(s);\n-            for diff.times {\n+            do diff.times {\n                 buf.push_char(padchar);\n             }\n             return;"}, {"sha": "f5c82bad2b1d486f4b8114b42abba1c18f920f73", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -626,7 +626,7 @@ mod tests {\n             let x = Exclusive::new(~~\"hello\");\n             let x2 = x.clone();\n             do task::spawn {\n-                for 10.times { task::yield(); } // try to let the unwrapper go\n+                do 10.times { task::yield(); } // try to let the unwrapper go\n                 fail!(); // punt it awake from its deadlock\n             }\n             let _z = x.unwrap();"}, {"sha": "6cff9ce84cf18643bb5a16b004a0afa47d5bd110", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -2767,19 +2767,19 @@ mod tests {\n         let mut results: ~[~[int]];\n \n         results = ~[];\n-        for each_permutation([]) |v| { results.push(v.to_owned()); }\n+        do each_permutation([]) |v| { results.push(v.to_owned()); true };\n         assert_eq!(results, ~[~[]]);\n \n         results = ~[];\n-        for each_permutation([7]) |v| { results.push(v.to_owned()); }\n+        do each_permutation([7]) |v| { results.push(v.to_owned()); true };\n         assert_eq!(results, ~[~[7]]);\n \n         results = ~[];\n-        for each_permutation([1,1]) |v| { results.push(v.to_owned()); }\n+        do each_permutation([1,1]) |v| { results.push(v.to_owned()); true };\n         assert_eq!(results, ~[~[1,1],~[1,1]]);\n \n         results = ~[];\n-        for each_permutation([5,2,0]) |v| { results.push(v.to_owned()); }\n+        do each_permutation([5,2,0]) |v| { results.push(v.to_owned()); true };\n         assert!(results ==\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]]);\n     }\n@@ -3107,12 +3107,13 @@ mod tests {\n     fn test_permute_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        for each_permutation(v) |_elt| {\n+        do each_permutation(v) |_elt| {\n             if i == 2 {\n                 fail!()\n             }\n             i += 0;\n-        }\n+            true\n+        };\n     }\n \n     #[test]\n@@ -3425,39 +3426,43 @@ mod tests {\n     fn test_permutations0() {\n         let values = [];\n         let mut v : ~[~[int]] = ~[];\n-        for each_permutation(values) |p| {\n+        do each_permutation(values) |p| {\n             v.push(p.to_owned());\n-        }\n+            true\n+        };\n         assert_eq!(v, ~[~[]]);\n     }\n \n     #[test]\n     fn test_permutations1() {\n         let values = [1];\n         let mut v : ~[~[int]] = ~[];\n-        for each_permutation(values) |p| {\n+        do each_permutation(values) |p| {\n             v.push(p.to_owned());\n-        }\n+            true\n+        };\n         assert_eq!(v, ~[~[1]]);\n     }\n \n     #[test]\n     fn test_permutations2() {\n         let values = [1,2];\n         let mut v : ~[~[int]] = ~[];\n-        for each_permutation(values) |p| {\n+        do each_permutation(values) |p| {\n             v.push(p.to_owned());\n-        }\n+            true\n+        };\n         assert_eq!(v, ~[~[1,2],~[2,1]]);\n     }\n \n     #[test]\n     fn test_permutations3() {\n         let values = [1,2,3];\n         let mut v : ~[~[int]] = ~[];\n-        for each_permutation(values) |p| {\n+        do each_permutation(values) |p| {\n             v.push(p.to_owned());\n-        }\n+            true\n+        };\n         assert_eq!(v, ~[~[1,2,3],~[1,3,2],~[2,1,3],~[2,3,1],~[3,1,2],~[3,2,1]]);\n     }\n "}, {"sha": "0fb28596e11ba78c8ac14458ca9a2c22f76d33ef", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -302,7 +302,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line.\n         let skip = fm.name.len() + digits + 3u;\n-        for skip.times() {\n+        do skip.times() {\n             s.push_char(' ');\n         }\n         let orig = fm.get_line(lines.lines[0] as int);\n@@ -323,7 +323,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n             let num_squigglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n-            for num_squigglies.times() {\n+            do num_squigglies.times() {\n                 s.push_char('~')\n             }\n         }"}, {"sha": "ad26d7b3f7eab8459689ab96022f6be48ebbffa1", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -403,7 +403,7 @@ pub fn parse(\n                 }\n                 cur_eis.push(ei);\n \n-                for rust_parser.tokens_consumed.times() || {\n+                do rust_parser.tokens_consumed.times() || {\n                     rdr.next_token();\n                 }\n             }"}, {"sha": "7a11a93abc5494b8c6d4e73d196b6d235b0c5549", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -59,7 +59,7 @@ impl Results {\n         {\n             let mut set = f();\n             do timed(&mut self.random_ints) {\n-                for num_keys.times {\n+                do num_keys.times {\n                     set.insert((rng.next() as uint) % rand_cap);\n                 }\n             }\n@@ -103,7 +103,7 @@ impl Results {\n         {\n             let mut set = f();\n             do timed(&mut self.random_strings) {\n-                for num_keys.times {\n+                do num_keys.times {\n                     let s = uint::to_str(rng.next() as uint);\n                     set.insert(s);\n                 }"}, {"sha": "e25f1bdfa78055da52ffa9643b9f80214a53e8bb", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -105,7 +105,7 @@ fn main() {\n     let symbols = [\" \", \"\u2591\", \"\u2592\", \"\u2593\", \"\u2588\", \"\u2588\"];\n     let mut pixels = [0f32, ..256*256];\n     let n2d = ~Noise2DContext::new();\n-    for 100.times {\n+    do 100.times {\n         for int::range(0, 256) |y| {\n             for int::range(0, 256) |x| {\n                 let v = n2d.get("}, {"sha": "4ad96a21b88d29a0b815eeae5697f82ff8c5410f", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -169,7 +169,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n     let mut creatures_met = 0;\n \n     // set up meetings...\n-    for nn.times {\n+    do nn.times {\n         let fst_creature: CreatureInfo = from_creatures.recv();\n         let snd_creature: CreatureInfo = from_creatures.recv();\n "}, {"sha": "f7b66e9e1458f5a5f60dc4bdb2beede6c5943614", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -164,7 +164,7 @@ impl RandomFasta {\n             let chars_left = n % LINE_LEN;\n             let mut buf = [0, ..LINE_LEN + 1];\n \n-            for lines.times {\n+            do lines.times {\n                 for range(0, LINE_LEN) |i| {\n                     buf[i] = self.nextc();\n                 }"}, {"sha": "69d173c8070266315bc9f8f58fee03c52df2b427", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -54,7 +54,7 @@ impl Code {\n     fn unpack(&self, frame: i32) -> ~str {\n         let mut key = **self;\n         let mut result = ~[];\n-        for (frame as uint).times {\n+        do (frame as uint).times {\n             result.push(unpack_symbol((key as u8) & 3));\n             key >>= 2;\n         }\n@@ -251,7 +251,7 @@ fn generate_frequencies(frequencies: &mut Table,\n     let mut code = Code(0);\n \n     // Pull first frame.\n-    for (frame as uint).times {\n+    do (frame as uint).times {\n         code = code.push_char(input[0]);\n         input = next_char(input);\n     }"}, {"sha": "930439fe7f08bc03f4e1ad57b1656371f1e8cfae", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -30,7 +30,7 @@ fn main() {\n                 let Cr = 2.0 * (x as f64) / (w as f64) - 1.5;\n                 let Ci = 2.0 * (y as f64) / (h as f64) - 1.0;\n \n-                for ITER.times {\n+                for range(0, ITER as i32) |_| {\n                     if Tr + Ti > LIMIT * LIMIT {\n                         break;\n                     }"}, {"sha": "b294ca8f282c64b94ee978069e60d652dc4dce3b", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -80,7 +80,7 @@ struct Planet {\n \n fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: i32) {\n     let mut d = [ 0.0, ..3 ];\n-    for (steps as uint).times {\n+    do (steps as uint).times {\n         for range(0, N_BODIES) |i| {\n             for range(i + 1, N_BODIES) |j| {\n                 d[0] = bodies[i].x[0] - bodies[j].x[0];"}, {"sha": "5187d0352985a1a15bc37592cc3a7f7a11cf6633", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -56,7 +56,7 @@ fn main() {\n     let mut u = vec::from_elem(n, 1f64);\n     let mut v = u.clone();\n     let mut tmp = u.clone();\n-    for 8.times {\n+    do 8.times {\n         mult_AtAv(u, v, tmp);\n         mult_AtAv(v, u, tmp);\n     }"}, {"sha": "ca539d712fdefb726cc41082f7524fe2a4d53d89", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -32,7 +32,7 @@ fn main() {\n }\n \n fn run(repeat: int, depth: int) {\n-    for (repeat as uint).times {\n+    do (repeat as uint).times {\n         info!(\"starting %.4f\", precise_time_s());\n         do task::try {\n             recurse_or_fail(depth, None)"}, {"sha": "6ab83e5b3830b632b3d0474e5672c8ebfac0b918", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -32,7 +32,7 @@ fn grandchild_group(num_tasks: uint) {\n     let (po, ch) = stream();\n     let ch = SharedChan::new(ch);\n \n-    for num_tasks.times {\n+    do num_tasks.times {\n         let ch = ch.clone();\n         do task::spawn { // linked\n             ch.send(());\n@@ -41,7 +41,7 @@ fn grandchild_group(num_tasks: uint) {\n         }\n     }\n     error!(\"Grandchild group getting started\");\n-    for num_tasks.times {\n+    do num_tasks.times {\n         // Make sure all above children are fully spawned; i.e., enlisted in\n         // their ancestor groups.\n         po.recv();"}, {"sha": "642e4653cd0239d3065ef1efdcce824001c78ba1", "filename": "src/test/compile-fail/borrowck-lend-flow-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -40,7 +40,7 @@ fn block_overarching_alias_mut() {\n \n     let mut v = ~3;\n     let mut x = &mut v;\n-    for 3.times {\n+    do 3.times {\n         borrow(v); //~ ERROR cannot borrow\n     }\n     *x = ~5;"}, {"sha": "bcd8e86d1d3bb18fb0e4a3e7a4fee6c76fca3e00", "filename": "src/test/compile-fail/issue-3651-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fcompile-fail%2Fissue-3651-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fcompile-fail%2Fissue-3651-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3651-2.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -9,5 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    do 5.times {}; //~ ERROR Do-block body must return bool, but returns () here. Perhaps\n+    fn take_block(f: &fn() -> bool) -> bool { f() }\n+    do take_block {}; //~ ERROR Do-block body must return bool, but returns () here. Perhaps\n }"}, {"sha": "5570562cf8b0040be00377f5277bf7294a652fe2", "filename": "src/test/compile-fail/lint-deprecated-for-loop.rs", "status": "renamed", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fcompile-fail%2Flint-deprecated-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Fcompile-fail%2Flint-deprecated-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-deprecated-for-loop.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n+#[forbid(deprecated_for_loop)];\n+\n+fn f(_: &fn() -> bool) -> bool {\n+    true\n+}\n+\n fn main() {\n-    for 2.times {  //~ ERROR A for-loop body must return (), but\n-        true\n-    }\n+    for f {} //~ ERROR `for` is deprecated\n }", "previous_filename": "src/test/compile-fail/block-must-not-have-result-for.rs"}, {"sha": "a281e9863649eb4455ea30c7496262dab4d02753", "filename": "src/test/run-fail/extern-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fextern-fail.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -40,7 +40,7 @@ fn count(n: uint) -> uint {\n }\n \n fn main() {\n-    for 10u.times {\n+    do 10u.times {\n         do task::spawn {\n             let result = count(5u);\n             info!(\"result = %?\", result);"}, {"sha": "b57e179f4a9af709155d39ca87fd1d7e1a863b52", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -13,11 +13,10 @@\n extern mod extra;\n use extra::bitv::*;\n \n-fn bitv_test() -> bool {\n+fn bitv_test() {\n     let mut v1 = ~Bitv::new(31, false);\n     let v2 = ~Bitv::new(31, true);\n     v1.union(v2);\n-    true\n }\n \n pub fn main() {"}, {"sha": "c282860957a1f13b6f5f3af6be36f7b191d944fc", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -69,7 +69,7 @@ pub fn main() {\n     roundtrip::<C>();\n     roundtrip::<D>();\n \n-    for 20.times {\n+    do 20.times {\n         roundtrip::<E>();\n         roundtrip::<F>();\n         roundtrip::<G<int>>();"}, {"sha": "65bfc14406fc49e651072b0c2453b797b0290fdf", "filename": "src/test/run-pass/deriving-rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-rand.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -32,7 +32,7 @@ enum D {\n \n fn main() {\n     // check there's no segfaults\n-    for 20.times {\n+    do 20.times {\n         rand::random::<A>();\n         rand::random::<B>();\n         rand::random::<C>();"}, {"sha": "4574fbc1ff0cdbc0cf11a8ef2d06e847d57a15fa", "filename": "src/test/run-pass/extern-stress.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-stress.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -39,7 +39,7 @@ fn count(n: uint) -> uint {\n }\n \n pub fn main() {\n-    for 100u.times {\n+    do 100u.times {\n         do task::spawn {\n             assert_eq!(count(5u), 16u);\n         };"}, {"sha": "4722eeea3d7ccfee718b23a595d8097fc32f02fb", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -36,7 +36,7 @@ fn count(n: uint) -> uint {\n }\n \n pub fn main() {\n-    for 10u.times {\n+    do 10u.times {\n         do task::spawn {\n             let result = count(5u);\n             info!(\"result = %?\", result);"}, {"sha": "b86ad6d56f826dbc5f92e6d1e521ec10d71917c9", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -65,13 +65,14 @@ fn square_from_char(c: char) -> square {\n fn read_board_grid<rdr:'static + io::Reader>(input: rdr) -> ~[~[square]] {\n     let input = @input as @io::Reader;\n     let mut grid = ~[];\n-    for input.each_line |line| {\n+    do input.each_line |line| {\n         let mut row = ~[];\n         foreach c in line.iter() {\n             row.push(square_from_char(c))\n         }\n-        grid.push(row)\n-    }\n+        grid.push(row);\n+        true\n+    };\n     let width = grid[0].len();\n     foreach row in grid.iter() { assert!(row.len() == width) }\n     grid"}, {"sha": "49ed6de0c99992235c778170d0730e6ca442bb18", "filename": "src/test/run-pass/issue-3211.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fissue-3211.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fissue-3211.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3211.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -1,6 +1,6 @@\n pub fn main() {\n     let mut x = 0;\n-    for 4096.times {\n+    do 4096.times {\n         x += 1;\n     }\n     assert_eq!(x, 4096);"}, {"sha": "5d8405ce43336a0c9906cfdbe561e7c18ea8cada", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -68,7 +68,7 @@ fn AsciiArt(width: uint, height: uint, fill: char) -> AsciiArt {\n     // Use an anonymous function to build a vector of vectors containing\n     // blank characters for each position in our canvas.\n     let mut lines = do vec::build_sized(height) |push| {\n-            for height.times {\n+            do height.times {\n                 push(vec::from_elem(width, '.'));\n             }\n         };"}, {"sha": "f9b374e7cd21b0a693bd80d15e2d2b739b040431", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -45,7 +45,7 @@ priv fn parse_data(len: uint, io: @io::Reader) -> Result {\n \n priv fn parse_list(len: uint, io: @io::Reader) -> Result {\n   let mut list: ~[Result] = ~[];\n-    for len.times {\n+    do len.times {\n     let v =\n         match io.read_char() {\n         '$' => parse_bulk(io),"}, {"sha": "99250c4c8a24a747c90fb922ebf04108ea27216d", "filename": "src/test/run-pass/issue-4401.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fissue-4401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fissue-4401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4401.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -1,6 +1,6 @@\n pub fn main() {\n     let mut count = 0;\n-    for 999_999.times() {\n+    do 999_999.times() {\n         count += 1;\n     }\n     assert_eq!(count, 999_999);"}, {"sha": "3f4b732af32764f628bf341c11623f4c1a3ce3c4", "filename": "src/test/run-pass/issue-5321-immediates-with-bare-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fissue-5321-immediates-with-bare-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fissue-5321-immediates-with-bare-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5321-immediates-with-bare-self.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -14,7 +14,7 @@ trait Fooable {\n \n impl Fooable for uint {\n     fn yes(self) {\n-        for self.times {\n+        do self.times {\n             println(\"yes\");\n         }\n     }"}, {"sha": "569ccf5335ea037cded12a353d5671c2f6e1f286", "filename": "src/test/run-pass/numeric-method-autoexport.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -32,7 +32,7 @@ pub fn main() {\n     assert_eq!(15u64.add(&6u64), 21u64);\n \n     // times\n-     15u.times(|| false);\n+     15u.times(|| {});\n \n // floats\n     // num"}, {"sha": "7c90b38bae1c9f6686c99216d51614cd25987c0b", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b24559e6aa0914f8a49e0a9dbfb3cf35372515/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=82b24559e6aa0914f8a49e0a9dbfb3cf35372515", "patch": "@@ -266,7 +266,7 @@ fn more_floats() {\n }\n \n fn pointer() {\n-    for 10.times {\n+    do 10.times {\n         let x: uint = ::std::rand::random();\n         assert_eq!(fmt!(\"%p\", x as *uint), fmt!(\"0x%x\", x));\n     }"}]}