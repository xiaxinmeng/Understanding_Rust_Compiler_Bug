{"sha": "88f0a105789d9d9cec4e89898109fb95238cc416", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZjBhMTA1Nzg5ZDlkOWNlYzRlODk4OTgxMDlmYjk1MjM4Y2M0MTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-08T03:51:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-08T03:51:36Z"}, "message": "auto merge of #5277 : bstrie/rust/deimpselfstd, r=brson", "tree": {"sha": "e51fdcd18ff73e1b9ba4515ea98b3eb37cd429fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e51fdcd18ff73e1b9ba4515ea98b3eb37cd429fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88f0a105789d9d9cec4e89898109fb95238cc416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88f0a105789d9d9cec4e89898109fb95238cc416", "html_url": "https://github.com/rust-lang/rust/commit/88f0a105789d9d9cec4e89898109fb95238cc416", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88f0a105789d9d9cec4e89898109fb95238cc416/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfba0c7f990948612b65e783da1bd9e9ff995835", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfba0c7f990948612b65e783da1bd9e9ff995835", "html_url": "https://github.com/rust-lang/rust/commit/cfba0c7f990948612b65e783da1bd9e9ff995835"}, {"sha": "0fed29cfb7bab00f1bcbc72587497d1ad350d358", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fed29cfb7bab00f1bcbc72587497d1ad350d358", "html_url": "https://github.com/rust-lang/rust/commit/0fed29cfb7bab00f1bcbc72587497d1ad350d358"}], "stats": {"total": 255, "additions": 128, "deletions": 127}, "files": [{"sha": "b07e6cdaa80261937a1b94937d7e9e0231fb1f72", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -335,7 +335,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * Failing will unlock the ARC while unwinding. However, unlike all other\n      * access modes, this will not poison the ARC.\n      */\n-    fn read<U>(blk: fn(x: &T) -> U) -> U {\n+    fn read<U>(&self, blk: fn(x: &T) -> U) -> U {\n         let state = unsafe { get_shared_immutable_state(&self.x) };\n         do (&state.lock).read {\n             check_poison(false, state.failed);\n@@ -360,7 +360,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(blk: fn(v: RWWriteMode<T>) -> U) -> U {\n+    fn write_downgrade<U>(&self, blk: fn(v: RWWriteMode<T>) -> U) -> U {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n@@ -373,7 +373,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n     }\n \n     /// To be called inside of the write_downgrade block.\n-    fn downgrade(token: RWWriteMode/&a<T>) -> RWReadMode/&a<T> {\n+    fn downgrade(&self, token: RWWriteMode/&a<T>) -> RWReadMode/&a<T> {\n         // The rwlock should assert that the token belongs to us for us.\n         let state = unsafe { get_shared_immutable_state(&self.x) };\n         let RWWriteMode((data, t, _poison)) = token;"}, {"sha": "d8fc6a5b9eedb5349c4e48b8b3e1c735298f36c1", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -13,11 +13,11 @@ use core::str;\n use core::vec;\n \n pub trait ToBase64 {\n-    pure fn to_base64() -> ~str;\n+    pure fn to_base64(&self) -> ~str;\n }\n \n impl ToBase64 for &self/[u8] {\n-    pure fn to_base64() -> ~str {\n+    pure fn to_base64(&self) -> ~str {\n         let chars = str::chars(\n           ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n         );\n@@ -70,17 +70,17 @@ impl ToBase64 for &self/[u8] {\n }\n \n impl ToBase64 for &self/str {\n-    pure fn to_base64() -> ~str {\n-        str::to_bytes(self).to_base64()\n+    pure fn to_base64(&self) -> ~str {\n+        str::to_bytes(*self).to_base64()\n     }\n }\n \n pub trait FromBase64 {\n-    pure fn from_base64() -> ~[u8];\n+    pure fn from_base64(&self) -> ~[u8];\n }\n \n impl FromBase64 for ~[u8] {\n-    pure fn from_base64() -> ~[u8] {\n+    pure fn from_base64(&self) -> ~[u8] {\n         if self.len() % 4u != 0u { fail!(~\"invalid base64 length\"); }\n \n         let len = self.len();\n@@ -142,8 +142,8 @@ impl FromBase64 for ~[u8] {\n }\n \n impl FromBase64 for ~str {\n-    pure fn from_base64() -> ~[u8] {\n-        str::to_bytes(self).from_base64()\n+    pure fn from_base64(&self) -> ~[u8] {\n+        str::to_bytes(*self).from_base64()\n     }\n }\n "}, {"sha": "4189b37c2a44074aceb9cdeb450a56e5f937ba17", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -29,19 +29,19 @@ pub struct DuplexStream<T, U> {\n #[cfg(stage1)]\n #[cfg(stage2)]\n pub impl<T:Owned,U:Owned> DuplexStream<T, U> {\n-    fn send(x: T) {\n+    fn send(&self, x: T) {\n         self.chan.send(x)\n     }\n-    fn try_send(x: T) -> bool {\n+    fn try_send(&self, x: T) -> bool {\n         self.chan.try_send(x)\n     }\n-    fn recv() -> U {\n+    fn recv(&self, ) -> U {\n         self.port.recv()\n     }\n-    fn try_recv() -> Option<U> {\n+    fn try_recv(&self) -> Option<U> {\n         self.port.try_recv()\n     }\n-    pure fn peek() -> bool {\n+    pure fn peek(&self) -> bool {\n         self.port.peek()\n     }\n }"}, {"sha": "bbf3fc8c0725535ff2bb13d770b1d75954661f63", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -217,7 +217,7 @@ pub mod reader {\n     }\n \n     priv impl Decoder {\n-        fn _check_label(lbl: &str) {\n+        fn _check_label(&self, lbl: &str) {\n             if self.pos < self.parent.end {\n                 let TaggedDoc { tag: r_tag, doc: r_doc } =\n                     doc_at(self.parent.data, self.pos);\n@@ -233,7 +233,7 @@ pub mod reader {\n             }\n         }\n \n-        fn next_doc(exp_tag: EbmlEncoderTag) -> Doc {\n+        fn next_doc(&self, exp_tag: EbmlEncoderTag) -> Doc {\n             debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n             if self.pos >= self.parent.end {\n                 fail!(~\"no more documents in current node!\");\n@@ -255,7 +255,7 @@ pub mod reader {\n             r_doc\n         }\n \n-        fn push_doc<T>(d: Doc, f: fn() -> T) -> T {\n+        fn push_doc<T>(&self, d: Doc, f: fn() -> T) -> T {\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n             self.parent = d;\n@@ -266,7 +266,7 @@ pub mod reader {\n             r\n         }\n \n-        fn _next_uint(exp_tag: EbmlEncoderTag) -> uint {\n+        fn _next_uint(&self, exp_tag: EbmlEncoderTag) -> uint {\n             let r = doc_as_u32(self.next_doc(exp_tag));\n             debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n             r as uint\n@@ -446,7 +446,7 @@ pub mod writer {\n \n     // FIXME (#2741): Provide a function to write the standard ebml header.\n     pub impl Encoder {\n-        fn start_tag(tag_id: uint) {\n+        fn start_tag(&self, tag_id: uint) {\n             debug!(\"Start tag %u\", tag_id);\n \n             // Write the enum ID:\n@@ -458,7 +458,7 @@ pub mod writer {\n             self.writer.write(zeroes);\n         }\n \n-        fn end_tag() {\n+        fn end_tag(&self) {\n             let last_size_pos = self.size_positions.pop();\n             let cur_pos = self.writer.tell();\n             self.writer.seek(last_size_pos as int, io::SeekSet);\n@@ -469,72 +469,72 @@ pub mod writer {\n             debug!(\"End tag (size = %u)\", size);\n         }\n \n-        fn wr_tag(tag_id: uint, blk: fn()) {\n+        fn wr_tag(&self, tag_id: uint, blk: fn()) {\n             self.start_tag(tag_id);\n             blk();\n             self.end_tag();\n         }\n \n-        fn wr_tagged_bytes(tag_id: uint, b: &[u8]) {\n+        fn wr_tagged_bytes(&self, tag_id: uint, b: &[u8]) {\n             write_vuint(self.writer, tag_id);\n             write_vuint(self.writer, vec::len(b));\n             self.writer.write(b);\n         }\n \n-        fn wr_tagged_u64(tag_id: uint, v: u64) {\n+        fn wr_tagged_u64(&self, tag_id: uint, v: u64) {\n             do io::u64_to_be_bytes(v, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_u32(tag_id: uint, v: u32) {\n+        fn wr_tagged_u32(&self, tag_id: uint, v: u32) {\n             do io::u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_u16(tag_id: uint, v: u16) {\n+        fn wr_tagged_u16(&self, tag_id: uint, v: u16) {\n             do io::u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_u8(tag_id: uint, v: u8) {\n+        fn wr_tagged_u8(&self, tag_id: uint, v: u8) {\n             self.wr_tagged_bytes(tag_id, &[v]);\n         }\n \n-        fn wr_tagged_i64(tag_id: uint, v: i64) {\n+        fn wr_tagged_i64(&self, tag_id: uint, v: i64) {\n             do io::u64_to_be_bytes(v as u64, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_i32(tag_id: uint, v: i32) {\n+        fn wr_tagged_i32(&self, tag_id: uint, v: i32) {\n             do io::u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_i16(tag_id: uint, v: i16) {\n+        fn wr_tagged_i16(&self, tag_id: uint, v: i16) {\n             do io::u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_i8(tag_id: uint, v: i8) {\n+        fn wr_tagged_i8(&self, tag_id: uint, v: i8) {\n             self.wr_tagged_bytes(tag_id, &[v as u8]);\n         }\n \n-        fn wr_tagged_str(tag_id: uint, v: &str) {\n+        fn wr_tagged_str(&self, tag_id: uint, v: &str) {\n             str::byte_slice(v, |b| self.wr_tagged_bytes(tag_id, b));\n         }\n \n-        fn wr_bytes(b: &[u8]) {\n+        fn wr_bytes(&self, b: &[u8]) {\n             debug!(\"Write %u bytes\", vec::len(b));\n             self.writer.write(b);\n         }\n \n-        fn wr_str(s: &str) {\n+        fn wr_str(&self, s: &str) {\n             debug!(\"Write str: %?\", s);\n             self.writer.write(str::to_bytes(s));\n         }\n@@ -549,12 +549,12 @@ pub mod writer {\n \n     priv impl Encoder {\n         // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_uint(t: EbmlEncoderTag, v: uint) {\n+        fn _emit_tagged_uint(&self, t: EbmlEncoderTag, v: uint) {\n             assert v <= 0xFFFF_FFFF_u;\n             self.wr_tagged_u32(t as uint, v as u32);\n         }\n \n-        fn _emit_label(label: &str) {\n+        fn _emit_label(&self, label: &str) {\n             // There are various strings that we have access to, such as\n             // the name of a record field, which do not actually appear in\n             // the encoded EBML (normally).  This is just for"}, {"sha": "68a9ce75593e253bf0e85136bbfbd10e5f7008dd", "filename": "src/libstd/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -47,7 +47,7 @@ priv enum FutureState<A> {\n \n /// Methods on the `future` type\n pub impl<A:Copy> Future<A> {\n-    fn get() -> A {\n+    fn get(&self) -> A {\n         //! Get the value of the future\n         *(self.get_ref())\n     }"}, {"sha": "7d673feaf254cbcc85caf813505de17ddbd328d5", "filename": "src/libstd/io_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio_util.rs?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -24,7 +24,7 @@ pub impl BufReader {\n         }\n     }\n \n-    priv fn as_bytes_reader<A>(f: &fn(&BytesReader) -> A) -> A {\n+    priv fn as_bytes_reader<A>(&self, f: &fn(&BytesReader) -> A) -> A {\n         // Recreating the BytesReader state every call since\n         // I can't get the borrowing to work correctly\n         let bytes_reader = BytesReader {"}, {"sha": "4ebd151eb2e03cce107fcd891fa98615c939abeb", "filename": "src/libstd/json.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -387,7 +387,7 @@ pub fn Parser(rdr: io::Reader) -> Parser {\n }\n \n pub impl Parser {\n-    fn parse() -> Result<Json, Error> {\n+    fn parse(&self) -> Result<Json, Error> {\n         match self.parse_value() {\n           Ok(value) => {\n             // Skip trailing whitespaces.\n@@ -405,9 +405,9 @@ pub impl Parser {\n }\n \n priv impl Parser {\n-    fn eof() -> bool { self.ch == -1 as char }\n+    fn eof(&self) -> bool { self.ch == -1 as char }\n \n-    fn bump() {\n+    fn bump(&self) {\n         self.ch = self.rdr.read_char();\n \n         if self.ch == '\\n' {\n@@ -418,16 +418,16 @@ priv impl Parser {\n         }\n     }\n \n-    fn next_char() -> char {\n+    fn next_char(&self) -> char {\n         self.bump();\n         self.ch\n     }\n \n-    fn error<T>(msg: ~str) -> Result<T, Error> {\n+    fn error<T>(&self, msg: ~str) -> Result<T, Error> {\n         Err(Error { line: self.line, col: self.col, msg: @msg })\n     }\n \n-    fn parse_value() -> Result<Json, Error> {\n+    fn parse_value(&self) -> Result<Json, Error> {\n         self.parse_whitespace();\n \n         if self.eof() { return self.error(~\"EOF while parsing value\"); }\n@@ -448,11 +448,11 @@ priv impl Parser {\n         }\n     }\n \n-    fn parse_whitespace() {\n+    fn parse_whitespace(&self) {\n         while char::is_whitespace(self.ch) { self.bump(); }\n     }\n \n-    fn parse_ident(ident: &str, value: Json) -> Result<Json, Error> {\n+    fn parse_ident(&self, ident: &str, value: Json) -> Result<Json, Error> {\n         if str::all(ident, |c| c == self.next_char()) {\n             self.bump();\n             Ok(value)\n@@ -461,7 +461,7 @@ priv impl Parser {\n         }\n     }\n \n-    fn parse_number() -> Result<Json, Error> {\n+    fn parse_number(&self) -> Result<Json, Error> {\n         let mut neg = 1f;\n \n         if self.ch == '-' {\n@@ -491,7 +491,7 @@ priv impl Parser {\n         Ok(Number(neg * res))\n     }\n \n-    fn parse_integer() -> Result<float, Error> {\n+    fn parse_integer(&self) -> Result<float, Error> {\n         let mut res = 0f;\n \n         match self.ch {\n@@ -523,7 +523,7 @@ priv impl Parser {\n         Ok(res)\n     }\n \n-    fn parse_decimal(res: float) -> Result<float, Error> {\n+    fn parse_decimal(&self, res: float) -> Result<float, Error> {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n@@ -549,7 +549,7 @@ priv impl Parser {\n         Ok(res)\n     }\n \n-    fn parse_exponent(res: float) -> Result<float, Error> {\n+    fn parse_exponent(&self, res: float) -> Result<float, Error> {\n         self.bump();\n \n         let mut res = res;\n@@ -590,7 +590,7 @@ priv impl Parser {\n         Ok(res)\n     }\n \n-    fn parse_str() -> Result<~str, Error> {\n+    fn parse_str(&self) -> Result<~str, Error> {\n         let mut escape = false;\n         let mut res = ~\"\";\n \n@@ -654,7 +654,7 @@ priv impl Parser {\n         self.error(~\"EOF while parsing string\")\n     }\n \n-    fn parse_list() -> Result<Json, Error> {\n+    fn parse_list(&self) -> Result<Json, Error> {\n         self.bump();\n         self.parse_whitespace();\n \n@@ -684,7 +684,7 @@ priv impl Parser {\n         };\n     }\n \n-    fn parse_object() -> Result<Json, Error> {\n+    fn parse_object(&self) -> Result<Json, Error> {\n         self.bump();\n         self.parse_whitespace();\n \n@@ -1072,87 +1072,87 @@ impl Eq for Error {\n     pure fn ne(&self, other: &Error) -> bool { !(*self).eq(other) }\n }\n \n-trait ToJson { fn to_json() -> Json; }\n+trait ToJson { fn to_json(&self) -> Json; }\n \n impl ToJson for Json {\n-    fn to_json() -> Json { copy self }\n+    fn to_json(&self) -> Json { copy *self }\n }\n \n impl ToJson for @Json {\n-    fn to_json() -> Json { (*self).to_json() }\n+    fn to_json(&self) -> Json { (**self).to_json() }\n }\n \n impl ToJson for int {\n-    fn to_json() -> Json { Number(self as float) }\n+    fn to_json(&self) -> Json { Number(*self as float) }\n }\n \n impl ToJson for i8 {\n-    fn to_json() -> Json { Number(self as float) }\n+    fn to_json(&self) -> Json { Number(*self as float) }\n }\n \n impl ToJson for i16 {\n-    fn to_json() -> Json { Number(self as float) }\n+    fn to_json(&self) -> Json { Number(*self as float) }\n }\n \n impl ToJson for i32 {\n-    fn to_json() -> Json { Number(self as float) }\n+    fn to_json(&self) -> Json { Number(*self as float) }\n }\n \n impl ToJson for i64 {\n-    fn to_json() -> Json { Number(self as float) }\n+    fn to_json(&self) -> Json { Number(*self as float) }\n }\n \n impl ToJson for uint {\n-    fn to_json() -> Json { Number(self as float) }\n+    fn to_json(&self) -> Json { Number(*self as float) }\n }\n \n impl ToJson for u8 {\n-    fn to_json() -> Json { Number(self as float) }\n+    fn to_json(&self) -> Json { Number(*self as float) }\n }\n \n impl ToJson for u16 {\n-    fn to_json() -> Json { Number(self as float) }\n+    fn to_json(&self) -> Json { Number(*self as float) }\n }\n \n impl ToJson for u32 {\n-    fn to_json() -> Json { Number(self as float) }\n+    fn to_json(&self) -> Json { Number(*self as float) }\n }\n \n impl ToJson for u64 {\n-    fn to_json() -> Json { Number(self as float) }\n+    fn to_json(&self) -> Json { Number(*self as float) }\n }\n \n impl ToJson for float {\n-    fn to_json() -> Json { Number(self) }\n+    fn to_json(&self) -> Json { Number(*self) }\n }\n \n impl ToJson for f32 {\n-    fn to_json() -> Json { Number(self as float) }\n+    fn to_json(&self) -> Json { Number(*self as float) }\n }\n \n impl ToJson for f64 {\n-    fn to_json() -> Json { Number(self as float) }\n+    fn to_json(&self) -> Json { Number(*self as float) }\n }\n \n impl ToJson for () {\n-    fn to_json() -> Json { Null }\n+    fn to_json(&self) -> Json { Null }\n }\n \n impl ToJson for bool {\n-    fn to_json() -> Json { Boolean(self) }\n+    fn to_json(&self) -> Json { Boolean(*self) }\n }\n \n impl ToJson for ~str {\n-    fn to_json() -> Json { String(copy self) }\n+    fn to_json(&self) -> Json { String(copy *self) }\n }\n \n impl ToJson for @~str {\n-    fn to_json() -> Json { String(copy *self) }\n+    fn to_json(&self) -> Json { String(copy **self) }\n }\n \n impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n-    fn to_json() -> Json {\n-        match self {\n+    fn to_json(&self) -> Json {\n+        match *self {\n           (ref a, ref b) => {\n             List(~[a.to_json(), b.to_json()])\n           }\n@@ -1161,8 +1161,8 @@ impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n }\n \n impl<A:ToJson,B:ToJson,C:ToJson> ToJson for (A, B, C) {\n-    fn to_json() -> Json {\n-        match self {\n+    fn to_json(&self) -> Json {\n+        match *self {\n           (ref a, ref b, ref c) => {\n             List(~[a.to_json(), b.to_json(), c.to_json()])\n           }\n@@ -1171,11 +1171,11 @@ impl<A:ToJson,B:ToJson,C:ToJson> ToJson for (A, B, C) {\n }\n \n impl<A:ToJson> ToJson for ~[A] {\n-    fn to_json() -> Json { List(self.map(|elt| elt.to_json())) }\n+    fn to_json(&self) -> Json { List(self.map(|elt| elt.to_json())) }\n }\n \n impl<A:ToJson + Copy> ToJson for LinearMap<~str, A> {\n-    fn to_json() -> Json {\n+    fn to_json(&self) -> Json {\n         let mut d = LinearMap::new();\n         for self.each |&(key, value)| {\n             d.insert(copy *key, value.to_json());\n@@ -1185,8 +1185,8 @@ impl<A:ToJson + Copy> ToJson for LinearMap<~str, A> {\n }\n \n impl<A:ToJson> ToJson for Option<A> {\n-    fn to_json() -> Json {\n-        match self {\n+    fn to_json(&self) -> Json {\n+        match *self {\n           None => Null,\n           Some(ref value) => value.to_json()\n         }"}, {"sha": "7a5c40f403f7b99cfebb23af3f83683c0f110a45", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -187,13 +187,13 @@ pub mod v4 {\n     pub struct Ipv4Rep { a: u8, b: u8, c: u8, d: u8 }\n \n     pub trait AsUnsafeU32 {\n-        unsafe fn as_u32() -> u32;\n+        unsafe fn as_u32(&self) -> u32;\n     }\n \n     impl AsUnsafeU32 for Ipv4Rep {\n         // this is pretty dastardly, i know\n-        unsafe fn as_u32() -> u32 {\n-            *((ptr::addr_of(&self)) as *u32)\n+        unsafe fn as_u32(&self) -> u32 {\n+            *((ptr::addr_of(self)) as *u32)\n         }\n     }\n     pub fn parse_to_ipv4_rep(ip: &str) -> result::Result<Ipv4Rep, ~str> {"}, {"sha": "f270739b2f2e63425429b8e7909440de66cac3ad", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -823,31 +823,31 @@ pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n \n /// Convenience methods extending `net::tcp::TcpSocket`\n pub impl TcpSocket {\n-    pub fn read_start() -> result::Result<@Port<\n+    pub fn read_start(&self) -> result::Result<@Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n-        read_start(&self)\n+        read_start(self)\n     }\n-    pub fn read_stop() ->\n+    pub fn read_stop(&self) ->\n         result::Result<(), TcpErrData> {\n-        read_stop(&self)\n+        read_stop(self)\n     }\n-    fn read(timeout_msecs: uint) ->\n+    fn read(&self, timeout_msecs: uint) ->\n         result::Result<~[u8], TcpErrData> {\n-        read(&self, timeout_msecs)\n+        read(self, timeout_msecs)\n     }\n-    fn read_future(timeout_msecs: uint) ->\n+    fn read_future(&self, timeout_msecs: uint) ->\n         future::Future<result::Result<~[u8], TcpErrData>> {\n-        read_future(&self, timeout_msecs)\n+        read_future(self, timeout_msecs)\n     }\n-    pub fn write(raw_write_data: ~[u8])\n+    pub fn write(&self, raw_write_data: ~[u8])\n         -> result::Result<(), TcpErrData> {\n-        write(&self, raw_write_data)\n+        write(self, raw_write_data)\n     }\n-    pub fn write_future(raw_write_data: ~[u8])\n+    pub fn write_future(&self, raw_write_data: ~[u8])\n         -> future::Future<result::Result<(), TcpErrData>> {\n-        write_future(&self, raw_write_data)\n+        write_future(self, raw_write_data)\n     }\n-    pub fn get_peer_addr() -> ip::IpAddr {\n+    pub fn get_peer_addr(&self) -> ip::IpAddr {\n         unsafe {\n             if self.socket_data.ipv6 {\n                 let addr = uv::ll::ip6_addr(\"\", 0);\n@@ -1264,11 +1264,11 @@ enum TcpReadResult {\n }\n \n trait ToTcpErr {\n-    fn to_tcp_err() -> TcpErrData;\n+    fn to_tcp_err(&self) -> TcpErrData;\n }\n \n impl ToTcpErr for uv::ll::uv_err_data {\n-    fn to_tcp_err() -> TcpErrData {\n+    fn to_tcp_err(&self) -> TcpErrData {\n         TcpErrData { err_name: self.err_name, err_msg: self.err_msg }\n     }\n }"}, {"sha": "eb5ad2b6d73badff031ecb6c95c6c0dd3ce4bfe0", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -74,7 +74,7 @@ pub mod chained {\n     }\n \n     priv impl<K:Eq + IterBytes + Hash,V> T<K, V> {\n-        pure fn search_rem(k: &K, h: uint, idx: uint,\n+        pure fn search_rem(&self, k: &K, h: uint, idx: uint,\n                            e_root: @Entry<K,V>) -> SearchResult<K,V> {\n             let mut e0 = e_root;\n             let mut comp = 1u;   // for logging\n@@ -100,7 +100,7 @@ pub mod chained {\n             };\n         }\n \n-        pure fn search_tbl(k: &K, h: uint) -> SearchResult<K,V> {\n+        pure fn search_tbl(&self, k: &K, h: uint) -> SearchResult<K,V> {\n             let idx = h % vec::len(self.chains);\n             match copy self.chains[idx] {\n               None => {\n@@ -120,7 +120,7 @@ pub mod chained {\n             }\n         }\n \n-        fn rehash() {\n+        fn rehash(&self) {\n             let n_old_chains = self.chains.len();\n             let n_new_chains: uint = uint::next_power_of_two(n_old_chains+1u);\n             let mut new_chains = chains(n_new_chains);\n@@ -134,7 +134,7 @@ pub mod chained {\n     }\n \n     pub impl<K:Eq + IterBytes + Hash,V> T<K, V> {\n-        pure fn each_entry(blk: fn(@Entry<K,V>) -> bool) {\n+        pure fn each_entry(&self, blk: fn(@Entry<K,V>) -> bool) {\n             // n.b. we can't use vec::iter() here because self.chains\n             // is stored in a mutable location.\n             let mut i = 0u, n = self.chains.len();\n@@ -176,7 +176,7 @@ pub mod chained {\n             }\n         }\n \n-        fn insert(k: K, v: V) -> bool {\n+        fn insert(&self, k: K, v: V) -> bool {\n             let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(&k, hash) {\n               NotFound => {\n@@ -220,7 +220,7 @@ pub mod chained {\n             }\n         }\n \n-        fn remove(k: &K) -> bool {\n+        fn remove(&self, k: &K) -> bool {\n             match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n               NotFound => false,\n               FoundFirst(idx, entry) => {\n@@ -260,7 +260,8 @@ pub mod chained {\n             }\n         }\n \n-        fn update_with_key(key: K, newval: V, ff: fn(K, V, V) -> V) -> bool {\n+        fn update_with_key(&self, key: K, newval: V, ff: fn(K, V, V) -> V)\n+                          -> bool {\n /*\n             match self.find(key) {\n                 None            => return self.insert(key, val),\n@@ -311,7 +312,7 @@ pub mod chained {\n             }\n         }\n \n-        fn update(key: K, newval: V, ff: fn(V, V) -> V) -> bool {\n+        fn update(&self, key: K, newval: V, ff: fn(V, V) -> V) -> bool {\n             return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n         }\n \n@@ -325,7 +326,7 @@ pub mod chained {\n     }\n \n     pub impl<K:Eq + IterBytes + Hash + Copy + ToStr,V:ToStr + Copy> T<K, V> {\n-        fn to_writer(wr: io::Writer) {\n+        fn to_writer(&self, wr: io::Writer) {\n             if self.count == 0u {\n                 wr.write_str(~\"{}\");\n                 return;"}, {"sha": "a3b18e50df26aeaf9976cf6569aeb511b2ff0f74", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -28,7 +28,7 @@ not required in or otherwise suitable for the core library.\n \n #[allow(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n-#[allow(deprecated_self)];\n+#[deny(deprecated_self)];\n #[allow(deprecated_mutable_fields)];\n \n #[no_core];"}, {"sha": "6c8d719e5f517b8baa73757619c7f71456a5560c", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -99,7 +99,7 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n \n #[doc(hidden)]\n pub impl<Q:Owned> &self/Sem<Q> {\n-    fn acquire() {\n+    fn acquire(&self) {\n         let mut waiter_nobe = None;\n         unsafe {\n             do (**self).with |state| {\n@@ -121,7 +121,7 @@ pub impl<Q:Owned> &self/Sem<Q> {\n             let _ = comm::recv_one(option::unwrap(waiter_nobe));\n         }\n     }\n-    fn release() {\n+    fn release(&self) {\n         unsafe {\n             do (**self).with |state| {\n                 state.count += 1;\n@@ -135,25 +135,25 @@ pub impl<Q:Owned> &self/Sem<Q> {\n // FIXME(#3154) move both copies of this into Sem<Q>, and unify the 2 structs\n #[doc(hidden)]\n pub impl &self/Sem<()> {\n-    fn access<U>(blk: fn() -> U) -> U {\n+    fn access<U>(&self, blk: fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n                 self.acquire();\n-                release = Some(SemRelease(self));\n+                release = Some(SemRelease(*self));\n             }\n         }\n         blk()\n     }\n }\n #[doc(hidden)]\n pub impl &self/Sem<~[Waitqueue]> {\n-    fn access<U>(blk: fn() -> U) -> U {\n+    fn access<U>(&self, blk: fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n                 self.acquire();\n-                release = Some(SemAndSignalRelease(self));\n+                release = Some(SemAndSignalRelease(*self));\n             }\n         }\n         blk()\n@@ -385,7 +385,7 @@ pub impl Semaphore {\n     fn release(&self) { (&self.sem).release() }\n \n     /// Run a function with ownership of one of the semaphore's resources.\n-    fn access<U>(blk: fn() -> U) -> U { (&self.sem).access(blk) }\n+    fn access<U>(&self, blk: fn() -> U) -> U { (&self.sem).access(blk) }\n }\n \n /****************************************************************************"}, {"sha": "3801fdf88347de741467531413365aedff45ce64", "filename": "src/libstd/time.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -209,33 +209,33 @@ pub pure fn strftime(format: &str, tm: &Tm) -> ~str {\n \n pub impl Tm {\n     /// Convert time to the seconds from January 1, 1970\n-    fn to_timespec() -> Timespec {\n+    fn to_timespec(&self) -> Timespec {\n         unsafe {\n             let mut sec = 0i64;\n             if self.tm_gmtoff == 0_i32 {\n-                rustrt::rust_timegm(self, &mut sec);\n+                rustrt::rust_timegm(*self, &mut sec);\n             } else {\n-                rustrt::rust_mktime(self, &mut sec);\n+                rustrt::rust_mktime(*self, &mut sec);\n             }\n             Timespec::new(sec, self.tm_nsec)\n         }\n     }\n \n     /// Convert time to the local timezone\n-    fn to_local() -> Tm {\n+    fn to_local(&self) -> Tm {\n         at(self.to_timespec())\n     }\n \n     /// Convert time to the UTC\n-    fn to_utc() -> Tm {\n+    fn to_utc(&self) -> Tm {\n         at_utc(self.to_timespec())\n     }\n \n     /**\n      * Return a string of the current time in the form\n      * \"Thu Jan  1 00:00:00 1970\".\n      */\n-    pure fn ctime() -> ~str { self.strftime(~\"%c\") }\n+    pure fn ctime(&self) -> ~str { self.strftime(~\"%c\") }\n \n     /// Formats the time according to the format string.\n     pure fn strftime(&self, format: &str) -> ~str {\n@@ -248,7 +248,7 @@ pub impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 UTC\"\n      */\n-    pure fn rfc822() -> ~str {\n+    pure fn rfc822(&self) -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(~\"%a, %d %b %Y %T GMT\")\n         } else {\n@@ -262,7 +262,7 @@ pub impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 -0700\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n      */\n-    pure fn rfc822z() -> ~str {\n+    pure fn rfc822z(&self) -> ~str {\n         self.strftime(~\"%a, %d %b %Y %T %z\")\n     }\n \n@@ -272,7 +272,7 @@ pub impl Tm {\n      * local: \"2012-02-22T07:53:18-07:00\"\n      * utc:   \"2012-02-22T14:53:18Z\"\n      */\n-    pure fn rfc3339() -> ~str {\n+    pure fn rfc3339(&self) -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(~\"%Y-%m-%dT%H:%M:%SZ\")\n         } else {"}, {"sha": "eac6e090f1f10dd104af9d66ccd01fff60e3320c", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f0a105789d9d9cec4e89898109fb95238cc416/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=88f0a105789d9d9cec4e89898109fb95238cc416", "patch": "@@ -200,7 +200,7 @@ struct Logger {\n }\n \n pub impl Logger {\n-    fn info(i: &str) {\n+    fn info(&self, i: &str) {\n         io::println(~\"workcache: \" + i.to_owned());\n     }\n }"}]}