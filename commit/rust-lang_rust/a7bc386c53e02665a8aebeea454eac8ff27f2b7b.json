{"sha": "a7bc386c53e02665a8aebeea454eac8ff27f2b7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YmMzODZjNTNlMDI2NjVhOGFlYmVlYTQ1NGVhYzhmZjI3ZjJiN2I=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-01T01:26:19Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-01T19:14:33Z"}, "message": "Delete parts of std::str that are no longer exported. Issue #855", "tree": {"sha": "c2a77e94b947c3b10705e5a7e090ce2513b47585", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2a77e94b947c3b10705e5a7e090ce2513b47585"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7bc386c53e02665a8aebeea454eac8ff27f2b7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7bc386c53e02665a8aebeea454eac8ff27f2b7b", "html_url": "https://github.com/rust-lang/rust/commit/a7bc386c53e02665a8aebeea454eac8ff27f2b7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7bc386c53e02665a8aebeea454eac8ff27f2b7b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34d197de97b5f750b38ad4cbaf228467302e6bf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d197de97b5f750b38ad4cbaf228467302e6bf1", "html_url": "https://github.com/rust-lang/rust/commit/34d197de97b5f750b38ad4cbaf228467302e6bf1"}], "stats": {"total": 518, "additions": 0, "deletions": 518}, "files": [{"sha": "14399bb80d0b0bc60e78eb09ecc08c4cf23b923e", "filename": "src/lib/str.rs", "status": "modified", "additions": 0, "deletions": 518, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/a7bc386c53e02665a8aebeea454eac8ff27f2b7b/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bc386c53e02665a8aebeea454eac8ff27f2b7b/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=a7bc386c53e02665a8aebeea454eac8ff27f2b7b", "patch": "@@ -1,58 +1,4 @@\n-\n-import rustrt::sbuf;\n-import uint::le;\n-// export sbuf;\n-// export rustrt;\n-// export eq;\n-// export lteq;\n-// export hash;\n-// export is_utf8;\n-// export is_ascii;\n-export alloc;\n-// export byte_len;\n-// export buf;\n-// export bytes;\n-// export unsafe_from_byte;\n-// export str_from_cstr;\n-// export str_from_buf;\n-// export push_utf8_bytes;\n-// export from_char;\n-// export from_chars;\n-// export utf8_char_width;\n-// export char_range_at;\n-// export char_at;\n-// export char_len;\n-// export to_chars;\n-// export push_char;\n-// export pop_char;\n-// export shift_char;\n-// export unshift_char;\n-// export refcount;\n-// export index;\n-// export rindex;\n-// export find;\n-// export starts_with;\n-// export ends_with;\n-// export substr;\n-// export slice;\n-// export shift_byte;\n-// export pop_byte;\n-// export push_byte;\n-// export unshift_byte;\n-// export split;\n-// export concat;\n-// export connect;\n-// export to_upper;\n-// export safe_slice;\n export unsafe_from_bytes;\n-// export is_empty;\n-// export is_not_empty;\n-// export is_whitespace;\n-// export replace;\n-// export char_slice;\n-// export trim_left;\n-// export trim_right;\n-// export trim;\n \n native \"rust\" mod rustrt {\n     type sbuf;\n@@ -67,470 +13,6 @@ native \"rust\" mod rustrt {\n     fn refcount<T>(s: str) -> uint;\n }\n \n-fn eq(a: &str, b: &str) -> bool {\n-    let i: uint = byte_len(a);\n-    if byte_len(b) != i { ret false; }\n-    while i > 0u {\n-        i -= 1u;\n-        let cha = a[i];\n-        let chb = b[i];\n-        if cha != chb { ret false; }\n-    }\n-    ret true;\n-}\n-\n-fn lteq(a: &str, b: &str) -> bool {\n-    let i: uint = byte_len(a);\n-    let j: uint = byte_len(b);\n-    let n: uint = i;\n-    if j < n { n = j; }\n-    let x: uint = 0u;\n-    while x < n {\n-        let cha = a[x];\n-        let chb = b[x];\n-        if cha < chb { ret true; } else if cha > chb { ret false; }\n-        x += 1u;\n-    }\n-    ret i <= j;\n-}\n-\n-fn hash(s: &str) -> uint {\n-    // djb hash.\n-    // FIXME: replace with murmur.\n-\n-    let u: uint = 5381u;\n-    for c: u8 in s { u *= 33u; u += c as uint; }\n-    ret u;\n-}\n-\n-\n-// UTF-8 tags and ranges\n-const tag_cont_u8: u8 = 128u8;\n-\n-const tag_cont: uint = 128u;\n-\n-const max_one_b: uint = 128u;\n-\n-const tag_two_b: uint = 192u;\n-\n-const max_two_b: uint = 2048u;\n-\n-const tag_three_b: uint = 224u;\n-\n-const max_three_b: uint = 65536u;\n-\n-const tag_four_b: uint = 240u;\n-\n-const max_four_b: uint = 2097152u;\n-\n-const tag_five_b: uint = 248u;\n-\n-const max_five_b: uint = 67108864u;\n-\n-const tag_six_b: uint = 252u;\n-\n-fn is_utf8(v: &[u8]) -> bool {\n-    let i = 0u;\n-    let total = vec::len::<u8>(v);\n-    while i < total {\n-        let chsize = utf8_char_width(v[i]);\n-        if chsize == 0u { ret false; }\n-        if i + chsize > total { ret false; }\n-        i += 1u;\n-        while chsize > 1u {\n-            if v[i] & 192u8 != tag_cont_u8 { ret false; }\n-            i += 1u;\n-            chsize -= 1u;\n-        }\n-    }\n-    ret true;\n-}\n-\n-fn is_ascii(s: str) -> bool {\n-    let i: uint = byte_len(s);\n-    while i > 0u { i -= 1u; if s[i] & 128u8 != 0u8 { ret false; } }\n-    ret true;\n-}\n-\n-fn alloc(n_bytes: uint) -> str { ret rustrt::str_alloc(n_bytes); }\n-\n-/// Returns true if the string has length 0\n-pure fn is_empty(s: str) -> bool { for c: u8 in s { ret false; } ret true; }\n-\n-/// Returns true if the string has length greater than 0\n-pure fn is_not_empty(s: str) -> bool { !is_empty(s) }\n-\n-fn is_whitespace(s: str) -> bool {\n-    let i = 0u;\n-    let len = char_len(s);\n-    while i < len {\n-        if !char::is_whitespace(char_at(s, i)) { ret false; }\n-        i += 1u\n-    }\n-    ret true;\n-}\n-\n-// Returns the number of bytes (a.k.a. UTF-8 code units) in s.\n-// Contrast with a function that would return the number of code\n-// points (char's), combining character sequences, words, etc.  See\n-// http://icu-project.org/apiref/icu4c/classBreakIterator.html for a\n-// way to implement those.\n-fn byte_len(s: str) -> uint { ret rustrt::str_byte_len(s); }\n-\n-fn buf(s: &str) -> sbuf { ret rustrt::str_buf(s); }\n-\n-fn bytes(s: str) -> [u8] {\n-    let sbuffer = buf(s);\n-    let ptr = unsafe::reinterpret_cast(sbuffer);\n-    ret vec::unsafe::from_buf(ptr, byte_len(s));\n-}\n-\n fn unsafe_from_bytes(v: &[mutable? u8]) -> str {\n     ret rustrt::str_from_vec(v);\n }\n-\n-fn unsafe_from_byte(u: u8) -> str { ret rustrt::str_from_vec([u]); }\n-\n-fn str_from_cstr(cstr: sbuf) -> str { ret rustrt::str_from_cstr(cstr); }\n-\n-fn str_from_buf(buf: sbuf, len: uint) -> str {\n-    ret rustrt::str_from_buf(buf, len);\n-}\n-\n-fn push_utf8_bytes(s: &mutable str, ch: char) {\n-    let code = ch as uint;\n-    if code < max_one_b {\n-        s = rustrt::str_push_byte(s, code);\n-    } else if code < max_two_b {\n-        s = rustrt::str_push_byte(s, code >> 6u & 31u | tag_two_b);\n-        s = rustrt::str_push_byte(s, code & 63u | tag_cont);\n-    } else if code < max_three_b {\n-        s = rustrt::str_push_byte(s, code >> 12u & 15u | tag_three_b);\n-        s = rustrt::str_push_byte(s, code >> 6u & 63u | tag_cont);\n-        s = rustrt::str_push_byte(s, code & 63u | tag_cont);\n-    } else if code < max_four_b {\n-        s = rustrt::str_push_byte(s, code >> 18u & 7u | tag_four_b);\n-        s = rustrt::str_push_byte(s, code >> 12u & 63u | tag_cont);\n-        s = rustrt::str_push_byte(s, code >> 6u & 63u | tag_cont);\n-        s = rustrt::str_push_byte(s, code & 63u | tag_cont);\n-    } else if code < max_five_b {\n-        s = rustrt::str_push_byte(s, code >> 24u & 3u | tag_five_b);\n-        s = rustrt::str_push_byte(s, code >> 18u & 63u | tag_cont);\n-        s = rustrt::str_push_byte(s, code >> 12u & 63u | tag_cont);\n-        s = rustrt::str_push_byte(s, code >> 6u & 63u | tag_cont);\n-        s = rustrt::str_push_byte(s, code & 63u | tag_cont);\n-    } else {\n-        s = rustrt::str_push_byte(s, code >> 30u & 1u | tag_six_b);\n-        s = rustrt::str_push_byte(s, code >> 24u & 63u | tag_cont);\n-        s = rustrt::str_push_byte(s, code >> 18u & 63u | tag_cont);\n-        s = rustrt::str_push_byte(s, code >> 12u & 63u | tag_cont);\n-        s = rustrt::str_push_byte(s, code >> 6u & 63u | tag_cont);\n-        s = rustrt::str_push_byte(s, code & 63u | tag_cont);\n-    }\n-}\n-\n-fn from_char(ch: char) -> str {\n-    let buf = \"\";\n-    push_utf8_bytes(buf, ch);\n-    ret buf;\n-}\n-\n-fn from_chars(chs: &[char]) -> str {\n-    let buf = \"\";\n-    for ch: char in chs { push_utf8_bytes(buf, ch); }\n-    ret buf;\n-}\n-\n-fn utf8_char_width(b: u8) -> uint {\n-    let byte: uint = b as uint;\n-    if byte < 128u { ret 1u; }\n-    if byte < 192u {\n-        ret 0u; // Not a valid start byte\n-\n-    }\n-    if byte < 224u { ret 2u; }\n-    if byte < 240u { ret 3u; }\n-    if byte < 248u { ret 4u; }\n-    if byte < 252u { ret 5u; }\n-    ret 6u;\n-}\n-\n-fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n-    let b0 = s[i];\n-    let w = utf8_char_width(b0);\n-    assert (w != 0u);\n-    if w == 1u { ret {ch: b0 as char, next: i + 1u}; }\n-    let val = 0u;\n-    let end = i + w;\n-    i += 1u;\n-    while i < end {\n-        let byte = s[i];\n-        assert (byte & 192u8 == tag_cont_u8);\n-        val <<= 6u;\n-        val += byte & 63u8 as uint;\n-        i += 1u;\n-    }\n-    // Clunky way to get the right bits from the first byte. Uses two shifts,\n-    // the first to clip off the marker bits at the left of the byte, and then\n-    // a second (as uint) to get it to the right position.\n-\n-    val += (b0 << (w + 1u as u8) as uint) << (w - 1u) * 6u - w - 1u;\n-    ret {ch: val as char, next: i};\n-}\n-\n-fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n-\n-fn char_len(s: str) -> uint {\n-    let i = 0u;\n-    let len = 0u;\n-    let total = byte_len(s);\n-    while i < total {\n-        let chsize = utf8_char_width(s[i]);\n-        assert (chsize > 0u);\n-        len += 1u;\n-        i += chsize;\n-    }\n-    assert (i == total);\n-    ret len;\n-}\n-\n-fn to_chars(s: str) -> [char] {\n-    let buf: [char] = [];\n-    let i = 0u;\n-    let len = byte_len(s);\n-    while i < len {\n-        let cur = char_range_at(s, i);\n-        buf += [cur.ch];\n-        i = cur.next;\n-    }\n-    ret buf;\n-}\n-\n-fn push_char(s: &mutable str, ch: char) { s += from_char(ch); }\n-\n-fn pop_char(s: &mutable str) -> char {\n-    let end = byte_len(s);\n-    while end > 0u && s[end - 1u] & 192u8 == tag_cont_u8 { end -= 1u; }\n-    assert (end > 0u);\n-    let ch = char_at(s, end - 1u);\n-    s = substr(s, 0u, end - 1u);\n-    ret ch;\n-}\n-\n-fn shift_char(s: &mutable str) -> char {\n-    let r = char_range_at(s, 0u);\n-    s = substr(s, r.next, byte_len(s) - r.next);\n-    ret r.ch;\n-}\n-\n-fn unshift_char(s: &mutable str, ch: char) { s = from_char(ch) + s; }\n-\n-fn refcount(s: str) -> uint {\n-    let r = rustrt::refcount::<u8>(s);\n-    if r == dbg::const_refcount { ret r; } else { ret r - 1u; }\n-}\n-\n-\n-// Standard bits from the world of string libraries.\n-fn index(s: str, c: u8) -> int {\n-    let i: int = 0;\n-    for k: u8 in s { if k == c { ret i; } i += 1; }\n-    ret -1;\n-}\n-\n-fn rindex(s: str, c: u8) -> int {\n-    let n: int = byte_len(s) as int;\n-    while n >= 0 { if s[n] == c { ret n; } n -= 1; }\n-    ret n;\n-}\n-\n-fn find(haystack: str, needle: str) -> int {\n-    let haystack_len: int = byte_len(haystack) as int;\n-    let needle_len: int = byte_len(needle) as int;\n-    if needle_len == 0 { ret 0; }\n-    fn match_at(haystack: &str, needle: &str, i: int) -> bool {\n-        let j: int = i;\n-        for c: u8 in needle { if haystack[j] != c { ret false; } j += 1; }\n-        ret true;\n-    }\n-    let i: int = 0;\n-    while i <= haystack_len - needle_len {\n-        if match_at(haystack, needle, i) { ret i; }\n-        i += 1;\n-    }\n-    ret -1;\n-}\n-\n-fn starts_with(haystack: str, needle: str) -> bool {\n-    let haystack_len: uint = byte_len(haystack);\n-    let needle_len: uint = byte_len(needle);\n-    if needle_len == 0u { ret true; }\n-    if needle_len > haystack_len { ret false; }\n-    ret eq(substr(haystack, 0u, needle_len), needle);\n-}\n-\n-fn ends_with(haystack: str, needle: str) -> bool {\n-    let haystack_len: uint = byte_len(haystack);\n-    let needle_len: uint = byte_len(needle);\n-    ret if needle_len == 0u {\n-            true\n-        } else if needle_len > haystack_len {\n-            false\n-        } else {\n-            eq(substr(haystack, haystack_len - needle_len, needle_len),\n-               needle)\n-        };\n-}\n-\n-fn substr(s: str, begin: uint, len: uint) -> str {\n-    ret slice(s, begin, begin + len);\n-}\n-\n-fn slice(s: str, begin: uint, end: uint) -> str {\n-    // FIXME: Typestate precondition\n-\n-    assert (begin <= end);\n-    assert (end <= byte_len(s));\n-    ret rustrt::str_slice(s, begin, end);\n-}\n-\n-fn safe_slice(s: str, begin: uint, end: uint) : le(begin, end) -> str {\n-    // would need some magic to\n-    // make this a precondition\n-    assert (end <= byte_len(s));\n-\n-    ret rustrt::str_slice(s, begin, end);\n-}\n-\n-fn shift_byte(s: &mutable str) -> u8 {\n-    let len = byte_len(s);\n-    assert (len > 0u);\n-    let b = s[0];\n-    s = substr(s, 1u, len - 1u);\n-    ret b;\n-}\n-\n-fn pop_byte(s: &mutable str) -> u8 {\n-    let len = byte_len(s);\n-    assert (len > 0u);\n-    let b = s[len - 1u];\n-    s = substr(s, 0u, len - 1u);\n-    ret b;\n-}\n-\n-fn push_byte(s: &mutable str, b: u8) {\n-    s = rustrt::str_push_byte(s, b as uint);\n-}\n-\n-fn unshift_byte(s: &mutable str, b: u8) {\n-    let rs = alloc(byte_len(s) + 1u);\n-    rs += unsafe_from_byte(b);\n-    rs += s;\n-    s = rs;\n-}\n-\n-fn split(s: str, sep: u8) -> [str] {\n-    let v: [str] = [];\n-    let accum: str = \"\";\n-    let ends_with_sep: bool = false;\n-    for c: u8 in s {\n-        if c == sep {\n-            v += [accum];\n-            accum = \"\";\n-            ends_with_sep = true;\n-        } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n-    }\n-    if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n-    ret v;\n-}\n-\n-fn concat(v: &[str]) -> str {\n-    let s: str = \"\";\n-    for ss: str in v { s += ss; }\n-    ret s;\n-}\n-\n-fn connect(v: &[str], sep: str) -> str {\n-    let s: str = \"\";\n-    let first: bool = true;\n-    for ss: str in v {\n-        if first { first = false; } else { s += sep; }\n-        s += ss;\n-    }\n-    ret s;\n-}\n-\n-\n-// FIXME: This only handles ASCII\n-fn to_upper(s: str) -> str {\n-    let outstr = \"\";\n-    let ascii_a = 'a' as u8;\n-    let ascii_z = 'z' as u8;\n-    let diff = 32u8;\n-    for byte: u8 in s {\n-        let next;\n-        if ascii_a <= byte && byte <= ascii_z {\n-            next = byte - diff;\n-        } else { next = byte; }\n-        push_byte(outstr, next);\n-    }\n-    ret outstr;\n-}\n-\n-// FIXME: This is super-inefficient\n-fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str {\n-    // FIXME (694): Shouldn't have to check this\n-    check (is_not_empty(from));\n-    if byte_len(s) == 0u {\n-        ret \"\";\n-    } else if starts_with(s, from) {\n-        ret to + replace(slice(s, byte_len(from), byte_len(s)), from, to);\n-    } else {\n-        ret unsafe_from_byte(s[0]) +\n-                replace(slice(s, 1u, byte_len(s)), from, to);\n-    }\n-}\n-\n-// FIXME: Also not efficient\n-fn char_slice(s: &str, begin: uint, end: uint) -> str {\n-    from_chars(vec::slice(to_chars(s), begin, end))\n-}\n-\n-fn trim_left(s: &str) -> str {\n-    fn count_whities(s: &[char]) -> uint {\n-        let i = 0u;\n-        while i < vec::len(s) {\n-            if !char::is_whitespace(s[i]) { break; }\n-            i += 1u;\n-        }\n-        ret i;\n-    }\n-    let chars = to_chars(s);\n-    let whities = count_whities(chars);\n-    ret from_chars(vec::slice(chars, whities, vec::len(chars)));\n-}\n-\n-fn trim_right(s: &str) -> str {\n-    fn count_whities(s: &[char]) -> uint {\n-        let i = vec::len(s);\n-        while 0u < i {\n-            if !char::is_whitespace(s[i - 1u]) { break; }\n-            i -= 1u;\n-        }\n-        ret i;\n-    }\n-    let chars = to_chars(s);\n-    let whities = count_whities(chars);\n-    ret from_chars(vec::slice(chars, 0u, whities));\n-}\n-\n-fn trim(s: &str) -> str { trim_left(trim_right(s)) }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:"}]}