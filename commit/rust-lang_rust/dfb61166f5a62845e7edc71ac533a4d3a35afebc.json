{"sha": "dfb61166f5a62845e7edc71ac533a4d3a35afebc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmYjYxMTY2ZjVhNjI4NDVlN2VkYzcxYWM1MzNhNGQzYTM1YWZlYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-29T19:36:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-29T19:36:41Z"}, "message": "auto merge of #11877 : Armavica/rust/doc-pm-vector, r=alexcrichton\n\nThis feature already was in the tutorial, but I believe that the tutorial should be a strict subset of the manual.\r\n\r\nI also added an example.", "tree": {"sha": "a7d9cf4ccdbc44ce8c23f3cb2655dc656f07bbab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7d9cf4ccdbc44ce8c23f3cb2655dc656f07bbab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfb61166f5a62845e7edc71ac533a4d3a35afebc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfb61166f5a62845e7edc71ac533a4d3a35afebc", "html_url": "https://github.com/rust-lang/rust/commit/dfb61166f5a62845e7edc71ac533a4d3a35afebc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfb61166f5a62845e7edc71ac533a4d3a35afebc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3ae182d5ce005e15d3d1f2906bd67cb65c61f8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ae182d5ce005e15d3d1f2906bd67cb65c61f8d", "html_url": "https://github.com/rust-lang/rust/commit/c3ae182d5ce005e15d3d1f2906bd67cb65c61f8d"}, {"sha": "d62097d88cee0ced0eb9508313c48d03ba355e51", "url": "https://api.github.com/repos/rust-lang/rust/commits/d62097d88cee0ced0eb9508313c48d03ba355e51", "html_url": "https://github.com/rust-lang/rust/commit/d62097d88cee0ced0eb9508313c48d03ba355e51"}], "stats": {"total": 51, "additions": 38, "deletions": 13}, "files": [{"sha": "503d1a1072b91abe1b35797db59c7f6855b7d3a2", "filename": "doc/rust.md", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/dfb61166f5a62845e7edc71ac533a4d3a35afebc/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfb61166f5a62845e7edc71ac533a4d3a35afebc/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=dfb61166f5a62845e7edc71ac533a4d3a35afebc", "patch": "@@ -2818,14 +2818,15 @@ match_pat : pat [ \"..\" pat ] ? [ \"if\" expr ] ;\n \n A `match` expression branches on a *pattern*. The exact form of matching that\n occurs depends on the pattern. Patterns consist of some combination of\n-literals, destructured enum constructors, structures, records and tuples, variable binding\n-specifications, wildcards (`..`), and placeholders (`_`). A `match` expression has a *head\n-expression*, which is the value to compare to the patterns. The type of the\n-patterns must equal the type of the head expression.\n+literals, destructured vectors or enum constructors, structures, records and\n+tuples, variable binding specifications, wildcards (`..`), and placeholders\n+(`_`). A `match` expression has a *head expression*, which is the value to\n+compare to the patterns. The type of the patterns must equal the type of the\n+head expression.\n \n-In a pattern whose head expression has an `enum` type, a placeholder (`_`) stands for a\n-*single* data field, whereas a wildcard `..` stands for *all* the fields of a particular\n-variant. For example:\n+In a pattern whose head expression has an `enum` type, a placeholder (`_`)\n+stands for a *single* data field, whereas a wildcard `..` stands for *all* the\n+fields of a particular variant. For example:\n \n ~~~~\n enum List<X> { Nil, Cons(X, ~List<X>) }\n@@ -2839,11 +2840,35 @@ match x {\n }\n ~~~~\n \n-The first pattern matches lists constructed by applying `Cons` to any head value, and a\n-tail value of `~Nil`. The second pattern matches _any_ list constructed with `Cons`,\n-ignoring the values of its arguments. The difference between `_` and `..` is that the pattern\n-`C(_)` is only type-correct if `C` has exactly one argument, while the pattern `C(..)` is\n-type-correct for any enum variant `C`, regardless of how many arguments `C` has.\n+The first pattern matches lists constructed by applying `Cons` to any head\n+value, and a tail value of `~Nil`. The second pattern matches _any_ list\n+constructed with `Cons`, ignoring the values of its arguments. The difference\n+between `_` and `..` is that the pattern `C(_)` is only type-correct if `C` has\n+exactly one argument, while the pattern `C(..)` is type-correct for any enum\n+variant `C`, regardless of how many arguments `C` has.\n+\n+Used inside a vector pattern, `..` stands for any number of elements. This\n+wildcard can be used at most once for a given vector, which implies that it\n+cannot be used to specifically match elements that are at an unknown distance\n+from both ends of a vector, like `[.., 42, ..]`. If followed by a variable name,\n+it will bind the corresponding slice to the variable. Example:\n+\n+~~~~\n+fn is_symmetric(list: &[uint]) -> bool {\n+    match list {\n+        [] | [_]                   => true,\n+        [x, ..inside, y] if x == y => is_symmetric(inside),\n+        _                          => false\n+    }\n+}\n+\n+fn main() {\n+    let sym     = &[0, 1, 4, 2, 4, 1, 0];\n+    let not_sym = &[0, 1, 7, 2, 4, 1, 0];\n+    assert!(is_symmetric(sym));\n+    assert!(!is_symmetric(not_sym));\n+}\n+~~~~\n \n A `match` behaves differently depending on whether or not the head expression\n is an [lvalue or an rvalue](#lvalues-rvalues-and-temporaries).\n@@ -2926,7 +2951,7 @@ let z = match x { &0 => \"zero\", _ => \"some\" };\n assert_eq!(y, z);\n ~~~~\n \n-A pattern that's just an identifier, like `Nil` in the previous answer,\n+A pattern that's just an identifier, like `Nil` in the previous example,\n could either refer to an enum variant that's in scope, or bind a new variable.\n The compiler resolves this ambiguity by forbidding variable bindings that occur\n in `match` patterns from shadowing names of variants that are in scope."}]}