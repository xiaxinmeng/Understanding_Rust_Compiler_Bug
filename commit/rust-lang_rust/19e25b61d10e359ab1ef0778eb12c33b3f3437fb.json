{"sha": "19e25b61d10e359ab1ef0778eb12c33b3f3437fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZTI1YjYxZDEwZTM1OWFiMWVmMDc3OGViMTJjMzNiM2YzNDM3ZmI=", "commit": {"author": {"name": "Sunjay Varma", "email": "varma.sunjay@gmail.com", "date": "2017-11-05T21:14:22Z"}, "committer": {"name": "Sunjay Varma", "email": "varma.sunjay@gmail.com", "date": "2017-12-01T06:24:53Z"}, "message": "Parsing generics in both trait items and impl items", "tree": {"sha": "a661e34f6fadc5d009137238e2c41906dca1e99d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a661e34f6fadc5d009137238e2c41906dca1e99d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19e25b61d10e359ab1ef0778eb12c33b3f3437fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19e25b61d10e359ab1ef0778eb12c33b3f3437fb", "html_url": "https://github.com/rust-lang/rust/commit/19e25b61d10e359ab1ef0778eb12c33b3f3437fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19e25b61d10e359ab1ef0778eb12c33b3f3437fb/comments", "author": {"login": "sunjay", "id": 530939, "node_id": "MDQ6VXNlcjUzMDkzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/530939?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunjay", "html_url": "https://github.com/sunjay", "followers_url": "https://api.github.com/users/sunjay/followers", "following_url": "https://api.github.com/users/sunjay/following{/other_user}", "gists_url": "https://api.github.com/users/sunjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunjay/subscriptions", "organizations_url": "https://api.github.com/users/sunjay/orgs", "repos_url": "https://api.github.com/users/sunjay/repos", "events_url": "https://api.github.com/users/sunjay/events{/privacy}", "received_events_url": "https://api.github.com/users/sunjay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sunjay", "id": 530939, "node_id": "MDQ6VXNlcjUzMDkzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/530939?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunjay", "html_url": "https://github.com/sunjay", "followers_url": "https://api.github.com/users/sunjay/followers", "following_url": "https://api.github.com/users/sunjay/following{/other_user}", "gists_url": "https://api.github.com/users/sunjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunjay/subscriptions", "organizations_url": "https://api.github.com/users/sunjay/orgs", "repos_url": "https://api.github.com/users/sunjay/repos", "events_url": "https://api.github.com/users/sunjay/events{/privacy}", "received_events_url": "https://api.github.com/users/sunjay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "804b15be82ea668d943fab70195eb57a2f942d4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/804b15be82ea668d943fab70195eb57a2f942d4b", "html_url": "https://github.com/rust-lang/rust/commit/804b15be82ea668d943fab70195eb57a2f942d4b"}], "stats": {"total": 39, "additions": 36, "deletions": 3}, "files": [{"sha": "ad7d0d22f81fca0117fcf52e203a734a16373a24", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/19e25b61d10e359ab1ef0778eb12c33b3f3437fb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e25b61d10e359ab1ef0778eb12c33b3f3437fb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=19e25b61d10e359ab1ef0778eb12c33b3f3437fb", "patch": "@@ -1293,9 +1293,10 @@ impl<'a> Parser<'a> {\n         let lo = self.span;\n \n         let (name, node, generics) = if self.eat_keyword(keywords::Type) {\n-            let TyParam {ident, bounds, default, ..} = self.parse_ty_param(vec![])?;\n+            let (generics, TyParam {ident, bounds, default, ..}) =\n+                self.parse_trait_item_assoc_ty(vec![])?;\n             self.expect(&token::Semi)?;\n-            (ident, TraitItemKind::Type(bounds, default), ast::Generics::default())\n+            (ident, TraitItemKind::Type(bounds, default), generics)\n         } else if self.is_const_item() {\n             self.expect_keyword(keywords::Const)?;\n             let ident = self.parse_ident()?;\n@@ -4442,6 +4443,36 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    fn parse_trait_item_assoc_ty(&mut self, preceding_attrs: Vec<Attribute>)\n+        -> PResult<'a, (Generics, TyParam)> {\n+        let span = self.span;\n+        let ident = self.parse_ident()?;\n+        let mut generics = self.parse_generics()?;\n+\n+        // Parse optional colon and param bounds.\n+        let bounds = if self.eat(&token::Colon) {\n+            self.parse_ty_param_bounds()?\n+        } else {\n+            Vec::new()\n+        };\n+\n+        let default = if self.eat(&token::Eq) {\n+            Some(self.parse_ty()?)\n+        } else {\n+            None\n+        };\n+        generics.where_clause = self.parse_where_clause()?;\n+\n+        Ok((Generics, TyParam {\n+            attrs: preceding_attrs.into(),\n+            ident,\n+            id: ast::DUMMY_NODE_ID,\n+            bounds,\n+            default,\n+            span,\n+        }))\n+    }\n+\n     /// Parses (possibly empty) list of lifetime and type parameters, possibly including\n     /// trailing comma and erroneous trailing attributes.\n     pub fn parse_generic_params(&mut self) -> PResult<'a, (Vec<LifetimeDef>, Vec<TyParam>)> {\n@@ -4984,10 +5015,12 @@ impl<'a> Parser<'a> {\n         let defaultness = self.parse_defaultness()?;\n         let (name, node, generics) = if self.eat_keyword(keywords::Type) {\n             let name = self.parse_ident()?;\n+            let mut generics = self.parse_generics()?;\n             self.expect(&token::Eq)?;\n             let typ = self.parse_ty()?;\n+            generics.where_clause = self.parse_where_clause()?;\n             self.expect(&token::Semi)?;\n-            (name, ast::ImplItemKind::Type(typ), ast::Generics::default())\n+            (name, ast::ImplItemKind::Type(typ), generics)\n         } else if self.is_const_item() {\n             self.expect_keyword(keywords::Const)?;\n             let name = self.parse_ident()?;"}]}