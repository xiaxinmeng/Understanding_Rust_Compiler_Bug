{"sha": "6a3fb269ede7d18de3597cae8d35edbb9b7c6c44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhM2ZiMjY5ZWRlN2QxOGRlMzU5N2NhZThkMzVlZGJiOWI3YzZjNDQ=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-03-23T13:02:58Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-04-23T11:06:16Z"}, "message": "Rename `Item` to `ConstCx`.\n\nThis renaming was already done in some modules via import renaming. It's strictly used as a context, and it contains a `TyCtxt`.", "tree": {"sha": "1406484e0a46a93c5494b0aea17ca348fd38e0e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1406484e0a46a93c5494b0aea17ca348fd38e0e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44", "html_url": "https://github.com/rust-lang/rust/commit/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a135ced5ce76a842c85a9b62baccefc5e53fb31c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a135ced5ce76a842c85a9b62baccefc5e53fb31c", "html_url": "https://github.com/rust-lang/rust/commit/a135ced5ce76a842c85a9b62baccefc5e53fb31c"}], "stats": {"total": 240, "additions": 120, "deletions": 120}, "files": [{"sha": "3812872ff785c0a5a2e30ddf62a4763764429e62", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=6a3fb269ede7d18de3597cae8d35edbb9b7c6c44", "patch": "@@ -20,20 +20,20 @@ pub mod validation;\n \n /// Information about the item currently being const-checked, as well as a reference to the global\n /// context.\n-pub struct Item<'mir, 'tcx> {\n+pub struct ConstCx<'mir, 'tcx> {\n     pub body: &'mir mir::Body<'tcx>,\n     pub tcx: TyCtxt<'tcx>,\n     pub def_id: DefId,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub const_kind: Option<ConstKind>,\n }\n \n-impl Item<'mir, 'tcx> {\n+impl ConstCx<'mir, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'mir mir::Body<'tcx>) -> Self {\n         let param_env = tcx.param_env(def_id);\n         let const_kind = ConstKind::for_item(tcx, def_id);\n \n-        Item { body, tcx, def_id, param_env, const_kind }\n+        ConstCx { body, tcx, def_id, param_env, const_kind }\n     }\n \n     /// Returns the kind of const context this `Item` represents (`const`, `static`, etc.)."}, {"sha": "60eb51f7ccabf03be4ef8261c14c11db87c92e5c", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=6a3fb269ede7d18de3597cae8d35edbb9b7c6c44", "patch": "@@ -7,7 +7,7 @@ use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol};\n \n-use super::{ConstKind, Item};\n+use super::{ConstCx, ConstKind};\n \n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n@@ -27,19 +27,19 @@ pub trait NonConstOp: std::fmt::Debug {\n     ///\n     /// By default, it returns `true` if and only if this operation has a corresponding feature\n     /// gate and that gate is enabled.\n-    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n-        Self::feature_gate().map_or(false, |gate| item.tcx.features().enabled(gate))\n+    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n+        Self::feature_gate().map_or(false, |gate| ccx.tcx.features().enabled(gate))\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0019,\n             \"{} contains unimplemented expression type\",\n-            item.const_kind()\n+            ccx.const_kind()\n         );\n-        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"A function call isn't allowed in the const's initialization expression \\\n                       because the expression's value must be known at compile-time.\",\n@@ -66,9 +66,9 @@ impl NonConstOp for Downcast {\n #[derive(Debug)]\n pub struct FnCallIndirect;\n impl NonConstOp for FnCallIndirect {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err =\n-            item.tcx.sess.struct_span_err(span, \"function pointers are not allowed in const fn\");\n+            ccx.tcx.sess.struct_span_err(span, \"function pointers are not allowed in const fn\");\n         err.emit();\n     }\n }\n@@ -77,14 +77,14 @@ impl NonConstOp for FnCallIndirect {\n #[derive(Debug)]\n pub struct FnCallNonConst(pub DefId);\n impl NonConstOp for FnCallNonConst {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0015,\n             \"calls in {}s are limited to constant functions, \\\n              tuple structs and tuple variants\",\n-            item.const_kind(),\n+            ccx.const_kind(),\n         );\n         err.emit();\n     }\n@@ -96,12 +96,12 @@ impl NonConstOp for FnCallNonConst {\n #[derive(Debug)]\n pub struct FnCallUnstable(pub DefId, pub Symbol);\n impl NonConstOp for FnCallUnstable {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let FnCallUnstable(def_id, feature) = *self;\n \n-        let mut err = item.tcx.sess.struct_span_err(\n+        let mut err = ccx.tcx.sess.struct_span_err(\n             span,\n-            &format!(\"`{}` is not yet stable as a const fn\", item.tcx.def_path_str(def_id)),\n+            &format!(\"`{}` is not yet stable as a const fn\", ccx.tcx.def_path_str(def_id)),\n         );\n         if nightly_options::is_nightly_build() {\n             err.help(&format!(\"add `#![feature({})]` to the crate attributes to enable\", feature));\n@@ -113,16 +113,16 @@ impl NonConstOp for FnCallUnstable {\n #[derive(Debug)]\n pub struct HeapAllocation;\n impl NonConstOp for HeapAllocation {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0010,\n             \"allocations are not allowed in {}s\",\n-            item.const_kind()\n+            ccx.const_kind()\n         );\n-        err.span_label(span, format!(\"allocation not allowed in {}s\", item.const_kind()));\n-        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+        err.span_label(span, format!(\"allocation not allowed in {}s\", ccx.const_kind()));\n+        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"The value of statics and constants must be known at compile time, \\\n                  and they live for the entire lifetime of a program. Creating a boxed \\\n@@ -141,9 +141,9 @@ impl NonConstOp for IfOrMatch {\n         Some(sym::const_if_match)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         // This should be caught by the HIR const-checker.\n-        item.tcx.sess.delay_span_bug(span, \"complex control flow is forbidden in a const context\");\n+        ccx.tcx.sess.delay_span_bug(span, \"complex control flow is forbidden in a const context\");\n     }\n }\n \n@@ -154,14 +154,14 @@ impl NonConstOp for InlineAsm {}\n #[derive(Debug)]\n pub struct LiveDrop;\n impl NonConstOp for LiveDrop {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0493,\n             \"destructors cannot be evaluated at compile-time\"\n         )\n-        .span_label(span, format!(\"{}s cannot evaluate destructors\", item.const_kind()))\n+        .span_label(span, format!(\"{}s cannot evaluate destructors\", ccx.const_kind()))\n         .emit();\n     }\n }\n@@ -173,18 +173,18 @@ impl NonConstOp for Loop {\n         Some(sym::const_loop)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         // This should be caught by the HIR const-checker.\n-        item.tcx.sess.delay_span_bug(span, \"complex control flow is forbidden in a const context\");\n+        ccx.tcx.sess.delay_span_bug(span, \"complex control flow is forbidden in a const context\");\n     }\n }\n \n #[derive(Debug)]\n pub struct CellBorrow;\n impl NonConstOp for CellBorrow {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0492,\n             \"cannot borrow a constant which may contain \\\n@@ -201,19 +201,19 @@ impl NonConstOp for MutBorrow {\n         Some(sym::const_mut_refs)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n             span,\n             &format!(\n                 \"references in {}s may only refer \\\n                       to immutable values\",\n-                item.const_kind()\n+                ccx.const_kind()\n             ),\n         );\n-        err.span_label(span, format!(\"{}s require immutable values\", item.const_kind()));\n-        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+        err.span_label(span, format!(\"{}s require immutable values\", ccx.const_kind()));\n+        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"References in statics and constants may only refer \\\n                       to immutable values.\\n\\n\\\n@@ -236,12 +236,12 @@ impl NonConstOp for MutAddressOf {\n         Some(sym::const_mut_refs)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n             span,\n-            &format!(\"`&raw mut` is not allowed in {}s\", item.const_kind()),\n+            &format!(\"`&raw mut` is not allowed in {}s\", ccx.const_kind()),\n         )\n         .emit();\n     }\n@@ -262,12 +262,12 @@ impl NonConstOp for Panic {\n         Some(sym::const_panic)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_panic,\n             span,\n-            &format!(\"panicking in {}s is unstable\", item.const_kind()),\n+            &format!(\"panicking in {}s is unstable\", ccx.const_kind()),\n         )\n         .emit();\n     }\n@@ -280,12 +280,12 @@ impl NonConstOp for RawPtrComparison {\n         Some(sym::const_compare_raw_pointers)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_compare_raw_pointers,\n             span,\n-            &format!(\"comparing raw pointers inside {}\", item.const_kind()),\n+            &format!(\"comparing raw pointers inside {}\", ccx.const_kind()),\n         )\n         .emit();\n     }\n@@ -298,12 +298,12 @@ impl NonConstOp for RawPtrDeref {\n         Some(sym::const_raw_ptr_deref)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_raw_ptr_deref,\n             span,\n-            &format!(\"dereferencing raw pointers in {}s is unstable\", item.const_kind(),),\n+            &format!(\"dereferencing raw pointers in {}s is unstable\", ccx.const_kind(),),\n         )\n         .emit();\n     }\n@@ -316,12 +316,12 @@ impl NonConstOp for RawPtrToIntCast {\n         Some(sym::const_raw_ptr_to_usize_cast)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_raw_ptr_to_usize_cast,\n             span,\n-            &format!(\"casting pointers to integers in {}s is unstable\", item.const_kind(),),\n+            &format!(\"casting pointers to integers in {}s is unstable\", ccx.const_kind(),),\n         )\n         .emit();\n     }\n@@ -331,22 +331,22 @@ impl NonConstOp for RawPtrToIntCast {\n #[derive(Debug)]\n pub struct StaticAccess;\n impl NonConstOp for StaticAccess {\n-    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n-        item.const_kind().is_static()\n+    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n+        ccx.const_kind().is_static()\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0013,\n             \"{}s cannot refer to statics\",\n-            item.const_kind()\n+            ccx.const_kind()\n         );\n         err.help(\n             \"consider extracting the value of the `static` to a `const`, and referring to that\",\n         );\n-        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"`static` and `const` variables can refer to other `const` variables. \\\n                     A `const` variable, however, cannot refer to a `static` variable.\",\n@@ -363,9 +363,9 @@ pub struct ThreadLocalAccess;\n impl NonConstOp for ThreadLocalAccess {\n     const IS_SUPPORTED_IN_MIRI: bool = false;\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0625,\n             \"thread-local statics cannot be \\\n@@ -378,19 +378,19 @@ impl NonConstOp for ThreadLocalAccess {\n #[derive(Debug)]\n pub struct UnionAccess;\n impl NonConstOp for UnionAccess {\n-    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n+    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n         // Union accesses are stable in all contexts except `const fn`.\n-        item.const_kind() != ConstKind::ConstFn\n-            || item.tcx.features().enabled(Self::feature_gate().unwrap())\n+        ccx.const_kind() != ConstKind::ConstFn\n+            || ccx.tcx.features().enabled(Self::feature_gate().unwrap())\n     }\n \n     fn feature_gate() -> Option<Symbol> {\n         Some(sym::const_fn_union)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_fn_union,\n             span,\n             \"unions in const fn are unstable\","}, {"sha": "f82f06599b74a0f0d5703d555f7592b4952a68b2", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=6a3fb269ede7d18de3597cae8d35edbb9b7c6c44", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::{self, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n \n-use super::Item as ConstCx;\n+use super::ConstCx;\n \n pub fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> ConstQualifs {\n     ConstQualifs {"}, {"sha": "a81d7a23be2fb640c0a60a58396770aa81e437fb", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=6a3fb269ede7d18de3597cae8d35edbb9b7c6c44", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::mir::{self, BasicBlock, Local, Location};\n \n use std::marker::PhantomData;\n \n-use super::{qualifs, Item, Qualif};\n+use super::{qualifs, ConstCx, Qualif};\n use crate::dataflow;\n \n /// A `Visitor` that propagates qualifs between locals. This defines the transfer function of\n@@ -18,7 +18,7 @@ use crate::dataflow;\n /// the `MaybeMutBorrowedLocals` dataflow pass to see if a `Local` may have become qualified via\n /// an indirect assignment or function call.\n struct TransferFunction<'a, 'mir, 'tcx, Q> {\n-    item: &'a Item<'mir, 'tcx>,\n+    ccx: &'a ConstCx<'mir, 'tcx>,\n     qualifs_per_local: &'a mut BitSet<Local>,\n \n     _qualif: PhantomData<Q>,\n@@ -28,16 +28,16 @@ impl<Q> TransferFunction<'a, 'mir, 'tcx, Q>\n where\n     Q: Qualif,\n {\n-    fn new(item: &'a Item<'mir, 'tcx>, qualifs_per_local: &'a mut BitSet<Local>) -> Self {\n-        TransferFunction { item, qualifs_per_local, _qualif: PhantomData }\n+    fn new(ccx: &'a ConstCx<'mir, 'tcx>, qualifs_per_local: &'a mut BitSet<Local>) -> Self {\n+        TransferFunction { ccx, qualifs_per_local, _qualif: PhantomData }\n     }\n \n     fn initialize_state(&mut self) {\n         self.qualifs_per_local.clear();\n \n-        for arg in self.item.body.args_iter() {\n-            let arg_ty = self.item.body.local_decls[arg].ty;\n-            if Q::in_any_value_of_ty(self.item, arg_ty) {\n+        for arg in self.ccx.body.args_iter() {\n+            let arg_ty = self.ccx.body.local_decls[arg].ty;\n+            if Q::in_any_value_of_ty(self.ccx, arg_ty) {\n                 self.qualifs_per_local.insert(arg);\n             }\n         }\n@@ -72,8 +72,8 @@ where\n     ) {\n         // We cannot reason about another function's internals, so use conservative type-based\n         // qualification for the result of a function call.\n-        let return_ty = return_place.ty(self.item.body, self.item.tcx).ty;\n-        let qualif = Q::in_any_value_of_ty(self.item, return_ty);\n+        let return_ty = return_place.ty(self.ccx.body, self.ccx.tcx).ty;\n+        let qualif = Q::in_any_value_of_ty(self.ccx, return_ty);\n \n         if !return_place.is_indirect() {\n             self.assign_qualif_direct(&return_place, qualif);\n@@ -108,7 +108,7 @@ where\n         location: Location,\n     ) {\n         let qualif = qualifs::in_rvalue::<Q, _>(\n-            self.item,\n+            self.ccx,\n             &mut |l| self.qualifs_per_local.contains(l),\n             rvalue,\n         );\n@@ -127,7 +127,7 @@ where\n \n         if let mir::TerminatorKind::DropAndReplace { value, location: dest, .. } = kind {\n             let qualif = qualifs::in_operand::<Q, _>(\n-                self.item,\n+                self.ccx,\n                 &mut |l| self.qualifs_per_local.contains(l),\n                 value,\n             );\n@@ -145,23 +145,23 @@ where\n \n /// The dataflow analysis used to propagate qualifs on arbitrary CFGs.\n pub(super) struct FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q> {\n-    item: &'a Item<'mir, 'tcx>,\n+    ccx: &'a ConstCx<'mir, 'tcx>,\n     _qualif: PhantomData<Q>,\n }\n \n impl<'a, 'mir, 'tcx, Q> FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>\n where\n     Q: Qualif,\n {\n-    pub(super) fn new(_: Q, item: &'a Item<'mir, 'tcx>) -> Self {\n-        FlowSensitiveAnalysis { item, _qualif: PhantomData }\n+    pub(super) fn new(_: Q, ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n+        FlowSensitiveAnalysis { ccx, _qualif: PhantomData }\n     }\n \n     fn transfer_function(\n         &self,\n         state: &'a mut BitSet<Local>,\n     ) -> TransferFunction<'a, 'mir, 'tcx, Q> {\n-        TransferFunction::<Q>::new(self.item, state)\n+        TransferFunction::<Q>::new(self.ccx, state)\n     }\n }\n "}, {"sha": "45d8e1d08b7219ded92ce987a9d020c96c9ec65a", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=6a3fb269ede7d18de3597cae8d35edbb9b7c6c44", "patch": "@@ -20,7 +20,7 @@ use std::ops::Deref;\n use super::ops::{self, NonConstOp};\n use super::qualifs::{self, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n-use super::{is_lang_panic_fn, ConstKind, Item, Qualif};\n+use super::{is_lang_panic_fn, ConstCx, ConstKind, Qualif};\n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::dataflow::MaybeMutBorrowedLocals;\n use crate::dataflow::{self, Analysis};\n@@ -37,15 +37,15 @@ struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n }\n \n impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n-    pub fn new(q: Q, item: &'a Item<'mir, 'tcx>) -> Self {\n-        let cursor = FlowSensitiveAnalysis::new(q, item)\n-            .into_engine(item.tcx, item.body, item.def_id)\n+    pub fn new(q: Q, ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n+        let cursor = FlowSensitiveAnalysis::new(q, ccx)\n+            .into_engine(ccx.tcx, ccx.body, ccx.def_id)\n             .iterate_to_fixpoint()\n-            .into_results_cursor(item.body);\n+            .into_results_cursor(ccx.body);\n \n-        let mut in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n-        for (local, decl) in item.body.local_decls.iter_enumerated() {\n-            if Q::in_any_value_of_ty(item, decl.ty) {\n+        let mut in_any_value_of_ty = BitSet::new_empty(ccx.body.local_decls.len());\n+        for (local, decl) in ccx.body.local_decls.iter_enumerated() {\n+            if Q::in_any_value_of_ty(ccx, decl.ty) {\n                 in_any_value_of_ty.insert(local);\n             }\n         }\n@@ -91,12 +91,12 @@ impl Qualifs<'a, 'mir, 'tcx> {\n             || self.indirectly_mutable(local, location)\n     }\n \n-    fn in_return_place(&mut self, item: &Item<'_, 'tcx>) -> ConstQualifs {\n+    fn in_return_place(&mut self, ccx: &ConstCx<'_, 'tcx>) -> ConstQualifs {\n         // Find the `Return` terminator if one exists.\n         //\n         // If no `Return` terminator exists, this MIR is divergent. Just return the conservative\n         // qualifs for the return type.\n-        let return_block = item\n+        let return_block = ccx\n             .body\n             .basic_blocks()\n             .iter_enumerated()\n@@ -107,11 +107,11 @@ impl Qualifs<'a, 'mir, 'tcx> {\n             .map(|(bb, _)| bb);\n \n         let return_block = match return_block {\n-            None => return qualifs::in_any_value_of_ty(item, item.body.return_ty()),\n+            None => return qualifs::in_any_value_of_ty(ccx, ccx.body.return_ty()),\n             Some(bb) => bb,\n         };\n \n-        let return_loc = item.body.terminator_loc(return_block);\n+        let return_loc = ccx.body.terminator_loc(return_block);\n \n         ConstQualifs {\n             needs_drop: self.needs_drop(RETURN_PLACE, return_loc),\n@@ -121,27 +121,27 @@ impl Qualifs<'a, 'mir, 'tcx> {\n }\n \n pub struct Validator<'a, 'mir, 'tcx> {\n-    item: &'a Item<'mir, 'tcx>,\n+    ccx: &'a ConstCx<'mir, 'tcx>,\n     qualifs: Qualifs<'a, 'mir, 'tcx>,\n \n     /// The span of the current statement.\n     span: Span,\n }\n \n impl Deref for Validator<'_, 'mir, 'tcx> {\n-    type Target = Item<'mir, 'tcx>;\n+    type Target = ConstCx<'mir, 'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n-        &self.item\n+        &self.ccx\n     }\n }\n \n impl Validator<'a, 'mir, 'tcx> {\n-    pub fn new(item: &'a Item<'mir, 'tcx>) -> Self {\n-        let Item { tcx, body, def_id, param_env, .. } = *item;\n+    pub fn new(ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n+        let ConstCx { tcx, body, def_id, param_env, .. } = *ccx;\n \n-        let needs_drop = QualifCursor::new(NeedsDrop, item);\n-        let has_mut_interior = QualifCursor::new(HasMutInterior, item);\n+        let needs_drop = QualifCursor::new(NeedsDrop, ccx);\n+        let has_mut_interior = QualifCursor::new(HasMutInterior, ccx);\n \n         // We can use `unsound_ignore_borrow_on_drop` here because custom drop impls are not\n         // allowed in a const.\n@@ -156,11 +156,11 @@ impl Validator<'a, 'mir, 'tcx> {\n \n         let qualifs = Qualifs { needs_drop, has_mut_interior, indirectly_mutable };\n \n-        Validator { span: item.body.span, item, qualifs }\n+        Validator { span: ccx.body.span, ccx, qualifs }\n     }\n \n     pub fn check_body(&mut self) {\n-        let Item { tcx, body, def_id, const_kind, .. } = *self.item;\n+        let ConstCx { tcx, body, def_id, const_kind, .. } = *self.ccx;\n \n         let use_min_const_fn_checks = (const_kind == Some(ConstKind::ConstFn)\n             && crate::const_eval::is_min_const_fn(tcx, def_id))\n@@ -175,7 +175,7 @@ impl Validator<'a, 'mir, 'tcx> {\n             }\n         }\n \n-        check_short_circuiting_in_const_local(self.item);\n+        check_short_circuiting_in_const_local(self.ccx);\n \n         if body.is_cfg_cyclic() {\n             // We can't provide a good span for the error here, but this should be caught by the\n@@ -196,7 +196,7 @@ impl Validator<'a, 'mir, 'tcx> {\n     }\n \n     pub fn qualifs_in_return_place(&mut self) -> ConstQualifs {\n-        self.qualifs.in_return_place(self.item)\n+        self.qualifs.in_return_place(self.ccx)\n     }\n \n     /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n@@ -344,7 +344,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             Rvalue::Ref(_, BorrowKind::Shared | BorrowKind::Shallow, ref place)\n             | Rvalue::AddressOf(Mutability::Not, ref place) => {\n                 let borrowed_place_has_mut_interior = qualifs::in_place::<HasMutInterior, _>(\n-                    &self.item,\n+                    &self.ccx,\n                     &mut |local| self.qualifs.has_mut_interior(local, location),\n                     place.as_ref(),\n                 );\n@@ -608,8 +608,8 @@ fn error_min_const_fn_violation(tcx: TyCtxt<'_>, span: Span, msg: Cow<'_, str>)\n         .emit();\n }\n \n-fn check_short_circuiting_in_const_local(item: &Item<'_, 'tcx>) {\n-    let body = item.body;\n+fn check_short_circuiting_in_const_local(ccx: &ConstCx<'_, 'tcx>) {\n+    let body = ccx.body;\n \n     if body.control_flow_destroyed.is_empty() {\n         return;\n@@ -618,12 +618,12 @@ fn check_short_circuiting_in_const_local(item: &Item<'_, 'tcx>) {\n     let mut locals = body.vars_iter();\n     if let Some(local) = locals.next() {\n         let span = body.local_decls[local].source_info.span;\n-        let mut error = item.tcx.sess.struct_span_err(\n+        let mut error = ccx.tcx.sess.struct_span_err(\n             span,\n             &format!(\n                 \"new features like let bindings are not permitted in {}s \\\n                 which also use short circuiting operators\",\n-                item.const_kind(),\n+                ccx.const_kind(),\n             ),\n         );\n         for (span, kind) in body.control_flow_destroyed.iter() {"}, {"sha": "a87955274a779c790fad76c083ff0dfcc0aaf49d", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=6a3fb269ede7d18de3597cae8d35edbb9b7c6c44", "patch": "@@ -194,10 +194,10 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n         return Default::default();\n     }\n \n-    let item =\n-        check_consts::Item { body, tcx, def_id, const_kind, param_env: tcx.param_env(def_id) };\n+    let ccx =\n+        check_consts::ConstCx { body, tcx, def_id, const_kind, param_env: tcx.param_env(def_id) };\n \n-    let mut validator = check_consts::validation::Validator::new(&item);\n+    let mut validator = check_consts::validation::Validator::new(&ccx);\n     validator.check_body();\n \n     // We return the qualifs in the return place for every MIR body, even though it is only used"}, {"sha": "b11dbef3294b5b8cc5ddc93e7a5cd252aa3fc216", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3fb269ede7d18de3597cae8d35edbb9b7c6c44/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=6a3fb269ede7d18de3597cae8d35edbb9b7c6c44", "patch": "@@ -30,7 +30,7 @@ use std::cell::Cell;\n use std::{cmp, iter, mem};\n \n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n-use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstKind, Item};\n+use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstCx, ConstKind};\n use crate::transform::{MirPass, MirSource};\n \n /// A `MirPass` for promotion.\n@@ -264,7 +264,7 @@ pub fn collect_temps_and_candidates(\n ///\n /// This wraps an `Item`, and has access to all fields of that `Item` via `Deref` coercion.\n struct Validator<'a, 'tcx> {\n-    item: Item<'a, 'tcx>,\n+    ccx: ConstCx<'a, 'tcx>,\n     temps: &'a IndexVec<Local, TempState>,\n \n     /// Explicit promotion happens e.g. for constant arguments declared via\n@@ -277,10 +277,10 @@ struct Validator<'a, 'tcx> {\n }\n \n impl std::ops::Deref for Validator<'a, 'tcx> {\n-    type Target = Item<'a, 'tcx>;\n+    type Target = ConstCx<'a, 'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n-        &self.item\n+        &self.ccx\n     }\n }\n \n@@ -413,7 +413,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let statement = &self.body[loc.block].statements[loc.statement_index];\n                 match &statement.kind {\n                     StatementKind::Assign(box (_, rhs)) => qualifs::in_rvalue::<Q, _>(\n-                        &self.item,\n+                        &self.ccx,\n                         &mut |l| self.qualif_local::<Q>(l),\n                         rhs,\n                     ),\n@@ -430,7 +430,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 match &terminator.kind {\n                     TerminatorKind::Call { .. } => {\n                         let return_ty = self.body.local_decls[local].ty;\n-                        Q::in_any_value_of_ty(&self.item, return_ty)\n+                        Q::in_any_value_of_ty(&self.ccx, return_ty)\n                     }\n                     kind => {\n                         span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n@@ -723,7 +723,7 @@ pub fn validate_candidates(\n     temps: &IndexVec<Local, TempState>,\n     candidates: &[Candidate],\n ) -> Vec<Candidate> {\n-    let mut validator = Validator { item: Item::new(tcx, def_id, body), temps, explicit: false };\n+    let mut validator = Validator { ccx: ConstCx::new(tcx, def_id, body), temps, explicit: false };\n \n     candidates\n         .iter()\n@@ -1155,7 +1155,7 @@ crate fn should_suggest_const_in_array_repeat_expressions_attribute<'tcx>(\n     let mut rpo = traversal::reverse_postorder(&body);\n     let (temps, _) = collect_temps_and_candidates(tcx, &body, &mut rpo);\n     let validator =\n-        Validator { item: Item::new(tcx, mir_def_id, body), temps: &temps, explicit: false };\n+        Validator { ccx: ConstCx::new(tcx, mir_def_id, body), temps: &temps, explicit: false };\n \n     let should_promote = validator.validate_operand(operand).is_ok();\n     let feature_flag = tcx.features().const_in_array_repeat_expressions;"}]}