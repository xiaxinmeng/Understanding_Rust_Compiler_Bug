{"sha": "556b0815d779a50a151c44032febf3ce253e621e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NmIwODE1ZDc3OWE1MGExNTFjNDQwMzJmZWJmM2NlMjUzZTYyMWU=", "commit": {"author": {"name": "Leif Arne Storset", "email": "leifarne@storset.net", "date": "2015-07-19T14:23:40Z"}, "committer": {"name": "Leif Arne Storset", "email": "leifarne@storset.net", "date": "2015-07-30T19:49:13Z"}, "message": "Using operator traits in generic structs", "tree": {"sha": "0f88ea62fb6a2ae0def84e4ac721841ab6dad2b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f88ea62fb6a2ae0def84e4ac721841ab6dad2b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/556b0815d779a50a151c44032febf3ce253e621e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/556b0815d779a50a151c44032febf3ce253e621e", "html_url": "https://github.com/rust-lang/rust/commit/556b0815d779a50a151c44032febf3ce253e621e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/556b0815d779a50a151c44032febf3ce253e621e/comments", "author": {"login": "lastorset", "id": 464989, "node_id": "MDQ6VXNlcjQ2NDk4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/464989?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lastorset", "html_url": "https://github.com/lastorset", "followers_url": "https://api.github.com/users/lastorset/followers", "following_url": "https://api.github.com/users/lastorset/following{/other_user}", "gists_url": "https://api.github.com/users/lastorset/gists{/gist_id}", "starred_url": "https://api.github.com/users/lastorset/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lastorset/subscriptions", "organizations_url": "https://api.github.com/users/lastorset/orgs", "repos_url": "https://api.github.com/users/lastorset/repos", "events_url": "https://api.github.com/users/lastorset/events{/privacy}", "received_events_url": "https://api.github.com/users/lastorset/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lastorset", "id": 464989, "node_id": "MDQ6VXNlcjQ2NDk4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/464989?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lastorset", "html_url": "https://github.com/lastorset", "followers_url": "https://api.github.com/users/lastorset/followers", "following_url": "https://api.github.com/users/lastorset/following{/other_user}", "gists_url": "https://api.github.com/users/lastorset/gists{/gist_id}", "starred_url": "https://api.github.com/users/lastorset/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lastorset/subscriptions", "organizations_url": "https://api.github.com/users/lastorset/orgs", "repos_url": "https://api.github.com/users/lastorset/repos", "events_url": "https://api.github.com/users/lastorset/events{/privacy}", "received_events_url": "https://api.github.com/users/lastorset/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e92165eafee26e0fb27f9a3756e8a68884d685d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e92165eafee26e0fb27f9a3756e8a68884d685d", "html_url": "https://github.com/rust-lang/rust/commit/0e92165eafee26e0fb27f9a3756e8a68884d685d"}], "stats": {"total": 58, "additions": 58, "deletions": 0}, "files": [{"sha": "e53664eeb552662e2b0e4a17aafd17dea37c2adb", "filename": "src/doc/trpl/operators-and-overloading.md", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/556b0815d779a50a151c44032febf3ce253e621e/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/556b0815d779a50a151c44032febf3ce253e621e/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md?ref=556b0815d779a50a151c44032febf3ce253e621e", "patch": "@@ -81,3 +81,55 @@ will let you do this:\n let p: Point = // ...\n let x: f64 = p + 2i32;\n ```\n+\n+# Using operator traits in generic structs\n+\n+Now that we know how operator traits are defined, we can define our `HasArea`\n+trait and `Square` struct from the [traits chapter][traits] more generically:\n+\n+[traits]: traits.html\n+\n+```rust\n+use std::ops::Mul;\n+\n+trait HasArea<T> {\n+    fn area(&self) -> T;\n+}\n+\n+struct Square<T> {\n+    x: T,\n+    y: T,\n+    side: T,\n+}\n+\n+impl<T> HasArea<T> for Square<T>\n+        where T: Mul<Output=T> + Copy {\n+    fn area(&self) -> T {\n+        self.side * self.side\n+    }\n+}\n+\n+fn main() {\n+    let s = Square {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        side: 12.0f64,\n+    };\n+\n+    println!(\"Area of s: {}\", s.area());\n+}\n+```\n+\n+For `HasArea` and `Square`, we just declare a type parameter `T` and replace\n+`f64` with it. The `impl` needs more involved modifications:\n+\n+```ignore\n+impl<T> HasArea<T> for Square<T>\n+        where T: Mul<Output=T> + Copy { ... }\n+```\n+\n+The `area` method requires that we can multiply the sides, so we declare that\n+type `T` must implement `std::ops::Mul`. Like `Add`, mentioned above, `Mul`\n+itself takes an `Output` parameter: since we know that numbers don't change\n+type when multiplied, we also set it to `T`. `T` must also support copying, so\n+Rust doesn't try to move `self.side` into the return value."}, {"sha": "0f2efd4657bf7a9ba045235e9c7ddcdfa78dfcde", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/556b0815d779a50a151c44032febf3ce253e621e/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/556b0815d779a50a151c44032febf3ce253e621e/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=556b0815d779a50a151c44032febf3ce253e621e", "patch": "@@ -199,7 +199,13 @@ equality.\n \n [PartialEq]: ../core/cmp/trait.PartialEq.html\n \n+Here we defined a new struct `Rectangle` that accepts numbers of any\n+precision\u2014really, objects of pretty much any type\u2014as long as they can be\n+compared for equality. Could we do the same for our `HasArea` structs, `Square`\n+and `Circle`? Yes, but they need multiplication, and to work with that we need\n+to know more about [operator traits][operators-and-overloading].\n \n+[operators-and-overloading]: operators-and-overloading.html\n \n # Rules for implementing traits\n "}]}