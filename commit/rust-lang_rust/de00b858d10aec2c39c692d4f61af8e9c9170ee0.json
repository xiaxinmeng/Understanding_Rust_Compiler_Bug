{"sha": "de00b858d10aec2c39c692d4f61af8e9c9170ee0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMDBiODU4ZDEwYWVjMmMzOWM2OTJkNGY2MWFmOGU5YzkxNzBlZTA=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-01T17:46:53Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-03T02:55:37Z"}, "message": "metadata: Introduce `EsSub8` and `EsSub32` tags.\n\nThey replace the existing `EsEnumVid`, `EsVecLen` and `EsMapLen`\ntags altogether; the meaning of them can be easily inferred\nfrom the enclosing tag. It also has an added benefit of\nencodings for smaller variant ids or lengths being more compact\n(5 bytes to 2 bytes).", "tree": {"sha": "bcc26b8f7ed7346dfd1ae78d20a69ca58e9b655d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcc26b8f7ed7346dfd1ae78d20a69ca58e9b655d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de00b858d10aec2c39c692d4f61af8e9c9170ee0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de00b858d10aec2c39c692d4f61af8e9c9170ee0", "html_url": "https://github.com/rust-lang/rust/commit/de00b858d10aec2c39c692d4f61af8e9c9170ee0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de00b858d10aec2c39c692d4f61af8e9c9170ee0/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35c798b3fcef00f6a31b40da91afa596a1476b4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/35c798b3fcef00f6a31b40da91afa596a1476b4b", "html_url": "https://github.com/rust-lang/rust/commit/35c798b3fcef00f6a31b40da91afa596a1476b4b"}], "stats": {"total": 112, "additions": 77, "deletions": 35}, "files": [{"sha": "fc4fbb36707ea77da48e3d1ed802e33efb26f240", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 77, "deletions": 35, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/de00b858d10aec2c39c692d4f61af8e9c9170ee0/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de00b858d10aec2c39c692d4f61af8e9c9170ee0/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=de00b858d10aec2c39c692d4f61af8e9c9170ee0", "patch": "@@ -97,32 +97,29 @@ pub enum EbmlEncoderTag {\n     EsChar     = 0x0b, // + 4 bytes\n     EsF64      = 0x0c, // + 8 bytes\n     EsF32      = 0x0d, // + 4 bytes\n-    EsEnumVid  = 0x0e, // + 4 bytes\n-    EsVecLen   = 0x0f, // + 4 bytes\n-    EsMapLen   = 0x10, // + 4 bytes\n-\n-    EsStr      = 0x11,\n-    EsEnum     = 0x12,\n-    EsVec      = 0x13,\n-    EsVecElt   = 0x14,\n-    EsMap      = 0x15,\n-    EsMapKey   = 0x16,\n-    EsMapVal   = 0x17,\n-    EsOpaque   = 0x18,\n+    EsSub8     = 0x0e, // + 1 byte\n+    EsSub32    = 0x0f, // + 4 bytes\n+\n+    EsStr      = 0x10,\n+    EsEnum     = 0x11, // encodes the variant id as the first EsSub*\n+    EsVec      = 0x12, // encodes the # of elements as the first EsSub*\n+    EsVecElt   = 0x13,\n+    EsMap      = 0x14, // encodes the # of pairs as the first EsSub*\n+    EsMapKey   = 0x15,\n+    EsMapVal   = 0x16,\n+    EsOpaque   = 0x17,\n }\n \n const NUM_TAGS: uint = 0x1000;\n-const NUM_IMPLICIT_TAGS: uint = 0x11;\n+const NUM_IMPLICIT_TAGS: uint = 0x10;\n \n static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n     8, 8, 4, 2, 1, // EsU*\n     8, 8, 4, 2, 1, // ESI*\n     1, // EsBool\n     4, // EsChar\n     8, 4, // EsF*\n-    4, // EsEnumVid\n-    4, // EsVecLen\n-    4, // EsMapLen\n+    1, 4, // EsSub*\n ];\n \n #[derive(Debug)]\n@@ -152,8 +149,8 @@ pub mod reader {\n \n     use serialize;\n \n-    use super::{ ApplicationError, EsVec, EsMap, EsEnum, EsVecLen, EsVecElt,\n-        EsMapLen, EsMapKey, EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64,\n+    use super::{ ApplicationError, EsVec, EsMap, EsEnum, EsSub8, EsSub32,\n+        EsVecElt, EsMapKey, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64,\n         EsI32, EsI16, EsI8, EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n         EsUint, EsOpaque, EbmlEncoderTag, Doc, TaggedDoc,\n         Error, IntTooBig, InvalidTag, Expected, NUM_IMPLICIT_TAGS, TAG_IMPLICIT_LEN };\n@@ -419,6 +416,37 @@ pub mod reader {\n             Ok(r_doc)\n         }\n \n+        fn next_doc2(&mut self,\n+                     exp_tag1: EbmlEncoderTag,\n+                     exp_tag2: EbmlEncoderTag) -> DecodeResult<(bool, Doc<'doc>)> {\n+            assert!((exp_tag1 as uint) != (exp_tag2 as uint));\n+            debug!(\". next_doc2(exp_tag1={:?}, exp_tag2={:?})\", exp_tag1, exp_tag2);\n+            if self.pos >= self.parent.end {\n+                return Err(Expected(format!(\"no more documents in \\\n+                                             current node!\")));\n+            }\n+            let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                try!(doc_at(self.parent.data, self.pos));\n+            debug!(\"self.parent={:?}-{:?} self.pos={:?} r_tag={:?} r_doc={:?}-{:?}\",\n+                   self.parent.start,\n+                   self.parent.end,\n+                   self.pos,\n+                   r_tag,\n+                   r_doc.start,\n+                   r_doc.end);\n+            if r_tag != (exp_tag1 as uint) && r_tag != (exp_tag2 as uint) {\n+                return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but \\\n+                                             found tag {:?}\", exp_tag1, exp_tag2, r_tag)));\n+            }\n+            if r_doc.end > self.parent.end {\n+                return Err(Expected(format!(\"invalid EBML, child extends to \\\n+                                             {:#x}, parent to {:#x}\",\n+                                            r_doc.end, self.parent.end)));\n+            }\n+            self.pos = r_doc.end;\n+            Ok((r_tag == (exp_tag2 as uint), r_doc))\n+        }\n+\n         fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n@@ -433,10 +461,15 @@ pub mod reader {\n             Ok(r)\n         }\n \n-        fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<uint> {\n-            let r = doc_as_u32(try!(self.next_doc(exp_tag)));\n-            debug!(\"_next_uint exp_tag={:?} result={:?}\", exp_tag, r);\n-            Ok(r as uint)\n+        fn _next_sub(&mut self) -> DecodeResult<uint> {\n+            let (big, doc) = try!(self.next_doc2(EsSub8, EsSub32));\n+            let r = if big {\n+                doc_as_u32(doc) as uint\n+            } else {\n+                doc_as_u8(doc) as uint\n+            };\n+            debug!(\"_next_sub result={:?}\", r);\n+            Ok(r)\n         }\n \n         pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R> where\n@@ -538,7 +571,7 @@ pub mod reader {\n             where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum_variant()\");\n-            let idx = try!(self._next_uint(EsEnumVid));\n+            let idx = try!(self._next_sub());\n             debug!(\"  idx={}\", idx);\n \n             f(self, idx)\n@@ -556,7 +589,7 @@ pub mod reader {\n             where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum_struct_variant()\");\n-            let idx = try!(self._next_uint(EsEnumVid));\n+            let idx = try!(self._next_sub());\n             debug!(\"  idx={}\", idx);\n \n             f(self, idx)\n@@ -647,7 +680,7 @@ pub mod reader {\n         {\n             debug!(\"read_seq()\");\n             self.push_doc(EsVec, move |d| {\n-                let len = try!(d._next_uint(EsVecLen));\n+                let len = try!(d._next_sub());\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n             })\n@@ -665,7 +698,7 @@ pub mod reader {\n         {\n             debug!(\"read_map()\");\n             self.push_doc(EsMap, move |d| {\n-                let len = try!(d._next_uint(EsMapLen));\n+                let len = try!(d._next_sub());\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n             })\n@@ -697,10 +730,10 @@ pub mod writer {\n     use std::old_io::{Writer, Seek};\n     use std::old_io;\n \n-    use super::{ EsVec, EsMap, EsEnum, EsVecLen, EsVecElt, EsMapLen, EsMapKey,\n-        EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n+    use super::{ EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n+        EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n         EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal, EsUint,\n-        EsOpaque, EbmlEncoderTag, NUM_IMPLICIT_TAGS, NUM_TAGS };\n+        EsOpaque, NUM_IMPLICIT_TAGS, NUM_TAGS };\n \n     use serialize;\n \n@@ -907,9 +940,18 @@ pub mod writer {\n \n     impl<'a, W: Writer + Seek> Encoder<'a, W> {\n         // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) -> EncodeResult {\n-            assert!(v <= 0xFFFF_FFFF);\n-            self.wr_tagged_raw_u32(t as uint, v as u32)\n+        fn _emit_tagged_sub(&mut self, v: uint) -> EncodeResult {\n+            if let Some(v) = v.to_u8() {\n+                self.wr_tagged_raw_u8(EsSub8 as uint, v)\n+            } else if let Some(v) = v.to_u32() {\n+                self.wr_tagged_raw_u32(EsSub32 as uint, v)\n+            } else {\n+                Err(old_io::IoError {\n+                    kind: old_io::OtherIoError,\n+                    desc: \"length or variant id too big\",\n+                    detail: Some(format!(\"{}\", v))\n+                })\n+            }\n         }\n \n         pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult where\n@@ -995,7 +1037,7 @@ pub mod writer {\n                                 f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n         {\n-            try!(self._emit_tagged_uint(EsEnumVid, v_id));\n+            try!(self._emit_tagged_sub(v_id));\n             f(self)\n         }\n \n@@ -1078,7 +1120,7 @@ pub mod writer {\n         {\n \n             try!(self.start_tag(EsVec as uint));\n-            try!(self._emit_tagged_uint(EsVecLen, len));\n+            try!(self._emit_tagged_sub(len));\n             try!(f(self));\n             self.end_tag()\n         }\n@@ -1097,7 +1139,7 @@ pub mod writer {\n         {\n \n             try!(self.start_tag(EsMap as uint));\n-            try!(self._emit_tagged_uint(EsMapLen, len));\n+            try!(self._emit_tagged_sub(len));\n             try!(f(self));\n             self.end_tag()\n         }"}]}