{"sha": "23eb90ffa77943153d203c3d184c182490d758e7", "node_id": "C_kwDOAAsO6NoAKDIzZWI5MGZmYTc3OTQzMTUzZDIwM2MzZDE4NGMxODI0OTBkNzU4ZTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-17T00:22:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-17T00:22:28Z"}, "message": "Auto merge of #109061 - saethlin:leak-backtraces, r=oli-obk\n\nAdd a backtrace to Allocation, display it in leak reports\n\nThis addresses https://github.com/rust-lang/miri/issues/2813\n\nInformation like this from diagnostics is indispensable for diagnosing problems that are difficult to reproduce such as https://github.com/rust-lang/miri-test-libstd/actions/runs/4395316008/jobs/7697019211#step:4:770 (which has not been reproduced or diagnosed).", "tree": {"sha": "edf67ba13980077dd1bb96b694b6a426253a3314", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edf67ba13980077dd1bb96b694b6a426253a3314"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23eb90ffa77943153d203c3d184c182490d758e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23eb90ffa77943153d203c3d184c182490d758e7", "html_url": "https://github.com/rust-lang/rust/commit/23eb90ffa77943153d203c3d184c182490d758e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23eb90ffa77943153d203c3d184c182490d758e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0f204e4d750b62f9d6c2593405e828757126832", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0f204e4d750b62f9d6c2593405e828757126832", "html_url": "https://github.com/rust-lang/rust/commit/d0f204e4d750b62f9d6c2593405e828757126832"}, {"sha": "fb68292b24e5bd14c04d820fd352722cc060c789", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb68292b24e5bd14c04d820fd352722cc060c789", "html_url": "https://github.com/rust-lang/rust/commit/fb68292b24e5bd14c04d820fd352722cc060c789"}], "stats": {"total": 253, "additions": 191, "deletions": 62}, "files": [{"sha": "b5b5cc4f1963843a06a5fa99a53f155aced87fe4", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -132,11 +132,10 @@ pub struct Frame<'mir, 'tcx, Prov: Provenance = AllocId, Extra = ()> {\n }\n \n /// What we store about a frame in an interpreter backtrace.\n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n pub struct FrameInfo<'tcx> {\n     pub instance: ty::Instance<'tcx>,\n     pub span: Span,\n-    pub lint_root: Option<hir::HirId>,\n }\n \n #[derive(Clone, Copy, Eq, PartialEq, Debug)] // Miri debug-prints these\n@@ -947,10 +946,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // This deliberately does *not* honor `requires_caller_location` since it is used for much\n         // more than just panics.\n         for frame in stack.iter().rev() {\n-            let lint_root = frame.lint_root();\n             let span = frame.current_span();\n-\n-            frames.push(FrameInfo { span, instance: frame.instance, lint_root });\n+            frames.push(FrameInfo { span, instance: frame.instance });\n         }\n         trace!(\"generate stacktrace: {:#?}\", frames);\n         frames"}, {"sha": "b448e3a24c68fb71a66b3b6f1c9c14b7f277c091", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -104,7 +104,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     type FrameExtra;\n \n     /// Extra data stored in every allocation.\n-    type AllocExtra: Debug + Clone + 'static;\n+    type AllocExtra: Debug + Clone + 'tcx;\n \n     /// Type for the bytes of the allocation.\n     type Bytes: AllocBytes + 'static;"}, {"sha": "d5b6a581a79f6ef8f5f6620e498fd8f7b5c4e2ca", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -215,7 +215,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.allocate_raw_ptr(alloc, kind)\n     }\n \n-    /// This can fail only of `alloc` contains provenance.\n+    /// This can fail only if `alloc` contains provenance.\n     pub fn allocate_raw_ptr(\n         &mut self,\n         alloc: Allocation,\n@@ -807,9 +807,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         DumpAllocs { ecx: self, allocs }\n     }\n \n-    /// Print leaked memory. Allocations reachable from `static_roots` or a `Global` allocation\n-    /// are not considered leaked. Leaks whose kind `may_leak()` returns true are not reported.\n-    pub fn leak_report(&self, static_roots: &[AllocId]) -> usize {\n+    /// Find leaked allocations. Allocations reachable from `static_roots` or a `Global` allocation\n+    /// are not considered leaked, as well as leaks whose kind's `may_leak()` returns true.\n+    pub fn find_leaked_allocations(\n+        &self,\n+        static_roots: &[AllocId],\n+    ) -> Vec<(AllocId, MemoryKind<M::MemoryKind>, Allocation<M::Provenance, M::AllocExtra, M::Bytes>)>\n+    {\n         // Collect the set of allocations that are *reachable* from `Global` allocations.\n         let reachable = {\n             let mut reachable = FxHashSet::default();\n@@ -833,14 +837,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n \n         // All allocations that are *not* `reachable` and *not* `may_leak` are considered leaking.\n-        let leaks: Vec<_> = self.memory.alloc_map.filter_map_collect(|&id, &(kind, _)| {\n-            if kind.may_leak() || reachable.contains(&id) { None } else { Some(id) }\n-        });\n-        let n = leaks.len();\n-        if n > 0 {\n-            eprintln!(\"The following memory was leaked: {:?}\", self.dump_allocs(leaks));\n-        }\n-        n\n+        self.memory.alloc_map.filter_map_collect(|id, (kind, alloc)| {\n+            if kind.may_leak() || reachable.contains(id) {\n+                None\n+            } else {\n+                Some((*id, *kind, alloc.clone()))\n+            }\n+        })\n     }\n }\n "}, {"sha": "04a1d939d2e5e837ed318f375552ee829caf8a19", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -301,18 +301,22 @@ environment variable. We first document the most relevant and most commonly used\n * `-Zmiri-disable-isolation` disables host isolation.  As a consequence,\n   the program has access to host resources such as environment variables, file\n   systems, and randomness.\n+* `-Zmiri-disable-leak-backtraces` disables backtraces reports for memory leaks. By default, a\n+  backtrace is captured for every allocation when it is created, just in case it leaks. This incurs\n+  some memory overhead to store data that is almost never used. This flag is implied by\n+  `-Zmiri-ignore-leaks`.\n+* `-Zmiri-env-forward=<var>` forwards the `var` environment variable to the interpreted program. Can\n+  be used multiple times to forward several variables. Execution will still be deterministic if the\n+  value of forwarded variables stays the same. Has no effect if `-Zmiri-disable-isolation` is set.\n+* `-Zmiri-ignore-leaks` disables the memory leak checker, and also allows some\n+  remaining threads to exist when the main thread exits.\n * `-Zmiri-isolation-error=<action>` configures Miri's response to operations\n   requiring host access while isolation is enabled. `abort`, `hide`, `warn`,\n   and `warn-nobacktrace` are the supported actions. The default is to `abort`,\n   which halts the machine. Some (but not all) operations also support continuing\n   execution with a \"permission denied\" error being returned to the program.\n   `warn` prints a full backtrace when that happens; `warn-nobacktrace` is less\n   verbose. `hide` hides the warning entirely.\n-* `-Zmiri-env-forward=<var>` forwards the `var` environment variable to the interpreted program. Can\n-  be used multiple times to forward several variables. Execution will still be deterministic if the\n-  value of forwarded variables stays the same. Has no effect if `-Zmiri-disable-isolation` is set.\n-* `-Zmiri-ignore-leaks` disables the memory leak checker, and also allows some\n-  remaining threads to exist when the main thread exits.\n * `-Zmiri-num-cpus` states the number of available CPUs to be reported by miri. By default, the\n   number of available CPUs is `1`. Note that this flag does not affect how miri handles threads in\n   any way."}, {"sha": "3aa71bb7e3c878ce4ae1523324a0cc5c6b60abe7", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -359,6 +359,8 @@ fn main() {\n                 isolation_enabled = Some(false);\n             }\n             miri_config.isolated_op = miri::IsolatedOp::Allow;\n+        } else if arg == \"-Zmiri-disable-leak-backtraces\" {\n+            miri_config.collect_leak_backtraces = false;\n         } else if arg == \"-Zmiri-disable-weak-memory-emulation\" {\n             miri_config.weak_memory_emulation = false;\n         } else if arg == \"-Zmiri-track-weak-memory-loads\" {\n@@ -385,6 +387,7 @@ fn main() {\n             };\n         } else if arg == \"-Zmiri-ignore-leaks\" {\n             miri_config.ignore_leaks = true;\n+            miri_config.collect_leak_backtraces = false;\n         } else if arg == \"-Zmiri-panic-on-unsupported\" {\n             miri_config.panic_on_unsupported = true;\n         } else if arg == \"-Zmiri-tag-raw-pointers\" {"}, {"sha": "d54adb72887a0ba957ea2bf12a280b4b74e6d7d4", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -352,7 +352,7 @@ pub enum AllocState {\n     TreeBorrows(Box<RefCell<tree_borrows::AllocState>>),\n }\n \n-impl machine::AllocExtra {\n+impl machine::AllocExtra<'_> {\n     #[track_caller]\n     pub fn borrow_tracker_sb(&self) -> &RefCell<stacked_borrows::AllocState> {\n         match self.borrow_tracker {"}, {"sha": "7a726be00da4e0222c14074598b09103bde53743", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -105,7 +105,7 @@ pub enum NonHaltingDiagnostic {\n }\n \n /// Level of Miri specific diagnostics\n-enum DiagLevel {\n+pub enum DiagLevel {\n     Error,\n     Warning,\n     Note,\n@@ -114,7 +114,7 @@ enum DiagLevel {\n /// Attempts to prune a stacktrace to omit the Rust runtime, and returns a bool indicating if any\n /// frames were pruned. If the stacktrace does not have any local frames, we conclude that it must\n /// be pointing to a problem in the Rust runtime itself, and do not prune it at all.\n-fn prune_stacktrace<'tcx>(\n+pub fn prune_stacktrace<'tcx>(\n     mut stacktrace: Vec<FrameInfo<'tcx>>,\n     machine: &MiriMachine<'_, 'tcx>,\n ) -> (Vec<FrameInfo<'tcx>>, bool) {\n@@ -338,12 +338,45 @@ pub fn report_error<'tcx, 'mir>(\n     None\n }\n \n+pub fn report_leaks<'mir, 'tcx>(\n+    ecx: &InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n+    leaks: Vec<(AllocId, MemoryKind<MiriMemoryKind>, Allocation<Provenance, AllocExtra<'tcx>>)>,\n+) {\n+    let mut any_pruned = false;\n+    for (id, kind, mut alloc) in leaks {\n+        let Some(backtrace) = alloc.extra.backtrace.take() else {\n+            continue;\n+        };\n+        let (backtrace, pruned) = prune_stacktrace(backtrace, &ecx.machine);\n+        any_pruned |= pruned;\n+        report_msg(\n+            DiagLevel::Error,\n+            &format!(\n+                \"memory leaked: {id:?} ({}, size: {:?}, align: {:?}), allocated here:\",\n+                kind,\n+                alloc.size().bytes(),\n+                alloc.align.bytes()\n+            ),\n+            vec![],\n+            vec![],\n+            vec![],\n+            &backtrace,\n+            &ecx.machine,\n+        );\n+    }\n+    if any_pruned {\n+        ecx.tcx.sess.diagnostic().note_without_error(\n+            \"some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\",\n+        );\n+    }\n+}\n+\n /// Report an error or note (depending on the `error` argument) with the given stacktrace.\n /// Also emits a full stacktrace of the interpreter stack.\n /// We want to present a multi-line span message for some errors. Diagnostics do not support this\n /// directly, so we pass the lines as a `Vec<String>` and display each line after the first with an\n /// additional `span_label` or `note` call.\n-fn report_msg<'tcx>(\n+pub fn report_msg<'tcx>(\n     diag_level: DiagLevel,\n     title: &str,\n     span_msg: Vec<String>,"}, {"sha": "defd37c37757e72f168e2e54af7b074c2a38a488", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -10,6 +10,7 @@ use std::thread;\n use log::info;\n \n use crate::borrow_tracker::RetagFields;\n+use crate::diagnostics::report_leaks;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n@@ -145,6 +146,8 @@ pub struct MiriConfig {\n     pub num_cpus: u32,\n     /// Requires Miri to emulate pages of a certain size\n     pub page_size: Option<u64>,\n+    /// Whether to collect a backtrace when each allocation is created, just in case it leaks.\n+    pub collect_leak_backtraces: bool,\n }\n \n impl Default for MiriConfig {\n@@ -179,6 +182,7 @@ impl Default for MiriConfig {\n             gc_interval: 10_000,\n             num_cpus: 1,\n             page_size: None,\n+            collect_leak_backtraces: true,\n         }\n     }\n }\n@@ -457,10 +461,17 @@ pub fn eval_entry<'tcx>(\n         }\n         // Check for memory leaks.\n         info!(\"Additonal static roots: {:?}\", ecx.machine.static_roots);\n-        let leaks = ecx.leak_report(&ecx.machine.static_roots);\n-        if leaks != 0 {\n-            tcx.sess.err(\"the evaluated program leaked memory\");\n-            tcx.sess.note_without_error(\"pass `-Zmiri-ignore-leaks` to disable this check\");\n+        let leaks = ecx.find_leaked_allocations(&ecx.machine.static_roots);\n+        if !leaks.is_empty() {\n+            report_leaks(&ecx, leaks);\n+            let leak_message = \"the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\";\n+            if ecx.machine.collect_leak_backtraces {\n+                // If we are collecting leak backtraces, each leak is a distinct error diagnostic.\n+                tcx.sess.note_without_error(leak_message);\n+            } else {\n+                // If we do not have backtraces, we just report an error without any span.\n+                tcx.sess.err(leak_message);\n+            };\n             // Ignore the provided return code - let the reported error\n             // determine the return code.\n             return None;"}, {"sha": "ecb3e13dd54e0708272b6cca9b27b7c4d3a9171e", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -253,20 +253,25 @@ impl ProvenanceExtra {\n \n /// Extra per-allocation data\n #[derive(Debug, Clone)]\n-pub struct AllocExtra {\n+pub struct AllocExtra<'tcx> {\n     /// Global state of the borrow tracker, if enabled.\n     pub borrow_tracker: Option<borrow_tracker::AllocState>,\n-    /// Data race detection via the use of a vector-clock,\n-    ///  this is only added if it is enabled.\n+    /// Data race detection via the use of a vector-clock.\n+    /// This is only added if it is enabled.\n     pub data_race: Option<data_race::AllocState>,\n-    /// Weak memory emulation via the use of store buffers,\n-    ///  this is only added if it is enabled.\n+    /// Weak memory emulation via the use of store buffers.\n+    /// This is only added if it is enabled.\n     pub weak_memory: Option<weak_memory::AllocState>,\n+    /// A backtrace to where this allocation was allocated.\n+    /// As this is recorded for leak reports, it only exists\n+    /// if this allocation is leakable. The backtrace is not\n+    /// pruned yet; that should be done before printing it.\n+    pub backtrace: Option<Vec<FrameInfo<'tcx>>>,\n }\n \n-impl VisitTags for AllocExtra {\n+impl VisitTags for AllocExtra<'_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n-        let AllocExtra { borrow_tracker, data_race, weak_memory } = self;\n+        let AllocExtra { borrow_tracker, data_race, weak_memory, backtrace: _ } = self;\n \n         borrow_tracker.visit_tags(visit);\n         data_race.visit_tags(visit);\n@@ -467,12 +472,17 @@ pub struct MiriMachine<'mir, 'tcx> {\n     pub(crate) gc_interval: u32,\n     /// The number of blocks that passed since the last BorTag GC pass.\n     pub(crate) since_gc: u32,\n+\n     /// The number of CPUs to be reported by miri.\n     pub(crate) num_cpus: u32,\n+\n     /// Determines Miri's page size and associated values\n     pub(crate) page_size: u64,\n     pub(crate) stack_addr: u64,\n     pub(crate) stack_size: u64,\n+\n+    /// Whether to collect a backtrace when each allocation is created, just in case it leaks.\n+    pub(crate) collect_leak_backtraces: bool,\n }\n \n impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n@@ -581,6 +591,7 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n             page_size,\n             stack_addr,\n             stack_size,\n+            collect_leak_backtraces: config.collect_leak_backtraces,\n         }\n     }\n \n@@ -728,6 +739,7 @@ impl VisitTags for MiriMachine<'_, '_> {\n             page_size: _,\n             stack_addr: _,\n             stack_size: _,\n+            collect_leak_backtraces: _,\n         } = self;\n \n         threads.visit_tags(visit);\n@@ -773,7 +785,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     type ExtraFnVal = Dlsym;\n \n     type FrameExtra = FrameExtra<'tcx>;\n-    type AllocExtra = AllocExtra;\n+    type AllocExtra = AllocExtra<'tcx>;\n \n     type Provenance = Provenance;\n     type ProvenanceExtra = ProvenanceExtra;\n@@ -967,9 +979,24 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             )\n         });\n         let buffer_alloc = ecx.machine.weak_memory.then(weak_memory::AllocState::new_allocation);\n+\n+        // If an allocation is leaked, we want to report a backtrace to indicate where it was\n+        // allocated. We don't need to record a backtrace for allocations which are allowed to\n+        // leak.\n+        let backtrace = if kind.may_leak() || !ecx.machine.collect_leak_backtraces {\n+            None\n+        } else {\n+            Some(ecx.generate_stacktrace())\n+        };\n+\n         let alloc: Allocation<Provenance, Self::AllocExtra> = alloc.adjust_from_tcx(\n             &ecx.tcx,\n-            AllocExtra { borrow_tracker, data_race: race_alloc, weak_memory: buffer_alloc },\n+            AllocExtra {\n+                borrow_tracker,\n+                data_race: race_alloc,\n+                weak_memory: buffer_alloc,\n+                backtrace,\n+            },\n             |ptr| ecx.global_base_pointer(ptr),\n         )?;\n         Ok(Cow::Owned(alloc))\n@@ -1049,7 +1076,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     fn before_memory_read(\n         _tcx: TyCtxt<'tcx>,\n         machine: &Self,\n-        alloc_extra: &AllocExtra,\n+        alloc_extra: &AllocExtra<'tcx>,\n         (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n@@ -1069,7 +1096,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     fn before_memory_write(\n         _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n-        alloc_extra: &mut AllocExtra,\n+        alloc_extra: &mut AllocExtra<'tcx>,\n         (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n@@ -1089,7 +1116,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     fn before_memory_deallocation(\n         _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n-        alloc_extra: &mut AllocExtra,\n+        alloc_extra: &mut AllocExtra<'tcx>,\n         (alloc_id, prove_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {"}, {"sha": "cefdcc2b5b83d051882ba0b0210952cedc6ccbd9", "filename": "src/tools/miri/src/tag_gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -125,7 +125,7 @@ impl VisitTags for Operand<Provenance> {\n     }\n }\n \n-impl VisitTags for Allocation<Provenance, AllocExtra> {\n+impl VisitTags for Allocation<Provenance, AllocExtra<'_>> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         for prov in self.provenance().provenances() {\n             prov.visit_tags(visit);"}, {"sha": "cbeb163b56c317c7f4167b2adba5a0b8810d68aa", "filename": "src/tools/miri/tests/fail/memleak.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.rs?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: the evaluated program leaked memory\n+//@error-pattern: memory leaked\n //@normalize-stderr-test: \".*\u2502.*\" -> \"$$stripped$$\"\n \n fn main() {"}, {"sha": "6d9b664c8f48338d081accc6ad75bf36a44b3b5e", "filename": "src/tools/miri/tests/fail/memleak.stderr", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.stderr?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -1,10 +1,23 @@\n-The following memory was leaked: ALLOC (Rust heap, size: 4, align: 4) {\n-$stripped$\n-}\n+error: memory leaked: ALLOC (Rust heap, size: 4, align: 4), allocated here:\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_alloc(layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: inside `std::alloc::alloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::alloc::Global::alloc_impl` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::alloc::Global as std::alloc::Allocator>::allocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `alloc::alloc::exchange_malloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::boxed::Box::<i32>::new` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/memleak.rs:LL:CC\n+   |\n+LL |     std::mem::forget(Box::new(42));\n+   |                      ^^^^^^^^^^^^\n \n-error: the evaluated program leaked memory\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-note: pass `-Zmiri-ignore-leaks` to disable this check\n+note: the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\n \n error: aborting due to previous error\n "}, {"sha": "24d4a02df712ceb5d339d5a2c29a58f9fa368862", "filename": "src/tools/miri/tests/fail/memleak_no_backtrace.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_no_backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_no_backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_no_backtrace.rs?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -0,0 +1,7 @@\n+//@compile-flags: -Zmiri-disable-leak-backtraces\n+//@error-pattern: the evaluated program leaked memory\n+//@normalize-stderr-test: \".*\u2502.*\" -> \"$$stripped$$\"\n+\n+fn main() {\n+    std::mem::forget(Box::new(42));\n+}"}, {"sha": "f44e6ce07977917aaafe306614c3662caa734f16", "filename": "src/tools/miri/tests/fail/memleak_no_backtrace.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_no_backtrace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_no_backtrace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_no_backtrace.stderr?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -0,0 +1,4 @@\n+error: the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\n+\n+error: aborting due to previous error\n+"}, {"sha": "0e1146cf4ad93755e873adc3c8bfd60dff6f121e", "filename": "src/tools/miri/tests/fail/memleak_rc.32bit.stderr", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.32bit.stderr?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -1,10 +1,24 @@\n-The following memory was leaked: ALLOC (Rust heap, size: 16, align: 4) {\n-$stripped$\n-}\n+error: memory leaked: ALLOC (Rust heap, size: 16, align: 4), allocated here:\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_alloc(layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: inside `std::alloc::alloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::alloc::Global::alloc_impl` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::alloc::Global as std::alloc::Allocator>::allocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `alloc::alloc::exchange_malloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::boxed::Box::<std::rc::RcBox<std::cell::RefCell<std::option::Option<Dummy>>>>::new` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+   = note: inside `std::rc::Rc::<std::cell::RefCell<std::option::Option<Dummy>>>::new` at RUSTLIB/alloc/src/rc.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/memleak_rc.rs:LL:CC\n+   |\n+LL |     let x = Dummy(Rc::new(RefCell::new(None)));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the evaluated program leaked memory\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-note: pass `-Zmiri-ignore-leaks` to disable this check\n+note: the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\n \n error: aborting due to previous error\n "}, {"sha": "4979588f370ff5f53c595478ce75d9ff4b66f886", "filename": "src/tools/miri/tests/fail/memleak_rc.64bit.stderr", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.64bit.stderr?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -1,11 +1,24 @@\n-The following memory was leaked: ALLOC (Rust heap, size: 32, align: 8) {\n-$stripped$\n-$stripped$\n-}\n+error: memory leaked: ALLOC (Rust heap, size: 32, align: 8), allocated here:\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_alloc(layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: inside `std::alloc::alloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::alloc::Global::alloc_impl` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::alloc::Global as std::alloc::Allocator>::allocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `alloc::alloc::exchange_malloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::boxed::Box::<std::rc::RcBox<std::cell::RefCell<std::option::Option<Dummy>>>>::new` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+   = note: inside `std::rc::Rc::<std::cell::RefCell<std::option::Option<Dummy>>>::new` at RUSTLIB/alloc/src/rc.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/memleak_rc.rs:LL:CC\n+   |\n+LL |     let x = Dummy(Rc::new(RefCell::new(None)));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the evaluated program leaked memory\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-note: pass `-Zmiri-ignore-leaks` to disable this check\n+note: the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\n \n error: aborting due to previous error\n "}, {"sha": "cf4671912ada8057c2fbc50f7e7bc3cef265e498", "filename": "src/tools/miri/tests/fail/memleak_rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23eb90ffa77943153d203c3d184c182490d758e7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.rs?ref=23eb90ffa77943153d203c3d184c182490d758e7", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: the evaluated program leaked memory\n+//@error-pattern: memory leaked\n //@stderr-per-bitwidth\n //@normalize-stderr-test: \".*\u2502.*\" -> \"$$stripped$$\"\n "}]}