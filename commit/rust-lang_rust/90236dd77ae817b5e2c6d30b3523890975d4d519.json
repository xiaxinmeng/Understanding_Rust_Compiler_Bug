{"sha": "90236dd77ae817b5e2c6d30b3523890975d4d519", "node_id": "C_kwDOAAsO6NoAKDkwMjM2ZGQ3N2FlODE3YjVlMmM2ZDMwYjM1MjM4OTA5NzVkNGQ1MTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-22T08:59:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-22T08:59:04Z"}, "message": "Auto merge of #11830 - nemethf:on-type-formatting, r=nemethf\n\nOn typing handler for angle brackets(<) with snippets\n\nI implemented my idea in #11398 in \"cargo cult programming\"-style without actually know what I'm doing, so feedback is welcome.  The PR is split into two commits to ease the review.  I used `@unexge's` original prototype, which forms the basis of the PR.", "tree": {"sha": "3f416c863307a1a13f719b0ba9760e4e4cc2ccdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f416c863307a1a13f719b0ba9760e4e4cc2ccdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90236dd77ae817b5e2c6d30b3523890975d4d519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90236dd77ae817b5e2c6d30b3523890975d4d519", "html_url": "https://github.com/rust-lang/rust/commit/90236dd77ae817b5e2c6d30b3523890975d4d519", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90236dd77ae817b5e2c6d30b3523890975d4d519/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3de03d4c61d2405b66337b96ea97aa21f7d04e4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3de03d4c61d2405b66337b96ea97aa21f7d04e4b", "html_url": "https://github.com/rust-lang/rust/commit/3de03d4c61d2405b66337b96ea97aa21f7d04e4b"}, {"sha": "f7c963c0f238a6ebb07bbb290d31f772b448c7aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c963c0f238a6ebb07bbb290d31f772b448c7aa", "html_url": "https://github.com/rust-lang/rust/commit/f7c963c0f238a6ebb07bbb290d31f772b448c7aa"}], "stats": {"total": 375, "additions": 354, "deletions": 21}, "files": [{"sha": "6af62d0ab23339b9d77f7c7d653e7249da92c8f9", "filename": "crates/ide/src/typing.rs", "status": "modified", "additions": 319, "deletions": 11, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/90236dd77ae817b5e2c6d30b3523890975d4d519/crates%2Fide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90236dd77ae817b5e2c6d30b3523890975d4d519/crates%2Fide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ftyping.rs?ref=90236dd77ae817b5e2c6d30b3523890975d4d519", "patch": "@@ -20,9 +20,9 @@ use ide_db::{\n     RootDatabase,\n };\n use syntax::{\n-    algo::find_node_at_offset,\n+    algo::{ancestors_at_offset, find_node_at_offset},\n     ast::{self, edit::IndentLevel, AstToken},\n-    AstNode, Parse, SourceFile, SyntaxKind, TextRange, TextSize,\n+    AstNode, Parse, SourceFile, SyntaxKind, TextRange, TextSize, T,\n };\n \n use text_edit::{Indel, TextEdit};\n@@ -32,7 +32,12 @@ use crate::SourceChange;\n pub(crate) use on_enter::on_enter;\n \n // Don't forget to add new trigger characters to `server_capabilities` in `caps.rs`.\n-pub(crate) const TRIGGER_CHARS: &str = \".=>{\";\n+pub(crate) const TRIGGER_CHARS: &str = \".=<>{\";\n+\n+struct ExtendedTextEdit {\n+    edit: TextEdit,\n+    is_snippet: bool,\n+}\n \n // Feature: On Typing Assists\n //\n@@ -68,23 +73,30 @@ pub(crate) fn on_char_typed(\n         return None;\n     }\n     let edit = on_char_typed_inner(file, position.offset, char_typed)?;\n-    Some(SourceChange::from_text_edit(position.file_id, edit))\n+    let mut sc = SourceChange::from_text_edit(position.file_id, edit.edit);\n+    sc.is_snippet = edit.is_snippet;\n+    Some(sc)\n }\n \n fn on_char_typed_inner(\n     file: &Parse<SourceFile>,\n     offset: TextSize,\n     char_typed: char,\n-) -> Option<TextEdit> {\n+) -> Option<ExtendedTextEdit> {\n     if !stdx::always!(TRIGGER_CHARS.contains(char_typed)) {\n         return None;\n     }\n-    match char_typed {\n-        '.' => on_dot_typed(&file.tree(), offset),\n-        '=' => on_eq_typed(&file.tree(), offset),\n-        '>' => on_arrow_typed(&file.tree(), offset),\n-        '{' => on_opening_brace_typed(file, offset),\n+    return match char_typed {\n+        '.' => conv(on_dot_typed(&file.tree(), offset)),\n+        '=' => conv(on_eq_typed(&file.tree(), offset)),\n+        '<' => on_left_angle_typed(&file.tree(), offset),\n+        '>' => conv(on_right_angle_typed(&file.tree(), offset)),\n+        '{' => conv(on_opening_brace_typed(file, offset)),\n         _ => unreachable!(),\n+    };\n+\n+    fn conv(text_edit: Option<TextEdit>) -> Option<ExtendedTextEdit> {\n+        Some(ExtendedTextEdit { edit: text_edit?, is_snippet: false })\n     }\n }\n \n@@ -302,8 +314,49 @@ fn on_dot_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n     Some(TextEdit::replace(TextRange::new(offset - current_indent_len, offset), target_indent))\n }\n \n+/// Add closing `>` for generic arguments/parameters.\n+fn on_left_angle_typed(file: &SourceFile, offset: TextSize) -> Option<ExtendedTextEdit> {\n+    let file_text = file.syntax().text();\n+    if !stdx::always!(file_text.char_at(offset) == Some('<')) {\n+        return None;\n+    }\n+\n+    // Find the next non-whitespace char in the line.\n+    let mut next_offset = offset + TextSize::of('<');\n+    while file_text.char_at(next_offset) == Some(' ') {\n+        next_offset += TextSize::of(' ')\n+    }\n+    if file_text.char_at(next_offset) == Some('>') {\n+        return None;\n+    }\n+\n+    let range = TextRange::at(offset, TextSize::of('<'));\n+    if let Some(t) = file.syntax().token_at_offset(offset).left_biased() {\n+        if T![impl] == t.kind() {\n+            return Some(ExtendedTextEdit {\n+                edit: TextEdit::replace(range, \"<$0>\".to_string()),\n+                is_snippet: true,\n+            });\n+        }\n+    }\n+\n+    if ancestors_at_offset(file.syntax(), offset)\n+        .find(|n| {\n+            ast::GenericParamList::can_cast(n.kind()) || ast::GenericArgList::can_cast(n.kind())\n+        })\n+        .is_some()\n+    {\n+        return Some(ExtendedTextEdit {\n+            edit: TextEdit::replace(range, \"<$0>\".to_string()),\n+            is_snippet: true,\n+        });\n+    }\n+\n+    None\n+}\n+\n /// Adds a space after an arrow when `fn foo() { ... }` is turned into `fn foo() -> { ... }`\n-fn on_arrow_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n+fn on_right_angle_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n     let file_text = file.syntax().text();\n     if !stdx::always!(file_text.char_at(offset) == Some('>')) {\n         return None;\n@@ -325,6 +378,12 @@ mod tests {\n \n     use super::*;\n \n+    impl ExtendedTextEdit {\n+        fn apply(&self, text: &mut String) {\n+            self.edit.apply(text);\n+        }\n+    }\n+\n     fn do_type_char(char_typed: char, before: &str) -> Option<String> {\n         let (offset, mut before) = extract_offset(before);\n         let edit = TextEdit::insert(offset, char_typed.to_string());\n@@ -869,6 +928,255 @@ use some::pa$0th::to::Item;\n         );\n     }\n \n+    #[test]\n+    fn adds_closing_angle_bracket_for_generic_args() {\n+        type_char(\n+            '<',\n+            r#\"\n+fn foo() {\n+    bar::$0\n+}\n+            \"#,\n+            r#\"\n+fn foo() {\n+    bar::<$0>\n+}\n+            \"#,\n+        );\n+\n+        type_char(\n+            '<',\n+            r#\"\n+fn foo(bar: &[u64]) {\n+    bar.iter().collect::$0();\n+}\n+            \"#,\n+            r#\"\n+fn foo(bar: &[u64]) {\n+    bar.iter().collect::<$0>();\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn adds_closing_angle_bracket_for_generic_params() {\n+        type_char(\n+            '<',\n+            r#\"\n+fn foo$0() {}\n+            \"#,\n+            r#\"\n+fn foo<$0>() {}\n+            \"#,\n+        );\n+        type_char(\n+            '<',\n+            r#\"\n+fn foo$0\n+            \"#,\n+            r#\"\n+fn foo<$0>\n+            \"#,\n+        );\n+        type_char(\n+            '<',\n+            r#\"\n+struct Foo$0 {}\n+            \"#,\n+            r#\"\n+struct Foo<$0> {}\n+            \"#,\n+        );\n+        type_char(\n+            '<',\n+            r#\"\n+struct Foo$0();\n+            \"#,\n+            r#\"\n+struct Foo<$0>();\n+            \"#,\n+        );\n+        type_char(\n+            '<',\n+            r#\"\n+struct Foo$0\n+            \"#,\n+            r#\"\n+struct Foo<$0>\n+            \"#,\n+        );\n+        type_char(\n+            '<',\n+            r#\"\n+enum Foo$0\n+            \"#,\n+            r#\"\n+enum Foo<$0>\n+            \"#,\n+        );\n+        type_char(\n+            '<',\n+            r#\"\n+trait Foo$0\n+            \"#,\n+            r#\"\n+trait Foo<$0>\n+            \"#,\n+        );\n+        type_char(\n+            '<',\n+            r#\"\n+type Foo$0 = Bar;\n+            \"#,\n+            r#\"\n+type Foo<$0> = Bar;\n+            \"#,\n+        );\n+        type_char(\n+            '<',\n+            r#\"\n+impl$0 Foo {}\n+            \"#,\n+            r#\"\n+impl<$0> Foo {}\n+            \"#,\n+        );\n+        type_char(\n+            '<',\n+            r#\"\n+impl<T> Foo$0 {}\n+            \"#,\n+            r#\"\n+impl<T> Foo<$0> {}\n+            \"#,\n+        );\n+        type_char(\n+            '<',\n+            r#\"\n+impl Foo$0 {}\n+            \"#,\n+            r#\"\n+impl Foo<$0> {}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn dont_add_closing_angle_bracket_for_comparison() {\n+        type_char_noop(\n+            '<',\n+            r#\"\n+fn main() {\n+    42$0\n+}\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+fn main() {\n+    42 $0\n+}\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+fn main() {\n+    let foo = 42;\n+    foo $0\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn dont_add_closing_angle_bracket_if_it_is_already_there() {\n+        type_char_noop(\n+            '<',\n+            r#\"\n+fn foo() {\n+    bar::$0>\n+}\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+fn foo(bar: &[u64]) {\n+    bar.iter().collect::$0   >();\n+}\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+fn foo$0>() {}\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+fn foo$0>\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+struct Foo$0> {}\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+struct Foo$0>();\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+struct Foo$0>\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+enum Foo$0>\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+trait Foo$0>\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+type Foo$0> = Bar;\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+impl$0> Foo {}\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+impl<T> Foo$0> {}\n+            \"#,\n+        );\n+        type_char_noop(\n+            '<',\n+            r#\"\n+impl Foo$0> {}\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn regression_629() {\n         type_char_noop("}, {"sha": "58b1f29df544ca321b1fa1ecaa99415a0ce934d1", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/90236dd77ae817b5e2c6d30b3523890975d4d519/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90236dd77ae817b5e2c6d30b3523890975d4d519/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=90236dd77ae817b5e2c6d30b3523890975d4d519", "patch": "@@ -56,7 +56,7 @@ pub fn server_capabilities(config: &Config) -> ServerCapabilities {\n         },\n         document_on_type_formatting_provider: Some(DocumentOnTypeFormattingOptions {\n             first_trigger_character: \"=\".to_string(),\n-            more_trigger_character: Some(vec![\".\".to_string(), \">\".to_string(), \"{\".to_string()]),\n+            more_trigger_character: Some(more_trigger_character(&config)),\n         }),\n         selection_range_provider: Some(SelectionRangeProviderCapability::Simple(true)),\n         folding_range_provider: Some(FoldingRangeProviderCapability::Simple(true)),\n@@ -189,3 +189,11 @@ fn code_action_capabilities(client_caps: &ClientCapabilities) -> CodeActionProvi\n             })\n         })\n }\n+\n+fn more_trigger_character(config: &Config) -> Vec<String> {\n+    let mut res = vec![\".\".to_string(), \">\".to_string(), \"{\".to_string()];\n+    if config.snippet_cap() {\n+        res.push(\"<\".to_string());\n+    }\n+    res\n+}"}, {"sha": "c53f7e8c5921b64c586ac6965c17ea040e6dd483", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90236dd77ae817b5e2c6d30b3523890975d4d519/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90236dd77ae817b5e2c6d30b3523890975d4d519/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=90236dd77ae817b5e2c6d30b3523890975d4d519", "patch": "@@ -1070,6 +1070,10 @@ impl Config {\n         }\n     }\n \n+    pub fn snippet_cap(&self) -> bool {\n+        self.experimental(\"snippetTextEdit\")\n+    }\n+\n     pub fn assist(&self) -> AssistConfig {\n         AssistConfig {\n             snippet_cap: SnippetCap::new(self.experimental(\"snippetTextEdit\")),"}, {"sha": "a16f0d904ce960d3d07873d9c1a13a312fcec69b", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90236dd77ae817b5e2c6d30b3523890975d4d519/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90236dd77ae817b5e2c6d30b3523890975d4d519/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=90236dd77ae817b5e2c6d30b3523890975d4d519", "patch": "@@ -276,7 +276,7 @@ pub(crate) fn handle_on_enter(\n pub(crate) fn handle_on_type_formatting(\n     snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentOnTypeFormattingParams,\n-) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n+) -> Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {\n     let _p = profile::span(\"handle_on_type_formatting\");\n     let mut position = from_proto::file_position(&snap, params.text_document_position)?;\n     let line_index = snap.file_line_index(position.file_id)?;\n@@ -306,9 +306,9 @@ pub(crate) fn handle_on_type_formatting(\n     };\n \n     // This should be a single-file edit\n-    let (_, edit) = edit.source_file_edits.into_iter().next().unwrap();\n+    let (_, text_edit) = edit.source_file_edits.into_iter().next().unwrap();\n \n-    let change = to_proto::text_edit_vec(&line_index, edit);\n+    let change = to_proto::snippet_text_edit_vec(&line_index, edit.is_snippet, text_edit);\n     Ok(Some(change))\n }\n "}, {"sha": "5f0e108624b2ef4991cbd065c4611d49b8c2613e", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/90236dd77ae817b5e2c6d30b3523890975d4d519/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90236dd77ae817b5e2c6d30b3523890975d4d519/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=90236dd77ae817b5e2c6d30b3523890975d4d519", "patch": "@@ -4,8 +4,8 @@ use std::{collections::HashMap, path::PathBuf};\n \n use lsp_types::request::Request;\n use lsp_types::{\n-    notification::Notification, CodeActionKind, PartialResultParams, Position, Range,\n-    TextDocumentIdentifier, WorkDoneProgressParams,\n+    notification::Notification, CodeActionKind, DocumentOnTypeFormattingParams,\n+    PartialResultParams, Position, Range, TextDocumentIdentifier, WorkDoneProgressParams,\n };\n use serde::{Deserialize, Serialize};\n \n@@ -512,6 +512,19 @@ pub enum WorkspaceSymbolSearchKind {\n     AllSymbols,\n }\n \n+/// The document on type formatting request is sent from the client to\n+/// the server to format parts of the document during typing.  This is\n+/// almost same as lsp_types::request::OnTypeFormatting, but the\n+/// result has SnippetTextEdit in it instead of TextEdit.\n+#[derive(Debug)]\n+pub enum OnTypeFormatting {}\n+\n+impl Request for OnTypeFormatting {\n+    type Params = DocumentOnTypeFormattingParams;\n+    type Result = Option<Vec<SnippetTextEdit>>;\n+    const METHOD: &'static str = \"textDocument/onTypeFormatting\";\n+}\n+\n #[derive(Debug, Serialize, Deserialize)]\n pub struct CompletionResolveData {\n     pub position: lsp_types::TextDocumentPositionParams,"}, {"sha": "3c879687433d3574ec3a323277e0450a019d2350", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90236dd77ae817b5e2c6d30b3523890975d4d519/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90236dd77ae817b5e2c6d30b3523890975d4d519/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=90236dd77ae817b5e2c6d30b3523890975d4d519", "patch": "@@ -605,7 +605,7 @@ impl GlobalState {\n             .on::<lsp_ext::OpenCargoToml>(handlers::handle_open_cargo_toml)\n             .on::<lsp_ext::MoveItem>(handlers::handle_move_item)\n             .on::<lsp_ext::WorkspaceSymbol>(handlers::handle_workspace_symbol)\n-            .on::<lsp_types::request::OnTypeFormatting>(handlers::handle_on_type_formatting)\n+            .on::<lsp_ext::OnTypeFormatting>(handlers::handle_on_type_formatting)\n             .on::<lsp_types::request::DocumentSymbolRequest>(handlers::handle_document_symbol)\n             .on::<lsp_types::request::GotoDefinition>(handlers::handle_goto_definition)\n             .on::<lsp_types::request::GotoDeclaration>(handlers::handle_goto_declaration)"}, {"sha": "983d8e1ac095dfb2ca0f4ea54cd5ed20944d7b74", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90236dd77ae817b5e2c6d30b3523890975d4d519/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/90236dd77ae817b5e2c6d30b3523890975d4d519/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=90236dd77ae817b5e2c6d30b3523890975d4d519", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: 44e8238e4fbd4128\n+lsp_ext.rs hash: 2a188defec26cc7c\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this issue:\n@@ -47,7 +47,7 @@ If a language client does not know about `rust-analyzer`'s configuration options\n \n **Experimental Client Capability:** `{ \"snippetTextEdit\": boolean }`\n \n-If this capability is set, `WorkspaceEdit`s returned from `codeAction` requests might contain `SnippetTextEdit`s instead of usual `TextEdit`s:\n+If this capability is set, `WorkspaceEdit`s returned from `codeAction` requests and `TextEdit`s returned from `textDocument/onTypeFormatting` requests might contain `SnippetTextEdit`s instead of usual `TextEdit`s:\n \n ```typescript\n interface SnippetTextEdit extends TextEdit {\n@@ -63,7 +63,7 @@ export interface TextDocumentEdit {\n }\n ```\n \n-When applying such code action, the editor should insert snippet, with tab stops and placeholder.\n+When applying such code action or text edit, the editor should insert snippet, with tab stops and placeholder.\n At the moment, rust-analyzer guarantees that only a single edit will have `InsertTextFormat.Snippet`.\n \n ### Example"}]}