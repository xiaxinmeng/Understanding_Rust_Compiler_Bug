{"sha": "db013f9f45a3083ccc9dd79299f110ec62e29704", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMDEzZjlmNDVhMzA4M2NjYzlkZDc5Mjk5ZjExMGVjNjJlMjk3MDQ=", "commit": {"author": {"name": "Daniel Grunwald", "email": "daniel@danielgrunwald.de", "date": "2015-01-18T20:43:03Z"}, "committer": {"name": "Daniel Grunwald", "email": "daniel@danielgrunwald.de", "date": "2015-01-22T18:55:15Z"}, "message": "Fix some grammar inconsistencies for the '..' range notation.\n\nGrammar changes:\n* allow 'for _ in 1..i {}' (fixes #20241)\n* allow 'for _ in 1.. {}' as infinite loop\n* prevent use of range notation in contexts where only operators of high\n  precedence are expected (fixes #20811)\n\nParser code cleanup:\n* remove RESTRICTION_NO_DOTS\n* make AS_PREC const and follow naming convention\n* make min_prec inclusive", "tree": {"sha": "7a716ac5c0f4082611d34561f5597f8b7c3e92f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a716ac5c0f4082611d34561f5597f8b7c3e92f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db013f9f45a3083ccc9dd79299f110ec62e29704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db013f9f45a3083ccc9dd79299f110ec62e29704", "html_url": "https://github.com/rust-lang/rust/commit/db013f9f45a3083ccc9dd79299f110ec62e29704", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db013f9f45a3083ccc9dd79299f110ec62e29704/comments", "author": {"login": "dgrunwald", "id": 243140, "node_id": "MDQ6VXNlcjI0MzE0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/243140?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dgrunwald", "html_url": "https://github.com/dgrunwald", "followers_url": "https://api.github.com/users/dgrunwald/followers", "following_url": "https://api.github.com/users/dgrunwald/following{/other_user}", "gists_url": "https://api.github.com/users/dgrunwald/gists{/gist_id}", "starred_url": "https://api.github.com/users/dgrunwald/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dgrunwald/subscriptions", "organizations_url": "https://api.github.com/users/dgrunwald/orgs", "repos_url": "https://api.github.com/users/dgrunwald/repos", "events_url": "https://api.github.com/users/dgrunwald/events{/privacy}", "received_events_url": "https://api.github.com/users/dgrunwald/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dgrunwald", "id": 243140, "node_id": "MDQ6VXNlcjI0MzE0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/243140?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dgrunwald", "html_url": "https://github.com/dgrunwald", "followers_url": "https://api.github.com/users/dgrunwald/followers", "following_url": "https://api.github.com/users/dgrunwald/following{/other_user}", "gists_url": "https://api.github.com/users/dgrunwald/gists{/gist_id}", "starred_url": "https://api.github.com/users/dgrunwald/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dgrunwald/subscriptions", "organizations_url": "https://api.github.com/users/dgrunwald/orgs", "repos_url": "https://api.github.com/users/dgrunwald/repos", "events_url": "https://api.github.com/users/dgrunwald/events{/privacy}", "received_events_url": "https://api.github.com/users/dgrunwald/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7930d93d9b57beaeabfeb43cf78fc8161ecd46c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7930d93d9b57beaeabfeb43cf78fc8161ecd46c", "html_url": "https://github.com/rust-lang/rust/commit/b7930d93d9b57beaeabfeb43cf78fc8161ecd46c"}], "stats": {"total": 103, "additions": 80, "deletions": 23}, "files": [{"sha": "768293cba79886d80877b97127848d2e228d30e1", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db013f9f45a3083ccc9dd79299f110ec62e29704/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/db013f9f45a3083ccc9dd79299f110ec62e29704/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=db013f9f45a3083ccc9dd79299f110ec62e29704", "patch": "@@ -3135,18 +3135,17 @@ The precedence of Rust binary operators is ordered as follows, going from\n strong to weak:\n \n ```{.text .precedence}\n-* / %\n as\n+* / %\n + -\n << >>\n &\n ^\n |\n-< > <= >=\n-== !=\n+== != < > <= >=\n &&\n ||\n-=\n+= ..\n ```\n \n Operators at the same precedence level are evaluated left-to-right. [Unary"}, {"sha": "cf0aac5bf4ab5e5d144940301fdf86a811b1a4eb", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db013f9f45a3083ccc9dd79299f110ec62e29704/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db013f9f45a3083ccc9dd79299f110ec62e29704/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=db013f9f45a3083ccc9dd79299f110ec62e29704", "patch": "@@ -336,8 +336,7 @@ pub fn operator_prec(op: ast::BinOp) -> usize {\n \n /// Precedence of the `as` operator, which is a binary operator\n /// not appearing in the prior table.\n-#[allow(non_upper_case_globals)]\n-pub static as_prec: usize = 12us;\n+pub const AS_PREC: usize = 12us;\n \n pub fn empty_generics() -> Generics {\n     Generics {"}, {"sha": "e59dbe52b769f2610ee402f20ad05333686cbc71", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/db013f9f45a3083ccc9dd79299f110ec62e29704/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db013f9f45a3083ccc9dd79299f110ec62e29704/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=db013f9f45a3083ccc9dd79299f110ec62e29704", "patch": "@@ -62,7 +62,7 @@ use ast::{UnnamedField, UnsafeBlock};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use ast;\n-use ast_util::{self, as_prec, ident_to_path, operator_prec};\n+use ast_util::{self, AS_PREC, ident_to_path, operator_prec};\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp};\n use diagnostic;\n use ext::tt::macro_parser;\n@@ -93,7 +93,6 @@ bitflags! {\n         const RESTRICTION_STMT_EXPR         = 0b0001,\n         const RESTRICTION_NO_BAR_OP         = 0b0010,\n         const RESTRICTION_NO_STRUCT_LITERAL = 0b0100,\n-        const RESTRICTION_NO_DOTS           = 0b1000,\n     }\n }\n \n@@ -2775,13 +2774,6 @@ impl<'a> Parser<'a> {\n             hi = e.span.hi;\n             ex = ExprAddrOf(m, e);\n           }\n-          token::DotDot if !self.restrictions.contains(RESTRICTION_NO_DOTS) => {\n-            // A range, closed above: `..expr`.\n-            self.bump();\n-            let e = self.parse_expr();\n-            hi = e.span.hi;\n-            ex = self.mk_range(None, Some(e));\n-          }\n           token::Ident(_, _) => {\n             if !self.token.is_keyword(keywords::Box) {\n                 return self.parse_dot_or_call_expr();\n@@ -2855,10 +2847,10 @@ impl<'a> Parser<'a> {\n                     self.check_no_chained_comparison(&*lhs, cur_op)\n                 }\n                 let cur_prec = operator_prec(cur_op);\n-                if cur_prec > min_prec {\n+                if cur_prec >= min_prec {\n                     self.bump();\n                     let expr = self.parse_prefix_expr();\n-                    let rhs = self.parse_more_binops(expr, cur_prec);\n+                    let rhs = self.parse_more_binops(expr, cur_prec + 1);\n                     let lhs_span = lhs.span;\n                     let rhs_span = rhs.span;\n                     let binary = self.mk_binary(cur_op, lhs, rhs);\n@@ -2869,7 +2861,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             None => {\n-                if as_prec > min_prec && self.eat_keyword(keywords::As) {\n+                if AS_PREC >= min_prec && self.eat_keyword(keywords::As) {\n                     let rhs = self.parse_ty();\n                     let _as = self.mk_expr(lhs.span.lo,\n                                            rhs.span.hi,\n@@ -2905,8 +2897,24 @@ impl<'a> Parser<'a> {\n     /// actually, this seems to be the main entry point for\n     /// parsing an arbitrary expression.\n     pub fn parse_assign_expr(&mut self) -> P<Expr> {\n-        let lhs = self.parse_binops();\n-        self.parse_assign_expr_with(lhs)\n+        match self.token {\n+          token::DotDot => {\n+            // prefix-form of range notation '..expr'\n+            // This has the same precedence as assignment expressions\n+            // (much lower than other prefix expressions) to be consistent\n+            // with the postfix-form 'expr..'\n+            let lo = self.span.lo;\n+            self.bump();\n+            let rhs = self.parse_binops();\n+            let hi = rhs.span.hi;\n+            let ex = self.mk_range(None, Some(rhs));\n+            self.mk_expr(lo, hi, ex)\n+          }\n+          _ => {\n+            let lhs = self.parse_binops();\n+            self.parse_assign_expr_with(lhs)\n+          }\n+        }\n     }\n \n     pub fn parse_assign_expr_with(&mut self, lhs: P<Expr>) -> P<Expr> {\n@@ -2938,11 +2946,11 @@ impl<'a> Parser<'a> {\n               self.mk_expr(span.lo, rhs_span.hi, assign_op)\n           }\n           // A range expression, either `expr..expr` or `expr..`.\n-          token::DotDot if !self.restrictions.contains(RESTRICTION_NO_DOTS) => {\n+          token::DotDot => {\n             self.bump();\n \n-            let opt_end = if self.token.can_begin_expr() {\n-                let end = self.parse_expr_res(RESTRICTION_NO_DOTS);\n+            let opt_end = if self.is_at_start_of_range_notation_rhs() {\n+                let end = self.parse_binops();\n                 Some(end)\n             } else {\n                 None\n@@ -2960,6 +2968,18 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn is_at_start_of_range_notation_rhs(&self) -> bool {\n+        if self.token.can_begin_expr() {\n+            // parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n+            if self.token == token::OpenDelim(token::Brace) {\n+                return !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL);\n+            }\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// Parse an 'if' or 'if let' expression ('if' token already eaten)\n     pub fn parse_if_expr(&mut self) -> P<Expr> {\n         if self.token.is_keyword(keywords::Let) {"}, {"sha": "fe79165236f8bbfa5b9332cdabd928ba2e1221b9", "filename": "src/test/compile-fail/range-3.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/db013f9f45a3083ccc9dd79299f110ec62e29704/src%2Ftest%2Fcompile-fail%2Frange-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db013f9f45a3083ccc9dd79299f110ec62e29704/src%2Ftest%2Fcompile-fail%2Frange-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-3.rs?ref=db013f9f45a3083ccc9dd79299f110ec62e29704", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test range syntax - syntax errors.\n+\n+pub fn main() {\n+    let r = 1..2..3;\n+    //~^ ERROR expected one of `.`, `;`, or an operator, found `..`\n+}\n\\ No newline at end of file"}, {"sha": "bbd6ae289cce9452592c158a6e214df246bb9f6c", "filename": "src/test/compile-fail/range-4.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/db013f9f45a3083ccc9dd79299f110ec62e29704/src%2Ftest%2Fcompile-fail%2Frange-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db013f9f45a3083ccc9dd79299f110ec62e29704/src%2Ftest%2Fcompile-fail%2Frange-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-4.rs?ref=db013f9f45a3083ccc9dd79299f110ec62e29704", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test range syntax - syntax errors.\n+\n+pub fn main() {\n+    let r = ..1..2;\n+    //~^ ERROR expected one of `.`, `;`, or an operator, found `..`\n+}\n\\ No newline at end of file"}, {"sha": "c947220f1f858886c19e93a6706db88dc1582c69", "filename": "src/test/run-pass/ranges-precedence.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db013f9f45a3083ccc9dd79299f110ec62e29704/src%2Ftest%2Frun-pass%2Franges-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db013f9f45a3083ccc9dd79299f110ec62e29704/src%2Ftest%2Frun-pass%2Franges-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Franges-precedence.rs?ref=db013f9f45a3083ccc9dd79299f110ec62e29704", "patch": "@@ -48,5 +48,12 @@ fn main() {\n     assert!(x == &a[3..]);\n \n     for _i in 2+4..10-3 {}\n+\n+    let i = 42;\n+    for _ in 1..i {}\n+    for _ in 1.. { break; }\n+\n+    let x = [1]..[2];\n+    assert!(x == (([1])..([2])));\n }\n "}]}