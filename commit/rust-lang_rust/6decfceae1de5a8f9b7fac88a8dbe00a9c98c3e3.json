{"sha": "6decfceae1de5a8f9b7fac88a8dbe00a9c98c3e3", "node_id": "C_kwDOAAsO6NoAKDZkZWNmY2VhZTFkZTVhOGY5YjdmYWM4OGE4ZGJlMDBhOWM5OGMzZTM", "commit": {"author": {"name": "Anatol Ulrich", "email": "anatol.ulrich@ferrous-systems.com", "date": "2021-10-27T02:31:14Z"}, "committer": {"name": "Anatol Ulrich", "email": "anatol.ulrich@ferrous-systems.com", "date": "2021-10-27T02:31:14Z"}, "message": "WIP: fix: make `rename` multi-token mapping aware", "tree": {"sha": "4776010b0d2dcc907c506f2e872e7a010ab0b35c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4776010b0d2dcc907c506f2e872e7a010ab0b35c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6decfceae1de5a8f9b7fac88a8dbe00a9c98c3e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6decfceae1de5a8f9b7fac88a8dbe00a9c98c3e3", "html_url": "https://github.com/rust-lang/rust/commit/6decfceae1de5a8f9b7fac88a8dbe00a9c98c3e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6decfceae1de5a8f9b7fac88a8dbe00a9c98c3e3/comments", "author": null, "committer": null, "parents": [{"sha": "a3830dfd3b074c101e9bfb99271871eca1d44f75", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3830dfd3b074c101e9bfb99271871eca1d44f75", "html_url": "https://github.com/rust-lang/rust/commit/a3830dfd3b074c101e9bfb99271871eca1d44f75"}], "stats": {"total": 174, "additions": 108, "deletions": 66}, "files": [{"sha": "8aa3d01818da64547d17dc71d048aefc1ec96cda", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 95, "deletions": 66, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/6decfceae1de5a8f9b7fac88a8dbe00a9c98c3e3/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6decfceae1de5a8f9b7fac88a8dbe00a9c98c3e3/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=6decfceae1de5a8f9b7fac88a8dbe00a9c98c3e3", "patch": "@@ -3,15 +3,20 @@\n //! This is mostly front-end for [`ide_db::rename`], but it also includes the\n //! tests. This module also implements a couple of magic tricks, like renaming\n //! `self` and to `self` (to switch between associated function and method).\n+\n use hir::{AsAssocItem, InFile, Semantics};\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n     rename::{bail, format_err, source_edit_from_references, IdentifierKind},\n     RootDatabase,\n };\n+use itertools::Itertools;\n use stdx::{always, never};\n-use syntax::{ast, AstNode, SyntaxNode};\n+use syntax::{\n+    ast::{self},\n+    AstNode, SyntaxNode,\n+};\n \n use text_edit::TextEdit;\n \n@@ -31,11 +36,12 @@ pub(crate) fn prepare_rename(\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax();\n \n-    let (name_like, def) = find_definition(&sema, syntax, position)?;\n-    if def.range_for_rename(&sema).is_none() {\n-        bail!(\"No references found at position\")\n-    }\n+    let mut defs = find_definitions(&sema, syntax, position)?;\n \n+    // TODO:\n+    // - empty case possible or already caught by `find_definitions`?\n+    // - is \"just take the first\" correct? If not, what do?\n+    let (name_like, _def) = defs.next().unwrap();\n     let frange = sema.original_range(name_like.syntax());\n     always!(frange.range.contains_inclusive(position.offset) && frange.file_id == position.file_id);\n     Ok(RangeInfo::new(frange.range, ()))\n@@ -61,20 +67,26 @@ pub(crate) fn rename(\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax();\n \n-    let (_name_like, def) = find_definition(&sema, syntax, position)?;\n-\n-    if let Definition::Local(local) = def {\n-        if let Some(self_param) = local.as_self_param(sema.db) {\n-            cov_mark::hit!(rename_self_to_param);\n-            return rename_self_to_param(&sema, local, self_param, new_name);\n-        }\n-        if new_name == \"self\" {\n-            cov_mark::hit!(rename_to_self);\n-            return rename_to_self(&sema, local);\n-        }\n-    }\n+    let defs = find_definitions(&sema, syntax, position)?;\n \n-    def.rename(&sema, new_name)\n+    let ops: RenameResult<Vec<SourceChange>> = defs\n+        .map(|(_namelike, def)| {\n+            if let Definition::Local(local) = def {\n+                if let Some(self_param) = local.as_self_param(sema.db) {\n+                    cov_mark::hit!(rename_self_to_param);\n+                    return rename_self_to_param(&sema, local, self_param, new_name);\n+                }\n+                if new_name == \"self\" {\n+                    cov_mark::hit!(rename_to_self);\n+                    return rename_to_self(&sema, local);\n+                }\n+            }\n+            def.rename(&sema, new_name)\n+        })\n+        .collect();\n+    ops?.into_iter()\n+        .reduce(|acc, elem| acc.merge(elem))\n+        .ok_or_else(|| format_err!(\"No references found at position\"))\n }\n \n /// Called by the client when it is about to rename a file.\n@@ -91,59 +103,76 @@ pub(crate) fn will_rename_file(\n     Some(change)\n }\n \n-fn find_definition(\n+fn find_definitions(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n-) -> RenameResult<(ast::NameLike, Definition)> {\n-    let name_like = sema\n-        .find_node_at_offset_with_descend::<ast::NameLike>(syntax, position.offset)\n-        .ok_or_else(|| format_err!(\"No references found at position\"))?;\n-\n-    let def = match &name_like {\n-        // renaming aliases would rename the item being aliased as the HIR doesn't track aliases yet\n-        ast::NameLike::Name(name)\n-            if name.syntax().parent().map_or(false, |it| ast::Rename::can_cast(it.kind())) =>\n-        {\n-            bail!(\"Renaming aliases is currently unsupported\")\n-        }\n-        ast::NameLike::Name(name) => NameClass::classify(sema, name).map(|class| match class {\n-            NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-            NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n-                Definition::Local(local_def)\n-            }\n-        }),\n-        ast::NameLike::NameRef(name_ref) => {\n-            if let Some(def) = NameRefClass::classify(sema, name_ref).map(|class| match class {\n-                NameRefClass::Definition(def) => def,\n-                NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n-                    Definition::Local(local_ref)\n+) -> RenameResult<impl Iterator<Item = (ast::NameLike, Definition)>> {\n+    let symbols = sema\n+        .find_nodes_at_offset_with_descend::<ast::NameLike>(syntax, position.offset)\n+        .map(|name_like| {\n+            let res = match &name_like {\n+                // renaming aliases would rename the item being aliased as the HIR doesn't track aliases yet\n+                ast::NameLike::Name(name)\n+                    if name\n+                        .syntax()\n+                        .parent()\n+                        .map_or(false, |it| ast::Rename::can_cast(it.kind())) =>\n+                {\n+                    bail!(\"Renaming aliases is currently unsupported\")\n                 }\n-            }) {\n-                // if the name differs from the definitions name it has to be an alias\n-                if def.name(sema.db).map_or(false, |it| it.to_string() != name_ref.text()) {\n-                    bail!(\"Renaming aliases is currently unsupported\");\n+                ast::NameLike::Name(name) => NameClass::classify(sema, name)\n+                    .map(|class| match class {\n+                        NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+                        NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n+                            Definition::Local(local_def)\n+                        }\n+                    })\n+                    .map(|def| (name_like.clone(), def))\n+                    .ok_or_else(|| format_err!(\"No references found at position\")),\n+                ast::NameLike::NameRef(name_ref) => NameRefClass::classify(sema, name_ref)\n+                    .map(|class| match class {\n+                        NameRefClass::Definition(def) => def,\n+                        NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n+                            Definition::Local(local_ref)\n+                        }\n+                    })\n+                    .and_then(|def| {\n+                        // if the name differs from the definitions name it has to be an alias\n+                        if def.name(sema.db).map_or(false, |it| it.to_string() != name_ref.text()) {\n+                            None\n+                        } else {\n+                            Some((name_like.clone(), def))\n+                        }\n+                    })\n+                    .ok_or_else(|| format_err!(\"Renaming aliases is currently unsupported\")),\n+                ast::NameLike::Lifetime(lifetime) => {\n+                    NameRefClass::classify_lifetime(sema, lifetime)\n+                        .and_then(|class| match class {\n+                            NameRefClass::Definition(def) => Some(def),\n+                            _ => None,\n+                        })\n+                        .or_else(|| {\n+                            NameClass::classify_lifetime(sema, lifetime).and_then(|it| match it {\n+                                NameClass::Definition(it) => Some(it),\n+                                _ => None,\n+                            })\n+                        })\n+                        .map(|def| (name_like, def))\n+                        .ok_or_else(|| format_err!(\"No references found at position\"))\n                 }\n-                Some(def)\n-            } else {\n-                None\n-            }\n-        }\n-        ast::NameLike::Lifetime(lifetime) => NameRefClass::classify_lifetime(sema, lifetime)\n-            .and_then(|class| match class {\n-                NameRefClass::Definition(def) => Some(def),\n-                _ => None,\n-            })\n-            .or_else(|| {\n-                NameClass::classify_lifetime(sema, lifetime).and_then(|it| match it {\n-                    NameClass::Definition(it) => Some(it),\n-                    _ => None,\n-                })\n-            }),\n-    }\n-    .ok_or_else(|| format_err!(\"No references found at position\"))?;\n-\n-    Ok((name_like, def))\n+            };\n+            res\n+        });\n+\n+    // TODO avoid collect() somehow?\n+    let v: RenameResult<Vec<(ast::NameLike, Definition)>> = symbols.collect();\n+    match v {\n+        // remove duplicates\n+        // TODO is \"unique by `Definition`\" correct?\n+        Ok(v) => Ok(v.into_iter().unique_by(|t| t.1)),\n+        Err(e) => Err(e),\n+    }\n }\n \n fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameResult<SourceChange> {"}, {"sha": "c80da1d2f791ef325802bc89a292f27b70b4316d", "filename": "crates/ide_db/src/source_change.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6decfceae1de5a8f9b7fac88a8dbe00a9c98c3e3/crates%2Fide_db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6decfceae1de5a8f9b7fac88a8dbe00a9c98c3e3/crates%2Fide_db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsource_change.rs?ref=6decfceae1de5a8f9b7fac88a8dbe00a9c98c3e3", "patch": "@@ -54,6 +54,13 @@ impl SourceChange {\n     pub fn get_source_edit(&self, file_id: FileId) -> Option<&TextEdit> {\n         self.source_file_edits.get(&file_id)\n     }\n+\n+    pub fn merge(mut self, other: SourceChange) -> SourceChange {\n+        self.extend(other.source_file_edits);\n+        self.extend(other.file_system_edits);\n+        self.is_snippet |= other.is_snippet; // TODO correct?\n+        self\n+    }\n }\n \n impl Extend<(FileId, TextEdit)> for SourceChange {\n@@ -62,6 +69,12 @@ impl Extend<(FileId, TextEdit)> for SourceChange {\n     }\n }\n \n+impl Extend<FileSystemEdit> for SourceChange {\n+    fn extend<T: IntoIterator<Item = FileSystemEdit>>(&mut self, iter: T) {\n+        iter.into_iter().for_each(|edit| self.push_file_system_edit(edit));\n+    }\n+}\n+\n impl From<FxHashMap<FileId, TextEdit>> for SourceChange {\n     fn from(source_file_edits: FxHashMap<FileId, TextEdit>) -> SourceChange {\n         SourceChange { source_file_edits, file_system_edits: Vec::new(), is_snippet: false }"}]}