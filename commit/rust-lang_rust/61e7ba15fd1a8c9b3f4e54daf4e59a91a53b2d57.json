{"sha": "61e7ba15fd1a8c9b3f4e54daf4e59a91a53b2d57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZTdiYTE1ZmQxYThjOWIzZjRlNTRkYWY0ZTU5YTkxYTUzYjJkNTc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-16T07:05:01Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-22T07:06:28Z"}, "message": "fix dynamically determining size and alignment", "tree": {"sha": "ac26c3a55f65b2fba2671e33d2d11d67233780f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac26c3a55f65b2fba2671e33d2d11d67233780f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61e7ba15fd1a8c9b3f4e54daf4e59a91a53b2d57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61e7ba15fd1a8c9b3f4e54daf4e59a91a53b2d57", "html_url": "https://github.com/rust-lang/rust/commit/61e7ba15fd1a8c9b3f4e54daf4e59a91a53b2d57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61e7ba15fd1a8c9b3f4e54daf4e59a91a53b2d57/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e314a4e75f18a77392ae3d316b777c1523908acf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e314a4e75f18a77392ae3d316b777c1523908acf", "html_url": "https://github.com/rust-lang/rust/commit/e314a4e75f18a77392ae3d316b777c1523908acf"}], "stats": {"total": 37, "additions": 20, "deletions": 17}, "files": [{"sha": "2b97860187ab07ccde64b8de56d1a00e988d05db", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/61e7ba15fd1a8c9b3f4e54daf4e59a91a53b2d57/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e7ba15fd1a8c9b3f4e54daf4e59a91a53b2d57/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=61e7ba15fd1a8c9b3f4e54daf4e59a91a53b2d57", "patch": "@@ -24,7 +24,7 @@ use syntax::source_map::{self, Span};\n use syntax::ast::Mutability;\n \n use super::{\n-    Value, ValTy, Operand, MemPlace, MPlaceTy, Place, PlaceExtra,\n+    Value, Operand, MemPlace, MPlaceTy, Place, PlaceExtra,\n     Memory, Machine\n };\n \n@@ -466,18 +466,19 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         self.layout_of(local_ty)\n     }\n \n-    /// Return the size and alignment of the value at the given type.\n+    /// Return the actual dynamic size and alignment of the place at the given type.\n     /// Note that the value does not matter if the type is sized. For unsized types,\n     /// the value has to be a fat pointer, and we only care about the \"extra\" data in it.\n-    pub fn size_and_align_of_val(\n+    pub fn size_and_align_of_mplace(\n         &self,\n-        val: ValTy<'tcx>,\n+        mplace: MPlaceTy<'tcx>,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n-        let pointee_ty = val.layout.ty.builtin_deref(true).unwrap().ty;\n-        let layout = self.layout_of(pointee_ty)?;\n-        if !layout.is_unsized() {\n-            Ok(layout.size_and_align())\n+        if let PlaceExtra::None = mplace.extra {\n+            assert!(!mplace.layout.is_unsized());\n+            Ok(mplace.layout.size_and_align())\n         } else {\n+            let layout = mplace.layout;\n+            assert!(layout.is_unsized());\n             match layout.ty.sty {\n                 ty::TyAdt(..) | ty::TyTuple(..) => {\n                     // First get the size of all statically known fields.\n@@ -498,12 +499,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                     // Recurse to get the size of the dynamically sized field (must be\n                     // the last field).\n-                    let field_layout = layout.field(self, layout.fields.count() - 1)?;\n-                    let (unsized_size, unsized_align) =\n-                        self.size_and_align_of_val(ValTy {\n-                            value: val.value,\n-                            layout: field_layout\n-                        })?;\n+                    let field = self.mplace_field(mplace, layout.fields.count() as u64 - 1)?;\n+                    let (unsized_size, unsized_align) = self.size_and_align_of_mplace(field)?;\n \n                     // FIXME (#26403, #27023): We should be adding padding\n                     // to `sized_size` (to accommodate the `unsized_align`\n@@ -533,18 +530,24 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     Ok((size.abi_align(align), align))\n                 }\n                 ty::TyDynamic(..) => {\n-                    let (_, vtable) = val.to_scalar_dyn_trait()?;\n+                    let vtable = match mplace.extra {\n+                        PlaceExtra::Vtable(vtable) => vtable,\n+                        _ => bug!(\"Expected vtable\"),\n+                    };\n                     // the second entry in the vtable is the dynamic size of the object.\n                     self.read_size_and_align_from_vtable(vtable)\n                 }\n \n                 ty::TySlice(_) | ty::TyStr => {\n+                    let len = match mplace.extra {\n+                        PlaceExtra::Length(len) => len,\n+                        _ => bug!(\"Expected length\"),\n+                    };\n                     let (elem_size, align) = layout.field(self, 0)?.size_and_align();\n-                    let (_, len) = val.to_scalar_slice(self)?;\n                     Ok((elem_size * len, align))\n                 }\n \n-                _ => bug!(\"size_of_val::<{:?}>\", layout.ty),\n+                _ => bug!(\"size_of_val::<{:?}> not supported\", layout.ty),\n             }\n         }\n     }"}]}