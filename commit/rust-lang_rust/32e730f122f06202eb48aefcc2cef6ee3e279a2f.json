{"sha": "32e730f122f06202eb48aefcc2cef6ee3e279a2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZTczMGYxMjJmMDYyMDJlYjQ4YWVmY2MyY2VmNmVlM2UyNzlhMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-24T20:46:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-24T20:46:32Z"}, "message": "auto merge of #11121 : vadimcn/rust/no-c++2, r=alexcrichton\n\nThis PR removes Rust's dependency on C++ for exception handling. Instead, it will use the unwind library API directly.\r\n\r\ncloses #10469", "tree": {"sha": "1316fc154599be29d575beb850b1c4ca4a86c24c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1316fc154599be29d575beb850b1c4ca4a86c24c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32e730f122f06202eb48aefcc2cef6ee3e279a2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32e730f122f06202eb48aefcc2cef6ee3e279a2f", "html_url": "https://github.com/rust-lang/rust/commit/32e730f122f06202eb48aefcc2cef6ee3e279a2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32e730f122f06202eb48aefcc2cef6ee3e279a2f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8c87fd9fe649d3211bb53754fb692a825ecfdff", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c87fd9fe649d3211bb53754fb692a825ecfdff", "html_url": "https://github.com/rust-lang/rust/commit/b8c87fd9fe649d3211bb53754fb692a825ecfdff"}, {"sha": "e3b37154b0f321ad74f293d98d9be2ae512c2ec7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3b37154b0f321ad74f293d98d9be2ae512c2ec7", "html_url": "https://github.com/rust-lang/rust/commit/e3b37154b0f321ad74f293d98d9be2ae512c2ec7"}], "stats": {"total": 516, "additions": 355, "deletions": 161}, "files": [{"sha": "6d5e4ae2fef446514d663f0203a8aa94ef433881", "filename": "mk/rt.mk", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -72,16 +72,16 @@ RUNTIME_CXXFLAGS_$(1)_$(2) = -D_RUST_STAGE1\n endif\n endif\n \n-RUNTIME_CXXS_$(1)_$(2) := \\\n-\t      rt/rust_cxx_glue.cpp\n-\n RUNTIME_CS_$(1)_$(2) := \\\n               rt/rust_builtin.c \\\n               rt/rust_upcall.c \\\n               rt/miniz.c \\\n               rt/rust_android_dummy.c \\\n               rt/rust_test_helpers.c\n \n+RUNTIME_LL_$(1)_$(2) := \\\n+\t\t\trt/rust_try.ll\n+\n # stage0 remove this after the next snapshot\n %.cpp:\n \t@touch tmp/foo.o\n@@ -94,19 +94,16 @@ RT_BUILD_DIR_$(1)_$(2) := $$(RT_OUTPUT_DIR_$(1))/stage$(2)\n RUNTIME_DEF_$(1)_$(2) := $$(RT_OUTPUT_DIR_$(1))/rustrt$$(CFG_DEF_SUFFIX_$(1))\n RUNTIME_INCS_$(1)_$(2) := -I $$(S)src/rt -I $$(S)src/rt/isaac -I $$(S)src/rt/uthash \\\n                      -I $$(S)src/rt/arch/$$(HOST_$(1))\n-RUNTIME_OBJS_$(1)_$(2) := $$(RUNTIME_CXXS_$(1)_$(2):rt/%.cpp=$$(RT_BUILD_DIR_$(1)_$(2))/%.o) \\\n+RUNTIME_OBJS_$(1)_$(2) := \\\n                      $$(RUNTIME_CS_$(1)_$(2):rt/%.c=$$(RT_BUILD_DIR_$(1)_$(2))/%.o) \\\n-                     $$(RUNTIME_S_$(1)_$(2):rt/%.S=$$(RT_BUILD_DIR_$(1)_$(2))/%.o)\n+                     $$(RUNTIME_S_$(1)_$(2):rt/%.S=$$(RT_BUILD_DIR_$(1)_$(2))/%.o) \\\n+                     $$(RUNTIME_LL_$(1)_$(2):rt/%.ll=$$(RT_BUILD_DIR_$(1)_$(2))/%.o)\n+\n ALL_OBJ_FILES += $$(RUNTIME_OBJS_$(1)_$(2))\n \n MORESTACK_OBJS_$(1)_$(2) := $$(RT_BUILD_DIR_$(1)_$(2))/arch/$$(HOST_$(1))/morestack.o\n ALL_OBJ_FILES += $$(MORESTACK_OBJS_$(1)_$(2))\n \n-$$(RT_BUILD_DIR_$(1)_$(2))/rust_cxx_glue.o: rt/rust_cxx_glue.cpp $$(MKFILE_DEPS)\n-\t@$$(call E, compile: $$@)\n-\t$$(Q)$$(call CFG_COMPILE_CXX_$(1), $$@, $$(RUNTIME_INCS_$(1)_$(2)) \\\n-                 $$(SNAP_DEFINES) $$(RUNTIME_CXXFLAGS_$(1)_$(2))) $$<\n-\n $$(RT_BUILD_DIR_$(1)_$(2))/%.o: rt/%.c $$(MKFILE_DEPS)\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(call CFG_COMPILE_C_$(1), $$@, $$(RUNTIME_INCS_$(1)_$(2)) \\\n@@ -117,6 +114,11 @@ $$(RT_BUILD_DIR_$(1)_$(2))/%.o: rt/%.S  $$(MKFILE_DEPS) \\\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(call CFG_ASSEMBLE_$(1),$$@,$$<)\n \n+$$(RT_BUILD_DIR_$(1)_$(2))/%.o: rt/%.ll  $$(MKFILE_DEPS) \\\n+                     $$(LLVM_CONFIG_$$(CFG_BUILD))\n+\t@$$(call E, compile: $$@)\n+\t$$(Q)$(LLC_$(CFG_BUILD)) -filetype=obj -mtriple=$(1) -relocation-model=pic -o $$@ $$<\n+\n $$(RT_BUILD_DIR_$(1)_$(2))/arch/$$(HOST_$(1))/libmorestack.a: $$(MORESTACK_OBJS_$(1)_$(2))\n \t@$$(call E, link: $$@)\n \t$$(Q)$(AR_$(1)) rcs $$@ $$^"}, {"sha": "5563ad5e7ef2d1275eb64a5fc90a7ca35dda13dc", "filename": "src/etc/mklldeps.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Fetc%2Fmklldeps.py", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Fetc%2Fmklldeps.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmklldeps.py?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -59,6 +59,7 @@\n     for lib in out.strip().split(' '):\n         lib = lib[2:] # chop of the leading '-l'\n         f.write(\"#[link(name = \\\"\" + lib + \"\\\", kind = \\\"static\\\")]\\n\")\n+    f.write(\"#[link(name = \\\"stdc++\\\")]\\n\")\n     if os == 'win32':\n         f.write(\"#[link(name = \\\"imagehlp\\\")]\\n\")\n     f.write(\"extern {}\\n\")"}, {"sha": "0cf91fbba0e88ba53cb731c864f1da1742d31324", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -708,10 +708,7 @@ pub fn get_cc_prog(sess: Session) -> ~str {\n     // In the future, FreeBSD will use clang as default compiler.\n     // It would be flexible to use cc (system's default C compiler)\n     // instead of hard-coded gcc.\n-    // For win32, there is no cc command, so we add a condition to make it use\n-    // g++.  We use g++ rather than gcc because it automatically adds linker\n-    // options required for generation of dll modules that correctly register\n-    // stack unwind tables.\n+    // For win32, there is no cc command, so we add a condition to make it use gcc.\n     match sess.targ_cfg.os {\n         abi::OsAndroid => match sess.opts.android_cross_path {\n             Some(ref path) => format!(\"{}/bin/arm-linux-androideabi-gcc\", *path),\n@@ -720,7 +717,7 @@ pub fn get_cc_prog(sess: Session) -> ~str {\n                             (--android-cross-path)\")\n             }\n         },\n-        abi::OsWin32 => ~\"g++\",\n+        abi::OsWin32 => ~\"gcc\",\n         _ => ~\"cc\",\n     }\n }\n@@ -1032,6 +1029,13 @@ fn link_args(sess: Session,\n         }\n     }\n \n+    if sess.targ_cfg.os == abi::OsWin32 {\n+        // Make sure that we link to the dynamic libgcc, otherwise cross-module\n+        // DWARF stack unwinding will not work.\n+        // This behavior may be overriden by --link-args \"-static-libgcc\"\n+        args.push(~\"-shared-libgcc\");\n+    }\n+\n     add_local_native_libraries(&mut args, sess);\n     add_upstream_rust_crates(&mut args, sess, dylib, tmpdir);\n     add_upstream_native_libraries(&mut args, sess);"}, {"sha": "730ceba12c786808231c70224556247abfcd1056", "filename": "src/librustc/back/upcall.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b8c87fd9fe649d3211bb53754fb692a825ecfdff/src%2Flibrustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c87fd9fe649d3211bb53754fb692a825ecfdff/src%2Flibrustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fupcall.rs?ref=b8c87fd9fe649d3211bb53754fb692a825ecfdff", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-use driver::session;\n-use middle::trans::base;\n-use middle::trans::type_::Type;\n-use lib::llvm::{ModuleRef, ValueRef};\n-\n-pub struct Upcalls {\n-    rust_personality: ValueRef,\n-}\n-\n-macro_rules! upcall (\n-    (nothrow fn $name:ident -> $ret:expr) => ({\n-        let fn_ty = Type::func([], &$ret);\n-        let decl = base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty);\n-        base::set_no_unwind(decl);\n-        decl\n-    })\n-)\n-\n-pub fn declare_upcalls(_targ_cfg: @session::config,\n-                       llmod: ModuleRef) -> @Upcalls {\n-    @Upcalls {\n-        rust_personality: upcall!(nothrow fn rust_personality -> Type::i32()),\n-    }\n-}"}, {"sha": "b9f4315ca2b139ce0a027602cf189e161979ed73", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -92,7 +92,6 @@ pub mod back {\n     pub mod link;\n     pub mod manifest;\n     pub mod abi;\n-    pub mod upcall;\n     pub mod arm;\n     pub mod mips;\n     pub mod x86;"}, {"sha": "754b5c8fb08076fc6d2647e9cb6e099ec6a93168", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -319,7 +319,6 @@ pub mod llvm {\n     // automatically updated whenever LLVM is updated to include an up-to-date\n     // set of the libraries we need to link to LLVM for.\n     #[link(name = \"rustllvm\", kind = \"static\")]\n-    #[link(name = \"stdc++\")]\n     extern {\n         /* Create and destroy contexts. */\n         pub fn LLVMContextCreate() -> ContextRef;"}, {"sha": "6fc077876a70d781a6128cdc6cddcaea4e64704c", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -208,7 +208,7 @@ pub fn collect_language_items(crate: &ast::Crate,\n }\n \n lets_do_this! {\n-    There are 42 lang items.\n+    There are 43 lang items.\n \n //  ID, Variant name,                    Name,                      Method name;\n     0,  FreezeTraitLangItem,             \"freeze\",                  freeze_trait;\n@@ -261,5 +261,7 @@ lets_do_this! {\n     40, EventLoopFactoryLangItem,        \"event_loop_factory\",      event_loop_factory;\n \n     41, TypeIdLangItem,                  \"type_id\",                 type_id;\n+\n+    42, EhPersonalityLangItem,           \"eh_personality\",          eh_personality_fn;\n }\n "}, {"sha": "9d14942a61ab0d3fd317f79136cdd27a9953aa29", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -37,6 +37,7 @@ use metadata::{csearch, cstore, encoder};\n use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::lang_items::{MallocFnLangItem, ClosureExchangeMallocFnLangItem};\n+use middle::lang_items::{EhPersonalityLangItem};\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::base;\n@@ -1027,10 +1028,10 @@ pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n     let llretty = Type::struct_([Type::i8p(), Type::i32()], false);\n-    // The exception handling personality function. This is the C++\n-    // personality function __gxx_personality_v0, wrapped in our naming\n-    // convention.\n-    let personality = bcx.ccx().upcalls.rust_personality;\n+    // The exception handling personality function.\n+    let personality = callee::trans_fn_ref(bcx,\n+                                           langcall(bcx, None, \"\", EhPersonalityLangItem),\n+                                           0).llfn;\n     // The only landing pad clause will be 'cleanup'\n     let llretval = LandingPad(pad_bcx, llretty, personality, 1u);\n     // The landing pad block is a cleanup\n@@ -3195,6 +3196,8 @@ pub fn trans_crate(sess: session::Session,\n     reachable.push(ccx.crate_map_name.to_owned());\n     reachable.push(~\"main\");\n     reachable.push(~\"rust_stack_exhausted\");\n+    reachable.push(~\"rust_eh_personality\"); // referenced from .eh_frame section on some platforms\n+    reachable.push(~\"rust_eh_personality_catch\"); // referenced from rt/rust_try.ll\n \n     return CrateTranslation {\n         context: llcx,"}, {"sha": "aca267023c7e9eecbdeb1f51c8ab828a6da466e1", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n \n-use back::{upcall};\n use driver::session;\n use lib::llvm::{ContextRef, ModuleRef, ValueRef};\n use lib::llvm::{llvm, TargetData, TypeNames};\n@@ -105,7 +104,6 @@ pub struct CrateContext {\n      tcx: ty::ctxt,\n      maps: astencode::Maps,\n      stats: @mut Stats,\n-     upcalls: @upcall::Upcalls,\n      tydesc_type: Type,\n      int_type: Type,\n      opaque_vec_type: Type,\n@@ -233,7 +231,6 @@ impl CrateContext {\n                     llvm_insns: HashMap::new(),\n                     fn_stats: ~[]\n                   },\n-                  upcalls: upcall::declare_upcalls(targ_cfg, llmod),\n                   tydesc_type: tydesc_type,\n                   int_type: int_type,\n                   opaque_vec_type: opaque_vec_type,"}, {"sha": "df1ebeb6407aaa439e62f6d85de53e89bfa4c9ed", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -173,6 +173,9 @@ mod local_ptr;\n /// Bindings to pthread/windows thread-local storage.\n mod thread_local_storage;\n \n+/// Stack unwinding\n+pub mod unwind;\n+\n /// Just stuff\n mod util;\n "}, {"sha": "30e05e9091f3efe4417c40086028832919f64659", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 66, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -18,10 +18,9 @@ use super::local_heap::LocalHeap;\n use prelude::*;\n \n use borrow;\n-use cast::transmute;\n use cleanup;\n use io::Writer;\n-use libc::{c_void, uintptr_t, c_char, size_t};\n+use libc::{c_char, size_t};\n use local_data;\n use option::{Option, Some, None};\n use rt::borrowck::BorrowRecord;\n@@ -33,8 +32,8 @@ use rt::local::Local;\n use rt::logging::StdErrLogger;\n use rt::sched::{Scheduler, SchedHandle};\n use rt::stack::{StackSegment, StackPool};\n+use rt::unwind::Unwinder;\n use send_str::SendStr;\n-use task::TaskResult;\n use unstable::finally::Finally;\n use unstable::mutex::Mutex;\n \n@@ -91,21 +90,6 @@ pub enum SchedHome {\n pub struct GarbageCollector;\n pub struct LocalStorage(Option<local_data::Map>);\n \n-pub struct Unwinder {\n-    unwinding: bool,\n-    cause: Option<~Any>\n-}\n-\n-impl Unwinder {\n-    fn result(&mut self) -> TaskResult {\n-        if self.unwinding {\n-            Err(self.cause.take().unwrap())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-}\n-\n impl Task {\n \n     // A helper to build a new task using the dynamically found\n@@ -452,54 +436,6 @@ impl Coroutine {\n \n }\n \n-\n-// Just a sanity check to make sure we are catching a Rust-thrown exception\n-static UNWIND_TOKEN: uintptr_t = 839147;\n-\n-impl Unwinder {\n-    pub fn try(&mut self, f: ||) {\n-        use unstable::raw::Closure;\n-\n-        unsafe {\n-            let closure: Closure = transmute(f);\n-            let code = transmute(closure.code);\n-            let env = transmute(closure.env);\n-\n-            let token = rust_try(try_fn, code, env);\n-            assert!(token == 0 || token == UNWIND_TOKEN);\n-        }\n-\n-        extern fn try_fn(code: *c_void, env: *c_void) {\n-            unsafe {\n-                let closure: Closure = Closure {\n-                    code: transmute(code),\n-                    env: transmute(env),\n-                };\n-                let closure: || = transmute(closure);\n-                closure();\n-            }\n-        }\n-\n-        extern {\n-            fn rust_try(f: extern \"C\" fn(*c_void, *c_void),\n-                        code: *c_void,\n-                        data: *c_void) -> uintptr_t;\n-        }\n-    }\n-\n-    pub fn begin_unwind(&mut self, cause: ~Any) -> ! {\n-        self.unwinding = true;\n-        self.cause = Some(cause);\n-        unsafe {\n-            rust_begin_unwind(UNWIND_TOKEN);\n-            return transmute(());\n-        }\n-        extern {\n-            fn rust_begin_unwind(token: uintptr_t);\n-        }\n-    }\n-}\n-\n /// This function is invoked from rust's current __morestack function. Segmented\n /// stacks are currently not enabled as segmented stacks, but rather one giant\n /// stack segment. This means that whenever we run out of stack, we want to"}, {"sha": "3f6f54a9c0eeea1b39cfe28832c9d4060f323609", "filename": "src/libstd/rt/unwind.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -0,0 +1,256 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// Implementation of Rust stack unwinding\n+//\n+// For background on exception handling and stack unwinding please see \"Exception Handling in LLVM\"\n+// (llvm.org/docs/ExceptionHandling.html) and documents linked from it.\n+// These are also good reads:\n+//     http://theofilos.cs.columbia.edu/blog/2013/09/22/base_abi/\n+//     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n+//     http://www.airs.com/blog/index.php?s=exception+frames\n+//\n+// ~~~ A brief summary ~~~\n+// Exception handling happens in two phases: a search phase and a cleanup phase.\n+//\n+// In both phases the unwinder walks stack frames from top to bottom using information from\n+// the stack frame unwind sections of the current process's modules (\"module\" here refers to\n+// an OS module, i.e. an executable or a dynamic library).\n+//\n+// For each stack frame, it invokes the associated \"personality routine\", whose address is also\n+// stored in the unwind info section.\n+//\n+// In the search phase, the job of a personality routine is to examine exception object being\n+// thrown, and to decide whether it should be caught at that stack frame.  Once the handler frame\n+// has been identified, cleanup phase begins.\n+//\n+// In the cleanup phase, personality routines invoke cleanup code associated with their\n+// stack frames (i.e. destructors).  Once stack has been unwound down to the handler frame level,\n+// unwinding stops and the last personality routine transfers control to its' catch block.\n+//\n+// ~~~ Frame unwind info registration ~~~\n+// Each module has its' own frame unwind info section (usually \".eh_frame\"), and unwinder needs\n+// to know about all of them in order for unwinding to be able to cross module boundaries.\n+//\n+// On some platforms, like Linux, this is achieved by dynamically enumerating currently loaded\n+// modules via the dl_iterate_phdr() API and finding all .eh_frame sections.\n+//\n+// Others, like Windows, require modules to actively register their unwind info sections by calling\n+// __register_frame_info() API at startup.\n+// In the latter case it is essential that there is only one copy of the unwinder runtime\n+// in the process.  This is usually achieved by linking to the dynamic version of the unwind\n+// runtime.\n+//\n+// Currently Rust uses unwind runtime provided by libgcc.\n+\n+use prelude::*;\n+use cast::transmute;\n+use task::TaskResult;\n+use libc::{c_void, c_int};\n+use self::libunwind::*;\n+\n+mod libunwind {\n+    //! Unwind library interface\n+\n+    #[allow(non_camel_case_types)];\n+\n+    use libc::{uintptr_t, uint64_t};\n+\n+    #[repr(C)]\n+    pub enum _Unwind_Action\n+    {\n+        _UA_SEARCH_PHASE = 1,\n+        _UA_CLEANUP_PHASE = 2,\n+        _UA_HANDLER_FRAME = 4,\n+        _UA_FORCE_UNWIND = 8,\n+        _UA_END_OF_STACK = 16,\n+    }\n+\n+    #[repr(C)]\n+    pub enum _Unwind_Reason_Code {\n+        _URC_NO_REASON = 0,\n+        _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n+        _URC_FATAL_PHASE2_ERROR = 2,\n+        _URC_FATAL_PHASE1_ERROR = 3,\n+        _URC_NORMAL_STOP = 4,\n+        _URC_END_OF_STACK = 5,\n+        _URC_HANDLER_FOUND = 6,\n+        _URC_INSTALL_CONTEXT = 7,\n+        _URC_CONTINUE_UNWIND = 8,\n+    }\n+\n+    pub type _Unwind_Exception_Class = uint64_t;\n+\n+    pub type _Unwind_Word = uintptr_t;\n+\n+    pub struct _Unwind_Exception {\n+        exception_class: _Unwind_Exception_Class,\n+        exception_cleanup: _Unwind_Exception_Cleanup_Fn,\n+        private_1: _Unwind_Word,\n+        private_2: _Unwind_Word,\n+    }\n+\n+    pub enum _Unwind_Context {}\n+\n+    pub type _Unwind_Exception_Cleanup_Fn = extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n+                                                          exception: *_Unwind_Exception);\n+\n+    extern \"C\" {\n+        pub fn _Unwind_RaiseException(exception: *_Unwind_Exception) -> _Unwind_Reason_Code;\n+        pub fn _Unwind_DeleteException(exception: *_Unwind_Exception);\n+    }\n+}\n+\n+pub struct Unwinder {\n+    unwinding: bool,\n+    cause: Option<~Any>\n+}\n+\n+impl Unwinder {\n+\n+    pub fn try(&mut self, f: ||) {\n+        use unstable::raw::Closure;\n+\n+        unsafe {\n+            let closure: Closure = transmute(f);\n+            let code = transmute(closure.code);\n+            let env = transmute(closure.env);\n+\n+            let ep = rust_try(try_fn, code, env);\n+            if !ep.is_null() {\n+                rtdebug!(\"Caught {}\", (*ep).exception_class);\n+                _Unwind_DeleteException(ep);\n+            }\n+        }\n+\n+        extern fn try_fn(code: *c_void, env: *c_void) {\n+            unsafe {\n+                let closure: Closure = Closure {\n+                    code: transmute(code),\n+                    env: transmute(env),\n+                };\n+                let closure: || = transmute(closure);\n+                closure();\n+            }\n+        }\n+\n+        extern {\n+            // Rust's try-catch\n+            // When f(...) returns normally, the return value is null.\n+            // When f(...) throws, the return value is a pointer to the caught exception object.\n+            fn rust_try(f: extern \"C\" fn(*c_void, *c_void),\n+                        code: *c_void,\n+                        data: *c_void) -> *_Unwind_Exception;\n+        }\n+    }\n+\n+    pub fn begin_unwind(&mut self, cause: ~Any) -> ! {\n+        rtdebug!(\"begin_unwind()\");\n+\n+        self.unwinding = true;\n+        self.cause = Some(cause);\n+\n+        unsafe {\n+            let exception = ~_Unwind_Exception {\n+                exception_class: rust_exception_class(),\n+                exception_cleanup: exception_cleanup,\n+                private_1: 0,\n+                private_2: 0\n+            };\n+            let error = _Unwind_RaiseException(transmute(exception));\n+            rtabort!(\"Could not unwind stack, error = {}\", error as int)\n+        }\n+\n+        extern \"C\" fn exception_cleanup(_unwind_code: _Unwind_Reason_Code,\n+                                        exception: *_Unwind_Exception) {\n+            rtdebug!(\"exception_cleanup()\");\n+            unsafe {\n+                let _: ~_Unwind_Exception = transmute(exception);\n+            }\n+        }\n+    }\n+\n+    pub fn result(&mut self) -> TaskResult {\n+        if self.unwinding {\n+            Err(self.cause.take().unwrap())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+}\n+\n+// Rust's exception class identifier.  This is used by personality routines to\n+// determine whether the exception was thrown by their own runtime.\n+fn rust_exception_class() -> _Unwind_Exception_Class {\n+    let bytes = bytes!(\"MOZ\\0RUST\"); // vendor, language\n+    unsafe {\n+        let ptr: *_Unwind_Exception_Class = transmute(bytes.as_ptr());\n+        *ptr\n+    }\n+}\n+\n+\n+// We could implement our personality routine in pure Rust, however exception info decoding\n+// is tedious.  More importantly, personality routines have to handle various platform\n+// quirks, which are not fun to maintain.  For this reason, we attempt to reuse personality\n+// routine of the C language: __gcc_personality_v0.\n+//\n+// Since C does not support exception catching, __gcc_personality_v0 simply always\n+// returns _URC_CONTINUE_UNWIND in search phase, and always returns _URC_INSTALL_CONTEXT\n+// (i.e. \"invoke cleanup code\") in cleanup phase.\n+//\n+// This is pretty close to Rust's exception handling approach, except that Rust does have\n+// a single \"catch-all\" handler at the bottom of each task's stack.\n+// So we have two versions:\n+// - rust_eh_personality, used by all cleanup landing pads, which never catches, so\n+//   the behavior of __gcc_personality_v0 is perfectly adequate there, and\n+// - rust_eh_personality_catch, used only by rust_try(), which always catches.  This is\n+//   achieved by overriding the return value in search phase to always say \"catch!\".\n+\n+extern \"C\" {\n+    fn __gcc_personality_v0(version: c_int,\n+                            actions: _Unwind_Action,\n+                            exception_class: _Unwind_Exception_Class,\n+                            ue_header: *_Unwind_Exception,\n+                            context: *_Unwind_Context) -> _Unwind_Reason_Code;\n+}\n+\n+#[lang=\"eh_personality\"]\n+#[no_mangle] // so we can reference it by name from middle/trans/base.rs\n+#[doc(hidden)]\n+#[cfg(not(test))]\n+pub extern \"C\" fn rust_eh_personality(version: c_int,\n+                                      actions: _Unwind_Action,\n+                                      exception_class: _Unwind_Exception_Class,\n+                                      ue_header: *_Unwind_Exception,\n+                                      context: *_Unwind_Context) -> _Unwind_Reason_Code {\n+    unsafe {\n+        __gcc_personality_v0(version, actions, exception_class, ue_header, context)\n+    }\n+}\n+\n+#[no_mangle] // referenced from rust_try.ll\n+#[doc(hidden)]\n+#[cfg(not(test))]\n+pub extern \"C\" fn rust_eh_personality_catch(version: c_int,\n+                                            actions: _Unwind_Action,\n+                                            exception_class: _Unwind_Exception_Class,\n+                                            ue_header: *_Unwind_Exception,\n+                                            context: *_Unwind_Context) -> _Unwind_Reason_Code {\n+    if (actions as c_int & _UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+        _URC_HANDLER_FOUND // catch!\n+    }\n+    else { // cleanup phase\n+        unsafe {\n+             __gcc_personality_v0(version, actions, exception_class, ue_header, context)\n+        }\n+    }\n+}"}, {"sha": "01d163f49e0a35ad3dc5fc6d2a03daf96e7361bc", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -26,24 +26,45 @@ extern {}\n #[link(name = \"dl\")]\n #[link(name = \"m\")]\n #[link(name = \"pthread\")]\n-#[link(name = \"stdc++\")]\n extern {}\n \n #[cfg(target_os = \"android\")]\n #[link(name = \"dl\")]\n #[link(name = \"log\")]\n-#[link(name = \"supc++\")]\n #[link(name = \"m\")]\n extern {}\n \n #[cfg(target_os = \"freebsd\")]\n #[link(name = \"execinfo\")]\n #[link(name = \"rt\")]\n-#[link(name = \"stdc++\")]\n #[link(name = \"pthread\")]\n extern {}\n \n #[cfg(target_os = \"macos\")]\n #[link(name = \"pthread\")]\n-#[link(name = \"stdc++\")]\n extern {}\n+\n+// NOTE: remove after snapshot\n+// stage0-generated code still depends on c++\n+#[cfg(stage0)]\n+mod stage0 {\n+    #[cfg(target_os = \"linux\")]\n+    #[link(name = \"stdc++\")]\n+    extern {}\n+\n+    #[cfg(target_os = \"android\")]\n+    #[link(name = \"supc++\")]\n+    extern {}\n+\n+    #[cfg(target_os = \"freebsd\")]\n+    #[link(name = \"stdc++\")]\n+    extern {}\n+\n+    #[cfg(target_os = \"macos\")]\n+    #[link(name = \"stdc++\")]\n+    extern {}\n+\n+    #[cfg(target_os = \"win32\")]\n+    #[link(name = \"stdc++\")]\n+    extern {}\n+}"}, {"sha": "b44d29642c4b7a820810f8d62cb4395375995965", "filename": "src/rt/rust_cxx_glue.cpp", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b8c87fd9fe649d3211bb53754fb692a825ecfdff/src%2Frt%2Frust_cxx_glue.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b8c87fd9fe649d3211bb53754fb692a825ecfdff/src%2Frt%2Frust_cxx_glue.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cxx_glue.cpp?ref=b8c87fd9fe649d3211bb53754fb692a825ecfdff", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/* Foreign builtins which require C++ */\n-\n-#include \"rust_globals.h\"\n-\n-typedef void *(rust_try_fn)(void*, void*);\n-\n-extern \"C\" CDECL uintptr_t\n-rust_try(rust_try_fn f, void *fptr, void *env) {\n-    try {\n-        f(fptr, env);\n-    } catch (uintptr_t token) {\n-        assert(token != 0);\n-        return token;\n-    }\n-    return 0;\n-}\n-\n-extern \"C\" CDECL void\n-rust_begin_unwind(uintptr_t token) {\n-    throw token;\n-}"}, {"sha": "c912aa789bf6bbe83c8d450eab04b71850ccd26c", "filename": "src/rt/rust_try.ll", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Frt%2Frust_try.ll", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Frt%2Frust_try.ll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_try.ll?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -0,0 +1,34 @@\n+; Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+; file at the top-level directory of this distribution and at\n+; http://rust-lang.org/COPYRIGHT.\n+;\n+; Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+; http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+; <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+; option. This file may not be copied, modified, or distributed\n+; except according to those terms.\n+\n+; Rust's try-catch\n+; When f(...) returns normally, the return value is null.\n+; When f(...) throws, the return value is a pointer to the caught exception object.\n+; See also: libstd/rt/unwind.rs\n+\n+define i8* @rust_try(void (i8*,i8*)* %f, i8* %fptr, i8* %env) {\n+\n+\tinvoke void %f(i8* %fptr, i8* %env)\n+\t\tto label %normal\n+\t\tunwind label %catch\n+\n+normal:\n+\tret i8* null\n+\n+catch:\n+\t%1 = landingpad { i8*, i32 } personality i8* bitcast (i32 (...)* @rust_eh_personality_catch to i8*)\n+\t\t\tcatch i8* null ; catch everything\n+\n+\t; extract and return pointer to the exception object\n+    %2 = extractvalue { i8*, i32 } %1, 0\n+\tret i8* %2\n+}\n+\n+declare i32 @rust_eh_personality_catch(...)"}, {"sha": "daa46bab404df94e2b79fd5e594641cb137f3b41", "filename": "src/rt/rust_upcall.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Frt%2Frust_upcall.c", "raw_url": "https://github.com/rust-lang/rust/raw/32e730f122f06202eb48aefcc2cef6ee3e279a2f/src%2Frt%2Frust_upcall.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.c?ref=32e730f122f06202eb48aefcc2cef6ee3e279a2f", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// NOTE: remove this file after snapshot\n+// unwind personality routine lives now in libstd/rt/unwind.rs\n+\n /*\n   Upcalls\n "}]}