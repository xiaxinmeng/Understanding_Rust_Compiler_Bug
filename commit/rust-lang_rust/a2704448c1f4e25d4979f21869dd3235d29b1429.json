{"sha": "a2704448c1f4e25d4979f21869dd3235d29b1429", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNzA0NDQ4YzFmNGUyNWQ0OTc5ZjIxODY5ZGQzMjM1ZDI5YjE0Mjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-08T23:37:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-08T23:37:06Z"}, "message": "Auto merge of #81361 - ssomers:btree_drainy_refactor_7, r=Mark-Simulacrum\n\nBTreeMap: lightly refactor the split_off implementation\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "2d72359dee1bbf252bd4d3235a9d80d3fd152ca0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d72359dee1bbf252bd4d3235a9d80d3fd152ca0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2704448c1f4e25d4979f21869dd3235d29b1429", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2704448c1f4e25d4979f21869dd3235d29b1429", "html_url": "https://github.com/rust-lang/rust/commit/a2704448c1f4e25d4979f21869dd3235d29b1429", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2704448c1f4e25d4979f21869dd3235d29b1429/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fc6756b42e0556cc2e18079f5fc6b4d58f4e81a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fc6756b42e0556cc2e18079f5fc6b4d58f4e81a", "html_url": "https://github.com/rust-lang/rust/commit/0fc6756b42e0556cc2e18079f5fc6b4d58f4e81a"}, {"sha": "b20f468489ae044a60775b6ee225fca91bac7a5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b20f468489ae044a60775b6ee225fca91bac7a5e", "html_url": "https://github.com/rust-lang/rust/commit/b20f468489ae044a60775b6ee225fca91bac7a5e"}], "stats": {"total": 109, "additions": 67, "deletions": 42}, "files": [{"sha": "dc1098757268a03603f259d383bd5984735f6a2e", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a2704448c1f4e25d4979f21869dd3235d29b1429/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2704448c1f4e25d4979f21869dd3235d29b1429/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=a2704448c1f4e25d4979f21869dd3235d29b1429", "patch": "@@ -20,6 +20,14 @@ use Entry::*;\n /// We might temporarily have fewer elements during methods.\n pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n \n+// A tree in a `BTreeMap` is a tree in the `node` module with addtional invariants:\n+// - Keys must appear in ascending order (according to the key's type).\n+// - If the root node is internal, it must contain at least 1 element.\n+// - Every non-root node contains at least MIN_LEN elements.\n+//\n+// An empty map may be represented both by the absense of a root node or by a\n+// root node that is an empty leaf.\n+\n /// A map based on a B-Tree.\n ///\n /// B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing\n@@ -1131,20 +1139,12 @@ impl<K, V> BTreeMap<K, V> {\n         let total_num = self.len();\n         let left_root = self.root.as_mut().unwrap(); // unwrap succeeds because not empty\n \n-        let mut right = Self::new();\n-        let right_root = Self::ensure_is_owned(&mut right.root);\n-\n-        left_root.split_off(right_root, key);\n+        let right_root = left_root.split_off(key);\n \n-        if left_root.height() < right_root.height() {\n-            self.length = left_root.reborrow().calc_length();\n-            right.length = total_num - self.len();\n-        } else {\n-            right.length = right_root.reborrow().calc_length();\n-            self.length = total_num - right.len();\n-        }\n+        let (new_left_len, right_len) = Root::calc_split_length(total_num, &left_root, &right_root);\n+        self.length = new_left_len;\n \n-        right\n+        BTreeMap { root: Some(right_root), length: right_len }\n     }\n \n     /// Creates an iterator that visits all elements (key-value pairs) in"}, {"sha": "1921982464ae460b0da06227bbae7ac20a8c194e", "filename": "library/alloc/src/collections/btree/split.rs", "status": "modified", "additions": 55, "deletions": 30, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a2704448c1f4e25d4979f21869dd3235d29b1429/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2704448c1f4e25d4979f21869dd3235d29b1429/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs?ref=a2704448c1f4e25d4979f21869dd3235d29b1429", "patch": "@@ -4,46 +4,71 @@ use super::search::SearchResult::*;\n use core::borrow::Borrow;\n \n impl<K, V> Root<K, V> {\n-    pub fn split_off<Q: ?Sized + Ord>(&mut self, right_root: &mut Self, key: &Q)\n+    /// Calculates the length of both trees that result from splitting up\n+    /// a given number of distinct key-value pairs.\n+    pub fn calc_split_length(\n+        total_num: usize,\n+        root_a: &Root<K, V>,\n+        root_b: &Root<K, V>,\n+    ) -> (usize, usize) {\n+        let (length_a, length_b);\n+        if root_a.height() < root_b.height() {\n+            length_a = root_a.reborrow().calc_length();\n+            length_b = total_num - length_a;\n+            debug_assert_eq!(length_b, root_b.reborrow().calc_length());\n+        } else {\n+            length_b = root_b.reborrow().calc_length();\n+            length_a = total_num - length_b;\n+            debug_assert_eq!(length_a, root_a.reborrow().calc_length());\n+        }\n+        (length_a, length_b)\n+    }\n+\n+    /// Split off a tree with key-value pairs at and after the given key.\n+    /// The result is meaningful only if the tree is ordered by key,\n+    /// and if the ordering of `Q` corresponds to that of `K`.\n+    /// If `self` respects all `BTreeMap` tree invariants, then both\n+    /// `self` and the returned tree will respect those invariants.\n+    pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n     where\n         K: Borrow<Q>,\n     {\n-        debug_assert!(right_root.height() == 0);\n-        debug_assert!(right_root.len() == 0);\n-\n         let left_root = self;\n-        for _ in 0..left_root.height() {\n-            right_root.push_internal_level();\n-        }\n-\n-        {\n-            let mut left_node = left_root.borrow_mut();\n-            let mut right_node = right_root.borrow_mut();\n-\n-            loop {\n-                let mut split_edge = match left_node.search_node(key) {\n-                    // key is going to the right tree\n-                    Found(kv) => kv.left_edge(),\n-                    GoDown(edge) => edge,\n-                };\n-\n-                split_edge.move_suffix(&mut right_node);\n-\n-                match (split_edge.force(), right_node.force()) {\n-                    (Internal(edge), Internal(node)) => {\n-                        left_node = edge.descend();\n-                        right_node = node.first_edge().descend();\n-                    }\n-                    (Leaf(_), Leaf(_)) => {\n-                        break;\n-                    }\n-                    _ => unreachable!(),\n+        let mut right_root = Root::new_pillar(left_root.height());\n+        let mut left_node = left_root.borrow_mut();\n+        let mut right_node = right_root.borrow_mut();\n+\n+        loop {\n+            let mut split_edge = match left_node.search_node(key) {\n+                // key is going to the right tree\n+                Found(kv) => kv.left_edge(),\n+                GoDown(edge) => edge,\n+            };\n+\n+            split_edge.move_suffix(&mut right_node);\n+\n+            match (split_edge.force(), right_node.force()) {\n+                (Internal(edge), Internal(node)) => {\n+                    left_node = edge.descend();\n+                    right_node = node.first_edge().descend();\n                 }\n+                (Leaf(_), Leaf(_)) => break,\n+                _ => unreachable!(),\n             }\n         }\n \n         left_root.fix_right_border();\n         right_root.fix_left_border();\n+        right_root\n+    }\n+\n+    /// Creates a tree consisting of empty nodes.\n+    fn new_pillar(height: usize) -> Self {\n+        let mut root = Root::new();\n+        for _ in 0..height {\n+            root.push_internal_level();\n+        }\n+        root\n     }\n \n     /// Removes empty levels on the top, but keeps an empty leaf if the entire tree is empty."}]}