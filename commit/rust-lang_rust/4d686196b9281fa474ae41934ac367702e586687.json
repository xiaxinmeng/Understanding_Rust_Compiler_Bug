{"sha": "4d686196b9281fa474ae41934ac367702e586687", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNjg2MTk2YjkyODFmYTQ3NGFlNDE5MzRhYzM2NzcwMmU1ODY2ODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-18T10:39:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-18T10:39:28Z"}, "message": "Auto merge of #6863 - Jarcho:wild_enum_match, r=llogiq\n\n`match_wildcard` improvements\n\nfixes: #6604\nfixes: #5733\nfixes: #6862\n\n#5733 is only fixed in the normal case, if different paths are used for the variants then the same problem will occur. It's cause by `def_path_str` returning an utterly useless result. I haven't dug into why yet.\n\nFor #6604 there should be some discussion before accepting this. It's easy enough to change the message rather than disable the lint for `Option` and `Result`.\n\nchangelog: Attempt to find a common path prefix for `match_wildcard_for_single_variants` and `wildcard_enum_match_arm`\nchangelog: Don't lint op `Option` and `Result` for `match_wildcard_for_single_variants` and `wildcard_enum_match_arm`\nchangelog: Consider `or` patterns and `Self` prefix for `match_wildcard_for_single_variants` and `wildcard_enum_match_arm`", "tree": {"sha": "0477a74d43f16b30e2fae61ba21a7ede7d230acc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0477a74d43f16b30e2fae61ba21a7ede7d230acc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d686196b9281fa474ae41934ac367702e586687", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d686196b9281fa474ae41934ac367702e586687", "html_url": "https://github.com/rust-lang/rust/commit/4d686196b9281fa474ae41934ac367702e586687", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d686196b9281fa474ae41934ac367702e586687/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba13311c466f9062d702acf4f2ac463471b42eb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba13311c466f9062d702acf4f2ac463471b42eb2", "html_url": "https://github.com/rust-lang/rust/commit/ba13311c466f9062d702acf4f2ac463471b42eb2"}, {"sha": "d5a7941ead06e1cb89a0a2cc6ea5c19810daea03", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5a7941ead06e1cb89a0a2cc6ea5c19810daea03", "html_url": "https://github.com/rust-lang/rust/commit/d5a7941ead06e1cb89a0a2cc6ea5c19810daea03"}], "stats": {"total": 439, "additions": 322, "deletions": 117}, "files": [{"sha": "a4ddef666c0b39f9f5f3964a2ae1cf5b391cafd5", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -430,7 +430,7 @@ fn is_relevant_block(cx: &LateContext<'_>, typeck_results: &ty::TypeckResults<'_\n         |stmt| match &stmt.kind {\n             StmtKind::Local(_) => true,\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => is_relevant_expr(cx, typeck_results, expr),\n-            _ => false,\n+            StmtKind::Item(_) => false,\n         },\n     )\n }\n@@ -613,7 +613,7 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n                             }\n                         }\n                     },\n-                    _ => {},\n+                    MetaItemKind::NameValue(..) => {},\n                 }\n             }\n         }"}, {"sha": "14338ac8fafea9066e7b4d3e49634e945160e813", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -583,7 +583,7 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                                 let returns_nothing = match &sig.decl.output {\n                                     FnRetTy::Default(..) => true,\n                                     FnRetTy::Ty(ty) if ty.kind.is_unit() => true,\n-                                    _ => false,\n+                                    FnRetTy::Ty(_) => false,\n                                 };\n \n                                 if returns_nothing && !is_async && !block.stmts.is_empty() {"}, {"sha": "ea33a4d98fd2a2f7d74f2ece926aae691b47ba41", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -273,7 +273,7 @@ fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt<'_>) -\n             .init\n             .as_ref()\n             .map_or(StopEarly::KeepGoing, |expr| check_expr(vis, expr)),\n-        _ => StopEarly::KeepGoing,\n+        StmtKind::Item(..) => StopEarly::KeepGoing,\n     }\n }\n "}, {"sha": "f63a3761a0d16910a4cdbeaf9c1d9b693740f1de", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -78,7 +78,7 @@ fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     match stmt.kind {\n         StmtKind::Semi(ref e, ..) | StmtKind::Expr(ref e, ..) => Some(e),\n         StmtKind::Local(ref local) => local.init.as_deref(),\n-        _ => None,\n+        StmtKind::Item(..) => None,\n     }\n }\n "}, {"sha": "d43cb32ee513e061430e663d72f658a7cdce571c", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 156, "deletions": 89, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -8,21 +8,21 @@ use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, pe\n use clippy_utils::visitors::LocalUsedVisitor;\n use clippy_utils::{\n     get_parent_expr, in_macro, is_allowed, is_expn_of, is_refutable, is_wild, match_qpath, meets_msrv, path_to_local,\n-    path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, remove_blocks, strip_pat_refs,\n+    path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns, remove_blocks, strip_pat_refs,\n };\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n-use rustc_hir::def::CtorKind;\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::{\n-    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, HirId, Local, MatchSource, Mutability, Node, Pat,\n-    PatKind, QPath, RangeEnd,\n+    self as hir, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, HirId, Local, MatchSource,\n+    Mutability, Node, Pat, PatKind, PathSegment, QPath, RangeEnd, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_middle::ty::{self, Ty, TyS, VariantDef};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n@@ -956,114 +956,181 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n     }\n }\n \n-fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    let ty = cx.typeck_results().expr_ty(ex);\n-    if !ty.is_enum() {\n-        // If there isn't a nice closed set of possible values that can be conveniently enumerated,\n-        // don't complain about not enumerating the mall.\n-        return;\n+enum CommonPrefixSearcher<'a> {\n+    None,\n+    Path(&'a [PathSegment<'a>]),\n+    Mixed,\n+}\n+impl CommonPrefixSearcher<'a> {\n+    fn with_path(&mut self, path: &'a [PathSegment<'a>]) {\n+        match path {\n+            [path @ .., _] => self.with_prefix(path),\n+            [] => (),\n+        }\n     }\n \n+    fn with_prefix(&mut self, path: &'a [PathSegment<'a>]) {\n+        match self {\n+            Self::None => *self = Self::Path(path),\n+            Self::Path(self_path)\n+                if path\n+                    .iter()\n+                    .map(|p| p.ident.name)\n+                    .eq(self_path.iter().map(|p| p.ident.name)) => {},\n+            Self::Path(_) => *self = Self::Mixed,\n+            Self::Mixed => (),\n+        }\n+    }\n+}\n+\n+#[allow(clippy::too_many_lines)]\n+fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n+    let ty = cx.typeck_results().expr_ty(ex).peel_refs();\n+    let adt_def = match ty.kind() {\n+        ty::Adt(adt_def, _)\n+            if adt_def.is_enum()\n+                && !(is_type_diagnostic_item(cx, ty, sym::option_type)\n+                    || is_type_diagnostic_item(cx, ty, sym::result_type)) =>\n+        {\n+            adt_def\n+        },\n+        _ => return,\n+    };\n+\n     // First pass - check for violation, but don't do much book-keeping because this is hopefully\n     // the uncommon case, and the book-keeping is slightly expensive.\n     let mut wildcard_span = None;\n     let mut wildcard_ident = None;\n+    let mut has_non_wild = false;\n     for arm in arms {\n-        if let PatKind::Wild = arm.pat.kind {\n-            wildcard_span = Some(arm.pat.span);\n-        } else if let PatKind::Binding(_, _, ident, None) = arm.pat.kind {\n-            wildcard_span = Some(arm.pat.span);\n-            wildcard_ident = Some(ident);\n+        match peel_hir_pat_refs(arm.pat).0.kind {\n+            PatKind::Wild => wildcard_span = Some(arm.pat.span),\n+            PatKind::Binding(_, _, ident, None) => {\n+                wildcard_span = Some(arm.pat.span);\n+                wildcard_ident = Some(ident);\n+            },\n+            _ => has_non_wild = true,\n         }\n     }\n+    let wildcard_span = match wildcard_span {\n+        Some(x) if has_non_wild => x,\n+        _ => return,\n+    };\n \n-    if let Some(wildcard_span) = wildcard_span {\n-        // Accumulate the variants which should be put in place of the wildcard because they're not\n-        // already covered.\n+    // Accumulate the variants which should be put in place of the wildcard because they're not\n+    // already covered.\n+    let mut missing_variants: Vec<_> = adt_def.variants.iter().collect();\n \n-        let mut missing_variants = vec![];\n-        if let ty::Adt(def, _) = ty.kind() {\n-            for variant in &def.variants {\n-                missing_variants.push(variant);\n+    let mut path_prefix = CommonPrefixSearcher::None;\n+    for arm in arms {\n+        // Guards mean that this case probably isn't exhaustively covered. Technically\n+        // this is incorrect, as we should really check whether each variant is exhaustively\n+        // covered by the set of guards that cover it, but that's really hard to do.\n+        recurse_or_patterns(arm.pat, |pat| {\n+            let path = match &peel_hir_pat_refs(pat).0.kind {\n+                PatKind::Path(path) => {\n+                    #[allow(clippy::match_same_arms)]\n+                    let id = match cx.qpath_res(path, pat.hir_id) {\n+                        Res::Def(DefKind::Const | DefKind::ConstParam | DefKind::AnonConst, _) => return,\n+                        Res::Def(_, id) => id,\n+                        _ => return,\n+                    };\n+                    if arm.guard.is_none() {\n+                        missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                    }\n+                    path\n+                },\n+                PatKind::TupleStruct(path, patterns, ..) => {\n+                    if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p)) {\n+                        let id = cx.qpath_res(path, pat.hir_id).def_id();\n+                        missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                    }\n+                    path\n+                },\n+                PatKind::Struct(path, patterns, ..) => {\n+                    if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p.pat)) {\n+                        let id = cx.qpath_res(path, pat.hir_id).def_id();\n+                        missing_variants.retain(|e| e.def_id != id);\n+                    }\n+                    path\n+                },\n+                _ => return,\n+            };\n+            match path {\n+                QPath::Resolved(_, path) => path_prefix.with_path(path.segments),\n+                QPath::TypeRelative(\n+                    hir::Ty {\n+                        kind: TyKind::Path(QPath::Resolved(_, path)),\n+                        ..\n+                    },\n+                    _,\n+                ) => path_prefix.with_prefix(path.segments),\n+                _ => (),\n             }\n-        }\n+        });\n+    }\n \n-        for arm in arms {\n-            if arm.guard.is_some() {\n-                // Guards mean that this case probably isn't exhaustively covered. Technically\n-                // this is incorrect, as we should really check whether each variant is exhaustively\n-                // covered by the set of guards that cover it, but that's really hard to do.\n-                continue;\n-            }\n-            if let PatKind::Path(ref path) = arm.pat.kind {\n-                if let QPath::Resolved(_, p) = path {\n-                    missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n-                }\n-            } else if let PatKind::TupleStruct(QPath::Resolved(_, p), ref patterns, ..) = arm.pat.kind {\n-                // Some simple checks for exhaustive patterns.\n-                // There is a room for improvements to detect more cases,\n-                // but it can be more expensive to do so.\n-                let is_pattern_exhaustive =\n-                    |pat: &&Pat<'_>| matches!(pat.kind, PatKind::Wild | PatKind::Binding(.., None));\n-                if patterns.iter().all(is_pattern_exhaustive) {\n-                    missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n+    let format_suggestion = |variant: &VariantDef| {\n+        format!(\n+            \"{}{}{}{}\",\n+            if let Some(ident) = wildcard_ident {\n+                format!(\"{} @ \", ident.name)\n+            } else {\n+                String::new()\n+            },\n+            if let CommonPrefixSearcher::Path(path_prefix) = path_prefix {\n+                let mut s = String::new();\n+                for seg in path_prefix {\n+                    s.push_str(&seg.ident.as_str());\n+                    s.push_str(\"::\");\n                 }\n+                s\n+            } else {\n+                let mut s = cx.tcx.def_path_str(adt_def.did);\n+                s.push_str(\"::\");\n+                s\n+            },\n+            variant.ident.name,\n+            match variant.ctor_kind {\n+                CtorKind::Fn if variant.fields.len() == 1 => \"(_)\",\n+                CtorKind::Fn => \"(..)\",\n+                CtorKind::Const => \"\",\n+                CtorKind::Fictive => \"{ .. }\",\n             }\n-        }\n-\n-        let mut suggestion: Vec<String> = missing_variants\n-            .iter()\n-            .map(|v| {\n-                let suffix = match v.ctor_kind {\n-                    CtorKind::Fn => \"(..)\",\n-                    CtorKind::Const | CtorKind::Fictive => \"\",\n-                };\n-                let ident_str = if let Some(ident) = wildcard_ident {\n-                    format!(\"{} @ \", ident.name)\n-                } else {\n-                    String::new()\n-                };\n-                // This path assumes that the enum type is imported into scope.\n-                format!(\"{}{}{}\", ident_str, cx.tcx.def_path_str(v.def_id), suffix)\n-            })\n-            .collect();\n-\n-        if suggestion.is_empty() {\n-            return;\n-        }\n-\n-        let mut message = \"wildcard match will miss any future added variants\";\n+        )\n+    };\n \n-        if let ty::Adt(def, _) = ty.kind() {\n-            if def.is_variant_list_non_exhaustive() {\n-                message = \"match on non-exhaustive enum doesn't explicitly match all known variants\";\n-                suggestion.push(String::from(\"_\"));\n-            }\n-        }\n+    match missing_variants.as_slice() {\n+        [] => (),\n+        [x] if !adt_def.is_variant_list_non_exhaustive() => span_lint_and_sugg(\n+            cx,\n+            MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+            wildcard_span,\n+            \"wildcard matches only a single variant and will also match any future added variants\",\n+            \"try this\",\n+            format_suggestion(x),\n+            Applicability::MaybeIncorrect,\n+        ),\n+        variants => {\n+            let mut suggestions: Vec<_> = variants.iter().cloned().map(format_suggestion).collect();\n+            let message = if adt_def.is_variant_list_non_exhaustive() {\n+                suggestions.push(\"_\".into());\n+                \"wildcard matches known variants and will also match future added variants\"\n+            } else {\n+                \"wildcard match will also match any future added variants\"\n+            };\n \n-        if suggestion.len() == 1 {\n-            // No need to check for non-exhaustive enum as in that case len would be greater than 1\n             span_lint_and_sugg(\n                 cx,\n-                MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+                WILDCARD_ENUM_MATCH_ARM,\n                 wildcard_span,\n                 message,\n                 \"try this\",\n-                suggestion[0].clone(),\n+                suggestions.join(\" | \"),\n                 Applicability::MaybeIncorrect,\n             )\n-        };\n-\n-        span_lint_and_sugg(\n-            cx,\n-            WILDCARD_ENUM_MATCH_ARM,\n-            wildcard_span,\n-            message,\n-            \"try this\",\n-            suggestion.join(\" | \"),\n-            Applicability::MaybeIncorrect,\n-        )\n-    }\n+        },\n+    };\n }\n \n // If the block contains only a `panic!` macro (as expression or statement)"}, {"sha": "37678fac1d2147e97ef1c0c40809f5db6428a33b", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -556,7 +556,7 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n                     mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n                         self.possible_borrower.add(p.local, *dest);\n                     },\n-                    _ => (),\n+                    mir::Operand::Constant(..) => (),\n                 }\n             }\n         }\n@@ -578,7 +578,7 @@ fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n \n     let mut visit_op = |op: &mir::Operand<'_>| match op {\n         mir::Operand::Copy(p) | mir::Operand::Move(p) => visit(p.local),\n-        _ => (),\n+        mir::Operand::Constant(..) => (),\n     };\n \n     match rvalue {"}, {"sha": "10c93c6ad06b0c57460c1942d775bb8c25e27b4e", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -276,7 +276,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n         match item.kind {\n             TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => self.check_ty(cx, ty, false),\n             TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, &sig.decl),\n-            _ => (),\n+            TraitItemKind::Type(..) => (),\n         }\n     }\n \n@@ -452,15 +452,15 @@ impl<'tcx> LateLintPass<'tcx> for TypeComplexity {\n             TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => self.check_type(cx, ty),\n             TraitItemKind::Fn(FnSig { ref decl, .. }, TraitFn::Required(_)) => self.check_fndecl(cx, decl),\n             // methods with default impl are covered by check_fn\n-            _ => (),\n+            TraitItemKind::Type(..) | TraitItemKind::Fn(_, TraitFn::Provided(_)) => (),\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         match item.kind {\n             ImplItemKind::Const(ref ty, _) | ImplItemKind::TyAlias(ref ty) => self.check_type(cx, ty),\n             // methods are covered by check_fn\n-            _ => (),\n+            ImplItemKind::Fn(..) => (),\n         }\n     }\n "}, {"sha": "c2be457e9dcf96066544102f1e6620c47466d3a2", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n                 }\n             },\n             FnKind::Closure => return,\n-            _ => (),\n+            FnKind::Method(..) => (),\n         }\n \n         // Abort if the method is implementing a trait or of it a trait method."}, {"sha": "7ee4f140d1ee2bcf3472b03398374deaf1aad008", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -977,6 +977,16 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n     }\n }\n \n+/// If the pattern is an `or` pattern, call the function once for each sub pattern. Otherwise, call\n+/// the function once on the given pattern.\n+pub fn recurse_or_patterns<'tcx, F: FnMut(&'tcx Pat<'tcx>)>(pat: &'tcx Pat<'tcx>, mut f: F) {\n+    if let PatKind::Or(pats) = pat.kind {\n+        pats.iter().cloned().for_each(f)\n+    } else {\n+        f(pat)\n+    }\n+}\n+\n /// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n /// implementations have.\n pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {"}, {"sha": "d99f9af3faf5b73df4884fb0296c882683787502", "filename": "tests/ui/match_wildcard_for_single_variants.fixed", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -15,6 +15,16 @@ enum Color {\n     Blue,\n     Rgb(u8, u8, u8),\n }\n+impl Color {\n+    fn f(self) {\n+        match self {\n+            Self::Red => (),\n+            Self::Green => (),\n+            Self::Blue => (),\n+            Self::Rgb(..) => (),\n+        };\n+    }\n+}\n \n fn main() {\n     let f = Foo::A;\n@@ -56,4 +66,46 @@ fn main() {\n         Color::Rgb(255, _, _) => {},\n         _ => {},\n     }\n+\n+    // References shouldn't change anything\n+    match &color {\n+        &Color::Red => (),\n+        Color::Green => (),\n+        &Color::Rgb(..) => (),\n+        Color::Blue => (),\n+    }\n+\n+    use self::Color as C;\n+\n+    match color {\n+        C::Red => (),\n+        C::Green => (),\n+        C::Rgb(..) => (),\n+        C::Blue => (),\n+    }\n+\n+    match color {\n+        C::Red => (),\n+        Color::Green => (),\n+        Color::Rgb(..) => (),\n+        Color::Blue => (),\n+    }\n+\n+    match Some(0) {\n+        Some(0) => 0,\n+        Some(_) => 1,\n+        _ => 2,\n+    };\n+\n+    #[non_exhaustive]\n+    enum Bar {\n+        A,\n+        B,\n+        C,\n+    }\n+    match Bar::A {\n+        Bar::A => (),\n+        Bar::B => (),\n+        _ => (),\n+    };\n }"}, {"sha": "1752a95de4b2cca9ec06caa7cbe9558086187b5b", "filename": "tests/ui/match_wildcard_for_single_variants.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/tests%2Fui%2Fmatch_wildcard_for_single_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/tests%2Fui%2Fmatch_wildcard_for_single_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wildcard_for_single_variants.rs?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -15,6 +15,16 @@ enum Color {\n     Blue,\n     Rgb(u8, u8, u8),\n }\n+impl Color {\n+    fn f(self) {\n+        match self {\n+            Self::Red => (),\n+            Self::Green => (),\n+            Self::Blue => (),\n+            _ => (),\n+        };\n+    }\n+}\n \n fn main() {\n     let f = Foo::A;\n@@ -56,4 +66,46 @@ fn main() {\n         Color::Rgb(255, _, _) => {},\n         _ => {},\n     }\n+\n+    // References shouldn't change anything\n+    match &color {\n+        &Color::Red => (),\n+        Color::Green => (),\n+        &Color::Rgb(..) => (),\n+        &_ => (),\n+    }\n+\n+    use self::Color as C;\n+\n+    match color {\n+        C::Red => (),\n+        C::Green => (),\n+        C::Rgb(..) => (),\n+        _ => (),\n+    }\n+\n+    match color {\n+        C::Red => (),\n+        Color::Green => (),\n+        Color::Rgb(..) => (),\n+        _ => (),\n+    }\n+\n+    match Some(0) {\n+        Some(0) => 0,\n+        Some(_) => 1,\n+        _ => 2,\n+    };\n+\n+    #[non_exhaustive]\n+    enum Bar {\n+        A,\n+        B,\n+        C,\n+    }\n+    match Bar::A {\n+        Bar::A => (),\n+        Bar::B => (),\n+        _ => (),\n+    };\n }"}, {"sha": "34538dea8e5f437e836daa4e8aa4bf2dc8074ffd", "filename": "tests/ui/match_wildcard_for_single_variants.stderr", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/tests%2Fui%2Fmatch_wildcard_for_single_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/tests%2Fui%2Fmatch_wildcard_for_single_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wildcard_for_single_variants.stderr?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -1,28 +1,52 @@\n-error: wildcard match will miss any future added variants\n-  --> $DIR/match_wildcard_for_single_variants.rs:24:9\n+error: wildcard matches only a single variant and will also match any future added variants\n+  --> $DIR/match_wildcard_for_single_variants.rs:24:13\n    |\n-LL |         _ => {},\n-   |         ^ help: try this: `Foo::C`\n+LL |             _ => (),\n+   |             ^ help: try this: `Self::Rgb(..)`\n    |\n    = note: `-D clippy::match-wildcard-for-single-variants` implied by `-D warnings`\n \n-error: wildcard match will miss any future added variants\n+error: wildcard matches only a single variant and will also match any future added variants\n   --> $DIR/match_wildcard_for_single_variants.rs:34:9\n    |\n+LL |         _ => {},\n+   |         ^ help: try this: `Foo::C`\n+\n+error: wildcard matches only a single variant and will also match any future added variants\n+  --> $DIR/match_wildcard_for_single_variants.rs:44:9\n+   |\n LL |         _ => {},\n    |         ^ help: try this: `Color::Blue`\n \n-error: wildcard match will miss any future added variants\n-  --> $DIR/match_wildcard_for_single_variants.rs:42:9\n+error: wildcard matches only a single variant and will also match any future added variants\n+  --> $DIR/match_wildcard_for_single_variants.rs:52:9\n    |\n LL |         _ => {},\n    |         ^ help: try this: `Color::Blue`\n \n-error: wildcard match will miss any future added variants\n-  --> $DIR/match_wildcard_for_single_variants.rs:48:9\n+error: wildcard matches only a single variant and will also match any future added variants\n+  --> $DIR/match_wildcard_for_single_variants.rs:58:9\n    |\n LL |         _ => {},\n    |         ^ help: try this: `Color::Blue`\n \n-error: aborting due to 4 previous errors\n+error: wildcard matches only a single variant and will also match any future added variants\n+  --> $DIR/match_wildcard_for_single_variants.rs:75:9\n+   |\n+LL |         &_ => (),\n+   |         ^^ help: try this: `Color::Blue`\n+\n+error: wildcard matches only a single variant and will also match any future added variants\n+  --> $DIR/match_wildcard_for_single_variants.rs:84:9\n+   |\n+LL |         _ => (),\n+   |         ^ help: try this: `C::Blue`\n+\n+error: wildcard matches only a single variant and will also match any future added variants\n+  --> $DIR/match_wildcard_for_single_variants.rs:91:9\n+   |\n+LL |         _ => (),\n+   |         ^ help: try this: `Color::Blue`\n+\n+error: aborting due to 8 previous errors\n "}, {"sha": "fd754e4c794f63416a1a496649eec7ff7e5d4126", "filename": "tests/ui/wildcard_enum_match_arm.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/tests%2Fui%2Fwildcard_enum_match_arm.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/tests%2Fui%2Fwildcard_enum_match_arm.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.fixed?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -77,7 +77,7 @@ fn main() {\n     let error_kind = ErrorKind::NotFound;\n     match error_kind {\n         ErrorKind::NotFound => {},\n-        std::io::ErrorKind::PermissionDenied | std::io::ErrorKind::ConnectionRefused | std::io::ErrorKind::ConnectionReset | std::io::ErrorKind::ConnectionAborted | std::io::ErrorKind::NotConnected | std::io::ErrorKind::AddrInUse | std::io::ErrorKind::AddrNotAvailable | std::io::ErrorKind::BrokenPipe | std::io::ErrorKind::AlreadyExists | std::io::ErrorKind::WouldBlock | std::io::ErrorKind::InvalidInput | std::io::ErrorKind::InvalidData | std::io::ErrorKind::TimedOut | std::io::ErrorKind::WriteZero | std::io::ErrorKind::Interrupted | std::io::ErrorKind::Other | std::io::ErrorKind::UnexpectedEof | _ => {},\n+        ErrorKind::PermissionDenied | ErrorKind::ConnectionRefused | ErrorKind::ConnectionReset | ErrorKind::ConnectionAborted | ErrorKind::NotConnected | ErrorKind::AddrInUse | ErrorKind::AddrNotAvailable | ErrorKind::BrokenPipe | ErrorKind::AlreadyExists | ErrorKind::WouldBlock | ErrorKind::InvalidInput | ErrorKind::InvalidData | ErrorKind::TimedOut | ErrorKind::WriteZero | ErrorKind::Interrupted | ErrorKind::Other | ErrorKind::UnexpectedEof | _ => {},\n     }\n     match error_kind {\n         ErrorKind::NotFound => {},"}, {"sha": "a513a62c748d6a7a683e70c9721ff93289f6b59c", "filename": "tests/ui/wildcard_enum_match_arm.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4d686196b9281fa474ae41934ac367702e586687/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d686196b9281fa474ae41934ac367702e586687/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.stderr?ref=4d686196b9281fa474ae41934ac367702e586687", "patch": "@@ -1,4 +1,4 @@\n-error: wildcard match will miss any future added variants\n+error: wildcard match will also match any future added variants\n   --> $DIR/wildcard_enum_match_arm.rs:39:9\n    |\n LL |         _ => eprintln!(\"Not red\"),\n@@ -10,29 +10,29 @@ note: the lint level is defined here\n LL | #![deny(clippy::wildcard_enum_match_arm)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: wildcard match will miss any future added variants\n+error: wildcard match will also match any future added variants\n   --> $DIR/wildcard_enum_match_arm.rs:43:9\n    |\n LL |         _not_red => eprintln!(\"Not red\"),\n    |         ^^^^^^^^ help: try this: `_not_red @ Color::Green | _not_red @ Color::Blue | _not_red @ Color::Rgb(..) | _not_red @ Color::Cyan`\n \n-error: wildcard match will miss any future added variants\n+error: wildcard match will also match any future added variants\n   --> $DIR/wildcard_enum_match_arm.rs:47:9\n    |\n LL |         not_red => format!(\"{:?}\", not_red),\n    |         ^^^^^^^ help: try this: `not_red @ Color::Green | not_red @ Color::Blue | not_red @ Color::Rgb(..) | not_red @ Color::Cyan`\n \n-error: wildcard match will miss any future added variants\n+error: wildcard match will also match any future added variants\n   --> $DIR/wildcard_enum_match_arm.rs:63:9\n    |\n LL |         _ => \"No red\",\n    |         ^ help: try this: `Color::Red | Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan`\n \n-error: match on non-exhaustive enum doesn't explicitly match all known variants\n+error: wildcard matches known variants and will also match future added variants\n   --> $DIR/wildcard_enum_match_arm.rs:80:9\n    |\n LL |         _ => {},\n-   |         ^ help: try this: `std::io::ErrorKind::PermissionDenied | std::io::ErrorKind::ConnectionRefused | std::io::ErrorKind::ConnectionReset | std::io::ErrorKind::ConnectionAborted | std::io::ErrorKind::NotConnected | std::io::ErrorKind::AddrInUse | std::io::ErrorKind::AddrNotAvailable | std::io::ErrorKind::BrokenPipe | std::io::ErrorKind::AlreadyExists | std::io::ErrorKind::WouldBlock | std::io::ErrorKind::InvalidInput | std::io::ErrorKind::InvalidData | std::io::ErrorKind::TimedOut | std::io::ErrorKind::WriteZero | std::io::ErrorKind::Interrupted | std::io::ErrorKind::Other | std::io::ErrorKind::UnexpectedEof | _`\n+   |         ^ help: try this: `ErrorKind::PermissionDenied | ErrorKind::ConnectionRefused | ErrorKind::ConnectionReset | ErrorKind::ConnectionAborted | ErrorKind::NotConnected | ErrorKind::AddrInUse | ErrorKind::AddrNotAvailable | ErrorKind::BrokenPipe | ErrorKind::AlreadyExists | ErrorKind::WouldBlock | ErrorKind::InvalidInput | ErrorKind::InvalidData | ErrorKind::TimedOut | ErrorKind::WriteZero | ErrorKind::Interrupted | ErrorKind::Other | ErrorKind::UnexpectedEof | _`\n \n error: aborting due to 5 previous errors\n "}]}