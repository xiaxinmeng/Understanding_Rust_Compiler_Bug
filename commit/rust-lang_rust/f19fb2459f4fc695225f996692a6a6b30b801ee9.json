{"sha": "f19fb2459f4fc695225f996692a6a6b30b801ee9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxOWZiMjQ1OWY0ZmM2OTUyMjVmOTk2NjkyYTZhNmIzMGI4MDFlZTk=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-03T02:13:00Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-03T14:46:50Z"}, "message": "Remove standalone comparison functions in vec, make the trait impls better.", "tree": {"sha": "b6bd30b5b071b88c8f394210f10e6f347ccf9bf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6bd30b5b071b88c8f394210f10e6f347ccf9bf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f19fb2459f4fc695225f996692a6a6b30b801ee9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f19fb2459f4fc695225f996692a6a6b30b801ee9", "html_url": "https://github.com/rust-lang/rust/commit/f19fb2459f4fc695225f996692a6a6b30b801ee9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f19fb2459f4fc695225f996692a6a6b30b801ee9/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "920780258999aa4a2669a594464cda780798d35f", "url": "https://api.github.com/repos/rust-lang/rust/commits/920780258999aa4a2669a594464cda780798d35f", "html_url": "https://github.com/rust-lang/rust/commit/920780258999aa4a2669a594464cda780798d35f"}], "stats": {"total": 360, "additions": 169, "deletions": 191}, "files": [{"sha": "8e493fd5396f90dd2716d7273eb5e9e3670d189d", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -601,9 +601,8 @@ fn make_run_args(config: &config, _props: &TestProps, testfile: &Path) ->\n    ProcArgs {\n     // If we've got another tool to run under (valgrind),\n     // then split apart its command\n-    let toolargs = split_maybe_args(&config.runtool);\n-\n-    let mut args = toolargs + [make_exe_name(config, testfile).to_str()];\n+    let mut args = split_maybe_args(&config.runtool);\n+    args.push(make_exe_name(config, testfile).to_str());\n     let prog = args.shift();\n     return ProcArgs {prog: prog, args: args};\n }"}, {"sha": "0f2d44f57e34c457762a38ec3160cded370aca3e", "filename": "src/libextra/crypto/sha1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -240,7 +240,6 @@ impl Digest for Sha1 {\n \n #[cfg(test)]\n mod tests {\n-    use std::vec;\n \n     use digest::{Digest, DigestUtil};\n     use sha1::Sha1;\n@@ -337,7 +336,7 @@ mod tests {\n         for tests.iter().advance |t| {\n             (*sh).input_str(t.input);\n             sh.result(out);\n-            assert!(vec::eq(t.output, out));\n+            assert!(t.output.as_slice() == out);\n \n             let out_str = (*sh).result_str();\n             assert_eq!(out_str.len(), 40);\n@@ -357,7 +356,7 @@ mod tests {\n                 left = left - take;\n             }\n             sh.result(out);\n-            assert!(vec::eq(t.output, out));\n+            assert!(t.output.as_slice() == out);\n \n             let out_str = (*sh).result_str();\n             assert_eq!(out_str.len(), 40);"}, {"sha": "de0a988f94c8ee68e02db4914787215e4b240cfd", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -55,7 +55,6 @@ use std::io;\n use std::comm::GenericChan;\n use std::comm::GenericPort;\n use std::sys::size_of;\n-use std::vec;\n \n /**\n A FlatPort, consisting of a `BytePort` that receives byte vectors,\n@@ -274,7 +273,7 @@ impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n             }\n         };\n \n-        if vec::eq(command, CONTINUE) {\n+        if CONTINUE.as_slice() == command {\n             let msg_len = match self.byte_port.try_recv(size_of::<u64>()) {\n                 Some(bytes) => {\n                     io::u64_from_be_bytes(bytes, 0, size_of::<u64>())\n@@ -931,7 +930,7 @@ mod test {\n         fn test_try_recv_none3<P:BytePort>(loader: PortLoader<P>) {\n             static CONTINUE: [u8, ..4] = [0xAA, 0xBB, 0xCC, 0xDD];\n             // The control word is followed by garbage\n-            let bytes = CONTINUE.to_owned() + [0];\n+            let bytes = CONTINUE.to_owned() + &[0u8];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n             assert!(res.is_none());\n@@ -955,7 +954,7 @@ mod test {\n                     1, sys::size_of::<u64>()) |len_bytes| {\n                     len_bytes.to_owned()\n                 };\n-                let bytes = CONTINUE.to_owned() + len_bytes + [0, 0, 0, 0];\n+                let bytes = CONTINUE.to_owned() + len_bytes + &[0u8, 0, 0, 0];\n \n                 let port = loader(bytes);\n "}, {"sha": "a0b95924e09dc46009514365cc421ac36009feb6", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -207,7 +207,7 @@ impl Add<BigUint, BigUint> for BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n         let mut carry = 0;\n-        let sum = do vec::from_fn(new_len) |i| {\n+        let mut sum = do vec::from_fn(new_len) |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n             let (hi, lo) = BigDigit::from_uint(\n@@ -216,8 +216,8 @@ impl Add<BigUint, BigUint> for BigUint {\n             carry = hi;\n             lo\n         };\n-        if carry == 0 { return BigUint::new(sum) };\n-        return BigUint::new(sum + [carry]);\n+        if carry != 0 { sum.push(carry); }\n+        return BigUint::new(sum);\n     }\n }\n \n@@ -284,15 +284,15 @@ impl Mul<BigUint, BigUint> for BigUint {\n             if n == 1 { return copy *a; }\n \n             let mut carry = 0;\n-            let prod = do a.data.iter().transform |ai| {\n+            let mut prod = do a.data.iter().transform |ai| {\n                 let (hi, lo) = BigDigit::from_uint(\n                     (*ai as uint) * (n as uint) + (carry as uint)\n                 );\n                 carry = hi;\n                 lo\n             }.collect::<~[BigDigit]>();\n-            if carry == 0 { return BigUint::new(prod) };\n-            return BigUint::new(prod + [carry]);\n+            if carry != 0 { prod.push(carry); }\n+            return BigUint::new(prod);\n         }\n \n \n@@ -621,15 +621,15 @@ impl BigUint {\n         if n_bits == 0 || self.is_zero() { return copy *self; }\n \n         let mut carry = 0;\n-        let shifted = do self.data.iter().transform |elem| {\n+        let mut shifted = do self.data.iter().transform |elem| {\n             let (hi, lo) = BigDigit::from_uint(\n                 (*elem as uint) << n_bits | (carry as uint)\n             );\n             carry = hi;\n             lo\n         }.collect::<~[BigDigit]>();\n-        if carry == 0 { return BigUint::new(shifted); }\n-        return BigUint::new(shifted + [carry]);\n+        if carry != 0 { shifted.push(carry); }\n+        return BigUint::new(shifted);\n     }\n \n "}, {"sha": "4755f7629511e84d6eab8773f5c023b5cc1c8070", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -131,13 +131,13 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n-            let ftys = do fields.map |field| {\n+            let mut ftys = do fields.map |field| {\n                 ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n             };\n             let packed = ty::lookup_packed(cx.tcx, def_id);\n             let dtor = ty::ty_dtor(cx.tcx, def_id).has_drop_flag();\n-            let ftys =\n-                if dtor { ftys + [ty::mk_bool()] } else { ftys };\n+            if dtor { ftys.push(ty::mk_bool()); }\n+\n             return Univariant(mk_struct(cx, ftys, packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n@@ -263,7 +263,7 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n             let padding = largest_size - most_aligned.size;\n \n             struct_llfields(cx, most_aligned, sizing)\n-                + [Type::array(&Type::i8(), padding)]\n+                + &[Type::array(&Type::i8(), padding)]\n         }\n     }\n }\n@@ -512,7 +512,7 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: int,\n             let discr_ty = C_int(ccx, discr);\n             let contents = build_const_struct(ccx, case,\n                                               ~[discr_ty] + vals);\n-            C_struct(contents + [padding(max_sz - case.size)])\n+            C_struct(contents + &[padding(max_sz - case.size)])\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             if discr == nndiscr {"}, {"sha": "0a3b6d881e47c6d0d4e0acc08caa9956caf53894", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -113,7 +113,7 @@ fn shim_types(ccx: @mut CrateContext, id: ast::node_id) -> ShimTypes {\n         _ => ccx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig);\n-    let bundle_ty = Type::struct_(llsig.llarg_tys + [llsig.llret_ty.ptr_to()], false);\n+    let bundle_ty = Type::struct_(llsig.llarg_tys + &[llsig.llret_ty.ptr_to()], false);\n     let ret_def = !ty::type_is_bot(fn_sig.output) &&\n                   !ty::type_is_nil(fn_sig.output);\n     let fn_ty = abi_info(ccx).compute_info(llsig.llarg_tys, llsig.llret_ty, ret_def);"}, {"sha": "04133bfe79acb4eeab54ad9893e27f8aaaa4d741", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -278,7 +278,7 @@ impl Reflector {\n             let opaqueptrty = ty::mk_ptr(ccx.tcx, ty::mt { ty: opaquety, mutbl: ast::m_imm });\n \n             let make_get_disr = || {\n-                let sub_path = bcx.fcx.path + [path_name(special_idents::anon)];\n+                let sub_path = bcx.fcx.path + &[path_name(special_idents::anon)];\n                 let sym = mangle_internal_name_by_path_and_seq(ccx,\n                                                                sub_path,\n                                                                \"get_disr\");"}, {"sha": "7878e17f7fc689f5d242ae6b81a468b4b39586b9", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -245,7 +245,7 @@ impl Type {\n     }\n \n     pub fn box(ctx: &CrateContext, ty: &Type) -> Type {\n-        Type::struct_(Type::box_header_fields(ctx) + [*ty], false)\n+        Type::struct_(Type::box_header_fields(ctx) + &[*ty], false)\n     }\n \n     pub fn opaque_box(ctx: &CrateContext) -> Type {"}, {"sha": "3fd6ad1699876346deb79da4c8d7530ae1956b71", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -141,7 +141,7 @@ fn first_sentence_(s: &str) -> ~str {\n pub fn paragraphs(s: &str) -> ~[~str] {\n     let mut whitespace_lines = 0;\n     let mut accum = ~\"\";\n-    let paras = do s.any_line_iter().fold(~[]) |paras, line| {\n+    let mut paras = do s.any_line_iter().fold(~[]) |paras, line| {\n         let mut res = paras;\n \n         if line.is_whitespace() {\n@@ -166,11 +166,8 @@ pub fn paragraphs(s: &str) -> ~[~str] {\n         res\n     };\n \n-    if !accum.is_empty() {\n-        paras + [accum]\n-    } else {\n-        paras\n-    }\n+    if !accum.is_empty() { paras.push(accum); }\n+    paras\n }\n \n #[cfg(test)]"}, {"sha": "f800a8ab946fe35e6e778b08c285f0a148f79740", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -172,7 +172,7 @@ pub fn header_kind(doc: doc::ItemTag) -> ~str {\n }\n \n pub fn header_name(doc: doc::ItemTag) -> ~str {\n-    let fullpath = (doc.path() + [doc.name()]).connect(\"::\");\n+    let fullpath = (doc.path() + &[doc.name()]).connect(\"::\");\n     match &doc {\n         &doc::ModTag(_) if doc.id() != syntax::ast::crate_node_id => {\n             fullpath"}, {"sha": "d757547d8f76f59332c1cf8464c388ec48f01dee", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -163,7 +163,7 @@ pub fn make_filename(\n             }\n           }\n           doc::ItemPage(doc) => {\n-            (doc.path() + [doc.name()]).connect(\"_\")\n+            (doc.path() + &[doc.name()]).connect(\"_\")\n           }\n         }\n     };"}, {"sha": "37a32d6b0f0081ba289b8e1aa0f6911a802e4af6", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -176,13 +176,14 @@ pub fn to_managed<T:Copy>(v: &[T]) -> @[T] {\n #[cfg(not(test))]\n pub mod traits {\n     use at_vec::append;\n+    use vec::Vector;\n     use kinds::Copy;\n     use ops::Add;\n \n-    impl<'self,T:Copy> Add<&'self [T],@[T]> for @[T] {\n+    impl<'self,T:Copy, V: Vector<T>> Add<V,@[T]> for @[T] {\n         #[inline]\n-        fn add(&self, rhs: & &'self [T]) -> @[T] {\n-            append(*self, (*rhs))\n+        fn add(&self, rhs: &V) -> @[T] {\n+            append(*self, rhs.as_slice())\n         }\n     }\n }\n@@ -312,7 +313,7 @@ mod test {\n \n     #[test]\n     fn append_test() {\n-        assert_eq!(@[1,2,3] + [4,5,6], @[1,2,3,4,5,6]);\n+        assert_eq!(@[1,2,3] + &[4,5,6], @[1,2,3,4,5,6]);\n     }\n \n     #[test]"}, {"sha": "db534cca971a58dc2a8ad867fff2de13b029f677", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -72,7 +72,7 @@ pub use tuple::{CloneableTuple10, CloneableTuple11, CloneableTuple12};\n pub use tuple::{ImmutableTuple2, ImmutableTuple3, ImmutableTuple4, ImmutableTuple5};\n pub use tuple::{ImmutableTuple6, ImmutableTuple7, ImmutableTuple8, ImmutableTuple9};\n pub use tuple::{ImmutableTuple10, ImmutableTuple11, ImmutableTuple12};\n-pub use vec::{VectorVector, CopyableVector, ImmutableVector};\n+pub use vec::{Vector, VectorVector, CopyableVector, ImmutableVector};\n pub use vec::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCopyableVector};\n pub use vec::{OwnedVector, OwnedCopyableVector,OwnedEqVector, MutableVector};\n pub use io::{Reader, ReaderUtil, Writer, WriterUtil};"}, {"sha": "b702a1c7281e2c5aa90dd266e661850ff0d3b4df", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 133, "deletions": 150, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -16,14 +16,13 @@ use cast::transmute;\n use cast;\n use container::{Container, Mutable};\n use cmp;\n-use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp::{Eq, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n use iterator::{FromIterator, Iterator, IteratorUtil};\n use kinds::Copy;\n use libc;\n use libc::c_void;\n use num::Zero;\n-use ops::Add;\n use option::{None, Option, Some};\n use ptr::to_unsafe_ptr;\n use ptr;\n@@ -40,8 +39,6 @@ use unstable::intrinsics::{get_tydesc, contains_managed};\n use vec;\n use util;\n \n-#[cfg(not(test))] use cmp::Equiv;\n-\n #[doc(hidden)]\n pub mod rustrt {\n     use libc;\n@@ -549,179 +546,165 @@ pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n \n // Equality\n \n-/// Tests whether two slices are equal to one another. This is only true if both\n-/// slices are of the same length, and each of the corresponding elements return\n-/// true when queried via the `eq` function.\n-fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n-    let (a_len, b_len) = (a.len(), b.len());\n-    if a_len != b_len { return false; }\n+#[cfg(not(test))]\n+pub mod traits {\n+    use super::Vector;\n+    use kinds::Copy;\n+    use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equal, Equiv};\n+    use ops::Add;\n \n-    let mut i = 0;\n-    while i < a_len {\n-        if a[i] != b[i] { return false; }\n-        i += 1;\n+    impl<'self,T:Eq> Eq for &'self [T] {\n+        fn eq(&self, other: & &'self [T]) -> bool {\n+            self.len() == other.len() &&\n+                self.iter().zip(other.iter()).all(|(s,o)| *s == *o)\n+        }\n+        #[inline]\n+        fn ne(&self, other: & &'self [T]) -> bool { !self.eq(other) }\n     }\n-    true\n-}\n-\n-/// Similar to the `vec::eq` function, but this is defined for types which\n-/// implement `TotalEq` as opposed to types which implement `Eq`. Equality\n-/// comparisons are done via the `equals` function instead of `eq`.\n-fn equals<T: TotalEq>(a: &[T], b: &[T]) -> bool {\n-    let (a_len, b_len) = (a.len(), b.len());\n-    if a_len != b_len { return false; }\n \n-    let mut i = 0;\n-    while i < a_len {\n-        if !a[i].equals(&b[i]) { return false; }\n-        i += 1;\n+    impl<T:Eq> Eq for ~[T] {\n+        #[inline]\n+        fn eq(&self, other: &~[T]) -> bool { self.as_slice() == *other }\n+        #[inline]\n+        fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n     }\n-    true\n-}\n-\n-#[cfg(not(test))]\n-impl<'self,T:Eq> Eq for &'self [T] {\n-    #[inline]\n-    fn eq(&self, other: & &'self [T]) -> bool { eq(*self, *other) }\n-    #[inline]\n-    fn ne(&self, other: & &'self [T]) -> bool { !self.eq(other) }\n-}\n \n-#[cfg(not(test))]\n-impl<T:Eq> Eq for ~[T] {\n-    #[inline]\n-    fn eq(&self, other: &~[T]) -> bool { eq(*self, *other) }\n-    #[inline]\n-    fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<T:Eq> Eq for @[T] {\n-    #[inline]\n-    fn eq(&self, other: &@[T]) -> bool { eq(*self, *other) }\n-    #[inline]\n-    fn ne(&self, other: &@[T]) -> bool { !self.eq(other) }\n-}\n+    impl<T:Eq> Eq for @[T] {\n+        #[inline]\n+        fn eq(&self, other: &@[T]) -> bool { self.as_slice() == *other }\n+        #[inline]\n+        fn ne(&self, other: &@[T]) -> bool { !self.eq(other) }\n+    }\n \n-#[cfg(not(test))]\n-impl<'self,T:TotalEq> TotalEq for &'self [T] {\n-    #[inline]\n-    fn equals(&self, other: & &'self [T]) -> bool { equals(*self, *other) }\n-}\n+    impl<'self,T:TotalEq> TotalEq for &'self [T] {\n+        fn equals(&self, other: & &'self [T]) -> bool {\n+            self.len() == other.len() &&\n+                self.iter().zip(other.iter()).all(|(s,o)| s.equals(o))\n+        }\n+    }\n \n-#[cfg(not(test))]\n-impl<T:TotalEq> TotalEq for ~[T] {\n-    #[inline]\n-    fn equals(&self, other: &~[T]) -> bool { equals(*self, *other) }\n-}\n+    impl<T:TotalEq> TotalEq for ~[T] {\n+        #[inline]\n+        fn equals(&self, other: &~[T]) -> bool { self.as_slice().equals(&other.as_slice()) }\n+    }\n \n-#[cfg(not(test))]\n-impl<T:TotalEq> TotalEq for @[T] {\n-    #[inline]\n-    fn equals(&self, other: &@[T]) -> bool { equals(*self, *other) }\n-}\n+    impl<T:TotalEq> TotalEq for @[T] {\n+        #[inline]\n+        fn equals(&self, other: &@[T]) -> bool { self.as_slice().equals(&other.as_slice()) }\n+    }\n \n-#[cfg(not(test))]\n-impl<'self,T:Eq> Equiv<~[T]> for &'self [T] {\n-    #[inline]\n-    fn equiv(&self, other: &~[T]) -> bool { eq(*self, *other) }\n-}\n+    impl<'self,T:Eq, V: Vector<T>> Equiv<V> for &'self [T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+    }\n \n-// Lexicographical comparison\n+    impl<'self,T:Eq, V: Vector<T>> Equiv<V> for ~[T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+    }\n \n-fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n-    let low = uint::min(a.len(), b.len());\n+    impl<'self,T:Eq, V: Vector<T>> Equiv<V> for @[T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+    }\n \n-    for uint::range(0, low) |idx| {\n-        match a[idx].cmp(&b[idx]) {\n-          Greater => return Greater,\n-          Less => return Less,\n-          Equal => ()\n+    impl<'self,T:TotalOrd> TotalOrd for &'self [T] {\n+        fn cmp(&self, other: & &'self [T]) -> Ordering {\n+            for self.iter().zip(other.iter()).advance |(s,o)| {\n+                match s.cmp(o) {\n+                    Equal => {},\n+                    non_eq => { return non_eq; }\n+                }\n+            }\n+            self.len().cmp(&other.len())\n         }\n     }\n \n-    a.len().cmp(&b.len())\n-}\n-\n-#[cfg(not(test))]\n-impl<'self,T:TotalOrd> TotalOrd for &'self [T] {\n-    #[inline]\n-    fn cmp(&self, other: & &'self [T]) -> Ordering { cmp(*self, *other) }\n-}\n+    impl<T: TotalOrd> TotalOrd for ~[T] {\n+        #[inline]\n+        fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n \n-#[cfg(not(test))]\n-impl<T: TotalOrd> TotalOrd for ~[T] {\n-    #[inline]\n-    fn cmp(&self, other: &~[T]) -> Ordering { cmp(*self, *other) }\n-}\n+    impl<T: TotalOrd> TotalOrd for @[T] {\n+        #[inline]\n+        fn cmp(&self, other: &@[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n \n-#[cfg(not(test))]\n-impl<T: TotalOrd> TotalOrd for @[T] {\n-    #[inline]\n-    fn cmp(&self, other: &@[T]) -> Ordering { cmp(*self, *other) }\n-}\n+    impl<'self,T:Ord> Ord for &'self [T] {\n+        fn lt(&self, other: & &'self [T]) -> bool {\n+            for self.iter().zip(other.iter()).advance |(s,o)| {\n+                if *s < *o { return true; }\n+                if *s > *o { return false; }\n+            }\n+            self.len() < other.len()\n+        }\n+        #[inline]\n+        fn le(&self, other: & &'self [T]) -> bool { !(*other < *self) }\n+        #[inline]\n+        fn ge(&self, other: & &'self [T]) -> bool { !(*self < *other) }\n+        #[inline]\n+        fn gt(&self, other: & &'self [T]) -> bool { *other < *self }\n+    }\n \n-fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n-    let (a_len, b_len) = (a.len(), b.len());\n-    let end = uint::min(a_len, b_len);\n+    impl<T:Ord> Ord for ~[T] {\n+        #[inline]\n+        fn lt(&self, other: &~[T]) -> bool { self.as_slice() < other.as_slice() }\n+        #[inline]\n+        fn le(&self, other: &~[T]) -> bool { self.as_slice() <= other.as_slice() }\n+        #[inline]\n+        fn ge(&self, other: &~[T]) -> bool { self.as_slice() >= other.as_slice() }\n+        #[inline]\n+        fn gt(&self, other: &~[T]) -> bool { self.as_slice() > other.as_slice() }\n+    }\n \n-    let mut i = 0;\n-    while i < end {\n-        let (c_a, c_b) = (&a[i], &b[i]);\n-        if *c_a < *c_b { return true; }\n-        if *c_a > *c_b { return false; }\n-        i += 1;\n+    impl<T:Ord> Ord for @[T] {\n+        #[inline]\n+        fn lt(&self, other: &@[T]) -> bool { self.as_slice() < other.as_slice() }\n+        #[inline]\n+        fn le(&self, other: &@[T]) -> bool { self.as_slice() <= other.as_slice() }\n+        #[inline]\n+        fn ge(&self, other: &@[T]) -> bool { self.as_slice() >= other.as_slice() }\n+        #[inline]\n+        fn gt(&self, other: &@[T]) -> bool { self.as_slice() > other.as_slice() }\n     }\n \n-    a_len < b_len\n+    impl<'self,T:Copy, V: Vector<T>> Add<V, ~[T]> for &'self [T] {\n+        #[inline]\n+        fn add(&self, rhs: &V) -> ~[T] {\n+            let mut res = self.to_owned();\n+            res.push_all(rhs.as_slice());\n+            res\n+        }\n+    }\n+    impl<T:Copy, V: Vector<T>> Add<V, ~[T]> for ~[T] {\n+        #[inline]\n+        fn add(&self, rhs: &V) -> ~[T] {\n+            let mut res = self.to_owned();\n+            res.push_all(rhs.as_slice());\n+            res\n+        }\n+    }\n }\n \n-fn le<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n-fn ge<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n-fn gt<T:Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n+#[cfg(test)]\n+pub mod traits {}\n \n-#[cfg(not(test))]\n-impl<'self,T:Ord> Ord for &'self [T] {\n-    #[inline]\n-    fn lt(&self, other: & &'self [T]) -> bool { lt((*self), (*other)) }\n-    #[inline]\n-    fn le(&self, other: & &'self [T]) -> bool { le((*self), (*other)) }\n-    #[inline]\n-    fn ge(&self, other: & &'self [T]) -> bool { ge((*self), (*other)) }\n-    #[inline]\n-    fn gt(&self, other: & &'self [T]) -> bool { gt((*self), (*other)) }\n+/// Any vector that can be represented as a slice.\n+pub trait Vector<T> {\n+    /// Work with `self` as a slice.\n+    fn as_slice<'a>(&'a self) -> &'a [T];\n }\n-\n-#[cfg(not(test))]\n-impl<T:Ord> Ord for ~[T] {\n-    #[inline]\n-    fn lt(&self, other: &~[T]) -> bool { lt((*self), (*other)) }\n-    #[inline]\n-    fn le(&self, other: &~[T]) -> bool { le((*self), (*other)) }\n-    #[inline]\n-    fn ge(&self, other: &~[T]) -> bool { ge((*self), (*other)) }\n-    #[inline]\n-    fn gt(&self, other: &~[T]) -> bool { gt((*self), (*other)) }\n+impl<'self,T> Vector<T> for &'self [T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n }\n-\n-#[cfg(not(test))]\n-impl<T:Ord> Ord for @[T] {\n-    #[inline]\n-    fn lt(&self, other: &@[T]) -> bool { lt((*self), (*other)) }\n-    #[inline]\n-    fn le(&self, other: &@[T]) -> bool { le((*self), (*other)) }\n-    #[inline]\n-    fn ge(&self, other: &@[T]) -> bool { ge((*self), (*other)) }\n-    #[inline]\n-    fn gt(&self, other: &@[T]) -> bool { gt((*self), (*other)) }\n+impl<T> Vector<T> for ~[T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n }\n-\n-#[cfg(not(test))]\n-impl<'self,T:Copy> Add<&'self [T], ~[T]> for ~[T] {\n-    #[inline]\n-    fn add(&self, rhs: & &'self [T]) -> ~[T] {\n-        append(copy *self, (*rhs))\n-    }\n+impl<T> Vector<T> for @[T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n }\n \n impl<'self, T> Container for &'self [T] {"}, {"sha": "abc44dfbc9bb71d9830338cf4b157bdda46ec34c", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19fb2459f4fc695225f996692a6a6b30b801ee9/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=f19fb2459f4fc695225f996692a6a6b30b801ee9", "patch": "@@ -96,7 +96,7 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n                 fn_box: || @Cons((), fn_box()),\n                 tuple: (@Cons((), st.tuple.first()),\n                         ~Cons((), @*st.tuple.second())),\n-                vec: st.vec + [@Cons((), *st.vec.last())],\n+                vec: st.vec + &[@Cons((), *st.vec.last())],\n                 res: r(@Cons((), st.res._l))\n             }\n           }"}]}