{"sha": "21064637ed8b8259d1305f21ace12c40b9561706", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMDY0NjM3ZWQ4YjgyNTlkMTMwNWYyMWFjZTEyYzQwYjk1NjE3MDY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-01T06:12:06Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-01T06:12:06Z"}, "message": "rt: Fix whitespace", "tree": {"sha": "c402d24572a9b4610930106d90358c1aeba2625a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c402d24572a9b4610930106d90358c1aeba2625a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21064637ed8b8259d1305f21ace12c40b9561706", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21064637ed8b8259d1305f21ace12c40b9561706", "html_url": "https://github.com/rust-lang/rust/commit/21064637ed8b8259d1305f21ace12c40b9561706", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21064637ed8b8259d1305f21ace12c40b9561706/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf0c4cd7d2918205c13df38c4a62f93e1c72c1ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf0c4cd7d2918205c13df38c4a62f93e1c72c1ac", "html_url": "https://github.com/rust-lang/rust/commit/cf0c4cd7d2918205c13df38c4a62f93e1c72c1ac"}], "stats": {"total": 208, "additions": 109, "deletions": 99}, "files": [{"sha": "4101e82cc40c942cd394ab57785d80d2f5f67c5c", "filename": "src/rt/arch/x86_64/context.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Farch%2Fx86_64%2Fcontext.h", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Farch%2Fx86_64%2Fcontext.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fcontext.h?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -31,11 +31,11 @@ struct registers_t {\n class context {\n public:\n     registers_t regs;\n-    \n+\n     context();\n-    \n+\n     context *next;\n-    \n+\n     void swap(context &out);\n     void call(void *f, void *arg, void *sp);\n };"}, {"sha": "68b4165edc68384d2f2b716313be39faa7b8fce7", "filename": "src/rt/memory_region.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Fmemory_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Fmemory_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.h?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -41,7 +41,6 @@ class memory_region {\n \n     inline alloc_header *get_header(void *mem);\n     inline void *get_data(alloc_header *);\n-    \n \n     rust_srv *_srv;\n     memory_region *_parent;"}, {"sha": "b5abfde0274e0374cf60067db02740bc0f285aac", "filename": "src/rt/rust_box_annihilator.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_box_annihilator.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_box_annihilator.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_box_annihilator.cpp?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -58,7 +58,8 @@ class annihilator : public shape::data<annihilator,shape::ptr> {\n     }\n \n     void walk_tag2(shape::tag_info &tinfo, uint32_t tag_variant) {\n-        shape::data<annihilator,shape::ptr>::walk_variant1(tinfo, tag_variant);\n+        shape::data<annihilator,shape::ptr>\n+          ::walk_variant1(tinfo, tag_variant);\n     }\n \n     void walk_uniq2() {\n@@ -83,7 +84,7 @@ class annihilator : public shape::data<annihilator,shape::ptr> {\n               if (pair.env) {\n                   // free closed over data:\n                   shape::data<annihilator,shape::ptr>::walk_fn_contents1();\n-                  \n+\n                   // now free the ptr:\n                   task->kernel->free(pair.env);\n               }"}, {"sha": "b0a1804d096be57d72f4a746c5ab67df16490625", "filename": "src/rt/rust_cc.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_cc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_cc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cc.cpp?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -210,11 +210,11 @@ irc::compute_ircs(rust_task *task, irc_map &ircs) {\n         type_desc *tydesc = box->td;\n         uint8_t *body = (uint8_t*) box_body(box);\n \n-        LOG(task, gc, \n+        LOG(task, gc,\n             \"determining internal ref counts: \"\n             \"box=%p tydesc=%p body=%p\",\n             box, tydesc, body);\n-        \n+\n         shape::arena arena;\n         shape::type_param *params =\n             shape::type_param::from_tydesc_and_data(tydesc, body, arena);\n@@ -425,7 +425,7 @@ void\n mark::do_mark(rust_task *task,\n               const std::vector<rust_opaque_box *> &roots,\n               std::set<rust_opaque_box *> &marked) {\n-    std::vector<rust_opaque_box *>::const_iterator \n+    std::vector<rust_opaque_box *>::const_iterator\n       begin(roots.begin()),\n       end(roots.end());\n     while (begin != end) {"}, {"sha": "9237e8b593c4a51109a52e7e7c675253ccd95acd", "filename": "src/rt/rust_env.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_env.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_env.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_env.cpp?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -84,10 +84,10 @@ static size_t\n get_max_stk_size() {\n     char *maxsz = getenv(RUST_MAX_STACK);\n     if (maxsz) {\n-\treturn strtol(maxsz, NULL, 0);\n+        return strtol(maxsz, NULL, 0);\n     }\n     else {\n-\treturn 1024*1024*8;\n+        return 1024*1024*8;\n     }\n }\n "}, {"sha": "896a4de660b37766d3a783ee0a83d48f1c1d36ab", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -67,7 +67,8 @@ rust_kernel::create_scheduler(size_t num_threads) {\n         sched = new (this, \"rust_scheduler\")\n             rust_scheduler(this, srv, num_threads, id);\n         bool is_new = sched_table\n-            .insert(std::pair<rust_sched_id, rust_scheduler*>(id, sched)).second;\n+            .insert(std::pair<rust_sched_id,\n+                              rust_scheduler*>(id, sched)).second;\n         A(this, is_new, \"Reusing a sched id?\");\n     }\n     sched->start_task_threads();"}, {"sha": "d958eac187c8976fc89a03f6ecbcd951e49e4088", "filename": "src/rt/rust_port_selector.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_port_selector.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_port_selector.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port_selector.cpp?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -50,10 +50,10 @@ rust_port_selector::select(rust_task *task, rust_port **dptr,\n         task->rendezvous_ptr = (uintptr_t*)dptr;\n         task->block(this, \"waiting for select rendezvous\");\n \n-\t// Blocking the task might fail if the task has already been\n-\t// killed, but in the event of both failure and success the\n-\t// task needs to yield. On success, it yields and waits to be\n-\t// unblocked. On failure it yields and is then fails the task.\n+        // Blocking the task might fail if the task has already been\n+        // killed, but in the event of both failure and success the\n+        // task needs to yield. On success, it yields and waits to be\n+        // unblocked. On failure it yields and is then fails the task.\n \n         *yield = true;\n     }"}, {"sha": "3bfc454aaf85c8c863d7097e3f866b9c358ee781", "filename": "src/rt/rust_port_selector.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_port_selector.h", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_port_selector.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port_selector.h?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -16,10 +16,10 @@ class rust_port_selector : public rust_cond {\n     rust_port_selector();\n \n     void select(rust_task *task,\n-\t\trust_port **dptr,\n-\t\trust_port **ports,\n-\t\tsize_t n_ports,\n-\t\tuintptr_t *yield);\n+                rust_port **dptr,\n+                rust_port **ports,\n+                size_t n_ports,\n+                uintptr_t *yield);\n \n     void msg_sent_on(rust_port *port);\n };"}, {"sha": "5ef266f890d46f921abb2fe76a9022497b6858d1", "filename": "src/rt/rust_scheduler.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -2,9 +2,9 @@\n #include \"rust_util.h\"\n \n rust_scheduler::rust_scheduler(rust_kernel *kernel,\n-\t\t\t       rust_srv *srv,\n-\t\t\t       size_t num_threads,\n-\t\t\t       rust_sched_id id) :\n+                               rust_srv *srv,\n+                               size_t num_threads,\n+                               rust_sched_id id) :\n     kernel(kernel),\n     srv(srv),\n     env(srv->env),\n@@ -107,8 +107,8 @@ rust_scheduler::release_task() {\n         }\n     }\n     if (need_exit) {\n-\t// There are no more tasks on this scheduler. Time to leave\n-\texit();\n+        // There are no more tasks on this scheduler. Time to leave\n+        exit();\n     }\n }\n "}, {"sha": "e75bafbe41d6e02cf72518ca2d95044e6c666ed1", "filename": "src/rt/rust_scheduler.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_scheduler.h", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_scheduler.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.h?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -33,7 +33,7 @@ class rust_scheduler : public kernel_owned<rust_scheduler> {\n \n public:\n     rust_scheduler(rust_kernel *kernel, rust_srv *srv, size_t num_threads,\n-\t\t   rust_sched_id id);\n+                   rust_sched_id id);\n     ~rust_scheduler();\n \n     void start_task_threads();"}, {"sha": "c361dd4d441bafd550755e5158ac52683d29c3ee", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -362,7 +362,8 @@ class cmp : public data<cmp,ptr_pair> {\n     void walk_fn2(char) { return cmp_two_pointers(); }\n     void walk_obj2()    { return cmp_two_pointers(); }\n \n-    void walk_tag2(tag_info &tinfo, const data_pair<tag_variant_t> &tag_variants);\n+    void walk_tag2(tag_info &tinfo,\n+                   const data_pair<tag_variant_t> &tag_variants);\n     void walk_struct2(const uint8_t *end_sp);\n     void walk_res2(const rust_fn *dtor, uint16_t n_ty_params,\n                    const type_param *ty_params_sp, const uint8_t *end_sp,\n@@ -400,7 +401,8 @@ cmp::walk_vec2(bool is_pod, const std::pair<ptr_pair,ptr_pair> &data_range) {\n }\n \n void\n-cmp::walk_tag2(tag_info &tinfo, const data_pair<tag_variant_t> &tag_variants) {\n+cmp::walk_tag2(tag_info &tinfo,\n+               const data_pair<tag_variant_t> &tag_variants) {\n     cmp_number(tag_variants);\n     if (result != 0)\n         return;\n@@ -548,8 +550,8 @@ log::walk_res2(const rust_fn *dtor, unsigned n_params,\n \n extern \"C\" void\n shape_cmp_type(int8_t *result, const type_desc *tydesc,\n-\t       const type_desc **subtydescs, uint8_t *data_0,\n-\t       uint8_t *data_1, uint8_t cmp_type) {\n+               const type_desc **subtydescs, uint8_t *data_0,\n+               uint8_t *data_1, uint8_t cmp_type) {\n     rust_task *task = rust_task_thread::get_task();\n     shape::arena arena;\n "}, {"sha": "ad3841b54432c449006e4fa6155e32162c021d99", "filename": "src/rt/rust_shape.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -395,7 +395,7 @@ ctxt<T>::get_variant_sp(tag_info &tinfo, tag_variant_t variant_id) {\n     const uint8_t *variant_ptr = tables->tags + variant_offset;\n     uint16_t variant_len = get_u16_bump(variant_ptr);\n     const uint8_t *variant_end = variant_ptr + variant_len;\n-    \n+\n     return std::make_pair(variant_ptr, variant_end);\n }\n \n@@ -936,7 +936,7 @@ class data : public ctxt< data<T,U> > {\n     }\n \n     template<typename WN>\n-    void walk_number1() { \n+    void walk_number1() {\n         //DATA_SIMPLE(W, walk_number2<W>());\n         ALIGN_TO(rust_alignof<WN>());\n         U end_dp = dp + sizeof(WN);\n@@ -1158,7 +1158,8 @@ class log : public data<log,ptr> {\n                        variant_ptr_and_end);\n     void walk_string2(const std::pair<ptr,ptr> &data);\n     void walk_res2(const rust_fn *dtor, unsigned n_params,\n-                   const type_param *params, const uint8_t *end_sp, bool live);\n+                   const type_param *params, const uint8_t *end_sp,\n+                   bool live);\n \n     template<typename T>\n     inline void walk_number2() {"}, {"sha": "adcf7e4b4bab91690a0de5f3c6103dc27b252b7e", "filename": "src/rt/rust_stack.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_stack.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_stack.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_stack.cpp?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -22,7 +22,7 @@ reuse_valgrind_stack(stk_seg *stk, uint8_t *sp) {\n     // old stack segments, since the act of popping the stack previously\n     // caused valgrind to consider the whole thing inaccessible.\n     assert(sp >= stk->data && sp <= (uint8_t*) stk->end\n-\t   && \"Stack pointer must be inside stack segment\");\n+           && \"Stack pointer must be inside stack segment\");\n     size_t sz = stk->end - (uintptr_t)sp;\n     (void) VALGRIND_MAKE_MEM_UNDEFINED(sp, sz);\n     (void) sz;"}, {"sha": "83a357f9e19bab4006c96b2a53ceb8a4770b2aa0", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -44,7 +44,8 @@ rust_task::rust_task(rust_task_thread *thread, rust_task_state state,\n     supervisor(spawner)\n {\n     LOGPTR(thread, \"new task\", (uintptr_t)this);\n-    DLOG(thread, task, \"sizeof(task) = %d (0x%x)\", sizeof *this, sizeof *this);\n+    DLOG(thread, task, \"sizeof(task) = %d (0x%x)\",\n+         sizeof *this, sizeof *this);\n \n     new_stack(init_stack_sz);\n     if (supervisor) {\n@@ -136,7 +137,7 @@ void task_start_wrapper(spawn_args *a)\n \n     bool threw_exception = false;\n     try {\n-        // The first argument is the return pointer; as the task fn \n+        // The first argument is the return pointer; as the task fn\n         // must have void return type, we can safely pass 0.\n         a->f(0, a->envptr, a->argptr);\n     } catch (rust_task *ex) {\n@@ -400,7 +401,8 @@ rust_task::wakeup(rust_cond *from) {\n     A(thread, cond != NULL, \"Cannot wake up unblocked task.\");\n     LOG(this, task, \"Blocked on 0x%\" PRIxPTR \" woken up on 0x%\" PRIxPTR,\n                         (uintptr_t) cond, (uintptr_t) from);\n-    A(thread, cond == from, \"Cannot wake up blocked task on wrong condition.\");\n+    A(thread, cond == from,\n+      \"Cannot wake up blocked task on wrong condition.\");\n \n     transition(task_state_blocked, task_state_running, NULL, \"none\");\n }"}, {"sha": "6a192c2c7cdc7d91f3b20b7df468359931725792", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -252,7 +252,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     void prev_stack();\n     void record_stack_limit();\n     void reset_stack_limit();\n-    \n+\n     bool on_rust_stack();\n     void check_stack_canary();\n     void delete_all_stacks();"}, {"sha": "62644d077fa5e48bdd739e0959c11e8fe5fdf992", "filename": "src/rt/rust_task_thread.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_task_thread.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_task_thread.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_thread.cpp?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -176,8 +176,8 @@ rust_task_thread::log_state() {\n     if (!blocked_tasks.is_empty()) {\n         log(NULL, log_debug, \"blocked tasks:\");\n         for (size_t i = 0; i < blocked_tasks.length(); i++) {\n-            log(NULL, log_debug, \"\\t task: %s @0x%\" PRIxPTR \", blocked on: 0x%\"\n-                PRIxPTR \" '%s'\",\n+            log(NULL, log_debug, \"\\t task: %s @0x%\" PRIxPTR\n+                \", blocked on: 0x%\" PRIxPTR \" '%s'\",\n                 blocked_tasks[i]->name, blocked_tasks[i],\n                 blocked_tasks[i]->get_cond(),\n                 blocked_tasks[i]->get_cond_name());\n@@ -300,7 +300,7 @@ rust_task_thread::state_name(rust_task_state state) {\n     }\n }\n \n-void \n+void\n rust_task_thread::transition(rust_task *task,\n                              rust_task_state src, rust_task_state dst,\n                              rust_cond *cond, const char* cond_name) {"}, {"sha": "b5fc36c4dde0c35ab393ab3879a2c9cccc3915a8", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -118,7 +118,7 @@ extern \"C\" CDECL void\n upcall_s_fail(s_fail_args *args) {\n     rust_task *task = rust_task_thread::get_task();\n     LOG_UPCALL_ENTRY(task);\n-    LOG_ERR(task, upcall, \"upcall fail '%s', %s:%\" PRIdPTR, \n+    LOG_ERR(task, upcall, \"upcall fail '%s', %s:%\" PRIdPTR,\n             args->expr, args->file, args->line);\n     task->fail();\n }\n@@ -416,7 +416,8 @@ extern \"C\" void\n upcall_cmp_type(int8_t *result, const type_desc *tydesc,\n                 const type_desc **subtydescs, uint8_t *data_0,\n                 uint8_t *data_1, uint8_t cmp_type) {\n-    s_cmp_type_args args = {result, tydesc, subtydescs, data_0, data_1, cmp_type};\n+    s_cmp_type_args args = {result, tydesc, subtydescs,\n+                            data_0, data_1, cmp_type};\n     UPCALL_SWITCH_STACK(&args, upcall_s_cmp_type);\n }\n "}, {"sha": "2c4eb8cd1745b8490b6b04b862af51b2d9c24b5b", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -95,7 +95,8 @@ vec_data(rust_vec *v) {\n \n inline void reserve_vec_exact(rust_task* task, rust_vec** vpp, size_t size) {\n     if (size > (*vpp)->alloc) {\n-        *vpp = (rust_vec*)task->kernel->realloc(*vpp, size + sizeof(rust_vec));\n+        *vpp = (rust_vec*)task->kernel\n+            ->realloc(*vpp, size + sizeof(rust_vec));\n         (*vpp)->alloc = size;\n     }\n }\n@@ -107,7 +108,8 @@ inline void reserve_vec(rust_task* task, rust_vec** vpp, size_t size) {\n typedef rust_vec rust_str;\n \n inline rust_str *\n-make_str(rust_kernel* kernel, const char* c, size_t strlen, const char* name) {\n+make_str(rust_kernel* kernel, const char* c, size_t strlen,\n+         const char* name) {\n     size_t str_fill = strlen + 1;\n     size_t str_alloc = str_fill;\n     rust_str *str = (rust_str *)"}, {"sha": "af5877460908e61cb2d1035bb56d89c8ec6693ad", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -3,18 +3,18 @@\n \n // crust fn pointers\n typedef void (*crust_async_op_cb)(uv_loop_t* loop, void* data,\n-\t\t\t\t\t\t\t\t  uv_async_t* op_handle);\n+                                  uv_async_t* op_handle);\n typedef void (*crust_simple_cb)(uint8_t* id_buf, void* loop_data);\n typedef void (*crust_close_cb)(uint8_t* id_buf, void* handle,\n-\t\t\t\t\t\t\t  void* data);\n+                                                          void* data);\n \n // data types\n #define RUST_UV_HANDLE_LEN 16\n \n struct handle_data {\n-\tuint8_t id_buf[RUST_UV_HANDLE_LEN];\n-\tcrust_simple_cb cb;\n-\tcrust_close_cb close_cb;\n+        uint8_t id_buf[RUST_UV_HANDLE_LEN];\n+        crust_simple_cb cb;\n+        crust_close_cb close_cb;\n };\n \n // helpers\n@@ -31,40 +31,40 @@ current_kernel_free(void* ptr) {\n \n static handle_data*\n new_handle_data_from(uint8_t* buf, crust_simple_cb cb) {\n-\thandle_data* data = (handle_data*)current_kernel_malloc(\n-\t\tsizeof(handle_data),\n-\t\t\"handle_data\");\n-\tmemcpy(data->id_buf, buf, RUST_UV_HANDLE_LEN);\n-\tdata->cb = cb;\n-\treturn data;\n+        handle_data* data = (handle_data*)current_kernel_malloc(\n+                sizeof(handle_data),\n+                \"handle_data\");\n+        memcpy(data->id_buf, buf, RUST_UV_HANDLE_LEN);\n+        data->cb = cb;\n+        return data;\n }\n \n // libuv callback impls\n static void\n native_crust_async_op_cb(uv_async_t* handle, int status) {\n     crust_async_op_cb cb = (crust_async_op_cb)handle->data;\n-\tvoid* loop_data = handle->loop->data;\n-\tcb(handle->loop, loop_data, handle);\n+        void* loop_data = handle->loop->data;\n+        cb(handle->loop, loop_data, handle);\n }\n \n static void\n native_async_cb(uv_async_t* handle, int status) {\n-\thandle_data* handle_d = (handle_data*)handle->data;\n-\tvoid* loop_data = handle->loop->data;\n-\thandle_d->cb(handle_d->id_buf, loop_data);\n+        handle_data* handle_d = (handle_data*)handle->data;\n+        void* loop_data = handle->loop->data;\n+        handle_d->cb(handle_d->id_buf, loop_data);\n }\n \n static void\n native_timer_cb(uv_timer_t* handle, int status) {\n-\thandle_data* handle_d = (handle_data*)handle->data;\n-\tvoid* loop_data = handle->loop->data;\n-\thandle_d->cb(handle_d->id_buf, loop_data);\n+        handle_data* handle_d = (handle_data*)handle->data;\n+        void* loop_data = handle->loop->data;\n+        handle_d->cb(handle_d->id_buf, loop_data);\n }\n \n static void\n native_close_cb(uv_handle_t* handle) {\n-\thandle_data* data = (handle_data*)handle->data;\n-\tdata->close_cb(data->id_buf, handle, handle->loop->data);\n+        handle_data* data = (handle_data*)handle->data;\n+        data->close_cb(data->id_buf, handle, handle->loop->data);\n }\n \n static void\n@@ -91,15 +91,15 @@ rust_uv_loop_set_data(uv_loop_t* loop, void* data) {\n \n extern \"C\" void*\n rust_uv_bind_op_cb(uv_loop_t* loop, crust_async_op_cb cb) {\n-\tuv_async_t* async = (uv_async_t*)current_kernel_malloc(\n-\t\tsizeof(uv_async_t),\n-\t\t\"uv_async_t\");\n-\tuv_async_init(loop, async, native_crust_async_op_cb);\n-\tasync->data = (void*)cb;\n-\t// decrement the ref count, so that our async bind\n-\t// doesn't count towards keeping the loop alive\n-\t//uv_unref(loop);\n-\treturn async;\n+        uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n+                sizeof(uv_async_t),\n+                \"uv_async_t\");\n+        uv_async_init(loop, async, native_crust_async_op_cb);\n+        async->data = (void*)cb;\n+        // decrement the ref count, so that our async bind\n+        // doesn't count towards keeping the loop alive\n+        //uv_unref(loop);\n+        return async;\n }\n \n extern \"C\" void\n@@ -109,14 +109,14 @@ rust_uv_stop_op_cb(uv_handle_t* op_handle) {\n \n extern \"C\" void\n rust_uv_run(uv_loop_t* loop) {\n-\tuv_run(loop);\n+        uv_run(loop);\n }\n \n extern \"C\" void\n rust_uv_close(uv_handle_t* handle, crust_close_cb cb) {\n-\thandle_data* data = (handle_data*)handle->data;\n-\tdata->close_cb = cb;\n-\tuv_close(handle, native_close_cb);\n+        handle_data* data = (handle_data*)handle->data;\n+        data->close_cb = cb;\n+        uv_close(handle, native_close_cb);\n }\n \n extern \"C\" void\n@@ -138,38 +138,38 @@ rust_uv_async_send(uv_async_t* handle) {\n \n extern \"C\" void*\n rust_uv_async_init(uv_loop_t* loop, crust_simple_cb cb,\n-\t\t\t\t\t\t uint8_t* buf) {\n-\tuv_async_t* async = (uv_async_t*)current_kernel_malloc(\n-\t\tsizeof(uv_async_t),\n-\t\t\"uv_async_t\");\n-\tuv_async_init(loop, async, native_async_cb);\n-\thandle_data* data = new_handle_data_from(buf, cb);\n-\tasync->data = data;\n+                                                 uint8_t* buf) {\n+        uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n+                sizeof(uv_async_t),\n+                \"uv_async_t\");\n+        uv_async_init(loop, async, native_async_cb);\n+        handle_data* data = new_handle_data_from(buf, cb);\n+        async->data = data;\n \n-\treturn async;\n+        return async;\n }\n \n extern \"C\" void*\n rust_uv_timer_init(uv_loop_t* loop, crust_simple_cb cb,\n-\t\t\t\t\t\t uint8_t* buf) {\n-\tuv_timer_t* new_timer = (uv_timer_t*)current_kernel_malloc(\n-\t\tsizeof(uv_timer_t),\n-\t\t\"uv_timer_t\");\n-\tuv_timer_init(loop, new_timer);\n-\thandle_data* data = new_handle_data_from(buf, cb);\n-\tnew_timer->data = data;\n+                                                 uint8_t* buf) {\n+        uv_timer_t* new_timer = (uv_timer_t*)current_kernel_malloc(\n+                sizeof(uv_timer_t),\n+                \"uv_timer_t\");\n+        uv_timer_init(loop, new_timer);\n+        handle_data* data = new_handle_data_from(buf, cb);\n+        new_timer->data = data;\n \n-\treturn new_timer;\n+        return new_timer;\n }\n \n extern \"C\" void\n rust_uv_timer_start(uv_timer_t* the_timer, uint32_t timeout,\n-\t\t\t\t\t\t  uint32_t repeat) {\n-\tuv_timer_start(the_timer, native_timer_cb, timeout, repeat);\n+                                                  uint32_t repeat) {\n+        uv_timer_start(the_timer, native_timer_cb, timeout, repeat);\n }\n \n extern \"C\" void\n rust_uv_timer_stop(uv_timer_t* the_timer) {\n-  uv_timer_stop(the_timer); \n+  uv_timer_stop(the_timer);\n }\n "}, {"sha": "0e904ae99bb858377d04012adbbb47c07bb4aca4", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/21064637ed8b8259d1305f21ace12c40b9561706/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=21064637ed8b8259d1305f21ace12c40b9561706", "patch": "@@ -25,7 +25,8 @@ lock_and_signal::lock_and_signal()\n     // TODO? Consider checking GetProcAddress(\"InitializeCriticalSectionEx\")\n     // so Windows >= Vista we can use CRITICAL_SECTION_NO_DEBUG_INFO to avoid\n     // allocating CRITICAL_SECTION debug info that is never released. See:\n-    // http://stackoverflow.com/questions/804848/critical-sections-leaking-memory-on-vista-win2008#889853\n+    // http://stackoverflow.com/questions/804848/\n+    //        critical-sections-leaking-memory-on-vista-win2008#889853\n }\n \n #else"}]}