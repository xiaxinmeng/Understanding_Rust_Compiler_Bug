{"sha": "1b3fda4978b691b2601ed862efae2798a82ef957", "node_id": "C_kwDOAAsO6NoAKDFiM2ZkYTQ5NzhiNjkxYjI2MDFlZDg2MmVmYWUyNzk4YTgyZWY5NTc", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2023-03-27T12:42:56Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2023-03-27T12:53:48Z"}, "message": "Use span of placeholders in format_args!() expansion.", "tree": {"sha": "230daf6f4b59b4a7da5136d285a5512693e7771f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/230daf6f4b59b4a7da5136d285a5512693e7771f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b3fda4978b691b2601ed862efae2798a82ef957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b3fda4978b691b2601ed862efae2798a82ef957", "html_url": "https://github.com/rust-lang/rust/commit/1b3fda4978b691b2601ed862efae2798a82ef957", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b3fda4978b691b2601ed862efae2798a82ef957/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309", "html_url": "https://github.com/rust-lang/rust/commit/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309"}], "stats": {"total": 66, "additions": 43, "deletions": 23}, "files": [{"sha": "c41bdc440935c9969508db9a95a378e44574205a", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 43, "deletions": 23, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1b3fda4978b691b2601ed862efae2798a82ef957/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b3fda4978b691b2601ed862efae2798a82ef957/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=1b3fda4978b691b2601ed862efae2798a82ef957", "patch": "@@ -2,7 +2,7 @@ use super::LoweringContext;\n use rustc_ast as ast;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::*;\n-use rustc_data_structures::fx::FxIndexSet;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_span::{\n     sym,\n@@ -238,7 +238,7 @@ fn make_count<'hir>(\n     ctx: &mut LoweringContext<'_, 'hir>,\n     sp: Span,\n     count: &Option<FormatCount>,\n-    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+    argmap: &mut FxIndexMap<(usize, ArgumentType), Option<Span>>,\n ) -> hir::Expr<'hir> {\n     match count {\n         Some(FormatCount::Literal(n)) => {\n@@ -252,7 +252,7 @@ fn make_count<'hir>(\n         }\n         Some(FormatCount::Argument(arg)) => {\n             if let Ok(arg_index) = arg.index {\n-                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize));\n+                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize), arg.span);\n                 let count_param = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n                     sp,\n                     hir::LangItem::FormatCount,\n@@ -291,12 +291,14 @@ fn make_format_spec<'hir>(\n     ctx: &mut LoweringContext<'_, 'hir>,\n     sp: Span,\n     placeholder: &FormatPlaceholder,\n-    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+    argmap: &mut FxIndexMap<(usize, ArgumentType), Option<Span>>,\n ) -> hir::Expr<'hir> {\n     let position = match placeholder.argument.index {\n         Ok(arg_index) => {\n-            let (i, _) =\n-                argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n+            let (i, _) = argmap.insert_full(\n+                (arg_index, ArgumentType::Format(placeholder.format_trait)),\n+                placeholder.span,\n+            );\n             ctx.expr_usize(sp, i)\n         }\n         Err(_) => ctx.expr(\n@@ -386,15 +388,18 @@ fn expand_format_args<'hir>(\n \n     // Create a list of all _unique_ (argument, format trait) combinations.\n     // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n-    let mut argmap = FxIndexSet::default();\n+    let mut argmap = FxIndexMap::default();\n     for piece in &fmt.template {\n         let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n         if placeholder.format_options != Default::default() {\n             // Can't use basic form if there's any formatting options.\n             use_format_options = true;\n         }\n         if let Ok(index) = placeholder.argument.index {\n-            if !argmap.insert((index, ArgumentType::Format(placeholder.format_trait))) {\n+            if argmap\n+                .insert((index, ArgumentType::Format(placeholder.format_trait)), placeholder.span)\n+                .is_some()\n+            {\n                 // Duplicate (argument, format trait) combination,\n                 // which we'll only put once in the args array.\n                 use_format_options = true;\n@@ -438,7 +443,7 @@ fn expand_format_args<'hir>(\n     // This is an optimization, speeding up compilation about 1-2% in some cases.\n     // See https://github.com/rust-lang/rust/pull/106770#issuecomment-1380790609\n     let use_simple_array = argmap.len() == arguments.len()\n-        && argmap.iter().enumerate().all(|(i, &(j, _))| i == j)\n+        && argmap.iter().enumerate().all(|(i, (&(j, _), _))| i == j)\n         && arguments.iter().skip(1).all(|arg| !may_contain_yield_point(&arg.expr));\n \n     let args = if use_simple_array {\n@@ -452,14 +457,19 @@ fn expand_format_args<'hir>(\n         let elements: Vec<_> = arguments\n             .iter()\n             .zip(argmap)\n-            .map(|(arg, (_, ty))| {\n-                let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+            .map(|(arg, ((_, ty), placeholder_span))| {\n+                let placeholder_span =\n+                    placeholder_span.unwrap_or(arg.expr.span).with_ctxt(macsp.ctxt());\n+                let arg_span = match arg.kind {\n+                    FormatArgumentKind::Captured(_) => placeholder_span,\n+                    _ => arg.expr.span.with_ctxt(macsp.ctxt()),\n+                };\n                 let arg = ctx.lower_expr(&arg.expr);\n                 let ref_arg = ctx.arena.alloc(ctx.expr(\n-                    sp,\n+                    arg_span,\n                     hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, arg),\n                 ));\n-                make_argument(ctx, sp, ref_arg, ty)\n+                make_argument(ctx, placeholder_span, ref_arg, ty)\n             })\n             .collect();\n         ctx.expr_array_ref(macsp, ctx.arena.alloc_from_iter(elements))\n@@ -475,16 +485,26 @@ fn expand_format_args<'hir>(\n         //     }\n         let args_ident = Ident::new(sym::args, macsp);\n         let (args_pat, args_hir_id) = ctx.pat_ident(macsp, args_ident);\n-        let args = ctx.arena.alloc_from_iter(argmap.iter().map(|&(arg_index, ty)| {\n-            let arg = &arguments[arg_index];\n-            let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n-            let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n-            let arg = ctx.arena.alloc(ctx.expr(\n-                sp,\n-                hir::ExprKind::Field(args_ident_expr, Ident::new(sym::integer(arg_index), macsp)),\n-            ));\n-            make_argument(ctx, sp, arg, ty)\n-        }));\n+        let args = ctx.arena.alloc_from_iter(argmap.iter().map(\n+            |(&(arg_index, ty), &placeholder_span)| {\n+                let arg = &arguments[arg_index];\n+                let placeholder_span =\n+                    placeholder_span.unwrap_or(arg.expr.span).with_ctxt(macsp.ctxt());\n+                let arg_span = match arg.kind {\n+                    FormatArgumentKind::Captured(_) => placeholder_span,\n+                    _ => arg.expr.span.with_ctxt(macsp.ctxt()),\n+                };\n+                let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n+                let arg = ctx.arena.alloc(ctx.expr(\n+                    arg_span,\n+                    hir::ExprKind::Field(\n+                        args_ident_expr,\n+                        Ident::new(sym::integer(arg_index), macsp),\n+                    ),\n+                ));\n+                make_argument(ctx, placeholder_span, arg, ty)\n+            },\n+        ));\n         let elements: Vec<_> = arguments\n             .iter()\n             .map(|arg| {"}]}