{"sha": "9f492fefef8d9a75f6dc27c834561fe977ca70c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNDkyZmVmZWY4ZDlhNzVmNmRjMjdjODM0NTYxZmU5NzdjYTcwYzU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-07T16:10:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-13T01:25:21Z"}, "message": "Switch to using predicates to drive checking. Correct various tests --\nin most cases, just the error message changed, but in some cases we\nare reporting new errors that OUGHT to have been reported before but\nwe're overlooked (mostly involving the `'static` bound on `Send`).", "tree": {"sha": "bfeccff865c113ad6667fbe809a1cb57a91d1e51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfeccff865c113ad6667fbe809a1cb57a91d1e51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f492fefef8d9a75f6dc27c834561fe977ca70c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f492fefef8d9a75f6dc27c834561fe977ca70c5", "html_url": "https://github.com/rust-lang/rust/commit/9f492fefef8d9a75f6dc27c834561fe977ca70c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f492fefef8d9a75f6dc27c834561fe977ca70c5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2be6c4f1ca6726068ceb70e7fb5369f2c1a42bb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2be6c4f1ca6726068ceb70e7fb5369f2c1a42bb0", "html_url": "https://github.com/rust-lang/rust/commit/2be6c4f1ca6726068ceb70e7fb5369f2c1a42bb0"}], "stats": {"total": 1932, "additions": 1063, "deletions": 869}, "files": [{"sha": "2b92ae8af0ab2d3d29ed2b73dbf47812038b495e", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -19,7 +19,7 @@\n \n /// Types able to be transferred across task boundaries.\n #[lang=\"send\"]\n-pub trait Send for Sized? {\n+pub trait Send for Sized? : 'static {\n     // empty.\n }\n "}, {"sha": "99e7966b66f684556a2119b8cbe3010cbe4ce38b", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -251,3 +251,7 @@ pub const tag_type_param_def: uint = 0xa5;\n \n pub const tag_item_generics: uint = 0xa6;\n pub const tag_method_ty_generics: uint = 0xa7;\n+\n+pub const tag_predicate: uint = 0xa8;\n+pub const tag_predicate_space: uint = 0xa9;\n+pub const tag_predicate_data: uint = 0xb0;"}, {"sha": "898f5d2ef93ca2b4c8540d173ec69b271eab271a", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -23,7 +23,8 @@ use metadata::csearch;\n use metadata::cstore;\n use metadata::tydecode::{parse_ty_data, parse_region_data, parse_def_id,\n                          parse_type_param_def_data, parse_bounds_data,\n-                         parse_bare_fn_ty_data, parse_trait_ref_data};\n+                         parse_bare_fn_ty_data, parse_trait_ref_data,\n+                         parse_predicate_data};\n use middle::def;\n use middle::lang_items;\n use middle::resolve::{TraitItemKind, TypeTraitItemKind};\n@@ -1437,7 +1438,18 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n         true\n     });\n \n-    let predicates = subst::VecPerParamSpace::empty(); // TODO fix in later commit\n+    let mut predicates = subst::VecPerParamSpace::empty();\n+    reader::tagged_docs(doc, tag_predicate, |predicate_doc| {\n+        let space_doc = reader::get_doc(predicate_doc, tag_predicate_space);\n+        let space = subst::ParamSpace::from_uint(reader::doc_as_u8(space_doc) as uint);\n+\n+        let data_doc = reader::get_doc(predicate_doc, tag_predicate_data);\n+        let data = parse_predicate_data(data_doc.data, data_doc.start, cdata.cnum, tcx,\n+                                        |_, did| translate_def_id(cdata, did));\n+\n+        predicates.push(space, data);\n+        true\n+    });\n \n     ty::Generics { types: types, regions: regions, predicates: predicates }\n }"}, {"sha": "48d1284f507873d8f911945caa8a4e3328893abf", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -803,6 +803,18 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n     }\n \n+    for (space, _, predicate) in generics.predicates.iter_enumerated() {\n+        rbml_w.start_tag(tag_predicate);\n+\n+        rbml_w.wr_tagged_u8(tag_predicate_space, space as u8);\n+\n+        rbml_w.start_tag(tag_predicate_data);\n+        tyencode::enc_predicate(rbml_w.writer, ty_str_ctxt, predicate);\n+        rbml_w.end_tag();\n+\n+        rbml_w.end_tag();\n+    }\n+\n     rbml_w.end_tag();\n }\n "}, {"sha": "37d790df37f46aaeb75cd9d5848e38bd677eb5c7", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -470,7 +470,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n         st.tcx.rcache.borrow_mut().insert(key, tt);\n         return tt;\n       }\n-      '\"' => {\n+      '\\\"' => {\n         let _ = parse_def(st, TypeWithId, |x,y| conv(x,y));\n         let inner = parse_ty(st, |x,y| conv(x,y));\n         inner\n@@ -646,6 +646,33 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     ast::DefId { krate: crate_num, node: def_num }\n }\n \n+pub fn parse_predicate_data<'tcx>(data: &[u8],\n+                                  start: uint,\n+                                  crate_num: ast::CrateNum,\n+                                  tcx: &ty::ctxt<'tcx>,\n+                                  conv: conv_did)\n+                                  -> ty::Predicate<'tcx>\n+{\n+    let mut st = parse_state_from_data(data, crate_num, start, tcx);\n+    parse_predicate(&mut st, conv)\n+}\n+\n+pub fn parse_predicate<'a,'tcx>(st: &mut PState<'a, 'tcx>,\n+                                conv: conv_did)\n+                                -> ty::Predicate<'tcx>\n+{\n+    match next(st) {\n+        't' => ty::Predicate::Trait(Rc::new(parse_trait_ref(st, conv))),\n+        'e' => ty::Predicate::Equate(parse_ty(st, |x,y| conv(x,y)),\n+                                     parse_ty(st, |x,y| conv(x,y))),\n+        'r' => ty::Predicate::RegionOutlives(parse_region(st, |x,y| conv(x,y)),\n+                                             parse_region(st, |x,y| conv(x,y))),\n+        'o' => ty::Predicate::TypeOutlives(parse_ty(st, |x,y| conv(x,y)),\n+                                           parse_region(st, |x,y| conv(x,y))),\n+        c => panic!(\"Encountered invalid character in metadata: {}\", c)\n+    }\n+}\n+\n pub fn parse_type_param_def_data<'tcx>(data: &[u8], start: uint,\n                                        crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n                                        conv: conv_did) -> ty::TypeParameterDef<'tcx>"}, {"sha": "5c7d15e16018b8ffd3bbb92e42909a74e8111c69", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -413,3 +413,30 @@ pub fn enc_type_param_def<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tc\n     enc_bounds(w, cx, &v.bounds);\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n }\n+\n+pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n+                               cx: &ctxt<'a, 'tcx>,\n+                               p: &ty::Predicate<'tcx>)\n+{\n+    match *p {\n+        ty::Predicate::Trait(ref trait_ref) => {\n+            mywrite!(w, \"t\");\n+            enc_trait_ref(w, cx, &**trait_ref);\n+        }\n+        ty::Predicate::Equate(a, b) => {\n+            mywrite!(w, \"e\");\n+            enc_ty(w, cx, a);\n+            enc_ty(w, cx, b);\n+        }\n+        ty::Predicate::RegionOutlives(a, b) => {\n+            mywrite!(w, \"r\");\n+            enc_region(w, cx, a);\n+            enc_region(w, cx, b);\n+        }\n+        ty::Predicate::TypeOutlives(a, b) => {\n+            mywrite!(w, \"o\");\n+            enc_ty(w, cx, a);\n+            enc_region(w, cx, b);\n+        }\n+    }\n+}"}, {"sha": "5a53979d719324edccf24940d1c0241717d9ce4f", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -31,6 +31,7 @@ use middle::infer;\n use middle::traits;\n use middle::mem_categorization as mc;\n use middle::expr_use_visitor as euv;\n+use util::common::ErrorReported;\n use util::nodemap::NodeSet;\n \n use syntax::ast;\n@@ -119,15 +120,17 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         let ty = ty::node_id_to_type(self.tcx, e.id);\n         let infcx = infer::new_infer_ctxt(self.tcx);\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n-        let cause = traits::ObligationCause::dummy();\n-        let obligation = traits::obligation_for_builtin_bound(self.tcx, cause, ty,\n-                                                              ty::BoundSync);\n-        fulfill_cx.register_obligation(self.tcx, obligation.unwrap());\n-        let env = ty::empty_parameter_environment();\n-        let result = fulfill_cx.select_all_or_error(&infcx, &env, self.tcx).is_ok();\n-        if !result {\n-            self.tcx.sess.span_err(e.span, \"shared static items must have a \\\n-                                            type which implements Sync\");\n+        match traits::trait_ref_for_builtin_bound(self.tcx, ty::BoundSync, ty) {\n+            Ok(trait_ref) => {\n+                fulfill_cx.register_trait_ref(self.tcx, trait_ref,\n+                                              traits::ObligationCause::dummy());\n+                let env = ty::empty_parameter_environment();\n+                if !fulfill_cx.select_all_or_error(&infcx, &env, self.tcx).is_ok() {\n+                    self.tcx.sess.span_err(e.span, \"shared static items must have a \\\n+                                                    type which implements Sync\");\n+                }\n+            }\n+            Err(ErrorReported) => { }\n         }\n     }\n }"}, {"sha": "9d9c3e238d40723e33d1d078fdf690d218e68e4a", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 160, "deletions": 82, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -10,22 +10,26 @@\n \n use middle::mem_categorization::Typer;\n use middle::ty::{mod, Ty};\n-use middle::infer::{mod, InferCtxt, ures};\n+use middle::infer::{mod, InferCtxt};\n use std::collections::HashSet;\n use std::collections::hash_map::{Occupied, Vacant};\n use std::default::Default;\n use std::rc::Rc;\n use syntax::ast;\n+use util::common::ErrorReported;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n use super::CodeAmbiguity;\n+use super::CodeSelectionError;\n+use super::FulfillmentError;\n use super::Obligation;\n use super::ObligationCause;\n-use super::TraitObligation;\n-use super::FulfillmentError;\n-use super::CodeSelectionError;\n+use super::PredicateObligation;\n+use super::Selection;\n use super::select::SelectionContext;\n+use super::trait_ref_for_builtin_bound;\n+use super::Unimplemented;\n \n /// The fulfillment context is used to drive trait resolution.  It\n /// consists of a list of obligations that must be (eventually)\n@@ -43,11 +47,11 @@ pub struct FulfillmentContext<'tcx> {\n     // than the `SelectionCache`: it avoids duplicate errors and\n     // permits recursive obligations, which are often generated from\n     // traits like `Send` et al.\n-    duplicate_set: HashSet<Rc<ty::TraitRef<'tcx>>>,\n+    duplicate_set: HashSet<ty::Predicate<'tcx>>,\n \n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n-    trait_obligations: Vec<TraitObligation<'tcx>>,\n+    predicates: Vec<PredicateObligation<'tcx>>,\n \n     // Remembers the count of trait obligations that we have already\n     // attempted to select. This is used to avoid repeating work\n@@ -91,63 +95,61 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             duplicate_set: HashSet::new(),\n-            trait_obligations: Vec::new(),\n+            predicates: Vec::new(),\n             attempted_mark: 0,\n             region_obligations: NodeMap::new(),\n         }\n     }\n \n-    pub fn register_predicate<'a>(&mut self,\n-                                  infcx: &InferCtxt<'a,'tcx>,\n-                                  predicate: &Obligation<'tcx, ty::Predicate<'tcx>>)\n-                                  -> ures<'tcx>\n+    pub fn register_builtin_bound(&mut self,\n+                                  tcx: &ty::ctxt<'tcx>,\n+                                  ty: Ty<'tcx>,\n+                                  builtin_bound: ty::BuiltinBound,\n+                                  cause: ObligationCause<'tcx>)\n     {\n-        match predicate.trait_ref {\n-            ty::Predicate::Trait(ref trait_ref) => {\n-                let trait_obligation = Obligation { cause: predicate.cause,\n-                                                    recursion_depth: predicate.recursion_depth,\n-                                                    trait_ref: (*trait_ref).clone() };\n-                Ok(self.register_obligation(infcx.tcx, trait_obligation))\n-            }\n-            ty::Predicate::Equate(a, b) => {\n-                let origin = infer::EquatePredicate(predicate.cause.span);\n-                infer::mk_eqty(infcx, false, origin, a, b) // `a == b` ==> ``\n-            }\n-            ty::Predicate::RegionOutlives(r_a, r_b) => {\n-                let origin = infer::RelateRegionParamBound(predicate.cause.span);\n-                Ok(infer::mk_subr(infcx, origin, r_b, r_a)) // `b : a` ==> `a <= b`\n-            }\n-            ty::Predicate::TypeOutlives(t_a, r_b) => {\n-                Ok(self.register_region_obligation(t_a, r_b, predicate.cause))\n+        match trait_ref_for_builtin_bound(tcx, builtin_bound, ty) {\n+            Ok(trait_ref) => {\n+                self.register_trait_ref(tcx, trait_ref, cause);\n             }\n+            Err(ErrorReported) => { }\n         }\n     }\n \n-    pub fn register_obligation(&mut self,\n-                               tcx: &ty::ctxt<'tcx>,\n-                               obligation: TraitObligation<'tcx>)\n+    pub fn register_trait_ref<'a>(&mut self,\n+                                  tcx: &ty::ctxt<'tcx>,\n+                                  trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                                  cause: ObligationCause<'tcx>)\n     {\n-        if self.duplicate_set.insert(obligation.trait_ref.clone()) {\n-            debug!(\"register_obligation({})\", obligation.repr(tcx));\n-            assert!(!obligation.trait_ref.has_escaping_regions());\n-            self.trait_obligations.push(obligation);\n-        } else {\n-            debug!(\"register_obligation({}) -- already seen, skip\", obligation.repr(tcx));\n-        }\n+        /*!\n+         * A convenience function for registering trait obligations.\n+         */\n+\n+        let trait_obligation = Obligation { cause: cause,\n+                                            recursion_depth: 0,\n+                                            trait_ref: ty::Predicate::Trait(trait_ref) };\n+        self.register_predicate(tcx, trait_obligation)\n     }\n \n     pub fn register_region_obligation(&mut self,\n-                                      sup_type: Ty<'tcx>,\n-                                      sub_region: ty::Region,\n+                                      tcx: &ty::ctxt<'tcx>,\n+                                      t_a: Ty<'tcx>,\n+                                      r_b: ty::Region,\n                                       cause: ObligationCause<'tcx>)\n     {\n-        let region_obligation = RegionObligation { sup_type: sup_type,\n-                                                   sub_region: sub_region,\n-                                                   cause: cause };\n-        match self.region_obligations.entry(cause.body_id) {\n-            Vacant(entry) => { entry.set(vec![region_obligation]); },\n-            Occupied(mut entry) => { entry.get_mut().push(region_obligation); },\n+        register_region_obligation(tcx, t_a, r_b, cause, &mut self.region_obligations);\n+    }\n+\n+    pub fn register_predicate<'a>(&mut self,\n+                                  tcx: &ty::ctxt<'tcx>,\n+                                  predicate: PredicateObligation<'tcx>)\n+    {\n+        if !self.duplicate_set.insert(predicate.trait_ref.clone()) {\n+            debug!(\"register_predicate({}) -- already seen, skip\", predicate.repr(tcx));\n+            return;\n         }\n+\n+        debug!(\"register_predicate({})\", predicate.repr(tcx));\n+        self.predicates.push(predicate);\n     }\n \n     pub fn region_obligations(&self,\n@@ -170,7 +172,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n         // Anything left is ambiguous.\n         let errors: Vec<FulfillmentError> =\n-            self.trait_obligations\n+            self.predicates\n             .iter()\n             .map(|o| FulfillmentError::new((*o).clone(), CodeAmbiguity))\n             .collect();\n@@ -206,8 +208,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         self.select(&mut selcx, false)\n     }\n \n-    pub fn pending_trait_obligations(&self) -> &[TraitObligation<'tcx>] {\n-        self.trait_obligations[]\n+    pub fn pending_obligations(&self) -> &[PredicateObligation<'tcx>] {\n+        self.predicates[]\n     }\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n@@ -218,14 +220,14 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                   -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         debug!(\"select({} obligations, only_new_obligations={}) start\",\n-               self.trait_obligations.len(),\n+               self.predicates.len(),\n                only_new_obligations);\n \n         let tcx = selcx.tcx();\n         let mut errors = Vec::new();\n \n         loop {\n-            let count = self.trait_obligations.len();\n+            let count = self.predicates.len();\n \n             debug!(\"select_where_possible({} obligations) iteration\",\n                    count);\n@@ -243,51 +245,37 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n             // First pass: walk each obligation, retaining\n             // only those that we cannot yet process.\n-            self.trait_obligations.retain(|obligation| {\n-                // Hack: Retain does not pass in the index, but we want\n-                // to avoid processing the first `start_count` entries.\n-                if skip > 0 {\n-                    skip -= 1;\n-                    true\n-                } else {\n-                    match selcx.select(obligation) {\n-                        Ok(None) => {\n-                            true\n-                        }\n-                        Ok(Some(s)) => {\n-                            selections.push(s);\n-                            false\n-                        }\n-                        Err(selection_err) => {\n-                            debug!(\"obligation: {} error: {}\",\n-                                   obligation.repr(tcx),\n-                                   selection_err.repr(tcx));\n-                            errors.push(FulfillmentError::new(\n-                                (*obligation).clone(),\n-                                CodeSelectionError(selection_err)));\n-                            false\n-                        }\n+            {\n+                let region_obligations = &mut self.region_obligations;\n+                self.predicates.retain(|predicate| {\n+                    // Hack: Retain does not pass in the index, but we want\n+                    // to avoid processing the first `start_count` entries.\n+                    if skip == 0 {\n+                        retain_predicate(selcx, predicate,\n+                                         &mut selections, &mut errors, region_obligations)\n+                    } else {\n+                        skip -= 1;\n+                        true\n                     }\n-                }\n-            });\n+                });\n+            }\n \n-            self.attempted_mark = self.trait_obligations.len();\n+            self.attempted_mark = self.predicates.len();\n \n-            if self.trait_obligations.len() == count {\n+            if self.predicates.len() == count {\n                 // Nothing changed.\n                 break;\n             }\n \n             // Now go through all the successful ones,\n             // registering any nested obligations for the future.\n             for selection in selections.into_iter() {\n-                selection.map_move_nested(\n-                    |o| self.register_obligation(tcx, o));\n+                selection.map_move_nested(|p| self.register_predicate(tcx, p));\n             }\n         }\n \n         debug!(\"select({} obligations, {} errors) done\",\n-               self.trait_obligations.len(),\n+               self.predicates.len(),\n                errors.len());\n \n         if errors.len() == 0 {\n@@ -298,10 +286,100 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     }\n }\n \n+fn retain_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+                             predicate: &PredicateObligation<'tcx>,\n+                             selections: &mut Vec<Selection<'tcx>>,\n+                             errors: &mut Vec<FulfillmentError<'tcx>>,\n+                             region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n+                             -> bool\n+{\n+    /*!\n+     * Evaluates a predicate obligation and modifies the appropriate\n+     * output array.  Returns `true` if the predicate must be retained\n+     * because it could not be fully evaluated yet due to insufficient\n+     * type inference.\n+     */\n+\n+    let tcx = selcx.tcx();\n+    match predicate.trait_ref {\n+        ty::Predicate::Trait(ref trait_ref) => {\n+            let trait_obligation = Obligation { cause: predicate.cause,\n+                                                recursion_depth: predicate.recursion_depth,\n+                                                trait_ref: trait_ref.clone() };\n+            match selcx.select(&trait_obligation) {\n+                Ok(None) => {\n+                    true\n+                }\n+                Ok(Some(s)) => {\n+                    selections.push(s);\n+                    false\n+                }\n+                Err(selection_err) => {\n+                    debug!(\"predicate: {} error: {}\",\n+                           predicate.repr(tcx),\n+                           selection_err.repr(tcx));\n+                    errors.push(\n+                        FulfillmentError::new(\n+                            predicate.clone(),\n+                            CodeSelectionError(selection_err)));\n+                    false\n+                }\n+            }\n+        }\n+\n+        ty::Predicate::Equate(a, b) => {\n+            let origin = infer::EquatePredicate(predicate.cause.span);\n+            match infer::mk_eqty(selcx.infcx(), false, origin, a, b) {\n+                Ok(()) => {\n+                    false\n+                }\n+                Err(_) => {\n+                    errors.push(\n+                        FulfillmentError::new(\n+                            predicate.clone(),\n+                            CodeSelectionError(Unimplemented)));\n+                    false\n+                }\n+            }\n+        }\n+\n+        ty::Predicate::RegionOutlives(r_a, r_b) => {\n+            let origin = infer::RelateRegionParamBound(predicate.cause.span);\n+            let () = infer::mk_subr(selcx.infcx(), origin, r_b, r_a); // `b : a` ==> `a <= b`\n+            false\n+        }\n+\n+        ty::Predicate::TypeOutlives(t_a, r_b) => {\n+            register_region_obligation(tcx, t_a, r_b, predicate.cause, region_obligations);\n+            false\n+        }\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for RegionObligation<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"RegionObligation(sub_region={}, sup_type={})\",\n                 self.sub_region.repr(tcx),\n                 self.sup_type.repr(tcx))\n     }\n }\n+\n+fn register_region_obligation<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                    t_a: Ty<'tcx>,\n+                                    r_b: ty::Region,\n+                                    cause: ObligationCause<'tcx>,\n+                                    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n+{\n+    let region_obligation = RegionObligation { sup_type: t_a,\n+                                               sub_region: r_b,\n+                                               cause: cause };\n+\n+    debug!(\"register_region_obligation({})\",\n+           region_obligation.repr(tcx));\n+\n+    match region_obligations.entry(region_obligation.cause.body_id) {\n+        Vacant(entry) => { entry.set(vec![region_obligation]); },\n+        Occupied(mut entry) => { entry.get_mut().push(region_obligation); },\n+    }\n+\n+}"}, {"sha": "f438b61e27c20bf7773054ec1333f0af0e78eaa1", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 20, "deletions": 60, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -15,21 +15,20 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n-use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::ty::{mod, Ty};\n use middle::infer::InferCtxt;\n use std::rc::Rc;\n use std::slice::Items;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n-use util::common::ErrorReported;\n \n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n+pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n pub use self::util::search_trait_and_supertraits_from_bound;\n@@ -54,6 +53,7 @@ pub struct Obligation<'tcx, T> {\n     pub trait_ref: T,\n }\n \n+pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, Rc<ty::TraitRef<'tcx>>>;\n \n /// Why did we incur this obligation? Used for error reporting.\n@@ -91,7 +91,7 @@ pub enum ObligationCauseCode<'tcx> {\n \n     // Captures of variable the given id by a closure (span is the\n     // span of the closure)\n-    ClosureCapture(ast::NodeId, Span),\n+    ClosureCapture(ast::NodeId, Span, ty::BuiltinBound),\n \n     // Types of fields (other than the last) in a struct must be sized.\n     FieldSized,\n@@ -101,20 +101,20 @@ pub enum ObligationCauseCode<'tcx> {\n }\n \n pub type Obligations<'tcx, O> = subst::VecPerParamSpace<Obligation<'tcx, O>>;\n-\n+pub type PredicateObligations<'tcx> = subst::VecPerParamSpace<PredicateObligation<'tcx>>;\n pub type TraitObligations<'tcx> = subst::VecPerParamSpace<TraitObligation<'tcx>>;\n \n-pub type Selection<'tcx> = Vtable<'tcx, TraitObligation<'tcx>>;\n+pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n \n #[deriving(Clone,Show)]\n pub enum SelectionError<'tcx> {\n     Unimplemented,\n     Overflow,\n-    OutputTypeParameterMismatch(Rc<ty::TraitRef<'tcx>>, ty::type_err<'tcx>)\n+    OutputTypeParameterMismatch(Rc<ty::TraitRef<'tcx>>, Rc<ty::TraitRef<'tcx>>, ty::type_err<'tcx>),\n }\n \n pub struct FulfillmentError<'tcx> {\n-    pub obligation: TraitObligation<'tcx>,\n+    pub obligation: PredicateObligation<'tcx>,\n     pub code: FulfillmentErrorCode<'tcx>\n }\n \n@@ -224,33 +224,6 @@ pub struct VtableParamData<'tcx> {\n     pub bound: Rc<ty::TraitRef<'tcx>>,\n }\n \n-/// Matches the self type of the inherent impl `impl_def_id`\n-/// against `self_ty` and returns the resulting resolution.  This\n-/// routine may modify the surrounding type context (for example,\n-/// it may unify variables).\n-pub fn select_inherent_impl<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                     param_env: &ty::ParameterEnvironment<'tcx>,\n-                                     typer: &Typer<'tcx>,\n-                                     cause: ObligationCause<'tcx>,\n-                                     impl_def_id: ast::DefId,\n-                                     self_ty: Ty<'tcx>)\n-                                     -> SelectionResult<'tcx,\n-                                            VtableImplData<'tcx, TraitObligation<'tcx>>>\n-{\n-    // This routine is only suitable for inherent impls. This is\n-    // because it does not attempt to unify the output type parameters\n-    // from the trait ref against the values from the obligation.\n-    // (These things do not apply to inherent impls, for which there\n-    // is no trait ref nor obligation.)\n-    //\n-    // Matching against non-inherent impls should be done with\n-    // `try_resolve_obligation()`.\n-    assert!(ty::impl_trait_ref(infcx.tcx, impl_def_id).is_none());\n-\n-    let mut selcx = select::SelectionContext::new(infcx, param_env, typer);\n-    selcx.select_inherent_impl(impl_def_id, cause, self_ty)\n-}\n-\n /// True if neither the trait nor self type is local. Note that `impl_def_id` must refer to an impl\n /// of a trait, not an inherent impl.\n pub fn is_orphan_impl(tcx: &ty::ctxt,\n@@ -270,32 +243,13 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n     coherence::impl_can_satisfy(infcx, impl2_def_id, impl1_def_id)\n }\n \n-/// Given generic bounds from an impl like:\n-///\n-///    impl<A:Foo, B:Bar+Qux> ...\n-///\n-/// along with the bindings for the types `A` and `B` (e.g., `<A=A0, B=B0>`), yields a result like\n-///\n-///    [[Foo for A0, Bar for B0, Qux for B0], [], []]\n-///\n-/// Expects that `generic_bounds` have already been fully substituted, late-bound regions liberated\n-/// and so forth, so that they are in the same namespace as `type_substs`.\n-pub fn obligations_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                      cause: ObligationCause<'tcx>,\n-                                      generic_bounds: &ty::GenericBounds<'tcx>,\n-                                      type_substs: &subst::VecPerParamSpace<Ty<'tcx>>)\n-                                      -> subst::VecPerParamSpace<TraitObligation<'tcx>>\n-{\n-    util::obligations_for_generics(tcx, cause, 0, generic_bounds, type_substs)\n-}\n-\n-pub fn obligation_for_builtin_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                          cause: ObligationCause<'tcx>,\n-                                          source_ty: Ty<'tcx>,\n-                                          builtin_bound: ty::BuiltinBound)\n-                                          -> Result<TraitObligation<'tcx>, ErrorReported>\n+/// Creates predicate obligations from the generic bounds.\n+pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                     cause: ObligationCause<'tcx>,\n+                                     generic_bounds: &ty::GenericBounds<'tcx>)\n+                                     -> PredicateObligations<'tcx>\n {\n-    util::obligation_for_builtin_bound(tcx, cause, builtin_bound, 0, source_ty)\n+    util::predicates_for_generics(tcx, cause, 0, generic_bounds)\n }\n \n impl<'tcx,O> Obligation<'tcx,O> {\n@@ -311,6 +265,12 @@ impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn misc(span: Span, body_id: ast::NodeId, trait_ref: O) -> Obligation<'tcx, O> {\n         Obligation::new(ObligationCause::misc(span, body_id), trait_ref)\n     }\n+\n+    pub fn with<P>(&self, value: P) -> Obligation<'tcx,P> {\n+        Obligation { cause: self.cause.clone(),\n+                     recursion_depth: self.recursion_depth,\n+                     trait_ref: value }\n+    }\n }\n \n impl<'tcx> Obligation<'tcx,Rc<ty::TraitRef<'tcx>>> {\n@@ -417,7 +377,7 @@ impl<N> VtableBuiltinData<N> {\n }\n \n impl<'tcx> FulfillmentError<'tcx> {\n-    fn new(obligation: TraitObligation<'tcx>,\n+    fn new(obligation: PredicateObligation<'tcx>,\n            code: FulfillmentErrorCode<'tcx>)\n            -> FulfillmentError<'tcx>\n     {"}, {"sha": "c55335ea190e2054b3b4e106c05934bbd5422337", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 112, "deletions": 74, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -17,9 +17,8 @@ use self::Candidate::*;\n use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n-use super::{TraitObligation, ObligationCause};\n-use super::{SelectionError, Unimplemented, Overflow,\n-            OutputTypeParameterMismatch};\n+use super::{PredicateObligation, Obligation, TraitObligation, ObligationCause};\n+use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure, VtableFnPointer};\n@@ -191,6 +190,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    pub fn infcx(&self) -> &'cx InferCtxt<'cx, 'tcx> {\n+        self.infcx\n+    }\n+\n     pub fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -225,29 +228,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    pub fn select_inherent_impl(&mut self,\n-                                impl_def_id: ast::DefId,\n-                                obligation_cause: ObligationCause<'tcx>,\n-                                obligation_self_ty: Ty<'tcx>)\n-                                -> SelectionResult<'tcx, VtableImplData<'tcx, TraitObligation<'tcx>>>\n-    {\n-        debug!(\"select_inherent_impl(impl_def_id={}, obligation_self_ty={})\",\n-               impl_def_id.repr(self.tcx()),\n-               obligation_self_ty.repr(self.tcx()));\n-\n-        match self.match_inherent_impl(impl_def_id,\n-                                       obligation_cause,\n-                                       obligation_self_ty) {\n-            Ok(substs) => {\n-                let vtable_impl = self.vtable_impl(impl_def_id, substs, obligation_cause, 0);\n-                Ok(Some(vtable_impl))\n-            }\n-            Err(()) => {\n-                Err(Unimplemented)\n-            }\n-        }\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // EVALUATION\n     //\n@@ -260,15 +240,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Evaluates whether the obligation `obligation` can be satisfied (by any means).\n     pub fn evaluate_obligation(&mut self,\n-                               obligation: &TraitObligation<'tcx>)\n+                               obligation: &PredicateObligation<'tcx>)\n                                -> bool\n     {\n         debug!(\"evaluate_obligation({})\",\n                obligation.repr(self.tcx()));\n-        assert!(!obligation.trait_ref.has_escaping_regions());\n \n-        let stack = self.push_stack(None, obligation);\n-        self.evaluate_stack(&stack).may_apply()\n+        self.evaluate_predicate_recursively(None, obligation).may_apply()\n     }\n \n     fn evaluate_builtin_bound_recursively<'o>(&mut self,\n@@ -278,7 +256,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               -> EvaluationResult<'tcx>\n     {\n         let obligation =\n-            util::obligation_for_builtin_bound(\n+            util::predicate_for_builtin_bound(\n                 self.tcx(),\n                 previous_stack.obligation.cause,\n                 bound,\n@@ -287,14 +265,44 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match obligation {\n             Ok(obligation) => {\n-                self.evaluate_obligation_recursively(Some(previous_stack), &obligation)\n+                self.evaluate_predicate_recursively(Some(previous_stack), &obligation)\n             }\n             Err(ErrorReported) => {\n                 EvaluatedToOk\n             }\n         }\n     }\n \n+    fn evaluate_predicate_recursively<'o>(&mut self,\n+                                          previous_stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                          obligation: &PredicateObligation<'tcx>)\n+                                           -> EvaluationResult<'tcx>\n+    {\n+        debug!(\"evaluate_predicate_recursively({})\",\n+               obligation.repr(self.tcx()));\n+\n+        match obligation.trait_ref {\n+            ty::Predicate::Trait(ref t) => {\n+                assert!(!t.has_escaping_regions());\n+                let obligation = obligation.with(t.clone());\n+                self.evaluate_obligation_recursively(previous_stack, &obligation)\n+            }\n+\n+            ty::Predicate::Equate(a, b) => {\n+                match infer::can_mk_eqty(self.infcx, a, b) {\n+                    Ok(()) => EvaluatedToOk,\n+                    Err(_) => EvaluatedToErr(Unimplemented),\n+                }\n+            }\n+\n+            ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => {\n+                // we do not consider region relationships when\n+                // evaluating trait matches\n+                EvaluatedToOk\n+            }\n+        }\n+    }\n+\n     fn evaluate_obligation_recursively<'o>(&mut self,\n                                            previous_stack: Option<&TraitObligationStack<'o, 'tcx>>,\n                                            obligation: &TraitObligation<'tcx>)\n@@ -347,7 +355,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n               stack.iter().skip(1).any(\n                   |prev| stack.skol_trait_ref.def_id == prev.skol_trait_ref.def_id))\n         {\n-            debug!(\"evaluate_stack_intracrate({}) --> unbound argument, recursion -->  ambiguous\",\n+            debug!(\"evaluate_stack({}) --> unbound argument, recursion -->  ambiguous\",\n                    stack.skol_trait_ref.repr(self.tcx()));\n             return EvaluatedToAmbig;\n         }\n@@ -376,7 +384,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .skip(1) // skip top-most frame\n             .any(|prev| stack.skol_trait_ref == prev.skol_trait_ref)\n         {\n-            debug!(\"evaluate_stack_intracrate({}) --> recursive\",\n+            debug!(\"evaluate_stack({}) --> recursive\",\n                    stack.skol_trait_ref.repr(self.tcx()));\n             return EvaluatedToOk;\n         }\n@@ -595,8 +603,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // common case, then we can use the global environment.\n         // See the discussion in doc.rs for more details.\n         if\n-            !self.param_env.caller_obligations.is_empty()\n-            &&\n+            !self.param_env.caller_bounds.is_empty() &&\n             cache_skol_trait_ref.input_types().iter().any(\n                 |&t| ty::type_has_ty_infer(t))\n         {\n@@ -690,8 +697,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation.repr(self.tcx()));\n \n         let caller_trait_refs: Vec<Rc<ty::TraitRef>> =\n-            self.param_env.caller_obligations.iter()\n-            .map(|o| o.trait_ref.clone())\n+            self.param_env.caller_bounds.predicates.iter()\n+            .filter_map(|o| o.to_trait())\n             .collect();\n \n         let all_bounds =\n@@ -852,7 +859,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in selection.iter_nested() {\n-            match self.evaluate_obligation_recursively(stack, obligation) {\n+            match self.evaluate_predicate_recursively(stack, obligation) {\n                 EvaluatedToErr(e) => { return EvaluatedToErr(e); }\n                 EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n                 EvaluatedToOk => { }\n@@ -932,8 +939,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                              candidates: &mut CandidateSet<'tcx>)\n                                              -> Result<(),SelectionError<'tcx>>\n     {\n-        match self.builtin_bound(bound, stack.obligation.self_ty()) {\n-            Ok(If(_)) => {\n+        match self.builtin_bound(bound, stack.obligation) {\n+            Ok(If(..)) => {\n                 debug!(\"builtin_bound: bound={}\",\n                        bound.repr(self.tcx()));\n                 candidates.vec.push(BuiltinCandidate(bound));\n@@ -947,10 +954,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn builtin_bound(&mut self,\n                      bound: ty::BuiltinBound,\n-                     self_ty: Ty<'tcx>)\n+                     obligation: &TraitObligation<'tcx>)\n                      -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n     {\n-        let self_ty = self.infcx.shallow_resolve(self_ty);\n+        let self_ty = self.infcx.shallow_resolve(obligation.trait_ref.self_ty());\n         return match self_ty.sty {\n             ty::ty_infer(ty::IntVar(_)) |\n             ty::ty_infer(ty::FloatVar(_)) |\n@@ -1023,8 +1030,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         match bound {\n                             ty::BoundCopy => {\n                                 match mutbl {\n-                                    ast::MutMutable => Err(Unimplemented),  // &mut T is affine\n-                                    ast::MutImmutable => Ok(If(Vec::new())),  // &T is copyable\n+                                    ast::MutMutable => {\n+                                        // &mut T is affine\n+                                        Err(Unimplemented)\n+                                    }\n+                                    ast::MutImmutable => {\n+                                        // &T is copyable, no matter what T is\n+                                        Ok(If(Vec::new()))\n+                                    }\n                                 }\n                             }\n \n@@ -1083,10 +1096,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundCopy => {\n                         match mutbl {\n                             // &mut T is affine and hence never `Copy`\n-                            ast::MutMutable => Err(Unimplemented),\n+                            ast::MutMutable => {\n+                                Err(Unimplemented)\n+                            }\n \n                             // &T is always copyable\n-                            ast::MutImmutable => Ok(If(Vec::new())),\n+                            ast::MutImmutable => {\n+                                Ok(If(Vec::new()))\n+                            }\n                         }\n                     }\n \n@@ -1122,8 +1139,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 match bound {\n                     ty::BoundCopy => {\n                         match *len {\n-                            Some(_) => Ok(If(vec![element_ty])), // [T, ..n] is copy iff T is copy\n-                            None => Err(Unimplemented), // [T] is unsized and hence affine\n+                            Some(_) => {\n+                                // [T, ..n] is copy iff T is copy\n+                                Ok(If(vec![element_ty]))\n+                            }\n+                            None => {\n+                                // [T] is unsized and hence affine\n+                                Err(Unimplemented)\n+                            }\n                         }\n                     }\n \n@@ -1256,7 +1279,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         Some(def_id) == tcx.lang_items.no_send_bound() ||\n                         Some(def_id) == tcx.lang_items.managed_bound()\n                     {\n-                        return Err(Unimplemented);\n+                        return Err(Unimplemented)\n                     }\n                 }\n \n@@ -1274,7 +1297,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         Some(def_id) == tcx.lang_items.no_sync_bound() ||\n                         Some(def_id) == tcx.lang_items.managed_bound()\n                     {\n-                        return Err(Unimplemented);\n+                        return Err(Unimplemented)\n                     } else if\n                         Some(def_id) == tcx.lang_items.unsafe_type()\n                     {\n@@ -1361,13 +1384,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_builtin_candidate(&mut self,\n                                  obligation: &TraitObligation<'tcx>,\n                                  bound: ty::BuiltinBound)\n-                                 -> Result<VtableBuiltinData<TraitObligation<'tcx>>,\n+                                 -> Result<VtableBuiltinData<PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n     {\n         debug!(\"confirm_builtin_candidate({})\",\n                obligation.repr(self.tcx()));\n \n-        match try!(self.builtin_bound(bound, obligation.self_ty())) {\n+        match try!(self.builtin_bound(bound, obligation)) {\n             If(nested) => Ok(self.vtable_builtin_data(obligation, bound, nested)),\n             AmbiguousBuiltin | ParameterBuiltin => {\n                 self.tcx().sess.span_bug(\n@@ -1382,29 +1405,44 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            obligation: &TraitObligation<'tcx>,\n                            bound: ty::BuiltinBound,\n                            nested: Vec<Ty<'tcx>>)\n-                           -> VtableBuiltinData<TraitObligation<'tcx>>\n+                           -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n         let obligations = nested.iter().map(|&t| {\n-            util::obligation_for_builtin_bound(\n+            util::predicate_for_builtin_bound(\n                 self.tcx(),\n                 obligation.cause,\n                 bound,\n                 obligation.recursion_depth + 1,\n                 t)\n         }).collect::<Result<_, _>>();\n-        let obligations = match obligations {\n+        let mut obligations = match obligations {\n             Ok(o) => o,\n             Err(ErrorReported) => Vec::new()\n         };\n+\n+        // as a special case, `Send` requires `'static`\n+        if bound == ty::BoundSend {\n+            obligations.push(Obligation {\n+                cause: obligation.cause,\n+                recursion_depth: obligation.recursion_depth+1,\n+                trait_ref: ty::Predicate::TypeOutlives(obligation.self_ty(),\n+                                                       ty::ReStatic)\n+            });\n+        }\n+\n         let obligations = VecPerParamSpace::new(obligations, Vec::new(),\n                                                 Vec::new(), Vec::new());\n+\n+        debug!(\"vtable_builtin_data: obligations={}\",\n+               obligations.repr(self.tcx()));\n+\n         VtableBuiltinData { nested: obligations }\n     }\n \n     fn confirm_impl_candidate(&mut self,\n                               obligation: &TraitObligation<'tcx>,\n                               impl_def_id: ast::DefId)\n-                              -> Result<VtableImplData<'tcx, TraitObligation<'tcx>>,\n+                              -> Result<VtableImplData<'tcx, PredicateObligation<'tcx>>,\n                                         SelectionError<'tcx>>\n     {\n         debug!(\"confirm_impl_candidate({},{})\",\n@@ -1414,6 +1452,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n         let substs = self.rematch_impl(impl_def_id, obligation);\n+        debug!(\"confirm_impl_candidate substs={}\", substs);\n         Ok(self.vtable_impl(impl_def_id, substs, obligation.cause, obligation.recursion_depth + 1))\n     }\n \n@@ -1422,16 +1461,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                    substs: Substs<'tcx>,\n                    cause: ObligationCause<'tcx>,\n                    recursion_depth: uint)\n-                   -> VtableImplData<'tcx, TraitObligation<'tcx>>\n+                   -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n     {\n-        let impl_obligations =\n-            self.impl_obligations(cause,\n-                                  recursion_depth,\n-                                  impl_def_id,\n-                                  &substs);\n+        let impl_predicates =\n+            self.impl_predicates(cause,\n+                                 recursion_depth,\n+                                 impl_def_id,\n+                                 &substs);\n         VtableImplData { impl_def_id: impl_def_id,\n                          substs: substs,\n-                         nested: impl_obligations }\n+                         nested: impl_predicates }\n     }\n \n     fn confirm_fn_pointer_candidate(&mut self,\n@@ -1752,9 +1791,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.infcx.sub_trait_refs(false,\n                                         origin,\n                                         expected_trait_ref.clone(),\n-                                        obligation_trait_ref) {\n+                                        obligation_trait_ref.clone()) {\n             Ok(()) => Ok(()),\n-            Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, e))\n+            Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n         }\n     }\n \n@@ -1785,17 +1824,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    fn impl_obligations(&self,\n-                        cause: ObligationCause<'tcx>,\n-                        recursion_depth: uint,\n-                        impl_def_id: ast::DefId,\n-                        impl_substs: &Substs<'tcx>)\n-                        -> VecPerParamSpace<TraitObligation<'tcx>>\n+    fn impl_predicates(&self,\n+                       cause: ObligationCause<'tcx>,\n+                       recursion_depth: uint,\n+                       impl_def_id: ast::DefId,\n+                       impl_substs: &Substs<'tcx>)\n+                       -> VecPerParamSpace<PredicateObligation<'tcx>>\n     {\n         let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n         let bounds = impl_generics.to_bounds(self.tcx(), impl_substs);\n-        util::obligations_for_generics(self.tcx(), cause, recursion_depth,\n-                                       &bounds, &impl_substs.types)\n+        util::predicates_for_generics(self.tcx(), cause, recursion_depth, &bounds)\n     }\n \n     fn fn_family_trait_kind(&self,"}, {"sha": "a9532aceebb124bb72e4b78ee6fee7dcb7a34267", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 151, "deletions": 136, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -9,8 +9,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::subst;\n-use middle::subst::{ParamSpace, Substs, VecPerParamSpace, Subst};\n+use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::infer::InferCtxt;\n use middle::ty::{mod, Ty};\n use std::collections::HashSet;\n@@ -21,115 +20,130 @@ use syntax::codemap::Span;\n use util::common::ErrorReported;\n use util::ppaux::Repr;\n \n-use super::{Obligation, ObligationCause, TraitObligation, VtableImpl,\n-            VtableParam, VtableParamData, VtableImplData};\n+use super::{Obligation, ObligationCause, PredicateObligation,\n+            VtableImpl, VtableParam, VtableParamData, VtableImplData};\n \n ///////////////////////////////////////////////////////////////////////////\n-// Supertrait iterator\n+// Elaboration iterator\n \n-pub struct Supertraits<'cx, 'tcx:'cx> {\n+pub struct Elaborator<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>,\n-    stack: Vec<SupertraitEntry<'tcx>>,\n-    visited: HashSet<Rc<ty::TraitRef<'tcx>>>,\n+    stack: Vec<StackEntry<'tcx>>,\n+    visited: HashSet<ty::Predicate<'tcx>>,\n }\n \n-struct SupertraitEntry<'tcx> {\n+struct StackEntry<'tcx> {\n     position: uint,\n-    supertraits: Vec<Rc<ty::TraitRef<'tcx>>>,\n+    predicates: Vec<ty::Predicate<'tcx>>,\n }\n \n-pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                              trait_ref: Rc<ty::TraitRef<'tcx>>)\n-                              -> Supertraits<'cx, 'tcx>\n+pub fn elaborate_trait_ref<'cx, 'tcx>(\n+    tcx: &'cx ty::ctxt<'tcx>,\n+    trait_ref: Rc<ty::TraitRef<'tcx>>)\n+    -> Elaborator<'cx, 'tcx>\n {\n-    //! Returns an iterator over the trait reference `T` and all of its supertrait references. May\n-    //! contain duplicates. In general the ordering is not defined.\n-    //!\n-    //! Example:\n-    //!\n-    //! ```\n-    //! trait Foo { ... }\n-    //! trait Bar : Foo { ... }\n-    //! trait Baz : Bar+Foo { ... }\n-    //! ```\n-    //!\n-    //! `supertraits(Baz)` yields `[Baz, Bar, Foo, Foo]` in some order.\n-\n-    transitive_bounds(tcx, &[trait_ref])\n+    elaborate_predicates(tcx, vec![ty::Predicate::Trait(trait_ref)])\n }\n \n-pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                                    bounds: &[Rc<ty::TraitRef<'tcx>>])\n-                                    -> Supertraits<'cx, 'tcx>\n+pub fn elaborate_trait_refs<'cx, 'tcx>(\n+    tcx: &'cx ty::ctxt<'tcx>,\n+    trait_refs: &[Rc<ty::TraitRef<'tcx>>])\n+    -> Elaborator<'cx, 'tcx>\n {\n-    let bounds = Vec::from_fn(bounds.len(), |i| bounds[i].clone());\n+    let predicates = trait_refs.iter()\n+                               .map(|trait_ref| ty::Predicate::Trait((*trait_ref).clone()))\n+                               .collect();\n+    elaborate_predicates(tcx, predicates)\n+}\n \n-    let visited: HashSet<Rc<ty::TraitRef>> =\n-        bounds.iter()\n-              .map(|b| (*b).clone())\n-              .collect();\n+pub fn elaborate_predicates<'cx, 'tcx>(\n+    tcx: &'cx ty::ctxt<'tcx>,\n+    predicates: Vec<ty::Predicate<'tcx>>)\n+    -> Elaborator<'cx, 'tcx>\n+{\n+    let visited: HashSet<ty::Predicate<'tcx>> =\n+        predicates.iter()\n+                  .map(|b| (*b).clone())\n+                  .collect();\n \n-    let entry = SupertraitEntry { position: 0, supertraits: bounds };\n-    Supertraits { tcx: tcx, stack: vec![entry], visited: visited }\n+    let entry = StackEntry { position: 0, predicates: predicates };\n+    Elaborator { tcx: tcx, stack: vec![entry], visited: visited }\n }\n \n-impl<'cx, 'tcx> Supertraits<'cx, 'tcx> {\n-    fn push(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n-        let ty::ParamBounds { builtin_bounds, mut trait_bounds, .. } =\n-            ty::bounds_for_trait_ref(self.tcx, trait_ref);\n-        for builtin_bound in builtin_bounds.iter() {\n-            let bound_trait_ref = trait_ref_for_builtin_bound(self.tcx,\n-                                                              builtin_bound,\n-                                                              trait_ref.self_ty());\n-            match bound_trait_ref {\n-                Ok(trait_ref) => { trait_bounds.push(trait_ref); }\n-                Err(ErrorReported) => { }\n+impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n+    fn push(&mut self, predicate: &ty::Predicate<'tcx>) {\n+        match *predicate {\n+            ty::Predicate::Trait(ref trait_ref) => {\n+                let mut predicates =\n+                    ty::predicates_for_trait_ref(self.tcx, &**trait_ref);\n+\n+                // Only keep those bounds that we haven't already\n+                // seen.  This is necessary to prevent infinite\n+                // recursion in some cases.  One common case is when\n+                // people define `trait Sized { }` rather than `trait\n+                // Sized for Sized? { }`.\n+                predicates.retain(|r| self.visited.insert((*r).clone()));\n+\n+                self.stack.push(StackEntry { position: 0,\n+                                             predicates: predicates });\n+            }\n+            ty::Predicate::Equate(..) => {\n+            }\n+            ty::Predicate::RegionOutlives(..) |\n+            ty::Predicate::TypeOutlives(..) => {\n+                // Currently, we do not \"elaborate\" predicates like\n+                // `'a : 'b` or `T : 'a`.  We could conceivably do\n+                // more here.  For example,\n+                //\n+                //     &'a int : 'b\n+                //\n+                // implies that\n+                //\n+                //     'a : 'b\n+                //\n+                // and we could get even more if we took WF\n+                // constraints into account. For example,\n+                //\n+                //     &'a &'b int : 'c\n+                //\n+                // implies that\n+                //\n+                //     'b : 'a\n+                //     'a : 'c\n             }\n         }\n-\n-        // Only keep those bounds that we haven't already seen.  This\n-        // is necessary to prevent infinite recursion in some cases.\n-        // One common case is when people define `trait Sized { }`\n-        // rather than `trait Sized for Sized? { }`.\n-        trait_bounds.retain(|r| self.visited.insert((*r).clone()));\n-\n-        let entry = SupertraitEntry { position: 0, supertraits: trait_bounds };\n-        self.stack.push(entry);\n-    }\n-\n-    /// Returns the path taken through the trait supertraits to reach the current point.\n-    pub fn indices(&self) -> Vec<uint> {\n-        self.stack.iter().map(|e| e.position).collect()\n     }\n }\n \n-impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n-    fn next(&mut self) -> Option<Rc<ty::TraitRef<'tcx>>> {\n+impl<'cx, 'tcx> Iterator<ty::Predicate<'tcx>> for Elaborator<'cx, 'tcx> {\n+    fn next(&mut self) -> Option<ty::Predicate<'tcx>> {\n         loop {\n             // Extract next item from top-most stack frame, if any.\n-            let next_trait = match self.stack.last_mut() {\n+            let next_predicate = match self.stack.last_mut() {\n                 None => {\n                     // No more stack frames. Done.\n                     return None;\n                 }\n                 Some(entry) => {\n                     let p = entry.position;\n-                    if p < entry.supertraits.len() {\n-                        // Still more supertraits left in the top stack frame.\n+                    if p < entry.predicates.len() {\n+                        // Still more predicates left in the top stack frame.\n                         entry.position += 1;\n \n-                        let next_trait = entry.supertraits[p].clone();\n-                        Some(next_trait)\n+                        let next_predicate =\n+                            entry.predicates[p].clone();\n+\n+                        Some(next_predicate)\n                     } else {\n                         None\n                     }\n                 }\n             };\n \n-            match next_trait {\n-                Some(next_trait) => {\n-                    self.push(&*next_trait);\n-                    return Some(next_trait);\n+            match next_predicate {\n+                Some(next_predicate) => {\n+                    self.push(&next_predicate);\n+                    return Some(next_predicate);\n                 }\n \n                 None => {\n@@ -141,6 +155,50 @@ impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Supertrait iterator\n+\n+pub struct Supertraits<'cx, 'tcx:'cx> {\n+    elaborator: Elaborator<'cx, 'tcx>,\n+}\n+\n+pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n+                              trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                              -> Supertraits<'cx, 'tcx>\n+{\n+    let elaborator = elaborate_trait_ref(tcx, trait_ref);\n+    Supertraits { elaborator: elaborator }\n+}\n+\n+pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n+                                    bounds: &[Rc<ty::TraitRef<'tcx>>])\n+                                    -> Supertraits<'cx, 'tcx>\n+{\n+    let elaborator = elaborate_trait_refs(tcx, bounds);\n+    Supertraits { elaborator: elaborator }\n+}\n+\n+impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n+    fn next(&mut self) -> Option<Rc<ty::TraitRef<'tcx>>> {\n+        loop {\n+            match self.elaborator.next() {\n+                None => {\n+                    return None;\n+                }\n+                Some(ty::Predicate::Trait(trait_ref)) => {\n+                    return Some(trait_ref);\n+                }\n+                Some(ty::Predicate::Equate(..)) |\n+                Some(ty::Predicate::RegionOutlives(..)) |\n+                Some(ty::Predicate::TypeOutlives(..)) => {\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n // determine the `self` type, using fresh variables for all variables\n // declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n@@ -179,64 +237,20 @@ impl<'tcx> fmt::Show for VtableParamData<'tcx> {\n }\n \n /// See `super::obligations_for_generics`\n-pub fn obligations_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                      cause: ObligationCause<'tcx>,\n-                                      recursion_depth: uint,\n-                                      generic_bounds: &ty::GenericBounds<'tcx>,\n-                                      type_substs: &VecPerParamSpace<Ty<'tcx>>)\n-                                      -> VecPerParamSpace<TraitObligation<'tcx>>\n+pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                     cause: ObligationCause<'tcx>,\n+                                     recursion_depth: uint,\n+                                     generic_bounds: &ty::GenericBounds<'tcx>)\n+                                     -> VecPerParamSpace<PredicateObligation<'tcx>>\n {\n+    debug!(\"predicates_for_generics(generic_bounds={})\",\n+           generic_bounds.repr(tcx));\n \n-    debug!(\"obligations_for_generics(generic_bounds={}, type_substs={})\",\n-           generic_bounds.repr(tcx), type_substs.repr(tcx));\n-\n-    let mut obligations = VecPerParamSpace::empty();\n-\n-    for (space, index, bounds) in generic_bounds.types.iter_enumerated() {\n-        push_obligations_for_param_bounds(tcx,\n-                                          cause,\n-                                          recursion_depth,\n-                                          space,\n-                                          index,\n-                                          bounds,\n-                                          type_substs,\n-                                          &mut obligations);\n-    }\n-\n-    debug!(\"obligations() ==> {}\", obligations.repr(tcx));\n-\n-    return obligations;\n-}\n-\n-fn push_obligations_for_param_bounds<'tcx>(\n-    tcx: &ty::ctxt<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    recursion_depth: uint,\n-    space: subst::ParamSpace,\n-    index: uint,\n-    param_bounds: &ty::ParamBounds<'tcx>,\n-    param_type_substs: &VecPerParamSpace<Ty<'tcx>>,\n-    obligations: &mut VecPerParamSpace<TraitObligation<'tcx>>)\n-{\n-    let param_ty = *param_type_substs.get(space, index);\n-    for builtin_bound in param_bounds.builtin_bounds.iter() {\n-        let obligation = obligation_for_builtin_bound(tcx,\n-                                                      cause,\n-                                                      builtin_bound,\n-                                                      recursion_depth,\n-                                                      param_ty);\n-        if let Ok(ob) = obligation {\n-            obligations.push(space, ob);\n-        }\n-    }\n-\n-    for bound_trait_ref in param_bounds.trait_bounds.iter() {\n-        obligations.push(\n-            space,\n-            Obligation { cause: cause,\n-                         recursion_depth: recursion_depth,\n-                         trait_ref: (*bound_trait_ref).clone() });\n-    }\n+    generic_bounds.predicates.map(|predicate| {\n+        Obligation { cause: cause,\n+                     recursion_depth: recursion_depth,\n+                     trait_ref: predicate.clone() }\n+    })\n }\n \n pub fn trait_ref_for_builtin_bound<'tcx>(\n@@ -259,19 +273,19 @@ pub fn trait_ref_for_builtin_bound<'tcx>(\n     }\n }\n \n-pub fn obligation_for_builtin_bound<'tcx>(\n+pub fn predicate_for_builtin_bound<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n     recursion_depth: uint,\n     param_ty: Ty<'tcx>)\n-    -> Result<TraitObligation<'tcx>, ErrorReported>\n+    -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n     let trait_ref = try!(trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n     Ok(Obligation {\n         cause: cause,\n         recursion_depth: recursion_depth,\n-        trait_ref: trait_ref\n+        trait_ref: ty::Predicate::Trait(trait_ref),\n     })\n }\n \n@@ -358,10 +372,11 @@ impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n             super::Unimplemented =>\n                 format!(\"Unimplemented\"),\n \n-            super::OutputTypeParameterMismatch(ref t, ref e) =>\n-                format!(\"OutputTypeParameterMismatch({}, {})\",\n-                        t.repr(tcx),\n-                        e.repr(tcx)),\n+            super::OutputTypeParameterMismatch(ref a, ref b, ref c) =>\n+                format!(\"OutputTypeParameterMismatch({},{},{})\",\n+                        a.repr(tcx),\n+                        b.repr(tcx),\n+                        c.repr(tcx)),\n         }\n     }\n }"}, {"sha": "ca226e2ca3fae49d40bdb5043a373704044de9df", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 191, "deletions": 138, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -44,6 +44,7 @@ use back::svh::Svh;\n use session::Session;\n use lint;\n use metadata::csearch;\n+use middle;\n use middle::const_eval;\n use middle::def;\n use middle::dependency_format;\n@@ -60,13 +61,14 @@ use middle::traits::ObligationCause;\n use middle::traits;\n use middle::ty;\n use middle::ty_fold::{mod, TypeFoldable, TypeFolder, HigherRankedFoldable};\n-use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::{trait_store_to_string, ty_to_string};\n use util::ppaux::{Repr, UserString};\n-use util::common::{indenter, memoized};\n+use util::common::{indenter, memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n+\n+use arena::TypedArena;\n use std::borrow::BorrowFrom;\n use std::cell::{Cell, RefCell};\n use std::cmp;\n@@ -75,8 +77,8 @@ use std::hash::{Hash, sip, Writer};\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n+use std::collections::enum_set::{EnumSet, CLike};\n use std::collections::hash_map::{HashMap, Occupied, Vacant};\n-use arena::TypedArena;\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, DUMMY_NODE_ID, FnStyle, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n@@ -87,7 +89,6 @@ use syntax::attr::{mod, AttrMetaMethods};\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::{mod, InternedString};\n use syntax::{ast, ast_map};\n-use std::collections::enum_set::{EnumSet, CLike};\n \n pub type Disr = u64;\n \n@@ -1613,30 +1614,21 @@ pub struct RegionParameterDef {\n     pub bounds: Vec<ty::Region>,\n }\n \n-/// Information about the formal type/lifetime parameters associated with an\n-/// item or method. Analogous to ast::Generics.\n+impl RegionParameterDef {\n+    pub fn to_early_bound_region(&self) -> ty::Region {\n+        ty::ReEarlyBound(self.def_id.node, self.space, self.index, self.name)\n+    }\n+}\n+\n+/// Information about the formal type/lifetime parameters associated\n+/// with an item or method. Analogous to ast::Generics.\n #[deriving(Clone, Show)]\n pub struct Generics<'tcx> {\n     pub types: VecPerParamSpace<TypeParameterDef<'tcx>>,\n     pub regions: VecPerParamSpace<RegionParameterDef>,\n     pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n \n-#[deriving(Clone, Show)]\n-pub enum Predicate<'tcx> {\n-    /// where Foo : Bar\n-    Trait(Rc<TraitRef<'tcx>>),\n-\n-    /// where Foo == Bar\n-    Equate(Ty<'tcx>, Ty<'tcx>),\n-\n-    /// where 'a : 'b\n-    RegionOutlives(Region, Region),\n-\n-    /// where T : 'a\n-    TypeOutlives(Ty<'tcx>, Region),\n-}\n-\n impl<'tcx> Generics<'tcx> {\n     pub fn empty() -> Generics<'tcx> {\n         Generics {\n@@ -1657,8 +1649,47 @@ impl<'tcx> Generics<'tcx> {\n     pub fn to_bounds(&self, tcx: &ty::ctxt<'tcx>, substs: &Substs<'tcx>)\n                      -> GenericBounds<'tcx> {\n         GenericBounds {\n-            types: self.types.map(|d| d.bounds.subst(tcx, substs)),\n-            regions: self.regions.map(|d| d.bounds.subst(tcx, substs)),\n+            predicates: self.predicates.subst(tcx, substs),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub enum Predicate<'tcx> {\n+    /// where Foo : Bar\n+    Trait(Rc<TraitRef<'tcx>>),\n+\n+    /// where Foo == Bar\n+    Equate(Ty<'tcx>, Ty<'tcx>),\n+\n+    /// where 'a : 'b\n+    RegionOutlives(Region, Region),\n+\n+    /// where T : 'a\n+    TypeOutlives(Ty<'tcx>, Region),\n+}\n+\n+impl<'tcx> Predicate<'tcx> {\n+    pub fn has_escaping_regions(&self) -> bool {\n+        match *self {\n+            Predicate::Trait(ref trait_ref) => trait_ref.has_escaping_regions(),\n+            Predicate::Equate(a, b) => (ty::type_has_escaping_regions(a) ||\n+                                        ty::type_has_escaping_regions(b)),\n+            Predicate::RegionOutlives(a, b) => a.escapes_depth(0) || b.escapes_depth(0),\n+            Predicate::TypeOutlives(a, b) => ty::type_has_escaping_regions(a) || b.escapes_depth(0),\n+        }\n+    }\n+\n+    pub fn to_trait(&self) -> Option<Rc<TraitRef<'tcx>>> {\n+        match *self {\n+            Predicate::Trait(ref t) => {\n+                Some(t.clone())\n+            }\n+            Predicate::Equate(..) |\n+            Predicate::RegionOutlives(..) |\n+            Predicate::TypeOutlives(..) => {\n+                None\n+            }\n         }\n     }\n }\n@@ -1684,19 +1715,20 @@ impl<'tcx> Generics<'tcx> {\n /// [uint:Bar<int>]]`.\n #[deriving(Clone, Show)]\n pub struct GenericBounds<'tcx> {\n-    pub types: VecPerParamSpace<ParamBounds<'tcx>>,\n-    pub regions: VecPerParamSpace<Vec<Region>>,\n+    pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n \n impl<'tcx> GenericBounds<'tcx> {\n     pub fn empty() -> GenericBounds<'tcx> {\n-        GenericBounds { types: VecPerParamSpace::empty(),\n-                        regions: VecPerParamSpace::empty() }\n+        GenericBounds { predicates: VecPerParamSpace::empty() }\n     }\n \n     pub fn has_escaping_regions(&self) -> bool {\n-        self.types.any(|pb| pb.trait_bounds.iter().any(|tr| tr.has_escaping_regions())) ||\n-            self.regions.any(|rs| rs.iter().any(|r| r.escapes_depth(0)))\n+        self.predicates.any(|p| p.has_escaping_regions())\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.predicates.is_empty()\n     }\n }\n \n@@ -1747,9 +1779,6 @@ pub struct ParameterEnvironment<'tcx> {\n     /// parameters in the same way, this only has an effect on regions.\n     pub free_substs: Substs<'tcx>,\n \n-    /// Bounds on the various type parameters\n-    pub bounds: VecPerParamSpace<ParamBounds<'tcx>>,\n-\n     /// Each type parameter has an implicit region bound that\n     /// indicates it must outlive at least the function body (the user\n     /// may specify stronger requirements). This field indicates the\n@@ -1759,10 +1788,7 @@ pub struct ParameterEnvironment<'tcx> {\n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations.\n-    ///\n-    /// Note: This effectively *duplicates* the `bounds` array for\n-    /// now.\n-    pub caller_obligations: VecPerParamSpace<traits::TraitObligation<'tcx>>,\n+    pub caller_bounds: ty::GenericBounds<'tcx>,\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that have to do with the parameters in scope.\n@@ -3160,7 +3186,8 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n pub fn type_moves_by_default<'tcx>(cx: &ctxt<'tcx>,\n                                    ty: Ty<'tcx>,\n                                    param_env: &ParameterEnvironment<'tcx>)\n-                                    -> bool {\n+                                   -> bool\n+{\n     if !type_has_params(ty) && !type_has_self(ty) {\n         match cx.type_moves_by_default_cache.borrow().get(&ty) {\n             None => {}\n@@ -3181,20 +3208,20 @@ pub fn type_moves_by_default<'tcx>(cx: &ctxt<'tcx>,\n     // (there shouldn't really be any anyhow)\n     let cause = ObligationCause::misc(DUMMY_SP, DUMMY_NODE_ID);\n \n-    let obligation = traits::obligation_for_builtin_bound(\n-        cx,\n-        cause,\n-        ty,\n-        ty::BoundCopy).unwrap();\n-    fulfill_cx.register_obligation(cx, obligation);\n-    let result = !fulfill_cx.select_all_or_error(&infcx,\n-                                                 param_env,\n-                                                 cx).is_ok();\n-    cx.type_moves_by_default_cache.borrow_mut().insert(ty, result);\n+    fulfill_cx.register_builtin_bound(cx, ty, ty::BoundCopy, cause);\n+\n+    // Note: we only assuming something is `Copy` if we can\n+    // *definitively* show that it implements `Copy`. Otherwise,\n+    // assume it is move; linear is always ok.\n+    let is_copy = fulfill_cx.select_all_or_error(&infcx, param_env, cx).is_ok();\n+    let is_move = !is_copy;\n+\n     debug!(\"determined whether {} moves by default: {}\",\n            ty_to_string(cx, ty),\n-           result);\n-    result\n+           is_move);\n+\n+    cx.type_moves_by_default_cache.borrow_mut().insert(ty, is_move);\n+    is_move\n }\n \n pub fn is_ffi_safe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -5006,9 +5033,9 @@ pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n \n /// Given a reference to a trait, returns the bounds declared on the\n /// trait, with appropriate substitutions applied.\n-pub fn bounds_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n-                                  trait_ref: &TraitRef<'tcx>)\n-                                  -> ty::ParamBounds<'tcx>\n+pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n+                                      trait_ref: &TraitRef<'tcx>)\n+                                      -> Vec<ty::Predicate<'tcx>>\n {\n     let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n \n@@ -5099,11 +5126,39 @@ pub fn bounds_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n     let builtin_bounds =\n         trait_def.bounds.builtin_bounds.subst(tcx, &trait_ref.substs);\n \n-    ty::ParamBounds {\n+    let bounds = ty::ParamBounds {\n         trait_bounds: trait_bounds,\n         region_bounds: region_bounds,\n         builtin_bounds: builtin_bounds,\n+    };\n+\n+    predicates(tcx, trait_ref.self_ty(), &bounds)\n+}\n+\n+pub fn predicates<'tcx>(\n+    tcx: &ctxt<'tcx>,\n+    param_ty: Ty<'tcx>,\n+    bounds: &ParamBounds<'tcx>)\n+    -> Vec<Predicate<'tcx>>\n+{\n+    let mut vec = Vec::new();\n+\n+    for builtin_bound in bounds.builtin_bounds.iter() {\n+        match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n+            Ok(trait_ref) => { vec.push(Predicate::Trait(trait_ref)); }\n+            Err(ErrorReported) => { }\n+        }\n+    }\n+\n+    for &region_bound in bounds.region_bounds.iter() {\n+        vec.push(Predicate::TypeOutlives(param_ty, region_bound));\n+    }\n+\n+    for bound_trait_ref in bounds.trait_bounds.iter() {\n+        vec.push(Predicate::Trait((*bound_trait_ref).clone()));\n     }\n+\n+    vec\n }\n \n /// Iterate over attributes of a definition.\n@@ -5461,56 +5516,62 @@ pub fn each_bound_trait_and_supertraits<'tcx>(tcx: &ctxt<'tcx>,\n     return true;\n }\n \n+pub fn object_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n+                                  opt_principal: Option<&TraitRef<'tcx>>, // None for boxed closures\n+                                  others: BuiltinBounds)\n+                                  -> Vec<ty::Region>\n+{\n+    // Since we don't actually *know* the self type for an object,\n+    // this \"open(err)\" serves as a kind of dummy standin -- basically\n+    // a skolemized type.\n+    let open_ty = ty::mk_infer(tcx, SkolemizedTy(0));\n+\n+    let opt_trait_ref = opt_principal.map_or(Vec::new(), |principal| {\n+        let substs = principal.substs.with_self_ty(open_ty);\n+        vec!(Rc::new(ty::TraitRef::new(principal.def_id, substs)))\n+    });\n+\n+    let param_bounds = ty::ParamBounds {\n+        region_bounds: Vec::new(),\n+        builtin_bounds: others,\n+        trait_bounds: opt_trait_ref,\n+    };\n+\n+    let predicates = ty::predicates(tcx, open_ty, &param_bounds);\n+    ty::required_region_bounds(tcx, open_ty, predicates)\n+}\n+\n /// Given a type which must meet the builtin bounds and trait bounds, returns a set of lifetimes\n /// which the type must outlive.\n ///\n /// Requires that trait definitions have been processed.\n pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n-                                    region_bounds: &[ty::Region],\n-                                    builtin_bounds: BuiltinBounds,\n-                                    trait_bounds: &[Rc<TraitRef<'tcx>>])\n+                                    param_ty: Ty<'tcx>,\n+                                    predicates: Vec<ty::Predicate<'tcx>>)\n                                     -> Vec<ty::Region>\n {\n-    let mut all_bounds = Vec::new();\n-\n-    debug!(\"required_region_bounds(builtin_bounds={}, trait_bounds={})\",\n-           builtin_bounds.repr(tcx),\n-           trait_bounds.repr(tcx));\n-\n-    all_bounds.push_all(region_bounds);\n-\n-    push_region_bounds(&[],\n-                       builtin_bounds,\n-                       &mut all_bounds);\n-\n-    debug!(\"from builtin bounds: all_bounds={}\", all_bounds.repr(tcx));\n-\n-    each_bound_trait_and_supertraits(\n-        tcx,\n-        trait_bounds,\n-        |trait_ref| {\n-            let bounds = ty::bounds_for_trait_ref(tcx, &*trait_ref);\n-            push_region_bounds(bounds.region_bounds.as_slice(),\n-                               bounds.builtin_bounds,\n-                               &mut all_bounds);\n-            debug!(\"from {}: bounds={} all_bounds={}\",\n-                   trait_ref.repr(tcx),\n-                   bounds.repr(tcx),\n-                   all_bounds.repr(tcx));\n-            true\n-        });\n-\n-    return all_bounds;\n-\n-    fn push_region_bounds(region_bounds: &[ty::Region],\n-                          builtin_bounds: ty::BuiltinBounds,\n-                          all_bounds: &mut Vec<ty::Region>) {\n-        all_bounds.push_all(region_bounds.as_slice());\n-\n-        if builtin_bounds.contains(&ty::BoundSend) {\n-            all_bounds.push(ty::ReStatic);\n-        }\n-    }\n+    debug!(\"required_region_bounds(param_ty={}, predicates={})\",\n+           param_ty.repr(tcx),\n+           predicates.repr(tcx));\n+\n+    traits::elaborate_predicates(tcx, predicates)\n+        .filter_map(|predicate| {\n+            match predicate {\n+                ty::Predicate::Trait(..) |\n+                ty::Predicate::Equate(..) |\n+                ty::Predicate::RegionOutlives(..) => {\n+                    None\n+                }\n+                ty::Predicate::TypeOutlives(t, r) => {\n+                    if t == param_ty {\n+                        Some(r)\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        })\n+        .collect()\n }\n \n pub fn get_tydesc_ty<'tcx>(tcx: &ctxt<'tcx>) -> Result<Ty<'tcx>, String> {\n@@ -5860,8 +5921,7 @@ impl Variance {\n /// are no free type/lifetime parameters in scope.\n pub fn empty_parameter_environment<'tcx>() -> ParameterEnvironment<'tcx> {\n     ty::ParameterEnvironment { free_substs: Substs::empty(),\n-                               bounds: VecPerParamSpace::empty(),\n-                               caller_obligations: VecPerParamSpace::empty(),\n+                               caller_bounds: GenericBounds::empty(),\n                                implicit_region_bound: ty::ReEmpty,\n                                selection_cache: traits::SelectionCache::new(), }\n }\n@@ -5906,35 +5966,24 @@ pub fn construct_parameter_environment<'tcx>(\n \n     let bounds = generics.to_bounds(tcx, &free_substs);\n     let bounds = liberate_late_bound_regions(tcx, free_id_scope, &bind(bounds)).value;\n-    let obligations = traits::obligations_for_generics(tcx,\n-                                                       traits::ObligationCause::dummy(),\n-                                                       &bounds,\n-                                                       &free_substs.types);\n-    let type_bounds = bounds.types.subst(tcx, &free_substs);\n \n     //\n     // Compute region bounds. For now, these relations are stored in a\n     // global table on the tcx, so just enter them there. I'm not\n     // crazy about this scheme, but it's convenient, at least.\n     //\n \n-    for &space in subst::ParamSpace::all().iter() {\n-        record_region_bounds(tcx, space, &free_substs, bounds.regions.get_slice(space));\n-    }\n-\n+    record_region_bounds(tcx, &bounds);\n \n-    debug!(\"construct_parameter_environment: free_id={} free_subst={} \\\n-           obligations={} type_bounds={}\",\n+    debug!(\"construct_parameter_environment: free_id={} free_subst={} bounds={}\",\n            free_id,\n            free_substs.repr(tcx),\n-           obligations.repr(tcx),\n-           type_bounds.repr(tcx));\n+           bounds.repr(tcx));\n \n     return ty::ParameterEnvironment {\n         free_substs: free_substs,\n-        bounds: bounds.types,\n         implicit_region_bound: ty::ReScope(free_id_scope),\n-        caller_obligations: obligations,\n+        caller_bounds: bounds,\n         selection_cache: traits::SelectionCache::new(),\n     };\n \n@@ -5963,31 +6012,24 @@ pub fn construct_parameter_environment<'tcx>(\n         }\n     }\n \n-    fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                  space: subst::ParamSpace,\n-                                  free_substs: &Substs<'tcx>,\n-                                  bound_sets: &[Vec<ty::Region>]) {\n-        for (subst_region, bound_set) in\n-            free_substs.regions().get_slice(space).iter().zip(\n-                bound_sets.iter())\n-        {\n-            // For each region parameter 'subst...\n-            for bound_region in bound_set.iter() {\n-                // Which is declared with a bound like 'subst:'bound...\n-                match (subst_region, bound_region) {\n-                    (&ty::ReFree(subst_fr), &ty::ReFree(bound_fr)) => {\n-                        // Record that 'subst outlives 'bound. Or, put\n-                        // another way, 'bound <= 'subst.\n-                        tcx.region_maps.relate_free_regions(bound_fr, subst_fr);\n-                    },\n-                    _ => {\n-                        // All named regions are instantiated with free regions.\n-                        tcx.sess.bug(\n-                            format!(\"record_region_bounds: \\\n-                                     non free region: {} / {}\",\n-                                    subst_region.repr(tcx),\n-                                    bound_region.repr(tcx)).as_slice());\n-                    }\n+    fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>, bounds: &GenericBounds<'tcx>) {\n+        debug!(\"record_region_bounds(bounds={})\", bounds.repr(tcx));\n+\n+        for predicate in bounds.predicates.iter() {\n+            match *predicate {\n+                Predicate::Trait(..) | Predicate::Equate(..) | Predicate::TypeOutlives(..) => {\n+                    // No region bounds here\n+                }\n+                Predicate::RegionOutlives(ty::ReFree(fr_a), ty::ReFree(fr_b)) => {\n+                    // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n+                    tcx.region_maps.relate_free_regions(fr_b, fr_a);\n+                }\n+                Predicate::RegionOutlives(r_a, r_b) => {\n+                    // All named regions are instantiated with free regions.\n+                    tcx.sess.bug(\n+                        format!(\"record_region_bounds: non free region: {} / {}\",\n+                                r_a.repr(tcx),\n+                                r_b.repr(tcx)).as_slice());\n                 }\n             }\n         }\n@@ -6306,6 +6348,17 @@ impl<'tcx> Repr<'tcx> for TyTrait<'tcx> {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for ty::Predicate<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        match *self {\n+            Predicate::Trait(ref a) => a.repr(tcx),\n+            Predicate::Equate(a, b) => format!(\"Equate({},{})\", a.repr(tcx), b.repr(tcx)),\n+            Predicate::RegionOutlives(a, b) => format!(\"Outlives({}:{})\", a.repr(tcx), b.repr(tcx)),\n+            Predicate::TypeOutlives(a, b) => format!(\"Outlives({}:{})\", a.repr(tcx), b.repr(tcx)),\n+        }\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for vtable_origin<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {"}, {"sha": "8b54a46bfb934d4d28249ce5f95e4fad476e2020", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -425,8 +425,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ty::GenericBounds<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericBounds<'tcx> {\n         ty::GenericBounds {\n-            types: self.types.fold_with(folder),\n-            regions: self.regions.fold_with(folder),\n+            predicates: self.predicates.fold_with(folder),\n         }\n     }\n }"}, {"sha": "7a14ed9cca8c932c52b82f499eedce5f30895647", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -914,17 +914,17 @@ impl<'tcx> Repr<'tcx> for ty::Polytype<'tcx> {\n \n impl<'tcx> Repr<'tcx> for ty::Generics<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"Generics(types: {}, regions: {})\",\n+        format!(\"Generics(types: {}, regions: {}, predicates: {})\",\n                 self.types.repr(tcx),\n-                self.regions.repr(tcx))\n+                self.regions.repr(tcx),\n+                self.predicates.repr(tcx))\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::GenericBounds<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"GenericBounds(types: {}, regions: {})\",\n-                self.types.repr(tcx),\n-                self.regions.repr(tcx))\n+        format!(\"GenericBounds({})\",\n+                self.predicates.repr(tcx))\n     }\n }\n "}, {"sha": "83938fa335708fe8d174ce4a3942c2e24e53cbb8", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -827,8 +827,8 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // fully bound. It could be a slight optimization to stop\n     // iterating early.\n     let mut fulfill_cx = traits::FulfillmentContext::new();\n-    let vtable = selection.map_move_nested(|obligation| {\n-        fulfill_cx.register_obligation(tcx, obligation);\n+    let vtable = selection.map_move_nested(|predicate| {\n+        fulfill_cx.register_predicate(infcx.tcx, predicate);\n     });\n     match fulfill_cx.select_all_or_error(&infcx, &param_env, tcx) {\n         Ok(()) => { }"}, {"sha": "4ad0d2b8293e1664980deff4de312a7f549e8d1e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 37, "deletions": 49, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -800,7 +800,7 @@ fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n     let existential_bounds = conv_existential_bounds(this,\n                                                      rscope,\n                                                      span,\n-                                                     &[Rc::new(trait_ref.clone())],\n+                                                     Some(&trait_ref),\n                                                      bounds);\n \n     let result = ty::mk_trait(this.tcx(), trait_ref, existential_bounds);\n@@ -918,7 +918,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 let bounds = conv_existential_bounds(this,\n                                                      rscope,\n                                                      ast_ty.span,\n-                                                     [].as_slice(),\n+                                                     None,\n                                                      f.bounds.as_slice());\n                 let fn_decl = ty_of_closure(this,\n                                             f.fn_style,\n@@ -935,9 +935,10 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             ast::TyProc(ref f) => {\n                 // Use corresponding trait store to figure out default bounds\n                 // if none were specified.\n-                let bounds = conv_existential_bounds(this, rscope,\n+                let bounds = conv_existential_bounds(this,\n+                                                     rscope,\n                                                      ast_ty.span,\n-                                                     [].as_slice(),\n+                                                     None,\n                                                      f.bounds.as_slice());\n \n                 let fn_decl = ty_of_closure(this,\n@@ -1370,7 +1371,7 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    main_trait_refs: &[Rc<ty::TraitRef<'tcx>>],\n+    principal_trait_ref: Option<&ty::TraitRef<'tcx>>, // None for boxed closures\n     ast_bounds: &[ast::TyParamBound])\n     -> ty::ExistentialBounds\n {\n@@ -1381,7 +1382,7 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n         partition_bounds(this.tcx(), span, ast_bound_refs.as_slice());\n \n     conv_existential_bounds_from_partitioned_bounds(\n-        this, rscope, span, main_trait_refs, partitioned_bounds)\n+        this, rscope, span, principal_trait_ref, partitioned_bounds)\n }\n \n fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n@@ -1411,11 +1412,12 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n         }\n     };\n \n-    let bounds = conv_existential_bounds_from_partitioned_bounds(this,\n-                                                                 rscope,\n-                                                                 span,\n-                                                                 main_trait_bound.as_slice(),\n-                                                                 partitioned_bounds);\n+    let bounds =\n+        conv_existential_bounds_from_partitioned_bounds(this,\n+                                                        rscope,\n+                                                        span,\n+                                                        main_trait_bound.as_ref().map(|tr| &**tr),\n+                                                        partitioned_bounds);\n \n     match main_trait_bound {\n         None => ty::mk_err(),\n@@ -1427,7 +1429,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    main_trait_refs: &[Rc<ty::TraitRef<'tcx>>],\n+    principal_trait_ref: Option<&ty::TraitRef<'tcx>>, // None for boxed closures\n     partitioned_bounds: PartitionedBounds)\n     -> ty::ExistentialBounds\n     where AC: AstConv<'tcx>, RS:RegionScope\n@@ -1445,28 +1447,12 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n                      as closure or object bounds\").as_slice());\n     }\n \n-    // The \"main trait refs\", rather annoyingly, have no type\n-    // specified for the `Self` parameter of the trait. The reason for\n-    // this is that they are, after all, *existential* types, and\n-    // hence that type is unknown. However, leaving this type missing\n-    // causes the substitution code to go all awry when walking the\n-    // bounds, so here we clone those trait refs and insert ty::err as\n-    // the self type. Perhaps we should do this more generally, it'd\n-    // be convenient (or perhaps something else, i.e., ty::erased).\n-    let main_trait_refs: Vec<Rc<ty::TraitRef>> =\n-        main_trait_refs.iter()\n-        .map(|t|\n-             Rc::new(ty::TraitRef {\n-                 def_id: t.def_id,\n-                 substs: t.substs.with_self_ty(ty::mk_err()) }))\n-        .collect();\n-\n     let region_bound = compute_region_bound(this,\n                                             rscope,\n                                             span,\n-                                            builtin_bounds,\n                                             region_bounds.as_slice(),\n-                                            main_trait_refs.as_slice());\n+                                            principal_trait_ref,\n+                                            builtin_bounds);\n \n     ty::ExistentialBounds {\n         region_bound: region_bound,\n@@ -1478,33 +1464,35 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n /// (if any) we can use to summarize this type. The basic idea is that we will use the bound the\n /// user provided, if they provided one, and otherwise search the supertypes of trait bounds for\n /// region bounds. It may be that we can derive no bound at all, in which case we return `None`.\n-pub fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                      span: Span,\n-                                      builtin_bounds: ty::BuiltinBounds,\n-                                      region_bounds: &[&ast::Lifetime],\n-                                      trait_bounds: &[Rc<ty::TraitRef<'tcx>>])\n-                                      -> Option<ty::Region>\n+fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  span: Span,\n+                                  explicit_region_bounds: &[&ast::Lifetime],\n+                                  principal_trait_ref: Option<&ty::TraitRef<'tcx>>,\n+                                  builtin_bounds: ty::BuiltinBounds)\n+                                  -> Option<ty::Region>\n {\n-    if region_bounds.len() > 1 {\n+    debug!(\"compute_opt_region_bound(explicit_region_bounds={}, \\\n+           principal_trait_ref={}, builtin_bounds={})\",\n+           explicit_region_bounds,\n+           principal_trait_ref.repr(tcx),\n+           builtin_bounds.repr(tcx));\n+\n+    if explicit_region_bounds.len() > 1 {\n         tcx.sess.span_err(\n-            region_bounds[1].span,\n+            explicit_region_bounds[1].span,\n             format!(\"only a single explicit lifetime bound is permitted\").as_slice());\n     }\n \n-    if region_bounds.len() != 0 {\n+    if explicit_region_bounds.len() != 0 {\n         // Explicitly specified region bound. Use that.\n-        let r = region_bounds[0];\n+        let r = explicit_region_bounds[0];\n         return Some(ast_region_to_region(tcx, r));\n     }\n \n     // No explicit region bound specified. Therefore, examine trait\n     // bounds and see if we can derive region bounds from those.\n     let derived_region_bounds =\n-        ty::required_region_bounds(\n-            tcx,\n-            &[],\n-            builtin_bounds,\n-            trait_bounds);\n+        ty::object_region_bounds(tcx, principal_trait_ref, builtin_bounds);\n \n     // If there are no derived region bounds, then report back that we\n     // can find no region bound.\n@@ -1538,13 +1526,13 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    builtin_bounds: ty::BuiltinBounds,\n     region_bounds: &[&ast::Lifetime],\n-    trait_bounds: &[Rc<ty::TraitRef<'tcx>>])\n+    principal_trait_ref: Option<&ty::TraitRef<'tcx>>, // None for closures\n+    builtin_bounds: ty::BuiltinBounds)\n     -> ty::Region\n {\n-    match compute_opt_region_bound(this.tcx(), span, builtin_bounds,\n-                                   region_bounds, trait_bounds) {\n+    match compute_opt_region_bound(this.tcx(), span, region_bounds,\n+                                   principal_trait_ref, builtin_bounds) {\n         Some(r) => r,\n         None => {\n             match rscope.default_region_bound(span) {"}, {"sha": "2b34b4a55b7c11460c753f8fcd1373ac0dba9a88", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -232,16 +232,24 @@ fn deduce_unboxed_closure_expectations_from_obligations<'a,'tcx>(\n     -> Option<(ty::FnSig<'tcx>, ty::UnboxedClosureKind)>\n {\n     // Here `expected_ty` is known to be a type inference variable.\n-    for obligation in fcx.inh.fulfillment_cx.borrow().pending_trait_obligations().iter() {\n-        let obligation_self_ty = fcx.infcx().shallow_resolve(obligation.self_ty());\n-        match obligation_self_ty.sty {\n-            ty::ty_infer(ty::TyVar(v)) if expected_vid == v => { }\n-            _ => { continue; }\n-        }\n+    for obligation in fcx.inh.fulfillment_cx.borrow().pending_obligations().iter() {\n+        match obligation.trait_ref {\n+            ty::Predicate::Trait(ref trait_ref) => {\n+                let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n+                match self_ty.sty {\n+                    ty::ty_infer(ty::TyVar(v)) if expected_vid == v => { }\n+                    _ => { continue; }\n+                }\n \n-        match deduce_unboxed_closure_expectations_from_trait_ref(fcx, &*obligation.trait_ref) {\n-            Some(e) => { return Some(e); }\n-            None => { }\n+                match deduce_unboxed_closure_expectations_from_trait_ref(fcx, &**trait_ref) {\n+                    Some(e) => { return Some(e); }\n+                    None => { }\n+                }\n+            }\n+            ty::Predicate::Equate(..) |\n+            ty::Predicate::RegionOutlives(..) |\n+            ty::Predicate::TypeOutlives(..) => {\n+            }\n         }\n     }\n "}, {"sha": "bf1f2c0ce809a165f41a8e9c10b4c649c40967ca", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -463,7 +463,6 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::misc(self.span, self.fcx.body_id),\n-            method_bounds_substs,\n             method_bounds);\n \n         self.fcx.add_default_region_param_bounds("}, {"sha": "d081b97b71ad8448ecc3b8750bbd430952dc5307", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -169,7 +169,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n \n     // Construct an obligation\n-    let obligation = traits::Obligation::misc(span, fcx.body_id, trait_ref.clone());\n+    let obligation = traits::Obligation::misc(span,\n+                                              fcx.body_id,\n+                                              ty::Predicate::Trait(trait_ref.clone()));\n \n     // Now we want to know if this can be matched\n     let mut selcx = traits::SelectionContext::new(fcx.infcx(),\n@@ -187,6 +189,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n     assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n \n+    debug!(\"lookup_in_trait_adjusted: method_num={} method_ty={}\",\n+           method_num, method_ty.repr(fcx.tcx()));\n+\n     // Substitute the trait parameters into the method type and\n     // instantiate late-bound regions to get the actual method type.\n     //\n@@ -204,7 +209,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n         abi: bare_fn_ty.abi.clone(),\n     });\n \n-    debug!(\"matched method fty={} obligation={}\",\n+    debug!(\"lookup_in_trait_adjusted: matched method fty={} obligation={}\",\n            fty.repr(fcx.tcx()),\n            obligation.repr(fcx.tcx()));\n \n@@ -220,7 +225,6 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     assert!(!method_bounds.has_escaping_regions());\n     fcx.add_obligations_for_parameters(\n         traits::ObligationCause::misc(span, fcx.body_id),\n-        &trait_ref.substs,\n         &method_bounds);\n \n     // FIXME(#18653) -- Try to resolve obligations, giving us more\n@@ -233,8 +237,8 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n         None => { }\n \n         Some(self_expr) => {\n-            debug!(\"inserting adjustment if needed (self-id = {}, \\\n-                   base adjustment = {}, explicit self = {})\",\n+            debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n+                   (self-id={}, base adjustment={}, explicit_self={})\",\n                    self_expr.id, autoderefref, method_ty.explicit_self);\n \n             match method_ty.explicit_self {"}, {"sha": "f0f527f667354c356e6ed6c2ea7f2af8672e2335", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -353,11 +353,27 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                param_ty: ty::ParamTy) {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n-        let ty::ParamTy { space, idx: index, .. } = param_ty;\n-        let bounds =\n-            self.fcx.inh.param_env.bounds.get(space, index).trait_bounds\n-            .as_slice();\n-        self.elaborate_bounds(bounds, true, |this, trait_ref, m, method_num| {\n+        let bounds: Vec<_> =\n+            self.fcx.inh.param_env.caller_bounds.predicates\n+            .iter()\n+            .filter_map(|predicate| {\n+                match *predicate {\n+                    ty::Predicate::Trait(ref trait_ref) => {\n+                        match trait_ref.self_ty().sty {\n+                            ty::ty_param(ref p) if *p == param_ty => Some(trait_ref.clone()),\n+                            _ => None\n+                        }\n+                    }\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::TypeOutlives(..) => {\n+                        None\n+                    }\n+                }\n+            })\n+            .collect();\n+\n+        self.elaborate_bounds(bounds.as_slice(), true, |this, trait_ref, m, method_num| {\n             let xform_self_ty =\n                 this.xform_self_ty(&m, &trait_ref.substs);\n \n@@ -400,6 +416,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                           m: Rc<ty::Method<'tcx>>,\n                           method_num: uint|)\n     {\n+        debug!(\"elaborate_bounds(bounds={})\", bounds.repr(self.tcx()));\n+\n         let tcx = self.tcx();\n         let mut cache = HashSet::new();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n@@ -802,11 +820,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n                     // Convert the bounds into obligations.\n                     let obligations =\n-                        traits::obligations_for_generics(\n+                        traits::predicates_for_generics(\n                             self.tcx(),\n                             traits::ObligationCause::misc(self.span, self.fcx.body_id),\n-                            &impl_bounds,\n-                            &substs.types);\n+                            &impl_bounds);\n                     debug!(\"impl_obligations={}\", obligations.repr(self.tcx()));\n \n                     // Evaluate those obligations to see if they might possibly hold."}, {"sha": "73fae97609718c2ed29d841fa6151333a27cf3db", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 26, "deletions": 91, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -104,6 +104,7 @@ use {CrateCtxt, lookup_def_ccx, no_params, require_same_types};\n use TypeAndSubsts;\n use middle::lang_items::TypeIdLangItem;\n use lint;\n+use util::common::ErrorReported;\n use util::common::{block_query, indenter, loop_query};\n use util::ppaux::{mod, UserString, Repr};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n@@ -1761,7 +1762,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 span,\n                 self.body_id,\n                 traits::ItemObligation(def_id)),\n-            &substs,\n             &bounds);\n         let monotype =\n             polytype.ty.subst(self.tcx(), &substs);\n@@ -1785,14 +1785,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                               code: traits::ObligationCauseCode<'tcx>,\n                               bound: ty::BuiltinBound)\n     {\n-        let obligation = traits::obligation_for_builtin_bound(\n-            self.tcx(),\n-            traits::ObligationCause::new(span, self.body_id, code),\n+        self.register_builtin_bound(\n             ty,\n-            bound);\n-        if let Ok(ob) = obligation {\n-            self.register_obligation(ob);\n-        }\n+            bound,\n+            traits::ObligationCause::new(span, self.body_id, code));\n     }\n \n     pub fn require_type_is_sized(&self,\n@@ -1810,15 +1806,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.require_type_is_sized(self.expr_ty(expr), expr.span, code);\n     }\n \n-    pub fn register_obligation(&self,\n-                               obligation: traits::TraitObligation<'tcx>)\n+    pub fn register_builtin_bound(&self,\n+                                  ty: Ty<'tcx>,\n+                                  builtin_bound: ty::BuiltinBound,\n+                                  cause: traits::ObligationCause<'tcx>)\n+    {\n+        self.inh.fulfillment_cx.borrow_mut()\n+            .register_builtin_bound(self.tcx(), ty, builtin_bound, cause);\n+    }\n+\n+    pub fn register_predicate(&self,\n+                              obligation: traits::PredicateObligation<'tcx>)\n     {\n-        debug!(\"register_obligation({})\",\n+        debug!(\"register_predicate({})\",\n                obligation.repr(self.tcx()));\n \n         self.inh.fulfillment_cx\n             .borrow_mut()\n-            .register_obligation(self.tcx(), obligation);\n+            .register_predicate(self.tcx(), obligation);\n     }\n \n     pub fn to_ty(&self, ast_t: &ast::Ty) -> Ty<'tcx> {\n@@ -1958,7 +1963,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                       cause: traits::ObligationCause<'tcx>)\n     {\n         let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n-        fulfillment_cx.register_region_obligation(ty, region, cause);\n+        fulfillment_cx.register_region_obligation(self.tcx(), ty, region, cause);\n     }\n \n     pub fn add_default_region_param_bounds(&self,\n@@ -1993,90 +1998,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// and `T`. This routine will add a region obligation `$1:'$0` and register it locally.\n     pub fn add_obligations_for_parameters(&self,\n                                           cause: traits::ObligationCause<'tcx>,\n-                                          substs: &Substs<'tcx>,\n                                           generic_bounds: &ty::GenericBounds<'tcx>)\n     {\n         assert!(!generic_bounds.has_escaping_regions());\n \n-        debug!(\"add_obligations_for_parameters(substs={}, generic_bounds={})\",\n-               substs.repr(self.tcx()),\n+        debug!(\"add_obligations_for_parameters(generic_bounds={})\",\n                generic_bounds.repr(self.tcx()));\n \n-        self.add_trait_obligations_for_generics(cause, substs, generic_bounds);\n-        self.add_region_obligations_for_generics(cause, substs, generic_bounds);\n-    }\n+        let obligations = traits::predicates_for_generics(self.tcx(),\n+                                                          cause,\n+                                                          generic_bounds);\n \n-    fn add_trait_obligations_for_generics(&self,\n-                                          cause: traits::ObligationCause<'tcx>,\n-                                          substs: &Substs<'tcx>,\n-                                          generic_bounds: &ty::GenericBounds<'tcx>) {\n-        assert!(!generic_bounds.has_escaping_regions());\n-        assert!(!substs.has_regions_escaping_depth(0));\n-\n-        let obligations =\n-            traits::obligations_for_generics(self.tcx(),\n-                                             cause,\n-                                             generic_bounds,\n-                                             &substs.types);\n-        obligations.map_move(|o| self.register_obligation(o));\n-    }\n-\n-    fn add_region_obligations_for_generics(&self,\n-                                           cause: traits::ObligationCause<'tcx>,\n-                                           substs: &Substs<'tcx>,\n-                                           generic_bounds: &ty::GenericBounds<'tcx>)\n-    {\n-        assert!(!generic_bounds.has_escaping_regions());\n-        assert_eq!(generic_bounds.types.iter().len(), substs.types.iter().len());\n-\n-        for (type_bounds, &type_param) in\n-            generic_bounds.types.iter().zip(\n-                substs.types.iter())\n-        {\n-            self.add_region_obligations_for_type_parameter(\n-                cause.span, type_bounds, type_param);\n-        }\n-\n-        assert_eq!(generic_bounds.regions.iter().len(),\n-                   substs.regions().iter().len());\n-        for (region_bounds, &region_param) in\n-            generic_bounds.regions.iter().zip(\n-                substs.regions().iter())\n-        {\n-            self.add_region_obligations_for_region_parameter(\n-                cause.span, region_bounds.as_slice(), region_param);\n-        }\n-    }\n-\n-    fn add_region_obligations_for_type_parameter(&self,\n-                                                 span: Span,\n-                                                 param_bound: &ty::ParamBounds<'tcx>,\n-                                                 ty: Ty<'tcx>)\n-    {\n-        // For each declared region bound `T:r`, `T` must outlive `r`.\n-        let region_bounds =\n-            ty::required_region_bounds(\n-                self.tcx(),\n-                param_bound.region_bounds.as_slice(),\n-                param_bound.builtin_bounds,\n-                param_bound.trait_bounds.as_slice());\n-        for &r in region_bounds.iter() {\n-            let cause = traits::ObligationCause::new(span, self.body_id, traits::MiscObligation);\n-            self.register_region_obligation(ty, r, cause);\n-        }\n-    }\n-\n-    fn add_region_obligations_for_region_parameter(&self,\n-                                                   span: Span,\n-                                                   region_bounds: &[ty::Region],\n-                                                   region_param: ty::Region)\n-    {\n-        for &b in region_bounds.iter() {\n-            // For each bound `region:b`, `b <= region` must hold\n-            // (i.e., `region` must outlive `b`).\n-            let origin = infer::RelateRegionParamBound(span);\n-            self.mk_subr(origin, b, region_param);\n-        }\n+        obligations.map_move(|o| self.register_predicate(o));\n     }\n }\n \n@@ -4029,6 +3962,9 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let typ = lookup_method_for_for_loop(fcx, &**head, expr.id);\n         vtable::select_new_fcx_obligations(fcx);\n \n+        debug!(\"ExprForLoop each item has type {}\",\n+               fcx.infcx().resolve_type_vars_if_possible(typ).repr(fcx.tcx()));\n+\n         let pcx = pat_ctxt {\n             fcx: fcx,\n             map: pat_id_map(&tcx.def_map, &**pat),\n@@ -5162,7 +5098,6 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     fcx.add_obligations_for_parameters(\n         traits::ObligationCause::new(span, fcx.body_id, traits::ItemObligation(def.def_id())),\n-        &substs,\n         &bounds);\n \n     // Substitute the values for the type parameters into the type of"}, {"sha": "cadcee43b4402b845f9d85ba3c7700b379534167", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -932,14 +932,9 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n             // Check that the type meets the criteria of the existential bounds:\n             for builtin_bound in bounds.builtin_bounds.iter() {\n-                let code = traits::ClosureCapture(var_node_id, expr.span);\n+                let code = traits::ClosureCapture(var_node_id, expr.span, builtin_bound);\n                 let cause = traits::ObligationCause::new(freevar.span, rcx.fcx.body_id, code);\n-                let obligation = traits::obligation_for_builtin_bound(rcx.tcx(), cause,\n-                                                                      var_ty, builtin_bound);\n-                if let Ok(obligation) = obligation {\n-                    rcx.fcx.inh.fulfillment_cx.borrow_mut().register_obligation(rcx.tcx(),\n-                                                                                obligation)\n-                }\n+                rcx.fcx.register_builtin_bound(var_ty, builtin_bound, cause);\n             }\n             type_must_outlive(\n                 rcx, infer::RelateProcBound(expr.span, var_node_id, var_ty),\n@@ -1859,20 +1854,14 @@ fn param_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n            region.repr(rcx.tcx()),\n            param_ty.repr(rcx.tcx()));\n \n-    // Collect all regions that `param_ty` is known to outlive into\n-    // this vector:\n-    let mut param_bounds;\n-\n     // To start, collect bounds from user:\n-    let param_bound = param_env.bounds.get(param_ty.space, param_ty.idx);\n-    param_bounds =\n+    let mut param_bounds =\n         ty::required_region_bounds(rcx.tcx(),\n-                                   param_bound.region_bounds.as_slice(),\n-                                   param_bound.builtin_bounds,\n-                                   param_bound.trait_bounds.as_slice());\n+                                   param_ty.to_ty(rcx.tcx()),\n+                                   param_env.caller_bounds.predicates.as_slice().to_vec());\n \n-    // Collect default bound of fn body that applies to all in scope\n-    // type parameters:\n+    // Add in the default bound of fn body that applies to all in\n+    // scope type parameters:\n     param_bounds.push(param_env.implicit_region_bound);\n \n     // Finally, collect regions we scraped from the well-formedness"}, {"sha": "112ad1fb5b9b8c81e5cbdafe70b2731851d8df3c", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -97,7 +97,9 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             }\n \n             ty::ty_trait(ref t) => {\n-                self.accumulate_from_object_ty(ty, &t.bounds)\n+                let required_region_bounds =\n+                    ty::object_region_bounds(self.tcx, Some(&t.principal), t.bounds.builtin_bounds);\n+                self.accumulate_from_object_ty(ty, t.bounds.region_bound, required_region_bounds)\n             }\n \n             ty::ty_enum(def_id, ref substs) |\n@@ -321,12 +323,15 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             ty::UniqTraitStore => { }\n         }\n \n-        self.accumulate_from_object_ty(ty, &c.bounds)\n+        let required_region_bounds =\n+            ty::object_region_bounds(self.tcx, None, c.bounds.builtin_bounds);\n+        self.accumulate_from_object_ty(ty, c.bounds.region_bound, required_region_bounds);\n     }\n \n     fn accumulate_from_object_ty(&mut self,\n                                  ty: Ty<'tcx>,\n-                                 bounds: &ty::ExistentialBounds)\n+                                 region_bound: ty::Region,\n+                                 required_region_bounds: Vec<ty::Region>)\n     {\n         // Imagine a type like this:\n         //\n@@ -362,17 +367,12 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n         // The content of this object type must outlive\n         // `bounds.region_bound`:\n-        let r_c = bounds.region_bound;\n+        let r_c = region_bound;\n         self.push_region_constraint_from_top(r_c);\n \n         // And then, in turn, to be well-formed, the\n         // `region_bound` that user specified must imply the\n         // region bounds required from all of the trait types:\n-        let required_region_bounds =\n-            ty::required_region_bounds(self.tcx,\n-                                       &[],\n-                                       bounds.builtin_bounds,\n-                                       &[]);\n         for &r_d in required_region_bounds.iter() {\n             // Each of these is an instance of the `'c <= 'b`\n             // constraint above"}, {"sha": "7c5ceb6f5107c8a5007dabfcde15672d926e040f", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 113, "deletions": 72, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -12,15 +12,14 @@ use check::{FnCtxt, structurally_resolved_type};\n use middle::subst::{SelfSpace, FnSpace};\n use middle::traits;\n use middle::traits::{SelectionError, OutputTypeParameterMismatch, Overflow, Unimplemented};\n-use middle::traits::{Obligation, ObligationCause, obligation_for_builtin_bound};\n+use middle::traits::{Obligation, ObligationCause};\n use middle::traits::{FulfillmentError, CodeSelectionError, CodeAmbiguity};\n-use middle::traits::{TraitObligation};\n+use middle::traits::{PredicateObligation};\n use middle::ty::{mod, Ty};\n use middle::infer;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::common::ErrorReported;\n use util::ppaux::{UserString, Repr, ty_to_string};\n \n pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -249,18 +248,10 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   -> Rc<ty::TraitRef<'tcx>>\n {\n     // We can only make objects from sized types.\n-    let sized_obligation =\n-        traits::obligation_for_builtin_bound(\n-            fcx.tcx(),\n-            traits::ObligationCause::new(span, fcx.body_id, traits::ObjectSized),\n-            referent_ty,\n-            ty::BoundSized);\n-    match sized_obligation {\n-        Ok(sized_obligation) => {\n-            fcx.register_obligation(sized_obligation);\n-        }\n-        Err(ErrorReported) => { }\n-    }\n+    fcx.register_builtin_bound(\n+        referent_ty,\n+        ty::BoundSized,\n+        traits::ObligationCause::new(span, fcx.body_id, traits::ObjectSized));\n \n     // This is just for better error reporting. Kinda goofy. The object type stuff\n     // needs some refactoring so there is a more convenient type to pass around.\n@@ -289,24 +280,18 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             ObligationCause::new(span,\n                                  fcx.body_id,\n                                  traits::ObjectCastObligation(object_trait_ty)),\n-            object_trait_ref.clone());\n-    fcx.register_obligation(object_obligation);\n+            ty::Predicate::Trait(object_trait_ref.clone()));\n+    fcx.register_predicate(object_obligation);\n \n     // Create additional obligations for all the various builtin\n     // bounds attached to the object cast. (In other words, if the\n     // object type is Foo+Send, this would create an obligation\n     // for the Send check.)\n     for builtin_bound in object_trait.bounds.builtin_bounds.iter() {\n-            let obligation = obligation_for_builtin_bound(\n-                fcx.tcx(),\n-                ObligationCause::new(span,\n-                                     fcx.body_id,\n-                                     traits::ObjectCastObligation(object_trait_ty)),\n-                referent_ty,\n-                builtin_bound);\n-        if let Ok(obligation) = obligation {\n-            fcx.register_obligation(obligation);\n-        }\n+        fcx.register_builtin_bound(\n+            referent_ty,\n+            builtin_bound,\n+            ObligationCause::new(span, fcx.body_id, traits::ObjectCastObligation(object_trait_ty)));\n     }\n \n     object_trait_ref\n@@ -325,17 +310,6 @@ pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n     }\n }\n \n-fn resolve_trait_ref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, obligation: &TraitObligation<'tcx>)\n-                               -> (Rc<ty::TraitRef<'tcx>>, Ty<'tcx>)\n-{\n-    let trait_ref =\n-        fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n-            &*obligation.trait_ref);\n-    let self_ty =\n-        trait_ref.substs.self_ty().unwrap();\n-    (Rc::new(trait_ref), self_ty)\n-}\n-\n pub fn report_fulfillment_errors<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                            errors: &Vec<FulfillmentError<'tcx>>) {\n     for error in errors.iter() {\n@@ -356,18 +330,42 @@ pub fn report_fulfillment_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        obligation: &TraitObligation<'tcx>,\n+                                        obligation: &PredicateObligation<'tcx>,\n                                         error: &SelectionError<'tcx>)\n {\n     match *error {\n         Overflow => {\n-            let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n-            fcx.tcx().sess.span_err(\n-                obligation.cause.span,\n-                format!(\n-                    \"overflow evaluating the trait `{}` for the type `{}`\",\n-                    trait_ref.user_string(fcx.tcx()),\n-                    self_ty.user_string(fcx.tcx())).as_slice());\n+            // We could track the stack here more precisely if we wanted, I imagine.\n+            match obligation.trait_ref {\n+                ty::Predicate::Trait(ref trait_ref) => {\n+                    let trait_ref =\n+                        fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(&**trait_ref);\n+                    fcx.tcx().sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"overflow evaluating the trait `{}` for the type `{}`\",\n+                            trait_ref.user_string(fcx.tcx()),\n+                            trait_ref.self_ty().user_string(fcx.tcx())).as_slice());\n+                }\n+\n+                ty::Predicate::Equate(a, b) => {\n+                    let a = fcx.infcx().resolve_type_vars_if_possible(a);\n+                    let b = fcx.infcx().resolve_type_vars_if_possible(b);\n+                    fcx.tcx().sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"overflow checking whether the types `{}` and `{}` are equal\",\n+                            a.user_string(fcx.tcx()),\n+                            b.user_string(fcx.tcx())).as_slice());\n+                }\n+\n+                ty::Predicate::TypeOutlives(..) |\n+                ty::Predicate::RegionOutlives(..) => {\n+                    fcx.tcx().sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\"overflow evaluating lifetime predicate\").as_slice());\n+                }\n+            }\n \n             let current_limit = fcx.tcx().sess.recursion_limit.get();\n             let suggested_limit = current_limit * 2;\n@@ -380,31 +378,63 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             note_obligation_cause(fcx, obligation);\n         }\n         Unimplemented => {\n-            let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n-            if !ty::type_is_error(self_ty) {\n-                fcx.tcx().sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n-                        \"the trait `{}` is not implemented for the type `{}`\",\n-                        trait_ref.user_string(fcx.tcx()),\n-                        self_ty.user_string(fcx.tcx())).as_slice());\n-                note_obligation_cause(fcx, obligation);\n+            match obligation.trait_ref {\n+                ty::Predicate::Trait(ref trait_ref) => {\n+                    let trait_ref =\n+                        fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n+                            &**trait_ref);\n+                    if !ty::type_is_error(trait_ref.self_ty()) {\n+                        fcx.tcx().sess.span_err(\n+                            obligation.cause.span,\n+                            format!(\n+                                \"the trait `{}` is not implemented for the type `{}`\",\n+                                trait_ref.user_string(fcx.tcx()),\n+                                trait_ref.self_ty().user_string(fcx.tcx())).as_slice());\n+                        note_obligation_cause(fcx, obligation);\n+                    }\n+                }\n+\n+                ty::Predicate::Equate(a, b) => {\n+                    let a = fcx.infcx().resolve_type_vars_if_possible(a);\n+                    let b = fcx.infcx().resolve_type_vars_if_possible(b);\n+                    let err = infer::can_mk_eqty(fcx.infcx(), a, b).unwrap_err();\n+                    fcx.tcx().sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"mismatched types: the types `{}` and `{}` are not equal ({})\",\n+                            a.user_string(fcx.tcx()),\n+                            b.user_string(fcx.tcx()),\n+                            ty::type_err_to_str(fcx.tcx(), &err)).as_slice());\n+                }\n+\n+                ty::Predicate::TypeOutlives(..) |\n+                ty::Predicate::RegionOutlives(..) => {\n+                    // these kinds of predicates turn into\n+                    // constraints, and hence errors show up in region\n+                    // inference.\n+                    fcx.tcx().sess.span_bug(\n+                        obligation.cause.span,\n+                        format!(\"region predicate error {}\",\n+                                obligation.repr(fcx.tcx())).as_slice());\n+                }\n             }\n         }\n-        OutputTypeParameterMismatch(ref expected_trait_ref, ref e) => {\n+        OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n             let expected_trait_ref =\n                 fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n                     &**expected_trait_ref);\n-            let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n-            if !ty::type_is_error(self_ty) {\n+            let actual_trait_ref =\n+                fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n+                    &**actual_trait_ref);\n+            if !ty::type_is_error(actual_trait_ref.self_ty()) {\n                 fcx.tcx().sess.span_err(\n                     obligation.cause.span,\n                     format!(\n                         \"type mismatch: the type `{}` implements the trait `{}`, \\\n                          but the trait `{}` is required ({})\",\n-                        self_ty.user_string(fcx.tcx()),\n+                        expected_trait_ref.self_ty().user_string(fcx.tcx()),\n                         expected_trait_ref.user_string(fcx.tcx()),\n-                        trait_ref.user_string(fcx.tcx()),\n+                        actual_trait_ref.user_string(fcx.tcx()),\n                         ty::type_err_to_str(fcx.tcx(), e)).as_slice());\n                 note_obligation_cause(fcx, obligation);\n             }\n@@ -413,12 +443,25 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        obligation: &TraitObligation<'tcx>) {\n+                                        obligation: &PredicateObligation<'tcx>) {\n     // Unable to successfully determine, probably means\n     // insufficient type information, but could mean\n     // ambiguous impls. The latter *ought* to be a\n     // coherence violation, so we don't report it here.\n-    let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n+\n+    let trait_ref = match obligation.trait_ref {\n+        ty::Predicate::Trait(ref trait_ref) => {\n+            fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(&**trait_ref)\n+        }\n+        _ => {\n+            fcx.tcx().sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"ambiguity from something other than a trait: {}\",\n+                        obligation.trait_ref.repr(fcx.tcx())).as_slice());\n+        }\n+    };\n+    let self_ty = trait_ref.self_ty();\n+\n     debug!(\"maybe_report_ambiguity(trait_ref={}, self_ty={}, obligation={})\",\n            trait_ref.repr(fcx.tcx()),\n            self_ty.repr(fcx.tcx()),\n@@ -475,8 +518,8 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n /// Select as many obligations as we can at present.\n-pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt) {\n-\n+pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt)\n+{\n     match\n         fcx.inh.fulfillment_cx\n         .borrow_mut()\n@@ -502,27 +545,23 @@ pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n }\n \n fn note_obligation_cause<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                   obligation: &TraitObligation<'tcx>) {\n+                                   obligation: &PredicateObligation<'tcx>) {\n     let tcx = fcx.tcx();\n-    let trait_name = ty::item_path_str(tcx, obligation.trait_ref.def_id);\n     match obligation.cause.code {\n         traits::MiscObligation => { }\n         traits::ItemObligation(item_def_id) => {\n             let item_name = ty::item_path_str(tcx, item_def_id);\n             tcx.sess.span_note(\n                 obligation.cause.span,\n                 format!(\n-                    \"the trait `{}` must be implemented because it is required by `{}`\",\n-                    trait_name,\n+                    \"required by `{}`\",\n                     item_name).as_slice());\n         }\n         traits::ObjectCastObligation(object_ty) => {\n             tcx.sess.span_note(\n                 obligation.cause.span,\n                 format!(\n-                    \"the trait `{}` must be implemented for the cast \\\n-                     to the object type `{}`\",\n-                    trait_name,\n+                    \"required for the cast to the object type `{}`\",\n                     fcx.infcx().ty_to_string(object_ty)).as_slice());\n         }\n         traits::RepeatVec => {\n@@ -560,7 +599,9 @@ fn note_obligation_cause<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                        \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n                        to force the compiler to allow this\");\n         }\n-        traits::ClosureCapture(var_id, closure_span) => {\n+        traits::ClosureCapture(var_id, closure_span, builtin_bound) => {\n+            let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n+            let trait_name = ty::item_path_str(tcx, def_id);\n             let name = ty::local_var_name_str(tcx, var_id);\n             span_note!(tcx.sess, closure_span,\n                        \"the closure that captures `{}` requires that all captured variables \\\""}, {"sha": "e89b127799c08d734fcf9bc6a923b763e72f85d0", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 32, "deletions": 43, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -122,16 +122,12 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 // For DST, all intermediate types must be sized.\n                 if variant.fields.len() > 0 {\n                     for field in variant.fields.init().iter() {\n-                        let cause = traits::ObligationCause::new(field.span,\n-                                                                 fcx.body_id,\n-                                                                 traits::FieldSized);\n-                        let obligation = traits::obligation_for_builtin_bound(fcx.tcx(),\n-                                                                              cause,\n-                                                                              field.ty,\n-                                                                              ty::BoundSized);\n-                        if let Ok(obligation) = obligation {\n-                            fcx.register_obligation(obligation);\n-                        }\n+                        fcx.register_builtin_bound(\n+                            field.ty,\n+                            ty::BoundSized,\n+                            traits::ObligationCause::new(field.span,\n+                                                         fcx.body_id,\n+                                                         traits::FieldSized));\n                     }\n                 }\n             }\n@@ -220,34 +216,16 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // the same way as we treat the self-type.\n             bounds_checker.check_trait_ref(&trait_ref);\n \n-            let trait_def = ty::lookup_trait_def(fcx.tcx(), trait_ref.def_id);\n-\n             let cause =\n                 traits::ObligationCause::new(\n                     item.span,\n                     fcx.body_id,\n                     traits::ItemObligation(trait_ref.def_id));\n \n             // Find the supertrait bounds. This will add `int:Bar`.\n-            //\n-            // FIXME -- This is a bit ill-factored. There is very similar\n-            // code in traits::util::obligations_for_generics.\n-            fcx.add_region_obligations_for_type_parameter(item.span,\n-                                                          &trait_def.bounds,\n-                                                          trait_ref.self_ty());\n-            for builtin_bound in trait_def.bounds.builtin_bounds.iter() {\n-                let obligation = traits::obligation_for_builtin_bound(fcx.tcx(),\n-                                                                      cause,\n-                                                                      trait_ref.self_ty(),\n-                                                                      builtin_bound);\n-                if let Ok(obligation) = obligation {\n-                    fcx.register_obligation(obligation);\n-                }\n-            }\n-            for trait_bound in trait_def.bounds.trait_bounds.iter() {\n-                let trait_bound = trait_bound.subst(fcx.tcx(), &trait_ref.substs);\n-                fcx.register_obligation(\n-                    traits::Obligation::new(cause, trait_bound));\n+            let predicates = ty::predicates_for_trait_ref(fcx.tcx(), &trait_ref);\n+            for predicate in predicates.into_iter() {\n+                fcx.register_predicate(traits::Obligation::new(cause, predicate));\n             }\n         });\n     }\n@@ -296,7 +274,6 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n                 self.span,\n                 self.fcx.body_id,\n                 traits::ItemObligation(trait_ref.def_id)),\n-            &trait_ref.substs,\n             &bounds);\n \n         for &ty in trait_ref.substs.types.iter() {\n@@ -347,7 +324,6 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                         traits::ObligationCause::new(self.span,\n                                                      self.fcx.body_id,\n                                                      traits::ItemObligation(type_id)),\n-                        substs,\n                         &polytype.generics.to_bounds(self.tcx(), substs));\n                 } else {\n                     // There are two circumstances in which we ignore\n@@ -372,12 +348,13 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                     //\n                     // (I believe we should do the same for traits, but\n                     // that will require an RFC. -nmatsakis)\n-                    self.fcx.add_trait_obligations_for_generics(\n+                    let bounds = polytype.generics.to_bounds(self.tcx(), substs);\n+                    let bounds = filter_to_trait_obligations(bounds);\n+                    self.fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(self.span,\n                                                      self.fcx.body_id,\n                                                      traits::ItemObligation(type_id)),\n-                        substs,\n-                        &polytype.generics.to_bounds(self.tcx(), substs));\n+                        &bounds);\n                 }\n \n                 self.fold_substs(substs);\n@@ -464,6 +441,24 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         .collect()\n }\n \n+fn filter_to_trait_obligations<'tcx>(bounds: ty::GenericBounds<'tcx>)\n+                                     -> ty::GenericBounds<'tcx>\n+{\n+    let mut result = ty::GenericBounds::empty();\n+    for (space, _, predicate) in bounds.predicates.iter_enumerated() {\n+        match *predicate {\n+            ty::Predicate::Trait(..) => {\n+                result.predicates.push(space, predicate.clone())\n+            }\n+            ty::Predicate::Equate(..) |\n+            ty::Predicate::TypeOutlives(..) |\n+            ty::Predicate::RegionOutlives(..) => {\n+            }\n+        }\n+    }\n+    result\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Special drop trait checking\n \n@@ -476,13 +471,7 @@ fn check_struct_safe_for_destructor<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         && !struct_tpt.generics.has_region_params(subst::TypeSpace)\n     {\n         let cause = traits::ObligationCause::new(span, fcx.body_id, traits::DropTrait);\n-        let obligation = traits::obligation_for_builtin_bound(fcx.tcx(),\n-                                                              cause,\n-                                                              self_ty,\n-                                                              ty::BoundSend);\n-        if let Ok(obligation) = obligation {\n-            fcx.register_obligation(obligation);\n-        }\n+        fcx.register_builtin_bound(self_ty, ty::BoundSend, cause);\n     } else {\n         span_err!(fcx.tcx().sess, span, E0141,\n                   \"cannot implement a destructor on a structure \\"}, {"sha": "09cf708047601a81d00171378d0087f098a677eb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -42,15 +42,13 @@ use middle::region;\n use middle::resolve_lifetime;\n use middle::subst;\n use middle::subst::{Substs};\n-use middle::traits;\n use middle::ty::{ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use middle::ty::{Polytype};\n use middle::ty::{mod, Ty};\n use middle::ty_fold::TypeFolder;\n use middle::infer;\n use rscope::*;\n use {CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n-use util::common::ErrorReported;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux;\n use util::ppaux::{Repr,UserString};\n@@ -1409,14 +1407,15 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     .collect();\n \n         // ...and also create generics synthesized from the associated types.\n+        let mut index = 0;\n         let assoc_types: Vec<_> =\n             items.iter()\n             .flat_map(|item| match *item {\n                 ast::TypeTraitItem(ref trait_item) => {\n-                    let index = types.len();\n+                    index += 1;\n                     Some(ty::mk_param(ccx.tcx,\n                                       subst::AssocSpace,\n-                                      index,\n+                                      index - 1,\n                                       local_def(trait_item.ty_param.id))).into_iter()\n                 }\n                 ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {\n@@ -1598,7 +1597,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    substs: &subst::Substs<'tcx>,\n                                    ast_generics: &ast::Generics,\n                                    items: &[ast::TraitItem])\n-                                   -> ty::Generics<'tcx> {\n+                                   -> ty::Generics<'tcx>\n+{\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n@@ -1646,7 +1646,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         bounds: ty::ParamBounds {\n             region_bounds: vec!(),\n             builtin_bounds: ty::empty_builtin_bounds(),\n-            trait_bounds: vec!(self_trait_ref),\n+            trait_bounds: vec!(self_trait_ref.clone()),\n         },\n         associated_with: None,\n         default: None\n@@ -1656,6 +1656,9 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     generics.types.push(subst::SelfSpace, def);\n \n+    generics.predicates.push(subst::SelfSpace,\n+                             ty::Predicate::Trait(self_trait_ref));\n+\n     generics\n }\n \n@@ -1904,24 +1907,18 @@ fn ty_generics<'tcx,AC>(this: &AC,\n         result: &mut ty::Generics<'tcx>,\n         space: subst::ParamSpace)\n     {\n-        for (index, type_param_def) in result.types.get_slice(space).iter().enumerate() {\n-            let param_ty = ty::mk_param(tcx, space, index, type_param_def.def_id);\n-\n-            for builtin_bound in type_param_def.bounds.builtin_bounds.iter() {\n-                match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n-                    Ok(trait_ref) => {\n-                        result.predicates.push(space, ty::Predicate::Trait(trait_ref));\n-                    }\n-                    Err(ErrorReported) => { }\n-                }\n-            }\n-\n-            for &region_bound in type_param_def.bounds.region_bounds.iter() {\n-                result.predicates.push(space, ty::Predicate::TypeOutlives(param_ty, region_bound));\n+        for type_param_def in result.types.get_slice(space).iter() {\n+            let param_ty = ty::mk_param_from_def(tcx, type_param_def);\n+            for predicate in ty::predicates(tcx, param_ty, &type_param_def.bounds).into_iter() {\n+                result.predicates.push(space, predicate);\n             }\n+        }\n \n-            for bound_trait_ref in type_param_def.bounds.trait_bounds.iter() {\n-                result.predicates.push(space, ty::Predicate::Trait((*bound_trait_ref).clone()));\n+        for region_param_def in result.regions.get_slice(space).iter() {\n+            let region = region_param_def.to_early_bound_region();\n+            for &bound_region in region_param_def.bounds.iter() {\n+                result.predicates.push(space, ty::Predicate::RegionOutlives(region,\n+                                                                            bound_region));\n             }\n         }\n     }\n@@ -2178,8 +2175,7 @@ pub fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let regions =\n         ty_generics.regions.map(\n-            |def| ty::ReEarlyBound(def.def_id.node, def.space,\n-                                   def.index, def.name));\n+            |def| def.to_early_bound_region());\n \n     subst::Substs::new(types, regions)\n }"}, {"sha": "4c7ff60fbdd0f6440def7a3e0a5a39cad659b0af", "filename": "src/test/compile-fail/builtin-superkinds-self-type.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -17,7 +17,6 @@ trait Foo : Sync+'static {\n \n impl <T: Sync> Foo for T { }\n //~^ ERROR the parameter type `T` may not live long enough\n-//~^^ ERROR the parameter type `T` may not live long enough\n \n fn main() {\n     let (tx, rx) = channel();"}, {"sha": "2c689f6909b3913463397e9b276e517ad061fa5d", "filename": "src/test/compile-fail/builtin-superkinds-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -14,6 +14,6 @@\n trait Foo : Send { }\n \n impl <'a> Foo for &'a mut () { }\n-//~^ ERROR does not fulfill the required lifetime\n+//~^ ERROR declared lifetime bound not satisfied\n \n fn main() { }"}, {"sha": "57ee4cf7cc3b03b7695db104745be532c6103293", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -34,6 +34,7 @@ fn g<T>(val: T) {\n fn foo<'a>() {\n     let t: S<&'a int> = S;\n     let a = &t as &Gettable<&'a int>;\n+    //~^ ERROR declared lifetime bound not satisfied\n }\n \n fn foo2<'a>() {"}, {"sha": "35e928d417c3b164ac6feefa3fb9cd5661d6abfa", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -22,7 +22,7 @@ fn test51<'a>() {\n }\n fn test52<'a>() {\n     assert_send::<&'a (Dummy+Send)>();\n-    //~^ ERROR does not fulfill the required lifetime\n+    //~^ ERROR declared lifetime bound not satisfied\n }\n \n // ...unless they are properly bounded"}, {"sha": "11148d2846c16aebe9759b4e9a083cf6c1901a78", "filename": "src/test/compile-fail/kindck-send-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -19,7 +19,7 @@ fn test32() { assert_send::<Vec<int> >(); }\n \n // but not if they own a bad thing\n fn test40<'a>(_: &'a int) {\n-    assert_send::<Box<&'a int>>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<Box<&'a int>>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn main() { }"}, {"sha": "04172932cfe6fcf88a04008c1a137cbbd153478e", "filename": "src/test/compile-fail/kindck-send-region-pointers.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -22,13 +22,13 @@ fn test10() { assert_send::<&'static mut int>(); }\n \n // otherwise lifetime pointers are not ok\n fn test20<'a>(_: &'a int) {\n-    assert_send::<&'a int>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<&'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n fn test21<'a>(_: &'a int) {\n-    assert_send::<&'a str>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<&'a str>(); //~ ERROR declared lifetime bound not satisfied\n }\n fn test22<'a>(_: &'a int) {\n-    assert_send::<&'a [int]>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<&'a [int]>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn main() { }"}, {"sha": "33314149d1fade8cd73284edf230617afb87a32a", "filename": "src/test/compile-fail/kindck-send-unsafe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -15,7 +15,7 @@ fn test70() {\n     assert_send::<*mut int>();\n }\n fn test71<'a>() {\n-    assert_send::<*mut &'a int>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<*mut &'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn main() {"}, {"sha": "1da7f47677a2c89633d07af93d4660089694d0e1", "filename": "src/test/compile-fail/recursion_limit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -44,8 +44,8 @@ fn main() {\n     is_send::<A>();\n     //~^ ERROR overflow evaluating\n     //~^^ NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n-    //~^^^ NOTE must be implemented\n+    //~^^^ NOTE required by `is_send`\n     //~^^^^ ERROR overflow evaluating\n     //~^^^^^ NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n-    //~^^^^^^ NOTE must be implemented\n+    //~^^^^^^ NOTE required by `is_send`\n }"}, {"sha": "b2b2d3337c419c7ec53d184e4d1d6dcf980505f3", "filename": "src/test/compile-fail/region-object-lifetime-in-coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -15,20 +15,20 @@ trait Foo {}\n impl<'a> Foo for &'a [u8] {}\n \n fn a(v: &[u8]) -> Box<Foo + 'static> {\n-    let x: Box<Foo + 'static> = box v; //~ ERROR does not outlive\n+    let x: Box<Foo + 'static> = box v; //~ ERROR declared lifetime bound not satisfied\n     x\n }\n \n fn b(v: &[u8]) -> Box<Foo + 'static> {\n-    box v //~ ERROR does not outlive\n+    box v //~ ERROR declared lifetime bound not satisfied\n }\n \n fn c(v: &[u8]) -> Box<Foo> {\n     box v // OK thanks to lifetime elision\n }\n \n fn d<'a,'b>(v: &'a [u8]) -> Box<Foo+'b> {\n-    box v //~ ERROR does not outlive\n+    box v //~ ERROR declared lifetime bound not satisfied\n }\n \n fn e<'a:'b,'b>(v: &'a [u8]) -> Box<Foo+'b> {"}, {"sha": "ec679a7dda170991168c02b259ce2d419e20bc44", "filename": "src/test/compile-fail/regions-bounded-by-send.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -29,15 +29,15 @@ fn static_lifime_ok<'a,T,U:Send>(_: &'a int) {\n // otherwise lifetime pointers are not ok\n \n fn param_not_ok<'a>(x: &'a int) {\n-    assert_send::<&'a int>(); //~ ERROR does not fulfill\n+    assert_send::<&'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn param_not_ok1<'a>(_: &'a int) {\n-    assert_send::<&'a str>(); //~ ERROR does not fulfill\n+    assert_send::<&'a str>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn param_not_ok2<'a>(_: &'a int) {\n-    assert_send::<&'a [int]>(); //~ ERROR does not fulfill\n+    assert_send::<&'a [int]>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n // boxes are ok\n@@ -51,7 +51,7 @@ fn box_ok() {\n // but not if they own a bad thing\n \n fn box_with_region_not_ok<'a>() {\n-    assert_send::<Box<&'a int>>(); //~ ERROR does not fulfill\n+    assert_send::<Box<&'a int>>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n // objects with insufficient bounds no ok\n@@ -63,7 +63,7 @@ fn object_with_random_bound_not_ok<'a>() {\n \n fn object_with_send_bound_not_ok<'a>() {\n     assert_send::<&'a (Dummy+Send)>();\n-    //~^ ERROR does not fulfill\n+    //~^ ERROR declared lifetime bound not satisfied\n }\n \n fn proc_with_lifetime_not_ok<'a>() {\n@@ -84,11 +84,11 @@ fn unsafe_ok1<'a>(_: &'a int) {\n }\n \n fn unsafe_ok2<'a>(_: &'a int) {\n-    assert_send::<*const &'a int>(); //~ ERROR does not fulfill\n+    assert_send::<*const &'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn unsafe_ok3<'a>(_: &'a int) {\n-    assert_send::<*mut &'a int>(); //~ ERROR does not fulfill\n+    assert_send::<*mut &'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn main() {"}, {"sha": "e3939a4e39046bfca361f38fec42154409ffb7a6", "filename": "src/test/compile-fail/regions-bounded-by-trait-requiring-static.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-trait-requiring-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-trait-requiring-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-trait-requiring-static.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -29,15 +29,15 @@ fn static_lifime_ok<'a,T,U:Send>(_: &'a int) {\n // otherwise lifetime pointers are not ok\n \n fn param_not_ok<'a>(x: &'a int) {\n-    assert_send::<&'a int>(); //~ ERROR does not fulfill\n+    assert_send::<&'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn param_not_ok1<'a>(_: &'a int) {\n-    assert_send::<&'a str>(); //~ ERROR does not fulfill\n+    assert_send::<&'a str>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn param_not_ok2<'a>(_: &'a int) {\n-    assert_send::<&'a [int]>(); //~ ERROR does not fulfill\n+    assert_send::<&'a [int]>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n // boxes are ok\n@@ -51,7 +51,7 @@ fn box_ok() {\n // but not if they own a bad thing\n \n fn box_with_region_not_ok<'a>() {\n-    assert_send::<Box<&'a int>>(); //~ ERROR does not fulfill\n+    assert_send::<Box<&'a int>>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n // unsafe pointers are ok unless they point at unsendable things\n@@ -62,11 +62,11 @@ fn unsafe_ok1<'a>(_: &'a int) {\n }\n \n fn unsafe_ok2<'a>(_: &'a int) {\n-    assert_send::<*const &'a int>(); //~ ERROR does not fulfill\n+    assert_send::<*const &'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn unsafe_ok3<'a>(_: &'a int) {\n-    assert_send::<*mut &'a int>(); //~ ERROR does not fulfill\n+    assert_send::<*mut &'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn main() {"}, {"sha": "10484925980a79da53098566d5cd46c3de95026e", "filename": "src/test/compile-fail/regions-bounded-method-type-parameters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -20,7 +20,7 @@ impl Foo {\n \n fn caller<'a>(x: &int) {\n     Foo.some_method::<&'a int>();\n-    //~^ ERROR does not fulfill the required lifetime\n+    //~^ ERROR declared lifetime bound not satisfied\n }\n \n fn main() { }"}, {"sha": "4c95e1eac6d58ddeec9fc0b9a60a5aa608601dad", "filename": "src/test/compile-fail/regions-proc-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fregions-proc-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f492fefef8d9a75f6dc27c834561fe977ca70c5/src%2Ftest%2Fcompile-fail%2Fregions-proc-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-proc-bounds.rs?ref=9f492fefef8d9a75f6dc27c834561fe977ca70c5", "patch": "@@ -12,7 +12,7 @@ fn is_static<T: 'static>() {}\n \n fn foo<'a>() {\n     is_static::<proc():'a>();\n-    //~^ ERROR does not fulfill the required lifetime\n+    //~^ ERROR declared lifetime bound not satisfied\n \n     is_static::<proc():'static>();\n }"}]}