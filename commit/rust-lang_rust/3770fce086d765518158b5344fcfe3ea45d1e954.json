{"sha": "3770fce086d765518158b5344fcfe3ea45d1e954", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NzBmY2UwODZkNzY1NTE4MTU4YjUzNDRmY2ZlM2VhNDVkMWU5NTQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-02T19:11:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-02T19:11:08Z"}, "message": "Merge #9465\n\n9465: feat: `replace_match_with_if_let` works on more 2-arm matches r=Veykril a=Veykril\n\nNow it works on pretty much on all 2-arm matches where only up to 1 arm binds a name instead of requiring either a sad or wildcard pattern to be present.\r\n\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "a6d29ca9164bf171a372b1e383b0d6b972e67d7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6d29ca9164bf171a372b1e383b0d6b972e67d7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3770fce086d765518158b5344fcfe3ea45d1e954", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg32TMCRBK7hj4Ov3rIwAAeVgIAJxk5W3pKhxWCrL6pVZe7xWo\n0l1w+0WFGScaBaSJogXAq3LfTMBRD9AIfotZc1gr5jXktlDiucjEWCyUo1yBmKMw\n2yo1v2TqPUCi3V0+5k5n2b0tipO5/Fl94X9sGSy/NsysARsOCpW5R+/VftEjsPFT\nUM4ajyOLA68RzQb8Skjw1P5r5P3M5Kp9kdMq8tN2VCafWT1OrA1mHpM5zkDIV/tX\ntAWF5CS9JN7GTrcXdD2biZKwc/+Em1eQb30hkNjxs/6VqhHW0zD0FvFMd0Iv3Trv\neOptIV1uNiIg68qVCj/XGO7b1EV1dqkY9/anzHu+7HUu9B6imZSDwxKJUo/FpT4=\n=6Yz8\n-----END PGP SIGNATURE-----\n", "payload": "tree a6d29ca9164bf171a372b1e383b0d6b972e67d7d\nparent dd69d4a97ce0ba7ad808909d4506668dc324d923\nparent eb3f90b301144434c197e09bd190fa8d234ef24d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1625253068 +0000\ncommitter GitHub <noreply@github.com> 1625253068 +0000\n\nMerge #9465\n\n9465: feat: `replace_match_with_if_let` works on more 2-arm matches r=Veykril a=Veykril\n\nNow it works on pretty much on all 2-arm matches where only up to 1 arm binds a name instead of requiring either a sad or wildcard pattern to be present.\r\n\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3770fce086d765518158b5344fcfe3ea45d1e954", "html_url": "https://github.com/rust-lang/rust/commit/3770fce086d765518158b5344fcfe3ea45d1e954", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3770fce086d765518158b5344fcfe3ea45d1e954/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd69d4a97ce0ba7ad808909d4506668dc324d923", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd69d4a97ce0ba7ad808909d4506668dc324d923", "html_url": "https://github.com/rust-lang/rust/commit/dd69d4a97ce0ba7ad808909d4506668dc324d923"}, {"sha": "eb3f90b301144434c197e09bd190fa8d234ef24d", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb3f90b301144434c197e09bd190fa8d234ef24d", "html_url": "https://github.com/rust-lang/rust/commit/eb3f90b301144434c197e09bd190fa8d234ef24d"}], "stats": {"total": 250, "additions": 184, "deletions": 66}, "files": [{"sha": "855220449bc2a554230bb6a9821387306c2310c2", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3770fce086d765518158b5344fcfe3ea45d1e954/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770fce086d765518158b5344fcfe3ea45d1e954/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=3770fce086d765518158b5344fcfe3ea45d1e954", "patch": "@@ -4137,6 +4137,7 @@ pub fn foo() {}\n \n     #[test]\n     fn hover_attr_path_qualifier() {\n+        cov_mark::check!(name_ref_classify_attr_path_qualifier);\n         check(\n             r#\"\n //- /foo.rs crate:foo"}, {"sha": "9ce3ea694b98152dc04db3edc4a82a600594228d", "filename": "crates/ide_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 178, "deletions": 66, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/3770fce086d765518158b5344fcfe3ea45d1e954/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770fce086d765518158b5344fcfe3ea45d1e954/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=3770fce086d765518158b5344fcfe3ea45d1e954", "patch": "@@ -86,53 +86,21 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n         target,\n         move |edit| {\n             let match_expr = {\n-                let else_arm = {\n-                    match else_block {\n-                        Some(else_block) => {\n-                            let pattern = match &*cond_bodies {\n-                                [(Either::Left(pat), _)] => ctx\n-                                    .sema\n-                                    .type_of_pat(&pat)\n-                                    .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n-                                    .map(|it| {\n-                                        if does_pat_match_variant(&pat, &it.sad_pattern()) {\n-                                            it.happy_pattern()\n-                                        } else {\n-                                            it.sad_pattern()\n-                                        }\n-                                    }),\n-                                _ => None,\n-                            }\n-                            .unwrap_or_else(|| make::wildcard_pat().into());\n-                            make::match_arm(\n-                                iter::once(pattern),\n-                                None,\n-                                unwrap_trivial_block(else_block),\n-                            )\n+                let else_arm = make_else_arm(else_block, &cond_bodies, ctx);\n+                let make_match_arm = |(pat, body): (_, ast::BlockExpr)| {\n+                    let body = body.reset_indent().indent(IndentLevel(1));\n+                    match pat {\n+                        Either::Left(pat) => {\n+                            make::match_arm(iter::once(pat), None, unwrap_trivial_block(body))\n                         }\n-                        None => make::match_arm(\n+                        Either::Right(expr) => make::match_arm(\n                             iter::once(make::wildcard_pat().into()),\n-                            None,\n-                            make::expr_unit().into(),\n+                            Some(expr),\n+                            unwrap_trivial_block(body),\n                         ),\n                     }\n                 };\n-                let arms = cond_bodies\n-                    .into_iter()\n-                    .map(|(pat, body)| {\n-                        let body = body.reset_indent().indent(IndentLevel(1));\n-                        match pat {\n-                            Either::Left(pat) => {\n-                                make::match_arm(iter::once(pat), None, unwrap_trivial_block(body))\n-                            }\n-                            Either::Right(expr) => make::match_arm(\n-                                iter::once(make::wildcard_pat().into()),\n-                                Some(expr),\n-                                unwrap_trivial_block(body),\n-                            ),\n-                        }\n-                    })\n-                    .chain(iter::once(else_arm));\n+                let arms = cond_bodies.into_iter().map(make_match_arm).chain(iter::once(else_arm));\n                 let match_expr = make::expr_match(scrutinee_to_be_expr, make::match_arm_list(arms));\n                 match_expr.indent(IndentLevel::from_node(if_expr.syntax()))\n             };\n@@ -150,6 +118,36 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n     )\n }\n \n+fn make_else_arm(\n+    else_block: Option<ast::BlockExpr>,\n+    cond_bodies: &Vec<(Either<ast::Pat, ast::Expr>, ast::BlockExpr)>,\n+    ctx: &AssistContext,\n+) -> ast::MatchArm {\n+    if let Some(else_block) = else_block {\n+        let pattern = if let [(Either::Left(pat), _)] = &**cond_bodies {\n+            ctx.sema\n+                .type_of_pat(&pat)\n+                .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n+                .zip(Some(pat))\n+        } else {\n+            None\n+        };\n+        let pattern = match pattern {\n+            Some((it, pat)) => {\n+                if does_pat_match_variant(&pat, &it.sad_pattern()) {\n+                    it.happy_pattern()\n+                } else {\n+                    it.sad_pattern()\n+                }\n+            }\n+            None => make::wildcard_pat().into(),\n+        };\n+        make::match_arm(iter::once(pattern), None, unwrap_trivial_block(else_block))\n+    } else {\n+        make::match_arm(iter::once(make::wildcard_pat().into()), None, make::expr_unit().into())\n+    }\n+}\n+\n // Assist: replace_match_with_if_let\n //\n // Replaces a binary `match` with a wildcard pattern and no guards with an `if let` expression.\n@@ -178,48 +176,47 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n // ```\n pub(crate) fn replace_match_with_if_let(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_expr: ast::MatchExpr = ctx.find_node_at_offset()?;\n+\n     let mut arms = match_expr.match_arm_list()?.arms();\n-    let first_arm = arms.next()?;\n-    let second_arm = arms.next()?;\n+    let (first_arm, second_arm) = (arms.next()?, arms.next()?);\n     if arms.next().is_some() || first_arm.guard().is_some() || second_arm.guard().is_some() {\n         return None;\n     }\n-    let condition_expr = match_expr.expr()?;\n-    let (if_let_pat, then_expr, else_expr) = if is_pat_wildcard_or_sad(&ctx.sema, &first_arm.pat()?)\n-    {\n-        (second_arm.pat()?, second_arm.expr()?, first_arm.expr()?)\n-    } else if is_pat_wildcard_or_sad(&ctx.sema, &second_arm.pat()?) {\n-        (first_arm.pat()?, first_arm.expr()?, second_arm.expr()?)\n-    } else {\n-        return None;\n-    };\n+\n+    let (if_let_pat, then_expr, else_expr) = pick_pattern_and_expr_order(\n+        &ctx.sema,\n+        first_arm.pat()?,\n+        second_arm.pat()?,\n+        first_arm.expr()?,\n+        second_arm.expr()?,\n+    )?;\n+    let scrutinee = match_expr.expr()?;\n \n     let target = match_expr.syntax().text_range();\n     acc.add(\n         AssistId(\"replace_match_with_if_let\", AssistKind::RefactorRewrite),\n         \"Replace with if let\",\n         target,\n         move |edit| {\n-            let condition = make::condition(condition_expr, Some(if_let_pat));\n+            let condition = make::condition(scrutinee, Some(if_let_pat));\n             let then_block = match then_expr.reset_indent() {\n                 ast::Expr::BlockExpr(block) => block,\n                 expr => make::block_expr(iter::empty(), Some(expr)),\n             };\n             let else_expr = match else_expr {\n-                ast::Expr::BlockExpr(block)\n-                    if block.statements().count() == 0 && block.tail_expr().is_none() =>\n-                {\n-                    None\n-                }\n-                ast::Expr::TupleExpr(tuple) if tuple.fields().count() == 0 => None,\n+                ast::Expr::BlockExpr(block) if block.is_empty() => None,\n+                ast::Expr::TupleExpr(tuple) if tuple.fields().next().is_none() => None,\n                 expr => Some(expr),\n             };\n             let if_let_expr = make::expr_if(\n                 condition,\n                 then_block,\n-                else_expr.map(|else_expr| {\n-                    ast::ElseBranch::Block(make::block_expr(iter::empty(), Some(else_expr)))\n-                }),\n+                else_expr\n+                    .map(|expr| match expr {\n+                        ast::Expr::BlockExpr(block) => block,\n+                        expr => (make::block_expr(iter::empty(), Some(expr))),\n+                    })\n+                    .map(ast::ElseBranch::Block),\n             )\n             .indent(IndentLevel::from_node(match_expr.syntax()));\n \n@@ -228,11 +225,51 @@ pub(crate) fn replace_match_with_if_let(acc: &mut Assists, ctx: &AssistContext)\n     )\n }\n \n-fn is_pat_wildcard_or_sad(sema: &hir::Semantics<RootDatabase>, pat: &ast::Pat) -> bool {\n+/// Pick the pattern for the if let condition and return the expressions for the `then` body and `else` body in that order.\n+fn pick_pattern_and_expr_order(\n+    sema: &hir::Semantics<RootDatabase>,\n+    pat: ast::Pat,\n+    pat2: ast::Pat,\n+    expr: ast::Expr,\n+    expr2: ast::Expr,\n+) -> Option<(ast::Pat, ast::Expr, ast::Expr)> {\n+    let res = match (pat, pat2) {\n+        (ast::Pat::WildcardPat(_), _) => return None,\n+        (pat, sad_pat) if is_sad_pat(sema, &sad_pat) => (pat, expr, expr2),\n+        (sad_pat, pat) if is_sad_pat(sema, &sad_pat) => (pat, expr2, expr),\n+        (pat, pat2) => match (binds_name(&pat), binds_name(&pat2)) {\n+            (true, true) => return None,\n+            (true, false) => (pat, expr, expr2),\n+            (false, true) => (pat2, expr2, expr),\n+            (false, false) => (pat, expr, expr2),\n+        },\n+    };\n+    Some(res)\n+}\n+\n+fn binds_name(pat: &ast::Pat) -> bool {\n+    let binds_name_v = |pat| binds_name(&pat);\n+    match pat {\n+        ast::Pat::IdentPat(_) => true,\n+        ast::Pat::MacroPat(_) => true,\n+        ast::Pat::OrPat(pat) => pat.pats().any(binds_name_v),\n+        ast::Pat::SlicePat(pat) => pat.pats().any(binds_name_v),\n+        ast::Pat::TuplePat(it) => it.fields().any(binds_name_v),\n+        ast::Pat::TupleStructPat(it) => it.fields().any(binds_name_v),\n+        ast::Pat::RecordPat(it) => it\n+            .record_pat_field_list()\n+            .map_or(false, |rpfl| rpfl.fields().flat_map(|rpf| rpf.pat()).any(binds_name_v)),\n+        ast::Pat::RefPat(pat) => pat.pat().map_or(false, binds_name_v),\n+        ast::Pat::BoxPat(pat) => pat.pat().map_or(false, binds_name_v),\n+        ast::Pat::ParenPat(pat) => pat.pat().map_or(false, binds_name_v),\n+        _ => false,\n+    }\n+}\n+\n+fn is_sad_pat(sema: &hir::Semantics<RootDatabase>, pat: &ast::Pat) -> bool {\n     sema.type_of_pat(pat)\n         .and_then(|ty| TryEnum::from_ty(sema, &ty))\n-        .map(|it| it.sad_pattern().syntax().text() == pat.syntax().text())\n-        .unwrap_or_else(|| matches!(pat, ast::Pat::WildcardPat(_)))\n+        .map_or(false, |it| does_pat_match_variant(pat, &it.sad_pattern()))\n }\n \n #[cfg(test)]\n@@ -664,4 +701,79 @@ fn main() {\n \"#,\n         )\n     }\n+\n+    #[test]\n+    fn replace_match_with_if_let_exhaustive() {\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+fn print_source(def_source: ModuleSource) {\n+    match def_so$0urce {\n+        ModuleSource::SourceFile(..) => { println!(\"source file\"); }\n+        ModuleSource::Module(..) => { println!(\"module\"); }\n+    }\n+}\n+\"#,\n+            r#\"\n+fn print_source(def_source: ModuleSource) {\n+    if let ModuleSource::SourceFile(..) = def_source { println!(\"source file\"); } else { println!(\"module\"); }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_match_with_if_let_prefer_name_bind() {\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+fn foo() {\n+    match $0Foo(0) {\n+        Foo(_) => (),\n+        Bar(bar) => println!(\"bar {}\", bar),\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    if let Bar(bar) = Foo(0) {\n+        println!(\"bar {}\", bar)\n+    }\n+}\n+\"#,\n+        );\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+fn foo() {\n+    match $0Foo(0) {\n+        Bar(bar) => println!(\"bar {}\", bar),\n+        Foo(_) => (),\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    if let Bar(bar) = Foo(0) {\n+        println!(\"bar {}\", bar)\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_match_with_if_let_rejects_double_name_bindings() {\n+        check_assist_not_applicable(\n+            replace_match_with_if_let,\n+            r#\"\n+fn foo() {\n+    match $0Foo(0) {\n+        Foo(foo) => println!(\"bar {}\", foo),\n+        Bar(bar) => println!(\"bar {}\", bar),\n+    }\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "2accc735fe8240880ac04cfeac6915420bc51303", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3770fce086d765518158b5344fcfe3ea45d1e954/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770fce086d765518158b5344fcfe3ea45d1e954/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=3770fce086d765518158b5344fcfe3ea45d1e954", "patch": "@@ -395,6 +395,7 @@ impl NameRefClass {\n                         // Don't wanna collide with builtin attributes here like `test` hence guard\n                         // so only resolve to modules that aren't the last segment\n                         PathResolution::Def(module @ ModuleDef::Module(_)) if path != top_path => {\n+                            cov_mark::hit!(name_ref_classify_attr_path_qualifier);\n                             Some(NameRefClass::Definition(Definition::ModuleDef(module)))\n                         }\n                         PathResolution::Macro(mac) if mac.kind() == hir::MacroKind::Attr => {"}, {"sha": "d8c5c4e76fbe53abce007dc99b399895ca4d83ba", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3770fce086d765518158b5344fcfe3ea45d1e954/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770fce086d765518158b5344fcfe3ea45d1e954/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=3770fce086d765518158b5344fcfe3ea45d1e954", "patch": "@@ -49,6 +49,10 @@ impl ast::BlockExpr {\n     pub fn items(&self) -> AstChildren<ast::Item> {\n         support::children(self.syntax())\n     }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.statements().next().is_none() && self.tail_expr().is_none()\n+    }\n }\n \n impl ast::Expr {"}]}