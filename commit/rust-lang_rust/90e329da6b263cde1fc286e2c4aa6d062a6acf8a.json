{"sha": "90e329da6b263cde1fc286e2c4aa6d062a6acf8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZTMyOWRhNmIyNjNjZGUxZmMyODZlMmM0YWE2ZDA2MmE2YWNmOGE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-21T20:09:25Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-21T20:09:25Z"}, "message": "First cut at translating const items. Support the literal forms at least. Un-XFAIL const.rs.", "tree": {"sha": "55b7a7b571be8752612e8eaaac69d07e34d03bef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55b7a7b571be8752612e8eaaac69d07e34d03bef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90e329da6b263cde1fc286e2c4aa6d062a6acf8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90e329da6b263cde1fc286e2c4aa6d062a6acf8a", "html_url": "https://github.com/rust-lang/rust/commit/90e329da6b263cde1fc286e2c4aa6d062a6acf8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90e329da6b263cde1fc286e2c4aa6d062a6acf8a/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c72d6a3e7a605d67ceff701465eff77b95dc2d32", "url": "https://api.github.com/repos/rust-lang/rust/commits/c72d6a3e7a605d67ceff701465eff77b95dc2d32", "html_url": "https://github.com/rust-lang/rust/commit/c72d6a3e7a605d67ceff701465eff77b95dc2d32"}], "stats": {"total": 101, "additions": 75, "deletions": 26}, "files": [{"sha": "385558b6062da2d34ac9855178b11960a2dcb609", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90e329da6b263cde1fc286e2c4aa6d062a6acf8a/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/90e329da6b263cde1fc286e2c4aa6d062a6acf8a/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=90e329da6b263cde1fc286e2c4aa6d062a6acf8a", "patch": "@@ -432,6 +432,7 @@ TEST_XFAILS_RUSTC := $(filter-out \\\n                         cast.rs \\\n                         char.rs \\\n                         complex.rs \\\n+                        const.rs \\\n                         dead-code-one-arm-if.rs \\\n                         deep.rs \\\n                         deref.rs \\"}, {"sha": "49d8a7caeefac4451af9b972ea73ae0601ab6d25", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 74, "deletions": 26, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/90e329da6b263cde1fc286e2c4aa6d062a6acf8a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e329da6b263cde1fc286e2c4aa6d062a6acf8a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=90e329da6b263cde1fc286e2c4aa6d062a6acf8a", "patch": "@@ -70,6 +70,7 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[ast.def_id, @ast.item] items,\n                             hashmap[ast.def_id, @tag_info] tags,\n                             hashmap[ast.def_id, ValueRef] fn_pairs,\n+                            hashmap[ast.def_id, ValueRef] consts,\n                             hashmap[ast.def_id,()] obj_methods,\n                             hashmap[@ty.t, ValueRef] tydescs,\n                             vec[ast.obj_field] obj_fields,\n@@ -527,7 +528,9 @@ fn C_int(int i) -> ValueRef {\n     ret C_integral(i, T_int());\n }\n \n-fn C_str(@crate_ctxt cx, str s) -> ValueRef {\n+// This is a 'c-like' raw string, which differs from\n+// our boxed-and-length-annotated strings.\n+fn C_cstr(@crate_ctxt cx, str s) -> ValueRef {\n     auto sc = llvm.LLVMConstString(_str.buf(s), _str.byte_len(s), False);\n     auto g = llvm.LLVMAddGlobal(cx.llmod, val_ty(sc),\n                                 _str.buf(cx.names.next(\"str\")));\n@@ -538,6 +541,23 @@ fn C_str(@crate_ctxt cx, str s) -> ValueRef {\n     ret g;\n }\n \n+// A rust boxed-and-length-annotated string.\n+fn C_str(@crate_ctxt cx, str s) -> ValueRef {\n+    auto len = _str.byte_len(s);\n+    auto box = C_struct(vec(C_int(abi.const_refcount as int),\n+                            C_int(len + 1u as int), // 'alloc'\n+                            C_int(len + 1u as int), // 'fill'\n+                            llvm.LLVMConstString(_str.buf(s),\n+                                                 len, False)));\n+    auto g = llvm.LLVMAddGlobal(cx.llmod, val_ty(box),\n+                                _str.buf(cx.names.next(\"str\")));\n+    llvm.LLVMSetInitializer(g, box);\n+    llvm.LLVMSetGlobalConstant(g, True);\n+    llvm.LLVMSetLinkage(g, lib.llvm.LLVMPrivateLinkage\n+                        as llvm.Linkage);\n+    ret llvm.LLVMConstPointerCast(g, T_ptr(T_str()));\n+}\n+\n fn C_zero_byte_arr(uint size) -> ValueRef {\n     auto i = 0u;\n     let vec[ValueRef] elts = vec();\n@@ -1504,13 +1524,13 @@ fn copy_ty(@block_ctxt cx,\n     fail;\n }\n \n-fn trans_lit(@block_ctxt cx, &ast.lit lit, &ast.ann ann) -> result {\n+fn trans_lit(@crate_ctxt cx, &ast.lit lit, &ast.ann ann) -> ValueRef {\n     alt (lit.node) {\n         case (ast.lit_int(?i)) {\n-            ret res(cx, C_int(i));\n+            ret C_int(i);\n         }\n         case (ast.lit_uint(?u)) {\n-            ret res(cx, C_int(u as int));\n+            ret C_int(u as int);\n         }\n         case (ast.lit_mach_int(?tm, ?i)) {\n             // FIXME: the entire handling of mach types falls apart\n@@ -1527,32 +1547,20 @@ fn trans_lit(@block_ctxt cx, &ast.lit lit, &ast.ann ann) -> result {\n                 case (common.ty_i16) { t = T_i16(); }\n                 case (common.ty_i32) { t = T_i32(); }\n                 case (common.ty_i64) { t = T_i64(); }\n-                case (_) {\n-                    cx.fcx.ccx.sess.bug(\"bad mach int literal type\");\n-                }\n             }\n-            ret res(cx, C_integral(i, t));\n+            ret C_integral(i, t);\n         }\n         case (ast.lit_char(?c)) {\n-            ret res(cx, C_integral(c as int, T_char()));\n+            ret C_integral(c as int, T_char());\n         }\n         case (ast.lit_bool(?b)) {\n-            ret res(cx, C_bool(b));\n+            ret C_bool(b);\n         }\n         case (ast.lit_nil) {\n-            ret res(cx, C_nil());\n+            ret C_nil();\n         }\n         case (ast.lit_str(?s)) {\n-            auto len = (_str.byte_len(s) as int) + 1;\n-            auto sub = trans_upcall(cx, \"upcall_new_str\",\n-                                    vec(p2i(C_str(cx.fcx.ccx, s)),\n-                                        C_int(len)));\n-            auto val = sub.bcx.build.IntToPtr(sub.val,\n-                                              T_ptr(T_str()));\n-            auto t = node_ann_type(cx.fcx.ccx, ann);\n-            find_scope_cx(cx).cleanups +=\n-                clean(bind drop_ty(_, val, t));\n-            ret res(sub.bcx, val);\n+            ret C_str(cx, s);\n         }\n     }\n }\n@@ -2087,6 +2095,10 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                         ret lval_val(cx, cx.fcx.ccx.item_ids.get(vid));\n                     }\n                 }\n+                case (ast.def_const(?did)) {\n+                    check (cx.fcx.ccx.consts.contains_key(did));\n+                    ret lval_mem(cx, cx.fcx.ccx.consts.get(did));\n+                }\n                 case (_) {\n                     cx.fcx.ccx.sess.unimpl(\"def variant in trans\");\n                 }\n@@ -2155,8 +2167,8 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n     ix.bcx.build.CondBr(bounds_check, next_cx.llbb, fail_cx.llbb);\n \n     // fail: bad bounds check.\n-    auto V_expr_str = p2i(C_str(cx.fcx.ccx, \"out-of-bounds access\"));\n-    auto V_filename = p2i(C_str(cx.fcx.ccx, sp.filename));\n+    auto V_expr_str = p2i(C_cstr(cx.fcx.ccx, \"out-of-bounds access\"));\n+    auto V_filename = p2i(C_cstr(cx.fcx.ccx, sp.filename));\n     auto V_line = sp.lo.line as int;\n     auto args = vec(V_expr_str, V_filename, C_int(V_line));\n     auto fail_res = trans_upcall(fail_cx, \"upcall_fail\", args);\n@@ -2667,7 +2679,7 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n     alt (e.node) {\n         case (ast.expr_lit(?lit, ?ann)) {\n-            ret trans_lit(cx, *lit, ann);\n+            ret res(cx, trans_lit(cx.fcx.ccx, *lit, ann));\n         }\n \n         case (ast.expr_unary(?op, ?x, ?ann)) {\n@@ -2806,8 +2818,8 @@ fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n     auto cond_res = trans_expr(cx, e);\n \n     // FIXME: need pretty-printer.\n-    auto V_expr_str = p2i(C_str(cx.fcx.ccx, \"<expr>\"));\n-    auto V_filename = p2i(C_str(cx.fcx.ccx, e.span.filename));\n+    auto V_expr_str = p2i(C_cstr(cx.fcx.ccx, \"<expr>\"));\n+    auto V_filename = p2i(C_cstr(cx.fcx.ccx, e.span.filename));\n     auto V_line = e.span.lo.line as int;\n     auto args = vec(V_expr_str, V_filename, C_int(V_line));\n \n@@ -3495,6 +3507,37 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n     bcx.build.Ret(lltagval);\n }\n \n+// FIXME: this should do some structural hash-consing to avoid\n+// duplicate constants. I think. Maybe LLVM has a magical mode\n+// that does so later on?\n+\n+fn trans_const_expr(@crate_ctxt cx, @ast.expr e) -> ValueRef {\n+    alt (e.node) {\n+        case (ast.expr_lit(?lit, ?ann)) {\n+            ret trans_lit(cx, *lit, ann);\n+        }\n+    }\n+}\n+\n+fn trans_const(@crate_ctxt cx, @ast.expr e,\n+               &ast.def_id cid, &ast.ann ann) {\n+    auto t = node_ann_type(cx, ann);\n+    auto v = trans_const_expr(cx, e);\n+    if (ty.type_is_scalar(t)) {\n+        // The scalars come back as 1st class LLVM vals\n+        // which we have to stick into global constants.\n+        auto g = llvm.LLVMAddGlobal(cx.llmod, val_ty(v),\n+                                    _str.buf(cx.names.next(cx.path)));\n+        llvm.LLVMSetInitializer(g, v);\n+        llvm.LLVMSetGlobalConstant(g, True);\n+        llvm.LLVMSetLinkage(g, lib.llvm.LLVMPrivateLinkage\n+                            as llvm.Linkage);\n+        cx.consts.insert(cid, g);\n+    } else {\n+        cx.consts.insert(cid, v);\n+    }\n+}\n+\n fn trans_item(@crate_ctxt cx, &ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n@@ -3518,6 +3561,10 @@ fn trans_item(@crate_ctxt cx, &ast.item item) {\n                 i += 1;\n             }\n         }\n+        case (ast.item_const(?name, _, ?expr, ?cid, ?ann)) {\n+            auto sub_cx = @rec(path=cx.path + \".\" + name with *cx);\n+            trans_const(sub_cx, expr, cid, ann);\n+        }\n         case (_) { /* fall through */ }\n     }\n }\n@@ -4055,6 +4102,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n                    items = new_def_hash[@ast.item](),\n                    tags = new_def_hash[@tag_info](),\n                    fn_pairs = new_def_hash[ValueRef](),\n+                   consts = new_def_hash[ValueRef](),\n                    obj_methods = new_def_hash[()](),\n                    tydescs = tydescs,\n                    obj_fields = obj_fields,"}]}