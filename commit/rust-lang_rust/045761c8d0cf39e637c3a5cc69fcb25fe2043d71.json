{"sha": "045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NTc2MWM4ZDBjZjM5ZTYzN2MzYTVjYzY5ZmNiMjVmZTIwNDNkNzE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-23T20:10:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-23T20:10:09Z"}, "message": "Rollup merge of #73587 - marmeladema:hir-id-ification-final, r=petrochenkov\n\nMove remaining `NodeId` APIs from `Definitions` to `Resolver`\n\nImplements https://github.com/rust-lang/rust/pull/73291#issuecomment-643515557\n\nTL;DR: it moves all fields that are only needed during name resolution passes into the `Resolver` and keep the rest in `Definitions`. This effectively enforces that all references to `NodeId`s are gone once HIR lowering is completed.\n\nAfter this, the only remaining work for #50928 should be to adjust the dev guide.\n\nr? @petrochenkov", "tree": {"sha": "6f2e2e671fe521fb21ed7b2003139d2ae7a7007b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f2e2e671fe521fb21ed7b2003139d2ae7a7007b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe8mGhCRBK7hj4Ov3rIwAAdHIIABm3nm4uUs0ZR07pRpIn6e6L\nuujGQBwzol2HqTl5nBTY+V8hgC2yinIuTJYSHUyTD4a4YeSwTibe6b/4AuaIDZYZ\nWirUkk42J7zpJuwnvJ33igJ/GWLaqcs4PoYoDzrCq2oTYw/pldTzaE8qV7ATM1oK\n6rZtMLMaTuNaLJwdR9WfHV9p5mOZP3A7k89j4s8OL+RhqFOTw1ZvKZitHsYycbbE\nymcQ55n5lbb0A/PJnJYkz8EHKO8LW29l72tZcRKvkQD0SRhb9dansUIl45QlvP6b\nw60kipOdvqopUGANtzTlFywQwzYsGqdDA7JamTc1DoBXAMuPKLkQlhnzmmzHKQw=\n=FgZa\n-----END PGP SIGNATURE-----\n", "payload": "tree 6f2e2e671fe521fb21ed7b2003139d2ae7a7007b\nparent 505cf52c537c0d64ecf72e12e9853e8693b30406\nparent bd4f6f0b7d88baa9a5ecb18a2a700978ddcd58ff\nauthor Manish Goregaokar <manishsmail@gmail.com> 1592943009 -0700\ncommitter GitHub <noreply@github.com> 1592943009 -0700\n\nRollup merge of #73587 - marmeladema:hir-id-ification-final, r=petrochenkov\n\nMove remaining `NodeId` APIs from `Definitions` to `Resolver`\n\nImplements https://github.com/rust-lang/rust/pull/73291#issuecomment-643515557\n\nTL;DR: it moves all fields that are only needed during name resolution passes into the `Resolver` and keep the rest in `Definitions`. This effectively enforces that all references to `NodeId`s are gone once HIR lowering is completed.\n\nAfter this, the only remaining work for #50928 should be to adjust the dev guide.\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "html_url": "https://github.com/rust-lang/rust/commit/045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "505cf52c537c0d64ecf72e12e9853e8693b30406", "url": "https://api.github.com/repos/rust-lang/rust/commits/505cf52c537c0d64ecf72e12e9853e8693b30406", "html_url": "https://github.com/rust-lang/rust/commit/505cf52c537c0d64ecf72e12e9853e8693b30406"}, {"sha": "bd4f6f0b7d88baa9a5ecb18a2a700978ddcd58ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd4f6f0b7d88baa9a5ecb18a2a700978ddcd58ff", "html_url": "https://github.com/rust-lang/rust/commit/bd4f6f0b7d88baa9a5ecb18a2a700978ddcd58ff"}], "stats": {"total": 500, "additions": 258, "deletions": 242}, "files": [{"sha": "b54566e7176b0db24feae34fda0f743323ecd4ea", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -4200,6 +4200,7 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_feature\",\n  \"rustc_hir\",\n+ \"rustc_index\",\n  \"rustc_metadata\",\n  \"rustc_middle\",\n  \"rustc_session\","}, {"sha": "00665c4cafb6b4d24d23c180cddeecaa52cd0414", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -253,7 +253,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 hir::ItemKind::Const(ty, body_id)\n             }\n             ItemKind::Fn(_, FnSig { ref decl, header }, ref generics, ref body) => {\n-                let fn_def_id = self.resolver.definitions().local_def_id(id);\n+                let fn_def_id = self.resolver.local_def_id(id);\n                 self.with_new_scopes(|this| {\n                     this.current_item = Some(ident.span);\n \n@@ -342,7 +342,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self_ty: ref ty,\n                 items: ref impl_items,\n             } => {\n-                let def_id = self.resolver.definitions().local_def_id(id);\n+                let def_id = self.resolver.local_def_id(id);\n \n                 // Lower the \"impl header\" first. This ordering is important\n                 // for in-band lifetimes! Consider `'a` here:\n@@ -646,7 +646,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem<'hir> {\n-        let def_id = self.resolver.definitions().local_def_id(i.id);\n+        let def_id = self.resolver.local_def_id(i.id);\n         hir::ForeignItem {\n             hir_id: self.lower_node_id(i.id),\n             ident: i.ident,\n@@ -747,7 +747,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_trait_item(&mut self, i: &AssocItem) -> hir::TraitItem<'hir> {\n-        let trait_item_def_id = self.resolver.definitions().local_def_id(i.id);\n+        let trait_item_def_id = self.resolver.local_def_id(i.id);\n \n         let (generics, kind) = match i.kind {\n             AssocItemKind::Const(_, ref ty, ref default) => {\n@@ -812,7 +812,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_impl_item(&mut self, i: &AssocItem) -> hir::ImplItem<'hir> {\n-        let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n+        let impl_item_def_id = self.resolver.local_def_id(i.id);\n \n         let (generics, kind) = match &i.kind {\n             AssocItemKind::Const(_, ty, expr) => {\n@@ -1320,12 +1320,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                                     if let Some(def_id) = def_id.as_local() {\n                                         for param in &generics.params {\n                                             if let GenericParamKind::Type { .. } = param.kind {\n-                                                if def_id\n-                                                    == self\n-                                                        .resolver\n-                                                        .definitions()\n-                                                        .local_def_id(param.id)\n-                                                {\n+                                                if def_id == self.resolver.local_def_id(param.id) {\n                                                     add_bounds\n                                                         .entry(param.id)\n                                                         .or_default()"}, {"sha": "39b14ac4588326dd66ca3b520d5d4b3edb496381", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -54,7 +54,7 @@ use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n use rustc_hir::intravisit;\n use rustc_hir::{ConstArg, GenericArg, ParamName};\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_session::config::nightly_options;\n use rustc_session::lint::{builtin::BARE_TRAIT_OBJECTS, BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::parse::ParseSess;\n@@ -205,6 +205,19 @@ pub trait Resolver {\n     fn next_node_id(&mut self) -> NodeId;\n \n     fn trait_map(&self) -> &NodeMap<Vec<hir::TraitCandidate>>;\n+\n+    fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId>;\n+\n+    fn local_def_id(&self, node: NodeId) -> LocalDefId;\n+\n+    fn create_def(\n+        &mut self,\n+        parent: LocalDefId,\n+        node_id: ast::NodeId,\n+        data: DefPathData,\n+        expn_id: ExpnId,\n+        span: Span,\n+    ) -> LocalDefId;\n }\n \n type NtToTokenstream = fn(&Nonterminal, &ParseSess, Span) -> TokenStream;\n@@ -436,7 +449,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 match tree.kind {\n                     UseTreeKind::Simple(_, id1, id2) => {\n                         for &id in &[id1, id2] {\n-                            self.lctx.resolver.definitions().create_def_with_parent(\n+                            self.lctx.resolver.create_def(\n                                 owner,\n                                 id,\n                                 DefPathData::Misc,\n@@ -488,7 +501,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     | ItemKind::Enum(_, ref generics)\n                     | ItemKind::TyAlias(_, ref generics, ..)\n                     | ItemKind::Trait(_, _, ref generics, ..) => {\n-                        let def_id = self.lctx.resolver.definitions().local_def_id(item.id);\n+                        let def_id = self.lctx.resolver.local_def_id(item.id);\n                         let count = generics\n                             .params\n                             .iter()\n@@ -564,7 +577,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .map(|(&k, v)| (self.node_id_to_hir_id[k].unwrap(), v.clone()))\n             .collect();\n \n-        self.resolver.definitions().init_node_id_to_hir_id_mapping(self.node_id_to_hir_id);\n+        let mut def_id_to_hir_id = IndexVec::default();\n+\n+        for (node_id, hir_id) in self.node_id_to_hir_id.into_iter_enumerated() {\n+            if let Some(def_id) = self.resolver.opt_local_def_id(node_id) {\n+                if def_id_to_hir_id.len() <= def_id.index() {\n+                    def_id_to_hir_id.resize(def_id.index() + 1, None);\n+                }\n+                def_id_to_hir_id[def_id] = hir_id;\n+            }\n+        }\n+\n+        self.resolver.definitions().init_def_id_to_hir_id_mapping(def_id_to_hir_id);\n \n         hir::Crate {\n             item: hir::CrateItem { module, attrs, span: c.span },\n@@ -628,7 +652,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .item_local_id_counters\n             .insert(owner, HIR_ID_COUNTER_LOCKED)\n             .unwrap_or_else(|| panic!(\"no `item_local_id_counters` entry for {:?}\", owner));\n-        let def_id = self.resolver.definitions().local_def_id(owner);\n+        let def_id = self.resolver.local_def_id(owner);\n         self.current_hir_id_owner.push((def_id, counter));\n         let ret = f(self);\n         let (new_def_id, new_counter) = self.current_hir_id_owner.pop().unwrap();\n@@ -671,8 +695,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             debug_assert!(local_id != HIR_ID_COUNTER_LOCKED);\n \n             *local_id_counter += 1;\n-            let owner = this.resolver.definitions().opt_local_def_id(owner).expect(\n-                \"you forgot to call `create_def_with_parent` or are lowering node-IDs \\\n+            let owner = this.resolver.opt_local_def_id(owner).expect(\n+                \"you forgot to call `create_def` or are lowering node-IDs \\\n                  that do not belong to the current owner\",\n             );\n \n@@ -800,7 +824,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         };\n \n         // Add a definition for the in-band lifetime def.\n-        self.resolver.definitions().create_def_with_parent(\n+        self.resolver.create_def(\n             parent_def_id,\n             node_id,\n             DefPathData::LifetimeNs(str_name),\n@@ -1088,7 +1112,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                     let impl_trait_node_id = self.resolver.next_node_id();\n                     let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n-                    self.resolver.definitions().create_def_with_parent(\n+                    self.resolver.create_def(\n                         parent_def_id,\n                         impl_trait_node_id,\n                         DefPathData::ImplTrait,\n@@ -1154,7 +1178,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             let node_id = self.resolver.next_node_id();\n \n                             // Add a definition for the in-band const def.\n-                            self.resolver.definitions().create_def_with_parent(\n+                            self.resolver.create_def(\n                                 parent_def_id,\n                                 node_id,\n                                 DefPathData::AnonConst,\n@@ -1339,7 +1363,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                     ImplTraitContext::Universal(in_band_ty_params) => {\n                         // Add a definition for the in-band `Param`.\n-                        let def_id = self.resolver.definitions().local_def_id(def_node_id);\n+                        let def_id = self.resolver.local_def_id(def_node_id);\n \n                         let hir_bounds = self.lower_param_bounds(\n                             bounds,\n@@ -1428,7 +1452,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // frequently opened issues show.\n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::OpaqueTy, span, None);\n \n-        let opaque_ty_def_id = self.resolver.definitions().local_def_id(opaque_ty_node_id);\n+        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n \n         self.allocate_hir_id_counter(opaque_ty_node_id);\n \n@@ -1620,7 +1644,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     let def_node_id = self.context.resolver.next_node_id();\n                     let hir_id =\n                         self.context.lower_node_id_with_owner(def_node_id, self.opaque_ty_id);\n-                    self.context.resolver.definitions().create_def_with_parent(\n+                    self.context.resolver.create_def(\n                         self.parent,\n                         def_node_id,\n                         DefPathData::LifetimeNs(name.ident().name),\n@@ -1870,7 +1894,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-        let opaque_ty_def_id = self.resolver.definitions().local_def_id(opaque_ty_node_id);\n+        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n \n         self.allocate_hir_id_counter(opaque_ty_node_id);\n "}, {"sha": "79b70682739326b1ea18c4254e7cbc83fbade8d1", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 30, "deletions": 119, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -8,14 +8,12 @@ pub use crate::def_id::DefPathHash;\n use crate::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use crate::hir;\n \n-use rustc_ast::ast;\n use rustc_ast::crate_disambiguator::CrateDisambiguator;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_index::vec::IndexVec;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::Span;\n \n use log::debug;\n use std::fmt::Write;\n@@ -73,17 +71,12 @@ impl DefPathTable {\n }\n \n /// The definition table containing node definitions.\n-/// It holds the `DefPathTable` for local `DefId`s/`DefPath`s and it also stores a\n-/// mapping from `NodeId`s to local `DefId`s.\n-#[derive(Clone, Default)]\n+/// It holds the `DefPathTable` for `LocalDefId`s/`DefPath`s.\n+/// It also stores mappings to convert `LocalDefId`s to/from `HirId`s.\n+#[derive(Clone)]\n pub struct Definitions {\n     table: DefPathTable,\n \n-    def_id_to_span: IndexVec<LocalDefId, Span>,\n-\n-    node_id_to_def_id: FxHashMap<ast::NodeId, LocalDefId>,\n-    def_id_to_node_id: IndexVec<LocalDefId, ast::NodeId>,\n-\n     // FIXME(eddyb) ideally all `LocalDefId`s would be HIR owners.\n     pub(super) def_id_to_hir_id: IndexVec<LocalDefId, Option<hir::HirId>>,\n     /// The reverse mapping of `def_id_to_hir_id`.\n@@ -94,12 +87,6 @@ pub struct Definitions {\n     parent_modules_of_macro_defs: FxHashMap<ExpnId, DefId>,\n     /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n     expansions_that_defined: FxHashMap<LocalDefId, ExpnId>,\n-    next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,\n-    /// When collecting definitions from an AST fragment produced by a macro invocation `ExpnId`\n-    /// we know what parent node that fragment should be attached to thanks to this table.\n-    invocation_parents: FxHashMap<ExpnId, LocalDefId>,\n-    /// Indices of unnamed struct or variant fields with unresolved attributes.\n-    placeholder_field_indices: FxHashMap<ast::NodeId, usize>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -319,16 +306,6 @@ impl Definitions {\n         })\n     }\n \n-    #[inline]\n-    pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<LocalDefId> {\n-        self.node_id_to_def_id.get(&node).copied()\n-    }\n-\n-    #[inline]\n-    pub fn local_def_id(&self, node: ast::NodeId) -> LocalDefId {\n-        self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n-    }\n-\n     #[inline]\n     pub fn as_local_hir_id(&self, def_id: LocalDefId) -> hir::HirId {\n         self.local_def_id_to_hir_id(def_id)\n@@ -349,18 +326,8 @@ impl Definitions {\n         self.hir_id_to_def_id.get(&hir_id).copied()\n     }\n \n-    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n-    #[inline]\n-    pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n-        if let Some(def_id) = def_id.as_local() { Some(self.def_id_to_span[def_id]) } else { None }\n-    }\n-\n     /// Adds a root definition (no parent) and a few other reserved definitions.\n-    pub fn create_root_def(\n-        &mut self,\n-        crate_name: &str,\n-        crate_disambiguator: CrateDisambiguator,\n-    ) -> LocalDefId {\n+    pub fn new(crate_name: &str, crate_disambiguator: CrateDisambiguator) -> Definitions {\n         let key = DefKey {\n             parent: None,\n             disambiguated_data: DisambiguatedDefPathData {\n@@ -372,52 +339,39 @@ impl Definitions {\n         let parent_hash = DefKey::root_parent_stable_hash(crate_name, crate_disambiguator);\n         let def_path_hash = key.compute_stable_hash(parent_hash);\n \n-        // Create the definition.\n-        let root = LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) };\n+        // Create the root definition.\n+        let mut table = DefPathTable::default();\n+        let root = LocalDefId { local_def_index: table.allocate(key, def_path_hash) };\n         assert_eq!(root.local_def_index, CRATE_DEF_INDEX);\n \n-        assert_eq!(self.def_id_to_node_id.push(ast::CRATE_NODE_ID), root);\n-        assert_eq!(self.def_id_to_span.push(rustc_span::DUMMY_SP), root);\n-\n-        self.node_id_to_def_id.insert(ast::CRATE_NODE_ID, root);\n-        self.set_invocation_parent(ExpnId::root(), root);\n+        Definitions {\n+            table,\n+            def_id_to_hir_id: Default::default(),\n+            hir_id_to_def_id: Default::default(),\n+            expansions_that_defined: Default::default(),\n+            parent_modules_of_macro_defs: Default::default(),\n+        }\n+    }\n \n-        root\n+    /// Retrieves the root definition.\n+    pub fn get_root_def(&self) -> LocalDefId {\n+        LocalDefId { local_def_index: CRATE_DEF_INDEX }\n     }\n \n     /// Adds a definition with a parent definition.\n-    pub fn create_def_with_parent(\n+    pub fn create_def(\n         &mut self,\n         parent: LocalDefId,\n-        node_id: ast::NodeId,\n         data: DefPathData,\n         expn_id: ExpnId,\n-        span: Span,\n+        mut next_disambiguator: impl FnMut(LocalDefId, DefPathData) -> u32,\n     ) -> LocalDefId {\n-        debug!(\n-            \"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n-            parent, node_id, data\n-        );\n-\n-        assert!(\n-            !self.node_id_to_def_id.contains_key(&node_id),\n-            \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n-            node_id,\n-            data,\n-            self.table.def_key(self.node_id_to_def_id[&node_id].local_def_index),\n-        );\n+        debug!(\"create_def(parent={:?}, data={:?}, expn_id={:?})\", parent, data, expn_id);\n \n         // The root node must be created with `create_root_def()`.\n         assert!(data != DefPathData::CrateRoot);\n \n-        // Find the next free disambiguator for this key.\n-        let disambiguator = {\n-            let next_disamb = self.next_disambiguator.entry((parent, data)).or_insert(0);\n-            let disambiguator = *next_disamb;\n-            *next_disamb = next_disamb.checked_add(1).expect(\"disambiguator overflow\");\n-            disambiguator\n-        };\n-\n+        let disambiguator = next_disambiguator(parent, data);\n         let key = DefKey {\n             parent: Some(parent.local_def_index),\n             disambiguated_data: DisambiguatedDefPathData { data, disambiguator },\n@@ -426,55 +380,36 @@ impl Definitions {\n         let parent_hash = self.table.def_path_hash(parent.local_def_index);\n         let def_path_hash = key.compute_stable_hash(parent_hash);\n \n-        debug!(\"create_def_with_parent: after disambiguation, key = {:?}\", key);\n+        debug!(\"create_def: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n         let def_id = LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) };\n \n-        assert_eq!(self.def_id_to_node_id.push(node_id), def_id);\n-        assert_eq!(self.def_id_to_span.push(span), def_id);\n-\n-        // Some things for which we allocate `LocalDefId`s don't correspond to\n-        // anything in the AST, so they don't have a `NodeId`. For these cases\n-        // we don't need a mapping from `NodeId` to `LocalDefId`.\n-        if node_id != ast::DUMMY_NODE_ID {\n-            debug!(\"create_def_with_parent: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n-            self.node_id_to_def_id.insert(node_id, def_id);\n-        }\n-\n         if expn_id != ExpnId::root() {\n             self.expansions_that_defined.insert(def_id, expn_id);\n         }\n \n         def_id\n     }\n \n-    /// Initializes the `ast::NodeId` to `HirId` mapping once it has been generated during\n+    /// Initializes the `LocalDefId` to `HirId` mapping once it has been generated during\n     /// AST to HIR lowering.\n-    pub fn init_node_id_to_hir_id_mapping(\n+    pub fn init_def_id_to_hir_id_mapping(\n         &mut self,\n-        mapping: IndexVec<ast::NodeId, Option<hir::HirId>>,\n+        mapping: IndexVec<LocalDefId, Option<hir::HirId>>,\n     ) {\n         assert!(\n             self.def_id_to_hir_id.is_empty(),\n             \"trying to initialize `LocalDefId` <-> `HirId` mappings twice\"\n         );\n \n-        self.def_id_to_hir_id = self\n-            .def_id_to_node_id\n-            .iter()\n-            .map(|&node_id| mapping.get(node_id).and_then(|&hir_id| hir_id))\n-            .collect();\n-\n         // Build the reverse mapping of `def_id_to_hir_id`.\n         self.hir_id_to_def_id = mapping\n-            .into_iter_enumerated()\n-            .filter_map(|(node_id, hir_id)| {\n-                hir_id.and_then(|hir_id| {\n-                    self.node_id_to_def_id.get(&node_id).map(|&def_id| (hir_id, def_id))\n-                })\n-            })\n+            .iter_enumerated()\n+            .filter_map(|(def_id, hir_id)| hir_id.map(|hir_id| (hir_id, def_id)))\n             .collect();\n+\n+        self.def_id_to_hir_id = mapping;\n     }\n \n     pub fn expansion_that_defined(&self, id: LocalDefId) -> ExpnId {\n@@ -488,30 +423,6 @@ impl Definitions {\n     pub fn add_parent_module_of_macro_def(&mut self, expn_id: ExpnId, module: DefId) {\n         self.parent_modules_of_macro_defs.insert(expn_id, module);\n     }\n-\n-    pub fn invocation_parent(&self, invoc_id: ExpnId) -> LocalDefId {\n-        self.invocation_parents[&invoc_id]\n-    }\n-\n-    pub fn set_invocation_parent(&mut self, invoc_id: ExpnId, parent: LocalDefId) {\n-        let old_parent = self.invocation_parents.insert(invoc_id, parent);\n-        assert!(old_parent.is_none(), \"parent `LocalDefId` is reset for an invocation\");\n-    }\n-\n-    pub fn placeholder_field_index(&self, node_id: ast::NodeId) -> usize {\n-        self.placeholder_field_indices[&node_id]\n-    }\n-\n-    pub fn set_placeholder_field_index(&mut self, node_id: ast::NodeId, index: usize) {\n-        let old_index = self.placeholder_field_indices.insert(node_id, index);\n-        assert!(old_index.is_none(), \"placeholder field index is reset for a node ID\");\n-    }\n-\n-    pub fn lint_node_id(&mut self, expn_id: ExpnId) -> ast::NodeId {\n-        self.invocation_parents\n-            .get(&expn_id)\n-            .map_or(ast::CRATE_NODE_ID, |id| self.def_id_to_node_id[*id])\n-    }\n }\n \n impl DefPathData {"}, {"sha": "e9a4119f4a3332e43edb5890a25d87c8d61ca9eb", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -737,7 +737,10 @@ pub fn create_global_ctxt<'tcx>(\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n ) -> QueryContext<'tcx> {\n     let sess = &compiler.session();\n-    let defs: &'tcx Definitions = arena.alloc(mem::take(&mut resolver_outputs.definitions));\n+    let defs: &'tcx Definitions = arena.alloc(mem::replace(\n+        &mut resolver_outputs.definitions,\n+        Definitions::new(crate_name, sess.local_crate_disambiguator()),\n+    ));\n \n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n "}, {"sha": "2c80c846681a66e60eba35f04fca53d0e5f40289", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n use rustc_expand::base::SyntaxExtension;\n-use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::cstore::DepKind;\n@@ -896,6 +896,7 @@ impl<'a> CrateLoader<'a> {\n         &mut self,\n         item: &ast::Item,\n         definitions: &Definitions,\n+        def_id: LocalDefId,\n     ) -> CrateNum {\n         match item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n@@ -918,7 +919,6 @@ impl<'a> CrateLoader<'a> {\n \n                 let cnum = self.resolve_crate(name, item.span, dep_kind, None);\n \n-                let def_id = definitions.opt_local_def_id(item.id).unwrap();\n                 let path_len = definitions.def_path(def_id).data.len();\n                 self.update_extern_crate(\n                     cnum,"}, {"sha": "6f6104c3d6932f5783edb6156444b713bc368a4f", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -24,6 +24,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_expand = { path = \"../librustc_expand\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_index = { path = \"../librustc_index\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }"}, {"sha": "ef43f597eab4754df4325d7e1cb6ab9893be50fb", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -19,6 +19,7 @@ use rustc_ast::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind,\n use rustc_ast::ast::{AssocItem, AssocItemKind, MetaItemKind, StmtKind};\n use rustc_ast::token::{self, Token};\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_attr as attr;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability};\n@@ -171,7 +172,7 @@ impl<'a> Resolver<'a> {\n         fragment: &AstFragment,\n         parent_scope: ParentScope<'a>,\n     ) -> MacroRulesScope<'a> {\n-        collect_definitions(&mut self.definitions, fragment, parent_scope.expansion);\n+        collect_definitions(self, fragment, parent_scope.expansion);\n         let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n         fragment.visit_with(&mut visitor);\n         visitor.parent_scope.macro_rules\n@@ -647,9 +648,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 } else if orig_name == Some(kw::SelfLower) {\n                     self.r.graph_root\n                 } else {\n-                    let def_id = self.r.definitions.local_def_id(item.id);\n+                    let def_id = self.r.local_def_id(item.id);\n                     let crate_id =\n-                        self.r.crate_loader.process_extern_crate(item, &self.r.definitions);\n+                        self.r.crate_loader.process_extern_crate(item, &self.r.definitions, def_id);\n                     self.r.extern_crate_map.insert(def_id, crate_id);\n                     self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n@@ -704,7 +705,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             ItemKind::Mod(..) if ident.name == kw::Invalid => {} // Crate root\n \n             ItemKind::Mod(..) => {\n-                let def_id = self.r.definitions.local_def_id(item.id);\n+                let def_id = self.r.local_def_id(item.id);\n                 let module_kind = ModuleKind::Def(DefKind::Mod, def_id.to_def_id(), ident.name);\n                 let module = self.r.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n@@ -727,18 +728,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n             // These items live in the value namespace.\n             ItemKind::Static(..) => {\n-                let res =\n-                    Res::Def(DefKind::Static, self.r.definitions.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::Static, self.r.local_def_id(item.id).to_def_id());\n                 self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n-                let res =\n-                    Res::Def(DefKind::Const, self.r.definitions.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::Const, self.r.local_def_id(item.id).to_def_id());\n                 self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n-                let res =\n-                    Res::Def(DefKind::Fn, self.r.definitions.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::Fn, self.r.local_def_id(item.id).to_def_id());\n                 self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n \n                 // Functions introducing procedural macros reserve a slot\n@@ -748,15 +746,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n             // These items live in the type namespace.\n             ItemKind::TyAlias(..) => {\n-                let res = Res::Def(\n-                    DefKind::TyAlias,\n-                    self.r.definitions.local_def_id(item.id).to_def_id(),\n-                );\n+                let res = Res::Def(DefKind::TyAlias, self.r.local_def_id(item.id).to_def_id());\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(_, _) => {\n-                let def_id = self.r.definitions.local_def_id(item.id).to_def_id();\n+                let def_id = self.r.local_def_id(item.id).to_def_id();\n                 self.r.variant_vis.insert(def_id, vis);\n                 let module_kind = ModuleKind::Def(DefKind::Enum, def_id, ident.name);\n                 let module = self.r.new_module(\n@@ -771,17 +766,14 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             ItemKind::TraitAlias(..) => {\n-                let res = Res::Def(\n-                    DefKind::TraitAlias,\n-                    self.r.definitions.local_def_id(item.id).to_def_id(),\n-                );\n+                let res = Res::Def(DefKind::TraitAlias, self.r.local_def_id(item.id).to_def_id());\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             // These items live in both the type and value namespaces.\n             ItemKind::Struct(ref vdata, _) => {\n                 // Define a name in the type namespace.\n-                let def_id = self.r.definitions.local_def_id(item.id).to_def_id();\n+                let def_id = self.r.local_def_id(item.id).to_def_id();\n                 let res = Res::Def(DefKind::Struct, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n@@ -814,15 +806,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     }\n                     let ctor_res = Res::Def(\n                         DefKind::Ctor(CtorOf::Struct, CtorKind::from_ast(vdata)),\n-                        self.r.definitions.local_def_id(ctor_node_id).to_def_id(),\n+                        self.r.local_def_id(ctor_node_id).to_def_id(),\n                     );\n                     self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, sp, expansion));\n                     self.r.struct_constructors.insert(def_id, (ctor_res, ctor_vis));\n                 }\n             }\n \n             ItemKind::Union(ref vdata, _) => {\n-                let def_id = self.r.definitions.local_def_id(item.id).to_def_id();\n+                let def_id = self.r.local_def_id(item.id).to_def_id();\n                 let res = Res::Def(DefKind::Union, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n@@ -831,7 +823,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             ItemKind::Trait(..) => {\n-                let def_id = self.r.definitions.local_def_id(item.id).to_def_id();\n+                let def_id = self.r.local_def_id(item.id).to_def_id();\n \n                 // Add all the items within to a new module.\n                 let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n@@ -856,18 +848,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem) {\n         let (res, ns) = match item.kind {\n-            ForeignItemKind::Fn(..) => (\n-                Res::Def(DefKind::Fn, self.r.definitions.local_def_id(item.id).to_def_id()),\n-                ValueNS,\n-            ),\n-            ForeignItemKind::Static(..) => (\n-                Res::Def(DefKind::Static, self.r.definitions.local_def_id(item.id).to_def_id()),\n-                ValueNS,\n-            ),\n-            ForeignItemKind::TyAlias(..) => (\n-                Res::Def(DefKind::ForeignTy, self.r.definitions.local_def_id(item.id).to_def_id()),\n-                TypeNS,\n-            ),\n+            ForeignItemKind::Fn(..) => {\n+                (Res::Def(DefKind::Fn, self.r.local_def_id(item.id).to_def_id()), ValueNS)\n+            }\n+            ForeignItemKind::Static(..) => {\n+                (Res::Def(DefKind::Static, self.r.local_def_id(item.id).to_def_id()), ValueNS)\n+            }\n+            ForeignItemKind::TyAlias(..) => {\n+                (Res::Def(DefKind::ForeignTy, self.r.local_def_id(item.id).to_def_id()), TypeNS)\n+            }\n             ForeignItemKind::MacCall(_) => unreachable!(),\n         };\n         let parent = self.parent_scope.module;\n@@ -1170,7 +1159,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn define_macro(&mut self, item: &ast::Item) -> MacroRulesScope<'a> {\n         let parent_scope = self.parent_scope;\n         let expansion = parent_scope.expansion;\n-        let def_id = self.r.definitions.local_def_id(item.id);\n+        let def_id = self.r.local_def_id(item.id);\n         let (ext, ident, span, macro_rules) = match &item.kind {\n             ItemKind::MacroDef(def) => {\n                 let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n@@ -1315,7 +1304,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         }\n \n         // Add the item to the trait info.\n-        let item_def_id = self.r.definitions.local_def_id(item.id).to_def_id();\n+        let item_def_id = self.r.local_def_id(item.id).to_def_id();\n         let (res, ns) = match item.kind {\n             AssocItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n             AssocItemKind::Fn(_, ref sig, _, _) => {\n@@ -1417,7 +1406,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         let ident = variant.ident;\n \n         // Define a name in the type namespace.\n-        let def_id = self.r.definitions.local_def_id(variant.id).to_def_id();\n+        let def_id = self.r.local_def_id(variant.id).to_def_id();\n         let res = Res::Def(DefKind::Variant, def_id);\n         self.r.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n \n@@ -1435,7 +1424,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         // It's ok to use the variant's id as a ctor id since an\n         // error will be reported on any use of such resolution anyway.\n         let ctor_node_id = variant.data.ctor_id().unwrap_or(variant.id);\n-        let ctor_def_id = self.r.definitions.local_def_id(ctor_node_id).to_def_id();\n+        let ctor_def_id = self.r.local_def_id(ctor_node_id).to_def_id();\n         let ctor_kind = CtorKind::from_ast(&variant.data);\n         let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n         self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expn_id));"}, {"sha": "0ca01a384e73ef108313f9c00cf942c1b9014fa9", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -29,6 +29,7 @@ use crate::Resolver;\n use rustc_ast::ast;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::visit::{self, Visitor};\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::pluralize;\n use rustc_middle::ty;\n@@ -64,7 +65,7 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     fn check_import(&mut self, id: ast::NodeId) {\n         let mut used = false;\n         self.r.per_ns(|this, ns| used |= this.used_imports.contains(&(id, ns)));\n-        let def_id = self.r.definitions.local_def_id(id);\n+        let def_id = self.r.local_def_id(id);\n         if !used {\n             if self.r.maybe_unused_trait_imports.contains(&def_id) {\n                 // Check later.\n@@ -246,7 +247,7 @@ impl Resolver<'_> {\n                     }\n                 }\n                 ImportKind::ExternCrate { .. } => {\n-                    let def_id = self.definitions.local_def_id(import.id);\n+                    let def_id = self.local_def_id(import.id);\n                     self.maybe_unused_extern_crates.push((def_id, import.span));\n                 }\n                 ImportKind::MacroUse => {"}, {"sha": "f1063f42c91ecb295ea84920ca14f288ea1eff60", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -1,8 +1,10 @@\n+use crate::Resolver;\n use log::debug;\n use rustc_ast::ast::*;\n use rustc_ast::token::{self, Token};\n use rustc_ast::visit::{self, FnKind};\n use rustc_ast::walk_list;\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_expand::expand::AstFragment;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::definitions::*;\n@@ -11,26 +13,26 @@ use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n \n crate fn collect_definitions(\n-    definitions: &mut Definitions,\n+    resolver: &mut Resolver<'_>,\n     fragment: &AstFragment,\n     expansion: ExpnId,\n ) {\n-    let parent_def = definitions.invocation_parent(expansion);\n-    fragment.visit_with(&mut DefCollector { definitions, parent_def, expansion });\n+    let parent_def = resolver.invocation_parents[&expansion];\n+    fragment.visit_with(&mut DefCollector { resolver, parent_def, expansion });\n }\n \n /// Creates `DefId`s for nodes in the AST.\n-struct DefCollector<'a> {\n-    definitions: &'a mut Definitions,\n+struct DefCollector<'a, 'b> {\n+    resolver: &'a mut Resolver<'b>,\n     parent_def: LocalDefId,\n     expansion: ExpnId,\n }\n \n-impl<'a> DefCollector<'a> {\n+impl<'a, 'b> DefCollector<'a, 'b> {\n     fn create_def(&mut self, node_id: NodeId, data: DefPathData, span: Span) -> LocalDefId {\n         let parent_def = self.parent_def;\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n-        self.definitions.create_def_with_parent(parent_def, node_id, data, self.expansion, span)\n+        self.resolver.create_def(parent_def, node_id, data, self.expansion, span)\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: LocalDefId, f: F) {\n@@ -43,12 +45,13 @@ impl<'a> DefCollector<'a> {\n         let index = |this: &Self| {\n             index.unwrap_or_else(|| {\n                 let node_id = NodeId::placeholder_from_expn_id(this.expansion);\n-                this.definitions.placeholder_field_index(node_id)\n+                this.resolver.placeholder_field_indices[&node_id]\n             })\n         };\n \n         if field.is_placeholder {\n-            self.definitions.set_placeholder_field_index(field.id, index(self));\n+            let old_index = self.resolver.placeholder_field_indices.insert(field.id, index(self));\n+            assert!(old_index.is_none(), \"placeholder field index is reset for a node ID\");\n             self.visit_macro_invoc(field.id);\n         } else {\n             let name = field.ident.map_or_else(|| sym::integer(index(self)), |ident| ident.name);\n@@ -58,11 +61,13 @@ impl<'a> DefCollector<'a> {\n     }\n \n     fn visit_macro_invoc(&mut self, id: NodeId) {\n-        self.definitions.set_invocation_parent(id.placeholder_to_expn_id(), self.parent_def);\n+        let old_parent =\n+            self.resolver.invocation_parents.insert(id.placeholder_to_expn_id(), self.parent_def);\n+        assert!(old_parent.is_none(), \"parent `LocalDefId` is reset for an invocation\");\n     }\n }\n \n-impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n+impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n     fn visit_item(&mut self, i: &'a Item) {\n         debug!(\"visit_item: {:?}\", i);\n "}, {"sha": "afe96ca7007817bd6f1bb4690d36fa9935c92cc2", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -108,7 +108,7 @@ impl<'a> Resolver<'a> {\n                 match outer_res {\n                     Res::SelfTy(maybe_trait_defid, maybe_impl_defid) => {\n                         if let Some(impl_span) =\n-                            maybe_impl_defid.and_then(|def_id| self.definitions.opt_span(def_id))\n+                            maybe_impl_defid.and_then(|def_id| self.opt_span(def_id))\n                         {\n                             err.span_label(\n                                 reduce_impl_span_to_impl_keyword(sm, impl_span),\n@@ -127,12 +127,12 @@ impl<'a> Resolver<'a> {\n                         return err;\n                     }\n                     Res::Def(DefKind::TyParam, def_id) => {\n-                        if let Some(span) = self.definitions.opt_span(def_id) {\n+                        if let Some(span) = self.opt_span(def_id) {\n                             err.span_label(span, \"type parameter from outer function\");\n                         }\n                     }\n                     Res::Def(DefKind::ConstParam, def_id) => {\n-                        if let Some(span) = self.definitions.opt_span(def_id) {\n+                        if let Some(span) = self.opt_span(def_id) {\n                             err.span_label(span, \"const parameter from outer function\");\n                         }\n                     }\n@@ -846,7 +846,7 @@ impl<'a> Resolver<'a> {\n                 Applicability::MaybeIncorrect,\n             );\n             let def_span = suggestion.res.opt_def_id().and_then(|def_id| match def_id.krate {\n-                LOCAL_CRATE => self.definitions.opt_span(def_id),\n+                LOCAL_CRATE => self.opt_span(def_id),\n                 _ => Some(\n                     self.session\n                         .source_map()"}, {"sha": "8a6541b399e381e8ff8e746978f26300e2f012b7", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -12,6 +12,7 @@ use crate::{NameBinding, NameBindingKind, PathResult, PrivacyError, ToNameBindin\n use rustc_ast::ast::NodeId;\n use rustc_ast::unwrap_or;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::ptr_key::PtrKey;\n use rustc_errors::{pluralize, struct_span_err, Applicability};\n@@ -1393,7 +1394,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             let is_good_import =\n                 binding.is_import() && !binding.is_ambiguity() && !ident.span.from_expansion();\n             if is_good_import || binding.is_macro_def() {\n-                let res = binding.res().map_id(|id| this.definitions.local_def_id(id));\n+                let res = binding.res().map_id(|id| this.local_def_id(id));\n                 if res != def::Res::Err {\n                     reexports.push(Export { ident, res, span: binding.span, vis: binding.vis });\n                 }"}, {"sha": "6f769c3c59cae6fda1efdecd28104866d245ddea", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -16,6 +16,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::{unwrap_or, walk_list};\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::DiagnosticId;\n use rustc_hir::def::Namespace::{self, *};\n@@ -707,7 +708,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn with_scope<T>(&mut self, id: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let id = self.r.definitions.local_def_id(id);\n+        let id = self.r.local_def_id(id);\n         let module = self.r.module_map.get(&id).cloned(); // clones a reference\n         if let Some(module) = module {\n             // Move down in the graph.\n@@ -759,7 +760,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         debug!(\"resolve_adt\");\n         self.with_current_self_item(item, |this| {\n             this.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                let item_def_id = this.r.definitions.local_def_id(item.id).to_def_id();\n+                let item_def_id = this.r.local_def_id(item.id).to_def_id();\n                 this.with_self_rib(Res::SelfTy(None, Some(item_def_id)), |this| {\n                     visit::walk_item(this, item);\n                 });\n@@ -839,7 +840,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ItemKind::Trait(.., ref generics, ref bounds, ref trait_items) => {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                    let local_def_id = this.r.definitions.local_def_id(item.id).to_def_id();\n+                    let local_def_id = this.r.local_def_id(item.id).to_def_id();\n                     this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_param_bound, bounds);\n@@ -880,7 +881,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ItemKind::TraitAlias(ref generics, ref bounds) => {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                    let local_def_id = this.r.definitions.local_def_id(item.id).to_def_id();\n+                    let local_def_id = this.r.local_def_id(item.id).to_def_id();\n                     this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_param_bound, bounds);\n@@ -961,7 +962,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             seen_bindings.entry(ident).or_insert(param.ident.span);\n \n             // Plain insert (no renaming).\n-            let res = Res::Def(def_kind, self.r.definitions.local_def_id(param.id).to_def_id());\n+            let res = Res::Def(def_kind, self.r.local_def_id(param.id).to_def_id());\n \n             match param.kind {\n                 GenericParamKind::Type { .. } => {\n@@ -1111,7 +1112,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             this.with_self_rib(Res::SelfTy(None, None), |this| {\n                 // Resolve the trait reference, if necessary.\n                 this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n-                    let item_def_id = this.r.definitions.local_def_id(item_id).to_def_id();\n+                    let item_def_id = this.r.local_def_id(item_id).to_def_id();\n                     this.with_self_rib(Res::SelfTy(trait_id, Some(item_def_id)), |this| {\n                         if let Some(trait_ref) = opt_trait_reference.as_ref() {\n                             // Resolve type arguments in the trait path.\n@@ -2002,7 +2003,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             if let StmtKind::Item(ref item) = stmt.kind {\n                 if let ItemKind::MacroDef(..) = item.kind {\n                     num_macro_definition_ribs += 1;\n-                    let res = self.r.definitions.local_def_id(item.id).to_def_id();\n+                    let res = self.r.local_def_id(item.id).to_def_id();\n                     self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n                     self.label_ribs.push(Rib::new(MacroDefinition(res)));\n                 }\n@@ -2296,7 +2297,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     ) -> SmallVec<[LocalDefId; 1]> {\n         let mut import_ids = smallvec![];\n         while let NameBindingKind::Import { import, binding, .. } = kind {\n-            let id = self.r.definitions.local_def_id(import.id);\n+            let id = self.r.local_def_id(import.id);\n             self.r.maybe_unused_trait_imports.insert(id);\n             self.r.add_to_glob_map(&import, trait_name);\n             import_ids.push(id);"}, {"sha": "1bce160acb6100ebbb2d23edd8c6a2d49f484ab1", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -512,7 +512,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 _ => {}\n             }\n             if !suggested {\n-                if let Some(span) = self.r.definitions.opt_span(def_id) {\n+                if let Some(span) = self.r.opt_span(def_id) {\n                     err.span_label(span, &format!(\"`{}` defined here\", path_str));\n                 }\n                 err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str));\n@@ -536,7 +536,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 if nightly_options::is_nightly_build() {\n                     let msg = \"you might have meant to use `#![feature(trait_alias)]` instead of a \\\n                                `type` alias\";\n-                    if let Some(span) = self.r.definitions.opt_span(def_id) {\n+                    if let Some(span) = self.r.opt_span(def_id) {\n                         err.span_help(span, msg);\n                     } else {\n                         err.help(msg);\n@@ -593,7 +593,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 bad_struct_syntax_suggestion(def_id);\n             }\n             (Res::Def(DefKind::Ctor(_, CtorKind::Fn), def_id), _) if ns == ValueNS => {\n-                if let Some(span) = self.r.definitions.opt_span(def_id) {\n+                if let Some(span) = self.r.opt_span(def_id) {\n                     err.span_label(span, &format!(\"`{}` defined here\", path_str));\n                 }\n                 err.span_label(span, format!(\"did you mean `{}( /* fields */ )`?\", path_str));"}, {"sha": "ce068b8ac69a45bda1ce19184773ca6f70c564dc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 106, "deletions": 25, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -27,6 +27,7 @@ use rustc_ast::attr;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::unwrap_or;\n use rustc_ast::visit::{self, Visitor};\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::ptr_key::PtrKey;\n@@ -36,9 +37,10 @@ use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n-use rustc_hir::definitions::{DefKey, Definitions};\n+use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n use rustc_hir::PrimTy::{self, Bool, Char, Float, Int, Str, Uint};\n use rustc_hir::TraitCandidate;\n+use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::hir::exports::ExportMap;\n use rustc_middle::middle::cstore::{CrateStore, MetadataLoaderDyn};\n@@ -256,31 +258,21 @@ impl<'a> From<&'a ast::PathSegment> for Segment {\n     }\n }\n \n-struct UsePlacementFinder<'d> {\n-    definitions: &'d Definitions,\n-    target_module: LocalDefId,\n+struct UsePlacementFinder {\n+    target_module: NodeId,\n     span: Option<Span>,\n     found_use: bool,\n }\n \n-impl<'d> UsePlacementFinder<'d> {\n-    fn check(\n-        definitions: &'d Definitions,\n-        krate: &Crate,\n-        target_module: DefId,\n-    ) -> (Option<Span>, bool) {\n-        if let Some(target_module) = target_module.as_local() {\n-            let mut finder =\n-                UsePlacementFinder { definitions, target_module, span: None, found_use: false };\n-            visit::walk_crate(&mut finder, krate);\n-            (finder.span, finder.found_use)\n-        } else {\n-            (None, false)\n-        }\n+impl UsePlacementFinder {\n+    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n+        let mut finder = UsePlacementFinder { target_module, span: None, found_use: false };\n+        visit::walk_crate(&mut finder, krate);\n+        (finder.span, finder.found_use)\n     }\n }\n \n-impl<'tcx, 'd> Visitor<'tcx> for UsePlacementFinder<'d> {\n+impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n     fn visit_mod(\n         &mut self,\n         module: &'tcx ast::Mod,\n@@ -291,7 +283,7 @@ impl<'tcx, 'd> Visitor<'tcx> for UsePlacementFinder<'d> {\n         if self.span.is_some() {\n             return;\n         }\n-        if self.definitions.local_def_id(node_id) != self.target_module {\n+        if node_id != self.target_module {\n             visit::walk_mod(self, module);\n             return;\n         }\n@@ -979,6 +971,19 @@ pub struct Resolver<'a> {\n     lint_buffer: LintBuffer,\n \n     next_node_id: NodeId,\n+\n+    def_id_to_span: IndexVec<LocalDefId, Span>,\n+\n+    node_id_to_def_id: FxHashMap<ast::NodeId, LocalDefId>,\n+    def_id_to_node_id: IndexVec<LocalDefId, ast::NodeId>,\n+\n+    /// Indices of unnamed struct or variant fields with unresolved attributes.\n+    placeholder_field_indices: FxHashMap<NodeId, usize>,\n+    /// When collecting definitions from an AST fragment produced by a macro invocation `ExpnId`\n+    /// we know what parent node that fragment should be attached to thanks to this table.\n+    invocation_parents: FxHashMap<ExpnId, LocalDefId>,\n+\n+    next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n@@ -1042,7 +1047,7 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n \n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n-impl rustc_ast_lowering::Resolver for Resolver<'_> {\n+impl ResolverAstLowering for Resolver<'_> {\n     fn def_key(&mut self, id: DefId) -> DefKey {\n         if let Some(id) = id.as_local() {\n             self.definitions().def_key(id)\n@@ -1113,6 +1118,56 @@ impl rustc_ast_lowering::Resolver for Resolver<'_> {\n     fn trait_map(&self) -> &NodeMap<Vec<TraitCandidate>> {\n         &self.trait_map\n     }\n+\n+    fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n+        self.node_id_to_def_id.get(&node).copied()\n+    }\n+\n+    fn local_def_id(&self, node: NodeId) -> LocalDefId {\n+        self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n+    }\n+\n+    /// Adds a definition with a parent definition.\n+    fn create_def(\n+        &mut self,\n+        parent: LocalDefId,\n+        node_id: ast::NodeId,\n+        data: DefPathData,\n+        expn_id: ExpnId,\n+        span: Span,\n+    ) -> LocalDefId {\n+        assert!(\n+            !self.node_id_to_def_id.contains_key(&node_id),\n+            \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n+            node_id,\n+            data,\n+            self.definitions.def_key(self.node_id_to_def_id[&node_id]),\n+        );\n+\n+        // Find the next free disambiguator for this key.\n+        let next_disambiguator = &mut self.next_disambiguator;\n+        let next_disambiguator = |parent, data| {\n+            let next_disamb = next_disambiguator.entry((parent, data)).or_insert(0);\n+            let disambiguator = *next_disamb;\n+            *next_disamb = next_disamb.checked_add(1).expect(\"disambiguator overflow\");\n+            disambiguator\n+        };\n+\n+        let def_id = self.definitions.create_def(parent, data, expn_id, next_disambiguator);\n+\n+        assert_eq!(self.def_id_to_span.push(span), def_id);\n+\n+        // Some things for which we allocate `LocalDefId`s don't correspond to\n+        // anything in the AST, so they don't have a `NodeId`. For these cases\n+        // we don't need a mapping from `NodeId` to `LocalDefId`.\n+        if node_id != ast::DUMMY_NODE_ID {\n+            debug!(\"create_def: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n+            self.node_id_to_def_id.insert(node_id, def_id);\n+        }\n+        assert_eq!(self.def_id_to_node_id.push(node_id), def_id);\n+\n+        def_id\n+    }\n }\n \n impl<'a> Resolver<'a> {\n@@ -1143,8 +1198,18 @@ impl<'a> Resolver<'a> {\n         let mut module_map = FxHashMap::default();\n         module_map.insert(LocalDefId { local_def_index: CRATE_DEF_INDEX }, graph_root);\n \n-        let mut definitions = Definitions::default();\n-        definitions.create_root_def(crate_name, session.local_crate_disambiguator());\n+        let definitions = Definitions::new(crate_name, session.local_crate_disambiguator());\n+        let root = definitions.get_root_def();\n+\n+        let mut def_id_to_span = IndexVec::default();\n+        assert_eq!(def_id_to_span.push(rustc_span::DUMMY_SP), root);\n+        let mut def_id_to_node_id = IndexVec::default();\n+        assert_eq!(def_id_to_node_id.push(CRATE_NODE_ID), root);\n+        let mut node_id_to_def_id = FxHashMap::default();\n+        node_id_to_def_id.insert(CRATE_NODE_ID, root);\n+\n+        let mut invocation_parents = FxHashMap::default();\n+        invocation_parents.insert(ExpnId::root(), root);\n \n         let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'_>> = session\n             .opts\n@@ -1263,6 +1328,12 @@ impl<'a> Resolver<'a> {\n             variant_vis: Default::default(),\n             lint_buffer: LintBuffer::default(),\n             next_node_id: NodeId::from_u32(1),\n+            def_id_to_span,\n+            node_id_to_def_id,\n+            def_id_to_node_id,\n+            placeholder_field_indices: Default::default(),\n+            invocation_parents,\n+            next_disambiguator: Default::default(),\n         }\n     }\n \n@@ -1457,7 +1528,7 @@ impl<'a> Resolver<'a> {\n     #[inline]\n     fn add_to_glob_map(&mut self, import: &Import<'_>, ident: Ident) {\n         if import.is_glob() {\n-            let def_id = self.definitions.local_def_id(import.id);\n+            let def_id = self.local_def_id(import.id);\n             self.glob_map.entry(def_id).or_default().insert(ident.name);\n         }\n     }\n@@ -2538,7 +2609,11 @@ impl<'a> Resolver<'a> {\n         for UseError { mut err, candidates, def_id, instead, suggestion } in\n             self.use_injections.drain(..)\n         {\n-            let (span, found_use) = UsePlacementFinder::check(&self.definitions, krate, def_id);\n+            let (span, found_use) = if let Some(def_id) = def_id.as_local() {\n+                UsePlacementFinder::check(krate, self.def_id_to_node_id[def_id])\n+            } else {\n+                (None, false)\n+            };\n             if !candidates.is_empty() {\n                 diagnostics::show_candidates(&mut err, span, &candidates, instead, found_use);\n             } else if let Some((span, msg, sugg, appl)) = suggestion {\n@@ -2934,6 +3009,12 @@ impl<'a> Resolver<'a> {\n     pub fn all_macros(&self) -> &FxHashMap<Symbol, Res> {\n         &self.all_macros\n     }\n+\n+    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n+    #[inline]\n+    pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n+        if let Some(def_id) = def_id.as_local() { Some(self.def_id_to_span[def_id]) } else { None }\n+    }\n }\n \n fn names_to_string(names: &[Symbol]) -> String {"}, {"sha": "398b0e92d9d8cf5fcbfb531b7ed84661aa882798", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045761c8d0cf39e637c3a5cc69fcb25fe2043d71/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "patch": "@@ -7,6 +7,7 @@ use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy};\n use crate::{CrateLint, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Weak};\n use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment, ToNameBinding};\n use rustc_ast::ast::{self, NodeId};\n+use rustc_ast_lowering::Resolver as ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, StabilityLevel};\n use rustc_data_structures::fx::FxHashSet;\n@@ -190,7 +191,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         )));\n \n         let parent_scope = if let Some(module_id) = parent_module_id {\n-            let parent_def_id = self.definitions.local_def_id(module_id);\n+            let parent_def_id = self.local_def_id(module_id);\n             self.definitions.add_parent_module_of_macro_def(expn_id, parent_def_id.to_def_id());\n             self.module_map[&parent_def_id]\n         } else {\n@@ -340,7 +341,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn lint_node_id(&mut self, expn_id: ExpnId) -> NodeId {\n-        self.definitions.lint_node_id(expn_id)\n+        self.invocation_parents\n+            .get(&expn_id)\n+            .map_or(ast::CRATE_NODE_ID, |id| self.def_id_to_node_id[*id])\n     }\n \n     fn has_derive_copy(&self, expn_id: ExpnId) -> bool {"}]}