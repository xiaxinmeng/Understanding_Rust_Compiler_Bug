{"sha": "f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZmM0OWMwNmU1YzcxYThkNjNkNjEyMGUxYTkyYjY0NDVmYjUwMWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-10T00:07:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-10T00:07:08Z"}, "message": "auto merge of #17853 : alexcrichton/rust/issue-17718, r=pcwalton\n\nThis change is an implementation of [RFC 69][rfc] which adds a third kind of\r\nglobal to the language, `const`. This global is most similar to what the old\r\n`static` was, and if you're unsure about what to use then you should use a\r\n`const`.\r\n\r\nThe semantics of these three kinds of globals are:\r\n\r\n* A `const` does not represent a memory location, but only a value. Constants\r\n  are translated as rvalues, which means that their values are directly inlined\r\n  at usage location (similar to a #define in C/C++). Constant values are, well,\r\n  constant, and can not be modified. Any \"modification\" is actually a\r\n  modification to a local value on the stack rather than the actual constant\r\n  itself.\r\n\r\n  Almost all values are allowed inside constants, whether they have interior\r\n  mutability or not. There are a few minor restrictions listed in the RFC, but\r\n  they should in general not come up too often.\r\n\r\n* A `static` now always represents a memory location (unconditionally). Any\r\n  references to the same `static` are actually a reference to the same memory\r\n  location. Only values whose types ascribe to `Sync` are allowed in a `static`.\r\n  This restriction is in place because many threads may access a `static`\r\n  concurrently. Lifting this restriction (and allowing unsafe access) is a\r\n  future extension not implemented at this time.\r\n\r\n* A `static mut` continues to always represent a memory location. All references\r\n  to a `static mut` continue to be `unsafe`.\r\n\r\nThis is a large breaking change, and many programs will need to be updated\r\naccordingly. A summary of the breaking changes is:\r\n\r\n* Statics may no longer be used in patterns. Statics now always represent a\r\n  memory location, which can sometimes be modified. To fix code, repurpose the\r\n  matched-on-`static` to a `const`.\r\n\r\n      static FOO: uint = 4;\r\n      match n {\r\n          FOO => { /* ... */ }\r\n          _ => { /* ... */ }\r\n      }\r\n\r\n  change this code to:\r\n\r\n      const FOO: uint = 4;\r\n      match n {\r\n          FOO => { /* ... */ }\r\n          _ => { /* ... */ }\r\n      }\r\n\r\n* Statics may no longer refer to other statics by value. Due to statics being\r\n  able to change at runtime, allowing them to reference one another could\r\n  possibly lead to confusing semantics. If you are in this situation, use a\r\n  constant initializer instead. Note, however, that statics may reference other\r\n  statics by address, however.\r\n\r\n* Statics may no longer be used in constant expressions, such as array lengths.\r\n  This is due to the same restrictions as listed above. Use a `const` instead.\r\n\r\n[breaking-change]\r\nCloses #17718 \r\n\r\n[rfc]: https://github.com/rust-lang/rfcs/pull/246", "tree": {"sha": "8a7c52db87b4ff8d5a7fa97dc44fb9ac10b92626", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a7c52db87b4ff8d5a7fa97dc44fb9ac10b92626"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "html_url": "https://github.com/rust-lang/rust/commit/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b12fb326b50c40c7b5acadb4403c7021fedb272", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b12fb326b50c40c7b5acadb4403c7021fedb272", "html_url": "https://github.com/rust-lang/rust/commit/8b12fb326b50c40c7b5acadb4403c7021fedb272"}, {"sha": "0b517117b3ac9c4981bbe00a529e48e4019554d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b517117b3ac9c4981bbe00a529e48e4019554d1", "html_url": "https://github.com/rust-lang/rust/commit/0b517117b3ac9c4981bbe00a529e48e4019554d1"}], "stats": {"total": 7324, "additions": 4052, "deletions": 3272}, "files": [{"sha": "c34a136a68e888e501d4f843743851c51ecb9d43", "filename": "src/doc/reference.md", "status": "modified", "additions": 65, "deletions": 19, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -1383,44 +1383,87 @@ a = Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n In this example, `Cat` is a _struct-like enum variant_,\n whereas `Dog` is simply called an enum variant.\n \n-### Static items\n+### Constant items\n \n ```{.ebnf .gram}\n-static_item : \"static\" ident ':' type '=' expr ';' ;\n+const_item : \"const\" ident ':' type '=' expr ';' ;\n ```\n \n-A *static item* is a named _constant value_ stored in the global data section\n-of a crate. Immutable static items are stored in the read-only data section.\n-The constant value bound to a static item is, like all constant values,\n-evaluated at compile time. Static items have the `static` lifetime, which\n-outlives all other lifetimes in a Rust program. Only values stored in the\n-global data section (such as string constants and static items) can have the\n-`static` lifetime; dynamically constructed values cannot safely be assigned the\n-`static` lifetime. Static items are declared with the `static` keyword. A\n-static item must have a _constant expression_ giving its definition.\n+A *constant item* is a named _constant value_ which is not associated with a\n+specific memory location in the program. Constants are essentially inlined\n+wherever they are used, meaning that they are copied directly into the relevant\n+context when used. References to the same constant are not necessarily\n+guaranteed to refer to the same memory address.\n+\n+Constant values must not have destructors, and otherwise permit most forms of\n+data. Constants may refer to the address of other constants, in which case the\n+address will have the `static` lifetime. The compiler is, however, still at\n+liberty to translate the constant many times, so the address referred to may not\n+be stable.\n \n-Static items must be explicitly typed. The type may be `bool`, `char`,\n-a number, or a type derived from those primitive types. The derived types are\n-references with the `static` lifetime, fixed-size arrays, tuples, and structs.\n+Constants must be explicitly typed. The type may be `bool`, `char`, a number, or\n+a type derived from those primitive types. The derived types are references with\n+the `static` lifetime, fixed-size arrays, tuples, enum variants, and structs.\n \n ```\n-static BIT1: uint = 1 << 0;\n-static BIT2: uint = 1 << 1;\n+const BIT1: uint = 1 << 0;\n+const BIT2: uint = 1 << 1;\n \n-static BITS: [uint, ..2] = [BIT1, BIT2];\n-static STRING: &'static str = \"bitstring\";\n+const BITS: [uint, ..2] = [BIT1, BIT2];\n+const STRING: &'static str = \"bitstring\";\n \n struct BitsNStrings<'a> {\n     mybits: [uint, ..2],\n     mystring: &'a str\n }\n \n-static BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings {\n+const BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings {\n     mybits: BITS,\n     mystring: STRING\n };\n ```\n \n+### Static items\n+\n+```{.ebnf .gram}\n+static_item : \"static\" ident ':' type '=' expr ';' ;\n+```\n+\n+A *static item* is similar to a *constant*, except that it represents a precise\n+memory location in the program. A static is never \"inlined\" at the usage site,\n+and all references to it refer to the same memory location. Static items have\n+the `static` lifetime, which outlives all other lifetimes in a Rust program.\n+Static items may be placed in read-only memory if they do not contain any\n+interior mutability.\n+\n+Statics may contain interior mutability through the `UnsafeCell` language item.\n+All access to a static is safe, but there are a number of restrictions on\n+statics:\n+\n+* Statics may not contain any destructors.\n+* The types of static values must ascribe to `Sync` to allow threadsafe access.\n+* Statics may not refer to other statics by value, only by reference.\n+* Constants cannot refer to statics.\n+\n+Constants should in general be preferred over statics, unless large amounts of\n+data are being stored, or single-address and mutability properties are required.\n+\n+```\n+use std::sync::atomic;\n+\n+// Note that INIT_ATOMIC_UINT is a *const*, but it may be used to initialize a\n+// static. This static can be modified, so it is not placed in read-only memory.\n+static COUNTER: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+\n+// This table is a candidate to be placed in read-only memory.\n+static TABLE: &'static [uint] = &[1, 2, 3, /* ... */];\n+\n+for slot in TABLE.iter() {\n+    println!(\"{}\", slot);\n+}\n+COUNTER.fetch_add(1, atomic::SeqCst);\n+```\n+\n #### Mutable statics\n \n If a static item is declared with the `mut` keyword, then it is allowed to\n@@ -1455,6 +1498,9 @@ unsafe fn bump_levels_unsafe2() -> uint {\n }\n ```\n \n+Mutable statics have the same restrictions as normal statics, except that the\n+type of the value is not required to ascribe to `Sync`.\n+\n ### Traits\n \n A _trait_ describes a set of method types."}, {"sha": "0b128686690f095f1f5c4974372281c8566da561", "filename": "src/etc/unicode.py", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -333,14 +333,14 @@ def emit_property_module(f, mod, tbl, emit_fn):\n def emit_regex_module(f, cats, w_data):\n     f.write(\"pub mod regex {\\n\")\n     regex_class = \"&'static [(char, char)]\"\n-    class_table = \"&'static [(&'static str, %s)]\" % regex_class\n+    class_table = \"&'static [(&'static str, &'static %s)]\" % regex_class\n \n     emit_table(f, \"UNICODE_CLASSES\", cats, class_table,\n-        pfun=lambda x: \"(\\\"%s\\\",super::%s::%s_table)\" % (x[0], x[1], x[0]))\n+        pfun=lambda x: \"(\\\"%s\\\",&super::%s::%s_table)\" % (x[0], x[1], x[0]))\n \n-    f.write(\"    pub static PERLD: %s = super::general_category::Nd_table;\\n\\n\"\n+    f.write(\"    pub static PERLD: &'static %s = &super::general_category::Nd_table;\\n\\n\"\n             % regex_class)\n-    f.write(\"    pub static PERLS: %s = super::property::White_Space_table;\\n\\n\"\n+    f.write(\"    pub static PERLS: &'static %s = &super::property::White_Space_table;\\n\\n\"\n             % regex_class)\n \n     emit_table(f, \"PERLW\", w_data, regex_class)"}, {"sha": "5a0f860ff844ef74278d244c83dc8437262a3278", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -85,7 +85,7 @@ pub fn stats_print() {\n ///\n /// This preserves the non-null invariant for types like `Box<T>`. The address may overlap with\n /// non-zero-size memory allocations.\n-pub static EMPTY: *mut () = 0x1 as *mut ();\n+pub const EMPTY: *mut () = 0x1 as *mut ();\n \n /// The allocator for unique pointers.\n #[cfg(not(test))]"}, {"sha": "fe8ced7f2aaafe29645f95182a54e4443b3640e2", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -34,10 +34,10 @@ use slice::{Items, MutItems};\n use slice;\n \n // FIXME: #5244: need to manually update the TrieNode constructor\n-static SHIFT: uint = 4;\n-static SIZE: uint = 1 << SHIFT;\n-static MASK: uint = SIZE - 1;\n-static NUM_CHUNKS: uint = uint::BITS / SHIFT;\n+const SHIFT: uint = 4;\n+const SIZE: uint = 1 << SHIFT;\n+const MASK: uint = SIZE - 1;\n+const NUM_CHUNKS: uint = uint::BITS / SHIFT;\n \n #[deriving(Clone)]\n enum Child<T> {"}, {"sha": "cc6fe06665bc823cc5dc23f070eb7bc6036f4a3e", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -77,19 +77,19 @@ pub enum Ordering {\n \n /// An `AtomicBool` initialized to `false`\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n-pub static INIT_ATOMIC_BOOL: AtomicBool =\n+pub const INIT_ATOMIC_BOOL: AtomicBool =\n         AtomicBool { v: UnsafeCell { value: 0 }, nocopy: marker::NoCopy };\n /// An `AtomicInt` initialized to `0`\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n-pub static INIT_ATOMIC_INT: AtomicInt =\n+pub const INIT_ATOMIC_INT: AtomicInt =\n         AtomicInt { v: UnsafeCell { value: 0 }, nocopy: marker::NoCopy };\n /// An `AtomicUint` initialized to `0`\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n-pub static INIT_ATOMIC_UINT: AtomicUint =\n+pub const INIT_ATOMIC_UINT: AtomicUint =\n         AtomicUint { v: UnsafeCell { value: 0, }, nocopy: marker::NoCopy };\n \n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n-static UINT_TRUE: uint = -1;\n+const UINT_TRUE: uint = -1;\n \n #[stable]\n impl AtomicBool {"}, {"sha": "d644fd0063ed34ae24d4e552665e3f36d407108d", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -219,8 +219,8 @@ pub struct RefCell<T> {\n // Values [1, MAX-1] represent the number of `Ref` active\n // (will not outgrow its range since `uint` is the size of the address space)\n type BorrowFlag = uint;\n-static UNUSED: BorrowFlag = 0;\n-static WRITING: BorrowFlag = -1;\n+const UNUSED: BorrowFlag = 0;\n+const WRITING: BorrowFlag = -1;\n \n impl<T> RefCell<T> {\n     /// Create a new `RefCell` containing `value`"}, {"sha": "8f3ecf0633cf3780b7f2e0f7a6d17fc4d5160e5f", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -63,7 +63,7 @@ static MAX_THREE_B: u32 =  0x10000u32;\n */\n \n /// The highest valid code point\n-pub static MAX: char = '\\U0010ffff';\n+pub const MAX: char = '\\U0010ffff';\n \n /// Converts from `u32` to a `char`\n #[inline]"}, {"sha": "b439f5577cbea126ef6a433af40b9928b6f68955", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -20,29 +20,29 @@ use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n use num::Float;\n use option::Option;\n \n-pub static RADIX: uint = 2u;\n+pub const RADIX: uint = 2u;\n \n-pub static MANTISSA_DIGITS: uint = 24u;\n-pub static DIGITS: uint = 6u;\n+pub const MANTISSA_DIGITS: uint = 24u;\n+pub const DIGITS: uint = 6u;\n \n-pub static EPSILON: f32 = 1.19209290e-07_f32;\n+pub const EPSILON: f32 = 1.19209290e-07_f32;\n \n /// Smallest finite f32 value\n-pub static MIN_VALUE: f32 = -3.40282347e+38_f32;\n+pub const MIN_VALUE: f32 = -3.40282347e+38_f32;\n /// Smallest positive, normalized f32 value\n-pub static MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n+pub const MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n /// Largest finite f32 value\n-pub static MAX_VALUE: f32 = 3.40282347e+38_f32;\n+pub const MAX_VALUE: f32 = 3.40282347e+38_f32;\n \n-pub static MIN_EXP: int = -125;\n-pub static MAX_EXP: int = 128;\n+pub const MIN_EXP: int = -125;\n+pub const MAX_EXP: int = 128;\n \n-pub static MIN_10_EXP: int = -37;\n-pub static MAX_10_EXP: int = 38;\n+pub const MIN_10_EXP: int = -37;\n+pub const MAX_10_EXP: int = 38;\n \n-pub static NAN: f32 = 0.0_f32/0.0_f32;\n-pub static INFINITY: f32 = 1.0_f32/0.0_f32;\n-pub static NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n+pub const NAN: f32 = 0.0_f32/0.0_f32;\n+pub const INFINITY: f32 = 1.0_f32/0.0_f32;\n+pub const NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n \n /// Various useful constants.\n pub mod consts {\n@@ -53,55 +53,55 @@ pub mod consts {\n     // of `Float`.\n \n     /// Archimedes' constant\n-    pub static PI: f32 = 3.14159265358979323846264338327950288_f32;\n+    pub const PI: f32 = 3.14159265358979323846264338327950288_f32;\n \n     /// pi * 2.0\n-    pub static PI_2: f32 = 6.28318530717958647692528676655900576_f32;\n+    pub const PI_2: f32 = 6.28318530717958647692528676655900576_f32;\n \n     /// pi/2.0\n-    pub static FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;\n+    pub const FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;\n \n     /// pi/3.0\n-    pub static FRAC_PI_3: f32 = 1.04719755119659774615421446109316763_f32;\n+    pub const FRAC_PI_3: f32 = 1.04719755119659774615421446109316763_f32;\n \n     /// pi/4.0\n-    pub static FRAC_PI_4: f32 = 0.785398163397448309615660845819875721_f32;\n+    pub const FRAC_PI_4: f32 = 0.785398163397448309615660845819875721_f32;\n \n     /// pi/6.0\n-    pub static FRAC_PI_6: f32 = 0.52359877559829887307710723054658381_f32;\n+    pub const FRAC_PI_6: f32 = 0.52359877559829887307710723054658381_f32;\n \n     /// pi/8.0\n-    pub static FRAC_PI_8: f32 = 0.39269908169872415480783042290993786_f32;\n+    pub const FRAC_PI_8: f32 = 0.39269908169872415480783042290993786_f32;\n \n     /// 1.0/pi\n-    pub static FRAC_1_PI: f32 = 0.318309886183790671537767526745028724_f32;\n+    pub const FRAC_1_PI: f32 = 0.318309886183790671537767526745028724_f32;\n \n     /// 2.0/pi\n-    pub static FRAC_2_PI: f32 = 0.636619772367581343075535053490057448_f32;\n+    pub const FRAC_2_PI: f32 = 0.636619772367581343075535053490057448_f32;\n \n     /// 2.0/sqrt(pi)\n-    pub static FRAC_2_SQRTPI: f32 = 1.12837916709551257389615890312154517_f32;\n+    pub const FRAC_2_SQRTPI: f32 = 1.12837916709551257389615890312154517_f32;\n \n     /// sqrt(2.0)\n-    pub static SQRT2: f32 = 1.41421356237309504880168872420969808_f32;\n+    pub const SQRT2: f32 = 1.41421356237309504880168872420969808_f32;\n \n     /// 1.0/sqrt(2.0)\n-    pub static FRAC_1_SQRT2: f32 = 0.707106781186547524400844362104849039_f32;\n+    pub const FRAC_1_SQRT2: f32 = 0.707106781186547524400844362104849039_f32;\n \n     /// Euler's number\n-    pub static E: f32 = 2.71828182845904523536028747135266250_f32;\n+    pub const E: f32 = 2.71828182845904523536028747135266250_f32;\n \n     /// log2(e)\n-    pub static LOG2_E: f32 = 1.44269504088896340735992468100189214_f32;\n+    pub const LOG2_E: f32 = 1.44269504088896340735992468100189214_f32;\n \n     /// log10(e)\n-    pub static LOG10_E: f32 = 0.434294481903251827651128918916605082_f32;\n+    pub const LOG10_E: f32 = 0.434294481903251827651128918916605082_f32;\n \n     /// ln(2.0)\n-    pub static LN_2: f32 = 0.693147180559945309417232121458176568_f32;\n+    pub const LN_2: f32 = 0.693147180559945309417232121458176568_f32;\n \n     /// ln(10.0)\n-    pub static LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n+    pub const LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n impl Float for f32 {\n@@ -143,8 +143,8 @@ impl Float for f32 {\n     /// is going to be tested, it is generally faster to use the specific\n     /// predicate instead.\n     fn classify(self) -> FPCategory {\n-        static EXP_MASK: u32 = 0x7f800000;\n-        static MAN_MASK: u32 = 0x007fffff;\n+        const EXP_MASK: u32 = 0x7f800000;\n+        const MAN_MASK: u32 = 0x007fffff;\n \n         let bits: u32 = unsafe { mem::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {"}, {"sha": "d980009c0db0d8a96153fea094b00dbba89f88dd", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -24,31 +24,31 @@ use option::Option;\n // constants are implemented in favour of referencing the respective\n // members of `Bounded` and `Float`.\n \n-pub static RADIX: uint = 2u;\n+pub const RADIX: uint = 2u;\n \n-pub static MANTISSA_DIGITS: uint = 53u;\n-pub static DIGITS: uint = 15u;\n+pub const MANTISSA_DIGITS: uint = 53u;\n+pub const DIGITS: uint = 15u;\n \n-pub static EPSILON: f64 = 2.2204460492503131e-16_f64;\n+pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n \n /// Smallest finite f64 value\n-pub static MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n+pub const MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n /// Smallest positive, normalized f64 value\n-pub static MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n+pub const MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n /// Largest finite f64 value\n-pub static MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n+pub const MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n \n-pub static MIN_EXP: int = -1021;\n-pub static MAX_EXP: int = 1024;\n+pub const MIN_EXP: int = -1021;\n+pub const MAX_EXP: int = 1024;\n \n-pub static MIN_10_EXP: int = -307;\n-pub static MAX_10_EXP: int = 308;\n+pub const MIN_10_EXP: int = -307;\n+pub const MAX_10_EXP: int = 308;\n \n-pub static NAN: f64 = 0.0_f64/0.0_f64;\n+pub const NAN: f64 = 0.0_f64/0.0_f64;\n \n-pub static INFINITY: f64 = 1.0_f64/0.0_f64;\n+pub const INFINITY: f64 = 1.0_f64/0.0_f64;\n \n-pub static NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n+pub const NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n \n /// Various useful constants.\n pub mod consts {\n@@ -59,55 +59,55 @@ pub mod consts {\n     // of `Float`.\n \n     /// Archimedes' constant\n-    pub static PI: f64 = 3.14159265358979323846264338327950288_f64;\n+    pub const PI: f64 = 3.14159265358979323846264338327950288_f64;\n \n     /// pi * 2.0\n-    pub static PI_2: f64 = 6.28318530717958647692528676655900576_f64;\n+    pub const PI_2: f64 = 6.28318530717958647692528676655900576_f64;\n \n     /// pi/2.0\n-    pub static FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;\n+    pub const FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;\n \n     /// pi/3.0\n-    pub static FRAC_PI_3: f64 = 1.04719755119659774615421446109316763_f64;\n+    pub const FRAC_PI_3: f64 = 1.04719755119659774615421446109316763_f64;\n \n     /// pi/4.0\n-    pub static FRAC_PI_4: f64 = 0.785398163397448309615660845819875721_f64;\n+    pub const FRAC_PI_4: f64 = 0.785398163397448309615660845819875721_f64;\n \n     /// pi/6.0\n-    pub static FRAC_PI_6: f64 = 0.52359877559829887307710723054658381_f64;\n+    pub const FRAC_PI_6: f64 = 0.52359877559829887307710723054658381_f64;\n \n     /// pi/8.0\n-    pub static FRAC_PI_8: f64 = 0.39269908169872415480783042290993786_f64;\n+    pub const FRAC_PI_8: f64 = 0.39269908169872415480783042290993786_f64;\n \n     /// 1.0/pi\n-    pub static FRAC_1_PI: f64 = 0.318309886183790671537767526745028724_f64;\n+    pub const FRAC_1_PI: f64 = 0.318309886183790671537767526745028724_f64;\n \n     /// 2.0/pi\n-    pub static FRAC_2_PI: f64 = 0.636619772367581343075535053490057448_f64;\n+    pub const FRAC_2_PI: f64 = 0.636619772367581343075535053490057448_f64;\n \n     /// 2.0/sqrt(pi)\n-    pub static FRAC_2_SQRTPI: f64 = 1.12837916709551257389615890312154517_f64;\n+    pub const FRAC_2_SQRTPI: f64 = 1.12837916709551257389615890312154517_f64;\n \n     /// sqrt(2.0)\n-    pub static SQRT2: f64 = 1.41421356237309504880168872420969808_f64;\n+    pub const SQRT2: f64 = 1.41421356237309504880168872420969808_f64;\n \n     /// 1.0/sqrt(2.0)\n-    pub static FRAC_1_SQRT2: f64 = 0.707106781186547524400844362104849039_f64;\n+    pub const FRAC_1_SQRT2: f64 = 0.707106781186547524400844362104849039_f64;\n \n     /// Euler's number\n-    pub static E: f64 = 2.71828182845904523536028747135266250_f64;\n+    pub const E: f64 = 2.71828182845904523536028747135266250_f64;\n \n     /// log2(e)\n-    pub static LOG2_E: f64 = 1.44269504088896340735992468100189214_f64;\n+    pub const LOG2_E: f64 = 1.44269504088896340735992468100189214_f64;\n \n     /// log10(e)\n-    pub static LOG10_E: f64 = 0.434294481903251827651128918916605082_f64;\n+    pub const LOG10_E: f64 = 0.434294481903251827651128918916605082_f64;\n \n     /// ln(2.0)\n-    pub static LN_2: f64 = 0.693147180559945309417232121458176568_f64;\n+    pub const LN_2: f64 = 0.693147180559945309417232121458176568_f64;\n \n     /// ln(10.0)\n-    pub static LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n+    pub const LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n impl Float for f64 {\n@@ -149,8 +149,8 @@ impl Float for f64 {\n     /// is going to be tested, it is generally faster to use the specific\n     /// predicate instead.\n     fn classify(self) -> FPCategory {\n-        static EXP_MASK: u64 = 0x7ff0000000000000;\n-        static MAN_MASK: u64 = 0x000fffffffffffff;\n+        const EXP_MASK: u64 = 0x7ff0000000000000;\n+        const MAN_MASK: u64 = 0x000fffffffffffff;\n \n         let bits: u64 = unsafe { mem::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {"}, {"sha": "0f8950344c8a0524a175125d488fd3449b81911a", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -16,20 +16,20 @@ macro_rules! int_module (($T:ty, $bits:expr) => (\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n #[unstable]\n-pub static BITS : uint = $bits;\n+pub const BITS : uint = $bits;\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n #[unstable]\n-pub static BYTES : uint = ($bits / 8);\n+pub const BYTES : uint = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::min_value` function.\n #[unstable]\n-pub static MIN: $T = (-1 as $T) << (BITS - 1);\n+pub const MIN: $T = (-1 as $T) << (BITS - 1);\n // FIXME(#9837): Compute MIN like this so the high bits that shouldn't exist are 0.\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::max_value` function.\n #[unstable]\n-pub static MAX: $T = !MIN;\n+pub const MAX: $T = !MIN;\n \n ))"}, {"sha": "2a94f851646c4f4bda95d17039f994689629941b", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -14,13 +14,13 @@\n macro_rules! uint_module (($T:ty, $T_SIGNED:ty, $bits:expr) => (\n \n #[unstable]\n-pub static BITS : uint = $bits;\n+pub const BITS : uint = $bits;\n #[unstable]\n-pub static BYTES : uint = ($bits / 8);\n+pub const BYTES : uint = ($bits / 8);\n \n #[unstable]\n-pub static MIN: $T = 0 as $T;\n+pub const MIN: $T = 0 as $T;\n #[unstable]\n-pub static MAX: $T = 0 as $T - 1 as $T;\n+pub const MAX: $T = 0 as $T - 1 as $T;\n \n ))"}, {"sha": "1cbe955274b65995ac281a960f948d2993be8aab", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -1049,9 +1049,9 @@ pub struct CharRange {\n }\n \n /// Mask of the value bits of a continuation byte\n-static CONT_MASK: u8 = 0b0011_1111u8;\n+const CONT_MASK: u8 = 0b0011_1111u8;\n /// Value of the tag bits (tag mask is !CONT_MASK) of a continuation byte\n-static TAG_CONT_U8: u8 = 0b1000_0000u8;\n+const TAG_CONT_U8: u8 = 0b1000_0000u8;\n \n /// Unsafe operations\n pub mod raw {"}, {"sha": "71942a716869ca187c78ee1f766a30eb8a3570db", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1770, "deletions": 1770, "changes": 3540, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d"}, {"sha": "b08ad3b6c61740cd3a237d1ff905cb32e8a21657", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -188,10 +188,10 @@ mod directive;\n \n /// Maximum logging level of a module that can be specified. Common logging\n /// levels are found in the DEBUG/INFO/WARN/ERROR constants.\n-pub static MAX_LOG_LEVEL: u32 = 255;\n+pub const MAX_LOG_LEVEL: u32 = 255;\n \n /// The default logging level of a crate if no other is specified.\n-static DEFAULT_LOG_LEVEL: u32 = 1;\n+const DEFAULT_LOG_LEVEL: u32 = 1;\n \n /// An unsafe constant that is the maximum logging level of any module\n /// specified. This is the first line of defense to determining whether a\n@@ -205,13 +205,13 @@ static mut DIRECTIVES: *const Vec<directive::LogDirective> =\n static mut FILTER: *const Regex = 0 as *const _;\n \n /// Debug log level\n-pub static DEBUG: u32 = 4;\n+pub const DEBUG: u32 = 4;\n /// Info log level\n-pub static INFO: u32 = 3;\n+pub const INFO: u32 = 3;\n /// Warn log level\n-pub static WARN: u32 = 2;\n+pub const WARN: u32 = 2;\n /// Error log level\n-pub static ERROR: u32 = 1;\n+pub const ERROR: u32 = 1;\n \n local_data_key!(local_logger: Box<Logger + Send>)\n "}, {"sha": "c2af9c03c42c1c59d813cbf5ef5c7595e6bf8e04", "filename": "src/libnative/io/c_unix.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -23,41 +23,41 @@ use libc;\n           target_os = \"ios\",\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\"))]\n-pub static FIONBIO: libc::c_ulong = 0x8004667e;\n+pub const FIONBIO: libc::c_ulong = 0x8004667e;\n #[cfg(any(all(target_os = \"linux\",\n               any(target_arch = \"x86\",\n                   target_arch = \"x86_64\",\n                   target_arch = \"arm\")),\n           target_os = \"android\"))]\n-pub static FIONBIO: libc::c_ulong = 0x5421;\n+pub const FIONBIO: libc::c_ulong = 0x5421;\n #[cfg(all(target_os = \"linux\",\n           any(target_arch = \"mips\", target_arch = \"mipsel\")))]\n-pub static FIONBIO: libc::c_ulong = 0x667e;\n+pub const FIONBIO: libc::c_ulong = 0x667e;\n \n #[cfg(any(target_os = \"macos\",\n           target_os = \"ios\",\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\"))]\n-pub static FIOCLEX: libc::c_ulong = 0x20006601;\n+pub const FIOCLEX: libc::c_ulong = 0x20006601;\n #[cfg(any(all(target_os = \"linux\",\n               any(target_arch = \"x86\",\n                   target_arch = \"x86_64\",\n                   target_arch = \"arm\")),\n           target_os = \"android\"))]\n-pub static FIOCLEX: libc::c_ulong = 0x5451;\n+pub const FIOCLEX: libc::c_ulong = 0x5451;\n #[cfg(all(target_os = \"linux\",\n           any(target_arch = \"mips\", target_arch = \"mipsel\")))]\n-pub static FIOCLEX: libc::c_ulong = 0x6601;\n+pub const FIOCLEX: libc::c_ulong = 0x6601;\n \n #[cfg(any(target_os = \"macos\",\n           target_os = \"ios\",\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\"))]\n-pub static MSG_DONTWAIT: libc::c_int = 0x80;\n+pub const MSG_DONTWAIT: libc::c_int = 0x80;\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub static MSG_DONTWAIT: libc::c_int = 0x40;\n+pub const MSG_DONTWAIT: libc::c_int = 0x40;\n \n-pub static WNOHANG: libc::c_int = 1;\n+pub const WNOHANG: libc::c_int = 1;\n \n extern {\n     pub fn gettimeofday(timeval: *mut libc::timeval,\n@@ -89,7 +89,7 @@ extern {\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n mod select {\n-    pub static FD_SETSIZE: uint = 1024;\n+    pub const FD_SETSIZE: uint = 1024;\n \n     #[repr(C)]\n     pub struct fd_set {\n@@ -109,7 +109,7 @@ mod select {\n     use std::uint;\n     use libc;\n \n-    pub static FD_SETSIZE: uint = 1024;\n+    pub const FD_SETSIZE: uint = 1024;\n \n     #[repr(C)]\n     pub struct fd_set {\n@@ -131,14 +131,14 @@ mod select {\n mod signal {\n     use libc;\n \n-    pub static SA_NOCLDSTOP: libc::c_ulong = 0x00000001;\n-    pub static SA_NOCLDWAIT: libc::c_ulong = 0x00000002;\n-    pub static SA_NODEFER: libc::c_ulong = 0x40000000;\n-    pub static SA_ONSTACK: libc::c_ulong = 0x08000000;\n-    pub static SA_RESETHAND: libc::c_ulong = 0x80000000;\n-    pub static SA_RESTART: libc::c_ulong = 0x10000000;\n-    pub static SA_SIGINFO: libc::c_ulong = 0x00000004;\n-    pub static SIGCHLD: libc::c_int = 17;\n+    pub const SA_NOCLDSTOP: libc::c_ulong = 0x00000001;\n+    pub const SA_NOCLDWAIT: libc::c_ulong = 0x00000002;\n+    pub const SA_NODEFER: libc::c_ulong = 0x40000000;\n+    pub const SA_ONSTACK: libc::c_ulong = 0x08000000;\n+    pub const SA_RESETHAND: libc::c_ulong = 0x80000000;\n+    pub const SA_RESTART: libc::c_ulong = 0x10000000;\n+    pub const SA_SIGINFO: libc::c_ulong = 0x00000004;\n+    pub const SIGCHLD: libc::c_int = 17;\n \n     // This definition is not as accurate as it could be, {pid, uid, status} is\n     // actually a giant union. Currently we're only interested in these fields,\n@@ -179,14 +179,14 @@ mod signal {\n mod signal {\n     use libc;\n \n-    pub static SA_NOCLDSTOP: libc::c_ulong = 0x00000001;\n-    pub static SA_NOCLDWAIT: libc::c_ulong = 0x00010000;\n-    pub static SA_NODEFER: libc::c_ulong = 0x40000000;\n-    pub static SA_ONSTACK: libc::c_ulong = 0x08000000;\n-    pub static SA_RESETHAND: libc::c_ulong = 0x80000000;\n-    pub static SA_RESTART: libc::c_ulong = 0x10000000;\n-    pub static SA_SIGINFO: libc::c_ulong = 0x00000008;\n-    pub static SIGCHLD: libc::c_int = 18;\n+    pub const SA_NOCLDSTOP: libc::c_ulong = 0x00000001;\n+    pub const SA_NOCLDWAIT: libc::c_ulong = 0x00010000;\n+    pub const SA_NODEFER: libc::c_ulong = 0x40000000;\n+    pub const SA_ONSTACK: libc::c_ulong = 0x08000000;\n+    pub const SA_RESETHAND: libc::c_ulong = 0x80000000;\n+    pub const SA_RESTART: libc::c_ulong = 0x10000000;\n+    pub const SA_SIGINFO: libc::c_ulong = 0x00000008;\n+    pub const SIGCHLD: libc::c_int = 18;\n \n     // This definition is not as accurate as it could be, {pid, uid, status} is\n     // actually a giant union. Currently we're only interested in these fields,\n@@ -223,14 +223,14 @@ mod signal {\n mod signal {\n     use libc;\n \n-    pub static SA_ONSTACK: libc::c_int = 0x0001;\n-    pub static SA_RESTART: libc::c_int = 0x0002;\n-    pub static SA_RESETHAND: libc::c_int = 0x0004;\n-    pub static SA_NOCLDSTOP: libc::c_int = 0x0008;\n-    pub static SA_NODEFER: libc::c_int = 0x0010;\n-    pub static SA_NOCLDWAIT: libc::c_int = 0x0020;\n-    pub static SA_SIGINFO: libc::c_int = 0x0040;\n-    pub static SIGCHLD: libc::c_int = 20;\n+    pub const SA_ONSTACK: libc::c_int = 0x0001;\n+    pub const SA_RESTART: libc::c_int = 0x0002;\n+    pub const SA_RESETHAND: libc::c_int = 0x0004;\n+    pub const SA_NOCLDSTOP: libc::c_int = 0x0008;\n+    pub const SA_NODEFER: libc::c_int = 0x0010;\n+    pub const SA_NOCLDWAIT: libc::c_int = 0x0020;\n+    pub const SA_SIGINFO: libc::c_int = 0x0040;\n+    pub const SIGCHLD: libc::c_int = 20;\n \n     #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n     pub type sigset_t = u32;"}, {"sha": "067a31166a50043399e6e350b702178545cbcaf5", "filename": "src/libnative/io/c_windows.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibnative%2Fio%2Fc_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibnative%2Fio%2Fc_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_windows.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -14,26 +14,26 @@\n \n use libc;\n \n-pub static WSADESCRIPTION_LEN: uint = 256;\n-pub static WSASYS_STATUS_LEN: uint = 128;\n-pub static FIONBIO: libc::c_long = 0x8004667e;\n-static FD_SETSIZE: uint = 64;\n-pub static MSG_DONTWAIT: libc::c_int = 0;\n-pub static ERROR_ILLEGAL_CHARACTER: libc::c_int = 582;\n-pub static ENABLE_ECHO_INPUT: libc::DWORD = 0x4;\n-pub static ENABLE_EXTENDED_FLAGS: libc::DWORD = 0x80;\n-pub static ENABLE_INSERT_MODE: libc::DWORD = 0x20;\n-pub static ENABLE_LINE_INPUT: libc::DWORD = 0x2;\n-pub static ENABLE_PROCESSED_INPUT: libc::DWORD = 0x1;\n-pub static ENABLE_QUICK_EDIT_MODE: libc::DWORD = 0x40;\n-pub static WSA_INVALID_EVENT: WSAEVENT = 0 as WSAEVENT;\n-\n-pub static FD_ACCEPT: libc::c_long = 0x08;\n-pub static FD_MAX_EVENTS: uint = 10;\n-pub static WSA_INFINITE: libc::DWORD = libc::INFINITE;\n-pub static WSA_WAIT_TIMEOUT: libc::DWORD = libc::consts::os::extra::WAIT_TIMEOUT;\n-pub static WSA_WAIT_EVENT_0: libc::DWORD = libc::consts::os::extra::WAIT_OBJECT_0;\n-pub static WSA_WAIT_FAILED: libc::DWORD = libc::consts::os::extra::WAIT_FAILED;\n+pub const WSADESCRIPTION_LEN: uint = 256;\n+pub const WSASYS_STATUS_LEN: uint = 128;\n+pub const FIONBIO: libc::c_long = 0x8004667e;\n+pub const FD_SETSIZE: uint = 64;\n+pub const MSG_DONTWAIT: libc::c_int = 0;\n+pub const ERROR_ILLEGAL_CHARACTER: libc::c_int = 582;\n+pub const ENABLE_ECHO_INPUT: libc::DWORD = 0x4;\n+pub const ENABLE_EXTENDED_FLAGS: libc::DWORD = 0x80;\n+pub const ENABLE_INSERT_MODE: libc::DWORD = 0x20;\n+pub const ENABLE_LINE_INPUT: libc::DWORD = 0x2;\n+pub const ENABLE_PROCESSED_INPUT: libc::DWORD = 0x1;\n+pub const ENABLE_QUICK_EDIT_MODE: libc::DWORD = 0x40;\n+pub const WSA_INVALID_EVENT: WSAEVENT = 0 as WSAEVENT;\n+\n+pub const FD_ACCEPT: libc::c_long = 0x08;\n+pub const FD_MAX_EVENTS: uint = 10;\n+pub const WSA_INFINITE: libc::DWORD = libc::INFINITE;\n+pub const WSA_WAIT_TIMEOUT: libc::DWORD = libc::consts::os::extra::WAIT_TIMEOUT;\n+pub const WSA_WAIT_EVENT_0: libc::DWORD = libc::consts::os::extra::WAIT_OBJECT_0;\n+pub const WSA_WAIT_FAILED: libc::DWORD = libc::consts::os::extra::WAIT_FAILED;\n \n #[repr(C)]\n #[cfg(target_arch = \"x86\")]"}, {"sha": "e52d62a040be83dc5fdf5c7ec0f4aac912596606", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -77,7 +77,7 @@ pub type BigDigit = u32;\n /// size is the double of the size of `BigDigit`.\n pub type DoubleBigDigit = u64;\n \n-pub static ZERO_BIG_DIGIT: BigDigit = 0;\n+pub const ZERO_BIG_DIGIT: BigDigit = 0;\n static ZERO_VEC: [BigDigit, ..1] = [ZERO_BIG_DIGIT];\n \n #[allow(non_snake_case)]\n@@ -87,10 +87,10 @@ pub mod BigDigit {\n \n     // `DoubleBigDigit` size dependent\n     #[allow(non_uppercase_statics)]\n-    pub static bits: uint = 32;\n+    pub const bits: uint = 32;\n \n     #[allow(non_uppercase_statics)]\n-    pub static base: DoubleBigDigit = 1 << bits;\n+    pub const base: DoubleBigDigit = 1 << bits;\n     #[allow(non_uppercase_statics)]\n     static lo_mask: DoubleBigDigit = (-1 as DoubleBigDigit) >> bits;\n "}, {"sha": "6690b1d5ddc7acd3b7c4b6f842e36a6e64b0cdd3", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -194,13 +194,13 @@ mod test {\n     use std::num::{Zero, One, Float};\n     use std::hash::hash;\n \n-    pub static _0_0i : Complex64 = Complex { re: 0.0, im: 0.0 };\n-    pub static _1_0i : Complex64 = Complex { re: 1.0, im: 0.0 };\n-    pub static _1_1i : Complex64 = Complex { re: 1.0, im: 1.0 };\n-    pub static _0_1i : Complex64 = Complex { re: 0.0, im: 1.0 };\n-    pub static _neg1_1i : Complex64 = Complex { re: -1.0, im: 1.0 };\n-    pub static _05_05i : Complex64 = Complex { re: 0.5, im: 0.5 };\n-    pub static all_consts : [Complex64, .. 5] = [_0_0i, _1_0i, _1_1i, _neg1_1i, _05_05i];\n+    pub const _0_0i : Complex64 = Complex { re: 0.0, im: 0.0 };\n+    pub const _1_0i : Complex64 = Complex { re: 1.0, im: 0.0 };\n+    pub const _1_1i : Complex64 = Complex { re: 1.0, im: 1.0 };\n+    pub const _0_1i : Complex64 = Complex { re: 0.0, im: 1.0 };\n+    pub const _neg1_1i : Complex64 = Complex { re: -1.0, im: 1.0 };\n+    pub const _05_05i : Complex64 = Complex { re: 0.5, im: 0.5 };\n+    pub const all_consts : [Complex64, .. 5] = [_0_0i, _1_0i, _1_1i, _neg1_1i, _05_05i];\n \n     #[test]\n     fn test_consts() {"}, {"sha": "83d03bb265e95f87208eb333b91963d4f1099662", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -14,9 +14,9 @@ use core::prelude::*;\n \n use {Rng, SeedableRng, Rand};\n \n-static KEY_WORDS    : uint =  8; // 8 words for the 256-bit key\n-static STATE_WORDS  : uint = 16;\n-static CHACHA_ROUNDS: uint = 20; // Cryptographically secure from 8 upwards as of this writing\n+const KEY_WORDS    : uint =  8; // 8 words for the 256-bit key\n+const STATE_WORDS  : uint = 16;\n+const CHACHA_ROUNDS: uint = 20; // Cryptographically secure from 8 upwards as of this writing\n \n /// A random number generator that uses the ChaCha20 algorithm [1].\n ///"}, {"sha": "9bfd9177e348b1cbffbea9e2d7db414fad36e10c", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -16,9 +16,9 @@ use core::slice::raw;\n \n use {Rng, SeedableRng, Rand};\n \n-static RAND_SIZE_LEN: u32 = 8;\n-static RAND_SIZE: u32 = 1 << (RAND_SIZE_LEN as uint);\n-static RAND_SIZE_UINT: uint = 1 << (RAND_SIZE_LEN as uint);\n+const RAND_SIZE_LEN: u32 = 8;\n+const RAND_SIZE: u32 = 1 << (RAND_SIZE_LEN as uint);\n+const RAND_SIZE_UINT: uint = 1 << (RAND_SIZE_LEN as uint);\n \n /// A random number generator that uses the ISAAC algorithm[1].\n ///\n@@ -251,8 +251,8 @@ impl Rand for IsaacRng {\n     }\n }\n \n-static RAND_SIZE_64_LEN: uint = 8;\n-static RAND_SIZE_64: uint = 1 << RAND_SIZE_64_LEN;\n+const RAND_SIZE_64_LEN: uint = 8;\n+const RAND_SIZE_64: uint = 1 << RAND_SIZE_64_LEN;\n \n /// A random number generator that uses ISAAC-64[1], the 64-bit\n /// variant of the ISAAC algorithm.\n@@ -356,8 +356,8 @@ impl Isaac64Rng {\n         // abbreviations\n         let mut a = self.a;\n         let mut b = self.b + self.c;\n-        static MIDPOINT: uint =  RAND_SIZE_64 / 2;\n-        static MP_VEC: [(uint, uint), .. 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n+        const MIDPOINT: uint =  RAND_SIZE_64 / 2;\n+        const MP_VEC: [(uint, uint), .. 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind (\n             ($x:expr) => {\n                 *self.mem.unsafe_get(($x as uint >> 3) & (RAND_SIZE_64 - 1))"}, {"sha": "1d1d1a0e9c5cab3668f09052cdff7d8187d392aa", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -162,12 +162,12 @@ impl BuildAst {\n /// expression.\n pub type Flags = u8;\n \n-pub static FLAG_EMPTY:      u8 = 0;\n-pub static FLAG_NOCASE:     u8 = 1 << 0; // i\n-pub static FLAG_MULTI:      u8 = 1 << 1; // m\n-pub static FLAG_DOTNL:      u8 = 1 << 2; // s\n-pub static FLAG_SWAP_GREED: u8 = 1 << 3; // U\n-pub static FLAG_NEGATED:    u8 = 1 << 4; // char class or not word boundary\n+pub const FLAG_EMPTY:      u8 = 0;\n+pub const FLAG_NOCASE:     u8 = 1 << 0; // i\n+pub const FLAG_MULTI:      u8 = 1 << 1; // m\n+pub const FLAG_DOTNL:      u8 = 1 << 2; // s\n+pub const FLAG_SWAP_GREED: u8 = 1 << 3; // U\n+pub const FLAG_NEGATED:    u8 = 1 << 4; // char class or not word boundary\n \n struct Parser<'a> {\n     // The input, parsed only as a sequence of UTF8 code points.\n@@ -1025,7 +1025,7 @@ fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n }\n \n type Class = &'static [(char, char)];\n-type NamedClasses = &'static [(&'static str, Class)];\n+type NamedClasses = &'static [(&'static str, &'static Class)];\n \n static ASCII_CLASSES: NamedClasses = &[\n     // Classes must be in alphabetical order so that bsearch works.\n@@ -1044,19 +1044,34 @@ static ASCII_CLASSES: NamedClasses = &[\n     // [:word:]       word characters (== [0-9A-Za-z_])\n     // [:xdigit:]     hex digit (== [0-9A-Fa-f])\n     // Taken from: http://golang.org/pkg/regex/syntax/\n-    (\"alnum\", &[('0', '9'), ('A', 'Z'), ('a', 'z')]),\n-    (\"alpha\", &[('A', 'Z'), ('a', 'z')]),\n-    (\"ascii\", &[('\\x00', '\\x7F')]),\n-    (\"blank\", &[(' ', ' '), ('\\t', '\\t')]),\n-    (\"cntrl\", &[('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]),\n-    (\"digit\", &[('0', '9')]),\n-    (\"graph\", &[('!', '~')]),\n-    (\"lower\", &[('a', 'z')]),\n-    (\"print\", &[(' ', '~')]),\n-    (\"punct\", &[('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]),\n-    (\"space\", &[('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'),\n-                ('\\r', '\\r'), (' ', ' ')]),\n-    (\"upper\", &[('A', 'Z')]),\n-    (\"word\", &[('0', '9'), ('A', 'Z'), ('a', 'z'), ('_', '_')]),\n-    (\"xdigit\", &[('0', '9'), ('A', 'F'), ('a', 'f')]),\n+    (\"alnum\", &ALNUM),\n+    (\"alpha\", &ALPHA),\n+    (\"ascii\", &ASCII),\n+    (\"blank\", &BLANK),\n+    (\"cntrl\", &CNTRL),\n+    (\"digit\", &DIGIT),\n+    (\"graph\", &GRAPH),\n+    (\"lower\", &LOWER),\n+    (\"print\", &PRINT),\n+    (\"punct\", &PUNCT),\n+    (\"space\", &SPACE),\n+    (\"upper\", &UPPER),\n+    (\"word\", &WORD),\n+    (\"xdigit\", &XDIGIT),\n ];\n+\n+static ALNUM: Class = &[('0', '9'), ('A', 'Z'), ('a', 'z')];\n+static ALPHA: Class = &[('A', 'Z'), ('a', 'z')];\n+static ASCII: Class = &[('\\x00', '\\x7F')];\n+static BLANK: Class = &[(' ', ' '), ('\\t', '\\t')];\n+static CNTRL: Class = &[('\\x00', '\\x1F'), ('\\x7F', '\\x7F')];\n+static DIGIT: Class = &[('0', '9')];\n+static GRAPH: Class = &[('!', '~')];\n+static LOWER: Class = &[('a', 'z')];\n+static PRINT: Class = &[(' ', '~')];\n+static PUNCT: Class = &[('!', '/'), (':', '@'), ('[', '`'), ('{', '~')];\n+static SPACE: Class = &[('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'),\n+                        ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')];\n+static UPPER: Class = &[('A', 'Z')];\n+static WORD: Class = &[('0', '9'), ('A', 'Z'), ('a', 'z'), ('_', '_')];\n+static XDIGIT: Class = &[('0', '9'), ('A', 'F'), ('a', 'f')];"}, {"sha": "eebe9b85e3b9daaf070898df0ef56cf5ec990b41", "filename": "src/libregex/re.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -128,7 +128,7 @@ pub struct ExNative {\n     #[doc(hidden)]\n     pub original: &'static str,\n     #[doc(hidden)]\n-    pub names: &'static [Option<&'static str>],\n+    pub names: &'static &'static [Option<&'static str>],\n     #[doc(hidden)]\n     pub prog: fn(MatchKind, &str, uint, uint) -> Vec<Option<uint>>\n }"}, {"sha": "04c0e7cc21fb1390b9862c796654b0797b1999b0", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -324,7 +324,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n \n ::regex::native::Native(::regex::native::ExNative {\n     original: $regex,\n-    names: CAP_NAMES,\n+    names: &CAP_NAMES,\n     prog: exec,\n })\n         })"}, {"sha": "fc5d726bf67c24c351dc5c368e3586b9436d1c21", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -55,22 +55,22 @@ use syntax::parse::token;\n \n // This is the \"magic number\" expected at the beginning of a LLVM bytecode\n // object in an rlib.\n-pub static RLIB_BYTECODE_OBJECT_MAGIC: &'static [u8] = b\"RUST_OBJECT\";\n+pub const RLIB_BYTECODE_OBJECT_MAGIC: &'static [u8] = b\"RUST_OBJECT\";\n \n // The version number this compiler will write to bytecode objects in rlibs\n-pub static RLIB_BYTECODE_OBJECT_VERSION: u32 = 1;\n+pub const RLIB_BYTECODE_OBJECT_VERSION: u32 = 1;\n \n // The offset in bytes the bytecode object format version number can be found at\n-pub static RLIB_BYTECODE_OBJECT_VERSION_OFFSET: uint = 11;\n+pub const RLIB_BYTECODE_OBJECT_VERSION_OFFSET: uint = 11;\n \n // The offset in bytes the size of the compressed bytecode can be found at in\n // format version 1\n-pub static RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET: uint =\n+pub const RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET: uint =\n     RLIB_BYTECODE_OBJECT_VERSION_OFFSET + 4;\n \n // The offset in bytes the compressed LLVM bytecode can be found at in format\n // version 1\n-pub static RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: uint =\n+pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: uint =\n     RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n \n "}, {"sha": "fdd3c5b5a2608b8782ccc57f71390171ca5b6540", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -154,10 +154,10 @@ pub enum CrateType {\n \n macro_rules! debugging_opts(\n     ([ $opt:ident ] $cnt:expr ) => (\n-        pub static $opt: u64 = 1 << $cnt;\n+        pub const $opt: u64 = 1 << $cnt;\n     );\n     ([ $opt:ident, $($rest:ident),* ] $cnt:expr ) => (\n-        pub static $opt: u64 = 1 << $cnt;\n+        pub const $opt: u64 = 1 << $cnt;\n         debugging_opts!([ $($rest),* ] $cnt + 1)\n     )\n )\n@@ -268,7 +268,7 @@ macro_rules! cgoptions(\n     }\n \n     pub type CodegenSetter = fn(&mut CodegenOptions, v: Option<&str>) -> bool;\n-    pub static CG_OPTIONS: &'static [(&'static str, CodegenSetter,\n+    pub const CG_OPTIONS: &'static [(&'static str, CodegenSetter,\n                                       &'static str)] =\n         &[ $( (stringify!($opt), cgsetters::$opt, $desc) ),* ];\n "}, {"sha": "451d39fbc3defe19b8f54865eb83c48138bb90fb", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -978,7 +978,8 @@ impl LintPass for NonUppercaseStatics {\n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         match it.node {\n             // only check static constants\n-            ast::ItemStatic(_, ast::MutImmutable, _) => {\n+            ast::ItemStatic(_, ast::MutImmutable, _) |\n+            ast::ItemConst(..) => {\n                 let s = token::get_ident(it.ident);\n                 // check for lowercase letters rather than non-uppercase\n                 // ones (some scripts don't have a concept of\n@@ -998,7 +999,7 @@ impl LintPass for NonUppercaseStatics {\n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n-            (&ast::PatIdent(_, ref path1, _), Some(&def::DefStatic(_, false))) => {\n+            (&ast::PatIdent(_, ref path1, _), Some(&def::DefConst(..))) => {\n                 let s = token::get_ident(path1.node);\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n                     cx.span_lint(NON_UPPERCASE_STATICS, path1.span,"}, {"sha": "6d00724fb41fc1be400908b1a596ea1ba6ad24ee", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -112,9 +112,9 @@ impl LintStore {\n     pub fn register_pass(&mut self, sess: Option<&Session>,\n                          from_plugin: bool, pass: LintPassObject) {\n         for &lint in pass.get_lints().iter() {\n-            self.lints.push((lint, from_plugin));\n+            self.lints.push((*lint, from_plugin));\n \n-            let id = LintId::of(lint);\n+            let id = LintId::of(*lint);\n             if !self.by_name.insert(lint.name_lower(), id) {\n                 let msg = format!(\"duplicate specification of lint {}\", lint.name_lower());\n                 match (sess, from_plugin) {"}, {"sha": "5afe5326171d7851b0047c06c3407906daf8fd07", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -99,12 +99,12 @@ macro_rules! declare_lint (\n macro_rules! lint_array ( ($( $lint:expr ),*) => (\n     {\n         #[allow(non_uppercase_statics)]\n-        static array: LintArray = &[ $( $lint ),* ];\n+        static array: LintArray = &[ $( &$lint ),* ];\n         array\n     }\n ))\n \n-pub type LintArray = &'static [&'static Lint];\n+pub type LintArray = &'static [&'static &'static Lint];\n \n /// Trait for types providing lint checks.\n ///"}, {"sha": "492feee6f84b3033240d5e9dc586778eb252e33e", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -15,83 +15,83 @@ use back::svh::Svh;\n \n // EBML enum definitions and utils shared by the encoder and decoder\n \n-pub static tag_items: uint = 0x00;\n+pub const tag_items: uint = 0x00;\n \n-pub static tag_paths_data_name: uint = 0x01;\n+pub const tag_paths_data_name: uint = 0x01;\n \n-pub static tag_def_id: uint = 0x02;\n+pub const tag_def_id: uint = 0x02;\n \n-pub static tag_items_data: uint = 0x03;\n+pub const tag_items_data: uint = 0x03;\n \n-pub static tag_items_data_item: uint = 0x04;\n+pub const tag_items_data_item: uint = 0x04;\n \n-pub static tag_items_data_item_family: uint = 0x05;\n+pub const tag_items_data_item_family: uint = 0x05;\n \n-pub static tag_items_data_item_type: uint = 0x07;\n+pub const tag_items_data_item_type: uint = 0x07;\n \n-pub static tag_items_data_item_symbol: uint = 0x08;\n+pub const tag_items_data_item_symbol: uint = 0x08;\n \n-pub static tag_items_data_item_variant: uint = 0x09;\n+pub const tag_items_data_item_variant: uint = 0x09;\n \n-pub static tag_items_data_parent_item: uint = 0x0a;\n+pub const tag_items_data_parent_item: uint = 0x0a;\n \n-pub static tag_items_data_item_is_tuple_struct_ctor: uint = 0x0b;\n+pub const tag_items_data_item_is_tuple_struct_ctor: uint = 0x0b;\n \n-pub static tag_index: uint = 0x0c;\n+pub const tag_index: uint = 0x0c;\n \n-pub static tag_index_buckets: uint = 0x0d;\n+pub const tag_index_buckets: uint = 0x0d;\n \n-pub static tag_index_buckets_bucket: uint = 0x0e;\n+pub const tag_index_buckets_bucket: uint = 0x0e;\n \n-pub static tag_index_buckets_bucket_elt: uint = 0x0f;\n+pub const tag_index_buckets_bucket_elt: uint = 0x0f;\n \n-pub static tag_index_table: uint = 0x10;\n+pub const tag_index_table: uint = 0x10;\n \n-pub static tag_meta_item_name_value: uint = 0x11;\n+pub const tag_meta_item_name_value: uint = 0x11;\n \n-pub static tag_meta_item_name: uint = 0x12;\n+pub const tag_meta_item_name: uint = 0x12;\n \n-pub static tag_meta_item_value: uint = 0x13;\n+pub const tag_meta_item_value: uint = 0x13;\n \n-pub static tag_attributes: uint = 0x14;\n+pub const tag_attributes: uint = 0x14;\n \n-pub static tag_attribute: uint = 0x15;\n+pub const tag_attribute: uint = 0x15;\n \n-pub static tag_meta_item_word: uint = 0x16;\n+pub const tag_meta_item_word: uint = 0x16;\n \n-pub static tag_meta_item_list: uint = 0x17;\n+pub const tag_meta_item_list: uint = 0x17;\n \n // The list of crates that this crate depends on\n-pub static tag_crate_deps: uint = 0x18;\n+pub const tag_crate_deps: uint = 0x18;\n \n // A single crate dependency\n-pub static tag_crate_dep: uint = 0x19;\n+pub const tag_crate_dep: uint = 0x19;\n \n-pub static tag_crate_hash: uint = 0x1a;\n-pub static tag_crate_crate_name: uint = 0x1b;\n+pub const tag_crate_hash: uint = 0x1a;\n+pub const tag_crate_crate_name: uint = 0x1b;\n \n-pub static tag_crate_dep_crate_name: uint = 0x1d;\n-pub static tag_crate_dep_hash: uint = 0x1e;\n+pub const tag_crate_dep_crate_name: uint = 0x1d;\n+pub const tag_crate_dep_hash: uint = 0x1e;\n \n-pub static tag_mod_impl: uint = 0x1f;\n+pub const tag_mod_impl: uint = 0x1f;\n \n-pub static tag_item_trait_item: uint = 0x20;\n+pub const tag_item_trait_item: uint = 0x20;\n \n-pub static tag_item_trait_ref: uint = 0x21;\n-pub static tag_item_super_trait_ref: uint = 0x22;\n+pub const tag_item_trait_ref: uint = 0x21;\n+pub const tag_item_super_trait_ref: uint = 0x22;\n \n // discriminator value for variants\n-pub static tag_disr_val: uint = 0x23;\n+pub const tag_disr_val: uint = 0x23;\n \n // used to encode ast_map::PathElem\n-pub static tag_path: uint = 0x24;\n-pub static tag_path_len: uint = 0x25;\n-pub static tag_path_elem_mod: uint = 0x26;\n-pub static tag_path_elem_name: uint = 0x27;\n-pub static tag_item_field: uint = 0x28;\n-pub static tag_item_field_origin: uint = 0x29;\n-\n-pub static tag_item_variances: uint = 0x2a;\n+pub const tag_path: uint = 0x24;\n+pub const tag_path_len: uint = 0x25;\n+pub const tag_path_elem_mod: uint = 0x26;\n+pub const tag_path_elem_name: uint = 0x27;\n+pub const tag_item_field: uint = 0x28;\n+pub const tag_item_field_origin: uint = 0x29;\n+\n+pub const tag_item_variances: uint = 0x2a;\n /*\n   trait items contain tag_item_trait_item elements,\n   impl items contain tag_item_impl_item elements, and classes\n@@ -100,15 +100,15 @@ pub static tag_item_variances: uint = 0x2a;\n   both, tag_item_trait_item and tag_item_impl_item have to be two\n   different tags.\n  */\n-pub static tag_item_impl_item: uint = 0x30;\n-pub static tag_item_trait_method_explicit_self: uint = 0x31;\n+pub const tag_item_impl_item: uint = 0x30;\n+pub const tag_item_trait_method_explicit_self: uint = 0x31;\n \n \n // Reexports are found within module tags. Each reexport contains def_ids\n // and names.\n-pub static tag_items_data_item_reexport: uint = 0x38;\n-pub static tag_items_data_item_reexport_def_id: uint = 0x39;\n-pub static tag_items_data_item_reexport_name: uint = 0x3a;\n+pub const tag_items_data_item_reexport: uint = 0x38;\n+pub const tag_items_data_item_reexport_def_id: uint = 0x39;\n+pub const tag_items_data_item_reexport_name: uint = 0x3a;\n \n // used to encode crate_ctxt side tables\n #[deriving(PartialEq)]\n@@ -153,15 +153,15 @@ impl astencode_tag {\n     }\n }\n \n-pub static tag_item_trait_item_sort: uint = 0x60;\n+pub const tag_item_trait_item_sort: uint = 0x60;\n \n-pub static tag_item_trait_parent_sort: uint = 0x61;\n+pub const tag_item_trait_parent_sort: uint = 0x61;\n \n-pub static tag_item_impl_type_basename: uint = 0x62;\n+pub const tag_item_impl_type_basename: uint = 0x62;\n \n-pub static tag_crate_triple: uint = 0x66;\n+pub const tag_crate_triple: uint = 0x66;\n \n-pub static tag_dylib_dependency_formats: uint = 0x67;\n+pub const tag_dylib_dependency_formats: uint = 0x67;\n \n // Language items are a top-level directory (for speed). Hierarchy:\n //\n@@ -170,81 +170,81 @@ pub static tag_dylib_dependency_formats: uint = 0x67;\n //   - tag_lang_items_item_id: u32\n //   - tag_lang_items_item_node_id: u32\n \n-pub static tag_lang_items: uint = 0x70;\n-pub static tag_lang_items_item: uint = 0x71;\n-pub static tag_lang_items_item_id: uint = 0x72;\n-pub static tag_lang_items_item_node_id: uint = 0x73;\n-pub static tag_lang_items_missing: uint = 0x74;\n+pub const tag_lang_items: uint = 0x70;\n+pub const tag_lang_items_item: uint = 0x71;\n+pub const tag_lang_items_item_id: uint = 0x72;\n+pub const tag_lang_items_item_node_id: uint = 0x73;\n+pub const tag_lang_items_missing: uint = 0x74;\n \n-pub static tag_item_unnamed_field: uint = 0x75;\n-pub static tag_items_data_item_visibility: uint = 0x76;\n+pub const tag_item_unnamed_field: uint = 0x75;\n+pub const tag_items_data_item_visibility: uint = 0x76;\n \n-pub static tag_item_method_tps: uint = 0x79;\n-pub static tag_item_method_fty: uint = 0x7a;\n+pub const tag_item_method_tps: uint = 0x79;\n+pub const tag_item_method_fty: uint = 0x7a;\n \n-pub static tag_mod_child: uint = 0x7b;\n-pub static tag_misc_info: uint = 0x7c;\n-pub static tag_misc_info_crate_items: uint = 0x7d;\n+pub const tag_mod_child: uint = 0x7b;\n+pub const tag_misc_info: uint = 0x7c;\n+pub const tag_misc_info_crate_items: uint = 0x7d;\n \n-pub static tag_item_method_provided_source: uint = 0x7e;\n-pub static tag_item_impl_vtables: uint = 0x7f;\n+pub const tag_item_method_provided_source: uint = 0x7e;\n+pub const tag_item_impl_vtables: uint = 0x7f;\n \n-pub static tag_impls: uint = 0x80;\n-pub static tag_impls_impl: uint = 0x81;\n+pub const tag_impls: uint = 0x80;\n+pub const tag_impls_impl: uint = 0x81;\n \n-pub static tag_items_data_item_inherent_impl: uint = 0x82;\n-pub static tag_items_data_item_extension_impl: uint = 0x83;\n+pub const tag_items_data_item_inherent_impl: uint = 0x82;\n+pub const tag_items_data_item_extension_impl: uint = 0x83;\n \n // GAP 0x84, 0x85, 0x86\n \n-pub static tag_native_libraries: uint = 0x87;\n-pub static tag_native_libraries_lib: uint = 0x88;\n-pub static tag_native_libraries_name: uint = 0x89;\n-pub static tag_native_libraries_kind: uint = 0x8a;\n+pub const tag_native_libraries: uint = 0x87;\n+pub const tag_native_libraries_lib: uint = 0x88;\n+pub const tag_native_libraries_name: uint = 0x89;\n+pub const tag_native_libraries_kind: uint = 0x8a;\n \n-pub static tag_plugin_registrar_fn: uint = 0x8b;\n-pub static tag_exported_macros: uint = 0x8c;\n-pub static tag_macro_def: uint = 0x8d;\n+pub const tag_plugin_registrar_fn: uint = 0x8b;\n+pub const tag_exported_macros: uint = 0x8c;\n+pub const tag_macro_def: uint = 0x8d;\n \n-pub static tag_method_argument_names: uint = 0x8e;\n-pub static tag_method_argument_name: uint = 0x8f;\n+pub const tag_method_argument_names: uint = 0x8e;\n+pub const tag_method_argument_name: uint = 0x8f;\n \n-pub static tag_reachable_extern_fns: uint = 0x90;\n-pub static tag_reachable_extern_fn_id: uint = 0x91;\n+pub const tag_reachable_extern_fns: uint = 0x90;\n+pub const tag_reachable_extern_fn_id: uint = 0x91;\n \n-pub static tag_items_data_item_stability: uint = 0x92;\n+pub const tag_items_data_item_stability: uint = 0x92;\n \n-pub static tag_items_data_item_repr: uint = 0x93;\n+pub const tag_items_data_item_repr: uint = 0x93;\n \n #[deriving(Clone, Show)]\n pub struct LinkMeta {\n     pub crate_name: String,\n     pub crate_hash: Svh,\n }\n \n-pub static tag_unboxed_closures: uint = 0x95;\n-pub static tag_unboxed_closure: uint = 0x96;\n-pub static tag_unboxed_closure_type: uint = 0x97;\n-pub static tag_unboxed_closure_kind: uint = 0x98;\n+pub const tag_unboxed_closures: uint = 0x95;\n+pub const tag_unboxed_closure: uint = 0x96;\n+pub const tag_unboxed_closure_type: uint = 0x97;\n+pub const tag_unboxed_closure_kind: uint = 0x98;\n \n-pub static tag_struct_fields: uint = 0x99;\n-pub static tag_struct_field: uint = 0x9a;\n-pub static tag_struct_field_id: uint = 0x9b;\n+pub const tag_struct_fields: uint = 0x99;\n+pub const tag_struct_field: uint = 0x9a;\n+pub const tag_struct_field_id: uint = 0x9b;\n \n-pub static tag_attribute_is_sugared_doc: uint = 0x9c;\n+pub const tag_attribute_is_sugared_doc: uint = 0x9c;\n \n-pub static tag_trait_def_bounds: uint = 0x9d;\n+pub const tag_trait_def_bounds: uint = 0x9d;\n \n-pub static tag_items_data_region: uint = 0x9e;\n+pub const tag_items_data_region: uint = 0x9e;\n \n-pub static tag_region_param_def: uint = 0xa0;\n-pub static tag_region_param_def_ident: uint = 0xa1;\n-pub static tag_region_param_def_def_id: uint = 0xa2;\n-pub static tag_region_param_def_space: uint = 0xa3;\n-pub static tag_region_param_def_index: uint = 0xa4;\n+pub const tag_region_param_def: uint = 0xa0;\n+pub const tag_region_param_def_ident: uint = 0xa1;\n+pub const tag_region_param_def_def_id: uint = 0xa2;\n+pub const tag_region_param_def_space: uint = 0xa3;\n+pub const tag_region_param_def_index: uint = 0xa4;\n \n-pub static tag_type_param_def: uint = 0xa5;\n+pub const tag_type_param_def: uint = 0xa5;\n \n-pub static tag_item_generics: uint = 0xa6;\n-pub static tag_method_ty_generics: uint = 0xa7;\n+pub const tag_item_generics: uint = 0xa6;\n+pub const tag_method_ty_generics: uint = 0xa7;\n "}, {"sha": "dcf394aa3f406663938b54f1774699073526b007", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -126,12 +126,14 @@ enum Family {\n     Trait,                 // I\n     Struct,                // S\n     PublicField,           // g\n-    InheritedField         // N\n+    InheritedField,        // N\n+    Constant,              // C\n }\n \n fn item_family(item: rbml::Doc) -> Family {\n     let fam = reader::get_doc(item, tag_items_data_item_family);\n     match reader::doc_as_u8(fam) as char {\n+      'C' => Constant,\n       'c' => ImmStatic,\n       'b' => MutStatic,\n       'f' => Fn,\n@@ -303,6 +305,7 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     -> DefLike {\n     let fam = item_family(item);\n     match fam {\n+        Constant  => DlDef(def::DefConst(did)),\n         ImmStatic => DlDef(def::DefStatic(did, false)),\n         MutStatic => DlDef(def::DefStatic(did, true)),\n         Struct    => DlDef(def::DefStruct(did)),"}, {"sha": "02f6a4a78dbc819f26501c10f3abff01b80cb172", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -69,7 +69,6 @@ pub struct EncodeParams<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports2: &'a middle::resolve::ExportMap2,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n-    pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n     pub encode_inlined_item: EncodeInlinedItem<'a>,\n@@ -81,7 +80,6 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports2: &'a middle::resolve::ExportMap2,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n-    pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n     pub encode_inlined_item: RefCell<EncodeInlinedItem<'a>>,\n@@ -1069,12 +1067,20 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_symbol(ecx, rbml_w, item.id);\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n-\n-        let inlineable = !ecx.non_inlineable_statics.borrow().contains(&item.id);\n-\n-        if inlineable {\n-            encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n-        }\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n+        encode_attributes(rbml_w, item.attrs.as_slice());\n+        rbml_w.end_tag();\n+      }\n+      ItemConst(_, _) => {\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 'C');\n+        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_name(rbml_w, item.ident.name);\n+        encode_path(rbml_w, path);\n+        encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n@@ -2029,7 +2035,7 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n \n // NB: Increment this as you change the metadata encoding version.\n #[allow(non_uppercase_statics)]\n-pub static metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 1 ];\n+pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 1 ];\n \n pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> Vec<u8> {\n     let mut wr = SeekableMemWriter::new();\n@@ -2076,7 +2082,6 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter, parms: EncodeParams, krate:\n         cstore,\n         encode_inlined_item,\n         link_meta,\n-        non_inlineable_statics,\n         reachable,\n         ..\n     } = parms;\n@@ -2085,7 +2090,6 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter, parms: EncodeParams, krate:\n         tcx: tcx,\n         reexports2: reexports2,\n         item_symbols: item_symbols,\n-        non_inlineable_statics: non_inlineable_statics,\n         link_meta: link_meta,\n         cstore: cstore,\n         encode_inlined_item: RefCell::new(encode_inlined_item),"}, {"sha": "62c179f598c965c8396807986365105a829854f0", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -241,23 +241,23 @@ use std::collections::hashmap::{Occupied, Vacant};\n use flate;\n use time;\n \n-pub static MACOS_DLL_PREFIX: &'static str = \"lib\";\n-pub static MACOS_DLL_SUFFIX: &'static str = \".dylib\";\n+pub const MACOS_DLL_PREFIX: &'static str = \"lib\";\n+pub const MACOS_DLL_SUFFIX: &'static str = \".dylib\";\n \n-pub static WIN32_DLL_PREFIX: &'static str = \"\";\n-pub static WIN32_DLL_SUFFIX: &'static str = \".dll\";\n+pub const WIN32_DLL_PREFIX: &'static str = \"\";\n+pub const WIN32_DLL_SUFFIX: &'static str = \".dll\";\n \n-pub static LINUX_DLL_PREFIX: &'static str = \"lib\";\n-pub static LINUX_DLL_SUFFIX: &'static str = \".so\";\n+pub const LINUX_DLL_PREFIX: &'static str = \"lib\";\n+pub const LINUX_DLL_SUFFIX: &'static str = \".so\";\n \n-pub static FREEBSD_DLL_PREFIX: &'static str = \"lib\";\n-pub static FREEBSD_DLL_SUFFIX: &'static str = \".so\";\n+pub const FREEBSD_DLL_PREFIX: &'static str = \"lib\";\n+pub const FREEBSD_DLL_SUFFIX: &'static str = \".so\";\n \n-pub static DRAGONFLY_DLL_PREFIX: &'static str = \"lib\";\n-pub static DRAGONFLY_DLL_SUFFIX: &'static str = \".so\";\n+pub const DRAGONFLY_DLL_PREFIX: &'static str = \"lib\";\n+pub const DRAGONFLY_DLL_SUFFIX: &'static str = \".so\";\n \n-pub static ANDROID_DLL_PREFIX: &'static str = \"lib\";\n-pub static ANDROID_DLL_SUFFIX: &'static str = \".so\";\n+pub const ANDROID_DLL_PREFIX: &'static str = \"lib\";\n+pub const ANDROID_DLL_SUFFIX: &'static str = \".so\";\n \n pub struct CrateMismatch {\n     path: Path,"}, {"sha": "955228c99deedea6a0abc9e05dbb583ef1d18b10", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -460,6 +460,7 @@ impl tr for def::Def {\n           def::DefMod(did) => { def::DefMod(did.tr(dcx)) }\n           def::DefForeignMod(did) => { def::DefForeignMod(did.tr(dcx)) }\n           def::DefStatic(did, m) => { def::DefStatic(did.tr(dcx), m) }\n+          def::DefConst(did) => { def::DefConst(did.tr(dcx)) }\n           def::DefLocal(nid) => { def::DefLocal(dcx.tr_id(nid)) }\n           def::DefVariant(e_did, v_did, is_s) => {\n             def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)"}, {"sha": "f2ff104ba1d104bb623c4af915fb1faf0b3c2556", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -169,15 +169,11 @@ fn check_aliasability(bccx: &BorrowckCtxt,\n             // Borrow of an immutable static item:\n             match safety {\n                 mc::InteriorUnsafe => {\n-                    // If the static item contains an Unsafe<T>, it has interior mutability.\n-                    // In such cases, we cannot permit it to be borrowed, because the\n-                    // static item resides in immutable memory and mutating it would\n-                    // cause segfaults.\n-                    bccx.tcx.sess.span_err(borrow_span,\n-                                           \"borrow of immutable static items \\\n-                                            with unsafe interior is not \\\n-                                            allowed\");\n-                    Err(())\n+                    // If the static item contains an Unsafe<T>, it has interior\n+                    // mutability.  In such cases, another phase of the compiler\n+                    // will ensure that the type is `Sync` and then trans will\n+                    // not put it in rodata, so this is ok to allow.\n+                    Ok(())\n                 }\n                 mc::InteriorSafe => {\n                     // Immutable static can be borrowed, no problem."}, {"sha": "7d0d99443b0d85d5a12801f0705fe637d8bb0ade", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -106,7 +106,8 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n     // loan step is intended for things that have a data\n     // flow dependent conditions.\n     match item.node {\n-        ast::ItemStatic(_, _, ref ex) => {\n+        ast::ItemStatic(_, _, ref ex) |\n+        ast::ItemConst(_, ref ex) => {\n             gather_loans::gather_loans_in_static_initializer(this, &**ex);\n         }\n         _ => {"}, {"sha": "f0455db6e3bb693cdade8cf92ff6a549582291ad", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 82, "deletions": 68, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -47,7 +47,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         check_pat(self, p);\n     }\n     fn visit_expr(&mut self, ex: &Expr) {\n-        check_expr(self, ex);\n+        if check_expr(self, ex) {\n+            visit::walk_expr(self, ex);\n+        }\n     }\n }\n \n@@ -59,7 +61,8 @@ pub fn check_crate(tcx: &ty::ctxt) {\n \n fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n     match it.node {\n-        ItemStatic(_, _, ref ex) => {\n+        ItemStatic(_, _, ref ex) |\n+        ItemConst(_, ref ex) => {\n             v.inside_const(|v| v.visit_expr(&**ex));\n         }\n         ItemEnum(ref enum_definition, _) => {\n@@ -96,73 +99,81 @@ fn check_pat(v: &mut CheckCrateVisitor, p: &Pat) {\n     }\n }\n \n-fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) {\n-    if v.in_const {\n-        match e.node {\n-          ExprUnary(UnDeref, _) => { }\n-          ExprUnary(UnUniq, _) => {\n-            span_err!(v.tcx.sess, e.span, E0010, \"cannot do allocations in constant expressions\");\n-            return;\n-          }\n-          ExprLit(ref lit) if ast_util::lit_is_str(&**lit) => {}\n-          ExprBinary(..) | ExprUnary(..) => {\n+fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n+    if !v.in_const { return true }\n+\n+    match e.node {\n+        ExprUnary(UnDeref, _) => {}\n+        ExprUnary(UnUniq, _) => {\n+            span_err!(v.tcx.sess, e.span, E0010,\n+                      \"cannot do allocations in constant expressions\");\n+            return false;\n+        }\n+        ExprLit(ref lit) if ast_util::lit_is_str(&**lit) => {}\n+        ExprBinary(..) | ExprUnary(..) => {\n             let method_call = typeck::MethodCall::expr(e.id);\n             if v.tcx.method_map.borrow().contains_key(&method_call) {\n                 span_err!(v.tcx.sess, e.span, E0011,\n-                    \"user-defined operators are not allowed in constant expressions\");\n+                          \"user-defined operators are not allowed in constant \\\n+                           expressions\");\n             }\n-          }\n-          ExprLit(_) => (),\n-          ExprCast(_, _) => {\n+        }\n+        ExprLit(_) => (),\n+        ExprCast(_, _) => {\n             let ety = ty::expr_ty(v.tcx, e);\n             if !ty::type_is_numeric(ety) && !ty::type_is_unsafe_ptr(ety) {\n                 span_err!(v.tcx.sess, e.span, E0012,\n-                    \"can not cast to `{}` in a constant expression\",\n-                    ppaux::ty_to_string(v.tcx, ety)\n-                );\n+                          \"can not cast to `{}` in a constant expression\",\n+                          ppaux::ty_to_string(v.tcx, ety));\n             }\n-          }\n-          ExprPath(ref pth) => {\n+        }\n+        ExprPath(ref pth) => {\n             // NB: In the future you might wish to relax this slightly\n             // to handle on-demand instantiation of functions via\n             // foo::<bar> in a const. Currently that is only done on\n             // a path in trans::callee that only works in block contexts.\n             if !pth.segments.iter().all(|segment| segment.types.is_empty()) {\n                 span_err!(v.tcx.sess, e.span, E0013,\n-                    \"paths in constants may only refer to items without type parameters\");\n+                          \"paths in constants may only refer to items without \\\n+                           type parameters\");\n             }\n             match v.tcx.def_map.borrow().find(&e.id) {\n-              Some(&DefStatic(..)) |\n-              Some(&DefFn(..)) |\n-              Some(&DefVariant(_, _, _)) |\n-              Some(&DefStruct(_)) => { }\n-\n-              Some(&def) => {\n-                debug!(\"(checking const) found bad def: {:?}\", def);\n-                span_err!(v.tcx.sess, e.span, E0014,\n-                    \"paths in constants may only refer to constants or functions\");\n-              }\n-              None => {\n-                v.tcx.sess.span_bug(e.span, \"unbound path in const?!\");\n-              }\n+                Some(&DefStatic(..)) |\n+                Some(&DefConst(..)) |\n+                Some(&DefFn(..)) |\n+                Some(&DefVariant(_, _, _)) |\n+                Some(&DefStruct(_)) => { }\n+\n+                Some(&def) => {\n+                    debug!(\"(checking const) found bad def: {:?}\", def);\n+                    span_err!(v.tcx.sess, e.span, E0014,\n+                              \"paths in constants may only refer to constants \\\n+                               or functions\");\n+                }\n+                None => {\n+                    v.tcx.sess.span_bug(e.span, \"unbound path in const?!\");\n+                }\n             }\n-          }\n-          ExprCall(ref callee, _) => {\n+        }\n+        ExprCall(ref callee, _) => {\n             match v.tcx.def_map.borrow().find(&callee.id) {\n                 Some(&DefStruct(..)) |\n                 Some(&DefVariant(..)) => {}    // OK.\n+\n                 _ => {\n                     span_err!(v.tcx.sess, e.span, E0015,\n-                      \"function calls in constants are limited to struct and enum constructors\");\n+                              \"function calls in constants are limited to \\\n+                               struct and enum constructors\");\n                 }\n             }\n-          }\n-          ExprBlock(ref block) => {\n+        }\n+        ExprBlock(ref block) => {\n             // Check all statements in the block\n             for stmt in block.stmts.iter() {\n                 let block_span_err = |span|\n                     span_err!(v.tcx.sess, span, E0016,\n-                        \"blocks in constants are limited to items and tail expressions\");\n+                              \"blocks in constants are limited to items and \\\n+                               tail expressions\");\n                 match stmt.node {\n                     StmtDecl(ref span, _) => {\n                         match span.node {\n@@ -174,40 +185,43 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) {\n                     }\n                     StmtExpr(ref expr, _) => block_span_err(expr.span),\n                     StmtSemi(ref semi, _) => block_span_err(semi.span),\n-                    StmtMac(..) => v.tcx.sess.span_bug(e.span,\n-                        \"unexpanded statement macro in const?!\")\n+                    StmtMac(..) => {\n+                        v.tcx.sess.span_bug(e.span, \"unexpanded statement \\\n+                                                     macro in const?!\")\n+                    }\n                 }\n             }\n             match block.expr {\n-                Some(ref expr) => check_expr(v, &**expr),\n+                Some(ref expr) => { check_expr(v, &**expr); }\n                 None => {}\n             }\n-          }\n-          ExprVec(_) |\n-          ExprAddrOf(MutImmutable, _) |\n-          ExprParen(..) |\n-          ExprField(..) |\n-          ExprTupField(..) |\n-          ExprIndex(..) |\n-          ExprTup(..) |\n-          ExprRepeat(..) |\n-          ExprStruct(..) => { }\n-          ExprAddrOf(_, ref inner) => {\n-                match inner.node {\n-                    // Mutable slices are allowed.\n-                    ExprVec(_) => {}\n-                    _ => span_err!(v.tcx.sess, e.span, E0017,\n-                                   \"references in constants may only refer to immutable values\")\n+        }\n+        ExprVec(_) |\n+        ExprAddrOf(MutImmutable, _) |\n+        ExprParen(..) |\n+        ExprField(..) |\n+        ExprTupField(..) |\n+        ExprIndex(..) |\n+        ExprTup(..) |\n+        ExprRepeat(..) |\n+        ExprStruct(..) => {}\n \n-                }\n-          },\n+        ExprAddrOf(_, ref inner) => {\n+            match inner.node {\n+                // Mutable slices are allowed.\n+                ExprVec(_) => {}\n+                _ => span_err!(v.tcx.sess, e.span, E0017,\n+                               \"references in constants may only refer \\\n+                                to immutable values\")\n+\n+            }\n+        }\n \n-          _ => {\n-              span_err!(v.tcx.sess, e.span, E0019,\n-                  \"constant contains unimplemented expression type\");\n-              return;\n-          }\n+        _ => {\n+            span_err!(v.tcx.sess, e.span, E0019,\n+                      \"constant contains unimplemented expression type\");\n+            return false;\n         }\n     }\n-    visit::walk_expr(v, e);\n+    true\n }"}, {"sha": "297640707687c766bebb603a71325d286a7b877b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -32,7 +32,7 @@ use syntax::ptr::P;\n use syntax::visit::{mod, Visitor, FnKind};\n use util::ppaux::ty_to_string;\n \n-static DUMMY_WILD_PAT: Pat = Pat {\n+pub const DUMMY_WILD_PAT: Pat = Pat {\n     id: DUMMY_NODE_ID,\n     node: PatWild(PatWildSingle),\n     span: DUMMY_SP\n@@ -299,9 +299,10 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n     match is_useful(cx, matrix, &[&DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n+            let dummy = DUMMY_WILD_PAT.clone();\n             let witness = match pats.as_slice() {\n                 [ref witness] => &**witness,\n-                [] => &DUMMY_WILD_PAT,\n+                [] => &dummy,\n                 _ => unreachable!()\n             };\n             span_err!(cx.tcx.sess, sp, E0004,\n@@ -349,7 +350,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n             PatIdent(..) | PatEnum(..) => {\n                 let def = self.tcx.def_map.borrow().find_copy(&pat.id);\n                 match def {\n-                    Some(DefStatic(did, _)) => match lookup_const_by_id(self.tcx, did) {\n+                    Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did) {\n                         Some(const_expr) => {\n                             const_expr_to_pat(self.tcx, const_expr).map(|mut new_pat| {\n                                 new_pat.span = pat.span;\n@@ -359,7 +360,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                         None => {\n                             self.failed = true;\n                             span_err!(self.tcx.sess, pat.span, E0158,\n-                                \"extern statics cannot be referenced in patterns\");\n+                                \"statics cannot be referenced in patterns\");\n                             pat\n                         }\n                     },\n@@ -555,8 +556,9 @@ fn is_useful(cx: &MatchCheckCtxt,\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n                                 let pat_slice = pats.as_slice();\n+                                let dummy = DUMMY_WILD_PAT.clone();\n                                 let subpats = Vec::from_fn(arity, |i| {\n-                                    pat_slice.get(i).map_or(&DUMMY_WILD_PAT, |p| &**p)\n+                                    pat_slice.get(i).map_or(&dummy, |p| &**p)\n                                 });\n                                 vec![construct_witness(cx, &c, subpats, left_ty)]\n                             };\n@@ -578,8 +580,9 @@ fn is_useful(cx: &MatchCheckCtxt,\n                 }).collect();\n                 match is_useful(cx, &matrix, v.tail(), witness) {\n                     UsefulWithWitness(pats) => {\n+                        let dummy = DUMMY_WILD_PAT.clone();\n                         let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats = Vec::from_elem(arity, &DUMMY_WILD_PAT);\n+                        let wild_pats = Vec::from_elem(arity, &dummy);\n                         let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n                         let mut new_pats = vec![enum_pat];\n                         new_pats.extend(pats.into_iter());\n@@ -600,10 +603,11 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n                          v: &[&Pat], ctor: Constructor, lty: ty::t,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n+    let dummy = DUMMY_WILD_PAT.clone();\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, r.as_slice(), &ctor, 0u, arity)\n+        specialize(cx, r.as_slice(), &dummy, &ctor, 0u, arity)\n     }).collect());\n-    match specialize(cx, v, &ctor, 0u, arity) {\n+    match specialize(cx, v, &dummy, &ctor, 0u, arity) {\n         Some(v) => is_useful(cx, &matrix, v.as_slice(), witness),\n         None => NotUseful\n     }\n@@ -624,23 +628,26 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     match pat.node {\n         PatIdent(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n-                Some(&DefStatic(..)) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've been rewritten\"),\n+                Some(&DefConst(..)) =>\n+                    cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n+                                                    been rewritten\"),\n                 Some(&DefStruct(_)) => vec!(Single),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!()\n             },\n         PatEnum(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n-                Some(&DefStatic(..)) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've been rewritten\"),\n+                Some(&DefConst(..)) =>\n+                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've \\\n+                                                    been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n         PatStruct(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n-                Some(&DefStatic(..)) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've been rewritten\"),\n+                Some(&DefConst(..)) =>\n+                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've \\\n+                                                    been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n@@ -722,40 +729,42 @@ fn range_covered_by_constructor(ctor: &Constructor,\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n+pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat], dummy: &'a Pat,\n                       constructor: &Constructor, col: uint, arity: uint) -> Option<Vec<&'a Pat>> {\n     let &Pat {\n         id: pat_id, node: ref node, span: pat_span\n     } = raw_pat(r[col]);\n     let head: Option<Vec<&Pat>> = match node {\n \n         &PatWild(_) =>\n-            Some(Vec::from_elem(arity, &DUMMY_WILD_PAT)),\n+            Some(Vec::from_elem(arity, dummy)),\n \n         &PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n             match opt_def {\n-                Some(DefStatic(..)) =>\n-                    cx.tcx.sess.span_bug(pat_span, \"static pattern should've been rewritten\"),\n+                Some(DefConst(..)) =>\n+                    cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n+                                                    been rewritten\"),\n                 Some(DefVariant(_, id, _)) => if *constructor == Variant(id) {\n                     Some(vec!())\n                 } else {\n                     None\n                 },\n-                _ => Some(Vec::from_elem(arity, &DUMMY_WILD_PAT))\n+                _ => Some(Vec::from_elem(arity, dummy))\n             }\n         }\n \n         &PatEnum(_, ref args) => {\n             let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n             match def {\n-                DefStatic(..) =>\n-                    cx.tcx.sess.span_bug(pat_span, \"static pattern should've been rewritten\"),\n+                DefConst(..) =>\n+                    cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n+                                                    been rewritten\"),\n                 DefVariant(_, id, _) if *constructor != Variant(id) => None,\n                 DefVariant(..) | DefStruct(..) => {\n                     Some(match args {\n                         &Some(ref args) => args.iter().map(|p| &**p).collect(),\n-                        &None => Vec::from_elem(arity, &DUMMY_WILD_PAT)\n+                        &None => Vec::from_elem(arity, dummy)\n                     })\n                 }\n                 _ => None\n@@ -766,8 +775,9 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             // Is this a struct or an enum variant?\n             let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n             let class_id = match def {\n-                DefStatic(..) =>\n-                    cx.tcx.sess.span_bug(pat_span, \"static pattern should've been rewritten\"),\n+                DefConst(..) =>\n+                    cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n+                                                    been rewritten\"),\n                 DefVariant(_, variant_id, _) => if *constructor == Variant(variant_id) {\n                     Some(variant_id)\n                 } else {\n@@ -790,7 +800,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 let args = struct_fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n                         Some(ref f) => &*f.pat,\n-                        _ => &DUMMY_WILD_PAT\n+                        _ => dummy\n                     }\n                 }).collect();\n                 args\n@@ -833,13 +843,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 // Fixed-length vectors.\n                 Single => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| &DUMMY_WILD_PAT);\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| dummy);\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n                 Slice(length) if before.len() + after.len() <= length && slice.is_some() => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| &DUMMY_WILD_PAT);\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| dummy);\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },"}, {"sha": "9cc1f92dc9304ed8b2f3aed79131f65346b3e82a", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 244, "deletions": 63, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -25,71 +25,124 @@\n // by borrowck::gather_loans\n \n use middle::ty;\n+use middle::def;\n+use middle::typeck;\n+use middle::traits;\n+use middle::mem_categorization as mc;\n+use middle::expr_use_visitor as euv;\n+use util::nodemap::NodeSet;\n \n use syntax::ast;\n+use syntax::print::pprust;\n use syntax::visit::Visitor;\n+use syntax::codemap::{DUMMY_SP, Span};\n use syntax::visit;\n-use syntax::print::pprust;\n-\n-\n-fn safe_type_for_static_mut(cx: &ty::ctxt, e: &ast::Expr) -> Option<String> {\n-    let node_ty = ty::node_id_to_type(cx, e.id);\n-    let tcontents = ty::type_contents(cx, node_ty);\n-    debug!(\"safe_type_for_static_mut(dtor={}, managed={}, owned={})\",\n-           tcontents.has_dtor(), tcontents.owns_managed(), tcontents.owns_owned())\n-\n-    let suffix = if tcontents.has_dtor() {\n-        \"destructors\"\n-    } else if tcontents.owns_managed() {\n-        \"managed pointers\"\n-    } else if tcontents.owns_owned() {\n-        \"owned pointers\"\n-    } else {\n-        return None;\n-    };\n \n-    Some(format!(\"mutable static items are not allowed to have {}\", suffix))\n+#[deriving(Eq, PartialEq)]\n+enum Mode {\n+    InConstant,\n+    InStatic,\n+    InStaticMut,\n+    InNothing,\n }\n \n struct CheckStaticVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    in_const: bool\n+    mode: Mode,\n+    checker: &'a mut GlobalChecker,\n+}\n+\n+struct GlobalVisitor<'a, 'b, 't: 'b>(euv::ExprUseVisitor<'a, 'b, ty::ctxt<'t>>);\n+struct GlobalChecker {\n+    static_consumptions: NodeSet,\n+    const_borrows: NodeSet,\n+    static_interior_borrows: NodeSet,\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n-    visit::walk_crate(&mut CheckStaticVisitor { tcx: tcx, in_const: false },\n-                      tcx.map.krate())\n+    let mut checker = GlobalChecker {\n+        static_consumptions: NodeSet::new(),\n+        const_borrows: NodeSet::new(),\n+        static_interior_borrows: NodeSet::new(),\n+    };\n+    {\n+        let visitor = euv::ExprUseVisitor::new(&mut checker, tcx);\n+        visit::walk_crate(&mut GlobalVisitor(visitor), tcx.map.krate());\n+    }\n+    visit::walk_crate(&mut CheckStaticVisitor {\n+        tcx: tcx,\n+        mode: InNothing,\n+        checker: &mut checker,\n+    }, tcx.map.krate());\n }\n \n impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n-    fn with_const(&mut self, in_const: bool, f: |&mut CheckStaticVisitor<'a, 'tcx>|) {\n-        let was_const = self.in_const;\n-        self.in_const = in_const;\n+    fn with_mode(&mut self, mode: Mode, f: |&mut CheckStaticVisitor<'a, 'tcx>|) {\n+        let old = self.mode;\n+        self.mode = mode;\n         f(self);\n-        self.in_const = was_const;\n+        self.mode = old;\n+    }\n+\n+    fn msg(&self) -> &'static str {\n+        match self.mode {\n+            InConstant => \"constants\",\n+            InStaticMut | InStatic => \"statics\",\n+            InNothing => unreachable!(),\n+        }\n+    }\n+\n+    fn check_static_mut_type(&self, e: &ast::Expr) {\n+        let node_ty = ty::node_id_to_type(self.tcx, e.id);\n+        let tcontents = ty::type_contents(self.tcx, node_ty);\n+\n+        let suffix = if tcontents.has_dtor() {\n+            \"destructors\"\n+        } else if tcontents.owns_owned() {\n+            \"owned pointers\"\n+        } else {\n+            return\n+        };\n+\n+        self.tcx.sess.span_err(e.span, format!(\"mutable statics are not allowed \\\n+                                                to have {}\", suffix).as_slice());\n+    }\n+\n+    fn check_static_type(&self, e: &ast::Expr) {\n+        let ty = ty::node_id_to_type(self.tcx, e.id);\n+        let infcx = typeck::infer::new_infer_ctxt(self.tcx);\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let cause = traits::ObligationCause::misc(DUMMY_SP);\n+        let obligation = traits::obligation_for_builtin_bound(self.tcx, cause, ty,\n+                                                              ty::BoundSync);\n+        fulfill_cx.register_obligation(self.tcx, obligation.unwrap());\n+        let env = ty::empty_parameter_environment();\n+        let result = fulfill_cx.select_all_or_error(&infcx, &env, self.tcx).is_ok();\n+        if !result {\n+            self.tcx.sess.span_err(e.span, \"shared static items must have a \\\n+                                            type which implements Sync\");\n+        }\n     }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n         debug!(\"visit_item(item={})\", pprust::item_to_string(i));\n         match i.node {\n-            ast::ItemStatic(_, mutability, ref expr) => {\n-                match mutability {\n-                    ast::MutImmutable => {\n-                        self.with_const(true, |v| v.visit_expr(&**expr));\n-                    }\n-                    ast::MutMutable => {\n-                        match safe_type_for_static_mut(self.tcx, &**expr) {\n-                            Some(msg) => {\n-                                self.tcx.sess.span_err(expr.span, msg.as_slice());\n-                            }\n-                            None => {}\n-                        }\n-                    }\n-                }\n+            ast::ItemStatic(_, ast::MutImmutable, ref expr) => {\n+                self.check_static_type(&**expr);\n+                self.with_mode(InStatic, |v| v.visit_expr(&**expr));\n+            }\n+            ast::ItemStatic(_, ast::MutMutable, ref expr) => {\n+                self.check_static_mut_type(&**expr);\n+                self.with_mode(InStaticMut, |v| v.visit_expr(&**expr));\n+            }\n+            ast::ItemConst(_, ref expr) => {\n+                self.with_mode(InConstant, |v| v.visit_expr(&**expr));\n+            }\n+            _ => {\n+                self.with_mode(InNothing, |v| visit::walk_item(v, i));\n             }\n-            _ => self.with_const(false, |v| visit::walk_item(v, i))\n         }\n     }\n \n@@ -100,42 +153,170 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n     /// of a static item, this method does nothing but walking\n     /// down through it.\n     fn visit_expr(&mut self, e: &ast::Expr) {\n-        debug!(\"visit_expr(expr={})\", pprust::expr_to_string(e));\n-\n-        if !self.in_const {\n+        if self.mode == InNothing {\n             return visit::walk_expr(self, e);\n         }\n \n-        match e.node {\n-            ast::ExprField(..) | ast::ExprTupField(..) | ast::ExprVec(..) |\n-            ast::ExprBlock(..) | ast::ExprTup(..)  => {\n-                visit::walk_expr(self, e);\n+        let node_ty = ty::node_id_to_type(self.tcx, e.id);\n+\n+        match ty::get(node_ty).sty {\n+            ty::ty_struct(did, _) |\n+            ty::ty_enum(did, _) if ty::has_dtor(self.tcx, did) => {\n+                self.tcx.sess.span_err(e.span,\n+                                       format!(\"{} are not allowed to have \\\n+                                                destructors\", self.msg()).as_slice())\n             }\n+            _ => {}\n+        }\n+\n+        // statics cannot be consumed by value at any time, that would imply\n+        // that they're an initializer (what a const is for) or kept in sync\n+        // over time (not feasible), so deny it outright.\n+        if self.checker.static_consumptions.remove(&e.id) {\n+            self.tcx.sess.span_err(e.span, \"cannot refer to other statics by \\\n+                                            value, use the address-of operator \\\n+                                            or a constant instead\");\n+        }\n+\n+        // Borrowed statics can specifically *only* have their address taken,\n+        // not any number of other borrows such as borrowing fields, reading\n+        // elements of an array, etc.\n+        if self.checker.static_interior_borrows.remove(&e.id) {\n+            self.tcx.sess.span_err(e.span, \"cannot refer to the interior of \\\n+                                            another static, use a constant \\\n+                                            instead\");\n+        }\n+\n+        // constants cannot be borrowed if they contain interior mutability as\n+        // it means that our \"silent insertion of statics\" could change\n+        // initializer values (very bad).\n+        if self.checker.const_borrows.remove(&e.id) {\n+            let node_ty = ty::node_id_to_type(self.tcx, e.id);\n+            let tcontents = ty::type_contents(self.tcx, node_ty);\n+            if tcontents.interior_unsafe() {\n+                self.tcx.sess.span_err(e.span, \"cannot borrow a constant which \\\n+                                                contains interior mutability, \\\n+                                                create a static instead\");\n+            }\n+        }\n+\n+        match e.node {\n             ast::ExprAddrOf(ast::MutMutable, _) => {\n-                span_err!(self.tcx.sess, e.span, E0020,\n-                    \"static items are not allowed to have mutable slices\");\n+                if self.mode != InStaticMut {\n+                    span_err!(self.tcx.sess, e.span, E0020,\n+                              \"{} are not allowed to have mutable references\",\n+                              self.msg());\n+                }\n             },\n             ast::ExprBox(..) |\n             ast::ExprUnary(ast::UnUniq, _) => {\n                 span_err!(self.tcx.sess, e.span, E0022,\n-                    \"static items are not allowed to have custom pointers\");\n+                          \"{} are not allowed to have custom pointers\",\n+                          self.msg());\n             }\n-            _ => {\n-                let node_ty = ty::node_id_to_type(self.tcx, e.id);\n-\n-                match ty::get(node_ty).sty {\n-                    ty::ty_struct(did, _) |\n-                    ty::ty_enum(did, _) => {\n-                        if ty::has_dtor(self.tcx, did) {\n-                            self.tcx.sess.span_err(e.span,\n-                                \"static items are not allowed to have destructors\");\n-                            return;\n-                        }\n+            ast::ExprPath(..) => {\n+                match ty::resolve_expr(self.tcx, e) {\n+                    def::DefStatic(..) if self.mode == InConstant => {\n+                        let msg = \"constants cannot refer to other statics, \\\n+                                   insert an intermediate constant \\\n+                                   instead\";\n+                        self.tcx.sess.span_err(e.span, msg.as_slice());\n                     }\n                     _ => {}\n                 }\n-                visit::walk_expr(self, e);\n             }\n+            _ => {}\n+        }\n+        visit::walk_expr(self, e);\n+    }\n+}\n+\n+impl<'a, 'b, 't, 'v> Visitor<'v> for GlobalVisitor<'a, 'b, 't> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemConst(_, ref e) |\n+            ast::ItemStatic(_, _, ref e) => {\n+                let GlobalVisitor(ref mut v) = *self;\n+                v.consume_expr(&**e);\n+            }\n+            _ => {}\n         }\n+        visit::walk_item(self, item);\n     }\n }\n+\n+impl euv::Delegate for GlobalChecker {\n+    fn consume(&mut self,\n+               consume_id: ast::NodeId,\n+               _consume_span: Span,\n+               cmt: mc::cmt,\n+               _mode: euv::ConsumeMode) {\n+        let mut cur = &cmt;\n+        loop {\n+            match cur.cat {\n+                mc::cat_static_item => {\n+                    self.static_consumptions.insert(consume_id);\n+                    break\n+                }\n+                mc::cat_deref(ref cmt, _, _) |\n+                mc::cat_discr(ref cmt, _) |\n+                mc::cat_downcast(ref cmt) |\n+                mc::cat_interior(ref cmt, _) => cur = cmt,\n+\n+                mc::cat_rvalue(..) |\n+                mc::cat_copied_upvar(..) |\n+                mc::cat_upvar(..) |\n+                mc::cat_local(..) => break,\n+            }\n+        }\n+    }\n+    fn borrow(&mut self,\n+              borrow_id: ast::NodeId,\n+              _borrow_span: Span,\n+              cmt: mc::cmt,\n+              _loan_region: ty::Region,\n+              _bk: ty::BorrowKind,\n+              _loan_cause: euv::LoanCause) {\n+        let mut cur = &cmt;\n+        let mut is_interior = false;\n+        loop {\n+            match cur.cat {\n+                mc::cat_rvalue(..) => {\n+                    self.const_borrows.insert(borrow_id);\n+                    break\n+                }\n+                mc::cat_static_item => {\n+                    if is_interior {\n+                        self.static_interior_borrows.insert(borrow_id);\n+                    }\n+                    break\n+                }\n+                mc::cat_deref(ref cmt, _, _) |\n+                mc::cat_interior(ref cmt, _) => {\n+                    is_interior = true;\n+                    cur = cmt;\n+                }\n+\n+                mc::cat_downcast(..) |\n+                mc::cat_discr(..) |\n+                mc::cat_copied_upvar(..) |\n+                mc::cat_upvar(..) |\n+                mc::cat_local(..) => unreachable!(),\n+            }\n+        }\n+    }\n+\n+    fn decl_without_init(&mut self,\n+                         _id: ast::NodeId,\n+                         _span: Span) {}\n+    fn mutate(&mut self,\n+              _assignment_id: ast::NodeId,\n+              _assignment_span: Span,\n+              _assignee_cmt: mc::cmt,\n+              _mode: euv::MutateMode) {}\n+    fn consume_pat(&mut self,\n+                   _consume_pat: &ast::Pat,\n+                   _cmt: mc::cmt,\n+                   _mode: euv::ConsumeMode) {}\n+}\n+"}, {"sha": "1f76d9dba263553e6d56a89caba63c793cece5fd", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -13,9 +13,9 @@\n \n use driver::session::Session;\n use middle::resolve;\n-use middle::def::DefStatic;\n+use middle::def::{DefStatic, DefConst};\n \n-use syntax::ast::{Crate, Expr, ExprPath, Item, ItemStatic, NodeId};\n+use syntax::ast;\n use syntax::{ast_util, ast_map};\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -27,13 +27,13 @@ struct CheckCrateVisitor<'a, 'ast: 'a> {\n }\n \n impl<'v, 'a, 'ast> Visitor<'v> for CheckCrateVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, i: &Item) {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         check_item(self, i);\n     }\n }\n \n pub fn check_crate<'ast>(sess: &Session,\n-                         krate: &Crate,\n+                         krate: &ast::Crate,\n                          def_map: &resolve::DefMap,\n                          ast_map: &ast_map::Map<'ast>) {\n     let mut visitor = CheckCrateVisitor {\n@@ -45,9 +45,10 @@ pub fn check_crate<'ast>(sess: &Session,\n     sess.abort_if_errors();\n }\n \n-fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n+fn check_item(v: &mut CheckCrateVisitor, it: &ast::Item) {\n     match it.node {\n-        ItemStatic(_, _, ref ex) => {\n+        ast::ItemStatic(_, _, ref ex) |\n+        ast::ItemConst(_, ref ex) => {\n             check_item_recursion(v.sess, v.ast_map, v.def_map, it);\n             visit::walk_expr(v, &**ex)\n         },\n@@ -56,19 +57,19 @@ fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n }\n \n struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n-    root_it: &'a Item,\n+    root_it: &'a ast::Item,\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map<'ast>,\n     def_map: &'a resolve::DefMap,\n-    idstack: Vec<NodeId>\n+    idstack: Vec<ast::NodeId>\n }\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n pub fn check_item_recursion<'a>(sess: &'a Session,\n                                 ast_map: &'a ast_map::Map,\n                                 def_map: &'a resolve::DefMap,\n-                                it: &'a Item) {\n+                                it: &'a ast::Item) {\n \n     let mut visitor = CheckItemRecursionVisitor {\n         root_it: it,\n@@ -81,7 +82,7 @@ pub fn check_item_recursion<'a>(sess: &'a Session,\n }\n \n impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, it: &Item) {\n+    fn visit_item(&mut self, it: &ast::Item) {\n         if self.idstack.iter().any(|x| x == &(it.id)) {\n             self.sess.span_err(self.root_it.span, \"recursive constant\");\n             return;\n@@ -91,11 +92,12 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n         self.idstack.pop();\n     }\n \n-    fn visit_expr(&mut self, e: &Expr) {\n+    fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ExprPath(..) => {\n+            ast::ExprPath(..) => {\n                 match self.def_map.borrow().find(&e.id) {\n-                    Some(&DefStatic(def_id, _)) if\n+                    Some(&DefStatic(def_id, _)) |\n+                    Some(&DefConst(def_id)) if\n                             ast_util::is_local(def_id) => {\n                         self.visit_item(&*self.ast_map.expect_item(def_id.node));\n                     }"}, {"sha": "abcdc45bdcfdec795bc7f5baf82eb52e473add75", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -87,7 +87,7 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n     let opt_def = tcx.def_map.borrow().find_copy(&e.id);\n     match opt_def {\n-        Some(def::DefStatic(def_id, false)) => {\n+        Some(def::DefConst(def_id)) => {\n             lookup_const_by_id(tcx, def_id)\n         }\n         Some(def::DefVariant(enum_def, variant_def, _)) => {\n@@ -155,7 +155,7 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n         match tcx.map.find(def_id.node) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n-                ItemStatic(_, ast::MutImmutable, ref const_expr) => {\n+                ItemConst(_, ref const_expr) => {\n                     Some(&**const_expr)\n                 }\n                 _ => None\n@@ -173,7 +173,7 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n         let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n             csearch::found(&ast::IIItem(ref item)) => match item.node {\n-                ItemStatic(_, ast::MutImmutable, ref const_expr) => Some(const_expr.id),\n+                ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n             _ => None"}, {"sha": "ff3720381009c187164ba5a78823c27cc3ee2c5c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -215,7 +215,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     ast::ItemFn(..)\n                     | ast::ItemEnum(..)\n                     | ast::ItemTy(..)\n-                    | ast::ItemStatic(..) => {\n+                    | ast::ItemStatic(..)\n+                    | ast::ItemConst(..) => {\n                         visit::walk_item(self, &*item);\n                     }\n                     _ => ()"}, {"sha": "3b7af9788ac57500bbe9ce5dee4a9d4876a709f0", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -20,6 +20,7 @@ pub enum Def {\n     DefMod(ast::DefId),\n     DefForeignMod(ast::DefId),\n     DefStatic(ast::DefId, bool /* is_mutbl */),\n+    DefConst(ast::DefId),\n     DefLocal(ast::NodeId),\n     DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n     DefTy(ast::DefId, bool /* is_enum */),\n@@ -61,7 +62,7 @@ impl Def {\n             DefForeignMod(id) | DefStatic(id, _) |\n             DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(id) |\n             DefTyParam(_, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n-            DefMethod(id, _) => {\n+            DefMethod(id, _) | DefConst(id) => {\n                 id\n             }\n             DefLocal(id) |"}, {"sha": "6cfdac93efc8ad93a3d89da8c3da053e7ea9e1fe", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -267,7 +267,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         }\n     }\n \n-    fn consume_expr(&mut self, expr: &ast::Expr) {\n+    pub fn consume_expr(&mut self, expr: &ast::Expr) {\n         debug!(\"consume_expr(expr={})\", expr.repr(self.tcx()));\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));"}, {"sha": "8484ec9293496da690040f446eeb3310df75a027", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -58,20 +58,20 @@ pub struct Edge<E> {\n #[deriving(Clone, PartialEq, Show)]\n pub struct NodeIndex(pub uint);\n #[allow(non_uppercase_statics)]\n-pub static InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n+pub const InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n \n #[deriving(PartialEq)]\n pub struct EdgeIndex(pub uint);\n #[allow(non_uppercase_statics)]\n-pub static InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n+pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n #[deriving(Show)]\n pub struct Direction { repr: uint }\n #[allow(non_uppercase_statics)]\n-pub static Outgoing: Direction = Direction { repr: 0 };\n+pub const Outgoing: Direction = Direction { repr: 0 };\n #[allow(non_uppercase_statics)]\n-pub static Incoming: Direction = Direction { repr: 1 };\n+pub const Incoming: Direction = Direction { repr: 1 };\n \n impl NodeIndex {\n     fn get(&self) -> uint { let NodeIndex(v) = *self; v }"}, {"sha": "fa494b357c19d5f8d100d4ffd819314be38ae182", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -544,7 +544,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         match def {\n           def::DefStruct(..) | def::DefVariant(..) | def::DefFn(..) |\n-          def::DefStaticMethod(..) => {\n+          def::DefStaticMethod(..) | def::DefConst(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n@@ -1104,7 +1104,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                                 |x,y,z| op(x,y,z)));\n                     }\n                 }\n-                Some(&def::DefStatic(..)) => {\n+                Some(&def::DefConst(..)) => {\n                     for subpat in subpats.iter() {\n                         if_ok!(self.cat_pattern(cmt.clone(), &**subpat, |x,y,z| op(x,y,z)));\n                     }"}, {"sha": "4d61baca70874860500cb5a560451b5f83690772", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -46,7 +46,7 @@ pub fn pat_is_const(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(_, _, None) | PatEnum(..) => {\n             match dm.borrow().find(&pat.id) {\n-                Some(&DefStatic(_, false)) => true,\n+                Some(&DefConst(..)) => true,\n                 _ => false\n             }\n         }"}, {"sha": "e434d859993c0e46ccf0b67f012293e20d764a84", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -805,6 +805,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             def::DefStaticMethod(..) => ck(\"static method\"),\n             def::DefFn(..) => ck(\"function\"),\n             def::DefStatic(..) => ck(\"static\"),\n+            def::DefConst(..) => ck(\"const\"),\n             def::DefVariant(..) => ck(\"variant\"),\n             def::DefTy(_, false) => ck(\"type\"),\n             def::DefTy(_, true) => ck(\"enum\"),\n@@ -1181,7 +1182,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            ast::ItemStatic(..) | ast::ItemStruct(..) |\n+            ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemStruct(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n             ast::ItemMac(..) => {}\n         }\n@@ -1245,7 +1246,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            ast::ItemStatic(..) |\n+            ast::ItemStatic(..) | ast::ItemConst(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n             ast::ItemMac(..) => {}\n         }"}, {"sha": "5d6f7048b82e14523d2a1a406c3067959fe7ce56", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -27,7 +27,6 @@ use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{is_local, PostExpansionMethod};\n-use syntax::ast_util;\n use syntax::attr::{InlineAlways, InlineHint, InlineNever, InlineNone};\n use syntax::attr;\n use syntax::visit::Visitor;\n@@ -121,15 +120,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                         self.worklist.push(def_id.node)\n                     } else {\n                         match def {\n-                            // If this path leads to a static, then we may have\n-                            // to do some work to figure out whether the static\n-                            // is indeed reachable. (Inlineable statics are\n-                            // never reachable.)\n-                            def::DefStatic(..) => {\n+                            // If this path leads to a constant, then we need to\n+                            // recurse into the constant to continue finding\n+                            // items that are reachable.\n+                            def::DefConst(..) => {\n                                 self.worklist.push(def_id.node);\n                             }\n \n-                            // If this wasn't a static, then this destination is\n+                            // If this wasn't a static, then the destination is\n                             // surely reachable.\n                             _ => {\n                                 self.reachable_symbols.insert(def_id.node);\n@@ -238,15 +236,14 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     fn propagate(&mut self) {\n         let mut scanned = HashSet::new();\n         loop {\n-            if self.worklist.len() == 0 {\n-                break\n-            }\n-            let search_item = self.worklist.pop().unwrap();\n-            if scanned.contains(&search_item) {\n+            let search_item = match self.worklist.pop() {\n+                Some(item) => item,\n+                None => break,\n+            };\n+            if !scanned.insert(search_item) {\n                 continue\n             }\n \n-            scanned.insert(search_item);\n             match self.tcx.map.find(search_item) {\n                 Some(ref item) => self.propagate_node(item, search_item),\n                 None if search_item == ast::CRATE_NODE_ID => {}\n@@ -297,21 +294,17 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         }\n                     }\n \n-                    // Statics with insignificant addresses are not reachable\n-                    // because they're inlined specially into all other crates.\n-                    ast::ItemStatic(_, mutbl, ref init) => {\n-                        if !ast_util::static_has_significant_address(\n-                                mutbl,\n-                                item.attrs.as_slice()) {\n-                            self.reachable_symbols.remove(&search_item);\n-                        }\n-                        visit::walk_expr(self, &**init);\n+                    // Reachable constants will be inlined into other crates\n+                    // unconditionally, so we need to make sure that their\n+                    // contents are also reachable.\n+                    ast::ItemConst(_, ref init) => {\n+                        self.visit_expr(&**init);\n                     }\n \n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n-                    ast::ItemTy(..) |\n+                    ast::ItemTy(..) | ast::ItemStatic(_, _, _) |\n                     ast::ItemMod(..) | ast::ItemForeignMod(..) |\n                     ast::ItemImpl(..) | ast::ItemTrait(..) |\n                     ast::ItemStruct(..) | ast::ItemEnum(..) => {}"}, {"sha": "d40c252d5f5e6f01d7364948d530a36caba36737", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -29,7 +29,7 @@ use syntax::ast::{ExprPath, ExprProc, ExprStruct, ExprUnboxedFn, FnDecl};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemEnum, ItemFn, ItemForeignMod};\n use syntax::ast::{ItemImpl, ItemMac, ItemMod, ItemStatic, ItemStruct};\n-use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local};\n+use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local, ItemConst};\n use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n@@ -1243,6 +1243,12 @@ impl<'a> Resolver<'a> {\n                     (DefStatic(local_def(item.id), mutbl), sp, is_public);\n                 parent\n             }\n+            ItemConst(_, _) => {\n+                self.add_child(ident, parent.clone(), ForbidDuplicateValues, sp)\n+                    .define_value(DefConst(local_def(item.id)),\n+                                  sp, is_public);\n+                parent\n+            }\n             ItemFn(_, fn_style, _, _, _) => {\n                 let name_bindings =\n                     self.add_child(ident, parent.clone(), ForbidDuplicateValues, sp);\n@@ -1829,7 +1835,7 @@ impl<'a> Resolver<'a> {\n                 csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n                     .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, is_public);\n           }\n-          DefFn(..) | DefStaticMethod(..) | DefStatic(..) => {\n+          DefFn(..) | DefStaticMethod(..) | DefStatic(..) | DefConst(..) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value (fn/static) {}\", final_ident);\n             child_name_bindings.define_value(def, DUMMY_SP, is_public);\n@@ -4216,7 +4222,7 @@ impl<'a> Resolver<'a> {\n                                       &**block);\n             }\n \n-            ItemStatic(..) => {\n+            ItemConst(..) | ItemStatic(..) => {\n                 self.with_constant_rib(|this| {\n                     visit::walk_item(this, item);\n                 });\n@@ -5106,6 +5112,7 @@ impl<'a> Resolver<'a> {\n                         Some(def @ (DefFn(..), _))      |\n                         Some(def @ (DefVariant(..), _)) |\n                         Some(def @ (DefStruct(..), _))  |\n+                        Some(def @ (DefConst(..), _))  |\n                         Some(def @ (DefStatic(..), _)) => {\n                             self.record_def(pattern.id, def);\n                         }\n@@ -5193,12 +5200,14 @@ impl<'a> Resolver<'a> {\n                             def @ DefVariant(..) | def @ DefStruct(..) => {\n                                 return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n                             }\n-                            def @ DefStatic(_, false) => {\n+                            def @ DefConst(..) => {\n                                 return FoundConst(def, LastMod(AllPublic));\n                             }\n-                            DefStatic(_, true) => {\n+                            DefStatic(..) => {\n                                 self.resolve_error(span,\n-                                    \"mutable static variables cannot be referenced in a pattern\");\n+                                                   \"static variables cannot be \\\n+                                                    referenced in a pattern, \\\n+                                                    use a `const` instead\");\n                                 return BareIdentifierPatternUnresolved;\n                             }\n                             _ => {"}, {"sha": "6d84b8cb49dd2319809190e8886a13f09779fce1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             ast::ItemMod(..) |\n             ast::ItemMac(..) |\n             ast::ItemForeignMod(..) |\n-            ast::ItemStatic(..) => {\n+            ast::ItemStatic(..) | ast::ItemConst(..) => {\n                 self.with(|_, f| f(RootScope), |v| visit::walk_item(v, item));\n                 return;\n             }"}, {"sha": "4aba29d7bae1639d4888a625b6d0fb5275265455", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -230,6 +230,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefAssociatedTy(..) |\n             def::DefTrait(_) => Some(recorder::TypeRef),\n             def::DefStatic(_, _) |\n+            def::DefConst(_) |\n             def::DefLocal(_) |\n             def::DefVariant(_, _, _) |\n             def::DefUpvar(..) => Some(recorder::VarRef),\n@@ -521,6 +522,29 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.visit_expr(expr);\n     }\n \n+    fn process_const(&mut self,\n+                      item: &ast::Item,\n+                      typ: &ast::Ty,\n+                      expr: &ast::Expr)\n+    {\n+        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+\n+        let sub_span = self.span.sub_span_after_keyword(item.span,\n+                                                        keywords::Const);\n+        self.fmt.static_str(item.span,\n+                            sub_span,\n+                            item.id,\n+                            get_ident(item.ident).get(),\n+                            qualname.as_slice(),\n+                            \"\",\n+                            ty_to_string(&*typ).as_slice(),\n+                            self.cur_scope);\n+\n+        // walk type and init value\n+        self.visit_ty(&*typ);\n+        self.visit_expr(expr);\n+    }\n+\n     fn process_struct(&mut self,\n                       item: &ast::Item,\n                       def: &ast::StructDef,\n@@ -740,6 +764,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefUpvar(..) |\n             def::DefLocal(..) |\n             def::DefStatic(..) |\n+            def::DefConst(..) |\n             def::DefVariant(..) => self.fmt.ref_str(recorder::VarRef,\n                                                     ex.span,\n                                                     sub_span,\n@@ -807,6 +832,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             },\n             def::DefLocal(_) |\n             def::DefStatic(_,_) |\n+            def::DefConst(..) |\n             def::DefStruct(_) |\n             def::DefFn(..) => self.write_sub_paths_truncated(path),\n             _ => {},\n@@ -1008,6 +1034,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.process_fn(item, &**decl, ty_params, &**body),\n             ast::ItemStatic(ref typ, mt, ref expr) =>\n                 self.process_static(item, &**typ, mt, &**expr),\n+            ast::ItemConst(ref typ, ref expr) =>\n+                self.process_const(item, &**typ, &**expr),\n             ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, &**def, ty_params),\n             ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n             ast::ItemImpl(ref ty_params,\n@@ -1386,6 +1414,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                             self.cur_scope),\n                 // FIXME(nrc) what is this doing here?\n                 def::DefStatic(_, _) => {}\n+                def::DefConst(..) => {}\n                 _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n                             *def)\n             }"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/librustc/middle/traexpr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftraexpr", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftraexpr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraexpr?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d"}, {"sha": "9eb02717f04a11e2b81ad6bf572fa06e6fb8e180", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -271,14 +271,14 @@ impl<'a> Opt<'a> {\n         match *self {\n             ConstantValue(ConstantExpr(lit_expr)) => {\n                 let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n-                let (llval, _, _) = consts::const_expr(ccx, &*lit_expr, true);\n+                let (llval, _) = consts::const_expr(ccx, &*lit_expr);\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n                 SingleResult(Result::new(bcx, lit_datum.val))\n             }\n             ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2)) => {\n-                let (l1, _, _) = consts::const_expr(ccx, &**l1, true);\n-                let (l2, _, _) = consts::const_expr(ccx, &**l2, true);\n+                let (l1, _) = consts::const_expr(ccx, &**l1);\n+                let (l2, _) = consts::const_expr(ccx, &**l2);\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }\n             Variant(disr_val, ref repr, _) => {\n@@ -350,7 +350,20 @@ struct ArmData<'p, 'blk, 'tcx: 'blk> {\n struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     pats: Vec<&'p ast::Pat>,\n     data: &'a ArmData<'p, 'blk, 'tcx>,\n-    bound_ptrs: Vec<(Ident, ValueRef)>\n+    bound_ptrs: Vec<(Ident, ValueRef)>,\n+\n+    // This is a pointer to an instance of check_match::DUMMY_WILD_PAT. The\n+    // check_match code requires that we pass this in (with the same lifetime as\n+    // the patterns passed in). Unfortunately this is required to be propagated\n+    // into this structure in order to get the lifetimes to work.\n+    //\n+    // Lots of the `check_match` code will deal with &DUMMY_WILD_PAT when\n+    // returning references, which used to have the `'static` lifetime before\n+    // const was added to the language. The DUMMY_WILD_PAT does not implement\n+    // Sync, however, so it must be a const, which longer has a static lifetime,\n+    // hence we're passing it in here. This certainly isn't crucial, and if it\n+    // can be removed, please do!\n+    dummy: &'p ast::Pat,\n }\n \n impl<'a, 'p, 'blk, 'tcx> Repr for Match<'a, 'p, 'blk, 'tcx> {\n@@ -403,21 +416,22 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         *pats.get_mut(col) = pat;\n         Match {\n             pats: pats,\n+            dummy: br.dummy,\n             data: &*br.data,\n             bound_ptrs: bound_ptrs\n         }\n     }).collect()\n }\n \n-type EnterPatterns<'a> = <'p> |&[&'p ast::Pat]|: 'a -> Option<Vec<&'p ast::Pat>>;\n+type EnterPatterns<'a, 'p> = |&[&'p ast::Pat]|: 'a -> Option<Vec<&'p ast::Pat>>;\n \n-fn enter_match<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   dm: &DefMap,\n-                                   m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                   col: uint,\n-                                   val: ValueRef,\n-                                   e: EnterPatterns)\n-                                   -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n+fn enter_match<'a, 'b, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       dm: &DefMap,\n+                                       m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                       col: uint,\n+                                       val: ValueRef,\n+                                       e: EnterPatterns<'b, 'p>)\n+                                       -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -450,6 +464,7 @@ fn enter_match<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n             Match {\n                 pats: pats,\n+                dummy: br.dummy,\n                 data: br.data,\n                 bound_ptrs: bound_ptrs\n             }\n@@ -544,7 +559,8 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n \n     let mcx = check_match::MatchCheckCtxt { tcx: bcx.tcx() };\n     enter_match(bcx, dm, m, col, val, |pats|\n-        check_match::specialize(&mcx, pats.as_slice(), &ctor, col, variant_size)\n+        check_match::specialize(&mcx, pats.as_slice(), m[0].dummy, &ctor, col,\n+                                variant_size)\n     )\n }\n \n@@ -1025,7 +1041,9 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     match adt_vals {\n         Some(field_vals) => {\n             let pats = enter_match(bcx, dm, m, col, val, |pats|\n-                check_match::specialize(&mcx, pats, &check_match::Single, col, field_vals.len())\n+                check_match::specialize(&mcx, pats, m[0].dummy,\n+                                        &check_match::Single, col,\n+                                        field_vals.len())\n             );\n             let vals = field_vals.append(vals_left.as_slice());\n             compile_submatch(bcx, pats.as_slice(), vals.as_slice(), chk, has_genuine_default);\n@@ -1347,6 +1365,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         bindings_map: create_bindings_map(bcx, &**arm.pats.get(0), discr_expr, &*arm.body)\n     }).collect();\n \n+    let dummy = check_match::DUMMY_WILD_PAT.clone();\n     let mut static_inliner = StaticInliner::new(scope_cx.tcx());\n     let arm_pats: Vec<Vec<P<ast::Pat>>> = arm_datas.iter().map(|arm_data| {\n         arm_data.arm.pats.iter().map(|p| static_inliner.fold_pat((*p).clone())).collect()\n@@ -1355,6 +1374,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     for (arm_data, pats) in arm_datas.iter().zip(arm_pats.iter()) {\n         matches.extend(pats.iter().map(|p| Match {\n             pats: vec![&**p],\n+            dummy: &dummy,\n             data: arm_data,\n             bound_ptrs: Vec::new(),\n         }));"}, {"sha": "8df5b375a81678f1b15bca07db999d7fa87c88a1", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 45, "deletions": 65, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -32,7 +32,7 @@ use driver::config::{NoDebugInfo, FullDebugInfo};\n use driver::driver::{CrateAnalysis, CrateTranslation, ModuleTranslation};\n use driver::session::Session;\n use lint;\n-use llvm::{BasicBlockRef, ModuleRef, ValueRef, Vector, get_param};\n+use llvm::{BasicBlockRef, ValueRef, Vector, get_param};\n use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n@@ -89,7 +89,7 @@ use std::rc::Rc;\n use std::{i8, i16, i32, i64};\n use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel, Rust, RustCall};\n use syntax::abi::{RustIntrinsic, Abi, OsWindows};\n-use syntax::ast_util::{local_def, is_local};\n+use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -317,17 +317,31 @@ pub fn decl_internal_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> Va\n     llfn\n }\n \n-pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n-                        name: &str, ty: Type) -> ValueRef {\n-    match externs.find_equiv(&name) {\n+pub fn get_extern_const(ccx: &CrateContext, did: ast::DefId,\n+                        t: ty::t) -> ValueRef {\n+    let name = csearch::get_symbol(&ccx.sess().cstore, did);\n+    let ty = type_of(ccx, t);\n+    match ccx.externs().borrow_mut().find(&name) {\n         Some(n) => return *n,\n         None => ()\n     }\n     unsafe {\n         let c = name.with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(llmod, ty.to_ref(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod(), ty.to_ref(), buf)\n         });\n-        externs.insert(name.to_string(), c);\n+        // Thread-local statics in some other crate need to *always* be linked\n+        // against in a thread-local fashion, so we need to be sure to apply the\n+        // thread-local attribute locally if it was present remotely. If we\n+        // don't do this then linker errors can be generated where the linker\n+        // complains that one object files has a thread local version of the\n+        // symbol and another one doesn't.\n+        ty::each_attr(ccx.tcx(), did, |attr| {\n+            if attr.check_name(\"thread_local\") {\n+                llvm::set_thread_local(c, true);\n+            }\n+            true\n+        });\n+        ccx.externs().borrow_mut().insert(name.to_string(), c);\n         return c;\n     }\n }\n@@ -935,11 +949,7 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n             get_extern_rust_fn(ccx, t, name.as_slice(), did)\n         }\n         _ => {\n-            let llty = type_of(ccx, t);\n-            get_extern_const(&mut *ccx.externs().borrow_mut(),\n-                             ccx.llmod(),\n-                             name.as_slice(),\n-                             llty)\n+            get_extern_const(ccx, did, t)\n         }\n     }\n }\n@@ -2228,21 +2238,19 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemEnum(ref enum_definition, _) => {\n         enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n       }\n+      ast::ItemConst(_, ref expr) => {\n+          // Recurse on the expression to catch items in blocks\n+          let mut v = TransItemVisitor{ ccx: ccx };\n+          v.visit_expr(&**expr);\n+      }\n       ast::ItemStatic(_, m, ref expr) => {\n           // Recurse on the expression to catch items in blocks\n           let mut v = TransItemVisitor{ ccx: ccx };\n           v.visit_expr(&**expr);\n \n-          let trans_everywhere = attr::requests_inline(item.attrs.as_slice());\n-          for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n-              consts::trans_const(ccx, m, item.id);\n-\n-              let g = get_item_val(ccx, item.id);\n-              update_linkage(ccx,\n-                             g,\n-                             Some(item.id),\n-                             if is_origin { OriginalTranslation } else { InlinedCopy });\n-          }\n+          consts::trans_static(ccx, m, item.id);\n+          let g = get_item_val(ccx, item.id);\n+          update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n \n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n@@ -2253,7 +2261,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                                          static\");\n               }\n \n-              let v = ccx.const_values().borrow().get_copy(&item.id);\n+              let v = ccx.static_values().borrow().get_copy(&item.id);\n               unsafe {\n                   if !(llvm::LLVMConstIntGetZExtValue(v) != 0) {\n                       ccx.sess().span_fatal(expr.span, \"static assertion failed\");\n@@ -2667,23 +2675,21 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n-            let sym = exported_name(ccx, id, ty, i.attrs.as_slice());\n+            let sym = || exported_name(ccx, id, ty, i.attrs.as_slice());\n \n             let v = match i.node {\n-                ast::ItemStatic(_, mutbl, ref expr) => {\n+                ast::ItemStatic(_, _, ref expr) => {\n                     // If this static came from an external crate, then\n                     // we need to get the symbol from csearch instead of\n                     // using the current crate's name/version\n                     // information in the hash of the symbol\n+                    let sym = sym();\n                     debug!(\"making {}\", sym);\n-                    let is_local = !ccx.external_srcs().borrow().contains_key(&id);\n \n                     // We need the translated value here, because for enums the\n                     // LLVM type is not fully determined by the Rust type.\n-                    let (v, inlineable, ty) = consts::const_expr(ccx, &**expr, is_local);\n-                    ccx.const_values().borrow_mut().insert(id, v);\n-                    let mut inlineable = inlineable;\n-\n+                    let (v, ty) = consts::const_expr(ccx, &**expr);\n+                    ccx.static_values().borrow_mut().insert(id, v);\n                     unsafe {\n                         // boolean SSA values are i1, but they have to be stored in i8 slots,\n                         // otherwise some LLVM optimization passes don't work as expected\n@@ -2694,55 +2700,30 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         };\n                         if contains_null(sym.as_slice()) {\n                             ccx.sess().fatal(\n-                                format!(\"Illegal null byte in export_name value: `{}`\",\n-                                        sym).as_slice());\n+                                format!(\"Illegal null byte in export_name \\\n+                                         value: `{}`\", sym).as_slice());\n                         }\n                         let g = sym.as_slice().with_c_str(|buf| {\n                             llvm::LLVMAddGlobal(ccx.llmod(), llty, buf)\n                         });\n \n-                        // Apply the `unnamed_addr` attribute if\n-                        // requested\n-                        if !ast_util::static_has_significant_address(\n-                                mutbl,\n-                                i.attrs.as_slice()) {\n-                            llvm::SetUnnamedAddr(g, true);\n-\n-                            // This is a curious case where we must make\n-                            // all of these statics inlineable. If a\n-                            // global is not tagged as `#[inline(never)]`,\n-                            // then LLVM won't coalesce globals unless they\n-                            // have an internal linkage type. This means that\n-                            // external crates cannot use this global.\n-                            // This is a problem for things like inner\n-                            // statics in generic functions, because the\n-                            // function will be inlined into another\n-                            // crate and then attempt to link to the\n-                            // static in the original crate, only to\n-                            // find that it's not there. On the other\n-                            // side of inlining, the crates knows to\n-                            // not declare this static as\n-                            // available_externally (because it isn't)\n-                            inlineable = true;\n-                        }\n-\n                         if attr::contains_name(i.attrs.as_slice(),\n                                                \"thread_local\") {\n                             llvm::set_thread_local(g, true);\n                         }\n-\n-                        if !inlineable {\n-                            debug!(\"{} not inlined\", sym);\n-                            ccx.non_inlineable_statics().borrow_mut()\n-                                                      .insert(id);\n-                        }\n-\n                         ccx.item_symbols().borrow_mut().insert(i.id, sym);\n                         g\n                     }\n                 }\n \n+                ast::ItemConst(_, ref expr) => {\n+                    let (v, _) = consts::const_expr(ccx, &**expr);\n+                    ccx.const_values().borrow_mut().insert(id, v);\n+                    v\n+                }\n+\n                 ast::ItemFn(_, _, abi, _, _) => {\n+                    let sym = sym();\n                     let llfn = if abi == Rust {\n                         register_fn(ccx, i.span, sym, i.id, ty)\n                     } else {\n@@ -2911,7 +2892,6 @@ pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'tcx>,\n         tcx: cx.tcx(),\n         reexports2: cx.exp_map2(),\n         item_symbols: cx.item_symbols(),\n-        non_inlineable_statics: cx.non_inlineable_statics(),\n         link_meta: cx.link_meta(),\n         cstore: &cx.sess().cstore,\n         encode_inlined_item: ie,"}, {"sha": "bc562b39c98f75af9cc4212c5cb3af3aece8ba78", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -196,6 +196,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 }\n             }\n             def::DefStatic(..) |\n+            def::DefConst(..) |\n             def::DefLocal(..) |\n             def::DefUpvar(..) => {\n                 datum_callee(bcx, ref_expr)"}, {"sha": "392436d3a806994a5c08c1672ba07f9492e0084b", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -49,9 +49,9 @@ pub struct CustomScopeIndex {\n     index: uint\n }\n \n-pub static EXIT_BREAK: uint = 0;\n-pub static EXIT_LOOP: uint = 1;\n-pub static EXIT_MAX: uint = 2;\n+pub const EXIT_BREAK: uint = 0;\n+pub const EXIT_LOOP: uint = 1;\n+pub const EXIT_MAX: uint = 2;\n \n pub enum CleanupScopeKind<'blk, 'tcx: 'blk> {\n     CustomScopeKind,"}, {"sha": "ec357f7bfd7c68573758e677e2c2722173e45b55", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 106, "deletions": 100, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -33,7 +33,6 @@ use middle::ty;\n use util::ppaux::{Repr, ty_to_string};\n \n use std::c_str::ToCStr;\n-use std::vec;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n use syntax::ptr::P;\n@@ -96,24 +95,20 @@ pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     }\n }\n \n-// Helper function because we don't have tuple-swizzling.\n-fn first_two<R, S, T>((a, b, _): (R, S, T)) -> (R, S) {\n-    (a, b)\n-}\n-\n fn const_vec(cx: &CrateContext, e: &ast::Expr,\n-             es: &[P<ast::Expr>], is_local: bool) -> (ValueRef, Type, bool) {\n+             es: &[P<ast::Expr>]) -> (ValueRef, Type) {\n     let vec_ty = ty::expr_ty(cx.tcx(), e);\n     let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n-    let (vs, inlineable) = vec::unzip(es.iter().map(|e| first_two(const_expr(cx, &**e, is_local))));\n+    let vs = es.iter().map(|e| const_expr(cx, &**e).val0())\n+                      .collect::<Vec<_>>();\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n         C_struct(cx, vs.as_slice(), false)\n     } else {\n         C_array(llunitty, vs.as_slice())\n     };\n-    (v, llunitty, inlineable.iter().fold(true, |a, &b| a && b))\n+    (v, llunitty)\n }\n \n pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) -> ValueRef {\n@@ -177,29 +172,25 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n }\n \n pub fn get_const_val(cx: &CrateContext,\n-                     mut def_id: ast::DefId) -> (ValueRef, bool) {\n+                     mut def_id: ast::DefId) -> ValueRef {\n     let contains_key = cx.const_values().borrow().contains_key(&def_id.node);\n     if !ast_util::is_local(def_id) || !contains_key {\n         if !ast_util::is_local(def_id) {\n             def_id = inline::maybe_instantiate_inline(cx, def_id);\n         }\n \n         match cx.tcx().map.expect_item(def_id.node).node {\n-            ast::ItemStatic(_, ast::MutImmutable, _) => {\n-                trans_const(cx, ast::MutImmutable, def_id.node);\n-            }\n+            ast::ItemConst(..) => { base::get_item_val(cx, def_id.node); }\n             _ => {}\n         }\n     }\n \n-    (cx.const_values().borrow().get_copy(&def_id.node),\n-     !cx.non_inlineable_statics().borrow().contains(&def_id.node))\n+    cx.const_values().borrow().get_copy(&def_id.node)\n }\n \n-pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef, bool, ty::t) {\n-    let (llconst, inlineable) = const_expr_unadjusted(cx, e, is_local);\n+pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n+    let llconst = const_expr_unadjusted(cx, e);\n     let mut llconst = llconst;\n-    let mut inlineable = inlineable;\n     let ety = ty::expr_ty(cx.tcx(), e);\n     let mut ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e);\n     let opt_adj = cx.tcx().adjustments.borrow().find_copy(&e.id);\n@@ -213,7 +204,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                                                    ety_adjusted,\n                                                                    def,\n                                                                    llconst,\n-                                                                   is_local);\n+                                                                   true);\n                     llconst = C_struct(cx, [wrapper, C_null(Type::i8p(cx))], false)\n                 }\n                 ty::AdjustAddEnv(store) => {\n@@ -250,7 +241,6 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                     // Don't copy data to do a deref+ref\n                                     // (i.e., skip the last auto-deref).\n                                     if adj.autoderefs == 0 {\n-                                        inlineable = false;\n                                         llconst = const_addr_of(cx, llconst, ast::MutImmutable);\n                                     }\n                                 }\n@@ -271,7 +261,6 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n \n                                     match ty::get(ty).sty {\n                                         ty::ty_vec(unit_ty, Some(len)) => {\n-                                            inlineable = false;\n                                             let llunitty = type_of::type_of(cx, unit_ty);\n                                             let llptr = const_ptrcast(cx, llconst, llunitty);\n                                             assert_eq!(abi::slice_elt_base, 0);\n@@ -314,29 +303,25 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                          e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety),\n                          csize, tsize).as_slice());\n     }\n-    (llconst, inlineable, ety_adjusted)\n+    (llconst, ety_adjusted)\n }\n \n // the bool returned is whether this expression can be inlined into other crates\n // if it's assigned to a static.\n-fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n-                         is_local: bool) -> (ValueRef, bool) {\n+fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n     let map_list = |exprs: &[P<ast::Expr>]| {\n-        exprs.iter().map(|e| first_two(const_expr(cx, &**e, is_local)))\n-             .fold((Vec::new(), true),\n-                   |(l, all_inlineable), (val, inlineable)| {\n-                (l.append_one(val), all_inlineable && inlineable)\n-             })\n+        exprs.iter().map(|e| const_expr(cx, &**e).val0())\n+             .fold(Vec::new(), |l, val| l.append_one(val))\n     };\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n           ast::ExprLit(ref lit) => {\n-              (consts::const_lit(cx, e, &**lit), true)\n+              consts::const_lit(cx, e, &**lit)\n           }\n           ast::ExprBinary(b, ref e1, ref e2) => {\n-            let (te1, _, _) = const_expr(cx, &**e1, is_local);\n-            let (te2, _, _) = const_expr(cx, &**e2, is_local);\n+            let (te1, _) = const_expr(cx, &**e1);\n+            let (te2, _) = const_expr(cx, &**e2);\n \n             let te2 = base::cast_shift_const_rhs(b, te1, te2);\n \n@@ -345,7 +330,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n             let ty = ty::expr_ty(cx.tcx(), &**e1);\n             let is_float = ty::type_is_fp(ty);\n             let signed = ty::type_is_signed(ty);\n-            return (match b {\n+            return match b {\n               ast::BiAdd   => {\n                 if is_float { llvm::LLVMConstFAdd(te1, te2) }\n                 else        { llvm::LLVMConstAdd(te1, te2) }\n@@ -414,13 +399,13 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                       else      { ConstICmp(IntUGT, te1, te2) }\n                   }\n               },\n-            }, true)\n+            }\n           },\n           ast::ExprUnary(u, ref e) => {\n-            let (te, _, _) = const_expr(cx, &**e, is_local);\n+            let (te, _) = const_expr(cx, &**e);\n             let ty = ty::expr_ty(cx.tcx(), &**e);\n             let is_float = ty::type_is_fp(ty);\n-            return (match u {\n+            return match u {\n               ast::UnUniq | ast::UnDeref => {\n                 let (dv, _dt) = const_deref(cx, te, ty, true);\n                 dv\n@@ -430,26 +415,26 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 if is_float { llvm::LLVMConstFNeg(te) }\n                 else        { llvm::LLVMConstNeg(te) }\n               }\n-            }, true)\n+            }\n           }\n           ast::ExprField(ref base, field, _) => {\n-              let (bv, inlineable, bt) = const_expr(cx, &**base, is_local);\n+              let (bv, bt) = const_expr(cx, &**base);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx(), field.node.name, field_tys);\n-                  (adt::const_get_field(cx, &*brepr, bv, discr, ix), inlineable)\n+                  adt::const_get_field(cx, &*brepr, bv, discr, ix)\n               })\n           }\n           ast::ExprTupField(ref base, idx, _) => {\n-              let (bv, inlineable, bt) = const_expr(cx, &**base, is_local);\n+              let (bv, bt) = const_expr(cx, &**base);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, _| {\n-                  (adt::const_get_field(cx, &*brepr, bv, discr, idx.node), inlineable)\n+                  adt::const_get_field(cx, &*brepr, bv, discr, idx.node)\n               })\n           }\n \n           ast::ExprIndex(ref base, ref index) => {\n-              let (bv, inlineable, bt) = const_expr(cx, &**base, is_local);\n+              let (bv, bt) = const_expr(cx, &**base);\n               let iv = match const_eval::eval_const_expr(cx.tcx(), &**index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n@@ -500,13 +485,13 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                   cx.sess().span_err(e.span,\n                                      \"const index-expr is out of bounds\");\n               }\n-              (const_get_elt(cx, arr, [iv as c_uint]), inlineable)\n+              const_get_elt(cx, arr, [iv as c_uint])\n           }\n           ast::ExprCast(ref base, _) => {\n             let ety = ty::expr_ty(cx.tcx(), e);\n             let llty = type_of::type_of(cx, ety);\n-            let (v, inlineable, basety) = const_expr(cx, &**base, is_local);\n-            return (match (expr::cast_type_kind(cx.tcx(), basety),\n+            let (v, basety) = const_expr(cx, &**base);\n+            return match (expr::cast_type_kind(cx.tcx(), basety),\n                            expr::cast_type_kind(cx.tcx(), ety)) {\n \n               (expr::cast_integral, expr::cast_integral) => {\n@@ -554,54 +539,73 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 cx.sess().impossible_case(e.span,\n                                           \"bad combination of types for cast\")\n               }\n-            }, inlineable)\n+            }\n           }\n           ast::ExprAddrOf(mutbl, ref sub) => {\n-              let (e, _, _) = const_expr(cx, &**sub, is_local);\n-              (const_addr_of(cx, e, mutbl), false)\n+              // If this is the address of some static, then we need to return\n+              // the actual address of the static itself (short circuit the rest\n+              // of const eval).\n+              let mut cur = sub;\n+              loop {\n+                  match cur.node {\n+                      ast::ExprParen(ref sub) => cur = sub,\n+                      _ => break,\n+                  }\n+              }\n+              let opt_def = cx.tcx().def_map.borrow().find_copy(&cur.id);\n+              match opt_def {\n+                  Some(def::DefStatic(def_id, _)) => {\n+                      let ty = ty::expr_ty(cx.tcx(), e);\n+                      return get_static_val(cx, def_id, ty);\n+                  }\n+                  _ => {}\n+              }\n+\n+              // If this isn't the address of a static, then keep going through\n+              // normal constant evaluation.\n+              let (e, _) = const_expr(cx, &**sub);\n+              const_addr_of(cx, e, mutbl)\n           }\n           ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n-              let (vals, inlineable) = map_list(es.as_slice());\n-              (adt::trans_const(cx, &*repr, 0, vals.as_slice()), inlineable)\n+              let vals = map_list(es.as_slice());\n+              adt::trans_const(cx, &*repr, 0, vals.as_slice())\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n               let tcx = cx.tcx();\n \n               let base_val = match *base_opt {\n-                Some(ref base) => Some(const_expr(cx, &**base, is_local)),\n+                Some(ref base) => Some(const_expr(cx, &**base)),\n                 None => None\n               };\n \n               expr::with_field_tys(tcx, ety, Some(e.id), |discr, field_tys| {\n-                  let (cs, inlineable) = vec::unzip(field_tys.iter().enumerate()\n-                      .map(|(ix, &field_ty)| {\n+                  let cs = field_tys.iter().enumerate()\n+                                    .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.ident.name == f.ident.node.name) {\n-                          Some(ref f) => first_two(const_expr(cx, &*f.expr, is_local)),\n+                          Some(ref f) => const_expr(cx, &*f.expr).val0(),\n                           None => {\n                               match base_val {\n-                                Some((bv, inlineable, _)) => {\n-                                    (adt::const_get_field(cx, &*repr, bv, discr, ix),\n-                                     inlineable)\n-                                }\n-                                None => cx.sess().span_bug(e.span, \"missing struct field\")\n+                                  Some((bv, _)) => {\n+                                      adt::const_get_field(cx, &*repr, bv,\n+                                                           discr, ix)\n+                                  }\n+                                  None => {\n+                                      cx.sess().span_bug(e.span,\n+                                                         \"missing struct field\")\n+                                  }\n                               }\n                           }\n                       }\n-                  }));\n-                  (adt::trans_const(cx, &*repr, discr, cs.as_slice()),\n-                   inlineable.iter().fold(true, |a, &b| a && b))\n+                  }).collect::<Vec<_>>();\n+                  adt::trans_const(cx, &*repr, discr, cs.as_slice())\n               })\n           }\n           ast::ExprVec(ref es) => {\n-            let (v, _, inlineable) = const_vec(cx,\n-                                               e,\n-                                               es.as_slice(),\n-                                               is_local);\n-            (v, inlineable)\n+            const_vec(cx, e, es.as_slice()).val0()\n           }\n           ast::ExprRepeat(ref elem, ref count) => {\n             let vec_ty = ty::expr_ty(cx.tcx(), e);\n@@ -612,13 +616,12 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = Vec::from_elem(n, const_expr(cx, &**elem, is_local).val0());\n-            let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n+            let vs = Vec::from_elem(n, const_expr(cx, &**elem).val0());\n+            if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(cx, vs.as_slice(), false)\n             } else {\n                 C_array(llunitty, vs.as_slice())\n-            };\n-            (v, true)\n+            }\n           }\n           ast::ExprPath(ref pth) => {\n             // Assert that there are no type parameters in this path.\n@@ -629,13 +632,13 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 Some(def::DefFn(def_id, _fn_style, _)) => {\n                     if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx(), def_id).ty;\n-                        (base::trans_external_path(cx, def_id, ty), true)\n+                        base::trans_external_path(cx, def_id, ty)\n                     } else {\n                         assert!(ast_util::is_local(def_id));\n-                        (base::get_item_val(cx, def_id.node), true)\n+                        base::get_item_val(cx, def_id.node)\n                     }\n                 }\n-                Some(def::DefStatic(def_id, false)) => {\n+                Some(def::DefConst(def_id)) => {\n                     get_const_val(cx, def_id)\n                 }\n                 Some(def::DefVariant(enum_did, variant_did, _)) => {\n@@ -644,15 +647,16 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                     let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n-                    (adt::trans_const(cx, &*repr, vinfo.disr_val, []), true)\n+                    adt::trans_const(cx, &*repr, vinfo.disr_val, [])\n                 }\n                 Some(def::DefStruct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx(), e);\n                     let llty = type_of::type_of(cx, ety);\n-                    (C_null(llty), true)\n+                    C_null(llty)\n                 }\n                 _ => {\n-                    cx.sess().span_bug(e.span, \"expected a const, fn, struct, or variant def\")\n+                    cx.sess().span_bug(e.span, \"expected a const, fn, struct, \\\n+                                                or variant def\")\n                 }\n             }\n           }\n@@ -662,30 +666,29 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                   Some(def::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n-                      let (arg_vals, inlineable) = map_list(args.as_slice());\n-                      (adt::trans_const(cx, &*repr, 0, arg_vals.as_slice()),\n-                       inlineable)\n+                      let arg_vals = map_list(args.as_slice());\n+                      adt::trans_const(cx, &*repr, 0, arg_vals.as_slice())\n                   }\n                   Some(def::DefVariant(enum_did, variant_did, _)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                            enum_did,\n                                                            variant_did);\n-                      let (arg_vals, inlineable) = map_list(args.as_slice());\n-                      (adt::trans_const(cx,\n-                                        &*repr,\n-                                        vinfo.disr_val,\n-                                        arg_vals.as_slice()), inlineable)\n+                      let arg_vals = map_list(args.as_slice());\n+                      adt::trans_const(cx,\n+                                       &*repr,\n+                                       vinfo.disr_val,\n+                                       arg_vals.as_slice())\n                   }\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n-          ast::ExprParen(ref e) => first_two(const_expr(cx, &**e, is_local)),\n+          ast::ExprParen(ref e) => const_expr(cx, &**e).val0(),\n           ast::ExprBlock(ref block) => {\n             match block.expr {\n-                Some(ref expr) => first_two(const_expr(cx, &**expr, is_local)),\n-                None => (C_nil(cx), true)\n+                Some(ref expr) => const_expr(cx, &**expr).val0(),\n+                None => C_nil(cx)\n             }\n           }\n           _ => cx.sess().span_bug(e.span,\n@@ -694,13 +697,13 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n     }\n }\n \n-pub fn trans_const(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n+pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n     unsafe {\n-        let _icx = push_ctxt(\"trans_const\");\n+        let _icx = push_ctxt(\"trans_static\");\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = ccx.const_values().borrow().get_copy(&id);\n+        let v = ccx.static_values().borrow().get_copy(&id);\n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n         let v = if llvm::LLVMTypeOf(v) == Type::i1(ccx).to_ref() {\n@@ -710,17 +713,20 @@ pub fn trans_const(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n         };\n         llvm::LLVMSetInitializer(g, v);\n \n-        // `get_item_val` left `g` with external linkage, but we just set an\n-        // initializer for it.  But we don't know yet if `g` should really be\n-        // defined in this compilation unit, so we set its linkage to\n-        // `AvailableExternallyLinkage`.  (It's still a definition, but acts\n-        // like a declaration for most purposes.)  If `g` really should be\n-        // declared here, then `trans_item` will fix up the linkage later on.\n-        llvm::SetLinkage(g, llvm::AvailableExternallyLinkage);\n-\n+        // As an optimization, all shared statics which do not have interior\n+        // mutability are placed into read-only memory.\n         if m != ast::MutMutable {\n-            llvm::LLVMSetGlobalConstant(g, True);\n+            let node_ty = ty::node_id_to_type(ccx.tcx(), id);\n+            let tcontents = ty::type_contents(ccx.tcx(), node_ty);\n+            if !tcontents.interior_unsafe() {\n+                llvm::LLVMSetGlobalConstant(g, True);\n+            }\n         }\n         debuginfo::create_global_var_metadata(ccx, id, g);\n     }\n }\n+\n+fn get_static_val(ccx: &CrateContext, did: ast::DefId, ty: ty::t) -> ValueRef {\n+    if ast_util::is_local(did) { return base::get_item_val(ccx, did.node) }\n+    base::trans_external_path(ccx, did, ty)\n+}"}, {"sha": "ee5ba61a295cfb080a793fe881ef139ff9c91532", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -66,10 +66,6 @@ pub struct SharedCrateContext<'tcx> {\n     reachable: NodeSet,\n     item_symbols: RefCell<NodeMap<String>>,\n     link_meta: LinkMeta,\n-    /// A set of static items which cannot be inlined into other crates. This\n-    /// will prevent in IIItem() structures from being encoded into the metadata\n-    /// that is generated\n-    non_inlineable_statics: RefCell<NodeSet>,\n     symbol_hasher: RefCell<Sha256>,\n     tcx: ty::ctxt<'tcx>,\n     stats: Stats,\n@@ -121,6 +117,9 @@ pub struct LocalCrateContext {\n     /// Cache of emitted const values\n     const_values: RefCell<NodeMap<ValueRef>>,\n \n+    /// Cache of emitted static values\n+    static_values: RefCell<NodeMap<ValueRef>>,\n+\n     /// Cache of external const values\n     extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n@@ -259,7 +258,6 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             reachable: reachable,\n             item_symbols: RefCell::new(NodeMap::new()),\n             link_meta: link_meta,\n-            non_inlineable_statics: RefCell::new(NodeSet::new()),\n             symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n             stats: Stats {\n@@ -351,10 +349,6 @@ impl<'tcx> SharedCrateContext<'tcx> {\n         &self.link_meta\n     }\n \n-    pub fn non_inlineable_statics<'a>(&'a self) -> &'a RefCell<NodeSet> {\n-        &self.non_inlineable_statics\n-    }\n-\n     pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n         &self.symbol_hasher\n     }\n@@ -414,6 +408,7 @@ impl LocalCrateContext {\n                 const_cstr_cache: RefCell::new(HashMap::new()),\n                 const_globals: RefCell::new(HashMap::new()),\n                 const_values: RefCell::new(NodeMap::new()),\n+                static_values: RefCell::new(NodeMap::new()),\n                 extern_const_values: RefCell::new(DefIdMap::new()),\n                 impl_method_cache: RefCell::new(HashMap::new()),\n                 closure_bare_wrapper_cache: RefCell::new(HashMap::new()),\n@@ -610,10 +605,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.external_srcs\n     }\n \n-    pub fn non_inlineable_statics<'a>(&'a self) -> &'a RefCell<NodeSet> {\n-        &self.shared.non_inlineable_statics\n-    }\n-\n     pub fn monomorphized<'a>(&'a self) -> &'a RefCell<HashMap<MonoId, ValueRef>> {\n         &self.local.monomorphized\n     }\n@@ -638,6 +629,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.const_values\n     }\n \n+    pub fn static_values<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n+        &self.local.static_values\n+    }\n+\n     pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n         &self.local.extern_const_values\n     }"}, {"sha": "ec92f935c49be3ab2be09683e5b96187f4b70fa6", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -776,6 +776,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         ast_map::NodeItem(item) => {\n             match item.node {\n                 ast::ItemStatic(..) => (item.ident, item.span),\n+                ast::ItemConst(..) => (item.ident, item.span),\n                 _ => {\n                     cx.sess()\n                       .span_bug(item.span,"}, {"sha": "19c9c5e0119d2aafa255870b74be6a9fe2d0a999", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -36,7 +36,6 @@\n use back::abi;\n use llvm;\n use llvm::{ValueRef};\n-use metadata::csearch;\n use middle::def;\n use middle::mem_categorization::Typer;\n use middle::subst;\n@@ -839,25 +838,20 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_def_fn_unadjusted(bcx, ref_expr, def)\n         }\n         def::DefStatic(did, _) => {\n-            // There are three things that may happen here:\n+            // There are two things that may happen here:\n             //  1) If the static item is defined in this crate, it will be\n             //     translated using `get_item_val`, and we return a pointer to\n             //     the result.\n-            //  2) If the static item is defined in another crate, but is\n-            //     marked inlineable, then it will be inlined into this crate\n-            //     and then translated with `get_item_val`.  Again, we return a\n-            //     pointer to the result.\n-            //  3) If the static item is defined in another crate and is not\n-            //     marked inlineable, then we add (or reuse) a declaration of\n-            //     an external global, and return a pointer to that.\n+            //  2) If the static item is defined in another crate then we add\n+            //     (or reuse) a declaration of an external global, and return a\n+            //     pointer to that.\n             let const_ty = expr_ty(bcx, ref_expr);\n \n-            fn get_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, did: ast::DefId, const_ty: ty::t)\n-                                   -> ValueRef {\n+            fn get_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, did: ast::DefId,\n+                                   const_ty: ty::t) -> ValueRef {\n                 // For external constants, we don't inline.\n                 if did.krate == ast::LOCAL_CRATE {\n-                    // Case 1 or 2.  (The inlining in case 2 produces a new\n-                    // DefId in LOCAL_CRATE.)\n+                    // Case 1.\n \n                     // The LLVM global has the type of its initializer,\n                     // which may not be equal to the enum's type for\n@@ -866,36 +860,41 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n                     PointerCast(bcx, val, pty)\n                 } else {\n-                    // Case 3.\n-                    match bcx.ccx().extern_const_values().borrow().find(&did) {\n-                        None => {}  // Continue.\n-                        Some(llval) => {\n-                            return *llval;\n-                        }\n-                    }\n-\n-                    unsafe {\n-                        let llty = type_of::type_of(bcx.ccx(), const_ty);\n-                        let symbol = csearch::get_symbol(\n-                            &bcx.ccx().sess().cstore,\n-                            did);\n-                        let llval = symbol.as_slice().with_c_str(|buf| {\n-                                llvm::LLVMAddGlobal(bcx.ccx().llmod(),\n-                                                    llty.to_ref(),\n-                                                    buf)\n-                            });\n-                        bcx.ccx().extern_const_values().borrow_mut()\n-                           .insert(did, llval);\n-                        llval\n-                    }\n+                    // Case 2.\n+                    base::get_extern_const(bcx.ccx(), did, const_ty)\n                 }\n             }\n-            // The DefId produced by `maybe_instantiate_inline`\n-            // may be in the LOCAL_CRATE or not.\n-            let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n             let val = get_val(bcx, did, const_ty);\n             DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr))\n         }\n+        def::DefConst(did) => {\n+            // First, inline any external constants into the local crate so we\n+            // can be sure to get the LLVM value corresponding to it.\n+            let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n+            if did.krate != ast::LOCAL_CRATE {\n+                bcx.tcx().sess.span_bug(ref_expr.span,\n+                                        \"cross crate constant could not \\\n+                                         be inlined\");\n+            }\n+            let val = base::get_item_val(bcx.ccx(), did.node);\n+\n+            // Next, we need to crate a ByRef rvalue datum to return. We can't\n+            // use the normal .to_ref_datum() function because the type of\n+            // `val` is not actually the same as `const_ty`.\n+            //\n+            // To get around this, we make a custom alloca slot with the\n+            // appropriate type (const_ty), and then we cast it to a pointer of\n+            // typeof(val), store the value, and then hand this slot over to\n+            // the datum infrastructure.\n+            let const_ty = expr_ty(bcx, ref_expr);\n+            let llty = type_of::type_of(bcx.ccx(), const_ty);\n+            let slot = alloca(bcx, llty, \"const\");\n+            let pty = Type::from_ref(unsafe { llvm::LLVMTypeOf(val) }).ptr_to();\n+            Store(bcx, val, PointerCast(bcx, slot, pty));\n+\n+            let datum = Datum::new(slot, const_ty, Rvalue::new(ByRef));\n+            DatumBlock::new(bcx, datum.to_expr_datum())\n+        }\n         _ => {\n             DatumBlock::new(bcx, trans_local_var(bcx, def).to_expr_datum())\n         }"}, {"sha": "048402782a6d96b5a41d07ae4bd7efb533f0ff73", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -17,7 +17,6 @@ use middle::ty;\n \n use syntax::ast;\n use syntax::ast_util::{local_def, PostExpansionMethod};\n-use syntax::ast_util;\n \n fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n     -> Option<ast::DefId> {\n@@ -76,21 +75,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n                         }\n                     }\n                 }\n-                ast::ItemStatic(_, mutbl, _) => {\n-                    if !ast_util::static_has_significant_address(mutbl, item.attrs.as_slice()) {\n-                        // Inlined static items use internal linkage when\n-                        // possible, so that LLVM will coalesce globals with\n-                        // identical initializers.  (It only does this for\n-                        // globals with unnamed_addr and either internal or\n-                        // private linkage.)\n-                        Some(InternalLinkage)\n-                    } else {\n-                        // The address is significant, so we can't create an\n-                        // internal copy of the static.  (The copy would have a\n-                        // different address from the original.)\n-                        Some(AvailableExternallyLinkage)\n-                    }\n-                }\n+                ast::ItemConst(..) => None,\n                 _ => unreachable!(),\n             };\n "}, {"sha": "cea74c6573d545ba89f37b7628194fdf07c87703", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -68,7 +68,7 @@ use std::collections::enum_set::{EnumSet, CLike};\n \n pub type Disr = u64;\n \n-pub static INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n+pub const INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n \n // Data types\n \n@@ -918,7 +918,7 @@ mod primitives {\n         flags: super::has_ty_err as uint,\n     };\n \n-    pub static LAST_PRIMITIVE_ID: uint = 18;\n+    pub const LAST_PRIMITIVE_ID: uint = 18;\n }\n \n // NB: If you change this, you'll probably want to change the corresponding\n@@ -1374,6 +1374,7 @@ impl ParameterEnvironment {\n                     ast::ItemEnum(..) |\n                     ast::ItemStruct(..) |\n                     ast::ItemImpl(..) |\n+                    ast::ItemConst(..) |\n                     ast::ItemStatic(..) => {\n                         let def_id = ast_util::local_def(id);\n                         let pty = ty::lookup_item_type(cx, def_id);\n@@ -2199,7 +2200,7 @@ macro_rules! def_type_content_sets(\n             use middle::ty::TypeContents;\n             $(\n                 #[allow(non_uppercase_statics)]\n-                pub static $name: TypeContents = TypeContents { bits: $bits };\n+                pub const $name: TypeContents = TypeContents { bits: $bits };\n              )+\n         }\n     }\n@@ -3576,6 +3577,8 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def::DefUpvar(..) |\n                 def::DefLocal(..) => LvalueExpr,\n \n+                def::DefConst(..) => RvalueDatumExpr,\n+\n                 def => {\n                     tcx.sess.span_bug(\n                         expr.span,"}, {"sha": "efd0a2a0e48b2fcad2f33bf012d70be8d8052f74", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -440,8 +440,8 @@ pub fn ast_path_to_ty_relaxed<'tcx, AC: AstConv<'tcx>,\n     }\n }\n \n-pub static NO_REGIONS: uint = 1;\n-pub static NO_TPS: uint = 2;\n+pub const NO_REGIONS: uint = 1;\n+pub const NO_TPS: uint = 2;\n \n fn check_path_args(tcx: &ty::ctxt,\n                    path: &ast::Path,"}, {"sha": "68bb3fcf945446534dd93c0d5a1832f44e1ac317", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -677,7 +677,8 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     let _indenter = indenter();\n \n     match it.node {\n-      ast::ItemStatic(_, _, ref e) => check_const(ccx, it.span, &**e, it.id),\n+      ast::ItemStatic(_, _, ref e) |\n+      ast::ItemConst(_, ref e) => check_const(ccx, it.span, &**e, it.id),\n       ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n@@ -5083,7 +5084,7 @@ pub fn polytype_for_def(fcx: &FnCtxt,\n       }\n       def::DefFn(id, _, _) | def::DefStaticMethod(id, _, _) |\n       def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n-      def::DefStruct(id) => {\n+      def::DefStruct(id) | def::DefConst(id) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n       def::DefTrait(_) |\n@@ -5211,6 +5212,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n \n         // Case 2. Reference to a top-level value.\n         def::DefFn(..) |\n+        def::DefConst(..) |\n         def::DefStatic(..) => {\n             segment_spaces = Vec::from_elem(path.segments.len() - 1, None);\n             segment_spaces.push(Some(subst::FnSpace));"}, {"sha": "4c3cec1aff42f2005c760fb9de67ca9f87fbc73e", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -69,6 +69,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             ast::ItemStatic(..) => {\n                 self.check_item_type(item);\n             }\n+            ast::ItemConst(..) => {\n+                self.check_item_type(item);\n+            }\n             ast::ItemStruct(ref struct_def, _) => {\n                 self.check_type_defn(item, |fcx| {\n                     vec![struct_variant(fcx, &**struct_def)]"}, {"sha": "0b5c86fea7123435c926985f564e4ecdfdd6633a", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -1550,7 +1550,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n         _ => {}\n     }\n     match it.node {\n-        ast::ItemStatic(ref t, _, _) => {\n+        ast::ItemStatic(ref t, _, _) | ast::ItemConst(ref t, _) => {\n             let typ = ccx.to_ty(&ExplicitRscope, &**t);\n             let pty = no_params(typ);\n "}, {"sha": "87f3fd987871cdea8336a33a84896dcd4b364941", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -57,21 +57,21 @@ use middle::typeck::infer::{unresolved_int_ty,unresolved_float_ty,unresolved_ty}\n use syntax::codemap::Span;\n use util::ppaux::{Repr, ty_to_string};\n \n-pub static resolve_nested_tvar: uint = 0b0000000001;\n-pub static resolve_rvar: uint        = 0b0000000010;\n-pub static resolve_ivar: uint        = 0b0000000100;\n-pub static resolve_fvar: uint        = 0b0000001000;\n-pub static resolve_all: uint         = 0b0000001111;\n-pub static force_tvar: uint          = 0b0000100000;\n-pub static force_rvar: uint          = 0b0001000000;\n-pub static force_ivar: uint          = 0b0010000000;\n-pub static force_fvar: uint          = 0b0100000000;\n-pub static force_all: uint           = 0b0111100000;\n+pub const resolve_nested_tvar: uint = 0b0000000001;\n+pub const resolve_rvar: uint        = 0b0000000010;\n+pub const resolve_ivar: uint        = 0b0000000100;\n+pub const resolve_fvar: uint        = 0b0000001000;\n+pub const resolve_all: uint         = 0b0000001111;\n+pub const force_tvar: uint          = 0b0000100000;\n+pub const force_rvar: uint          = 0b0001000000;\n+pub const force_ivar: uint          = 0b0010000000;\n+pub const force_fvar: uint          = 0b0100000000;\n+pub const force_all: uint           = 0b0111100000;\n \n-pub static not_regions: uint         = !(force_rvar | resolve_rvar);\n+pub const not_regions: uint         = !(force_rvar | resolve_rvar);\n \n-pub static try_resolve_tvar_shallow: uint = 0;\n-pub static resolve_and_force_all_but_regions: uint =\n+pub const try_resolve_tvar_shallow: uint = 0;\n+pub const resolve_and_force_all_but_regions: uint =\n     (resolve_all | force_all) & not_regions;\n \n pub struct ResolveState<'a, 'tcx: 'a> {"}, {"sha": "6ef2143b624f821543f4759fa52720f9d2c5df3d", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             }\n \n             return match it.node {\n-                ast::ItemStatic(..) | ast::ItemFn(..) |\n+                ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemFn(..) |\n                 ast::ItemForeignMod(..) | ast::ItemTy(..) => {\n                     None\n                 }"}, {"sha": "60a7aa77904420b151b397fa31f1d3823472ce03", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -384,6 +384,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n \n             ast::ItemImpl(..) |\n             ast::ItemStatic(..) |\n+            ast::ItemConst(..) |\n             ast::ItemFn(..) |\n             ast::ItemMod(..) |\n             ast::ItemForeignMod(..) |\n@@ -528,6 +529,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             }\n \n             ast::ItemStatic(..) |\n+            ast::ItemConst(..) |\n             ast::ItemFn(..) |\n             ast::ItemMod(..) |\n             ast::ItemForeignMod(..) |"}, {"sha": "bf525db7661b008a41aa415a4fe066b413f714b3", "filename": "src/librustc_back/abi.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -10,20 +10,20 @@\n \n #![allow(non_uppercase_statics)]\n \n-pub static box_field_refcnt: uint = 0u;\n-pub static box_field_drop_glue: uint = 1u;\n-pub static box_field_body: uint = 4u;\n+pub const box_field_refcnt: uint = 0u;\n+pub const box_field_drop_glue: uint = 1u;\n+pub const box_field_body: uint = 4u;\n \n-pub static tydesc_field_visit_glue: uint = 3u;\n+pub const tydesc_field_visit_glue: uint = 3u;\n \n // The two halves of a closure: code and environment.\n-pub static fn_field_code: uint = 0u;\n-pub static fn_field_box: uint = 1u;\n+pub const fn_field_code: uint = 0u;\n+pub const fn_field_box: uint = 1u;\n \n // The two fields of a trait object/trait instance: vtable and box.\n // The vtable contains the type descriptor as first element.\n-pub static trt_field_box: uint = 0u;\n-pub static trt_field_vtable: uint = 1u;\n+pub const trt_field_box: uint = 0u;\n+pub const trt_field_vtable: uint = 1u;\n \n-pub static slice_elt_base: uint = 0u;\n-pub static slice_elt_len: uint = 1u;\n+pub const slice_elt_base: uint = 0u;\n+pub const slice_elt_len: uint = 1u;"}, {"sha": "e1576e37cc64cea92843a451d7fe83eacfc02437", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -43,8 +43,8 @@ pub mod diagnostic;\n pub type Opcode = u32;\n pub type Bool = c_uint;\n \n-pub static True: Bool = 1 as Bool;\n-pub static False: Bool = 0 as Bool;\n+pub const True: Bool = 1 as Bool;\n+pub const False: Bool = 0 as Bool;\n \n // Consts for the LLVM CallConv type, pre-cast to uint.\n \n@@ -93,32 +93,32 @@ pub enum DiagnosticSeverity {\n \n bitflags! {\n     flags Attribute : u32 {\n-        static ZExtAttribute = 1 << 0,\n-        static SExtAttribute = 1 << 1,\n-        static NoReturnAttribute = 1 << 2,\n-        static InRegAttribute = 1 << 3,\n-        static StructRetAttribute = 1 << 4,\n-        static NoUnwindAttribute = 1 << 5,\n-        static NoAliasAttribute = 1 << 6,\n-        static ByValAttribute = 1 << 7,\n-        static NestAttribute = 1 << 8,\n-        static ReadNoneAttribute = 1 << 9,\n-        static ReadOnlyAttribute = 1 << 10,\n-        static NoInlineAttribute = 1 << 11,\n-        static AlwaysInlineAttribute = 1 << 12,\n-        static OptimizeForSizeAttribute = 1 << 13,\n-        static StackProtectAttribute = 1 << 14,\n-        static StackProtectReqAttribute = 1 << 15,\n-        static AlignmentAttribute = 31 << 16,\n-        static NoCaptureAttribute = 1 << 21,\n-        static NoRedZoneAttribute = 1 << 22,\n-        static NoImplicitFloatAttribute = 1 << 23,\n-        static NakedAttribute = 1 << 24,\n-        static InlineHintAttribute = 1 << 25,\n-        static StackAttribute = 7 << 26,\n-        static ReturnsTwiceAttribute = 1 << 29,\n-        static UWTableAttribute = 1 << 30,\n-        static NonLazyBindAttribute = 1 << 31,\n+        const ZExtAttribute = 1 << 0,\n+        const SExtAttribute = 1 << 1,\n+        const NoReturnAttribute = 1 << 2,\n+        const InRegAttribute = 1 << 3,\n+        const StructRetAttribute = 1 << 4,\n+        const NoUnwindAttribute = 1 << 5,\n+        const NoAliasAttribute = 1 << 6,\n+        const ByValAttribute = 1 << 7,\n+        const NestAttribute = 1 << 8,\n+        const ReadNoneAttribute = 1 << 9,\n+        const ReadOnlyAttribute = 1 << 10,\n+        const NoInlineAttribute = 1 << 11,\n+        const AlwaysInlineAttribute = 1 << 12,\n+        const OptimizeForSizeAttribute = 1 << 13,\n+        const StackProtectAttribute = 1 << 14,\n+        const StackProtectReqAttribute = 1 << 15,\n+        const AlignmentAttribute = 31 << 16,\n+        const NoCaptureAttribute = 1 << 21,\n+        const NoRedZoneAttribute = 1 << 22,\n+        const NoImplicitFloatAttribute = 1 << 23,\n+        const NakedAttribute = 1 << 24,\n+        const InlineHintAttribute = 1 << 25,\n+        const StackAttribute = 7 << 26,\n+        const ReturnsTwiceAttribute = 1 << 29,\n+        const UWTableAttribute = 1 << 30,\n+        const NonLazyBindAttribute = 1 << 31,\n     }\n }\n "}, {"sha": "7e9bb2844a7c7a802de8f015574b42fa4d867736", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -300,6 +300,7 @@ pub enum ItemEnum {\n     ModuleItem(Module),\n     TypedefItem(Typedef),\n     StaticItem(Static),\n+    ConstantItem(Constant),\n     TraitItem(Trait),\n     ImplItem(Impl),\n     /// `use` and `extern crate`\n@@ -347,6 +348,7 @@ impl Clean<Item> for doctree::Module {\n             self.mods.clean(cx),\n             self.typedefs.clean(cx),\n             self.statics.clean(cx),\n+            self.constants.clean(cx),\n             self.traits.clean(cx),\n             self.impls.clean(cx),\n             self.view_items.clean(cx).into_iter()\n@@ -1741,6 +1743,29 @@ impl Clean<Item> for doctree::Static {\n     }\n }\n \n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Constant {\n+    pub type_: Type,\n+    pub expr: String,\n+}\n+\n+impl Clean<Item> for doctree::Constant {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            def_id: ast_util::local_def(self.id),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n+            inner: ConstantItem(Constant {\n+                type_: self.type_.clean(cx),\n+                expr: self.expr.span.to_src(cx),\n+            }),\n+        }\n+    }\n+}\n+\n #[deriving(Show, Clone, Encodable, Decodable, PartialEq)]\n pub enum Mutability {\n     Mutable,"}, {"sha": "b173f0f16e30d17d6c6070dada268bdb69833637", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -30,6 +30,7 @@ pub struct Module {\n     pub id: NodeId,\n     pub typedefs: Vec<Typedef>,\n     pub statics: Vec<Static>,\n+    pub constants: Vec<Constant>,\n     pub traits: Vec<Trait>,\n     pub vis: ast::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -56,6 +57,7 @@ impl Module {\n             mods       : Vec::new(),\n             typedefs   : Vec::new(),\n             statics    : Vec::new(),\n+            constants  : Vec::new(),\n             traits     : Vec::new(),\n             impls      : Vec::new(),\n             view_items : Vec::new(),\n@@ -151,6 +153,17 @@ pub struct Static {\n     pub whence: Span,\n }\n \n+pub struct Constant {\n+    pub type_: P<ast::Ty>,\n+    pub expr: P<ast::Expr>,\n+    pub name: Ident,\n+    pub attrs: Vec<ast::Attribute>,\n+    pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n+    pub id: ast::NodeId,\n+    pub whence: Span,\n+}\n+\n pub struct Trait {\n     pub name: Ident,\n     pub items: Vec<ast::TraitItem>, //should be TraitItem"}, {"sha": "ef921a84cfb8eea5f7a240ddc3b63b36ef989f62", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -38,10 +38,10 @@ mod imp {\n             pub l_sysid: libc::c_int,\n         }\n \n-        pub static F_WRLCK: libc::c_short = 1;\n-        pub static F_UNLCK: libc::c_short = 2;\n-        pub static F_SETLK: libc::c_int = 6;\n-        pub static F_SETLKW: libc::c_int = 7;\n+        pub const F_WRLCK: libc::c_short = 1;\n+        pub const F_UNLCK: libc::c_short = 2;\n+        pub const F_SETLK: libc::c_int = 6;\n+        pub const F_SETLKW: libc::c_int = 7;\n     }\n \n     #[cfg(target_os = \"freebsd\")]\n@@ -57,10 +57,10 @@ mod imp {\n             pub l_sysid: libc::c_int,\n         }\n \n-        pub static F_UNLCK: libc::c_short = 2;\n-        pub static F_WRLCK: libc::c_short = 3;\n-        pub static F_SETLK: libc::c_int = 12;\n-        pub static F_SETLKW: libc::c_int = 13;\n+        pub const F_UNLCK: libc::c_short = 2;\n+        pub const F_WRLCK: libc::c_short = 3;\n+        pub const F_SETLK: libc::c_int = 12;\n+        pub const F_SETLKW: libc::c_int = 13;\n     }\n \n     #[cfg(target_os = \"dragonfly\")]\n@@ -78,10 +78,10 @@ mod imp {\n             pub l_sysid: libc::c_int,\n         }\n \n-        pub static F_UNLCK: libc::c_short = 2;\n-        pub static F_WRLCK: libc::c_short = 3;\n-        pub static F_SETLK: libc::c_int = 8;\n-        pub static F_SETLKW: libc::c_int = 9;\n+        pub const F_UNLCK: libc::c_short = 2;\n+        pub const F_WRLCK: libc::c_short = 3;\n+        pub const F_SETLK: libc::c_int = 8;\n+        pub const F_SETLKW: libc::c_int = 9;\n     }\n \n     #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n@@ -99,10 +99,10 @@ mod imp {\n             pub l_sysid: libc::c_int,\n         }\n \n-        pub static F_UNLCK: libc::c_short = 2;\n-        pub static F_WRLCK: libc::c_short = 3;\n-        pub static F_SETLK: libc::c_int = 8;\n-        pub static F_SETLKW: libc::c_int = 9;\n+        pub const F_UNLCK: libc::c_short = 2;\n+        pub const F_WRLCK: libc::c_short = 3;\n+        pub const F_SETLK: libc::c_int = 8;\n+        pub const F_SETLKW: libc::c_int = 9;\n     }\n \n     pub struct Lock {"}, {"sha": "0b35f8ddc6963b397df5a633200553eec11b9cdd", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -39,6 +39,7 @@ pub enum ItemType {\n     Macro           = 15,\n     Primitive       = 16,\n     AssociatedType  = 17,\n+    Constant        = 18,\n }\n \n impl ItemType {\n@@ -62,6 +63,7 @@ impl ItemType {\n             Macro           => \"macro\",\n             Primitive       => \"primitive\",\n             AssociatedType  => \"associatedtype\",\n+            Constant        => \"constant\",\n         }\n     }\n }\n@@ -86,6 +88,7 @@ pub fn shortty(item: &clean::Item) -> ItemType {\n         clean::FunctionItem(..)        => Function,\n         clean::TypedefItem(..)         => Typedef,\n         clean::StaticItem(..)          => Static,\n+        clean::ConstantItem(..)        => Constant,\n         clean::TraitItem(..)           => Trait,\n         clean::ImplItem(..)            => Impl,\n         clean::ViewItemItem(..)        => ViewItem,"}, {"sha": "a5c6f79ef6b17fb7f6b0694655c44157a333d5de", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -48,16 +48,16 @@ pub struct Markdown<'a>(pub &'a str);\n /// table of contents.\n pub struct MarkdownWithToc<'a>(pub &'a str);\n \n-static DEF_OUNIT: libc::size_t = 64;\n-static HOEDOWN_EXT_NO_INTRA_EMPHASIS: libc::c_uint = 1 << 10;\n-static HOEDOWN_EXT_TABLES: libc::c_uint = 1 << 0;\n-static HOEDOWN_EXT_FENCED_CODE: libc::c_uint = 1 << 1;\n-static HOEDOWN_EXT_AUTOLINK: libc::c_uint = 1 << 3;\n-static HOEDOWN_EXT_STRIKETHROUGH: libc::c_uint = 1 << 4;\n-static HOEDOWN_EXT_SUPERSCRIPT: libc::c_uint = 1 << 8;\n-static HOEDOWN_EXT_FOOTNOTES: libc::c_uint = 1 << 2;\n-\n-static HOEDOWN_EXTENSIONS: libc::c_uint =\n+const DEF_OUNIT: libc::size_t = 64;\n+const HOEDOWN_EXT_NO_INTRA_EMPHASIS: libc::c_uint = 1 << 10;\n+const HOEDOWN_EXT_TABLES: libc::c_uint = 1 << 0;\n+const HOEDOWN_EXT_FENCED_CODE: libc::c_uint = 1 << 1;\n+const HOEDOWN_EXT_AUTOLINK: libc::c_uint = 1 << 3;\n+const HOEDOWN_EXT_STRIKETHROUGH: libc::c_uint = 1 << 4;\n+const HOEDOWN_EXT_SUPERSCRIPT: libc::c_uint = 1 << 8;\n+const HOEDOWN_EXT_FOOTNOTES: libc::c_uint = 1 << 2;\n+\n+const HOEDOWN_EXTENSIONS: libc::c_uint =\n     HOEDOWN_EXT_NO_INTRA_EMPHASIS | HOEDOWN_EXT_TABLES |\n     HOEDOWN_EXT_FENCED_CODE | HOEDOWN_EXT_AUTOLINK |\n     HOEDOWN_EXT_STRIKETHROUGH | HOEDOWN_EXT_SUPERSCRIPT |"}, {"sha": "497bbd3a1cd6bef5a552b5980bb59cc953530660", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -1471,6 +1471,8 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             (_, &clean::StructItem(..)) => Greater,\n             (&clean::EnumItem(..), _) => Less,\n             (_, &clean::EnumItem(..)) => Greater,\n+            (&clean::ConstantItem(..), _) => Less,\n+            (_, &clean::ConstantItem(..)) => Greater,\n             (&clean::StaticItem(..), _) => Less,\n             (_, &clean::StaticItem(..)) => Greater,\n             (&clean::ForeignFunctionItem(..), _) => Less,\n@@ -1507,6 +1509,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 clean::FunctionItem(..)        => (\"functions\", \"Functions\"),\n                 clean::TypedefItem(..)         => (\"types\", \"Type Definitions\"),\n                 clean::StaticItem(..)          => (\"statics\", \"Statics\"),\n+                clean::ConstantItem(..)        => (\"constants\", \"Constants\"),\n                 clean::TraitItem(..)           => (\"traits\", \"Traits\"),\n                 clean::ImplItem(..)            => (\"impls\", \"Implementations\"),\n                 clean::ViewItemItem(..)        => (\"reexports\", \"Reexports\"),\n@@ -1526,28 +1529,28 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                         id = short, name = name));\n         }\n \n-        match myitem.inner {\n-            clean::StaticItem(ref s) | clean::ForeignStaticItem(ref s) => {\n-                struct Initializer<'a>(&'a str, Item<'a>);\n-                impl<'a> fmt::Show for Initializer<'a> {\n-                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                        let Initializer(s, item) = *self;\n-                        if s.len() == 0 { return Ok(()); }\n-                        try!(write!(f, \"<code> = </code>\"));\n-                        if s.contains(\"\\n\") {\n-                            match item.href() {\n-                                Some(url) => {\n-                                    write!(f, \"<a href='{}'>[definition]</a>\",\n-                                           url)\n-                                }\n-                                None => Ok(()),\n-                            }\n-                        } else {\n-                            write!(f, \"<code>{}</code>\", s.as_slice())\n+        struct Initializer<'a>(&'a str, Item<'a>);\n+        impl<'a> fmt::Show for Initializer<'a> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                let Initializer(s, item) = *self;\n+                if s.len() == 0 { return Ok(()); }\n+                try!(write!(f, \"<code> = </code>\"));\n+                if s.contains(\"\\n\") {\n+                    match item.href() {\n+                        Some(url) => {\n+                            write!(f, \"<a href='{}'>[definition]</a>\",\n+                                   url)\n                         }\n+                        None => Ok(()),\n                     }\n+                } else {\n+                    write!(f, \"<code>{}</code>\", s.as_slice())\n                 }\n+            }\n+        }\n \n+        match myitem.inner {\n+            clean::StaticItem(ref s) | clean::ForeignStaticItem(ref s) => {\n                 try!(write!(w, \"\n                     <tr>\n                         <td>{}<code>{}static {}{}: {}</code>{}</td>\n@@ -1562,6 +1565,20 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 Initializer(s.expr.as_slice(), Item { cx: cx, item: myitem }),\n                 Markdown(blank(myitem.doc_value()))));\n             }\n+            clean::ConstantItem(ref s) => {\n+                try!(write!(w, \"\n+                    <tr>\n+                        <td>{}<code>{}const {}: {}</code>{}</td>\n+                        <td class='docblock'>{}&nbsp;</td>\n+                    </tr>\n+                \",\n+                ConciseStability(&myitem.stability),\n+                VisSpace(myitem.visibility),\n+                *myitem.name.get_ref(),\n+                s.type_,\n+                Initializer(s.expr.as_slice(), Item { cx: cx, item: myitem }),\n+                Markdown(blank(myitem.doc_value()))));\n+            }\n \n             clean::ViewItemItem(ref item) => {\n                 match item.inner {"}, {"sha": "7c6f7ed3fe23014151ad32712b00f4ed4495382e", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -569,7 +569,9 @@\n                          \"ffi\",\n                          \"ffs\",\n                          \"macro\",\n-                         \"primitive\"];\n+                         \"primitive\",\n+                         \"associatedtype\",\n+                         \"constant\"];\n \n         function itemTypeFromName(typename) {\n             for (var i = 0; i < itemTypes.length; ++i) {"}, {"sha": "1a9dd226f87df6ffdec9b6321d10f603204b6ca3", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -134,7 +134,8 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::StructItem(..) | clean::EnumItem(..) |\n             clean::TraitItem(..) | clean::FunctionItem(..) |\n             clean::VariantItem(..) | clean::MethodItem(..) |\n-            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) => {\n+            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n+            clean::ConstantItem(..) => {\n                 if ast_util::is_local(i.def_id) &&\n                    !self.exported_items.contains(&i.def_id.node) {\n                     return None;"}, {"sha": "6456f4acd30c3e69119232163798dfd7f8b2c23d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -308,6 +308,19 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.statics.push(s);\n             },\n+            ast::ItemConst(ref ty, ref exp) => {\n+                let s = Constant {\n+                    type_: ty.clone(),\n+                    expr: exp.clone(),\n+                    id: item.id,\n+                    name: name,\n+                    attrs: item.attrs.clone(),\n+                    whence: item.span,\n+                    vis: item.vis,\n+                    stab: self.stability(item.id),\n+                };\n+                om.constants.push(s);\n+            },\n             ast::ItemTrait(ref gen, _, ref b, ref items) => {\n                 let t = Trait {\n                     name: name,"}, {"sha": "a5ac70286fe81e7454a71efed8d19c5f60fa1ba6", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -414,7 +414,7 @@ impl ToCStr for String {\n }\n \n // The length of the stack allocated buffer for `vec.with_c_str()`\n-static BUF_LEN: uint = 128;\n+const BUF_LEN: uint = 128;\n \n impl<'a> ToCStr for &'a [u8] {\n     fn to_c_str(&self) -> CString {"}, {"sha": "e45167565ea489bac1a940a28f61b3a634d73ffc", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -100,7 +100,7 @@ pub trait Runtime {\n \n /// The default error code of the rust runtime if the main task fails instead\n /// of exiting cleanly.\n-pub static DEFAULT_ERROR_CODE: int = 101;\n+pub const DEFAULT_ERROR_CODE: int = 101;\n \n /// One-time runtime initialization.\n ///"}, {"sha": "6867cb2e76b344822aa45fa58e44cc1233749d12", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -57,19 +57,19 @@ pub type _Unwind_Exception_Class = u64;\n pub type _Unwind_Word = libc::uintptr_t;\n \n #[cfg(target_arch = \"x86\")]\n-pub static unwinder_private_data_size: uint = 5;\n+pub const unwinder_private_data_size: uint = 5;\n \n #[cfg(target_arch = \"x86_64\")]\n-pub static unwinder_private_data_size: uint = 6;\n+pub const unwinder_private_data_size: uint = 6;\n \n #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\")))]\n-pub static unwinder_private_data_size: uint = 20;\n+pub const unwinder_private_data_size: uint = 20;\n \n #[cfg(all(target_arch = \"arm\", target_os = \"ios\"))]\n-pub static unwinder_private_data_size: uint = 5;\n+pub const unwinder_private_data_size: uint = 5;\n \n #[cfg(any(target_arch = \"mips\", target_arch = \"mipsel\"))]\n-pub static unwinder_private_data_size: uint = 2;\n+pub const unwinder_private_data_size: uint = 2;\n \n #[repr(C)]\n pub struct _Unwind_Exception {"}, {"sha": "bd47874d6472058665d46d5c71cd386d44c28044", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -88,7 +88,7 @@ pub struct LockGuard<'a> {\n     lock: &'a StaticNativeMutex\n }\n \n-pub static NATIVE_MUTEX_INIT: StaticNativeMutex = StaticNativeMutex {\n+pub const NATIVE_MUTEX_INIT: StaticNativeMutex = StaticNativeMutex {\n     inner: imp::MUTEX_INIT,\n };\n \n@@ -353,9 +353,9 @@ mod imp {\n         pub type pthread_mutex_t = *mut libc::c_void;\n         pub type pthread_cond_t = *mut libc::c_void;\n \n-        pub static PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t =\n+        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t =\n             0 as pthread_mutex_t;\n-        pub static PTHREAD_COND_INITIALIZER: pthread_cond_t =\n+        pub const PTHREAD_COND_INITIALIZER: pthread_cond_t =\n             0 as pthread_cond_t;\n     }\n \n@@ -364,20 +364,20 @@ mod imp {\n         use libc;\n \n         #[cfg(target_arch = \"x86_64\")]\n-        static __PTHREAD_MUTEX_SIZE__: uint = 56;\n+        const __PTHREAD_MUTEX_SIZE__: uint = 56;\n         #[cfg(target_arch = \"x86_64\")]\n-        static __PTHREAD_COND_SIZE__: uint = 40;\n+        const __PTHREAD_COND_SIZE__: uint = 40;\n         #[cfg(target_arch = \"x86\")]\n-        static __PTHREAD_MUTEX_SIZE__: uint = 40;\n+        const __PTHREAD_MUTEX_SIZE__: uint = 40;\n         #[cfg(target_arch = \"x86\")]\n-        static __PTHREAD_COND_SIZE__: uint = 24;\n+        const __PTHREAD_COND_SIZE__: uint = 24;\n         #[cfg(target_arch = \"arm\")]\n-        static __PTHREAD_MUTEX_SIZE__: uint = 40;\n+        const __PTHREAD_MUTEX_SIZE__: uint = 40;\n         #[cfg(target_arch = \"arm\")]\n-        static __PTHREAD_COND_SIZE__: uint = 24;\n+        const __PTHREAD_COND_SIZE__: uint = 24;\n \n-        static _PTHREAD_MUTEX_SIG_INIT: libc::c_long = 0x32AAABA7;\n-        static _PTHREAD_COND_SIG_INIT: libc::c_long = 0x3CB0B1BB;\n+        const _PTHREAD_MUTEX_SIG_INIT: libc::c_long = 0x32AAABA7;\n+        const _PTHREAD_COND_SIG_INIT: libc::c_long = 0x3CB0B1BB;\n \n         #[repr(C)]\n         pub struct pthread_mutex_t {\n@@ -390,11 +390,11 @@ mod imp {\n             __opaque: [u8, ..__PTHREAD_COND_SIZE__],\n         }\n \n-        pub static PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n+        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n             __sig: _PTHREAD_MUTEX_SIG_INIT,\n             __opaque: [0, ..__PTHREAD_MUTEX_SIZE__],\n         };\n-        pub static PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n+        pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n             __sig: _PTHREAD_COND_SIG_INIT,\n             __opaque: [0, ..__PTHREAD_COND_SIZE__],\n         };\n@@ -406,25 +406,25 @@ mod imp {\n \n         // minus 8 because we have an 'align' field\n         #[cfg(target_arch = \"x86_64\")]\n-        static __SIZEOF_PTHREAD_MUTEX_T: uint = 40 - 8;\n+        const __SIZEOF_PTHREAD_MUTEX_T: uint = 40 - 8;\n         #[cfg(target_arch = \"x86\")]\n-        static __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n+        const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n         #[cfg(target_arch = \"arm\")]\n-        static __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n+        const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n         #[cfg(target_arch = \"mips\")]\n-        static __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n+        const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n         #[cfg(target_arch = \"mipsel\")]\n-        static __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n+        const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n         #[cfg(target_arch = \"x86_64\")]\n-        static __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n+        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n         #[cfg(target_arch = \"x86\")]\n-        static __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n+        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n         #[cfg(target_arch = \"arm\")]\n-        static __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n+        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n         #[cfg(target_arch = \"mips\")]\n-        static __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n+        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n         #[cfg(target_arch = \"mipsel\")]\n-        static __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n+        const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n \n         #[repr(C)]\n         pub struct pthread_mutex_t {\n@@ -437,11 +437,11 @@ mod imp {\n             size: [u8, ..__SIZEOF_PTHREAD_COND_T],\n         }\n \n-        pub static PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n+        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n             __align: 0,\n             size: [0, ..__SIZEOF_PTHREAD_MUTEX_T],\n         };\n-        pub static PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n+        pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n             __align: 0,\n             size: [0, ..__SIZEOF_PTHREAD_COND_T],\n         };\n@@ -455,10 +455,10 @@ mod imp {\n         #[repr(C)]\n         pub struct pthread_cond_t { value: libc::c_int }\n \n-        pub static PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n+        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n             value: 0,\n         };\n-        pub static PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n+        pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n             value: 0,\n         };\n     }\n@@ -468,7 +468,7 @@ mod imp {\n         cond: UnsafeCell<pthread_cond_t>,\n     }\n \n-    pub static MUTEX_INIT: Mutex = Mutex {\n+    pub const MUTEX_INIT: Mutex = Mutex {\n         lock: UnsafeCell { value: PTHREAD_MUTEX_INITIALIZER },\n         cond: UnsafeCell { value: PTHREAD_COND_INITIALIZER },\n     };\n@@ -523,19 +523,19 @@ mod imp {\n     use libc;\n \n     type LPCRITICAL_SECTION = *mut c_void;\n-    static SPIN_COUNT: DWORD = 4000;\n+    const SPIN_COUNT: DWORD = 4000;\n     #[cfg(target_arch = \"x86\")]\n-    static CRIT_SECTION_SIZE: uint = 24;\n+    const CRIT_SECTION_SIZE: uint = 24;\n     #[cfg(target_arch = \"x86_64\")]\n-    static CRIT_SECTION_SIZE: uint = 40;\n+    const CRIT_SECTION_SIZE: uint = 40;\n \n     pub struct Mutex {\n         // pointers for the lock/cond handles, atomically updated\n         lock: atomic::AtomicUint,\n         cond: atomic::AtomicUint,\n     }\n \n-    pub static MUTEX_INIT: Mutex = Mutex {\n+    pub const MUTEX_INIT: Mutex = Mutex {\n         lock: atomic::INIT_ATOMIC_UINT,\n         cond: atomic::INIT_ATOMIC_UINT,\n     };"}, {"sha": "4034000e28f33e22adbfad9af7f14f028bb61a47", "filename": "src/librustrt/stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -46,7 +46,7 @@\n // corresponding prolog, decision was taken to disable segmented\n // stack support on iOS.\n \n-pub static RED_ZONE: uint = 20 * 1024;\n+pub const RED_ZONE: uint = 20 * 1024;\n \n /// This function is invoked from rust's current __morestack function. Segmented\n /// stacks are currently not enabled as segmented stacks, but rather one giant"}, {"sha": "2a2fa29eca0b29bd4ead1b4c96e3d3f2a1b08487", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -91,7 +91,7 @@ pub type Callback = fn(msg: &Any + Send, file: &'static str, line: uint);\n // Variables used for invoking callbacks when a task starts to unwind.\n //\n // For more information, see below.\n-static MAX_CALLBACKS: uint = 16;\n+const MAX_CALLBACKS: uint = 16;\n static mut CALLBACKS: [atomic::AtomicUint, ..MAX_CALLBACKS] =\n         [atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n          atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,"}, {"sha": "a94da33e543572bfe6d241db4f51c2caeb1907cc", "filename": "src/librustrt/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -23,15 +23,15 @@ use libc;\n //\n // FIXME: Once the runtime matures remove the `true` below to turn off rtassert,\n //        etc.\n-pub static ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n+pub const ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n                                   cfg!(rtassert);\n \n pub struct Stdio(libc::c_int);\n \n #[allow(non_uppercase_statics)]\n-pub static Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n+pub const Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n #[allow(non_uppercase_statics)]\n-pub static Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n+pub const Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n \n impl fmt::FormatWriter for Stdio {\n     fn write(&mut self, data: &[u8]) -> fmt::Result {"}, {"sha": "5d9211caac1b102254a1632b348e547dd07fc157", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -360,18 +360,16 @@ fn escape_char(writer: &mut io::Writer, v: char) -> Result<(), io::IoError> {\n }\n \n fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n-    #[allow(non_uppercase_statics)]\n-    static len: uint = 16;\n-    #[allow(non_uppercase_statics)]\n-    static buf: [u8, ..len] = [b' ', ..len];\n+    const LEN: uint = 16;\n+    static BUF: [u8, ..LEN] = [b' ', ..LEN];\n \n-    while n >= len {\n-        try!(wr.write(buf));\n-        n -= len;\n+    while n >= LEN {\n+        try!(wr.write(BUF));\n+        n -= LEN;\n     }\n \n     if n > 0 {\n-        wr.write(buf[..n])\n+        wr.write(BUF[..n])\n     } else {\n         Ok(())\n     }"}, {"sha": "adb55f2cc8cff4fd4363195c6619ad7b0115e9a6", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -24,12 +24,12 @@\n /// ```{.rust}\n /// bitflags! {\n ///     flags Flags: u32 {\n-///         static FLAG_A       = 0x00000001,\n-///         static FLAG_B       = 0x00000010,\n-///         static FLAG_C       = 0x00000100,\n-///         static FLAG_ABC     = FLAG_A.bits\n-///                             | FLAG_B.bits\n-///                             | FLAG_C.bits,\n+///         const FLAG_A       = 0x00000001,\n+///         const FLAG_B       = 0x00000010,\n+///         const FLAG_C       = 0x00000100,\n+///         const FLAG_ABC     = FLAG_A.bits\n+///                            | FLAG_B.bits\n+///                            | FLAG_C.bits,\n ///     }\n /// }\n ///\n@@ -50,8 +50,8 @@\n ///\n /// bitflags! {\n ///     flags Flags: u32 {\n-///         static FLAG_A   = 0x00000001,\n-///         static FLAG_B   = 0x00000010,\n+///         const FLAG_A   = 0x00000001,\n+///         const FLAG_B   = 0x00000010,\n ///     }\n /// }\n ///\n@@ -115,15 +115,15 @@\n #[macro_export]\n macro_rules! bitflags {\n     ($(#[$attr:meta])* flags $BitFlags:ident: $T:ty {\n-        $($(#[$Flag_attr:meta])* static $Flag:ident = $value:expr),+\n+        $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr),+\n     }) => {\n         #[deriving(PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\n         $(#[$attr])*\n         pub struct $BitFlags {\n             bits: $T,\n         }\n \n-        $($(#[$Flag_attr])* pub static $Flag: $BitFlags = $BitFlags { bits: $value };)+\n+        $($(#[$Flag_attr])* pub const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n \n         impl $BitFlags {\n             /// Returns an empty set of flags.\n@@ -235,12 +235,12 @@ macro_rules! bitflags {\n         }\n     };\n     ($(#[$attr:meta])* flags $BitFlags:ident: $T:ty {\n-        $($(#[$Flag_attr:meta])* static $Flag:ident = $value:expr),+,\n+        $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr),+,\n     }) => {\n         bitflags! {\n             $(#[$attr])*\n             flags $BitFlags: $T {\n-                $($(#[$Flag_attr])* static $Flag = $value),+\n+                $($(#[$Flag_attr])* const $Flag = $value),+\n             }\n         }\n     };\n@@ -259,22 +259,22 @@ mod tests {\n         #[doc = \"> \"]\n         #[doc = \"> - Richard Feynman\"]\n         flags Flags: u32 {\n-            static FlagA       = 0x00000001,\n+            const FlagA       = 0x00000001,\n             #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\n-            static FlagB       = 0x00000010,\n-            static FlagC       = 0x00000100,\n+            const FlagB       = 0x00000010,\n+            const FlagC       = 0x00000100,\n             #[doc = \"* cmr bed\"]\n             #[doc = \"* strcat table\"]\n             #[doc = \"<strcat> wait what?\"]\n-            static FlagABC     = FlagA.bits\n+            const FlagABC     = FlagA.bits\n                                | FlagB.bits\n                                | FlagC.bits,\n         }\n     }\n \n     bitflags! {\n         flags AnotherSetOfFlags: uint {\n-            static AnotherFlag = 1u,\n+            const AnotherFlag = 1u,\n         }\n     }\n "}, {"sha": "ef40402105b54581c38bae801e8632d63b8e951f", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -41,8 +41,8 @@ use super::table::{\n     SafeHash\n };\n \n-static INITIAL_LOG2_CAP: uint = 5;\n-pub static INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n+const INITIAL_LOG2_CAP: uint = 5;\n+pub const INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n \n /// The default behavior of HashMap implements a load factor of 90.9%.\n /// This behavior is characterized by the following conditions:"}, {"sha": "ee64a7931c06242d887e9f222da7e5443606e3c3", "filename": "src/libstd/collections/hashmap/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -24,7 +24,7 @@ use ptr::{RawPtr, copy_nonoverlapping_memory, zero_memory};\n use ptr;\n use rt::heap::{allocate, deallocate};\n \n-static EMPTY_BUCKET: u64 = 0u64;\n+const EMPTY_BUCKET: u64 = 0u64;\n \n /// The raw hashtable, providing safe-ish access to the unzipped and highly\n /// optimized arrays of hashes, keys, and values."}, {"sha": "d18b3cdf2e7509c905dbe523791a4ec96959be8d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -283,7 +283,7 @@ pub mod util;\n /// The default buffer size for various I/O operations\n // libuv recommends 64k buffers to maximize throughput\n // https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA\n-static DEFAULT_BUF_SIZE: uint = 1024 * 64;\n+const DEFAULT_BUF_SIZE: uint = 1024 * 64;\n \n /// A convenient typedef of the return value of any I/O action.\n pub type IoResult<T> = Result<T, IoError>;\n@@ -1803,93 +1803,93 @@ bitflags! {\n     #[doc = \"A set of permissions for a file or directory is represented\"]\n     #[doc = \"by a set of flags which are or'd together.\"]\n     flags FilePermission: u32 {\n-        static USER_READ     = 0o400,\n-        static USER_WRITE    = 0o200,\n-        static USER_EXECUTE  = 0o100,\n-        static GROUP_READ    = 0o040,\n-        static GROUP_WRITE   = 0o020,\n-        static GROUP_EXECUTE = 0o010,\n-        static OTHER_READ    = 0o004,\n-        static OTHER_WRITE   = 0o002,\n-        static OTHER_EXECUTE = 0o001,\n-\n-        static USER_RWX  = USER_READ.bits | USER_WRITE.bits | USER_EXECUTE.bits,\n-        static GROUP_RWX = GROUP_READ.bits | GROUP_WRITE.bits | GROUP_EXECUTE.bits,\n-        static OTHER_RWX = OTHER_READ.bits | OTHER_WRITE.bits | OTHER_EXECUTE.bits,\n+        const USER_READ     = 0o400,\n+        const USER_WRITE    = 0o200,\n+        const USER_EXECUTE  = 0o100,\n+        const GROUP_READ    = 0o040,\n+        const GROUP_WRITE   = 0o020,\n+        const GROUP_EXECUTE = 0o010,\n+        const OTHER_READ    = 0o004,\n+        const OTHER_WRITE   = 0o002,\n+        const OTHER_EXECUTE = 0o001,\n+\n+        const USER_RWX  = USER_READ.bits | USER_WRITE.bits | USER_EXECUTE.bits,\n+        const GROUP_RWX = GROUP_READ.bits | GROUP_WRITE.bits | GROUP_EXECUTE.bits,\n+        const OTHER_RWX = OTHER_READ.bits | OTHER_WRITE.bits | OTHER_EXECUTE.bits,\n \n         #[doc = \"Permissions for user owned files, equivalent to 0644 on\"]\n         #[doc = \"unix-like systems.\"]\n-        static USER_FILE = USER_READ.bits | USER_WRITE.bits | GROUP_READ.bits | OTHER_READ.bits,\n+        const USER_FILE = USER_READ.bits | USER_WRITE.bits | GROUP_READ.bits | OTHER_READ.bits,\n \n         #[doc = \"Permissions for user owned directories, equivalent to 0755 on\"]\n         #[doc = \"unix-like systems.\"]\n-        static USER_DIR  = USER_RWX.bits | GROUP_READ.bits | GROUP_EXECUTE.bits |\n+        const USER_DIR  = USER_RWX.bits | GROUP_READ.bits | GROUP_EXECUTE.bits |\n                    OTHER_READ.bits | OTHER_EXECUTE.bits,\n \n         #[doc = \"Permissions for user owned executables, equivalent to 0755\"]\n         #[doc = \"on unix-like systems.\"]\n-        static USER_EXEC = USER_DIR.bits,\n+        const USER_EXEC = USER_DIR.bits,\n \n         #[doc = \"All possible permissions enabled.\"]\n-        static ALL_PERMISSIONS = USER_RWX.bits | GROUP_RWX.bits | OTHER_RWX.bits,\n+        const ALL_PERMISSIONS = USER_RWX.bits | GROUP_RWX.bits | OTHER_RWX.bits,\n \n         // Deprecated names\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use USER_READ instead\"]\n-        static UserRead     = USER_READ.bits,\n+        const UserRead     = USER_READ.bits,\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use USER_WRITE instead\"]\n-        static UserWrite    = USER_WRITE.bits,\n+        const UserWrite    = USER_WRITE.bits,\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use USER_EXECUTE instead\"]\n-        static UserExecute  = USER_EXECUTE.bits,\n+        const UserExecute  = USER_EXECUTE.bits,\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use GROUP_READ instead\"]\n-        static GroupRead    = GROUP_READ.bits,\n+        const GroupRead    = GROUP_READ.bits,\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use GROUP_WRITE instead\"]\n-        static GroupWrite   = GROUP_WRITE.bits,\n+        const GroupWrite   = GROUP_WRITE.bits,\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use GROUP_EXECUTE instead\"]\n-        static GroupExecute = GROUP_EXECUTE.bits,\n+        const GroupExecute = GROUP_EXECUTE.bits,\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use OTHER_READ instead\"]\n-        static OtherRead    = OTHER_READ.bits,\n+        const OtherRead    = OTHER_READ.bits,\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use OTHER_WRITE instead\"]\n-        static OtherWrite   = OTHER_WRITE.bits,\n+        const OtherWrite   = OTHER_WRITE.bits,\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use OTHER_EXECUTE instead\"]\n-        static OtherExecute = OTHER_EXECUTE.bits,\n+        const OtherExecute = OTHER_EXECUTE.bits,\n \n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use USER_RWX instead\"]\n-        static UserRWX  = USER_RWX.bits,\n+        const UserRWX  = USER_RWX.bits,\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use GROUP_RWX instead\"]\n-        static GroupRWX = GROUP_RWX.bits,\n+        const GroupRWX = GROUP_RWX.bits,\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use OTHER_RWX instead\"]\n-        static OtherRWX = OTHER_RWX.bits,\n+        const OtherRWX = OTHER_RWX.bits,\n \n         #[doc = \"Deprecated: use `USER_FILE` instead.\"]\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use USER_FILE instead\"]\n-        static UserFile = USER_FILE.bits,\n+        const UserFile = USER_FILE.bits,\n \n         #[doc = \"Deprecated: use `USER_DIR` instead.\"]\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use USER_DIR instead\"]\n-        static UserDir  = USER_DIR.bits,\n+        const UserDir  = USER_DIR.bits,\n         #[doc = \"Deprecated: use `USER_EXEC` instead.\"]\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use USER_EXEC instead\"]\n-        static UserExec = USER_EXEC.bits,\n+        const UserExec = USER_EXEC.bits,\n \n         #[doc = \"Deprecated: use `ALL_PERMISSIONS` instead\"]\n         #[allow(non_uppercase_statics)]\n         #[deprecated = \"use ALL_PERMISSIONS instead\"]\n-        static AllPermissions = ALL_PERMISSIONS.bits,\n+        const AllPermissions = ALL_PERMISSIONS.bits,\n     }\n }\n "}, {"sha": "5de4bc10e1aec3f1813f9500cf04941f752da877", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -32,16 +32,16 @@ use std::hash::sip::SipState;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n /// SIGTERM on unix platforms.\n-#[cfg(windows)] pub static PleaseExitSignal: int = 15;\n+#[cfg(windows)] pub const PleaseExitSignal: int = 15;\n /// Signal a process to exit immediately, forcibly killing it. Corresponds to\n /// SIGKILL on unix platforms.\n-#[cfg(windows)] pub static MustDieSignal: int = 9;\n+#[cfg(windows)] pub const MustDieSignal: int = 9;\n /// Signal a process to exit, without forcibly killing it. Corresponds to\n /// SIGTERM on unix platforms.\n-#[cfg(not(windows))] pub static PleaseExitSignal: int = libc::SIGTERM as int;\n+#[cfg(not(windows))] pub const PleaseExitSignal: int = libc::SIGTERM as int;\n /// Signal a process to exit immediately, forcibly killing it. Corresponds to\n /// SIGKILL on unix platforms.\n-#[cfg(not(windows))] pub static MustDieSignal: int = libc::SIGKILL as int;\n+#[cfg(not(windows))] pub const MustDieSignal: int = libc::SIGKILL as int;\n \n /// Representation of a running or exited child process.\n ///"}, {"sha": "60386ec0631b7bf2e161390e49250e0cf510c2e0", "filename": "src/libstd/os.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -66,8 +66,8 @@ pub fn num_cpus() -> uint {\n     }\n }\n \n-pub static TMPBUF_SZ : uint = 1000u;\n-static BUF_BYTES : uint = 2048u;\n+pub const TMPBUF_SZ : uint = 1000u;\n+const BUF_BYTES : uint = 2048u;\n \n /// Returns the current working directory as a Path.\n ///\n@@ -1672,230 +1672,230 @@ impl MemoryMap {\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n-    pub static FAMILY: &'static str = \"unix\";\n+    pub const FAMILY: &'static str = \"unix\";\n \n     /// A string describing the specific operating system in use: in this\n     /// case, `linux`.\n-    pub static SYSNAME: &'static str = \"linux\";\n+    pub const SYSNAME: &'static str = \"linux\";\n \n     /// Specifies the filename prefix used for shared libraries on this\n     /// platform: in this case, `lib`.\n-    pub static DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n \n     /// Specifies the filename suffix used for shared libraries on this\n     /// platform: in this case, `.so`.\n-    pub static DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n \n     /// Specifies the file extension used for shared libraries on this\n     /// platform that goes after the dot: in this case, `so`.\n-    pub static DLL_EXTENSION: &'static str = \"so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n \n     /// Specifies the filename suffix used for executable binaries on this\n     /// platform: in this case, the empty string.\n-    pub static EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n \n     /// Specifies the file extension, if any, used for executable binaries\n     /// on this platform: in this case, the empty string.\n-    pub static EXE_EXTENSION: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n }\n \n #[cfg(target_os = \"macos\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n-    pub static FAMILY: &'static str = \"unix\";\n+    pub const FAMILY: &'static str = \"unix\";\n \n     /// A string describing the specific operating system in use: in this\n     /// case, `macos`.\n-    pub static SYSNAME: &'static str = \"macos\";\n+    pub const SYSNAME: &'static str = \"macos\";\n \n     /// Specifies the filename prefix used for shared libraries on this\n     /// platform: in this case, `lib`.\n-    pub static DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n \n     /// Specifies the filename suffix used for shared libraries on this\n     /// platform: in this case, `.dylib`.\n-    pub static DLL_SUFFIX: &'static str = \".dylib\";\n+    pub const DLL_SUFFIX: &'static str = \".dylib\";\n \n     /// Specifies the file extension used for shared libraries on this\n     /// platform that goes after the dot: in this case, `dylib`.\n-    pub static DLL_EXTENSION: &'static str = \"dylib\";\n+    pub const DLL_EXTENSION: &'static str = \"dylib\";\n \n     /// Specifies the filename suffix used for executable binaries on this\n     /// platform: in this case, the empty string.\n-    pub static EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n \n     /// Specifies the file extension, if any, used for executable binaries\n     /// on this platform: in this case, the empty string.\n-    pub static EXE_EXTENSION: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n }\n \n #[cfg(target_os = \"ios\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n-    pub static FAMILY: &'static str = \"unix\";\n+    pub const FAMILY: &'static str = \"unix\";\n \n     /// A string describing the specific operating system in use: in this\n     /// case, `ios`.\n-    pub static SYSNAME: &'static str = \"ios\";\n+    pub const SYSNAME: &'static str = \"ios\";\n \n     /// Specifies the filename suffix used for executable binaries on this\n     /// platform: in this case, the empty string.\n-    pub static EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n \n     /// Specifies the file extension, if any, used for executable binaries\n     /// on this platform: in this case, the empty string.\n-    pub static EXE_EXTENSION: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n }\n \n #[cfg(target_os = \"freebsd\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n-    pub static FAMILY: &'static str = \"unix\";\n+    pub const FAMILY: &'static str = \"unix\";\n \n     /// A string describing the specific operating system in use: in this\n     /// case, `freebsd`.\n-    pub static SYSNAME: &'static str = \"freebsd\";\n+    pub const SYSNAME: &'static str = \"freebsd\";\n \n     /// Specifies the filename prefix used for shared libraries on this\n     /// platform: in this case, `lib`.\n-    pub static DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n \n     /// Specifies the filename suffix used for shared libraries on this\n     /// platform: in this case, `.so`.\n-    pub static DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n \n     /// Specifies the file extension used for shared libraries on this\n     /// platform that goes after the dot: in this case, `so`.\n-    pub static DLL_EXTENSION: &'static str = \"so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n \n     /// Specifies the filename suffix used for executable binaries on this\n     /// platform: in this case, the empty string.\n-    pub static EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n \n     /// Specifies the file extension, if any, used for executable binaries\n     /// on this platform: in this case, the empty string.\n-    pub static EXE_EXTENSION: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n }\n \n #[cfg(target_os = \"dragonfly\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n-    pub static FAMILY: &'static str = \"unix\";\n+    pub const FAMILY: &'static str = \"unix\";\n \n     /// A string describing the specific operating system in use: in this\n     /// case, `dragonfly`.\n-    pub static SYSNAME: &'static str = \"dragonfly\";\n+    pub const SYSNAME: &'static str = \"dragonfly\";\n \n     /// Specifies the filename prefix used for shared libraries on this\n     /// platform: in this case, `lib`.\n-    pub static DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n \n     /// Specifies the filename suffix used for shared libraries on this\n     /// platform: in this case, `.so`.\n-    pub static DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n \n     /// Specifies the file extension used for shared libraries on this\n     /// platform that goes after the dot: in this case, `so`.\n-    pub static DLL_EXTENSION: &'static str = \"so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n \n     /// Specifies the filename suffix used for executable binaries on this\n     /// platform: in this case, the empty string.\n-    pub static EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n \n     /// Specifies the file extension, if any, used for executable binaries\n     /// on this platform: in this case, the empty string.\n-    pub static EXE_EXTENSION: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n }\n \n #[cfg(target_os = \"android\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n-    pub static FAMILY: &'static str = \"unix\";\n+    pub const FAMILY: &'static str = \"unix\";\n \n     /// A string describing the specific operating system in use: in this\n     /// case, `android`.\n-    pub static SYSNAME: &'static str = \"android\";\n+    pub const SYSNAME: &'static str = \"android\";\n \n     /// Specifies the filename prefix used for shared libraries on this\n     /// platform: in this case, `lib`.\n-    pub static DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n \n     /// Specifies the filename suffix used for shared libraries on this\n     /// platform: in this case, `.so`.\n-    pub static DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n \n     /// Specifies the file extension used for shared libraries on this\n     /// platform that goes after the dot: in this case, `so`.\n-    pub static DLL_EXTENSION: &'static str = \"so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n \n     /// Specifies the filename suffix used for executable binaries on this\n     /// platform: in this case, the empty string.\n-    pub static EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n \n     /// Specifies the file extension, if any, used for executable binaries\n     /// on this platform: in this case, the empty string.\n-    pub static EXE_EXTENSION: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n }\n \n #[cfg(target_os = \"windows\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n-    pub static FAMILY: &'static str = \"windows\";\n+    pub const FAMILY: &'static str = \"windows\";\n \n     /// A string describing the specific operating system in use: in this\n     /// case, `windows`.\n-    pub static SYSNAME: &'static str = \"windows\";\n+    pub const SYSNAME: &'static str = \"windows\";\n \n     /// Specifies the filename prefix used for shared libraries on this\n     /// platform: in this case, the empty string.\n-    pub static DLL_PREFIX: &'static str = \"\";\n+    pub const DLL_PREFIX: &'static str = \"\";\n \n     /// Specifies the filename suffix used for shared libraries on this\n     /// platform: in this case, `.dll`.\n-    pub static DLL_SUFFIX: &'static str = \".dll\";\n+    pub const DLL_SUFFIX: &'static str = \".dll\";\n \n     /// Specifies the file extension used for shared libraries on this\n     /// platform that goes after the dot: in this case, `dll`.\n-    pub static DLL_EXTENSION: &'static str = \"dll\";\n+    pub const DLL_EXTENSION: &'static str = \"dll\";\n \n     /// Specifies the filename suffix used for executable binaries on this\n     /// platform: in this case, `.exe`.\n-    pub static EXE_SUFFIX: &'static str = \".exe\";\n+    pub const EXE_SUFFIX: &'static str = \".exe\";\n \n     /// Specifies the file extension, if any, used for executable binaries\n     /// on this platform: in this case, `exe`.\n-    pub static EXE_EXTENSION: &'static str = \"exe\";\n+    pub const EXE_EXTENSION: &'static str = \"exe\";\n }\n \n #[cfg(target_arch = \"x86\")]\n mod arch_consts {\n-    pub static ARCH: &'static str = \"x86\";\n+    pub const ARCH: &'static str = \"x86\";\n }\n \n #[cfg(target_arch = \"x86_64\")]\n mod arch_consts {\n-    pub static ARCH: &'static str = \"x86_64\";\n+    pub const ARCH: &'static str = \"x86_64\";\n }\n \n #[cfg(target_arch = \"arm\")]\n mod arch_consts {\n-    pub static ARCH: &'static str = \"arm\";\n+    pub const ARCH: &'static str = \"arm\";\n }\n \n #[cfg(target_arch = \"mips\")]\n mod arch_consts {\n-    pub static ARCH: &'static str = \"mips\";\n+    pub const ARCH: &'static str = \"mips\";\n }\n \n #[cfg(target_arch = \"mipsel\")]\n mod arch_consts {\n-    pub static ARCH: &'static str = \"mipsel\";\n+    pub const ARCH: &'static str = \"mipsel\";\n }\n \n #[cfg(test)]"}, {"sha": "f7fb9adb1fb6497ab8acf6d4f1b6e69c4d8d6e2e", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -42,10 +42,10 @@ pub struct Path {\n }\n \n /// The standard path separator character\n-pub static SEP: char = '/';\n+pub const SEP: char = '/';\n \n /// The standard path separator byte\n-pub static SEP_BYTE: u8 = SEP as u8;\n+pub const SEP_BYTE: u8 = SEP as u8;\n \n /// Returns whether the given byte is a path separator\n #[inline]"}, {"sha": "5bd738ed58bd36c955cf4cdd6d5ed0f49f552124", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -958,14 +958,14 @@ pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n }\n \n /// The standard path separator character\n-pub static SEP: char = '\\\\';\n+pub const SEP: char = '\\\\';\n /// The standard path separator byte\n-pub static SEP_BYTE: u8 = SEP as u8;\n+pub const SEP_BYTE: u8 = SEP as u8;\n \n /// The alternative path separator character\n-pub static SEP2: char = '/';\n+pub const SEP2: char = '/';\n /// The alternative path separator character\n-pub static SEP2_BYTE: u8 = SEP2 as u8;\n+pub const SEP2_BYTE: u8 = SEP2 as u8;\n \n /// Returns whether the given char is a path separator.\n /// Allows both the primary separator '\\' and the alternative separator '/'."}, {"sha": "6cbbc0af3909e4e7ea9afefcc91b934466ab9ddf", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -45,8 +45,8 @@ pub fn log_enabled() -> bool {\n     val == 2\n }\n \n-#[cfg(target_word_size = \"64\")] static HEX_WIDTH: uint = 18;\n-#[cfg(target_word_size = \"32\")] static HEX_WIDTH: uint = 10;\n+#[cfg(target_word_size = \"64\")] const HEX_WIDTH: uint = 18;\n+#[cfg(target_word_size = \"32\")] const HEX_WIDTH: uint = 10;\n \n // All rust symbols are in theory lists of \"::\"-separated identifiers. Some\n // assemblers, however, can't handle these characters in symbol names. To get\n@@ -273,7 +273,7 @@ mod imp {\n \n         try!(writeln!(w, \"stack backtrace:\"));\n         // 100 lines should be enough\n-        static SIZE: uint = 100;\n+        const SIZE: uint = 100;\n         let mut buf: [*mut libc::c_void, ..SIZE] = unsafe {mem::zeroed()};\n         let cnt = unsafe { backtrace(buf.as_mut_ptr(), SIZE as libc::c_int) as uint};\n \n@@ -697,10 +697,10 @@ mod imp {\n                            *mut libc::c_void, *mut libc::c_void,\n                            *mut libc::c_void, *mut libc::c_void) -> libc::BOOL;\n \n-    static MAX_SYM_NAME: uint = 2000;\n-    static IMAGE_FILE_MACHINE_I386: libc::DWORD = 0x014c;\n-    static IMAGE_FILE_MACHINE_IA64: libc::DWORD = 0x0200;\n-    static IMAGE_FILE_MACHINE_AMD64: libc::DWORD = 0x8664;\n+    const MAX_SYM_NAME: uint = 2000;\n+    const IMAGE_FILE_MACHINE_I386: libc::DWORD = 0x014c;\n+    const IMAGE_FILE_MACHINE_IA64: libc::DWORD = 0x0200;\n+    const IMAGE_FILE_MACHINE_AMD64: libc::DWORD = 0x8664;\n \n     #[repr(C)]\n     struct SYMBOL_INFO {\n@@ -772,7 +772,7 @@ mod imp {\n     mod arch {\n         use libc;\n \n-        static MAXIMUM_SUPPORTED_EXTENSION: uint = 512;\n+        const MAXIMUM_SUPPORTED_EXTENSION: uint = 512;\n \n         #[repr(C)]\n         pub struct CONTEXT {"}, {"sha": "751eb00bfaeccf65add80c63bd92f7de3bebba80", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -20,23 +20,23 @@ use num::{CheckedAdd, CheckedMul};\n use result::{Result, Ok, Err};\n \n /// The number of nanoseconds in a microsecond.\n-static NANOS_PER_MICRO: i32 = 1000;\n+const NANOS_PER_MICRO: i32 = 1000;\n /// The number of nanoseconds in a millisecond.\n-static NANOS_PER_MILLI: i32 = 1000_000;\n+const NANOS_PER_MILLI: i32 = 1000_000;\n /// The number of nanoseconds in seconds.\n-static NANOS_PER_SEC: i32 = 1_000_000_000;\n+const NANOS_PER_SEC: i32 = 1_000_000_000;\n /// The number of microseconds per second.\n-static MICROS_PER_SEC: i64 = 1000_000;\n+const MICROS_PER_SEC: i64 = 1000_000;\n /// The number of milliseconds per second.\n-static MILLIS_PER_SEC: i64 = 1000;\n+const MILLIS_PER_SEC: i64 = 1000;\n /// The number of seconds in a minute.\n-static SECS_PER_MINUTE: i64 = 60;\n+const SECS_PER_MINUTE: i64 = 60;\n /// The number of seconds in an hour.\n-static SECS_PER_HOUR: i64 = 3600;\n+const SECS_PER_HOUR: i64 = 3600;\n /// The number of (non-leap) seconds in days.\n-static SECS_PER_DAY: i64 = 86400;\n+const SECS_PER_DAY: i64 = 86400;\n /// The number of (non-leap) seconds in a week.\n-static SECS_PER_WEEK: i64 = 604800;\n+const SECS_PER_WEEK: i64 = 604800;\n \n macro_rules! try_opt(\n     ($e:expr) => (match $e { Some(v) => v, None => return None })\n@@ -52,13 +52,13 @@ pub struct Duration {\n }\n \n /// The minimum possible `Duration`: `i64::MIN` milliseconds.\n-pub static MIN: Duration = Duration {\n+pub const MIN: Duration = Duration {\n     secs: i64::MIN / MILLIS_PER_SEC - 1,\n     nanos: NANOS_PER_SEC + (i64::MIN % MILLIS_PER_SEC) as i32 * NANOS_PER_MILLI\n };\n \n /// The maximum possible `Duration`: `i64::MAX` milliseconds.\n-pub static MAX: Duration = Duration {\n+pub const MAX: Duration = Duration {\n     secs: i64::MAX / MILLIS_PER_SEC,\n     nanos: (i64::MAX % MILLIS_PER_SEC) as i32 * NANOS_PER_MILLI\n };\n@@ -456,7 +456,7 @@ mod tests {\n         assert_eq!(MIN.num_microseconds(), None);\n \n         // overflow checks\n-        static MICROS_PER_DAY: i64 = 86400_000_000;\n+        const MICROS_PER_DAY: i64 = 86400_000_000;\n         assert_eq!(Duration::days(i64::MAX / MICROS_PER_DAY).num_microseconds(),\n                    Some(i64::MAX / MICROS_PER_DAY * MICROS_PER_DAY));\n         assert_eq!(Duration::days(i64::MIN / MICROS_PER_DAY).num_microseconds(),\n@@ -477,7 +477,7 @@ mod tests {\n         assert_eq!(MIN.num_nanoseconds(), None);\n \n         // overflow checks\n-        static NANOS_PER_DAY: i64 = 86400_000_000_000;\n+        const NANOS_PER_DAY: i64 = 86400_000_000_000;\n         assert_eq!(Duration::days(i64::MAX / NANOS_PER_DAY).num_nanoseconds(),\n                    Some(i64::MAX / NANOS_PER_DAY * NANOS_PER_DAY));\n         assert_eq!(Duration::days(i64::MIN / NANOS_PER_DAY).num_nanoseconds(),"}, {"sha": "053b5dc4c8a7478454cefee3514d9543857597fa", "filename": "src/libsync/comm/oneshot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsync%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsync%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Foneshot.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -43,9 +43,9 @@ use atomic;\n use comm::Receiver;\n \n // Various states you can find a port in.\n-static EMPTY: uint = 0;\n-static DATA: uint = 1;\n-static DISCONNECTED: uint = 2;\n+const EMPTY: uint = 0;\n+const DATA: uint = 1;\n+const DISCONNECTED: uint = 2;\n \n pub struct Packet<T> {\n     // Internal state of the chan/port pair (stores the blocked task as well)"}, {"sha": "cfd045d08821af814a61728f27d90c529a94fb4b", "filename": "src/libsync/comm/shared.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsync%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsync%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fshared.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -31,12 +31,12 @@ use rustrt::thread::Thread;\n use atomic;\n use mpsc_queue as mpsc;\n \n-static DISCONNECTED: int = int::MIN;\n-static FUDGE: int = 1024;\n+const DISCONNECTED: int = int::MIN;\n+const FUDGE: int = 1024;\n #[cfg(test)]\n-static MAX_STEALS: int = 5;\n+const MAX_STEALS: int = 5;\n #[cfg(not(test))]\n-static MAX_STEALS: int = 1 << 20;\n+const MAX_STEALS: int = 1 << 20;\n \n pub struct Packet<T> {\n     queue: mpsc::Queue<T>,"}, {"sha": "8e433c6a585f3dc57b7d7c29066184126ac5ae0f", "filename": "src/libsync/comm/stream.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsync%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsync%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fstream.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -30,11 +30,11 @@ use atomic;\n use comm::Receiver;\n use spsc_queue as spsc;\n \n-static DISCONNECTED: int = int::MIN;\n+const DISCONNECTED: int = int::MIN;\n #[cfg(test)]\n-static MAX_STEALS: int = 5;\n+const MAX_STEALS: int = 5;\n #[cfg(not(test))]\n-static MAX_STEALS: int = 1 << 20;\n+const MAX_STEALS: int = 1 << 20;\n \n pub struct Packet<T> {\n     queue: spsc::Queue<Message<T>>, // internal queue for all message"}, {"sha": "c6413d0d09cc724a3d0235624494d32ced2a30cb", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -70,9 +70,9 @@ use rustrt::thread::Thread;\n \n use mpsc_intrusive as q;\n \n-pub static LOCKED: uint = 1 << 0;\n-pub static GREEN_BLOCKED: uint = 1 << 1;\n-pub static NATIVE_BLOCKED: uint = 1 << 2;\n+pub const LOCKED: uint = 1 << 0;\n+pub const GREEN_BLOCKED: uint = 1 << 1;\n+pub const NATIVE_BLOCKED: uint = 1 << 2;\n \n /// A mutual exclusion primitive useful for protecting shared data\n ///\n@@ -163,7 +163,7 @@ pub struct Guard<'a> {\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n-pub static MUTEX_INIT: StaticMutex = StaticMutex {\n+pub const MUTEX_INIT: StaticMutex = StaticMutex {\n     lock: mutex::NATIVE_MUTEX_INIT,\n     state: atomic::INIT_ATOMIC_UINT,\n     flavor: UnsafeCell { value: Unlocked },"}, {"sha": "c740c4f3d2e95f2076cd896c23a52ddbb763bffd", "filename": "src/libsync/one.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsync%2Fone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsync%2Fone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fone.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -45,7 +45,7 @@ pub struct Once {\n }\n \n /// Initialization value for static `Once` values.\n-pub static ONCE_INIT: Once = Once {\n+pub const ONCE_INIT: Once = Once {\n     mutex: MUTEX_INIT,\n     cnt: atomic::INIT_ATOMIC_INT,\n     lock_cnt: atomic::INIT_ATOMIC_INT,"}, {"sha": "03325ad470668497522d3db0710a4bbe2fb995b6", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -48,9 +48,9 @@ pub enum Architecture {\n }\n \n #[allow(non_uppercase_statics)]\n-static IntelBits: u32 = (1 << (X86 as uint)) | (1 << (X86_64 as uint));\n+const IntelBits: u32 = (1 << (X86 as uint)) | (1 << (X86_64 as uint));\n #[allow(non_uppercase_statics)]\n-static ArmBits: u32 = (1 << (Arm as uint));\n+const ArmBits: u32 = (1 << (Arm as uint));\n \n pub struct AbiData {\n     abi: Abi,"}, {"sha": "274bb2e39e019fbf1bbc37cc92907585d1c2bc64", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -104,8 +104,8 @@ impl PartialEq for Ident {\n // this uint is a reference to a table stored in thread-local\n // storage.\n pub type SyntaxContext = u32;\n-pub static EMPTY_CTXT : SyntaxContext = 0;\n-pub static ILLEGAL_CTXT : SyntaxContext = 1;\n+pub const EMPTY_CTXT : SyntaxContext = 0;\n+pub const ILLEGAL_CTXT : SyntaxContext = 1;\n \n /// A name is a part of an identifier, representing a string or gensym. It's\n /// the result of interning.\n@@ -198,13 +198,13 @@ pub struct DefId {\n \n /// Item definitions in the currently-compiled crate would have the CrateNum\n /// LOCAL_CRATE in their DefId.\n-pub static LOCAL_CRATE: CrateNum = 0;\n-pub static CRATE_NODE_ID: NodeId = 0;\n+pub const LOCAL_CRATE: CrateNum = 0;\n+pub const CRATE_NODE_ID: NodeId = 0;\n \n /// When parsing and doing expansions, we initially give all AST nodes this AST\n /// node value. Then later, in the renumber pass, we renumber them to have\n /// small, positive ids.\n-pub static DUMMY_NODE_ID: NodeId = -1;\n+pub const DUMMY_NODE_ID: NodeId = -1;\n \n /// The AST represents all type param bounds as types.\n /// typeck::collect::compute_bounds matches these against\n@@ -1309,6 +1309,7 @@ pub struct Item {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Item_ {\n     ItemStatic(P<Ty>, Mutability, P<Expr>),\n+    ItemConst(P<Ty>, P<Expr>),\n     ItemFn(P<FnDecl>, FnStyle, Abi, Generics, P<Block>),\n     ItemMod(Mod),\n     ItemForeignMod(ForeignMod),"}, {"sha": "2d0cea2fefc9d0576707f5ac0d0f98d1b0e61c46", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -1018,6 +1018,7 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n             let item_str = match item.node {\n                 ItemStatic(..) => \"static\",\n+                ItemConst(..) => \"const\",\n                 ItemFn(..) => \"fn\",\n                 ItemMod(..) => \"mod\",\n                 ItemForeignMod(..) => \"foreign mod\","}, {"sha": "f51c2985f0bf413701222b08b8ef7170b5d3b176", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -12,8 +12,6 @@ use abi::Abi;\n use ast::*;\n use ast;\n use ast_util;\n-use attr::{InlineNever, InlineNone};\n-use attr;\n use codemap;\n use codemap::Span;\n use owned_slice::OwnedSlice;\n@@ -706,18 +704,6 @@ pub fn lit_is_str(lit: &Lit) -> bool {\n     }\n }\n \n-/// Returns true if the static with the given mutability and attributes\n-/// has a significant address and false otherwise.\n-pub fn static_has_significant_address(mutbl: ast::Mutability,\n-                                              attrs: &[ast::Attribute])\n-                                              -> bool {\n-    if mutbl == ast::MutMutable {\n-        return true\n-    }\n-    let inline = attr::find_inline_attr(attrs);\n-    inline == InlineNever || inline == InlineNone\n-}\n-\n /// Macro invocations are guaranteed not to occur after expansion is complete.\n /// Extracting fields of a method requires a dynamic check to make sure that it's\n /// not a macro invocation. This check is guaranteed to succeed, assuming"}, {"sha": "5d96cc359c2ff8d83da72a501dc6a18bb18c8734", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -96,7 +96,7 @@ pub struct Span {\n     pub expn_id: ExpnId\n }\n \n-pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_id: NO_EXPANSION };\n+pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_id: NO_EXPANSION };\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Spanned<T> {\n@@ -227,7 +227,7 @@ pub struct ExpnInfo {\n #[deriving(PartialEq, Eq, Clone, Show, Hash, Encodable, Decodable)]\n pub struct ExpnId(u32);\n \n-pub static NO_EXPANSION: ExpnId = ExpnId(-1);\n+pub const NO_EXPANSION: ExpnId = ExpnId(-1);\n \n impl ExpnId {\n     pub fn from_llvm_cookie(cookie: c_uint) -> ExpnId {"}, {"sha": "87983e1aea3a920df1412c5742ecae3fce3fae72", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -250,6 +250,13 @@ pub trait AstBuilder {\n                    expr: P<ast::Expr>)\n                    -> P<ast::Item>;\n \n+    fn item_const(&self,\n+                   span: Span,\n+                   name: Ident,\n+                   ty: P<ast::Ty>,\n+                   expr: P<ast::Expr>)\n+                   -> P<ast::Item>;\n+\n     fn item_ty_poly(&self,\n                     span: Span,\n                     name: Ident,\n@@ -1033,6 +1040,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.item(span, name, Vec::new(), ast::ItemStatic(ty, mutbl, expr))\n     }\n \n+    fn item_const(&self,\n+                  span: Span,\n+                  name: Ident,\n+                  ty: P<ast::Ty>,\n+                  expr: P<ast::Expr>)\n+                  -> P<ast::Item> {\n+        self.item(span, name, Vec::new(), ast::ItemConst(ty, expr))\n+    }\n+\n     fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n                     generics: Generics) -> P<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemTy(ty, generics))"}, {"sha": "a93295815e0ed834c7bddff1b35aa9fcd3d549f1", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -104,19 +104,14 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let e = cx.expr_vec_slice(sp, bytes);\n-    let ty = cx.ty(sp, ast::TyVec(cx.ty_ident(sp, cx.ident_of(\"u8\"))));\n-    let lifetime = cx.lifetime(sp, cx.ident_of(\"'static\").name);\n-    let item = cx.item_static(sp,\n-                              cx.ident_of(\"BYTES\"),\n-                              cx.ty_rptr(sp,\n-                                         ty,\n-                                         Some(lifetime),\n-                                         ast::MutImmutable),\n-                              ast::MutImmutable,\n-                              e);\n-    let e = cx.expr_block(cx.block(sp,\n-                                   vec!(cx.stmt_item(sp, item)),\n-                                   Some(cx.expr_ident(sp, cx.ident_of(\"BYTES\")))));\n+    let len = bytes.len();\n+    let e = cx.expr_vec(sp, bytes);\n+    let ty = cx.ty(sp, ast::TyFixedLengthVec(cx.ty_ident(sp, cx.ident_of(\"u8\")),\n+                                             cx.expr_uint(sp, len)));\n+    let item = cx.item_static(sp, cx.ident_of(\"BYTES\"), ty, ast::MutImmutable, e);\n+    let ret = cx.expr_ident(sp, cx.ident_of(\"BYTES\"));\n+    let ret = cx.expr_addr_of(sp, ret);\n+    let e = cx.expr_block(cx.block(sp, vec![cx.stmt_item(sp, item)],\n+                                   Some(ret)));\n     MacExpr::new(e)\n }"}, {"sha": "32e226361e9d45d980c02afd65936e2541e9b455", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -903,6 +903,9 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n         ItemStatic(t, m, e) => {\n             ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n+        ItemConst(t, e) => {\n+            ItemConst(folder.fold_ty(t), folder.fold_expr(e))\n+        }\n         ItemFn(decl, fn_style, abi, generics, body) => {\n             ItemFn(\n                 folder.fold_fn_decl(decl),"}, {"sha": "e7f40cf072296e16fc209fa526de503b0a5a01a0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -32,7 +32,7 @@ use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n use ast::{FnOnceUnboxedClosureKind};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n use ast::{Ident, NormalFn, Inherited, ImplItem, Item, Item_, ItemStatic};\n-use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl};\n+use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy};\n use ast::{LifetimeDef, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitBinary};\n@@ -91,10 +91,10 @@ use std::iter;\n \n bitflags! {\n     flags Restrictions: u8 {\n-        static UNRESTRICTED                  = 0b0000,\n-        static RESTRICTION_STMT_EXPR         = 0b0001,\n-        static RESTRICTION_NO_BAR_OP         = 0b0010,\n-        static RESTRICTION_NO_STRUCT_LITERAL = 0b0100\n+        const UNRESTRICTED                  = 0b0000,\n+        const RESTRICTION_STMT_EXPR         = 0b0001,\n+        const RESTRICTION_NO_BAR_OP         = 0b0010,\n+        const RESTRICTION_NO_STRUCT_LITERAL = 0b0100\n     }\n }\n \n@@ -4739,14 +4739,18 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_item_const(&mut self, m: Mutability) -> ItemInfo {\n+    fn parse_item_const(&mut self, m: Option<Mutability>) -> ItemInfo {\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n         let ty = self.parse_ty(true);\n         self.expect(&token::EQ);\n         let e = self.parse_expr();\n         self.commit_expr_expecting(&*e, token::SEMI);\n-        (id, ItemStatic(ty, m, e), None)\n+        let item = match m {\n+            Some(m) => ItemStatic(ty, m, e),\n+            None => ItemConst(ty, e),\n+        };\n+        (id, item, None)\n     }\n \n     /// Parse a `mod <foo> { ... }` or `mod <foo>;` item\n@@ -5296,7 +5300,7 @@ impl<'a> Parser<'a> {\n             // STATIC ITEM\n             self.bump();\n             let m = if self.eat_keyword(keywords::Mut) {MutMutable} else {MutImmutable};\n-            let (ident, item_, extra_attrs) = self.parse_item_const(m);\n+            let (ident, item_, extra_attrs) = self.parse_item_const(Some(m));\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n@@ -5314,7 +5318,7 @@ impl<'a> Parser<'a> {\n                 self.span_err(last_span, \"const globals cannot be mutable, \\\n                                           did you mean to declare a static?\");\n             }\n-            let (ident, item_, extra_attrs) = self.parse_item_const(MutImmutable);\n+            let (ident, item_, extra_attrs) = self.parse_item_const(None);\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,"}, {"sha": "fa6b0c5ad4ae785d079c36dd2f345892c751e19a", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -385,13 +385,13 @@ macro_rules! declare_special_idents_and_keywords {(\n         use ast::{Ident, Name};\n         $(\n             #[allow(non_uppercase_statics)]\n-            pub static $si_static: Ident = Ident { name: Name($si_name), ctxt: 0 };\n+            pub const $si_static: Ident = Ident { name: Name($si_name), ctxt: 0 };\n          )*\n     }\n \n     pub mod special_names {\n         use ast::Name;\n-        $( #[allow(non_uppercase_statics)] pub static $si_static: Name =  Name($si_name); )*\n+        $( #[allow(non_uppercase_statics)] pub const $si_static: Name =  Name($si_name); )*\n     }\n \n     /**\n@@ -432,13 +432,13 @@ macro_rules! declare_special_idents_and_keywords {(\n }}\n \n // If the special idents get renumbered, remember to modify these two as appropriate\n-pub static SELF_KEYWORD_NAME: Name = Name(SELF_KEYWORD_NAME_NUM);\n-static STATIC_KEYWORD_NAME: Name = Name(STATIC_KEYWORD_NAME_NUM);\n-static SUPER_KEYWORD_NAME: Name = Name(SUPER_KEYWORD_NAME_NUM);\n+pub const SELF_KEYWORD_NAME: Name = Name(SELF_KEYWORD_NAME_NUM);\n+const STATIC_KEYWORD_NAME: Name = Name(STATIC_KEYWORD_NAME_NUM);\n+const SUPER_KEYWORD_NAME: Name = Name(SUPER_KEYWORD_NAME_NUM);\n \n-pub static SELF_KEYWORD_NAME_NUM: u32 = 1;\n-static STATIC_KEYWORD_NAME_NUM: u32 = 2;\n-static SUPER_KEYWORD_NAME_NUM: u32 = 3;\n+pub const SELF_KEYWORD_NAME_NUM: u32 = 1;\n+const STATIC_KEYWORD_NAME_NUM: u32 = 2;\n+const SUPER_KEYWORD_NAME_NUM: u32 = 3;\n \n // NB: leaving holes in the ident table is bad! a different ident will get\n // interned with the id from the hole, but it will be between the min and max"}, {"sha": "e1a2b2aeefeea7bd4563e1c87d88802e4c8035db", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -90,10 +90,10 @@ pub fn rust_printer_annotated<'a>(writer: Box<io::Writer+'static>,\n }\n \n #[allow(non_uppercase_statics)]\n-pub static indent_unit: uint = 4u;\n+pub const indent_unit: uint = 4u;\n \n #[allow(non_uppercase_statics)]\n-pub static default_columns: uint = 78u;\n+pub const default_columns: uint = 78u;\n \n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments and literals to\n@@ -757,6 +757,20 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n+            ast::ItemConst(ref ty, ref expr) => {\n+                try!(self.head(visibility_qualified(item.vis,\n+                                                    \"const\").as_slice()));\n+                try!(self.print_ident(item.ident));\n+                try!(self.word_space(\":\"));\n+                try!(self.print_type(&**ty));\n+                try!(space(&mut self.s));\n+                try!(self.end()); // end the head-ibox\n+\n+                try!(self.word_space(\"=\"));\n+                try!(self.print_expr(&**expr));\n+                try!(word(&mut self.s, \";\"));\n+                try!(self.end()); // end the outer cbox\n+            }\n             ast::ItemFn(ref decl, fn_style, abi, ref typarams, ref body) => {\n                 try!(self.print_fn(\n                     &**decl,"}, {"sha": "9fb5742bb9b15fbc0fc19257b6d0511bbdaaf557", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -493,11 +493,10 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n                                   Some(static_lt),\n                                   ast::MutImmutable);\n     // static TESTS: $static_type = &[...];\n-    ecx.item_static(sp,\n-                    ecx.ident_of(\"TESTS\"),\n-                    static_type,\n-                    ast::MutImmutable,\n-                    test_descs)\n+    ecx.item_const(sp,\n+                   ecx.ident_of(\"TESTS\"),\n+                   static_type,\n+                   test_descs)\n }\n \n fn is_test_crate(krate: &ast::Crate) -> bool {"}, {"sha": "5c7b144f4ab6efde7d1167375e8addb6cbda93c4", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -211,7 +211,8 @@ pub fn walk_trait_ref_helper<'v,V>(visitor: &mut V, trait_ref: &'v TraitRef)\n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n-        ItemStatic(ref typ, _, ref expr) => {\n+        ItemStatic(ref typ, _, ref expr) |\n+        ItemConst(ref typ, ref expr) => {\n             visitor.visit_ty(&**typ);\n             visitor.visit_expr(&**expr);\n         }"}, {"sha": "fbf17b76d6201397a5bb0b3315b9c83fdb4d77ef", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -155,23 +155,23 @@ pub mod color {\n     /// Number for a terminal color\n     pub type Color = u16;\n \n-    pub static BLACK:   Color = 0u16;\n-    pub static RED:     Color = 1u16;\n-    pub static GREEN:   Color = 2u16;\n-    pub static YELLOW:  Color = 3u16;\n-    pub static BLUE:    Color = 4u16;\n-    pub static MAGENTA: Color = 5u16;\n-    pub static CYAN:    Color = 6u16;\n-    pub static WHITE:   Color = 7u16;\n-\n-    pub static BRIGHT_BLACK:   Color = 8u16;\n-    pub static BRIGHT_RED:     Color = 9u16;\n-    pub static BRIGHT_GREEN:   Color = 10u16;\n-    pub static BRIGHT_YELLOW:  Color = 11u16;\n-    pub static BRIGHT_BLUE:    Color = 12u16;\n-    pub static BRIGHT_MAGENTA: Color = 13u16;\n-    pub static BRIGHT_CYAN:    Color = 14u16;\n-    pub static BRIGHT_WHITE:   Color = 15u16;\n+    pub const BLACK:   Color = 0u16;\n+    pub const RED:     Color = 1u16;\n+    pub const GREEN:   Color = 2u16;\n+    pub const YELLOW:  Color = 3u16;\n+    pub const BLUE:    Color = 4u16;\n+    pub const MAGENTA: Color = 5u16;\n+    pub const CYAN:    Color = 6u16;\n+    pub const WHITE:   Color = 7u16;\n+\n+    pub const BRIGHT_BLACK:   Color = 8u16;\n+    pub const BRIGHT_RED:     Color = 9u16;\n+    pub const BRIGHT_GREEN:   Color = 10u16;\n+    pub const BRIGHT_YELLOW:  Color = 11u16;\n+    pub const BRIGHT_BLUE:    Color = 12u16;\n+    pub const BRIGHT_MAGENTA: Color = 13u16;\n+    pub const BRIGHT_CYAN:    Color = 14u16;\n+    pub const BRIGHT_WHITE:   Color = 15u16;\n }\n \n /// Terminal attributes"}, {"sha": "76a9476d1fc8dfc452e76e64d43822998431e2d7", "filename": "src/libunicode/normalize.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibunicode%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibunicode%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fnormalize.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -100,15 +100,15 @@ pub fn compose(a: char, b: char) -> Option<char> {\n }\n \n // Constants from Unicode 6.3.0 Section 3.12 Conjoining Jamo Behavior\n-static S_BASE: u32 = 0xAC00;\n-static L_BASE: u32 = 0x1100;\n-static V_BASE: u32 = 0x1161;\n-static T_BASE: u32 = 0x11A7;\n-static L_COUNT: u32 = 19;\n-static V_COUNT: u32 = 21;\n-static T_COUNT: u32 = 28;\n-static N_COUNT: u32 = (V_COUNT * T_COUNT);\n-static S_COUNT: u32 = (L_COUNT * N_COUNT);\n+const S_BASE: u32 = 0xAC00;\n+const L_BASE: u32 = 0x1100;\n+const V_BASE: u32 = 0x1161;\n+const T_BASE: u32 = 0x11A7;\n+const L_COUNT: u32 = 19;\n+const V_COUNT: u32 = 21;\n+const T_COUNT: u32 = 28;\n+const N_COUNT: u32 = (V_COUNT * T_COUNT);\n+const S_COUNT: u32 = (L_COUNT * N_COUNT);\n \n // Decompose a precomposed Hangul syllable\n #[inline(always)]"}, {"sha": "e359883295f421925f87588e0d207aacbaaed403", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 103, "deletions": 102, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -3636,108 +3636,109 @@ pub mod property {\n }\n \n pub mod regex {\n-    pub static UNICODE_CLASSES: &'static [(&'static str, &'static [(char, char)])] = &[\n-        (\"Alphabetic\", super::derived_property::Alphabetic_table), (\"Arabic\",\n-        super::script::Arabic_table), (\"Armenian\", super::script::Armenian_table), (\"Avestan\",\n-        super::script::Avestan_table), (\"Balinese\", super::script::Balinese_table), (\"Bamum\",\n-        super::script::Bamum_table), (\"Bassa_Vah\", super::script::Bassa_Vah_table), (\"Batak\",\n-        super::script::Batak_table), (\"Bengali\", super::script::Bengali_table), (\"Bopomofo\",\n-        super::script::Bopomofo_table), (\"Brahmi\", super::script::Brahmi_table), (\"Braille\",\n-        super::script::Braille_table), (\"Buginese\", super::script::Buginese_table), (\"Buhid\",\n-        super::script::Buhid_table), (\"C\", super::general_category::C_table),\n-        (\"Canadian_Aboriginal\", super::script::Canadian_Aboriginal_table), (\"Carian\",\n-        super::script::Carian_table), (\"Caucasian_Albanian\",\n-        super::script::Caucasian_Albanian_table), (\"Cc\", super::general_category::Cc_table), (\"Cf\",\n-        super::general_category::Cf_table), (\"Chakma\", super::script::Chakma_table), (\"Cham\",\n-        super::script::Cham_table), (\"Cherokee\", super::script::Cherokee_table), (\"Cn\",\n-        super::general_category::Cn_table), (\"Co\", super::general_category::Co_table), (\"Common\",\n-        super::script::Common_table), (\"Coptic\", super::script::Coptic_table), (\"Cuneiform\",\n-        super::script::Cuneiform_table), (\"Cypriot\", super::script::Cypriot_table), (\"Cyrillic\",\n-        super::script::Cyrillic_table), (\"Default_Ignorable_Code_Point\",\n-        super::derived_property::Default_Ignorable_Code_Point_table), (\"Deseret\",\n-        super::script::Deseret_table), (\"Devanagari\", super::script::Devanagari_table), (\"Duployan\",\n-        super::script::Duployan_table), (\"Egyptian_Hieroglyphs\",\n-        super::script::Egyptian_Hieroglyphs_table), (\"Elbasan\", super::script::Elbasan_table),\n-        (\"Ethiopic\", super::script::Ethiopic_table), (\"Georgian\", super::script::Georgian_table),\n-        (\"Glagolitic\", super::script::Glagolitic_table), (\"Gothic\", super::script::Gothic_table),\n-        (\"Grantha\", super::script::Grantha_table), (\"Greek\", super::script::Greek_table),\n-        (\"Gujarati\", super::script::Gujarati_table), (\"Gurmukhi\", super::script::Gurmukhi_table),\n-        (\"Han\", super::script::Han_table), (\"Hangul\", super::script::Hangul_table), (\"Hanunoo\",\n-        super::script::Hanunoo_table), (\"Hebrew\", super::script::Hebrew_table), (\"Hiragana\",\n-        super::script::Hiragana_table), (\"Imperial_Aramaic\", super::script::Imperial_Aramaic_table),\n-        (\"Inherited\", super::script::Inherited_table), (\"Inscriptional_Pahlavi\",\n-        super::script::Inscriptional_Pahlavi_table), (\"Inscriptional_Parthian\",\n-        super::script::Inscriptional_Parthian_table), (\"Javanese\", super::script::Javanese_table),\n-        (\"Join_Control\", super::property::Join_Control_table), (\"Kaithi\",\n-        super::script::Kaithi_table), (\"Kannada\", super::script::Kannada_table), (\"Katakana\",\n-        super::script::Katakana_table), (\"Kayah_Li\", super::script::Kayah_Li_table), (\"Kharoshthi\",\n-        super::script::Kharoshthi_table), (\"Khmer\", super::script::Khmer_table), (\"Khojki\",\n-        super::script::Khojki_table), (\"Khudawadi\", super::script::Khudawadi_table), (\"L\",\n-        super::general_category::L_table), (\"LC\", super::general_category::LC_table), (\"Lao\",\n-        super::script::Lao_table), (\"Latin\", super::script::Latin_table), (\"Lepcha\",\n-        super::script::Lepcha_table), (\"Limbu\", super::script::Limbu_table), (\"Linear_A\",\n-        super::script::Linear_A_table), (\"Linear_B\", super::script::Linear_B_table), (\"Lisu\",\n-        super::script::Lisu_table), (\"Ll\", super::general_category::Ll_table), (\"Lm\",\n-        super::general_category::Lm_table), (\"Lo\", super::general_category::Lo_table), (\"Lowercase\",\n-        super::derived_property::Lowercase_table), (\"Lt\", super::general_category::Lt_table), (\"Lu\",\n-        super::general_category::Lu_table), (\"Lycian\", super::script::Lycian_table), (\"Lydian\",\n-        super::script::Lydian_table), (\"M\", super::general_category::M_table), (\"Mahajani\",\n-        super::script::Mahajani_table), (\"Malayalam\", super::script::Malayalam_table), (\"Mandaic\",\n-        super::script::Mandaic_table), (\"Manichaean\", super::script::Manichaean_table), (\"Mc\",\n-        super::general_category::Mc_table), (\"Me\", super::general_category::Me_table),\n-        (\"Meetei_Mayek\", super::script::Meetei_Mayek_table), (\"Mende_Kikakui\",\n-        super::script::Mende_Kikakui_table), (\"Meroitic_Cursive\",\n-        super::script::Meroitic_Cursive_table), (\"Meroitic_Hieroglyphs\",\n-        super::script::Meroitic_Hieroglyphs_table), (\"Miao\", super::script::Miao_table), (\"Mn\",\n-        super::general_category::Mn_table), (\"Modi\", super::script::Modi_table), (\"Mongolian\",\n-        super::script::Mongolian_table), (\"Mro\", super::script::Mro_table), (\"Myanmar\",\n-        super::script::Myanmar_table), (\"N\", super::general_category::N_table), (\"Nabataean\",\n-        super::script::Nabataean_table), (\"Nd\", super::general_category::Nd_table), (\"New_Tai_Lue\",\n-        super::script::New_Tai_Lue_table), (\"Nko\", super::script::Nko_table), (\"Nl\",\n-        super::general_category::Nl_table), (\"No\", super::general_category::No_table),\n-        (\"Noncharacter_Code_Point\", super::property::Noncharacter_Code_Point_table), (\"Ogham\",\n-        super::script::Ogham_table), (\"Ol_Chiki\", super::script::Ol_Chiki_table), (\"Old_Italic\",\n-        super::script::Old_Italic_table), (\"Old_North_Arabian\",\n-        super::script::Old_North_Arabian_table), (\"Old_Permic\", super::script::Old_Permic_table),\n-        (\"Old_Persian\", super::script::Old_Persian_table), (\"Old_South_Arabian\",\n-        super::script::Old_South_Arabian_table), (\"Old_Turkic\", super::script::Old_Turkic_table),\n-        (\"Oriya\", super::script::Oriya_table), (\"Osmanya\", super::script::Osmanya_table), (\"P\",\n-        super::general_category::P_table), (\"Pahawh_Hmong\", super::script::Pahawh_Hmong_table),\n-        (\"Palmyrene\", super::script::Palmyrene_table), (\"Pau_Cin_Hau\",\n-        super::script::Pau_Cin_Hau_table), (\"Pc\", super::general_category::Pc_table), (\"Pd\",\n-        super::general_category::Pd_table), (\"Pe\", super::general_category::Pe_table), (\"Pf\",\n-        super::general_category::Pf_table), (\"Phags_Pa\", super::script::Phags_Pa_table),\n-        (\"Phoenician\", super::script::Phoenician_table), (\"Pi\", super::general_category::Pi_table),\n-        (\"Po\", super::general_category::Po_table), (\"Ps\", super::general_category::Ps_table),\n-        (\"Psalter_Pahlavi\", super::script::Psalter_Pahlavi_table), (\"Rejang\",\n-        super::script::Rejang_table), (\"Runic\", super::script::Runic_table), (\"S\",\n-        super::general_category::S_table), (\"Samaritan\", super::script::Samaritan_table),\n-        (\"Saurashtra\", super::script::Saurashtra_table), (\"Sc\", super::general_category::Sc_table),\n-        (\"Sharada\", super::script::Sharada_table), (\"Shavian\", super::script::Shavian_table),\n-        (\"Siddham\", super::script::Siddham_table), (\"Sinhala\", super::script::Sinhala_table), (\"Sk\",\n-        super::general_category::Sk_table), (\"Sm\", super::general_category::Sm_table), (\"So\",\n-        super::general_category::So_table), (\"Sora_Sompeng\", super::script::Sora_Sompeng_table),\n-        (\"Sundanese\", super::script::Sundanese_table), (\"Syloti_Nagri\",\n-        super::script::Syloti_Nagri_table), (\"Syriac\", super::script::Syriac_table), (\"Tagalog\",\n-        super::script::Tagalog_table), (\"Tagbanwa\", super::script::Tagbanwa_table), (\"Tai_Le\",\n-        super::script::Tai_Le_table), (\"Tai_Tham\", super::script::Tai_Tham_table), (\"Tai_Viet\",\n-        super::script::Tai_Viet_table), (\"Takri\", super::script::Takri_table), (\"Tamil\",\n-        super::script::Tamil_table), (\"Telugu\", super::script::Telugu_table), (\"Thaana\",\n-        super::script::Thaana_table), (\"Thai\", super::script::Thai_table), (\"Tibetan\",\n-        super::script::Tibetan_table), (\"Tifinagh\", super::script::Tifinagh_table), (\"Tirhuta\",\n-        super::script::Tirhuta_table), (\"Ugaritic\", super::script::Ugaritic_table), (\"Uppercase\",\n-        super::derived_property::Uppercase_table), (\"Vai\", super::script::Vai_table),\n-        (\"Warang_Citi\", super::script::Warang_Citi_table), (\"White_Space\",\n-        super::property::White_Space_table), (\"XID_Continue\",\n-        super::derived_property::XID_Continue_table), (\"XID_Start\",\n-        super::derived_property::XID_Start_table), (\"Yi\", super::script::Yi_table), (\"Z\",\n-        super::general_category::Z_table), (\"Zl\", super::general_category::Zl_table), (\"Zp\",\n-        super::general_category::Zp_table), (\"Zs\", super::general_category::Zs_table)\n-    ];\n-\n-    pub static PERLD: &'static [(char, char)] = super::general_category::Nd_table;\n-\n-    pub static PERLS: &'static [(char, char)] = super::property::White_Space_table;\n+    pub static UNICODE_CLASSES: &'static [(&'static str, &'static &'static [(char, char)])] = &[\n+        (\"Alphabetic\", &super::derived_property::Alphabetic_table), (\"Arabic\",\n+        &super::script::Arabic_table), (\"Armenian\", &super::script::Armenian_table), (\"Avestan\",\n+        &super::script::Avestan_table), (\"Balinese\", &super::script::Balinese_table), (\"Bamum\",\n+        &super::script::Bamum_table), (\"Bassa_Vah\", &super::script::Bassa_Vah_table), (\"Batak\",\n+        &super::script::Batak_table), (\"Bengali\", &super::script::Bengali_table), (\"Bopomofo\",\n+        &super::script::Bopomofo_table), (\"Brahmi\", &super::script::Brahmi_table), (\"Braille\",\n+        &super::script::Braille_table), (\"Buginese\", &super::script::Buginese_table), (\"Buhid\",\n+        &super::script::Buhid_table), (\"C\", &super::general_category::C_table),\n+        (\"Canadian_Aboriginal\", &super::script::Canadian_Aboriginal_table), (\"Carian\",\n+        &super::script::Carian_table), (\"Caucasian_Albanian\",\n+        &super::script::Caucasian_Albanian_table), (\"Cc\", &super::general_category::Cc_table),\n+        (\"Cf\", &super::general_category::Cf_table), (\"Chakma\", &super::script::Chakma_table),\n+        (\"Cham\", &super::script::Cham_table), (\"Cherokee\", &super::script::Cherokee_table), (\"Cn\",\n+        &super::general_category::Cn_table), (\"Co\", &super::general_category::Co_table), (\"Common\",\n+        &super::script::Common_table), (\"Coptic\", &super::script::Coptic_table), (\"Cuneiform\",\n+        &super::script::Cuneiform_table), (\"Cypriot\", &super::script::Cypriot_table), (\"Cyrillic\",\n+        &super::script::Cyrillic_table), (\"Default_Ignorable_Code_Point\",\n+        &super::derived_property::Default_Ignorable_Code_Point_table), (\"Deseret\",\n+        &super::script::Deseret_table), (\"Devanagari\", &super::script::Devanagari_table),\n+        (\"Duployan\", &super::script::Duployan_table), (\"Egyptian_Hieroglyphs\",\n+        &super::script::Egyptian_Hieroglyphs_table), (\"Elbasan\", &super::script::Elbasan_table),\n+        (\"Ethiopic\", &super::script::Ethiopic_table), (\"Georgian\", &super::script::Georgian_table),\n+        (\"Glagolitic\", &super::script::Glagolitic_table), (\"Gothic\", &super::script::Gothic_table),\n+        (\"Grantha\", &super::script::Grantha_table), (\"Greek\", &super::script::Greek_table),\n+        (\"Gujarati\", &super::script::Gujarati_table), (\"Gurmukhi\", &super::script::Gurmukhi_table),\n+        (\"Han\", &super::script::Han_table), (\"Hangul\", &super::script::Hangul_table), (\"Hanunoo\",\n+        &super::script::Hanunoo_table), (\"Hebrew\", &super::script::Hebrew_table), (\"Hiragana\",\n+        &super::script::Hiragana_table), (\"Imperial_Aramaic\",\n+        &super::script::Imperial_Aramaic_table), (\"Inherited\", &super::script::Inherited_table),\n+        (\"Inscriptional_Pahlavi\", &super::script::Inscriptional_Pahlavi_table),\n+        (\"Inscriptional_Parthian\", &super::script::Inscriptional_Parthian_table), (\"Javanese\",\n+        &super::script::Javanese_table), (\"Join_Control\", &super::property::Join_Control_table),\n+        (\"Kaithi\", &super::script::Kaithi_table), (\"Kannada\", &super::script::Kannada_table),\n+        (\"Katakana\", &super::script::Katakana_table), (\"Kayah_Li\", &super::script::Kayah_Li_table),\n+        (\"Kharoshthi\", &super::script::Kharoshthi_table), (\"Khmer\", &super::script::Khmer_table),\n+        (\"Khojki\", &super::script::Khojki_table), (\"Khudawadi\", &super::script::Khudawadi_table),\n+        (\"L\", &super::general_category::L_table), (\"LC\", &super::general_category::LC_table),\n+        (\"Lao\", &super::script::Lao_table), (\"Latin\", &super::script::Latin_table), (\"Lepcha\",\n+        &super::script::Lepcha_table), (\"Limbu\", &super::script::Limbu_table), (\"Linear_A\",\n+        &super::script::Linear_A_table), (\"Linear_B\", &super::script::Linear_B_table), (\"Lisu\",\n+        &super::script::Lisu_table), (\"Ll\", &super::general_category::Ll_table), (\"Lm\",\n+        &super::general_category::Lm_table), (\"Lo\", &super::general_category::Lo_table),\n+        (\"Lowercase\", &super::derived_property::Lowercase_table), (\"Lt\",\n+        &super::general_category::Lt_table), (\"Lu\", &super::general_category::Lu_table), (\"Lycian\",\n+        &super::script::Lycian_table), (\"Lydian\", &super::script::Lydian_table), (\"M\",\n+        &super::general_category::M_table), (\"Mahajani\", &super::script::Mahajani_table),\n+        (\"Malayalam\", &super::script::Malayalam_table), (\"Mandaic\", &super::script::Mandaic_table),\n+        (\"Manichaean\", &super::script::Manichaean_table), (\"Mc\",\n+        &super::general_category::Mc_table), (\"Me\", &super::general_category::Me_table),\n+        (\"Meetei_Mayek\", &super::script::Meetei_Mayek_table), (\"Mende_Kikakui\",\n+        &super::script::Mende_Kikakui_table), (\"Meroitic_Cursive\",\n+        &super::script::Meroitic_Cursive_table), (\"Meroitic_Hieroglyphs\",\n+        &super::script::Meroitic_Hieroglyphs_table), (\"Miao\", &super::script::Miao_table), (\"Mn\",\n+        &super::general_category::Mn_table), (\"Modi\", &super::script::Modi_table), (\"Mongolian\",\n+        &super::script::Mongolian_table), (\"Mro\", &super::script::Mro_table), (\"Myanmar\",\n+        &super::script::Myanmar_table), (\"N\", &super::general_category::N_table), (\"Nabataean\",\n+        &super::script::Nabataean_table), (\"Nd\", &super::general_category::Nd_table),\n+        (\"New_Tai_Lue\", &super::script::New_Tai_Lue_table), (\"Nko\", &super::script::Nko_table),\n+        (\"Nl\", &super::general_category::Nl_table), (\"No\", &super::general_category::No_table),\n+        (\"Noncharacter_Code_Point\", &super::property::Noncharacter_Code_Point_table), (\"Ogham\",\n+        &super::script::Ogham_table), (\"Ol_Chiki\", &super::script::Ol_Chiki_table), (\"Old_Italic\",\n+        &super::script::Old_Italic_table), (\"Old_North_Arabian\",\n+        &super::script::Old_North_Arabian_table), (\"Old_Permic\", &super::script::Old_Permic_table),\n+        (\"Old_Persian\", &super::script::Old_Persian_table), (\"Old_South_Arabian\",\n+        &super::script::Old_South_Arabian_table), (\"Old_Turkic\", &super::script::Old_Turkic_table),\n+        (\"Oriya\", &super::script::Oriya_table), (\"Osmanya\", &super::script::Osmanya_table), (\"P\",\n+        &super::general_category::P_table), (\"Pahawh_Hmong\", &super::script::Pahawh_Hmong_table),\n+        (\"Palmyrene\", &super::script::Palmyrene_table), (\"Pau_Cin_Hau\",\n+        &super::script::Pau_Cin_Hau_table), (\"Pc\", &super::general_category::Pc_table), (\"Pd\",\n+        &super::general_category::Pd_table), (\"Pe\", &super::general_category::Pe_table), (\"Pf\",\n+        &super::general_category::Pf_table), (\"Phags_Pa\", &super::script::Phags_Pa_table),\n+        (\"Phoenician\", &super::script::Phoenician_table), (\"Pi\",\n+        &super::general_category::Pi_table), (\"Po\", &super::general_category::Po_table), (\"Ps\",\n+        &super::general_category::Ps_table), (\"Psalter_Pahlavi\",\n+        &super::script::Psalter_Pahlavi_table), (\"Rejang\", &super::script::Rejang_table), (\"Runic\",\n+        &super::script::Runic_table), (\"S\", &super::general_category::S_table), (\"Samaritan\",\n+        &super::script::Samaritan_table), (\"Saurashtra\", &super::script::Saurashtra_table), (\"Sc\",\n+        &super::general_category::Sc_table), (\"Sharada\", &super::script::Sharada_table), (\"Shavian\",\n+        &super::script::Shavian_table), (\"Siddham\", &super::script::Siddham_table), (\"Sinhala\",\n+        &super::script::Sinhala_table), (\"Sk\", &super::general_category::Sk_table), (\"Sm\",\n+        &super::general_category::Sm_table), (\"So\", &super::general_category::So_table),\n+        (\"Sora_Sompeng\", &super::script::Sora_Sompeng_table), (\"Sundanese\",\n+        &super::script::Sundanese_table), (\"Syloti_Nagri\", &super::script::Syloti_Nagri_table),\n+        (\"Syriac\", &super::script::Syriac_table), (\"Tagalog\", &super::script::Tagalog_table),\n+        (\"Tagbanwa\", &super::script::Tagbanwa_table), (\"Tai_Le\", &super::script::Tai_Le_table),\n+        (\"Tai_Tham\", &super::script::Tai_Tham_table), (\"Tai_Viet\", &super::script::Tai_Viet_table),\n+        (\"Takri\", &super::script::Takri_table), (\"Tamil\", &super::script::Tamil_table), (\"Telugu\",\n+        &super::script::Telugu_table), (\"Thaana\", &super::script::Thaana_table), (\"Thai\",\n+        &super::script::Thai_table), (\"Tibetan\", &super::script::Tibetan_table), (\"Tifinagh\",\n+        &super::script::Tifinagh_table), (\"Tirhuta\", &super::script::Tirhuta_table), (\"Ugaritic\",\n+        &super::script::Ugaritic_table), (\"Uppercase\", &super::derived_property::Uppercase_table),\n+        (\"Vai\", &super::script::Vai_table), (\"Warang_Citi\", &super::script::Warang_Citi_table),\n+        (\"White_Space\", &super::property::White_Space_table), (\"XID_Continue\",\n+        &super::derived_property::XID_Continue_table), (\"XID_Start\",\n+        &super::derived_property::XID_Start_table), (\"Yi\", &super::script::Yi_table), (\"Z\",\n+        &super::general_category::Z_table), (\"Zl\", &super::general_category::Zl_table), (\"Zp\",\n+        &super::general_category::Zp_table), (\"Zs\", &super::general_category::Zs_table)\n+    ];\n+\n+    pub static PERLD: &'static &'static [(char, char)] = &super::general_category::Nd_table;\n+\n+    pub static PERLS: &'static &'static [(char, char)] = &super::property::White_Space_table;\n \n     pub static PERLW: &'static [(char, char)] = &[\n         ('\\x30', '\\x39'), ('\\x41', '\\x5a'), ('\\x5f', '\\x5f'), ('\\x61', '\\x7a'), ('\\xaa', '\\xaa'),"}, {"sha": "945004ede6de84518702b6e889d6027d3f2258a6", "filename": "src/test/auxiliary/cci_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fauxiliary%2Fcci_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fauxiliary%2Fcci_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_const.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -11,6 +11,6 @@\n pub extern fn bar() {\n }\n \n-pub static foopy: &'static str = \"hi there\";\n-pub static uint_val: uint = 12;\n-pub static uint_expr: uint = (1 << uint_val) - 1;\n+pub const foopy: &'static str = \"hi there\";\n+pub const uint_val: uint = 12;\n+pub const uint_expr: uint = (1 << uint_val) - 1;"}, {"sha": "3a9d76406e10a1c0d8af35a72468c37fd9d85402", "filename": "src/test/auxiliary/iss.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fauxiliary%2Fiss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fauxiliary%2Fiss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fiss.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -17,7 +17,7 @@ pub struct C<'a> {\n }\n \n fn no_op() { }\n-pub static D : C<'static> = C {\n+pub const D : C<'static> = C {\n     k: no_op\n };\n "}, {"sha": "e373421fabfaca1cba11a77d2595fcd4ec23152a", "filename": "src/test/auxiliary/issue-13620-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fauxiliary%2Fissue-13620-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fauxiliary%2Fissue-13620-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-13620-1.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -14,6 +14,6 @@ pub struct Foo {\n \n extern fn the_foo() {}\n \n-pub static FOO: Foo = Foo {\n+pub const FOO: Foo = Foo {\n     foo: the_foo\n };"}, {"sha": "3657d39ff77e4824aa4362ab9feebca02eec8945", "filename": "src/test/auxiliary/issue-17718-const-privacy.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fauxiliary%2Fissue-17718-const-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fauxiliary%2Fissue-17718-const-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17718-const-privacy.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use foo::FOO2;\n+\n+pub const FOO: uint = 3;\n+const BAR: uint = 3;\n+\n+mod foo {\n+    pub const FOO2: uint = 3;\n+}"}, {"sha": "f0b431b1db932c9226a70efae1972c450b919af9", "filename": "src/test/auxiliary/issue-17718.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17718.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::sync::atomic;\n+\n+pub const C1: uint = 1;\n+pub const C2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+pub const C3: fn() = foo;\n+pub const C4: uint = C1 * C1 + C1 / C1;\n+pub const C5: &'static uint = &C4;\n+\n+pub static S1: uint = 3;\n+pub static S2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+\n+fn foo() {}"}, {"sha": "5bd52ef501068c80decef3ebc60fc75b8b8735df", "filename": "src/test/auxiliary/issue13213aux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -21,7 +21,7 @@ mod private {\n     pub struct P {\n         p: i32,\n     }\n-    pub static THREE: P = P { p: 3 };\n+    pub const THREE: P = P { p: 3 };\n }\n \n pub static A: S = S { p: private::THREE };"}, {"sha": "e151369ff38ac645a5cc50dabf966fb3bb896b9f", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -45,24 +45,24 @@ use std::io::{stdout, IoResult};\n use std::os;\n use std::slice::bytes::copy_memory;\n \n-static LINE_LEN: uint = 60;\n-static LOOKUP_SIZE: uint = 4 * 1024;\n-static LOOKUP_SCALE: f32 = (LOOKUP_SIZE - 1) as f32;\n+const LINE_LEN: uint = 60;\n+const LOOKUP_SIZE: uint = 4 * 1024;\n+const LOOKUP_SCALE: f32 = (LOOKUP_SIZE - 1) as f32;\n \n // Random number generator constants\n-static IM: u32 = 139968;\n-static IA: u32 = 3877;\n-static IC: u32 = 29573;\n+const IM: u32 = 139968;\n+const IA: u32 = 3877;\n+const IC: u32 = 29573;\n \n-static ALU: &'static str = \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG\\\n+const ALU: &'static str = \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG\\\n                             GGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGA\\\n                             GACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAA\\\n                             AATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAAT\\\n                             CCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAAC\\\n                             CCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTG\\\n                             CACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n \n-static NULL_AMINO_ACID: AminoAcid = AminoAcid { c: ' ' as u8, p: 0.0 };\n+const NULL_AMINO_ACID: AminoAcid = AminoAcid { c: ' ' as u8, p: 0.0 };\n \n static IUB: [AminoAcid, ..15] = [\n     AminoAcid { c: 'a' as u8, p: 0.27 },"}, {"sha": "77311edba4e7afbafa9363e542d17f903aabd10c", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -45,8 +45,8 @@ use std::io::{BufferedWriter, File};\n use std::cmp::min;\n use std::os;\n \n-static LINE_LENGTH: uint = 60;\n-static IM: u32 = 139968;\n+const LINE_LENGTH: uint = 60;\n+const IM: u32 = 139968;\n \n struct MyRandom {\n     last: u32"}, {"sha": "66fe52d9ec7ed5e5f8122fa0c68a992ab7205e49", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -49,9 +49,9 @@ use std::os;\n use std::simd::f64x2;\n use std::sync::{Arc, Future};\n \n-static ITER: int = 50;\n-static LIMIT: f64 = 2.0;\n-static WORKERS: uint = 16;\n+const ITER: int = 50;\n+const LIMIT: f64 = 2.0;\n+const WORKERS: uint = 16;\n \n #[inline(always)]\n fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n@@ -144,7 +144,7 @@ fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n fn write_line(init_i: f64, vec_init_r: &[f64], res: &mut Vec<u8>) {\n     let v_init_i : f64x2 = f64x2(init_i, init_i);\n     let v_2 : f64x2 = f64x2(2.0, 2.0);\n-    static LIMIT_SQUARED: f64 = LIMIT * LIMIT;\n+    const LIMIT_SQUARED: f64 = LIMIT * LIMIT;\n \n     for chunk_init_r in vec_init_r.chunks(8) {\n         let mut cur_byte = 0xff;"}, {"sha": "a945e0f7796d18db225d982078611cf41662ed43", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -38,10 +38,10 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-static PI: f64 = 3.141592653589793;\n-static SOLAR_MASS: f64 = 4.0 * PI * PI;\n-static YEAR: f64 = 365.24;\n-static N_BODIES: uint = 5;\n+const PI: f64 = 3.141592653589793;\n+const SOLAR_MASS: f64 = 4.0 * PI * PI;\n+const YEAR: f64 = 365.24;\n+const N_BODIES: uint = 5;\n \n static BODIES: [Planet, ..N_BODIES] = [\n     // Sun"}, {"sha": "2945a05024792411a12333971c128e3b9656c988", "filename": "src/test/compile-fail/check-static-immutable-mut-slices.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fcheck-static-immutable-mut-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fcheck-static-immutable-mut-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-immutable-mut-slices.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -11,6 +11,6 @@\n // Checks that immutable static items can't have mutable slices\n \n static TEST: &'static mut [int] = &mut [];\n-//~^ ERROR static items are not allowed to have mutable slices\n+//~^ ERROR statics are not allowed to have mutable references\n \n pub fn main() { }"}, {"sha": "d23aa317247c08c0a95e9d2d6b06fa2a56dad909", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Verifies all possible restrictions for static items values.\n+// Verifies all possible restrictions for statics values.\n \n use std::kinds::marker;\n \n@@ -21,7 +21,7 @@ impl Drop for WithDtor {\n // This enum will be used to test the following rules:\n // 1. Variants are safe for static\n // 2. Expr calls are allowed as long as they arguments are safe\n-// 3. Expr calls with unsafe arguments for static items are rejected\n+// 3. Expr calls with unsafe arguments for statics are rejected\n enum SafeEnum {\n     Variant1,\n     Variant2(int),\n@@ -35,7 +35,7 @@ static STATIC2: SafeEnum = Variant2(0);\n \n // This one should fail\n static STATIC3: SafeEnum = Variant3(WithDtor);\n-//~^ ERROR static items are not allowed to have destructors\n+//~^ ERROR statics are not allowed to have destructors\n \n \n // This enum will be used to test that variants\n@@ -52,9 +52,9 @@ impl Drop for UnsafeEnum {\n \n \n static STATIC4: UnsafeEnum = Variant5;\n-//~^ ERROR static items are not allowed to have destructors\n+//~^ ERROR statics are not allowed to have destructors\n static STATIC5: UnsafeEnum = Variant6(0);\n-//~^ ERROR static items are not allowed to have destructors\n+//~^ ERROR statics are not allowed to have destructors\n \n \n struct SafeStruct {\n@@ -68,7 +68,7 @@ static STATIC6: SafeStruct = SafeStruct{field1: Variant1, field2: Variant2(0)};\n \n // field2 has an unsafe value, hence this should fail\n static STATIC7: SafeStruct = SafeStruct{field1: Variant1, field2: Variant3(WithDtor)};\n-//~^ ERROR static items are not allowed to have destructors\n+//~^ ERROR statics are not allowed to have destructors\n \n // Test variadic constructor for structs. The base struct should be examined\n // as well as every field present in the constructor.\n@@ -79,7 +79,7 @@ static STATIC8: SafeStruct = SafeStruct{field1: Variant1,\n // This example should fail because field1 in the base struct is not safe\n static STATIC9: SafeStruct = SafeStruct{field1: Variant1,\n                                         ..SafeStruct{field1: Variant3(WithDtor), field2: Variant1}};\n-//~^ ERROR static items are not allowed to have destructors\n+//~^ ERROR statics are not allowed to have destructors\n \n struct UnsafeStruct;\n \n@@ -89,44 +89,48 @@ impl Drop for UnsafeStruct {\n \n // Types with destructors are not allowed for statics\n static STATIC10: UnsafeStruct = UnsafeStruct;\n-//~^ ERROR static items are not allowed to have destructor\n+//~^ ERROR statics are not allowed to have destructor\n \n struct MyOwned;\n \n static STATIC11: Box<MyOwned> = box MyOwned;\n-//~^ ERROR static items are not allowed to have custom pointers\n+//~^ ERROR statics are not allowed to have custom pointers\n \n // The following examples test that mutable structs are just forbidden\n // to have types with destructors\n // These should fail\n static mut STATIC12: UnsafeStruct = UnsafeStruct;\n-//~^ ERROR mutable static items are not allowed to have destructors\n+//~^ ERROR mutable statics are not allowed to have destructors\n+//~^^ ERROR statics are not allowed to have destructors\n \n static mut STATIC13: SafeStruct = SafeStruct{field1: Variant1, field2: Variant3(WithDtor)};\n-//~^ ERROR mutable static items are not allowed to have destructors\n+//~^ ERROR mutable statics are not allowed to have destructors\n+//~^^ ERROR: statics are not allowed to have destructors\n \n static mut STATIC14: SafeStruct = SafeStruct {\n-//~^ ERROR mutable static items are not allowed to have destructors\n+//~^ ERROR mutable statics are not allowed to have destructors\n     field1: Variant1,\n     field2: Variant4(\"str\".to_string())\n };\n \n-static STATIC15: &'static [Box<MyOwned>] = &[box MyOwned, box MyOwned];\n-//~^ ERROR static items are not allowed to have custom pointers\n-//~^^ ERROR static items are not allowed to have custom pointers\n+static STATIC15: &'static [Box<MyOwned>] = &[\n+    box MyOwned, //~ ERROR statics are not allowed to have custom pointers\n+    box MyOwned, //~ ERROR statics are not allowed to have custom pointers\n+];\n \n-static STATIC16: (&'static Box<MyOwned>, &'static Box<MyOwned>) =\n-    (&box MyOwned, &box MyOwned);\n-//~^ ERROR static items are not allowed to have custom pointers\n-//~^^ ERROR static items are not allowed to have custom pointers\n+static STATIC16: (&'static Box<MyOwned>, &'static Box<MyOwned>) = (\n+    &box MyOwned, //~ ERROR statics are not allowed to have custom pointers\n+    &box MyOwned, //~ ERROR statics are not allowed to have custom pointers\n+);\n \n static mut STATIC17: SafeEnum = Variant1;\n-//~^ ERROR mutable static items are not allowed to have destructors\n+//~^ ERROR mutable statics are not allowed to have destructors\n \n-static STATIC19: Box<int> = box 3;\n-//~^ ERROR static items are not allowed to have custom pointers\n+static STATIC19: Box<int> =\n+    box 3;\n+//~^ ERROR statics are not allowed to have custom pointers\n \n pub fn main() {\n     let y = { static x: Box<int> = box 3; x };\n-    //~^ ERROR static items are not allowed to have custom pointers\n+    //~^ ERROR statics are not allowed to have custom pointers\n }"}, {"sha": "6d9657ab28912ef5d3df5528e4618a73f95f1078", "filename": "src/test/compile-fail/issue-15524.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static N: int = 1;\n+const N: int = 1;\n \n enum Foo {\n     A = 1,"}, {"sha": "aa586e58f7084846c1edaa910528f2183a546a0b", "filename": "src/test/compile-fail/issue-16149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -15,7 +15,7 @@ extern {\n fn main() {\n     let boolValue = match 42 {\n         externalValue => true,\n-        //~^ ERROR extern statics cannot be referenced in patterns\n+        //~^ ERROR static variables cannot be referenced in a pattern\n         _ => false\n     };\n }"}, {"sha": "1f763dbdc9fa642001f8e79a7eef83259e2408fe", "filename": "src/test/compile-fail/issue-17718-borrow-interior.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-borrow-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-borrow-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-borrow-interior.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S { a: uint }\n+static A: S  = S { a: 3 };\n+static B: &'static uint = &A.a;\n+//~^ ERROR: cannot refer to the interior of another static\n+static C: &'static uint = &(A.a);\n+//~^ ERROR: cannot refer to the interior of another static\n+\n+static D: [uint, ..1] = [1];\n+static E: uint = D[0];\n+//~^ ERROR: cannot refer to other statics by value\n+static F: &'static uint = &D[0];\n+//~^ ERROR: cannot refer to the interior of another static\n+\n+fn main() {}"}, {"sha": "6425dbda5c6c9071528e57cdb03987aec0683554", "filename": "src/test/compile-fail/issue-17718-const-bad-values.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const C1: &'static mut [uint] = &mut [];\n+//~^ ERROR: constants are not allowed to have mutable references\n+\n+static mut S: uint = 3;\n+const C2: &'static mut uint = &mut S;\n+//~^ ERROR: constants cannot refer to other statics\n+//~^^ ERROR: are not allowed to have mutable references\n+\n+fn main() {}\n+"}, {"sha": "21cc9a757cf19d1b4ca95be0fcee87d2b49aacff", "filename": "src/test/compile-fail/issue-17718-const-borrow.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-borrow.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::UnsafeCell;\n+\n+const A: UnsafeCell<uint> = UnsafeCell { value: 1 };\n+const B: &'static UnsafeCell<uint> = &A;\n+//~^ ERROR: cannot borrow a constant which contains interior mutability\n+\n+struct C { a: UnsafeCell<uint> }\n+const D: C = C { a: UnsafeCell { value: 1 } };\n+const E: &'static UnsafeCell<uint> = &D.a;\n+//~^ ERROR: cannot borrow a constant which contains interior mutability\n+const F: &'static C = &D;\n+//~^ ERROR: cannot borrow a constant which contains interior mutability\n+\n+fn main() {}"}, {"sha": "e888f917741abdd8b13987e55da7ef72ecec1758", "filename": "src/test/compile-fail/issue-17718-const-destructors.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-destructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-destructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-destructors.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A;\n+impl Drop for A {\n+    fn drop(&mut self) {}\n+}\n+\n+const FOO: A = A;\n+//~^ ERROR: constants are not allowed to have destructors\n+\n+fn main() {}"}, {"sha": "046f038847b7bb3435f61b7d0b5840eb13dfa9d9", "filename": "src/test/compile-fail/issue-17718-const-naming.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deny(warnings)]\n+\n+const foo: int = 3;\n+//~^ ERROR: should have an uppercase name such as\n+\n+fn main() {}"}, {"sha": "d3be9f3dd3f77529fbae1d104c5ecb148b1532ac", "filename": "src/test/compile-fail/issue-17718-const-privacy.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-privacy.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-17718-const-privacy.rs\n+\n+extern crate \"issue-17718-const-privacy\" as other;\n+\n+use a::B; //~ ERROR: const `B` is private\n+use other::{\n+    FOO,\n+    BAR, //~ ERROR: const `BAR` is private\n+    FOO2,\n+};\n+\n+mod a {\n+    const B: uint = 3;\n+}\n+\n+fn main() {}"}, {"sha": "8c51b592054a5f33307b46c24c73140b60a99200", "filename": "src/test/compile-fail/issue-17718-constants-not-static.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-constants-not-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-constants-not-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-constants-not-static.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const FOO: uint = 3;\n+\n+fn foo() -> &'static uint { &FOO }\n+//~^ ERROR: borrowed value does not live long enough\n+\n+fn main() {\n+}"}, {"sha": "235d1222d81c0d99d2d5b58496f78a82b9c3d5e7", "filename": "src/test/compile-fail/issue-17718-extern-const.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-extern-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-extern-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-extern-const.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern {\n+    const FOO: uint; //~ ERROR: unexpected token: `const`\n+}\n+\n+fn main() {}"}, {"sha": "01dfb1b4af93cdc7abc06a9ce2f4792933e1005b", "filename": "src/test/compile-fail/issue-17718-patterns.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-patterns.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static A1: uint = 1;\n+static mut A2: uint = 1;\n+const A3: uint = 1;\n+\n+fn main() {\n+    match 1u {\n+        A1 => {} //~ ERROR: static variables cannot be referenced in a pattern\n+        A2 => {} //~ ERROR: static variables cannot be referenced in a pattern\n+        A3 => {}\n+        _ => {}\n+    }\n+}"}, {"sha": "a13dfe639c12bd5806b184c979cf832f2aa29f34", "filename": "src/test/compile-fail/issue-17718-recursive.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-recursive.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const A: uint = B; //~ ERROR: recursive constant\n+const B: uint = A; //~ ERROR: recursive constant\n+\n+fn main() {}"}, {"sha": "7b272e1610c7fa328d65c8f73b4e93c00db00bd4", "filename": "src/test/compile-fail/issue-17718-references.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Struct { a: uint }\n+\n+const C: uint = 1;\n+static S: uint = 1;\n+\n+const T1: &'static uint = &C;\n+const T2: &'static uint = &S; //~ ERROR: constants cannot refer to other statics\n+static T3: &'static uint = &C;\n+static T4: &'static uint = &S;\n+\n+const T5: uint = C;\n+const T6: uint = S; //~ ERROR: constants cannot refer to other statics\n+//~^ cannot refer to other statics\n+static T7: uint = C;\n+static T8: uint = S; //~ ERROR: cannot refer to other statics by value\n+\n+const T9: Struct = Struct { a: C };\n+const T10: Struct = Struct { a: S }; //~ ERROR: cannot refer to other statics by value\n+//~^ ERROR: constants cannot refer to other statics\n+static T11: Struct = Struct { a: C };\n+static T12: Struct = Struct { a: S }; //~ ERROR: cannot refer to other statics by value\n+\n+fn main() {}"}, {"sha": "c57df9a3af4a4f88392a6f739f55f689f42fb954", "filename": "src/test/compile-fail/issue-17718-static-move.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-move.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::kinds::marker;\n+\n+struct Foo { nc: marker::NoCopy }\n+const INIT: Foo = Foo { nc: marker::NoCopy };\n+static FOO: Foo = INIT;\n+\n+fn main() {\n+    let _a = FOO; //~ ERROR: cannot move out of static item\n+}"}, {"sha": "2304b18adb63d698af51410f614af52ceeeb2fe4", "filename": "src/test/compile-fail/issue-17718-static-sync.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-sync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-sync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-sync.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::kinds::marker;\n+\n+struct Foo { marker: marker::NoSync }\n+\n+static FOO: uint = 3;\n+static BAR: Foo = Foo { marker: marker::NoSync };\n+//~^ ERROR: shared static items must have a type which implements Sync\n+\n+fn main() {}"}, {"sha": "a181215f4184d799d35b24621fed5969a5a2992e", "filename": "src/test/compile-fail/issue-4968.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-4968.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-4968.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4968.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -10,7 +10,7 @@\n \n // Regression test for issue #4968\n \n-static A: (int,int) = (4,2);\n+const A: (int,int) = (4,2);\n fn main() {\n     match 42 { A => () }\n     //~^ ERROR mismatched types: expected `<generic integer #0>`, found `(int,int)`"}, {"sha": "7f0d9ef3b11ec9018f0a7346af66c4ae5b4474a3", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -13,6 +13,7 @@ use std::cell::RefCell;\n \n // Regresion test for issue 7364\n static boxed: Box<RefCell<int>> = box RefCell::new(0);\n-//~^ ERROR static items are not allowed to have custom pointers\n+//~^ ERROR statics are not allowed to have custom pointers\n+//~^^ ERROR: shared static items must have a type which implements Sync\n \n fn main() { }"}, {"sha": "eb3618c9f04081f3ddf451ff95e5113321a3b5d0", "filename": "src/test/compile-fail/issue-9243.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-9243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fissue-9243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-9243.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -14,7 +14,7 @@ struct Test {\n     mem: int,\n }\n \n-pub static g_test: Test = Test {mem: 0}; //~ ERROR static items are not allowed to have destructors\n+pub static g_test: Test = Test {mem: 0}; //~ ERROR statics are not allowed to have destructors\n \n impl Drop for Test {\n     fn drop(&mut self) {}"}, {"sha": "a4320b8dc77511ae224910eb7dbdb2cc472916a9", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -13,14 +13,12 @@\n #![allow(non_camel_case_types)]\n #![allow(non_uppercase_statics)]\n #![deny(dead_code)]\n-#![feature(lang_items)]\n \n #![crate_type=\"lib\"]\n \n-pub use foo2::Bar2;\n+extern crate core;\n \n-#[lang=\"sized\"]\n-pub trait Sized {}\n+pub use foo2::Bar2;\n \n mod foo {\n     pub struct Bar; //~ ERROR: struct is never used\n@@ -32,10 +30,10 @@ mod foo2 {\n \n pub static pub_static: int = 0;\n static priv_static: int = 0; //~ ERROR: static item is never used\n-static used_static: int = 0;\n+const used_static: int = 0;\n pub static used_static2: int = used_static;\n-static USED_STATIC: int = 0;\n-static STATIC_USED_IN_ENUM_DISCRIMINANT: int = 10;\n+const USED_STATIC: int = 0;\n+const STATIC_USED_IN_ENUM_DISCRIMINANT: int = 10;\n \n pub type typ = *const UsedStruct4;\n pub struct PubStruct;\n@@ -107,7 +105,3 @@ fn bar() { //~ ERROR: function is never used\n #[allow(dead_code)]\n fn g() { h(); }\n fn h() {}\n-\n-// Similarly, lang items are live\n-#[lang=\"fail\"]\n-fn fail(_: *const u8, _: *const u8, _: uint) -> ! { loop {} }"}, {"sha": "cedc0098c00f54c5d0c2ad3667375d428eadd28d", "filename": "src/test/compile-fail/match-arm-statics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fmatch-arm-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fmatch-arm-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-arm-statics.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -17,7 +17,7 @@ enum Direction {\n     West\n }\n \n-static TRUE_TRUE: (bool, bool) = (true, true);\n+const TRUE_TRUE: (bool, bool) = (true, true);\n \n fn nonexhaustive_1() {\n     match (true, false) {\n@@ -39,8 +39,8 @@ fn unreachable_1() {\n     }\n }\n \n-static NONE: Option<Direction> = None;\n-static EAST: Direction = East;\n+const NONE: Option<Direction> = None;\n+const EAST: Direction = East;\n \n fn nonexhaustive_2() {\n     match Some(Some(North)) {\n@@ -66,13 +66,13 @@ fn unreachable_2() {\n     }\n }\n \n-static NEW_FALSE: NewBool = NewBool(false);\n+const NEW_FALSE: NewBool = NewBool(false);\n struct Foo {\n     bar: Option<Direction>,\n     baz: NewBool\n }\n \n-static STATIC_FOO: Foo = Foo { bar: None, baz: NEW_FALSE };\n+const STATIC_FOO: Foo = Foo { bar: None, baz: NEW_FALSE };\n \n fn nonexhaustive_3() {\n     match (Foo { bar: Some(North), baz: NewBool(true) }) {"}, {"sha": "af7938948a70f10c0e83198b3a27893131dacb04", "filename": "src/test/compile-fail/match-static-const-lc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fmatch-static-const-lc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fmatch-static-const-lc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-static-const-lc.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -14,7 +14,7 @@\n #![deny(non_uppercase_statics)]\n \n #[allow(non_uppercase_statics)]\n-pub static a : int = 97;\n+pub const a : int = 97;\n \n fn f() {\n     let r = match (0,0) {\n@@ -27,7 +27,7 @@ fn f() {\n \n mod m {\n     #[allow(non_uppercase_statics)]\n-    pub static aha : int = 7;\n+    pub const aha : int = 7;\n }\n \n fn g() {\n@@ -41,7 +41,7 @@ fn g() {\n }\n \n mod n {\n-    pub static OKAY : int = 8;\n+    pub const OKAY : int = 8;\n }\n \n fn h() {"}, {"sha": "84c72de5548a2eb95eda28e8df3e2237a6b3ae11", "filename": "src/test/compile-fail/static-mut-not-constant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -10,6 +10,7 @@\n \n \n static mut a: Box<int> = box 3;\n-//~^ ERROR mutable static items are not allowed to have owned pointers\n+//~^ ERROR statics are not allowed to have custom pointers\n+//~^^ ERROR mutable statics are not allowed to have owned pointers\n \n fn main() {}"}, {"sha": "b3ffcb0b9896728ba1179959ea08bc568b5c03a0", "filename": "src/test/compile-fail/static-mut-not-pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -20,7 +20,7 @@ fn main() {\n     // instead of spitting out a custom error about some identifier collisions\n     // (we should allow shadowing)\n     match 4i {\n-        a => {} //~ ERROR mutable static variables cannot be referenced in a pattern\n+        a => {} //~ ERROR static variables cannot be referenced in a pattern\n         _ => {}\n     }\n }\n@@ -32,7 +32,7 @@ enum Direction {\n     South,\n     West\n }\n-static NEW_FALSE: NewBool = NewBool(false);\n+const NEW_FALSE: NewBool = NewBool(false);\n struct Foo {\n     bar: Option<Direction>,\n     baz: NewBool\n@@ -44,7 +44,7 @@ fn mutable_statics() {\n     match (Foo { bar: Some(North), baz: NewBool(true) }) {\n         Foo { bar: None, baz: NewBool(true) } => (),\n         STATIC_MUT_FOO => (),\n-        //~^ ERROR mutable static variables cannot be referenced in a pattern\n+        //~^ ERROR static variables cannot be referenced in a pattern\n         Foo { bar: Some(South), .. } => (),\n         Foo { bar: Some(EAST), .. } => (),\n         Foo { bar: Some(North), baz: NewBool(true) } => (),"}, {"sha": "c0122b8a2a97ac8735462d26b3b1b8b801124fe9", "filename": "src/test/compile-fail/std-uncopyable-atomics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -16,11 +16,11 @@ use std::sync::atomic::*;\n use std::ptr;\n \n fn main() {\n-    let x = INIT_ATOMIC_BOOL; //~ ERROR cannot move out of static item\n+    let x = INIT_ATOMIC_BOOL;\n     let x = *&x; //~ ERROR: cannot move out of dereference\n-    let x = INIT_ATOMIC_INT; //~ ERROR cannot move out of static item\n+    let x = INIT_ATOMIC_INT;\n     let x = *&x; //~ ERROR: cannot move out of dereference\n-    let x = INIT_ATOMIC_UINT; //~ ERROR cannot move out of static item\n+    let x = INIT_ATOMIC_UINT;\n     let x = *&x; //~ ERROR: cannot move out of dereference\n     let x: AtomicPtr<uint> = AtomicPtr::new(ptr::null_mut());\n     let x = *&x; //~ ERROR: cannot move out of dereference"}, {"sha": "c5229f0f9f971a84e5811185998a261f5de76a92", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -25,7 +25,7 @@\n pub fn foo(_: [int, ..(3 as uint)]) { }\n \n pub fn bar() {\n-    static FOO: uint = ((5u as uint) - (4u as uint) as uint);\n+    const FOO: uint = ((5u as uint) - (4u as uint) as uint);\n     let _: [(), ..(FOO as uint)] = ([(() as ())] as [(), ..1]);\n \n     let _: [(), ..(1u as uint)] = ([(() as ())] as [(), ..1]);"}, {"sha": "ad0954e6eabc3f777ddca657b98f3031a76d63b4", "filename": "src/test/pretty/issue-4264.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fpretty%2Fissue-4264.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Fpretty%2Fissue-4264.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -17,7 +17,7 @@\n pub fn foo(_: [int, ..3]) {}\n \n pub fn bar() {\n-    static FOO: uint = 5u - 4u;\n+    const FOO: uint = 5u - 4u;\n     let _: [(), ..FOO] = [()];\n \n     let _ : [(), ..1u] = [()];"}, {"sha": "65db841b0c0edb5bbbddd57af531fa12f11772b6", "filename": "src/test/run-make/sepcomp-cci-copies/Makefile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -7,4 +7,3 @@ all:\n \t$(RUSTC) cci_lib.rs\n \t$(RUSTC) foo.rs --emit=ir -C codegen-units=3\n \t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ .*cci_fn)\" -eq \"2\" ]\n-\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c CCI_STATIC.*=.*constant)\" -eq \"2\" ]"}, {"sha": "a7cd85db4a2d116cec2883a41b954428bf50e5fd", "filename": "src/test/run-make/sepcomp-cci-copies/cci_lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2Fcci_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2Fcci_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2Fcci_lib.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -14,6 +14,3 @@\n pub fn cci_fn() -> uint {\n     1234\n }\n-\n-#[inline]\n-pub static CCI_STATIC: uint = 2345;"}, {"sha": "b0642b64cdaac8983e7287d3f9b6ecd465d5d495", "filename": "src/test/run-make/sepcomp-cci-copies/foo.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2Ffoo.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n extern crate cci_lib;\n-use cci_lib::{cci_fn, CCI_STATIC};\n+use cci_lib::{cci_fn};\n \n fn call1() -> uint {\n-    cci_fn() + CCI_STATIC\n+    cci_fn()\n }\n \n mod a {\n@@ -23,9 +23,8 @@ mod a {\n }\n \n mod b {\n-    use cci_lib::CCI_STATIC;\n     pub fn call3() -> uint {\n-        CCI_STATIC\n+        0\n     }\n }\n "}, {"sha": "2ce8c40c77183e847e9d32002c76f093afba0e25", "filename": "src/test/run-pass/bytes-macro-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fbytes-macro-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fbytes-macro-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbytes-macro-static.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -11,7 +11,7 @@\n static FOO: &'static [u8] = bytes!(\"hello, world\");\n \n pub fn main() {\n-    let b = match true {\n+    let b: &'static [u8] = match true {\n         true => bytes!(\"test\"),\n         false => unreachable!()\n     };"}, {"sha": "aaffb013ad8c75c93307d28e22fe34c4e0d1aaf2", "filename": "src/test/run-pass/cast-in-array-size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fcast-in-array-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fcast-in-array-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-in-array-size.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -10,7 +10,7 @@\n \n \n // issues #10618 and #16382\n-static SIZE: int = 25;\n+const SIZE: int = 25;\n \n fn main() {\n     let _a: [bool, ..1 as uint];"}, {"sha": "60daedec4c79fe5199ad7b2237a2e958936d82b3", "filename": "src/test/run-pass/check-static-slice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -11,12 +11,12 @@\n // Check that the various ways of getting to a reference to a vec (both sized\n // and unsized) work properly.\n \n-static aa: [int, ..3] = [1, 2, 3];\n-static ab: &'static [int, ..3] = &aa;\n-static ac: &'static [int] = ab;\n-static ad: &'static [int] = &aa;\n-static ae: &'static [int, ..3] = &[1, 2, 3];\n-static af: &'static [int] = &[1, 2, 3];\n+const aa: [int, ..3] = [1, 2, 3];\n+const ab: &'static [int, ..3] = &aa;\n+const ac: &'static [int] = ab;\n+const ad: &'static [int] = &aa;\n+const ae: &'static [int, ..3] = &[1, 2, 3];\n+const af: &'static [int] = &[1, 2, 3];\n \n static ca: int = aa[0];\n static cb: int = ab[1];"}, {"sha": "5d8e31f93441109e13d4e12f36bbe88c5714735b", "filename": "src/test/run-pass/const-cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cast.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -12,9 +12,9 @@ extern crate libc;\n \n extern fn foo() {}\n \n-static x: extern \"C\" fn() = foo;\n+const x: extern \"C\" fn() = foo;\n static y: *const libc::c_void = x as *const libc::c_void;\n-static a: &'static int = &10;\n+const a: &'static int = &10;\n static b: *const int = a as *const int;\n \n pub fn main() {"}, {"sha": "ba2947f73679028fc9eac4af5cfb3b0d27491df7", "filename": "src/test/run-pass/const-const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-const.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static a: int = 1;\n-static b: int = a + 2;\n+const a: int = 1;\n+const b: int = a + 2;\n \n pub fn main() {\n     assert_eq!(b, 3);"}, {"sha": "480fb50a1ffe5170d19f29e5e724f90c82c68c78", "filename": "src/test/run-pass/const-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-deref.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static C: &'static int = &1000;\n+const C: &'static int = &1000;\n static D: int = *C;\n \n pub fn main() {"}, {"sha": "2a00daa3c038c53ce173f07c5fbaf681f9e524b9", "filename": "src/test/run-pass/const-enum-vec-index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n enum E { V1(int), V0 }\n-static C: &'static [E] = &[V0, V1(0xDEADBEE)];\n+const C: &'static [E] = &[V0, V1(0xDEADBEE)];\n static C0: E = C[0];\n static C1: E = C[1];\n-static D: &'static [E, ..2] = &[V0, V1(0xDEADBEE)];\n+const D: &'static [E, ..2] = &[V0, V1(0xDEADBEE)];\n static D0: E = C[0];\n static D1: E = C[1];\n "}, {"sha": "317a54e927f31fb40ebbabc75f7f9a0fad49f240", "filename": "src/test/run-pass/const-expr-in-fixed-length-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-expr-in-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-expr-in-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-expr-in-fixed-length-vec.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -13,7 +13,7 @@\n \n pub fn main() {\n \n-    static FOO: uint = 2;\n+    const FOO: uint = 2;\n     let _v: [int, ..FOO*3];\n \n }"}, {"sha": "54386b33dd9dad8b9c89f622da1ef8eac0a2a2f5", "filename": "src/test/run-pass/const-expr-in-vec-repeat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-expr-in-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-expr-in-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-expr-in-vec-repeat.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -12,7 +12,7 @@\n \n pub fn main() {\n \n-    static FOO: uint = 2;\n+    const FOO: uint = 2;\n     let _v = [0i, ..FOO*3*2/2];\n \n }"}, {"sha": "fc098ff93574b3d62192a35153a166c824c1f414", "filename": "src/test/run-pass/const-fields-and-indexing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -10,20 +10,20 @@\n \n extern crate debug;\n \n-static x : [int, ..4] = [1,2,3,4];\n+const x : [int, ..4] = [1,2,3,4];\n static p : int = x[2];\n-static y : &'static [int] = &[1,2,3,4];\n+const y : &'static [int] = &[1,2,3,4];\n static q : int = y[2];\n \n struct S {a: int, b: int}\n \n-static s : S = S {a: 10, b: 20};\n+const s : S = S {a: 10, b: 20};\n static t : int = s.b;\n \n struct K {a: int, b: int, c: D}\n struct D { d: int, e: int }\n \n-static k : K = K {a: 10, b: 20, c: D {d: 30, e: 40}};\n+const k : K = K {a: 10, b: 20, c: D {d: 30, e: 40}};\n static m : int = k.c.e;\n \n pub fn main() {"}, {"sha": "5e417efb4b5838ef2f1ca0ab37ae82e936dc3226", "filename": "src/test/run-pass/const-region-ptrs-noncopy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -10,8 +10,8 @@\n \n type Big = [u64, ..8];\n struct Pair<'a> { a: int, b: &'a Big }\n-static x: &'static Big = &([13, 14, 10, 13, 11, 14, 14, 15]);\n-static y: &'static Pair<'static> = &Pair {a: 15, b: x};\n+const x: &'static Big = &([13, 14, 10, 13, 11, 14, 14, 15]);\n+const y: &'static Pair<'static> = &Pair {a: 15, b: x};\n \n pub fn main() {\n     assert_eq!(x as *const Big, y.b as *const Big);"}, {"sha": "e5d3f0ece0cf5b94a254c8c88363a63ebe345a2f", "filename": "src/test/run-pass/const-region-ptrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -10,9 +10,9 @@\n \n struct Pair<'a> { a: int, b: &'a int }\n \n-static x: &'static int = &10;\n+const x: &'static int = &10;\n \n-static y: &'static Pair<'static> = &Pair {a: 15, b: x};\n+const y: &'static Pair<'static> = &Pair {a: 15, b: x};\n \n pub fn main() {\n     println!(\"x = {}\", *x);"}, {"sha": "7395a997a05c5e27646cb4fc23fd8fab0ce8290a", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -10,9 +10,9 @@\n \n use std::{str, string};\n \n-static A: [u8, ..2] = ['h' as u8, 'i' as u8];\n-static B: &'static [u8, ..2] = &A;\n-static C: *const u8 = B as *const u8;\n+const A: [u8, ..2] = ['h' as u8, 'i' as u8];\n+const B: &'static [u8, ..2] = &A;\n+const C: *const u8 = B as *const u8;\n \n pub fn main() {\n     unsafe {"}, {"sha": "f2db119156960d4ba3b663f07c8f71143fed0ac0", "filename": "src/test/run-pass/const-struct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-struct.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -22,10 +22,10 @@ impl cmp::PartialEq for foo {\n     fn ne(&self, other: &foo) -> bool { !(*self).eq(other) }\n }\n \n-static x : foo = foo { a:1, b:2, c: 3 };\n-static y : foo = foo { b:2, c:3, a: 1 };\n-static z : &'static foo = &foo { a: 10, b: 22, c: 12 };\n-static w : foo = foo { a:5, ..x };\n+const x : foo = foo { a:1, b:2, c: 3 };\n+const y : foo = foo { b:2, c:3, a: 1 };\n+const z : &'static foo = &foo { a: 10, b: 22, c: 12 };\n+const w : foo = foo { a:5, ..x };\n \n pub fn main() {\n     assert_eq!(x.b, 2);"}, {"sha": "87b7fcad38522462531b21c8058bd05d6bad57d7", "filename": "src/test/run-pass/consts-in-patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconsts-in-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fconsts-in-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts-in-patterns.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static FOO: int = 10;\n-static BAR: int = 3;\n+const FOO: int = 10;\n+const BAR: int = 3;\n \n pub fn main() {\n     let x: int = 3i;"}, {"sha": "d51562d2490deeb914993944101cbef65a61c206", "filename": "src/test/run-pass/enum-vec-initializer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fenum-vec-initializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fenum-vec-initializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-vec-initializer.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -12,13 +12,13 @@ enum Flopsy {\n     Bunny = 2\n }\n \n-static BAR:uint = Bunny as uint;\n-static BAR2:uint = BAR;\n+const BAR:uint = Bunny as uint;\n+const BAR2:uint = BAR;\n \n pub fn main() {\n     let _v = [0i, .. Bunny as uint];\n     let _v = [0i, .. BAR];\n     let _v = [0i, .. BAR2];\n-    static BAR3:uint = BAR2;\n+    const BAR3:uint = BAR2;\n     let _v = [0i, .. BAR3];\n }"}, {"sha": "1540679b099b43b45f8fcaeb302ceefb1385fc2d", "filename": "src/test/run-pass/issue-11940.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-11940.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-11940.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11940.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static TEST_STR: &'static str = \"abcd\";\n+const TEST_STR: &'static str = \"abcd\";\n \n fn main() {\n     let s = \"abcd\";"}, {"sha": "8b2b732415ee0b9f6e2d9c7b09eec2f39da1ea3f", "filename": "src/test/run-pass/issue-13763.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-13763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-13763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13763.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -10,7 +10,7 @@\n \n use std::u8;\n \n-static NUM: uint = u8::BITS as uint;\n+const NUM: uint = u8::BITS as uint;\n \n struct MyStruct { nums: [uint, ..8] }\n "}, {"sha": "d35c3a587c5a5efde128d301bc1ebc035dda7555", "filename": "src/test/run-pass/issue-17074.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-17074.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-17074.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17074.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static X: u64 = -1 as u16 as u64;\n-static Y: u64 = -1 as u32 as u64;\n+static X2: u64 = -1 as u16 as u64;\n+static Y2: u64 = -1 as u32 as u64;\n+const X: u64 = -1 as u16 as u64;\n+const Y: u64 = -1 as u32 as u64;\n \n fn main() {\n     assert_eq!(match 1 {"}, {"sha": "8f76d95c54815bb622aa6555179df32f7aef7b1f", "filename": "src/test/run-pass/issue-17718-static-unsafe-interior.rs", "status": "renamed", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Verify that it is not possible to take the address of\n-// static items with unsafe interior.\n-\n use std::kinds::marker;\n use std::cell::UnsafeCell;\n \n@@ -30,25 +27,22 @@ enum UnsafeEnum<T> {\n static STATIC1: UnsafeEnum<int> = VariantSafe;\n \n static STATIC2: UnsafeCell<int> = UnsafeCell { value: 1 };\n-static STATIC3: MyUnsafe<int> = MyUnsafe{value: STATIC2};\n+const CONST: UnsafeCell<int> = UnsafeCell { value: 1 };\n+static STATIC3: MyUnsafe<int> = MyUnsafe{value: CONST};\n \n static STATIC4: &'static UnsafeCell<int> = &STATIC2;\n-//~^ ERROR borrow of immutable static items with unsafe interior is not allowed\n \n struct Wrap<T> {\n     value: T\n }\n \n static UNSAFE: UnsafeCell<int> = UnsafeCell{value: 1};\n static WRAPPED_UNSAFE: Wrap<&'static UnsafeCell<int>> = Wrap { value: &UNSAFE };\n-//~^ ERROR borrow of immutable static items with unsafe interior is not allowed\n \n fn main() {\n     let a = &STATIC1;\n-    //~^ ERROR borrow of immutable static items with unsafe interior is not allowed\n \n     STATIC3.forbidden()\n-    //~^ ERROR borrow of immutable static items with unsafe interior is not allowed\n }\n \n ", "previous_filename": "src/test/compile-fail/borrowck-forbid-static-unsafe-interior.rs"}, {"sha": "90a102222ba172c31662dc976feaa36f55aee2bb", "filename": "src/test/run-pass/issue-17718.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-17718.rs\n+\n+extern crate \"issue-17718\" as other;\n+\n+use std::sync::atomic;\n+\n+const C1: uint = 1;\n+const C2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+const C3: fn() = foo;\n+const C4: uint = C1 * C1 + C1 / C1;\n+const C5: &'static uint = &C4;\n+const C6: uint = {\n+    const C: uint = 3;\n+    C\n+};\n+\n+static S1: uint = 3;\n+static S2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+\n+mod test {\n+    static A: uint = 4;\n+    static B: &'static uint = &A;\n+    static C: &'static uint = &(A);\n+}\n+\n+fn foo() {}\n+\n+fn main() {\n+    assert_eq!(C1, 1);\n+    assert_eq!(C3(), ());\n+    assert_eq!(C2.fetch_add(1, atomic::SeqCst), 0);\n+    assert_eq!(C2.fetch_add(1, atomic::SeqCst), 0);\n+    assert_eq!(C4, 2);\n+    assert_eq!(*C5, 2);\n+    assert_eq!(C6, 3);\n+    assert_eq!(S1, 3);\n+    assert_eq!(S2.fetch_add(1, atomic::SeqCst), 0);\n+    assert_eq!(S2.fetch_add(1, atomic::SeqCst), 1);\n+\n+    match 1 {\n+        C1 => {}\n+        _ => unreachable!(),\n+    }\n+\n+    let _a = C1;\n+    let _a = C2;\n+    let _a = C3;\n+    let _a = C4;\n+    let _a = C5;\n+    let _a = C6;\n+    let _a = S1;\n+\n+    assert_eq!(other::C1, 1);\n+    assert_eq!(other::C3(), ());\n+    assert_eq!(other::C2.fetch_add(1, atomic::SeqCst), 0);\n+    assert_eq!(other::C2.fetch_add(1, atomic::SeqCst), 0);\n+    assert_eq!(other::C4, 2);\n+    assert_eq!(*other::C5, 2);\n+    assert_eq!(other::S1, 3);\n+    assert_eq!(other::S2.fetch_add(1, atomic::SeqCst), 0);\n+    assert_eq!(other::S2.fetch_add(1, atomic::SeqCst), 1);\n+\n+    let _a = other::C1;\n+    let _a = other::C2;\n+    let _a = other::C3;\n+    let _a = other::C4;\n+    let _a = other::C5;\n+\n+    match 1 {\n+        other::C1 => {}\n+        _ => unreachable!(),\n+    }\n+}"}, {"sha": "b2ebbf3b148cf79bfef11621af50039104824e12", "filename": "src/test/run-pass/issue-2428.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-2428.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-2428.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2428.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     let _foo = 100i;\n-    static quux: int = 5;\n+    const quux: int = 5;\n \n     enum Stuff {\n         Bar = quux"}, {"sha": "1f6493d961c5a847fd4578326f671b7ba7b8f615", "filename": "src/test/run-pass/issue-5353.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-5353.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-5353.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5353.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static INVALID_ENUM : u32 = 0;\n-static INVALID_VALUE : u32 = 1;\n+const INVALID_ENUM : u32 = 0;\n+const INVALID_VALUE : u32 = 1;\n \n fn gl_err_str(err: u32) -> String\n {"}, {"sha": "65ea895c2c85fb88cc22d3b6bb60fc3f401cf267", "filename": "src/test/run-pass/issue-7222.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-7222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-7222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7222.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    static FOO: f64 = 10.0;\n+    const FOO: f64 = 10.0;\n \n     match 0.0 {\n         0.0 ... FOO => (),"}, {"sha": "b9410ffdb43ec7f63724a71307b7d6a4814ed47c", "filename": "src/test/run-pass/issue-9942.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-9942.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fissue-9942.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9942.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n pub fn main() {\n-    static S: uint = 23 as uint; [0i, ..S]; ()\n+    const S: uint = 23 as uint; [0i, ..S]; ()\n }"}, {"sha": "29972c0efd0dba0e1005683cc54e50625221445d", "filename": "src/test/run-pass/match-arm-statics.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -29,19 +29,19 @@ enum EnumWithStructVariants {\n     }\n }\n \n-static TRUE_TRUE: (bool, bool) = (true, true);\n-static NONE: Option<Direction> = None;\n-static EAST: Direction = East;\n-static NEW_FALSE: NewBool = NewBool(false);\n-static STATIC_FOO: Foo = Foo { bar: Some(South), baz: NEW_FALSE };\n-static VARIANT2_NORTH: EnumWithStructVariants = Variant2 { dir: North };\n+const TRUE_TRUE: (bool, bool) = (true, true);\n+const NONE: Option<Direction> = None;\n+const EAST: Direction = East;\n+const NEW_FALSE: NewBool = NewBool(false);\n+const STATIC_FOO: Foo = Foo { bar: Some(South), baz: NEW_FALSE };\n+const VARIANT2_NORTH: EnumWithStructVariants = Variant2 { dir: North };\n \n pub mod glfw {\n     pub struct InputState(uint);\n \n-    pub static RELEASE  : InputState = InputState(0);\n-    pub static PRESS    : InputState = InputState(1);\n-    pub static REPEAT   : InputState = InputState(2);\n+    pub const RELEASE  : InputState = InputState(0);\n+    pub const PRESS    : InputState = InputState(1);\n+    pub const REPEAT   : InputState = InputState(2);\n }\n \n fn issue_6533() {\n@@ -63,7 +63,7 @@ fn issue_6533() {\n }\n \n fn issue_13626() {\n-    static VAL: [u8, ..1] = [0];\n+    const VAL: [u8, ..1] = [0];\n     match [1] {\n         VAL => unreachable!(),\n         _ => ()\n@@ -72,8 +72,8 @@ fn issue_13626() {\n \n fn issue_14576() {\n     type Foo = (i32, i32);\n-    static ON: Foo = (1, 1);\n-    static OFF: Foo = (0, 0);\n+    const ON: Foo = (1, 1);\n+    const OFF: Foo = (0, 0);\n \n     match (1, 1) {\n         OFF => unreachable!(),\n@@ -82,14 +82,14 @@ fn issue_14576() {\n     }\n \n     enum C { D = 3, E = 4 }\n-    static F : C = D;\n+    const F : C = D;\n \n     assert_eq!(match D { F => 1i, _ => 2, }, 1);\n }\n \n fn issue_13731() {\n     enum A { AA(()) }\n-    static B: A = AA(());\n+    const B: A = AA(());\n \n     match AA(()) {\n         B => ()\n@@ -102,8 +102,8 @@ fn issue_15393() {\n         bits: uint\n     }\n \n-    static FOO: Flags = Flags { bits: 0x01 };\n-    static BAR: Flags = Flags { bits: 0x02 };\n+    const FOO: Flags = Flags { bits: 0x01 };\n+    const BAR: Flags = Flags { bits: 0x02 };\n     match (Flags { bits: 0x02 }) {\n         FOO => unreachable!(),\n         BAR => (),"}, {"sha": "0feeea70221a4aa3dd445f99bd745752cf2fcbd6", "filename": "src/test/run-pass/match-range-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fmatch-range-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fmatch-range-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-range-static.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static s: int = 1;\n-static e: int = 42;\n+const s: int = 1;\n+const e: int = 42;\n \n pub fn main() {\n     match 7 {"}, {"sha": "f3fe93650af5ef98ffb944e115ab2fd6937b292a", "filename": "src/test/run-pass/match-static-const-rename.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fmatch-static-const-rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fmatch-static-const-rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-static-const-rename.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -18,7 +18,7 @@\n \n #![deny(non_uppercase_statics)]\n \n-pub static A : int = 97;\n+pub const A : int = 97;\n \n fn f() {\n     let r = match (0,0) {\n@@ -35,7 +35,7 @@ fn f() {\n \n mod m {\n     #[allow(non_uppercase_statics)]\n-    pub static aha : int = 7;\n+    pub const aha : int = 7;\n }\n \n fn g() {"}, {"sha": "8aa12aa3e98ad9973e983ed71b6617f842335351", "filename": "src/test/run-pass/resolve-issue-2428.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fresolve-issue-2428.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fresolve-issue-2428.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresolve-issue-2428.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static foo: int = 4 >> 1;\n+const foo: int = 4 >> 1;\n enum bs { thing = foo }\n pub fn main() { assert!((thing as int == foo)); }"}, {"sha": "26a5c4d1c5026cb6b9dd4d0c8e634dfb813be9e8", "filename": "src/test/run-pass/sepcomp-statics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fsepcomp-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fsepcomp-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-statics.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -14,7 +14,7 @@\n \n fn pad() -> uint { 0 }\n \n-static ONE: uint = 1;\n+const ONE: uint = 1;\n \n mod b {\n     // Separate compilation always switches to the LLVM module with the fewest\n@@ -28,7 +28,7 @@ mod b {\n mod a {\n     fn pad() -> uint { 0 }\n \n-    pub static TWO: uint = ::ONE + ::ONE;\n+    pub const TWO: uint = ::ONE + ::ONE;\n }\n \n fn main() {"}, {"sha": "1f92677fb6f895e61de0f9478b82a1d78397f613", "filename": "src/test/run-pass/syntax-extension-bytes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fsyntax-extension-bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fsyntax-extension-bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-bytes.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -11,15 +11,15 @@\n static static_vec: &'static [u8] = bytes!(\"abc\", 0xFF, '!');\n \n pub fn main() {\n-    let vec = bytes!(\"abc\");\n+    let vec: &'static [u8] = bytes!(\"abc\");\n     let expected: &[u8] = &[97_u8, 98_u8, 99_u8];\n     assert_eq!(vec, expected);\n \n-    let vec = bytes!(\"null\", 0);\n+    let vec: &'static [u8] = bytes!(\"null\", 0);\n     let expected: &[u8] = &[110_u8, 117_u8, 108_u8, 108_u8, 0_u8];\n     assert_eq!(vec, expected);\n \n-    let vec = bytes!(' ', \" \", 32, 32u8);\n+    let vec: &'static [u8] = bytes!(' ', \" \", 32, 32u8);\n     let expected: &[u8] = &[32_u8, 32_u8, 32_u8, 32_u8];\n     assert_eq!(vec, expected);\n "}, {"sha": "a8ab0e48ccf8a2776c4e9ec324145cf19e748478", "filename": "src/test/run-pass/vector-sort-failure-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -11,7 +11,7 @@\n use std::task;\n use std::rand::{task_rng, Rng};\n \n-static MAX_LEN: uint = 20;\n+const MAX_LEN: uint = 20;\n static mut drop_counts: [uint, .. MAX_LEN] = [0, .. MAX_LEN];\n static mut clone_count: uint = 0;\n "}, {"sha": "7eb73968db5ef9e96e8302b3b4208433789d981d", "filename": "src/test/run-pass/xcrate-unit-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fc49c06e5c71a8d63d6120e1a92b6445fb501d/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs?ref=f9fc49c06e5c71a8d63d6120e1a92b6445fb501d", "patch": "@@ -11,7 +11,7 @@\n // aux-build:xcrate_unit_struct.rs\n extern crate xcrate_unit_struct;\n \n-static s1: xcrate_unit_struct::Struct = xcrate_unit_struct::Struct;\n+const s1: xcrate_unit_struct::Struct = xcrate_unit_struct::Struct;\n static s2: xcrate_unit_struct::Unit = xcrate_unit_struct::UnitVariant;\n static s3: xcrate_unit_struct::Unit =\n                 xcrate_unit_struct::Argument(xcrate_unit_struct::Struct);"}]}