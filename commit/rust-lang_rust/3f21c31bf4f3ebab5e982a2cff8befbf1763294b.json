{"sha": "3f21c31bf4f3ebab5e982a2cff8befbf1763294b", "node_id": "C_kwDOAAsO6NoAKDNmMjFjMzFiZjRmM2ViYWI1ZTk4MmEyY2ZmOGJlZmJmMTc2MzI5NGI", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-05-21T12:35:07Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-05-21T12:38:23Z"}, "message": "rustdoc: Some link resolution caching cleanup", "tree": {"sha": "9a05cc81f138aee0d3513fbb4f6ab7d7a6fbe9bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a05cc81f138aee0d3513fbb4f6ab7d7a6fbe9bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f21c31bf4f3ebab5e982a2cff8befbf1763294b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f21c31bf4f3ebab5e982a2cff8befbf1763294b", "html_url": "https://github.com/rust-lang/rust/commit/3f21c31bf4f3ebab5e982a2cff8befbf1763294b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f21c31bf4f3ebab5e982a2cff8befbf1763294b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5449f57c190c2bbe29d6a4c7f0ced7049a46b6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5449f57c190c2bbe29d6a4c7f0ced7049a46b6f", "html_url": "https://github.com/rust-lang/rust/commit/c5449f57c190c2bbe29d6a4c7f0ced7049a46b6f"}], "stats": {"total": 51, "additions": 16, "deletions": 35}, "files": [{"sha": "ffc765f4040d482c4d374b1ecd06ede7a7c4e50f", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 16, "deletions": 35, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3f21c31bf4f3ebab5e982a2cff8befbf1763294b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f21c31bf4f3ebab5e982a2cff8befbf1763294b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3f21c31bf4f3ebab5e982a2cff8befbf1763294b", "patch": "@@ -277,11 +277,6 @@ struct DiagnosticInfo<'a> {\n     link_range: Range<usize>,\n }\n \n-#[derive(Clone, Debug, Hash)]\n-struct CachedLink {\n-    res: (Res, Option<UrlFragment>),\n-}\n-\n struct LinkCollector<'a, 'tcx> {\n     cx: &'a mut DocContext<'tcx>,\n     /// A stack of modules used to decide what scope to resolve in.\n@@ -291,7 +286,7 @@ struct LinkCollector<'a, 'tcx> {\n     mod_ids: Vec<DefId>,\n     /// Cache the resolved links so we can avoid resolving (and emitting errors for) the same link.\n     /// The link will be `None` if it could not be resolved (i.e. the error was cached).\n-    visited_links: FxHashMap<ResolutionInfo, Option<CachedLink>>,\n+    visited_links: FxHashMap<ResolutionInfo, Option<(Res, Option<UrlFragment>)>>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n@@ -1060,6 +1055,9 @@ impl LinkCollector<'_, '_> {\n                 extra_fragment: extra_fragment.clone(),\n             },\n             diag_info.clone(), // this struct should really be Copy, but Range is not :(\n+            // For reference-style links we want to report only one error so unsuccessful\n+            // resolutions are cached, for other links we want to report an error every\n+            // time so they are not cached.\n             matches!(ori_link.kind, LinkType::Reference | LinkType::Shortcut),\n         )?;\n \n@@ -1256,26 +1254,20 @@ impl LinkCollector<'_, '_> {\n         &mut self,\n         key: ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n-        cache_resolution_failure: bool,\n+        // If errors are cached then they are only reported on first ocurrence\n+        // which we want in some cases but not in others.\n+        cache_errors: bool,\n     ) -> Option<(Res, Option<UrlFragment>)> {\n-        if let Some(ref cached) = self.visited_links.get(&key) {\n-            match cached {\n-                Some(cached) => {\n-                    return Some(cached.res.clone());\n-                }\n-                None if cache_resolution_failure => return None,\n-                None => {\n-                    // Although we hit the cache and found a resolution error, this link isn't\n-                    // supposed to cache those. Run link resolution again to emit the expected\n-                    // resolution error.\n-                }\n+        if let Some(res) = self.visited_links.get(&key) {\n+            if res.is_some() || cache_errors {\n+                return res.clone();\n             }\n         }\n \n         let res = self.resolve_with_disambiguator(&key, diag.clone()).and_then(|(res, def_id)| {\n             let fragment = match (&key.extra_fragment, def_id) {\n                 (Some(_), Some(def_id)) => {\n-                    report_anchor_conflict(self.cx, diag, Res::from_def_id(self.cx.tcx, def_id));\n+                    report_anchor_conflict(self.cx, diag, def_id);\n                     return None;\n                 }\n                 (Some(u_frag), None) => Some(UrlFragment::UserWritten(u_frag.clone())),\n@@ -1285,21 +1277,10 @@ impl LinkCollector<'_, '_> {\n             Some((res, fragment))\n         });\n \n-        // Cache only if resolved successfully - don't silence duplicate errors\n-        if let Some(res) = res {\n-            // Store result for the actual namespace\n-            self.visited_links.insert(key, Some(CachedLink { res: res.clone() }));\n-\n-            Some(res)\n-        } else {\n-            if cache_resolution_failure {\n-                // For reference-style links we only want to report one resolution error\n-                // so let's cache them as well.\n-                self.visited_links.insert(key, None);\n-            }\n-\n-            None\n+        if res.is_some() || cache_errors {\n+            self.visited_links.insert(key, res.clone());\n         }\n+        res\n     }\n \n     /// After parsing the disambiguator, resolve the main part of the link.\n@@ -1875,8 +1856,8 @@ fn report_multiple_anchors(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>) {\n     anchor_failure(cx, diag_info, &msg, 1)\n }\n \n-fn report_anchor_conflict(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, res: Res) {\n-    let (link, kind) = (diag_info.ori_link, res.descr());\n+fn report_anchor_conflict(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, def_id: DefId) {\n+    let (link, kind) = (diag_info.ori_link, Res::from_def_id(cx.tcx, def_id).descr());\n     let msg = format!(\"`{link}` contains an anchor, but links to {kind}s are already anchored\");\n     anchor_failure(cx, diag_info, &msg, 0)\n }"}]}