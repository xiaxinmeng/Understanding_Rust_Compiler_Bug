{"sha": "cb1c06fdd8921071a353b70d4752d834a76c5f94", "node_id": "C_kwDOAAsO6NoAKGNiMWMwNmZkZDg5MjEwNzFhMzUzYjcwZDQ3NTJkODM0YTc2YzVmOTQ", "commit": {"author": {"name": "Takashi Idobe", "email": "idobetakashi@gmail.com", "date": "2021-09-24T13:31:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-24T13:31:03Z"}, "message": "Merge branch 'rust-lang:master' into master", "tree": {"sha": "d4606b4bee7f5dd22f5a0122fa5796961b815a60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4606b4bee7f5dd22f5a0122fa5796961b815a60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb1c06fdd8921071a353b70d4752d834a76c5f94", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhTdMXCRBK7hj4Ov3rIwAA7E0IAJp0L+tT+e9Ntn4f4TxFEg3K\ndfgstcZgoDTRL8kE2VaIGXS+rarXRNu+rsfkk2XNi3ZrZ0GFURKB4J1GFuJfV8uw\nbNyCs+zvKyOkeL3tJbfrRZJulIgZQTvoGNLSJVzanSdWS4S3STRY5S2lm1Ok2MHJ\ncqAbqxHGupgafM2ylN1+AaLOlmBigE0TZRVt7LgW+VDwNtz+gv3RFXMyx9S07FQz\nGGKI7FY9k/6PldDmBt/CakIJyZr6cfn+OX3BLAfRV/Orh47TwG4o5djsMzsSfFpX\nYB0DrpRwsX8NbzAY2h8GGf2xwVucWViINZHhra8RQxdd6kZIQqxVC/S45tLAG24=\n=oMxe\n-----END PGP SIGNATURE-----\n", "payload": "tree d4606b4bee7f5dd22f5a0122fa5796961b815a60\nparent b146525140a8776aec1f7852643ec2abd787a197\nparent 91d8da1f4ba24679e92b7939a26c681a5d2d3548\nauthor Takashi Idobe <idobetakashi@gmail.com> 1632490263 -0500\ncommitter GitHub <noreply@github.com> 1632490263 -0500\n\nMerge branch 'rust-lang:master' into master\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb1c06fdd8921071a353b70d4752d834a76c5f94", "html_url": "https://github.com/rust-lang/rust/commit/cb1c06fdd8921071a353b70d4752d834a76c5f94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb1c06fdd8921071a353b70d4752d834a76c5f94/comments", "author": {"login": "Takashiidobe", "id": 26013562, "node_id": "MDQ6VXNlcjI2MDEzNTYy", "avatar_url": "https://avatars.githubusercontent.com/u/26013562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Takashiidobe", "html_url": "https://github.com/Takashiidobe", "followers_url": "https://api.github.com/users/Takashiidobe/followers", "following_url": "https://api.github.com/users/Takashiidobe/following{/other_user}", "gists_url": "https://api.github.com/users/Takashiidobe/gists{/gist_id}", "starred_url": "https://api.github.com/users/Takashiidobe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Takashiidobe/subscriptions", "organizations_url": "https://api.github.com/users/Takashiidobe/orgs", "repos_url": "https://api.github.com/users/Takashiidobe/repos", "events_url": "https://api.github.com/users/Takashiidobe/events{/privacy}", "received_events_url": "https://api.github.com/users/Takashiidobe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b146525140a8776aec1f7852643ec2abd787a197", "url": "https://api.github.com/repos/rust-lang/rust/commits/b146525140a8776aec1f7852643ec2abd787a197", "html_url": "https://github.com/rust-lang/rust/commit/b146525140a8776aec1f7852643ec2abd787a197"}, {"sha": "91d8da1f4ba24679e92b7939a26c681a5d2d3548", "url": "https://api.github.com/repos/rust-lang/rust/commits/91d8da1f4ba24679e92b7939a26c681a5d2d3548", "html_url": "https://github.com/rust-lang/rust/commit/91d8da1f4ba24679e92b7939a26c681a5d2d3548"}], "stats": {"total": 1192, "additions": 934, "deletions": 258}, "files": [{"sha": "9e03fc33ae0f18fbf606920ea6c7585209519236", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -4,7 +4,7 @@ use crate::type_::Type;\n use rustc_codegen_ssa::traits::*;\n use rustc_middle::bug;\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Ty, TypeFoldable};\n use rustc_target::abi::{Abi, AddressSpace, Align, FieldsShape};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n@@ -43,7 +43,8 @@ fn uncached_llvm_type<'a, 'tcx>(\n         // in problematically distinct types due to HRTB and subtyping (see #47638).\n         // ty::Dynamic(..) |\n         ty::Adt(..) | ty::Closure(..) | ty::Foreign(..) | ty::Generator(..) | ty::Str => {\n-            let mut name = with_no_trimmed_paths(|| layout.ty.to_string());\n+            let mut name =\n+                with_no_visible_paths(|| with_no_trimmed_paths(|| layout.ty.to_string()));\n             if let (&ty::Adt(def, _), &Variants::Single { index }) =\n                 (layout.ty.kind(), &layout.variants)\n             {"}, {"sha": "b0a5631549df85af3bd872d04f00fd6bac9a84b7", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -15,7 +15,7 @@ use rustc_index::vec::Idx;\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::{self, SwitchTargets};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n@@ -476,15 +476,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 UninitValid => !layout.might_permit_raw_init(bx, /*zero:*/ false),\n             };\n             if do_panic {\n-                let msg_str = with_no_trimmed_paths(|| {\n-                    if layout.abi.is_uninhabited() {\n-                        // Use this error even for the other intrinsics as it is more precise.\n-                        format!(\"attempted to instantiate uninhabited type `{}`\", ty)\n-                    } else if intrinsic == ZeroValid {\n-                        format!(\"attempted to zero-initialize type `{}`, which is invalid\", ty)\n-                    } else {\n-                        format!(\"attempted to leave type `{}` uninitialized, which is invalid\", ty)\n-                    }\n+                let msg_str = with_no_visible_paths(|| {\n+                    with_no_trimmed_paths(|| {\n+                        if layout.abi.is_uninhabited() {\n+                            // Use this error even for the other intrinsics as it is more precise.\n+                            format!(\"attempted to instantiate uninhabited type `{}`\", ty)\n+                        } else if intrinsic == ZeroValid {\n+                            format!(\"attempted to zero-initialize type `{}`, which is invalid\", ty)\n+                        } else {\n+                            format!(\n+                                \"attempted to leave type `{}` uninitialized, which is invalid\",\n+                                ty\n+                            )\n+                        }\n+                    })\n                 });\n                 let msg = bx.const_str(Symbol::intern(&msg_str));\n                 let location = self.get_caller_location(bx, source_info).immediate();"}, {"sha": "8dd7e6af257fc53f1bf74d3ae4328f401af4d552", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -22,14 +22,14 @@\n // is also useful to track which value is the \"expected\" value in\n // terms of error reporting.\n \n+use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n use super::unify_key::replace_if_possible;\n use super::unify_key::{ConstVarValue, ConstVariableValue};\n use super::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use super::{equate::Equate, type_variable::Diverging};\n use super::{InferCtxt, MiscVariable, TypeTrace};\n \n use crate::traits::{Obligation, PredicateObligations};\n@@ -645,7 +645,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                                 .inner\n                                 .borrow_mut()\n                                 .type_variables()\n-                                .new_var(self.for_universe, Diverging::NotDiverging, origin);\n+                                .new_var(self.for_universe, origin);\n                             let u = self.tcx().mk_ty_var(new_var_id);\n \n                             // Record that we replaced `vid` with `new_var_id` as part of a generalization\n@@ -885,11 +885,12 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n \n                         let origin =\n                             *self.infcx.inner.borrow_mut().type_variables().var_origin(vid);\n-                        let new_var_id = self.infcx.inner.borrow_mut().type_variables().new_var(\n-                            self.for_universe,\n-                            Diverging::NotDiverging,\n-                            origin,\n-                        );\n+                        let new_var_id = self\n+                            .infcx\n+                            .inner\n+                            .borrow_mut()\n+                            .type_variables()\n+                            .new_var(self.for_universe, origin);\n                         let u = self.tcx().mk_ty_var(new_var_id);\n                         debug!(\n                             \"ConstInferUnifier: replacing original vid={:?} with new={:?}\","}, {"sha": "d9b7022f03ac1a9ac2e74e61e87f1b22b2556963", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -7,7 +7,7 @@\n //! inference graph arose so that we can explain to the user what gave\n //! rise to a particular error.\n //!\n-//! The basis of the system are the \"origin\" types. An \"origin\" is the\n+//! The system is based around a set of \"origin\" types. An \"origin\" is the\n //! reason that a constraint or inference variable arose. There are\n //! different \"origin\" enums for different kinds of constraints/variables\n //! (e.g., `TypeOrigin`, `RegionVariableOrigin`). An origin always has"}, {"sha": "632e792bbd1acadccd66b06465116facb2ee18a1", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -46,7 +46,7 @@ use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, Veri\n use self::region_constraints::{\n     RegionConstraintCollector, RegionConstraintStorage, RegionSnapshot,\n };\n-use self::type_variable::{Diverging, TypeVariableOrigin, TypeVariableOriginKind};\n+use self::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n \n pub mod at;\n pub mod canonical;\n@@ -702,17 +702,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         t.fold_with(&mut self.freshener())\n     }\n \n-    /// Returns whether `ty` is a diverging type variable or not.\n-    /// (If `ty` is not a type variable at all, returns not diverging.)\n-    ///\n-    /// No attempt is made to resolve `ty`.\n-    pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> Diverging {\n-        match *ty.kind() {\n-            ty::Infer(ty::TyVar(vid)) => self.inner.borrow_mut().type_variables().var_diverges(vid),\n-            _ => Diverging::NotDiverging,\n-        }\n-    }\n-\n     /// Returns the origin of the type variable identified by `vid`, or `None`\n     /// if this is not a type variable.\n     ///\n@@ -1071,31 +1060,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn next_ty_var_id(&self, diverging: Diverging, origin: TypeVariableOrigin) -> TyVid {\n-        self.inner.borrow_mut().type_variables().new_var(self.universe(), diverging, origin)\n+    /// Number of type variables created so far.\n+    pub fn num_ty_vars(&self) -> usize {\n+        self.inner.borrow_mut().type_variables().num_vars()\n+    }\n+\n+    pub fn next_ty_var_id(&self, origin: TypeVariableOrigin) -> TyVid {\n+        self.inner.borrow_mut().type_variables().new_var(self.universe(), origin)\n     }\n \n     pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_ty_var(self.next_ty_var_id(Diverging::NotDiverging, origin))\n+        self.tcx.mk_ty_var(self.next_ty_var_id(origin))\n     }\n \n     pub fn next_ty_var_in_universe(\n         &self,\n         origin: TypeVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> Ty<'tcx> {\n-        let vid = self.inner.borrow_mut().type_variables().new_var(\n-            universe,\n-            Diverging::NotDiverging,\n-            origin,\n-        );\n+        let vid = self.inner.borrow_mut().type_variables().new_var(universe, origin);\n         self.tcx.mk_ty_var(vid)\n     }\n \n-    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_ty_var(self.next_ty_var_id(Diverging::Diverges, origin))\n-    }\n-\n     pub fn next_const_var(\n         &self,\n         ty: Ty<'tcx>,\n@@ -1207,7 +1193,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // as the substitutions for the default, `(T, U)`.\n                 let ty_var_id = self.inner.borrow_mut().type_variables().new_var(\n                     self.universe(),\n-                    Diverging::NotDiverging,\n                     TypeVariableOrigin {\n                         kind: TypeVariableOriginKind::TypeParameterDefinition(\n                             param.name,"}, {"sha": "73d74584a5e13db33c74ced5712e7d8b7427eed4", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -22,7 +22,6 @@\n //!   constituents)\n \n use crate::infer::combine::ConstEquateRelation;\n-use crate::infer::type_variable::Diverging;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n use rustc_data_structures::fx::FxHashMap;\n@@ -927,8 +926,7 @@ where\n                             // Replacing with a new variable in the universe `self.universe`,\n                             // it will be unified later with the original type variable in\n                             // the universe `_universe`.\n-                            let new_var_id =\n-                                variables.new_var(self.universe, Diverging::NotDiverging, origin);\n+                            let new_var_id = variables.new_var(self.universe, origin);\n \n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);"}, {"sha": "0e832685310d51b687d225f2fdb5139359f28383", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -129,19 +129,16 @@ pub enum TypeVariableOriginKind {\n     SubstitutionPlaceholder,\n     AutoDeref,\n     AdjustmentType,\n-    DivergingFn,\n+\n+    /// In type check, when we are type checking a function that\n+    /// returns `-> dyn Foo`, we substitute a type variable for the\n+    /// return type for diagnostic purposes.\n+    DynReturnFn,\n     LatticeVariable,\n }\n \n pub(crate) struct TypeVariableData {\n     origin: TypeVariableOrigin,\n-    diverging: Diverging,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum Diverging {\n-    NotDiverging,\n-    Diverges,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -191,14 +188,6 @@ impl<'tcx> TypeVariableStorage<'tcx> {\n }\n \n impl<'tcx> TypeVariableTable<'_, 'tcx> {\n-    /// Returns the diverges flag given when `vid` was created.\n-    ///\n-    /// Note that this function does not return care whether\n-    /// `vid` has been unified with something else or not.\n-    pub fn var_diverges(&self, vid: ty::TyVid) -> Diverging {\n-        self.storage.values.get(vid.index()).diverging\n-    }\n-\n     /// Returns the origin that was given when `vid` was created.\n     ///\n     /// Note that this function does not return care whether\n@@ -260,21 +249,17 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n     pub fn new_var(\n         &mut self,\n         universe: ty::UniverseIndex,\n-        diverging: Diverging,\n         origin: TypeVariableOrigin,\n     ) -> ty::TyVid {\n         let eq_key = self.eq_relations().new_key(TypeVariableValue::Unknown { universe });\n \n         let sub_key = self.sub_relations().new_key(());\n         assert_eq!(eq_key.vid, sub_key);\n \n-        let index = self.values().push(TypeVariableData { origin, diverging });\n+        let index = self.values().push(TypeVariableData { origin });\n         assert_eq!(eq_key.vid.as_u32(), index as u32);\n \n-        debug!(\n-            \"new_var(index={:?}, universe={:?}, diverging={:?}, origin={:?}\",\n-            eq_key.vid, universe, diverging, origin,\n-        );\n+        debug!(\"new_var(index={:?}, universe={:?}, origin={:?}\", eq_key.vid, universe, origin,);\n \n         eq_key.vid\n     }"}, {"sha": "a12f7dc759c09aa7d5a415896568cb5d557041e1", "filename": "compiler/rustc_infer/src/traits/engine.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1,5 +1,6 @@\n use crate::infer::InferCtxt;\n use crate::traits::Obligation;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, ToPredicate, Ty, WithConstness};\n@@ -73,6 +74,8 @@ pub trait TraitEngine<'tcx>: 'tcx {\n     }\n \n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n+\n+    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships>;\n }\n \n pub trait TraitEngineExt<'tcx> {"}, {"sha": "b4f7a9fa8e9d6584afb69e4201a9ba3fe8281db5", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -599,7 +599,7 @@ rustc_queries! {\n         desc { \"computing the inferred outlives predicates for items in this crate\" }\n     }\n \n-    /// Maps from an impl/trait `DefId to a list of the `DefId`s of its items.\n+    /// Maps from an impl/trait `DefId` to a list of the `DefId`s of its items.\n     query associated_item_def_ids(key: DefId) -> &'tcx [DefId] {\n         desc { |tcx| \"collecting associated items of `{}`\", tcx.def_path_str(key) }\n     }"}, {"sha": "cc81ddbcc01b9806268b7db9f09121013a5d0c01", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -2090,3 +2090,16 @@ impl<'tcx> fmt::Debug for SymbolName<'tcx> {\n         fmt::Display::fmt(&self.name, fmt)\n     }\n }\n+\n+#[derive(Debug, Default, Copy, Clone)]\n+pub struct FoundRelationships {\n+    /// This is true if we identified that this Ty (`?T`) is found in a `?T: Foo`\n+    /// obligation, where:\n+    ///\n+    ///  * `Foo` is not `Sized`\n+    ///  * `(): Foo` may be satisfied\n+    pub self_in_trait: bool,\n+    /// This is true if we identified that this Ty (`?T`) is found in a `<_ as\n+    /// _>::AssocType = ?T`\n+    pub output: bool,\n+}"}, {"sha": "d99534c200a5a557c8e1dcff2d1241c8ca00071a", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -59,6 +59,7 @@ thread_local! {\n     static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = const { Cell::new(false) };\n     static NO_TRIMMED_PATH: Cell<bool> = const { Cell::new(false) };\n     static NO_QUERIES: Cell<bool> = const { Cell::new(false) };\n+    static NO_VISIBLE_PATH: Cell<bool> = const { Cell::new(false) };\n }\n \n /// Avoids running any queries during any prints that occur\n@@ -112,6 +113,16 @@ pub fn with_no_trimmed_paths<F: FnOnce() -> R, R>(f: F) -> R {\n     })\n }\n \n+/// Prevent selection of visible paths. `Display` impl of DefId will prefer visible (public) reexports of types as paths.\n+pub fn with_no_visible_paths<F: FnOnce() -> R, R>(f: F) -> R {\n+    NO_VISIBLE_PATH.with(|flag| {\n+        let old = flag.replace(true);\n+        let result = f();\n+        flag.set(old);\n+        result\n+    })\n+}\n+\n /// The \"region highlights\" are used to control region printing during\n /// specific error messages. When a \"region highlight\" is enabled, it\n /// gives an alternate way to print specific regions. For now, we\n@@ -268,6 +279,10 @@ pub trait PrettyPrinter<'tcx>:\n     /// from at least one local module, and returns `true`. If the crate defining `def_id` is\n     /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n     fn try_print_visible_def_path(self, def_id: DefId) -> Result<(Self, bool), Self::Error> {\n+        if NO_VISIBLE_PATH.with(|flag| flag.get()) {\n+            return Ok((self, false));\n+        }\n+\n         let mut callers = Vec::new();\n         self.try_print_visible_def_path_recur(def_id, &mut callers)\n     }"}, {"sha": "1e17ba204b2c7ff2fc0548e9d0dda3532e0deb04", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1672,6 +1672,14 @@ impl<'tcx> TyS<'tcx> {\n         matches!(self.kind(), Infer(TyVar(_)))\n     }\n \n+    #[inline]\n+    pub fn ty_vid(&self) -> Option<ty::TyVid> {\n+        match self.kind() {\n+            &Infer(TyVar(vid)) => Some(vid),\n+            _ => None,\n+        }\n+    }\n+\n     #[inline]\n     pub fn is_ty_infer(&self) -> bool {\n         matches!(self.kind(), Infer(_))"}, {"sha": "c5417ea23f2190ab466b5a06a2ab90735f937bb3", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1568,6 +1568,20 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn parse_lit(&mut self) -> PResult<'a, Lit> {\n         self.parse_opt_lit().ok_or_else(|| {\n+            if let token::Interpolated(inner) = &self.token.kind {\n+                let expr = match inner.as_ref() {\n+                    token::NtExpr(expr) => Some(expr),\n+                    token::NtLiteral(expr) => Some(expr),\n+                    _ => None,\n+                };\n+                if let Some(expr) = expr {\n+                    if matches!(expr.kind, ExprKind::Err) {\n+                        self.diagnostic()\n+                            .delay_span_bug(self.token.span, &\"invalid interpolated expression\");\n+                        return self.diagnostic().struct_dummy();\n+                    }\n+                }\n+            }\n             let msg = format!(\"unexpected token: {}\", super::token_descr(&self.token));\n             self.struct_span_err(self.token.span, &msg)\n         })"}, {"sha": "bb686b5ef3f3a9c6f95d3e5bf98b50cd2569b9d7", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -321,10 +321,13 @@ macro_rules! define_queries {\n             pub fn $name<$tcx>(tcx: QueryCtxt<$tcx>, key: query_keys::$name<$tcx>) -> QueryStackFrame {\n                 let kind = dep_graph::DepKind::$name;\n                 let name = stringify!($name);\n-                let description = ty::print::with_forced_impl_filename_line(\n+                // Disable visible paths printing for performance reasons.\n+                // Showing visible path instead of any path is not that important in production.\n+                let description = ty::print::with_no_visible_paths(\n+                    || ty::print::with_forced_impl_filename_line(\n                     // Force filename-line mode to avoid invoking `type_of` query.\n                     || queries::$name::describe(tcx, key)\n-                );\n+                ));\n                 let description = if tcx.sess.verbose() {\n                     format!(\"{} [{}]\", description, name)\n                 } else {"}, {"sha": "ec62ee400688ca2f62cae140fc32b1f40da8bf5e", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -7,16 +7,21 @@ use crate::traits::{\n     ChalkEnvironmentAndGoal, FulfillmentError, FulfillmentErrorCode, ObligationCause,\n     PredicateObligation, SelectionError, TraitEngine,\n };\n-use rustc_data_structures::fx::FxIndexSet;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_middle::ty::{self, Ty};\n \n pub struct FulfillmentContext<'tcx> {\n     obligations: FxIndexSet<PredicateObligation<'tcx>>,\n+\n+    relationships: FxHashMap<ty::TyVid, ty::FoundRelationships>,\n }\n \n impl FulfillmentContext<'tcx> {\n     crate fn new() -> Self {\n-        FulfillmentContext { obligations: FxIndexSet::default() }\n+        FulfillmentContext {\n+            obligations: FxIndexSet::default(),\n+            relationships: FxHashMap::default(),\n+        }\n     }\n }\n \n@@ -39,6 +44,8 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         assert!(!infcx.is_in_snapshot());\n         let obligation = infcx.resolve_vars_if_possible(obligation);\n \n+        super::relationships::update(self, infcx, &obligation);\n+\n         self.obligations.insert(obligation);\n     }\n \n@@ -146,4 +153,8 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.obligations.iter().cloned().collect()\n     }\n+\n+    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n+        &mut self.relationships\n+    }\n }"}, {"sha": "61462f23886ce650c6e911ad02857ff5fe549bee", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1,4 +1,5 @@\n use crate::infer::{InferCtxt, TyOrConstInferVar};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n@@ -53,6 +54,9 @@ pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n     predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n+\n+    relationships: FxHashMap<ty::TyVid, ty::FoundRelationships>,\n+\n     // Should this fulfillment context register type-lives-for-region\n     // obligations on its parent infcx? In some cases, region\n     // obligations are either already known to hold (normalization) or\n@@ -97,6 +101,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n+            relationships: FxHashMap::default(),\n             register_region_obligations: true,\n             usable_in_snapshot: false,\n         }\n@@ -105,6 +110,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new_in_snapshot() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n+            relationships: FxHashMap::default(),\n             register_region_obligations: true,\n             usable_in_snapshot: true,\n         }\n@@ -113,6 +119,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new_ignoring_regions() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n+            relationships: FxHashMap::default(),\n             register_region_obligations: false,\n             usable_in_snapshot: false,\n         }\n@@ -210,6 +217,8 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n         assert!(!infcx.is_in_snapshot() || self.usable_in_snapshot);\n \n+        super::relationships::update(self, infcx, &obligation);\n+\n         self.predicates\n             .register_obligation(PendingPredicateObligation { obligation, stalled_on: vec![] });\n     }\n@@ -265,6 +274,10 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.predicates.map_pending_obligations(|o| o.obligation.clone())\n     }\n+\n+    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n+        &mut self.relationships\n+    }\n }\n \n struct FulfillProcessor<'a, 'b, 'tcx> {"}, {"sha": "df2422048b9d7b90d60f97b7fc09f26b52675db8", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -15,6 +15,7 @@ mod object_safety;\n mod on_unimplemented;\n mod project;\n pub mod query;\n+pub(crate) mod relationships;\n mod select;\n mod specialize;\n mod structural_match;"}, {"sha": "7751dd84f4cac95d4b61f62d6706e67c7c23df16", "filename": "compiler/rustc_trait_selection/src/traits/relationships.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,69 @@\n+use crate::infer::InferCtxt;\n+use crate::traits::query::evaluate_obligation::InferCtxtExt;\n+use crate::traits::{ObligationCause, PredicateObligation};\n+use rustc_infer::traits::TraitEngine;\n+use rustc_middle::ty::{self, ToPredicate};\n+\n+pub(crate) fn update<'tcx, T>(\n+    engine: &mut T,\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    obligation: &PredicateObligation<'tcx>,\n+) where\n+    T: TraitEngine<'tcx>,\n+{\n+    // (*) binder skipped\n+    if let ty::PredicateKind::Trait(predicate) = obligation.predicate.kind().skip_binder() {\n+        if let Some(ty) =\n+            infcx.shallow_resolve(predicate.self_ty()).ty_vid().map(|t| infcx.root_var(t))\n+        {\n+            if infcx\n+                .tcx\n+                .lang_items()\n+                .sized_trait()\n+                .map_or(false, |st| st != predicate.trait_ref.def_id)\n+            {\n+                let new_self_ty = infcx.tcx.types.unit;\n+\n+                let trait_ref = ty::TraitRef {\n+                    substs: infcx\n+                        .tcx\n+                        .mk_substs_trait(new_self_ty, &predicate.trait_ref.substs[1..]),\n+                    ..predicate.trait_ref\n+                };\n+\n+                // Then contstruct a new obligation with Self = () added\n+                // to the ParamEnv, and see if it holds.\n+                let o = rustc_infer::traits::Obligation::new(\n+                    ObligationCause::dummy(),\n+                    obligation.param_env,\n+                    obligation\n+                        .predicate\n+                        .kind()\n+                        .map_bound(|_| {\n+                            // (*) binder moved here\n+                            ty::PredicateKind::Trait(ty::TraitPredicate {\n+                                trait_ref,\n+                                constness: predicate.constness,\n+                            })\n+                        })\n+                        .to_predicate(infcx.tcx),\n+                );\n+                // Don't report overflow errors. Otherwise equivalent to may_hold.\n+                if let Ok(result) = infcx.probe(|_| infcx.evaluate_obligation(&o)) {\n+                    if result.may_apply() {\n+                        engine.relationships().entry(ty).or_default().self_in_trait = true;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    if let ty::PredicateKind::Projection(predicate) = obligation.predicate.kind().skip_binder() {\n+        // If the projection predicate (Foo::Bar == X) has X as a non-TyVid,\n+        // we need to make it into one.\n+        if let Some(vid) = predicate.ty.ty_vid() {\n+            debug!(\"relationship: {:?}.output = true\", vid);\n+            engine.relationships().entry(vid).or_default().output = true;\n+        }\n+    }\n+}"}, {"sha": "9f0ed0cd18d920aeeb125d9f5bcd4ed3902cdd21", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -241,32 +241,16 @@ pub(super) fn check_fn<'a, 'tcx>(\n     // we saw and assigning it to the expected return type. This isn't\n     // really expected to fail, since the coercions would have failed\n     // earlier when trying to find a LUB.\n-    //\n-    // However, the behavior around `!` is sort of complex. In the\n-    // event that the `actual_return_ty` comes back as `!`, that\n-    // indicates that the fn either does not return or \"returns\" only\n-    // values of type `!`. In this case, if there is an expected\n-    // return type that is *not* `!`, that should be ok. But if the\n-    // return type is being inferred, we want to \"fallback\" to `!`:\n-    //\n-    //     let x = move || panic!();\n-    //\n-    // To allow for that, I am creating a type variable with diverging\n-    // fallback. This was deemed ever so slightly better than unifying\n-    // the return value with `!` because it allows for the caller to\n-    // make more assumptions about the return type (e.g., they could do\n-    //\n-    //     let y: Option<u32> = Some(x());\n-    //\n-    // which would then cause this return type to become `u32`, not\n-    // `!`).\n     let coercion = fcx.ret_coercion.take().unwrap().into_inner();\n     let mut actual_return_ty = coercion.complete(&fcx);\n-    if actual_return_ty.is_never() {\n-        actual_return_ty = fcx.next_diverging_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::DivergingFn,\n-            span,\n-        });\n+    debug!(\"actual_return_ty = {:?}\", actual_return_ty);\n+    if let ty::Dynamic(..) = declared_ret_ty.kind() {\n+        // We have special-cased the case where the function is declared\n+        // `-> dyn Foo` and we don't actually relate it to the\n+        // `fcx.ret_coercion`, so just substitute a type variable.\n+        actual_return_ty =\n+            fcx.next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::DynReturnFn, span });\n+        debug!(\"actual_return_ty replaced with {:?}\", actual_return_ty);\n     }\n     fcx.demand_suptype(span, revealed_ret_ty, actual_return_ty);\n "}, {"sha": "5b9481ce4e1b9d0cd92efa4d1014ce0f4130a83f", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -159,24 +159,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Coercing from `!` to any type is allowed:\n         if a.is_never() {\n-            // Subtle: If we are coercing from `!` to `?T`, where `?T` is an unbound\n-            // type variable, we want `?T` to fallback to `!` if not\n-            // otherwise constrained. An example where this arises:\n-            //\n-            //     let _: Option<?T> = Some({ return; });\n-            //\n-            // here, we would coerce from `!` to `?T`.\n-            return if b.is_ty_var() {\n-                // Micro-optimization: no need for this if `b` is\n-                // already resolved in some way.\n-                let diverging_ty = self.next_diverging_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::AdjustmentType,\n-                    span: self.cause.span,\n-                });\n-                self.coerce_from_inference_variable(diverging_ty, b, simple(Adjust::NeverToAny))\n-            } else {\n-                success(simple(Adjust::NeverToAny)(b), b, vec![])\n-            };\n+            return success(simple(Adjust::NeverToAny)(b), b, vec![]);\n         }\n \n         // Coercing *from* an unresolved inference variable means that"}, {"sha": "8a69e0a737d501c1b2aed4d780c1a65fd8b321da", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 !self.typeck_results.borrow().adjustments().contains_key(expr.hir_id),\n                 \"expression with never type wound up being adjusted\"\n             );\n-            let adj_ty = self.next_diverging_ty_var(TypeVariableOrigin {\n+            let adj_ty = self.next_ty_var(TypeVariableOrigin {\n                 kind: TypeVariableOriginKind::AdjustmentType,\n                 span: expr.span,\n             });"}, {"sha": "296e45337ed1035b3ed1868396f371ba6b045c86", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 336, "deletions": 36, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1,29 +1,52 @@\n use crate::check::FnCtxt;\n-use rustc_infer::infer::type_variable::Diverging;\n+use rustc_data_structures::{\n+    fx::FxHashMap,\n+    graph::WithSuccessors,\n+    graph::{iterate::DepthFirstSearch, vec_graph::VecGraph},\n+    stable_set::FxHashSet,\n+};\n use rustc_middle::ty::{self, Ty};\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n     /// Performs type inference fallback, returning true if any fallback\n     /// occurs.\n     pub(super) fn type_inference_fallback(&self) -> bool {\n+        debug!(\n+            \"type-inference-fallback start obligations: {:#?}\",\n+            self.fulfillment_cx.borrow_mut().pending_obligations()\n+        );\n+\n         // All type checking constraints were added, try to fallback unsolved variables.\n         self.select_obligations_where_possible(false, |_| {});\n-        let mut fallback_has_occurred = false;\n \n+        debug!(\n+            \"type-inference-fallback post selection obligations: {:#?}\",\n+            self.fulfillment_cx.borrow_mut().pending_obligations()\n+        );\n+\n+        // Check if we have any unsolved varibales. If not, no need for fallback.\n+        let unsolved_variables = self.unsolved_variables();\n+        if unsolved_variables.is_empty() {\n+            return false;\n+        }\n+\n+        let diverging_fallback = self.calculate_diverging_fallback(&unsolved_variables);\n+\n+        let mut fallback_has_occurred = false;\n         // We do fallback in two passes, to try to generate\n         // better error messages.\n         // The first time, we do *not* replace opaque types.\n-        for ty in &self.unsolved_variables() {\n+        for ty in unsolved_variables {\n             debug!(\"unsolved_variable = {:?}\", ty);\n-            fallback_has_occurred |= self.fallback_if_possible(ty);\n+            fallback_has_occurred |= self.fallback_if_possible(ty, &diverging_fallback);\n         }\n \n-        // We now see if we can make progress. This might\n-        // cause us to unify inference variables for opaque types,\n-        // since we may have unified some other type variables\n-        // during the first phase of fallback.\n-        // This means that we only replace inference variables with their underlying\n-        // opaque types as a last resort.\n+        // We now see if we can make progress. This might cause us to\n+        // unify inference variables for opaque types, since we may\n+        // have unified some other type variables during the first\n+        // phase of fallback.  This means that we only replace\n+        // inference variables with their underlying opaque types as a\n+        // last resort.\n         //\n         // In code like this:\n         //\n@@ -62,36 +85,44 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     //\n     // - Unconstrained floats are replaced with with `f64`.\n     //\n-    // - Non-numerics get replaced with `!` when `#![feature(never_type_fallback)]`\n-    //   is enabled. Otherwise, they are replaced with `()`.\n+    // - Non-numerics may get replaced with `()` or `!`, depending on\n+    //   how they were categorized by `calculate_diverging_fallback`\n+    //   (and the setting of `#![feature(never_type_fallback)]`).\n+    //\n+    // Fallback becomes very dubious if we have encountered\n+    // type-checking errors.  In that case, fallback to Error.\n     //\n-    // Fallback becomes very dubious if we have encountered type-checking errors.\n-    // In that case, fallback to Error.\n     // The return value indicates whether fallback has occurred.\n-    fn fallback_if_possible(&self, ty: Ty<'tcx>) -> bool {\n+    fn fallback_if_possible(\n+        &self,\n+        ty: Ty<'tcx>,\n+        diverging_fallback: &FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n+    ) -> bool {\n         // Careful: we do NOT shallow-resolve `ty`. We know that `ty`\n-        // is an unsolved variable, and we determine its fallback based\n-        // solely on how it was created, not what other type variables\n-        // it may have been unified with since then.\n+        // is an unsolved variable, and we determine its fallback\n+        // based solely on how it was created, not what other type\n+        // variables it may have been unified with since then.\n         //\n-        // The reason this matters is that other attempts at fallback may\n-        // (in principle) conflict with this fallback, and we wish to generate\n-        // a type error in that case. (However, this actually isn't true right now,\n-        // because we're only using the builtin fallback rules. This would be\n-        // true if we were using user-supplied fallbacks. But it's still useful\n-        // to write the code to detect bugs.)\n+        // The reason this matters is that other attempts at fallback\n+        // may (in principle) conflict with this fallback, and we wish\n+        // to generate a type error in that case. (However, this\n+        // actually isn't true right now, because we're only using the\n+        // builtin fallback rules. This would be true if we were using\n+        // user-supplied fallbacks. But it's still useful to write the\n+        // code to detect bugs.)\n         //\n-        // (Note though that if we have a general type variable `?T` that is then unified\n-        // with an integer type variable `?I` that ultimately never gets\n-        // resolved to a special integral type, `?T` is not considered unsolved,\n-        // but `?I` is. The same is true for float variables.)\n+        // (Note though that if we have a general type variable `?T`\n+        // that is then unified with an integer type variable `?I`\n+        // that ultimately never gets resolved to a special integral\n+        // type, `?T` is not considered unsolved, but `?I` is. The\n+        // same is true for float variables.)\n         let fallback = match ty.kind() {\n             _ if self.is_tainted_by_errors() => self.tcx.ty_error(),\n             ty::Infer(ty::IntVar(_)) => self.tcx.types.i32,\n             ty::Infer(ty::FloatVar(_)) => self.tcx.types.f64,\n-            _ => match self.type_var_diverges(ty) {\n-                Diverging::Diverges => self.tcx.mk_diverging_default(),\n-                Diverging::NotDiverging => return false,\n+            _ => match diverging_fallback.get(&ty) {\n+                Some(&fallback_ty) => fallback_ty,\n+                None => return false,\n             },\n         };\n         debug!(\"fallback_if_possible(ty={:?}): defaulting to `{:?}`\", ty, fallback);\n@@ -105,11 +136,10 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         true\n     }\n \n-    /// Second round of fallback: Unconstrained type variables\n-    /// created from the instantiation of an opaque\n-    /// type fall back to the opaque type itself. This is a\n-    /// somewhat incomplete attempt to manage \"identity passthrough\"\n-    /// for `impl Trait` types.\n+    /// Second round of fallback: Unconstrained type variables created\n+    /// from the instantiation of an opaque type fall back to the\n+    /// opaque type itself. This is a somewhat incomplete attempt to\n+    /// manage \"identity passthrough\" for `impl Trait` types.\n     ///\n     /// For example, in this code:\n     ///\n@@ -158,4 +188,274 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             return false;\n         }\n     }\n+\n+    /// The \"diverging fallback\" system is rather complicated. This is\n+    /// a result of our need to balance 'do the right thing' with\n+    /// backwards compatibility.\n+    ///\n+    /// \"Diverging\" type variables are variables created when we\n+    /// coerce a `!` type into an unbound type variable `?X`. If they\n+    /// never wind up being constrained, the \"right and natural\" thing\n+    /// is that `?X` should \"fallback\" to `!`. This means that e.g. an\n+    /// expression like `Some(return)` will ultimately wind up with a\n+    /// type like `Option<!>` (presuming it is not assigned or\n+    /// constrained to have some other type).\n+    ///\n+    /// However, the fallback used to be `()` (before the `!` type was\n+    /// added).  Moreover, there are cases where the `!` type 'leaks\n+    /// out' from dead code into type variables that affect live\n+    /// code. The most common case is something like this:\n+    ///\n+    /// ```rust\n+    /// match foo() {\n+    ///     22 => Default::default(), // call this type `?D`\n+    ///     _ => return, // return has type `!`\n+    /// } // call the type of this match `?M`\n+    /// ```\n+    ///\n+    /// Here, coercing the type `!` into `?M` will create a diverging\n+    /// type variable `?X` where `?X <: ?M`.  We also have that `?D <:\n+    /// ?M`. If `?M` winds up unconstrained, then `?X` will\n+    /// fallback. If it falls back to `!`, then all the type variables\n+    /// will wind up equal to `!` -- this includes the type `?D`\n+    /// (since `!` doesn't implement `Default`, we wind up a \"trait\n+    /// not implemented\" error in code like this). But since the\n+    /// original fallback was `()`, this code used to compile with `?D\n+    /// = ()`. This is somewhat surprising, since `Default::default()`\n+    /// on its own would give an error because the types are\n+    /// insufficiently constrained.\n+    ///\n+    /// Our solution to this dilemma is to modify diverging variables\n+    /// so that they can *either* fallback to `!` (the default) or to\n+    /// `()` (the backwards compatibility case). We decide which\n+    /// fallback to use based on whether there is a coercion pattern\n+    /// like this:\n+    ///\n+    /// ```\n+    /// ?Diverging -> ?V\n+    /// ?NonDiverging -> ?V\n+    /// ?V != ?NonDiverging\n+    /// ```\n+    ///\n+    /// Here `?Diverging` represents some diverging type variable and\n+    /// `?NonDiverging` represents some non-diverging type\n+    /// variable. `?V` can be any type variable (diverging or not), so\n+    /// long as it is not equal to `?NonDiverging`.\n+    ///\n+    /// Intuitively, what we are looking for is a case where a\n+    /// \"non-diverging\" type variable (like `?M` in our example above)\n+    /// is coerced *into* some variable `?V` that would otherwise\n+    /// fallback to `!`. In that case, we make `?V` fallback to `!`,\n+    /// along with anything that would flow into `?V`.\n+    ///\n+    /// The algorithm we use:\n+    /// * Identify all variables that are coerced *into* by a\n+    ///   diverging variable.  Do this by iterating over each\n+    ///   diverging, unsolved variable and finding all variables\n+    ///   reachable from there. Call that set `D`.\n+    /// * Walk over all unsolved, non-diverging variables, and find\n+    ///   any variable that has an edge into `D`.\n+    fn calculate_diverging_fallback(\n+        &self,\n+        unsolved_variables: &[Ty<'tcx>],\n+    ) -> FxHashMap<Ty<'tcx>, Ty<'tcx>> {\n+        debug!(\"calculate_diverging_fallback({:?})\", unsolved_variables);\n+\n+        let relationships = self.fulfillment_cx.borrow_mut().relationships().clone();\n+\n+        // Construct a coercion graph where an edge `A -> B` indicates\n+        // a type variable is that is coerced\n+        let coercion_graph = self.create_coercion_graph();\n+\n+        // Extract the unsolved type inference variable vids; note that some\n+        // unsolved variables are integer/float variables and are excluded.\n+        let unsolved_vids = unsolved_variables.iter().filter_map(|ty| ty.ty_vid());\n+\n+        // Compute the diverging root vids D -- that is, the root vid of\n+        // those type variables that (a) are the target of a coercion from\n+        // a `!` type and (b) have not yet been solved.\n+        //\n+        // These variables are the ones that are targets for fallback to\n+        // either `!` or `()`.\n+        let diverging_roots: FxHashSet<ty::TyVid> = self\n+            .diverging_type_vars\n+            .borrow()\n+            .iter()\n+            .map(|&ty| self.infcx.shallow_resolve(ty))\n+            .filter_map(|ty| ty.ty_vid())\n+            .map(|vid| self.infcx.root_var(vid))\n+            .collect();\n+        debug!(\n+            \"calculate_diverging_fallback: diverging_type_vars={:?}\",\n+            self.diverging_type_vars.borrow()\n+        );\n+        debug!(\"calculate_diverging_fallback: diverging_roots={:?}\", diverging_roots);\n+\n+        // Find all type variables that are reachable from a diverging\n+        // type variable. These will typically default to `!`, unless\n+        // we find later that they are *also* reachable from some\n+        // other type variable outside this set.\n+        let mut roots_reachable_from_diverging = DepthFirstSearch::new(&coercion_graph);\n+        let mut diverging_vids = vec![];\n+        let mut non_diverging_vids = vec![];\n+        for unsolved_vid in unsolved_vids {\n+            let root_vid = self.infcx.root_var(unsolved_vid);\n+            debug!(\n+                \"calculate_diverging_fallback: unsolved_vid={:?} root_vid={:?} diverges={:?}\",\n+                unsolved_vid,\n+                root_vid,\n+                diverging_roots.contains(&root_vid),\n+            );\n+            if diverging_roots.contains(&root_vid) {\n+                diverging_vids.push(unsolved_vid);\n+                roots_reachable_from_diverging.push_start_node(root_vid);\n+\n+                debug!(\n+                    \"calculate_diverging_fallback: root_vid={:?} reaches {:?}\",\n+                    root_vid,\n+                    coercion_graph.depth_first_search(root_vid).collect::<Vec<_>>()\n+                );\n+\n+                // drain the iterator to visit all nodes reachable from this node\n+                roots_reachable_from_diverging.complete_search();\n+            } else {\n+                non_diverging_vids.push(unsolved_vid);\n+            }\n+        }\n+\n+        debug!(\n+            \"calculate_diverging_fallback: roots_reachable_from_diverging={:?}\",\n+            roots_reachable_from_diverging,\n+        );\n+\n+        // Find all type variables N0 that are not reachable from a\n+        // diverging variable, and then compute the set reachable from\n+        // N0, which we call N. These are the *non-diverging* type\n+        // variables. (Note that this set consists of \"root variables\".)\n+        let mut roots_reachable_from_non_diverging = DepthFirstSearch::new(&coercion_graph);\n+        for &non_diverging_vid in &non_diverging_vids {\n+            let root_vid = self.infcx.root_var(non_diverging_vid);\n+            if roots_reachable_from_diverging.visited(root_vid) {\n+                continue;\n+            }\n+            roots_reachable_from_non_diverging.push_start_node(root_vid);\n+            roots_reachable_from_non_diverging.complete_search();\n+        }\n+        debug!(\n+            \"calculate_diverging_fallback: roots_reachable_from_non_diverging={:?}\",\n+            roots_reachable_from_non_diverging,\n+        );\n+\n+        debug!(\"inherited: {:#?}\", self.inh.fulfillment_cx.borrow_mut().pending_obligations());\n+        debug!(\"obligations: {:#?}\", self.fulfillment_cx.borrow_mut().pending_obligations());\n+        debug!(\"relationships: {:#?}\", relationships);\n+\n+        // For each diverging variable, figure out whether it can\n+        // reach a member of N. If so, it falls back to `()`. Else\n+        // `!`.\n+        let mut diverging_fallback = FxHashMap::default();\n+        diverging_fallback.reserve(diverging_vids.len());\n+        for &diverging_vid in &diverging_vids {\n+            let diverging_ty = self.tcx.mk_ty_var(diverging_vid);\n+            let root_vid = self.infcx.root_var(diverging_vid);\n+            let can_reach_non_diverging = coercion_graph\n+                .depth_first_search(root_vid)\n+                .any(|n| roots_reachable_from_non_diverging.visited(n));\n+\n+            let mut relationship = ty::FoundRelationships { self_in_trait: false, output: false };\n+\n+            for (vid, rel) in relationships.iter() {\n+                if self.infcx.root_var(*vid) == root_vid {\n+                    relationship.self_in_trait |= rel.self_in_trait;\n+                    relationship.output |= rel.output;\n+                }\n+            }\n+\n+            if relationship.self_in_trait && relationship.output {\n+                // This case falls back to () to ensure that the code pattern in\n+                // src/test/ui/never_type/fallback-closure-ret.rs continues to\n+                // compile when never_type_fallback is enabled.\n+                //\n+                // This rule is not readily explainable from first principles,\n+                // but is rather intended as a patchwork fix to ensure code\n+                // which compiles before the stabilization of never type\n+                // fallback continues to work.\n+                //\n+                // Typically this pattern is encountered in a function taking a\n+                // closure as a parameter, where the return type of that closure\n+                // (checked by `relationship.output`) is expected to implement\n+                // some trait (checked by `relationship.self_in_trait`). This\n+                // can come up in non-closure cases too, so we do not limit this\n+                // rule to specifically `FnOnce`.\n+                //\n+                // When the closure's body is something like `panic!()`, the\n+                // return type would normally be inferred to `!`. However, it\n+                // needs to fall back to `()` in order to still compile, as the\n+                // trait is specifically implemented for `()` but not `!`.\n+                //\n+                // For details on the requirements for these relationships to be\n+                // set, see the relationship finding module in\n+                // compiler/rustc_trait_selection/src/traits/relationships.rs.\n+                debug!(\"fallback to () - found trait and projection: {:?}\", diverging_vid);\n+                diverging_fallback.insert(diverging_ty, self.tcx.types.unit);\n+            } else if can_reach_non_diverging {\n+                debug!(\"fallback to () - reached non-diverging: {:?}\", diverging_vid);\n+                diverging_fallback.insert(diverging_ty, self.tcx.types.unit);\n+            } else {\n+                debug!(\"fallback to ! - all diverging: {:?}\", diverging_vid);\n+                diverging_fallback.insert(diverging_ty, self.tcx.mk_diverging_default());\n+            }\n+        }\n+\n+        diverging_fallback\n+    }\n+\n+    /// Returns a graph whose nodes are (unresolved) inference variables and where\n+    /// an edge `?A -> ?B` indicates that the variable `?A` is coerced to `?B`.\n+    fn create_coercion_graph(&self) -> VecGraph<ty::TyVid> {\n+        let pending_obligations = self.fulfillment_cx.borrow_mut().pending_obligations();\n+        debug!(\"create_coercion_graph: pending_obligations={:?}\", pending_obligations);\n+        let coercion_edges: Vec<(ty::TyVid, ty::TyVid)> = pending_obligations\n+            .into_iter()\n+            .filter_map(|obligation| {\n+                // The predicates we are looking for look like `Coerce(?A -> ?B)`.\n+                // They will have no bound variables.\n+                obligation.predicate.kind().no_bound_vars()\n+            })\n+            .filter_map(|atom| {\n+                // We consider both subtyping and coercion to imply 'flow' from\n+                // some position in the code `a` to a different position `b`.\n+                // This is then used to determine which variables interact with\n+                // live code, and as such must fall back to `()` to preserve\n+                // soundness.\n+                //\n+                // In practice currently the two ways that this happens is\n+                // coercion and subtyping.\n+                let (a, b) = if let ty::PredicateKind::Coerce(ty::CoercePredicate { a, b }) = atom {\n+                    (a, b)\n+                } else if let ty::PredicateKind::Subtype(ty::SubtypePredicate {\n+                    a_is_expected: _,\n+                    a,\n+                    b,\n+                }) = atom\n+                {\n+                    (a, b)\n+                } else {\n+                    return None;\n+                };\n+\n+                let a_vid = self.root_vid(a)?;\n+                let b_vid = self.root_vid(b)?;\n+                Some((a_vid, b_vid))\n+            })\n+            .collect();\n+        debug!(\"create_coercion_graph: coercion_edges={:?}\", coercion_edges);\n+        let num_ty_vars = self.infcx.num_ty_vars();\n+        VecGraph::new(num_ty_vars, coercion_edges)\n+    }\n+\n+    /// If `ty` is an unresolved type variable, returns its root vid.\n+    fn root_vid(&self, ty: Ty<'tcx>) -> Option<ty::TyVid> {\n+        Some(self.infcx.root_var(self.infcx.shallow_resolve(ty).ty_vid()?))\n+    }\n }"}, {"sha": "562d05d3ef9b1b00e803893f1539fd66e5f00397", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -286,6 +286,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n+        for a in &adj {\n+            if let Adjust::NeverToAny = a.kind {\n+                if a.target.is_ty_var() {\n+                    self.diverging_type_vars.borrow_mut().insert(a.target);\n+                    debug!(\"apply_adjustments: adding `{:?}` as diverging type var\", a.target);\n+                }\n+            }\n+        }\n+\n         let autoborrow_mut = adj.iter().any(|adj| {\n             matches!(\n                 adj,"}, {"sha": "f7552c1f4eb0cae7e6281e52d553f3cae5a09ec6", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1,6 +1,7 @@\n use super::callee::DeferredCallResolution;\n use super::MaybeInProgressTables;\n \n+use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n use rustc_hir::HirIdMap;\n@@ -56,6 +57,11 @@ pub struct Inherited<'a, 'tcx> {\n     pub(super) constness: hir::Constness,\n \n     pub(super) body_id: Option<hir::BodyId>,\n+\n+    /// Whenever we introduce an adjustment from `!` into a type variable,\n+    /// we record that type variable here. This is later used to inform\n+    /// fallback. See the `fallback` module for details.\n+    pub(super) diverging_type_vars: RefCell<FxHashSet<Ty<'tcx>>>,\n }\n \n impl<'a, 'tcx> Deref for Inherited<'a, 'tcx> {\n@@ -121,6 +127,7 @@ impl Inherited<'a, 'tcx> {\n             deferred_call_resolutions: RefCell::new(Default::default()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n+            diverging_type_vars: RefCell::new(Default::default()),\n             constness,\n             body_id,\n         }"}, {"sha": "2e3db4d6d655f53447438c62ec0c76ad90b7a397", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1,6 +1,7 @@\n use crate::structured_errors::StructuredDiagnostic;\n use rustc_errors::{pluralize, Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc_hir as hir;\n+use rustc_middle::hir::map::fn_sig;\n use rustc_middle::middle::resolve_lifetime::LifetimeScopeForPath;\n use rustc_middle::ty::{self as ty, TyCtxt};\n use rustc_session::Session;\n@@ -292,12 +293,30 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         &self,\n         num_params_to_take: usize,\n     ) -> String {\n+        let fn_sig = self.tcx.hir().get_if_local(self.def_id).and_then(|node| fn_sig(node));\n+        let is_used_in_input = |def_id| {\n+            fn_sig.map_or(false, |fn_sig| {\n+                fn_sig.decl.inputs.iter().any(|ty| match ty.kind {\n+                    hir::TyKind::Path(hir::QPath::Resolved(\n+                        None,\n+                        hir::Path { res: hir::def::Res::Def(_, id), .. },\n+                    )) if *id == def_id => true,\n+                    _ => false,\n+                })\n+            })\n+        };\n         self.gen_params\n             .params\n             .iter()\n             .skip(self.params_offset + self.num_provided_type_or_const_args())\n             .take(num_params_to_take)\n-            .map(|param| param.name.to_string())\n+            .map(|param| match param.kind {\n+                // This is being infered from the item's inputs, no need to set it.\n+                ty::GenericParamDefKind::Type { .. } if is_used_in_input(param.def_id) => {\n+                    \"_\".to_string()\n+                }\n+                _ => param.name.to_string(),\n+            })\n             .collect::<Vec<_>>()\n             .join(\", \")\n     }"}, {"sha": "daef5c98967cc4cfe1ca9058da04ff97725a25f3", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1849,17 +1849,17 @@ macro_rules! int_impl {\n         #[doc = concat!(\"let a: \", stringify!($SelfT),\" = 8;\")]\n         /// let b = 3;\n         ///\n-        /// assert_eq!(a.div_floor(b), 2);\n-        /// assert_eq!(a.div_floor(-b), -3);\n-        /// assert_eq!((-a).div_floor(b), -3);\n-        /// assert_eq!((-a).div_floor(-b), 2);\n+        /// assert_eq!(a.unstable_div_floor(b), 2);\n+        /// assert_eq!(a.unstable_div_floor(-b), -3);\n+        /// assert_eq!((-a).unstable_div_floor(b), -3);\n+        /// assert_eq!((-a).unstable_div_floor(-b), 2);\n         /// ```\n         #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n-        pub const fn div_floor(self, rhs: Self) -> Self {\n+        pub const fn unstable_div_floor(self, rhs: Self) -> Self {\n             let d = self / rhs;\n             let r = self % rhs;\n             if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {\n@@ -1884,17 +1884,17 @@ macro_rules! int_impl {\n         #[doc = concat!(\"let a: \", stringify!($SelfT),\" = 8;\")]\n         /// let b = 3;\n         ///\n-        /// assert_eq!(a.div_ceil(b), 3);\n-        /// assert_eq!(a.div_ceil(-b), -2);\n-        /// assert_eq!((-a).div_ceil(b), -2);\n-        /// assert_eq!((-a).div_ceil(-b), 3);\n+        /// assert_eq!(a.unstable_div_ceil(b), 3);\n+        /// assert_eq!(a.unstable_div_ceil(-b), -2);\n+        /// assert_eq!((-a).unstable_div_ceil(b), -2);\n+        /// assert_eq!((-a).unstable_div_ceil(-b), 3);\n         /// ```\n         #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n-        pub const fn div_ceil(self, rhs: Self) -> Self {\n+        pub const fn unstable_div_ceil(self, rhs: Self) -> Self {\n             let d = self / rhs;\n             let r = self % rhs;\n             if (r > 0 && rhs > 0) || (r < 0 && rhs < 0) {\n@@ -1919,21 +1919,21 @@ macro_rules! int_impl {\n         ///\n         /// ```\n         /// #![feature(int_roundings)]\n-        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n-        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n-        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(-8), 16);\")]\n-        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(-8), 16);\")]\n-        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").next_multiple_of(8), -16);\")]\n-        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").next_multiple_of(8), -16);\")]\n-        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").next_multiple_of(-8), -16);\")]\n-        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").next_multiple_of(-8), -24);\")]\n+        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".unstable_next_multiple_of(8), 16);\")]\n+        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".unstable_next_multiple_of(8), 24);\")]\n+        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".unstable_next_multiple_of(-8), 16);\")]\n+        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".unstable_next_multiple_of(-8), 16);\")]\n+        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").unstable_next_multiple_of(8), -16);\")]\n+        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").unstable_next_multiple_of(8), -16);\")]\n+        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").unstable_next_multiple_of(-8), -16);\")]\n+        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").unstable_next_multiple_of(-8), -24);\")]\n         /// ```\n         #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n-        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n+        pub const fn unstable_next_multiple_of(self, rhs: Self) -> Self {\n             // This would otherwise fail when calculating `r` when self == T::MIN.\n             if rhs == -1 {\n                 return self;"}, {"sha": "8ce826626309147f7c2ace97f2ca3f975cd8305e", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1859,12 +1859,12 @@ macro_rules! uint_impl {\n         ///\n         /// ```\n         /// #![feature(int_roundings)]\n-        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n+        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".unstable_div_floor(4), 1);\")]\n         /// ```\n         #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n         #[inline(always)]\n         #[rustc_inherit_overflow_checks]\n-        pub const fn div_floor(self, rhs: Self) -> Self {\n+        pub const fn unstable_div_floor(self, rhs: Self) -> Self {\n             self / rhs\n         }\n \n@@ -1880,12 +1880,12 @@ macro_rules! uint_impl {\n         ///\n         /// ```\n         /// #![feature(int_roundings)]\n-        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n+        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".unstable_div_ceil(4), 2);\")]\n         /// ```\n         #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n-        pub const fn div_ceil(self, rhs: Self) -> Self {\n+        pub const fn unstable_div_ceil(self, rhs: Self) -> Self {\n             let d = self / rhs;\n             let r = self % rhs;\n             if r > 0 && rhs > 0 {\n@@ -1908,15 +1908,15 @@ macro_rules! uint_impl {\n         ///\n         /// ```\n         /// #![feature(int_roundings)]\n-        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n-        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n+        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".unstable_next_multiple_of(8), 16);\")]\n+        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".unstable_next_multiple_of(8), 24);\")]\n         /// ```\n         #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n-        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n+        pub const fn unstable_next_multiple_of(self, rhs: Self) -> Self {\n             match self % rhs {\n                 0 => self,\n                 r => self + (rhs - r)"}, {"sha": "0ad85bf6d943d1d254ef0f34a0d0a348b8b0108c", "filename": "library/core/tests/num/int_macros.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -294,33 +294,33 @@ macro_rules! int_module {\n             fn test_div_floor() {\n                 let a: $T = 8;\n                 let b = 3;\n-                assert_eq!(a.div_floor(b), 2);\n-                assert_eq!(a.div_floor(-b), -3);\n-                assert_eq!((-a).div_floor(b), -3);\n-                assert_eq!((-a).div_floor(-b), 2);\n+                assert_eq!(a.unstable_div_floor(b), 2);\n+                assert_eq!(a.unstable_div_floor(-b), -3);\n+                assert_eq!((-a).unstable_div_floor(b), -3);\n+                assert_eq!((-a).unstable_div_floor(-b), 2);\n             }\n \n             #[test]\n             fn test_div_ceil() {\n                 let a: $T = 8;\n                 let b = 3;\n-                assert_eq!(a.div_ceil(b), 3);\n-                assert_eq!(a.div_ceil(-b), -2);\n-                assert_eq!((-a).div_ceil(b), -2);\n-                assert_eq!((-a).div_ceil(-b), 3);\n+                assert_eq!(a.unstable_div_ceil(b), 3);\n+                assert_eq!(a.unstable_div_ceil(-b), -2);\n+                assert_eq!((-a).unstable_div_ceil(b), -2);\n+                assert_eq!((-a).unstable_div_ceil(-b), 3);\n             }\n \n             #[test]\n             fn test_next_multiple_of() {\n-                assert_eq!((16 as $T).next_multiple_of(8), 16);\n-                assert_eq!((23 as $T).next_multiple_of(8), 24);\n-                assert_eq!((16 as $T).next_multiple_of(-8), 16);\n-                assert_eq!((23 as $T).next_multiple_of(-8), 16);\n-                assert_eq!((-16 as $T).next_multiple_of(8), -16);\n-                assert_eq!((-23 as $T).next_multiple_of(8), -16);\n-                assert_eq!((-16 as $T).next_multiple_of(-8), -16);\n-                assert_eq!((-23 as $T).next_multiple_of(-8), -24);\n-                assert_eq!(MIN.next_multiple_of(-1), MIN);\n+                assert_eq!((16 as $T).unstable_next_multiple_of(8), 16);\n+                assert_eq!((23 as $T).unstable_next_multiple_of(8), 24);\n+                assert_eq!((16 as $T).unstable_next_multiple_of(-8), 16);\n+                assert_eq!((23 as $T).unstable_next_multiple_of(-8), 16);\n+                assert_eq!((-16 as $T).unstable_next_multiple_of(8), -16);\n+                assert_eq!((-23 as $T).unstable_next_multiple_of(8), -16);\n+                assert_eq!((-16 as $T).unstable_next_multiple_of(-8), -16);\n+                assert_eq!((-23 as $T).unstable_next_multiple_of(-8), -24);\n+                assert_eq!(MIN.unstable_next_multiple_of(-1), MIN);\n             }\n \n             #[test]"}, {"sha": "35ec88c6af7d6873396354bed9154eb2732310f7", "filename": "library/core/tests/num/uint_macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -208,19 +208,19 @@ macro_rules! uint_module {\n \n             #[test]\n             fn test_div_floor() {\n-                assert_eq!((8 as $T).div_floor(3), 2);\n+                assert_eq!((8 as $T).unstable_div_floor(3), 2);\n             }\n \n             #[test]\n             fn test_div_ceil() {\n-                assert_eq!((8 as $T).div_ceil(3), 3);\n+                assert_eq!((8 as $T).unstable_div_ceil(3), 3);\n             }\n \n             #[test]\n             fn test_next_multiple_of() {\n-                assert_eq!((16 as $T).next_multiple_of(8), 16);\n-                assert_eq!((23 as $T).next_multiple_of(8), 24);\n-                assert_eq!(MAX.next_multiple_of(1), MAX);\n+                assert_eq!((16 as $T).unstable_next_multiple_of(8), 16);\n+                assert_eq!((23 as $T).unstable_next_multiple_of(8), 24);\n+                assert_eq!(MAX.unstable_next_multiple_of(1), MAX);\n             }\n \n             #[test]"}, {"sha": "8487a5f8b50d3215790285d4841ac2ec1021afc4", "filename": "library/std/src/sync/mpsc/shared.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -248,7 +248,11 @@ impl<T> Packet<T> {\n     // Returns true if blocking should proceed.\n     fn decrement(&self, token: SignalToken) -> StartResult {\n         unsafe {\n-            assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n+            assert_eq!(\n+                self.to_wake.load(Ordering::SeqCst),\n+                0,\n+                \"This is a known bug in the Rust standard library. See https://github.com/rust-lang/rust/issues/39364\"\n+            );\n             let ptr = token.cast_to_usize();\n             self.to_wake.store(ptr, Ordering::SeqCst);\n "}, {"sha": "cba558df777a045b5657d56c29944e9e8fd3a776", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1 +1 @@\n-Subproject commit 86c7daa627aefda1371568b948eba21edf720747\n+Subproject commit cba558df777a045b5657d56c29944e9e8fd3a776"}, {"sha": "4ba296ee04a1a5218acb1117d72c1ee4740eca42", "filename": "src/test/rustdoc/cross-crate-primitive-doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1,6 +1,6 @@\n // aux-build:primitive-doc.rs\n // compile-flags: --extern-html-root-url=primitive_doc=../ -Z unstable-options\n-// ignore-windows\n+// only-linux\n \n #![feature(no_core)]\n #![no_core]"}, {"sha": "9d869984bbd7ce7e1d6333df122ae3fcdd9c267e", "filename": "src/test/rustdoc/intra-doc/prim-methods-external-core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-methods-external-core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-methods-external-core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-methods-external-core.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1,7 +1,7 @@\n // aux-build:my-core.rs\n // build-aux-docs\n // ignore-cross-compile\n-// ignore-windows\n+// only-linux\n \n #![deny(broken_intra_doc_links)]\n #![feature(no_core, lang_items)]"}, {"sha": "f5f75f9f4dac5dbf9e62307de61b8d792f204641", "filename": "src/test/ui/attributes/extented-attribute-macro-error.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fattributes%2Fextented-attribute-macro-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fattributes%2Fextented-attribute-macro-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fextented-attribute-macro-error.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,8 @@\n+// normalize-stderr-test: \"couldn't read.*\" -> \"couldn't read the file\"\n+\n+#![feature(extended_key_value_attributes)]\n+#![doc = include_str!(\"../not_existing_file.md\")]\n+struct Documented {}\n+//~^^ ERROR couldn't read\n+\n+fn main() {}"}, {"sha": "e4deeacd0ff605f676e406681bac632f19f5e05f", "filename": "src/test/ui/attributes/extented-attribute-macro-error.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fattributes%2Fextented-attribute-macro-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fattributes%2Fextented-attribute-macro-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fextented-attribute-macro-error.stderr?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,10 @@\n+error: couldn't read the file\n+  --> $DIR/extented-attribute-macro-error.rs:4:10\n+   |\n+LL | #![doc = include_str!(\"../not_existing_file.md\")]\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `include_str` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "fbaa874792a0180031fb706523a303daac511232", "filename": "src/test/ui/coercion/coerce-issue-49593-box-never.nofallback.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `(): std::error::Error` is not satisfied\n+  --> $DIR/coerce-issue-49593-box-never.rs:17:53\n+   |\n+LL |     /* *mut $0 is coerced to Box<dyn Error> here */ Box::<_ /* ! */>::new(x)\n+   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::error::Error` is not implemented for `()`\n+   |\n+   = note: required for the cast to the object type `dyn std::error::Error`\n+\n+error[E0277]: the trait bound `(): std::error::Error` is not satisfied\n+  --> $DIR/coerce-issue-49593-box-never.rs:22:49\n+   |\n+LL |     /* *mut $0 is coerced to *mut Error here */ raw_ptr_box::<_ /* ! */>(x)\n+   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::error::Error` is not implemented for `()`\n+   |\n+   = note: required for the cast to the object type `(dyn std::error::Error + 'static)`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "7a4324bd5adcedd124b9473e4e742cb1ea3fd4e8", "filename": "src/test/ui/coercion/coerce-issue-49593-box-never.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1,5 +1,9 @@\n-// check-pass\n-#![feature(never_type, never_type_fallback)]\n+// revisions: nofallback fallback\n+//[fallback] check-pass\n+//[nofallback] check-fail\n+\n+#![feature(never_type)]\n+#![cfg_attr(fallback, feature(never_type_fallback))]\n #![allow(unreachable_code)]\n \n use std::error::Error;\n@@ -11,10 +15,12 @@ fn raw_ptr_box<T>(t: T) -> *mut T {\n \n fn foo(x: !) -> Box<dyn Error> {\n     /* *mut $0 is coerced to Box<dyn Error> here */ Box::<_ /* ! */>::new(x)\n+    //[nofallback]~^ ERROR trait bound `(): std::error::Error` is not satisfied\n }\n \n fn foo_raw_ptr(x: !) -> *mut dyn Error {\n     /* *mut $0 is coerced to *mut Error here */ raw_ptr_box::<_ /* ! */>(x)\n+    //[nofallback]~^ ERROR trait bound `(): std::error::Error` is not satisfied\n }\n \n fn no_coercion(d: *mut dyn Error) -> *mut dyn Error {"}, {"sha": "634ff14869eb4d371384f31a382a5d4b93a66005", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -34,7 +34,7 @@ note: ...which requires type-checking `cycle1`...\n    |\n LL |     send(cycle2().clone());\n    |     ^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n+   = note: ...which requires evaluating trait selection obligation `impl core::clone::Clone: core::marker::Send`...\n note: ...which requires computing type of `cycle2::{opaque#0}`...\n   --> $DIR/auto-trait-leak.rs:19:16\n    |\n@@ -70,7 +70,7 @@ note: ...which requires type-checking `cycle2`...\n    |\n LL |     send(cycle1().clone());\n    |     ^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n+   = note: ...which requires evaluating trait selection obligation `impl core::clone::Clone: core::marker::Send`...\n    = note: ...which again requires computing type of `cycle1::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/auto-trait-leak.rs:1:1"}, {"sha": "50f1a2f25b95d5df556f7e37d086e4349138b889", "filename": "src/test/ui/intrinsics/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -2,6 +2,7 @@\n // ignore-wasm32-bare compiled with panic=abort by default\n // revisions: mir thir\n // [thir]compile-flags: -Zthir-unsafeck\n+// ignore-tidy-linelength\n \n // This test checks panic emitted from `mem::{uninitialized,zeroed}`.\n \n@@ -114,11 +115,11 @@ fn main() {\n \n         test_panic_msg(\n             || mem::uninitialized::<*const dyn Send>(),\n-            \"attempted to leave type `*const dyn std::marker::Send` uninitialized, which is invalid\"\n+            \"attempted to leave type `*const dyn core::marker::Send` uninitialized, which is invalid\"\n         );\n         test_panic_msg(\n             || mem::zeroed::<*const dyn Send>(),\n-            \"attempted to zero-initialize type `*const dyn std::marker::Send`, which is invalid\"\n+            \"attempted to zero-initialize type `*const dyn core::marker::Send`, which is invalid\"\n         );\n \n         /* FIXME(#66151) we conservatively do not error here yet.\n@@ -145,12 +146,12 @@ fn main() {\n \n         test_panic_msg(\n             || mem::uninitialized::<(NonNull<u32>, u32, u32)>(),\n-            \"attempted to leave type `(std::ptr::NonNull<u32>, u32, u32)` uninitialized, \\\n+            \"attempted to leave type `(core::ptr::non_null::NonNull<u32>, u32, u32)` uninitialized, \\\n                 which is invalid\"\n         );\n         test_panic_msg(\n             || mem::zeroed::<(NonNull<u32>, u32, u32)>(),\n-            \"attempted to zero-initialize type `(std::ptr::NonNull<u32>, u32, u32)`, \\\n+            \"attempted to zero-initialize type `(core::ptr::non_null::NonNull<u32>, u32, u32)`, \\\n                 which is invalid\"\n         );\n \n@@ -187,7 +188,7 @@ fn main() {\n         );\n         test_panic_msg(\n             || mem::uninitialized::<ManuallyDrop<LR>>(),\n-            \"attempted to leave type `std::mem::ManuallyDrop<LR>` uninitialized, which is invalid\"\n+            \"attempted to leave type `core::mem::manually_drop::ManuallyDrop<LR>` uninitialized, which is invalid\"\n         );\n \n         // Some things that should work."}, {"sha": "588d644c77b0dc159d5a056c30fb087d339bb400", "filename": "src/test/ui/never_type/defaulted-never-note.fallback.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.fallback.stderr?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `!: ImplementedForUnitButNotNever` is not satisfied\n-  --> $DIR/defaulted-never-note.rs:26:5\n+  --> $DIR/defaulted-never-note.rs:30:5\n    |\n LL |     foo(_x);\n    |     ^^^ the trait `ImplementedForUnitButNotNever` is not implemented for `!`\n@@ -8,7 +8,7 @@ LL |     foo(_x);\n    = note: this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information).\n    = help: did you intend to use the type `()` here instead?\n note: required by a bound in `foo`\n-  --> $DIR/defaulted-never-note.rs:21:11\n+  --> $DIR/defaulted-never-note.rs:25:11\n    |\n LL | fn foo<T: ImplementedForUnitButNotNever>(_t: T) {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `foo`", "previous_filename": "src/test/ui/never_type/defaulted-never-note.stderr"}, {"sha": "54f551759cb3926f9cf7cdf02865e6c171bd64ff", "filename": "src/test/ui/never_type/defaulted-never-note.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1,6 +1,10 @@\n+// revisions: nofallback fallback\n+//[nofallback] run-pass\n+//[fallback] check-fail\n+\n // We need to opt into the `never_type_fallback` feature\n // to trigger the requirement that this is testing.\n-#![feature(never_type, never_type_fallback)]\n+#![cfg_attr(fallback, feature(never_type, never_type_fallback))]\n \n #![allow(unused)]\n \n@@ -19,16 +23,16 @@ trait ImplementedForUnitButNotNever {}\n impl ImplementedForUnitButNotNever for () {}\n \n fn foo<T: ImplementedForUnitButNotNever>(_t: T) {}\n-//~^ NOTE required by this bound in `foo`\n-//~| NOTE required by a bound in `foo`\n+//[fallback]~^ NOTE required by this bound in `foo`\n+//[fallback]~| NOTE required by a bound in `foo`\n fn smeg() {\n     let _x = return;\n     foo(_x);\n-    //~^ ERROR the trait bound\n-    //~| NOTE the trait `ImplementedForUnitButNotNever` is not implemented\n-    //~| NOTE this trait is implemented for `()`\n-    //~| NOTE this error might have been caused\n-    //~| HELP did you intend\n+    //[fallback]~^ ERROR the trait bound\n+    //[fallback]~| NOTE the trait `ImplementedForUnitButNotNever` is not implemented\n+    //[fallback]~| NOTE this trait is implemented for `()`\n+    //[fallback]~| NOTE this error might have been caused\n+    //[fallback]~| HELP did you intend\n }\n \n fn main() {"}, {"sha": "45a3362fa6d8ea07dc6eab46c26da2bbe14182ba", "filename": "src/test/ui/never_type/diverging-fallback-control-flow.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-control-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-control-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-control-flow.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1,30 +1,28 @@\n+// revisions: nofallback fallback\n // run-pass\n \n #![allow(dead_code)]\n #![allow(unused_assignments)]\n #![allow(unused_variables)]\n #![allow(unreachable_code)]\n-\n // Test various cases where we permit an unconstrained variable\n-// to fallback based on control-flow.\n-//\n-// These represent current behavior, but are pretty dubious.  I would\n-// like to revisit these and potentially change them. --nmatsakis\n-\n-#![feature(never_type, never_type_fallback)]\n+// to fallback based on control-flow. In all of these cases,\n+// the type variable winds up being the target of both a `!` coercion\n+// and a coercion from a non-`!` variable, and hence falls back to `()`.\n+#![cfg_attr(fallback, feature(never_type, never_type_fallback))]\n \n-trait BadDefault {\n+trait UnitDefault {\n     fn default() -> Self;\n }\n \n-impl BadDefault for u32 {\n+impl UnitDefault for u32 {\n     fn default() -> Self {\n         0\n     }\n }\n \n-impl BadDefault for ! {\n-    fn default() -> ! {\n+impl UnitDefault for () {\n+    fn default() -> () {\n         panic!()\n     }\n }\n@@ -33,7 +31,7 @@ fn assignment() {\n     let x;\n \n     if true {\n-        x = BadDefault::default();\n+        x = UnitDefault::default();\n     } else {\n         x = return;\n     }\n@@ -45,13 +43,13 @@ fn assignment_rev() {\n     if true {\n         x = return;\n     } else {\n-        x = BadDefault::default();\n+        x = UnitDefault::default();\n     }\n }\n \n fn if_then_else() {\n     let _x = if true {\n-        BadDefault::default()\n+        UnitDefault::default()\n     } else {\n         return;\n     };\n@@ -61,19 +59,19 @@ fn if_then_else_rev() {\n     let _x = if true {\n         return;\n     } else {\n-        BadDefault::default()\n+        UnitDefault::default()\n     };\n }\n \n fn match_arm() {\n-    let _x = match Ok(BadDefault::default()) {\n+    let _x = match Ok(UnitDefault::default()) {\n         Ok(v) => v,\n         Err(()) => return,\n     };\n }\n \n fn match_arm_rev() {\n-    let _x = match Ok(BadDefault::default()) {\n+    let _x = match Ok(UnitDefault::default()) {\n         Err(()) => return,\n         Ok(v) => v,\n     };\n@@ -84,7 +82,7 @@ fn loop_break() {\n         if false {\n             break return;\n         } else {\n-            break BadDefault::default();\n+            break UnitDefault::default();\n         }\n     };\n }\n@@ -94,9 +92,9 @@ fn loop_break_rev() {\n         if false {\n             break return;\n         } else {\n-            break BadDefault::default();\n+            break UnitDefault::default();\n         }\n     };\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "3a5b602f1118fc196623978bf86cef4b2135b583", "filename": "src/test/ui/never_type/diverging-fallback-no-leak.fallback.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.fallback.stderr?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `!: Test` is not satisfied\n+  --> $DIR/diverging-fallback-no-leak.rs:17:5\n+   |\n+LL |     unconstrained_arg(return);\n+   |     ^^^^^^^^^^^^^^^^^ the trait `Test` is not implemented for `!`\n+   |\n+   = note: this trait is implemented for `()`.\n+   = note: this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information).\n+   = help: did you intend to use the type `()` here instead?\n+note: required by a bound in `unconstrained_arg`\n+  --> $DIR/diverging-fallback-no-leak.rs:12:25\n+   |\n+LL | fn unconstrained_arg<T: Test>(_: T) {}\n+   |                         ^^^^ required by this bound in `unconstrained_arg`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "03478e19ddcddbb5bf57adf7c147a5ce4c3b1058", "filename": "src/test/ui/never_type/diverging-fallback-no-leak.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,19 @@\n+// revisions: nofallback fallback\n+//[nofallback] check-pass\n+\n+#![cfg_attr(fallback, feature(never_type, never_type_fallback))]\n+\n+fn make_unit() {}\n+\n+trait Test {}\n+impl Test for i32 {}\n+impl Test for () {}\n+\n+fn unconstrained_arg<T: Test>(_: T) {}\n+\n+fn main() {\n+    // Here the type variable falls back to `!`,\n+    // and hence we get a type error.\n+    unconstrained_arg(return);\n+    //[fallback]~^ ERROR trait bound `!: Test` is not satisfied\n+}"}, {"sha": "7ea97126f89c992c12111a802dfec18142219318", "filename": "src/test/ui/never_type/diverging-fallback-unconstrained-return.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-unconstrained-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-unconstrained-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-unconstrained-return.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,37 @@\n+// Variant of diverging-falllback-control-flow that tests\n+// the specific case of a free function with an unconstrained\n+// return type. This captures the pattern we saw in the wild\n+// in the objc crate, where changing the fallback from `!` to `()`\n+// resulted in unsoundness.\n+//\n+// check-pass\n+\n+// revisions: nofallback fallback\n+\n+#![cfg_attr(fallback, feature(never_type, never_type_fallback))]\n+\n+\n+fn make_unit() {}\n+\n+trait UnitReturn {}\n+impl UnitReturn for i32 {}\n+impl UnitReturn for () {}\n+\n+fn unconstrained_return<T: UnitReturn>() -> T {\n+    unsafe {\n+        let make_unit_fn: fn() = make_unit;\n+        let ffi: fn() -> T = std::mem::transmute(make_unit_fn);\n+        ffi()\n+    }\n+}\n+\n+fn main() {\n+    // In Ye Olde Days, the `T` parameter of `unconstrained_return`\n+    // winds up \"entangled\" with the `!` type that results from\n+    // `panic!`, and hence falls back to `()`. This is kind of unfortunate\n+    // and unexpected. When we introduced the `!` type, the original\n+    // idea was to change that fallback to `!`, but that would have resulted\n+    // in this code no longer compiling (or worse, in some cases it injected\n+    // unsound results).\n+    let _ = if true { unconstrained_return() } else { panic!() };\n+}"}, {"sha": "5c8ce48cbb0b6abf750b6bc99bebb778222399f8", "filename": "src/test/ui/never_type/fallback-closure-ret.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-ret.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,23 @@\n+// This test verifies that never type fallback preserves the following code in a\n+// compiling state. This pattern is fairly common in the wild, notably seen in\n+// wasmtime v0.16. Typically this is some closure wrapper that expects a\n+// collection of 'known' signatures, and -> ! is not included in that set.\n+//\n+// This test is specifically targeted by the unit type fallback when\n+// encountering a set of obligations like `?T: Foo` and `Trait::Projection =\n+// ?T`. In the code below, these are `R: Bar` and `Fn::Output = R`.\n+//\n+// revisions: nofallback fallback\n+// check-pass\n+\n+#![cfg_attr(fallback, feature(never_type_fallback))]\n+\n+trait Bar { }\n+impl Bar for () {  }\n+impl Bar for u32 {  }\n+\n+fn foo<R: Bar>(_: impl Fn() -> R) {}\n+\n+fn main() {\n+    foo(|| panic!());\n+}"}, {"sha": "78d1a3caf4a30e379e01860e4b3fb3a65535aa4a", "filename": "src/test/ui/never_type/fallback-closure-wrap.fallback.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,17 @@\n+error[E0271]: type mismatch resolving `<[closure@$DIR/fallback-closure-wrap.rs:18:40: 21:6] as FnOnce<()>>::Output == ()`\n+  --> $DIR/fallback-closure-wrap.rs:18:31\n+   |\n+LL |       let error = Closure::wrap(Box::new(move || {\n+   |  _______________________________^\n+LL | |\n+LL | |         panic!(\"Can't connect to server.\");\n+LL | |     }) as Box<dyn FnMut()>);\n+   | |______^ expected `()`, found `!`\n+   |\n+   = note: expected unit type `()`\n+                   found type `!`\n+   = note: required for the cast to the object type `dyn FnMut()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "af0577ac0609fcb24d9eaad0302819b6f5787771", "filename": "src/test/ui/never_type/fallback-closure-wrap.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,30 @@\n+// This is a minified example from Crater breakage observed when attempting to\n+// stabilize never type, nstoddard/webgl-gui @ 22f0169f.\n+//\n+// This particular test case currently fails as the inference to `()` rather\n+// than `!` happens as a result of an `as` cast, which is not currently tracked.\n+// Crater did not find many cases of this occuring, but it is included for\n+// awareness.\n+//\n+// revisions: nofallback fallback\n+//[nofallback] check-pass\n+//[fallback] check-fail\n+\n+#![cfg_attr(fallback, feature(never_type_fallback))]\n+\n+use std::marker::PhantomData;\n+\n+fn main() {\n+    let error = Closure::wrap(Box::new(move || {\n+        //[fallback]~^ ERROR type mismatch resolving\n+        panic!(\"Can't connect to server.\");\n+    }) as Box<dyn FnMut()>);\n+}\n+\n+struct Closure<T: ?Sized>(PhantomData<T>);\n+\n+impl<T: ?Sized> Closure<T> {\n+    fn wrap(data: Box<T>) -> Closure<T> {\n+        todo!()\n+    }\n+}"}, {"sha": "f374266626bcc4c517d47de601b08ab3231f44ca", "filename": "src/test/ui/never_type/never-value-fallback-issue-66757.nofallback.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.nofallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.nofallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.nofallback.stderr?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,17 @@\n+error[E0277]: the trait bound `E: From<()>` is not satisfied\n+  --> $DIR/never-value-fallback-issue-66757.rs:27:5\n+   |\n+LL |     <E as From<_>>::from(never);\n+   |     ^^^^^^^^^^^^^^^^^^^^ the trait `From<()>` is not implemented for `E`\n+   |\n+   = help: the following implementations were found:\n+             <E as From<!>>\n+note: required by `from`\n+  --> $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+   |\n+LL |     fn from(_: T) -> Self;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "6dc7e6ad2d93de43f267af45bfa69836d55cfbe4", "filename": "src/test/ui/never_type/never-value-fallback-issue-66757.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -4,12 +4,13 @@\n // never) and an uninferred variable (here the argument to `From`) it\n // doesn't fallback to `()` but rather `!`.\n //\n-// run-pass\n+// revisions: nofallback fallback\n+//[fallback] run-pass\n+//[nofallback] check-fail\n \n #![feature(never_type)]\n \n-// FIXME(#67225) -- this should be true even without the fallback gate.\n-#![feature(never_type_fallback)]\n+#![cfg_attr(fallback, feature(never_type_fallback))]\n \n struct E;\n \n@@ -23,7 +24,7 @@ impl From<!> for E {\n #[allow(dead_code)]\n fn foo(never: !) {\n     <E as From<!>>::from(never);  // Ok\n-    <E as From<_>>::from(never);  // Inference fails here\n+    <E as From<_>>::from(never);  //[nofallback]~ ERROR trait bound `E: From<()>` is not satisfied\n }\n \n fn main() { }"}, {"sha": "4fd5622b0626ce8949770710dd9b0f2d2ad3e47d", "filename": "src/test/ui/recursion/issue-26548-recursion-via-normalize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1,8 +1,8 @@\n //~ ERROR cycle detected when computing layout of `S`\n-//~| NOTE ...which requires computing layout of `std::option::Option<<S as Mirror>::It>`...\n-//~| NOTE ...which requires computing layout of `std::option::Option<S>`...\n+//~| NOTE ...which requires computing layout of `core::option::Option<<S as Mirror>::It>`...\n+//~| NOTE ...which requires computing layout of `core::option::Option<S>`...\n //~| NOTE ...which again requires computing layout of `S`, completing the cycle\n-//~| NOTE cycle used when computing layout of `std::option::Option<S>`\n+//~| NOTE cycle used when computing layout of `core::option::Option<S>`\n \n // build-fail\n "}, {"sha": "6042379a91887c4bbe2bd5239f0fd1f685a531a4", "filename": "src/test/ui/recursion/issue-26548-recursion-via-normalize.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -1,9 +1,9 @@\n error[E0391]: cycle detected when computing layout of `S`\n    |\n-   = note: ...which requires computing layout of `std::option::Option<<S as Mirror>::It>`...\n-   = note: ...which requires computing layout of `std::option::Option<S>`...\n+   = note: ...which requires computing layout of `core::option::Option<<S as Mirror>::It>`...\n+   = note: ...which requires computing layout of `core::option::Option<S>`...\n    = note: ...which again requires computing layout of `S`, completing the cycle\n-   = note: cycle used when computing layout of `std::option::Option<S>`\n+   = note: cycle used when computing layout of `core::option::Option<S>`\n \n error: aborting due to previous error\n "}, {"sha": "cc4120041b9865e7215259af4ec5ef3a50793dc2", "filename": "src/test/ui/suggestions/missing-type-param-used-in-param.fixed", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-type-param-used-in-param.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-type-param-used-in-param.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-type-param-used-in-param.fixed?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+\n+fn two_type_params<A, B>(_: B) {}\n+\n+fn main() {\n+    two_type_params::<String, _>(100); //~ ERROR this function takes 2 generic arguments\n+    two_type_params::<String, _>(100);\n+}"}, {"sha": "19286331b60232d7c21cdf485310beab74d9eda1", "filename": "src/test/ui/suggestions/missing-type-param-used-in-param.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-type-param-used-in-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-type-param-used-in-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-type-param-used-in-param.rs?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+\n+fn two_type_params<A, B>(_: B) {}\n+\n+fn main() {\n+    two_type_params::<String>(100); //~ ERROR this function takes 2 generic arguments\n+    two_type_params::<String, _>(100);\n+}"}, {"sha": "4f7058a6492596ad1382c9050548042c8333661b", "filename": "src/test/ui/suggestions/missing-type-param-used-in-param.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-type-param-used-in-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-type-param-used-in-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-type-param-used-in-param.stderr?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -0,0 +1,21 @@\n+error[E0107]: this function takes 2 generic arguments but 1 generic argument was supplied\n+  --> $DIR/missing-type-param-used-in-param.rs:6:5\n+   |\n+LL |     two_type_params::<String>(100);\n+   |     ^^^^^^^^^^^^^^^   ------ supplied 1 generic argument\n+   |     |\n+   |     expected 2 generic arguments\n+   |\n+note: function defined here, with 2 generic parameters: `A`, `B`\n+  --> $DIR/missing-type-param-used-in-param.rs:3:4\n+   |\n+LL | fn two_type_params<A, B>(_: B) {}\n+   |    ^^^^^^^^^^^^^^^ -  -\n+help: add missing generic argument\n+   |\n+LL |     two_type_params::<String, _>(100);\n+   |                             +++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "c0147e56c9364a6bb2d3f99d8c1f014a20768539", "filename": "src/test/ui/type-alias-impl-trait/auto-trait-leakage3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -9,7 +9,7 @@ note: ...which requires type-checking `m::bar`...\n    |\n LL |         is_send(foo());\n    |         ^^^^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl std::fmt::Debug: std::marker::Send`...\n+   = note: ...which requires evaluating trait selection obligation `impl core::fmt::Debug: core::marker::Send`...\n    = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in module `m`\n   --> $DIR/auto-trait-leakage3.rs:6:1"}, {"sha": "e12124664778ed249087f4e88bb0011577b7e323", "filename": "src/test/ui/type-alias-impl-trait/inference-cycle.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb1c06fdd8921071a353b70d4752d834a76c5f94/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.stderr?ref=cb1c06fdd8921071a353b70d4752d834a76c5f94", "patch": "@@ -9,7 +9,7 @@ note: ...which requires type-checking `m::bar`...\n    |\n LL |         is_send(foo()); // Today: error\n    |         ^^^^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl std::fmt::Debug: std::marker::Send`...\n+   = note: ...which requires evaluating trait selection obligation `impl core::fmt::Debug: core::marker::Send`...\n    = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in module `m`\n   --> $DIR/inference-cycle.rs:4:1"}]}