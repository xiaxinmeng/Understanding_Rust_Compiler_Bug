{"sha": "13161ab738af83a60205ab26d9da9f7ea8db855e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMTYxYWI3MzhhZjgzYTYwMjA1YWIyNmQ5ZGE5ZjdlYThkYjg1NWU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-04T14:04:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-04T14:04:01Z"}, "message": "Merge #9489\n\n9489: feat: always prefer postfix snippets if there's exact textual match r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "5cf409ee63e67d9fe4bf5c5a950a9d21099e3d35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cf409ee63e67d9fe4bf5c5a950a9d21099e3d35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13161ab738af83a60205ab26d9da9f7ea8db855e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg4b/RCRBK7hj4Ov3rIwAA+HAIABRs2bl60/KMdFbBsp6aNcDL\nfHD5x0dM0j5Bq3upPFFemn5uwxSvNbzDef4nA3GtyMMHfJDFOiK9/HbSiXcYl56m\nzZddDejTsqAfto/57ajxmrX16e99wPnsJNbDh69PdM2FM8h0qNl7LsDniPtW4O55\npd+R/qM5zGxYQsHcg9r8apS2WP2jb+mx1B7pA0MwmfPpDmUDnkQ6JNQ8eqHbz33J\nYEHsyrm5uMLCyE0Y309Yb9bwe+a94Zngmhq88rItDmI8sXNzZ0ENwGlqJOJmFwTT\n4TwrzPCecnGNwndKW1FeWzthfnn03kvhOckY7gPiB5dIuhmZEbC64YVp2yRe9TM=\n=+ht9\n-----END PGP SIGNATURE-----\n", "payload": "tree 5cf409ee63e67d9fe4bf5c5a950a9d21099e3d35\nparent 030217d573691f36c34fb3664e13a441e23aafa0\nparent 9b3292541c74b8de48a0dc11b3ce56800d812f86\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1625407441 +0000\ncommitter GitHub <noreply@github.com> 1625407441 +0000\n\nMerge #9489\n\n9489: feat: always prefer postfix snippets if there's exact textual match r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13161ab738af83a60205ab26d9da9f7ea8db855e", "html_url": "https://github.com/rust-lang/rust/commit/13161ab738af83a60205ab26d9da9f7ea8db855e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13161ab738af83a60205ab26d9da9f7ea8db855e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "030217d573691f36c34fb3664e13a441e23aafa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/030217d573691f36c34fb3664e13a441e23aafa0", "html_url": "https://github.com/rust-lang/rust/commit/030217d573691f36c34fb3664e13a441e23aafa0"}, {"sha": "9b3292541c74b8de48a0dc11b3ce56800d812f86", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b3292541c74b8de48a0dc11b3ce56800d812f86", "html_url": "https://github.com/rust-lang/rust/commit/9b3292541c74b8de48a0dc11b3ce56800d812f86"}], "stats": {"total": 143, "additions": 115, "deletions": 28}, "files": [{"sha": "aaa346eeae9aa0d5cf807130ca7706308fff88b0", "filename": "crates/ide_completion/src/completions/postfix.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13161ab738af83a60205ab26d9da9f7ea8db855e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13161ab738af83a60205ab26d9da9f7ea8db855e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=13161ab738af83a60205ab26d9da9f7ea8db855e", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     context::CompletionContext,\n     item::{Builder, CompletionKind},\n     patterns::ImmediateLocation,\n-    CompletionItem, CompletionItemKind, Completions,\n+    CompletionItem, CompletionItemKind, CompletionRelevance, Completions,\n };\n \n pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n@@ -299,6 +299,12 @@ fn postfix_snippet(\n     };\n     let mut item = CompletionItem::new(CompletionKind::Postfix, ctx.source_range(), label);\n     item.detail(detail).kind(CompletionItemKind::Snippet).snippet_edit(cap, edit);\n+    if ctx.original_token.text() == label {\n+        let mut relevance = CompletionRelevance::default();\n+        relevance.exact_postfix_snippet_match = true;\n+        item.set_relevance(relevance);\n+    }\n+\n     item\n }\n "}, {"sha": "96d3fcf5916bf39a72f4b42cbf946fcd5389f0df", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/13161ab738af83a60205ab26d9da9f7ea8db855e/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13161ab738af83a60205ab26d9da9f7ea8db855e/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=13161ab738af83a60205ab26d9da9f7ea8db855e", "patch": "@@ -144,6 +144,15 @@ pub struct CompletionRelevance {\n     /// }\n     /// ```\n     pub is_local: bool,\n+    /// This is set in cases like these:\n+    ///\n+    /// ```\n+    /// (a > b).not$0\n+    /// ```\n+    ///\n+    /// Basically, we want to guarantee that postfix snippets always takes\n+    /// precedence over everything else.\n+    pub exact_postfix_snippet_match: bool,\n }\n \n #[derive(Debug, Clone, Copy, Eq, PartialEq)]\n@@ -194,7 +203,9 @@ impl CompletionRelevance {\n         if self.is_local {\n             score += 1;\n         }\n-\n+        if self.exact_postfix_snippet_match {\n+            score += 100;\n+        }\n         score\n     }\n \n@@ -598,6 +609,13 @@ mod tests {\n                 exact_name_match: true,\n                 type_match: Some(CompletionRelevanceTypeMatch::Exact),\n                 is_local: true,\n+                ..CompletionRelevance::default()\n+            }],\n+            vec![CompletionRelevance {\n+                exact_name_match: false,\n+                type_match: None,\n+                is_local: false,\n+                exact_postfix_snippet_match: true,\n             }],\n         ];\n "}, {"sha": "f1ce3aa7130978ccdbadcab455cdbeabf2d44249", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 78, "deletions": 22, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/13161ab738af83a60205ab26d9da9f7ea8db855e/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13161ab738af83a60205ab26d9da9f7ea8db855e/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=13161ab738af83a60205ab26d9da9f7ea8db855e", "patch": "@@ -330,6 +330,8 @@ fn compute_ref_match(\n \n #[cfg(test)]\n mod tests {\n+    use std::cmp;\n+\n     use expect_test::{expect, Expect};\n     use itertools::Itertools;\n \n@@ -339,32 +341,25 @@ mod tests {\n         CompletionKind, CompletionRelevance,\n     };\n \n+    #[track_caller]\n     fn check(ra_fixture: &str, expect: Expect) {\n         let actual = do_completion(ra_fixture, CompletionKind::Reference);\n         expect.assert_debug_eq(&actual);\n     }\n \n+    #[track_caller]\n     fn check_relevance(ra_fixture: &str, expect: Expect) {\n-        fn display_relevance(relevance: CompletionRelevance) -> String {\n-            let relevance_factors = vec![\n-                (relevance.type_match == Some(CompletionRelevanceTypeMatch::Exact), \"type\"),\n-                (\n-                    relevance.type_match == Some(CompletionRelevanceTypeMatch::CouldUnify),\n-                    \"type_could_unify\",\n-                ),\n-                (relevance.exact_name_match, \"name\"),\n-                (relevance.is_local, \"local\"),\n-            ]\n-            .into_iter()\n-            .filter_map(|(cond, desc)| if cond { Some(desc) } else { None })\n-            .join(\"+\");\n+        check_relevance_for_kinds(&[CompletionKind::Reference], ra_fixture, expect)\n+    }\n \n-            format!(\"[{}]\", relevance_factors)\n-        }\n+    #[track_caller]\n+    fn check_relevance_for_kinds(kinds: &[CompletionKind], ra_fixture: &str, expect: Expect) {\n+        let mut actual = get_all_items(TEST_CONFIG, ra_fixture);\n+        actual.retain(|it| kinds.contains(&it.completion_kind));\n+        actual.sort_by_key(|it| cmp::Reverse(it.relevance().score()));\n \n-        let actual = get_all_items(TEST_CONFIG, ra_fixture)\n+        let actual = actual\n             .into_iter()\n-            .filter(|it| it.completion_kind == CompletionKind::Reference)\n             .flat_map(|it| {\n                 let mut items = vec![];\n \n@@ -384,6 +379,24 @@ mod tests {\n             .collect::<String>();\n \n         expect.assert_eq(&actual);\n+\n+        fn display_relevance(relevance: CompletionRelevance) -> String {\n+            let relevance_factors = vec![\n+                (relevance.type_match == Some(CompletionRelevanceTypeMatch::Exact), \"type\"),\n+                (\n+                    relevance.type_match == Some(CompletionRelevanceTypeMatch::CouldUnify),\n+                    \"type_could_unify\",\n+                ),\n+                (relevance.exact_name_match, \"name\"),\n+                (relevance.is_local, \"local\"),\n+                (relevance.exact_postfix_snippet_match, \"snippet\"),\n+            ]\n+            .into_iter()\n+            .filter_map(|(cond, desc)| if cond { Some(desc) } else { None })\n+            .join(\"+\");\n+\n+            format!(\"[{}]\", relevance_factors)\n+        }\n     }\n \n     #[test]\n@@ -528,6 +541,7 @@ fn main() { let _: m::Spam = S$0 }\n                                 Exact,\n                             ),\n                             is_local: false,\n+                            exact_postfix_snippet_match: false,\n                         },\n                         trigger_call_info: true,\n                     },\n@@ -556,6 +570,7 @@ fn main() { let _: m::Spam = S$0 }\n                                 Exact,\n                             ),\n                             is_local: false,\n+                            exact_postfix_snippet_match: false,\n                         },\n                     },\n                     CompletionItem {\n@@ -649,6 +664,7 @@ fn foo() { A { the$0 } }\n                                 CouldUnify,\n                             ),\n                             is_local: false,\n+                            exact_postfix_snippet_match: false,\n                         },\n                     },\n                 ]\n@@ -910,9 +926,9 @@ fn test(bar: u32) { }\n fn foo(s: S) { test(s.$0) }\n \"#,\n             expect![[r#\"\n-                fd foo []\n                 fd bar [type+name]\n                 fd baz [type]\n+                fd foo []\n             \"#]],\n         );\n     }\n@@ -926,9 +942,9 @@ struct B { x: (), y: f32, bar: u32 }\n fn foo(a: A) { B { bar: a.$0 }; }\n \"#,\n             expect![[r#\"\n-                fd foo []\n                 fd bar [type+name]\n                 fd baz [type]\n+                fd foo []\n             \"#]],\n         )\n     }\n@@ -956,9 +972,9 @@ fn f(foo: i64) {  }\n fn foo(a: A) { f(B { bar: a.$0 }); }\n \"#,\n             expect![[r#\"\n-                fd foo []\n                 fd bar [type+name]\n                 fd baz [type]\n+                fd foo []\n             \"#]],\n         );\n     }\n@@ -1004,9 +1020,9 @@ fn bar() -> u8 { 0 }\n fn f() { A { bar: b$0 }; }\n \"#,\n             expect![[r#\"\n+                fn bar() [type+name]\n                 fn baz() [type]\n                 st A []\n-                fn bar() [type+name]\n                 fn f() []\n             \"#]],\n         );\n@@ -1329,14 +1345,54 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n+                lc foo [type+local]\n                 ev Foo::A(\u2026) [type_could_unify]\n                 ev Foo::B [type_could_unify]\n-                lc foo [type+local]\n                 en Foo []\n                 fn baz() []\n                 fn bar() []\n                 fn foo() []\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn postfix_completion_relevance() {\n+        check_relevance_for_kinds(\n+            &[CompletionKind::Postfix, CompletionKind::Magic],\n+            r#\"\n+mod ops {\n+    pub trait Not {\n+        type Output;\n+        fn not(self) -> Self::Output;\n+    }\n+\n+    impl Not for bool {\n+        type Output = bool;\n+        fn not(self) -> bool { if self { false } else { true }}\n+    }\n+}\n+\n+fn main() {\n+    let _: bool = (9 > 2).not$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                sn not [snippet]\n+                me not() (ops::Not) [type_could_unify]\n+                sn if []\n+                sn while []\n+                sn ref []\n+                sn refm []\n+                sn match []\n+                sn box []\n+                sn ok []\n+                sn err []\n+                sn some []\n+                sn dbg []\n+                sn dbgr []\n+                sn call []\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "7b951b4e93cd3c1fc97e9f6fcbbcf91fe6475fe3", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/13161ab738af83a60205ab26d9da9f7ea8db855e/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13161ab738af83a60205ab26d9da9f7ea8db855e/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=13161ab738af83a60205ab26d9da9f7ea8db855e", "patch": "@@ -195,6 +195,7 @@ pub(crate) fn completion_items(\n     tdpp: lsp_types::TextDocumentPositionParams,\n     items: Vec<CompletionItem>,\n ) -> Vec<lsp_types::CompletionItem> {\n+    let max_relevance = items.iter().map(|it| it.relevance().score()).max().unwrap_or_default();\n     let mut res = Vec::with_capacity(items.len());\n     for item in items {\n         completion_item(\n@@ -203,6 +204,7 @@ pub(crate) fn completion_items(\n             enable_imports_on_the_fly,\n             line_index,\n             &tdpp,\n+            max_relevance,\n             item,\n         )\n     }\n@@ -215,6 +217,7 @@ fn completion_item(\n     enable_imports_on_the_fly: bool,\n     line_index: &LineIndex,\n     tdpp: &lsp_types::TextDocumentPositionParams,\n+    max_relevance: u32,\n     item: CompletionItem,\n ) {\n     let mut additional_text_edits = Vec::new();\n@@ -259,7 +262,7 @@ fn completion_item(\n         ..Default::default()\n     };\n \n-    set_score(&mut lsp_item, item.relevance());\n+    set_score(&mut lsp_item, max_relevance, item.relevance());\n \n     if item.deprecated() {\n         lsp_item.tags = Some(vec![lsp_types::CompletionItemTag::Deprecated])\n@@ -288,7 +291,7 @@ fn completion_item(\n \n     if let Some((mutability, relevance)) = item.ref_match() {\n         let mut lsp_item_with_ref = lsp_item.clone();\n-        set_score(&mut lsp_item_with_ref, relevance);\n+        set_score(&mut lsp_item_with_ref, max_relevance, relevance);\n         lsp_item_with_ref.label =\n             format!(\"&{}{}\", mutability.as_keyword_for_ref(), lsp_item_with_ref.label);\n         if let Some(it) = &mut lsp_item_with_ref.text_edit {\n@@ -304,8 +307,12 @@ fn completion_item(\n \n     acc.push(lsp_item);\n \n-    fn set_score(res: &mut lsp_types::CompletionItem, relevance: CompletionRelevance) {\n-        if relevance.is_relevant() {\n+    fn set_score(\n+        res: &mut lsp_types::CompletionItem,\n+        max_relevance: u32,\n+        relevance: CompletionRelevance,\n+    ) {\n+        if relevance.is_relevant() && relevance.score() == max_relevance {\n             res.preselect = Some(true);\n         }\n         // The relevance needs to be inverted to come up with a sort score"}]}