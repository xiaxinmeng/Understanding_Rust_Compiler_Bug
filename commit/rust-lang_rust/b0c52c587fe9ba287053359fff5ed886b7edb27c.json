{"sha": "b0c52c587fe9ba287053359fff5ed886b7edb27c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYzUyYzU4N2ZlOWJhMjg3MDUzMzU5ZmZmNWVkODg2YjdlZGIyN2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-13T07:24:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-13T07:24:53Z"}, "message": "Auto merge of #38909 - clarcharr:char_struct_display, r=alexcrichton\n\nImplement Display for char Escape*, To*case.\n\nSee: rust-lang/rfcs#1848.\n\nA good example of where this is useful would be in the example `print!(\"{}\", '\u00df'.to_uppercase())`.\n\nNot sure if this requires a formal RFC, but I decided to write the code for it anyway regardless.", "tree": {"sha": "b38e98ea95ce6bf2a9bb1e853cba5fcc305ff956", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b38e98ea95ce6bf2a9bb1e853cba5fcc305ff956"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0c52c587fe9ba287053359fff5ed886b7edb27c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0c52c587fe9ba287053359fff5ed886b7edb27c", "html_url": "https://github.com/rust-lang/rust/commit/b0c52c587fe9ba287053359fff5ed886b7edb27c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0c52c587fe9ba287053359fff5ed886b7edb27c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "927c55d86b0be44337f37cf5b0a76fb8ba86e06c", "url": "https://api.github.com/repos/rust-lang/rust/commits/927c55d86b0be44337f37cf5b0a76fb8ba86e06c", "html_url": "https://github.com/rust-lang/rust/commit/927c55d86b0be44337f37cf5b0a76fb8ba86e06c"}, {"sha": "3a79f2e2f1b1e07066f9e4a8fdc38816e5a0b6e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a79f2e2f1b1e07066f9e4a8fdc38816e5a0b6e7", "html_url": "https://github.com/rust-lang/rust/commit/3a79f2e2f1b1e07066f9e4a8fdc38816e5a0b6e7"}], "stats": {"total": 452, "additions": 277, "deletions": 175}, "files": [{"sha": "367422f55364a997d5a83b85d7e94820b37bde69", "filename": "src/libcore/char.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b0c52c587fe9ba287053359fff5ed886b7edb27c/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0c52c587fe9ba287053359fff5ed886b7edb27c/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=b0c52c587fe9ba287053359fff5ed886b7edb27c", "patch": "@@ -17,7 +17,7 @@\n \n use char_private::is_printable;\n use convert::TryFrom;\n-use fmt;\n+use fmt::{self, Write};\n use slice;\n use iter::FusedIterator;\n use mem::transmute;\n@@ -588,6 +588,16 @@ impl ExactSizeIterator for EscapeUnicode {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl FusedIterator for EscapeUnicode {}\n \n+#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+impl fmt::Display for EscapeUnicode {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for c in self.clone() {\n+            f.write_char(c)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n /// An iterator that yields the literal escape code of a `char`.\n ///\n /// This `struct` is created by the [`escape_default()`] method on [`char`]. See\n@@ -691,6 +701,16 @@ impl ExactSizeIterator for EscapeDefault {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl FusedIterator for EscapeDefault {}\n \n+#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+impl fmt::Display for EscapeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for c in self.clone() {\n+            f.write_char(c)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n /// An iterator that yields the literal escape code of a `char`.\n ///\n /// This `struct` is created by the [`escape_debug()`] method on [`char`]. See its\n@@ -715,6 +735,13 @@ impl ExactSizeIterator for EscapeDebug { }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl FusedIterator for EscapeDebug {}\n \n+#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+impl fmt::Display for EscapeDebug {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n \n \n /// An iterator over an iterator of bytes of the characters the bytes represent"}, {"sha": "e4012ec91e2b3f1fdd8a0132d934e01dac18ee03", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 99, "deletions": 125, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/b0c52c587fe9ba287053359fff5ed886b7edb27c/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0c52c587fe9ba287053359fff5ed886b7edb27c/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=b0c52c587fe9ba287053359fff5ed886b7edb27c", "patch": "@@ -75,47 +75,53 @@ fn test_to_digit() {\n \n #[test]\n fn test_to_lowercase() {\n-    fn lower(c: char) -> Vec<char> {\n-        c.to_lowercase().collect()\n+    fn lower(c: char) -> String {\n+        let iter: String = c.to_lowercase().collect();\n+        let disp: String = c.to_lowercase().to_string();\n+        assert_eq!(iter, disp);\n+        iter\n     }\n-    assert_eq!(lower('A'), ['a']);\n-    assert_eq!(lower('\u00d6'), ['\u00f6']);\n-    assert_eq!(lower('\u00df'), ['\u00df']);\n-    assert_eq!(lower('\u00dc'), ['\u00fc']);\n-    assert_eq!(lower('\ud83d\udca9'), ['\ud83d\udca9']);\n-    assert_eq!(lower('\u03a3'), ['\u03c3']);\n-    assert_eq!(lower('\u03a4'), ['\u03c4']);\n-    assert_eq!(lower('\u0399'), ['\u03b9']);\n-    assert_eq!(lower('\u0393'), ['\u03b3']);\n-    assert_eq!(lower('\u039c'), ['\u03bc']);\n-    assert_eq!(lower('\u0391'), ['\u03b1']);\n-    assert_eq!(lower('\u03a3'), ['\u03c3']);\n-    assert_eq!(lower('\u01c5'), ['\u01c6']);\n-    assert_eq!(lower('\ufb01'), ['\ufb01']);\n-    assert_eq!(lower('\u0130'), ['i', '\\u{307}']);\n+    assert_eq!(lower('A'), \"a\");\n+    assert_eq!(lower('\u00d6'), \"\u00f6\");\n+    assert_eq!(lower('\u00df'), \"\u00df\");\n+    assert_eq!(lower('\u00dc'), \"\u00fc\");\n+    assert_eq!(lower('\ud83d\udca9'), \"\ud83d\udca9\");\n+    assert_eq!(lower('\u03a3'), \"\u03c3\");\n+    assert_eq!(lower('\u03a4'), \"\u03c4\");\n+    assert_eq!(lower('\u0399'), \"\u03b9\");\n+    assert_eq!(lower('\u0393'), \"\u03b3\");\n+    assert_eq!(lower('\u039c'), \"\u03bc\");\n+    assert_eq!(lower('\u0391'), \"\u03b1\");\n+    assert_eq!(lower('\u03a3'), \"\u03c3\");\n+    assert_eq!(lower('\u01c5'), \"\u01c6\");\n+    assert_eq!(lower('\ufb01'), \"\ufb01\");\n+    assert_eq!(lower('\u0130'), \"i\\u{307}\");\n }\n \n #[test]\n fn test_to_uppercase() {\n-    fn upper(c: char) -> Vec<char> {\n-        c.to_uppercase().collect()\n+    fn upper(c: char) -> String {\n+        let iter: String = c.to_uppercase().collect();\n+        let disp: String = c.to_uppercase().to_string();\n+        assert_eq!(iter, disp);\n+        iter\n     }\n-    assert_eq!(upper('a'), ['A']);\n-    assert_eq!(upper('\u00f6'), ['\u00d6']);\n-    assert_eq!(upper('\u00df'), ['S', 'S']); // not \u1e9e: Latin capital letter sharp s\n-    assert_eq!(upper('\u00fc'), ['\u00dc']);\n-    assert_eq!(upper('\ud83d\udca9'), ['\ud83d\udca9']);\n-\n-    assert_eq!(upper('\u03c3'), ['\u03a3']);\n-    assert_eq!(upper('\u03c4'), ['\u03a4']);\n-    assert_eq!(upper('\u03b9'), ['\u0399']);\n-    assert_eq!(upper('\u03b3'), ['\u0393']);\n-    assert_eq!(upper('\u03bc'), ['\u039c']);\n-    assert_eq!(upper('\u03b1'), ['\u0391']);\n-    assert_eq!(upper('\u03c2'), ['\u03a3']);\n-    assert_eq!(upper('\u01c5'), ['\u01c4']);\n-    assert_eq!(upper('\ufb01'), ['F', 'I']);\n-    assert_eq!(upper('\u1f80'), ['\u1f08', '\u0399']);\n+    assert_eq!(upper('a'), \"A\");\n+    assert_eq!(upper('\u00f6'), \"\u00d6\");\n+    assert_eq!(upper('\u00df'), \"SS\"); // not \u1e9e: Latin capital letter sharp s\n+    assert_eq!(upper('\u00fc'), \"\u00dc\");\n+    assert_eq!(upper('\ud83d\udca9'), \"\ud83d\udca9\");\n+\n+    assert_eq!(upper('\u03c3'), \"\u03a3\");\n+    assert_eq!(upper('\u03c4'), \"\u03a4\");\n+    assert_eq!(upper('\u03b9'), \"\u0399\");\n+    assert_eq!(upper('\u03b3'), \"\u0393\");\n+    assert_eq!(upper('\u03bc'), \"\u039c\");\n+    assert_eq!(upper('\u03b1'), \"\u0391\");\n+    assert_eq!(upper('\u03c2'), \"\u03a3\");\n+    assert_eq!(upper('\u01c5'), \"\u01c4\");\n+    assert_eq!(upper('\ufb01'), \"FI\");\n+    assert_eq!(upper('\u1f80'), \"\u1f08\u0399\");\n }\n \n #[test]\n@@ -144,107 +150,75 @@ fn test_is_digit() {\n #[test]\n fn test_escape_debug() {\n     fn string(c: char) -> String {\n-        c.escape_debug().collect()\n+        let iter: String = c.escape_debug().collect();\n+        let disp: String = c.escape_debug().to_string();\n+        assert_eq!(iter, disp);\n+        iter\n     }\n-    let s = string('\\n');\n-    assert_eq!(s, \"\\\\n\");\n-    let s = string('\\r');\n-    assert_eq!(s, \"\\\\r\");\n-    let s = string('\\'');\n-    assert_eq!(s, \"\\\\'\");\n-    let s = string('\"');\n-    assert_eq!(s, \"\\\\\\\"\");\n-    let s = string(' ');\n-    assert_eq!(s, \" \");\n-    let s = string('a');\n-    assert_eq!(s, \"a\");\n-    let s = string('~');\n-    assert_eq!(s, \"~\");\n-    let s = string('\u00e9');\n-    assert_eq!(s, \"\u00e9\");\n-    let s = string('\u6587');\n-    assert_eq!(s, \"\u6587\");\n-    let s = string('\\x00');\n-    assert_eq!(s, \"\\\\u{0}\");\n-    let s = string('\\x1f');\n-    assert_eq!(s, \"\\\\u{1f}\");\n-    let s = string('\\x7f');\n-    assert_eq!(s, \"\\\\u{7f}\");\n-    let s = string('\\u{80}');\n-    assert_eq!(s, \"\\\\u{80}\");\n-    let s = string('\\u{ff}');\n-    assert_eq!(s, \"\\u{ff}\");\n-    let s = string('\\u{11b}');\n-    assert_eq!(s, \"\\u{11b}\");\n-    let s = string('\\u{1d4b6}');\n-    assert_eq!(s, \"\\u{1d4b6}\");\n-    let s = string('\\u{200b}'); // zero width space\n-    assert_eq!(s, \"\\\\u{200b}\");\n-    let s = string('\\u{e000}'); // private use 1\n-    assert_eq!(s, \"\\\\u{e000}\");\n-    let s = string('\\u{100000}'); // private use 2\n-    assert_eq!(s, \"\\\\u{100000}\");\n+    assert_eq!(string('\\n'), \"\\\\n\");\n+    assert_eq!(string('\\r'), \"\\\\r\");\n+    assert_eq!(string('\\''), \"\\\\'\");\n+    assert_eq!(string('\"'), \"\\\\\\\"\");\n+    assert_eq!(string(' '), \" \");\n+    assert_eq!(string('a'), \"a\");\n+    assert_eq!(string('~'), \"~\");\n+    assert_eq!(string('\u00e9'), \"\u00e9\");\n+    assert_eq!(string('\u6587'), \"\u6587\");\n+    assert_eq!(string('\\x00'), \"\\\\u{0}\");\n+    assert_eq!(string('\\x1f'), \"\\\\u{1f}\");\n+    assert_eq!(string('\\x7f'), \"\\\\u{7f}\");\n+    assert_eq!(string('\\u{80}'), \"\\\\u{80}\");\n+    assert_eq!(string('\\u{ff}'), \"\\u{ff}\");\n+    assert_eq!(string('\\u{11b}'), \"\\u{11b}\");\n+    assert_eq!(string('\\u{1d4b6}'), \"\\u{1d4b6}\");\n+    assert_eq!(string('\\u{200b}'),\"\\\\u{200b}\");      // zero width space\n+    assert_eq!(string('\\u{e000}'), \"\\\\u{e000}\");     // private use 1\n+    assert_eq!(string('\\u{100000}'), \"\\\\u{100000}\"); // private use 2\n }\n \n #[test]\n fn test_escape_default() {\n     fn string(c: char) -> String {\n-        c.escape_default().collect()\n+        let iter: String = c.escape_default().collect();\n+        let disp: String = c.escape_default().to_string();\n+        assert_eq!(iter, disp);\n+        iter\n     }\n-    let s = string('\\n');\n-    assert_eq!(s, \"\\\\n\");\n-    let s = string('\\r');\n-    assert_eq!(s, \"\\\\r\");\n-    let s = string('\\'');\n-    assert_eq!(s, \"\\\\'\");\n-    let s = string('\"');\n-    assert_eq!(s, \"\\\\\\\"\");\n-    let s = string(' ');\n-    assert_eq!(s, \" \");\n-    let s = string('a');\n-    assert_eq!(s, \"a\");\n-    let s = string('~');\n-    assert_eq!(s, \"~\");\n-    let s = string('\u00e9');\n-    assert_eq!(s, \"\\\\u{e9}\");\n-    let s = string('\\x00');\n-    assert_eq!(s, \"\\\\u{0}\");\n-    let s = string('\\x1f');\n-    assert_eq!(s, \"\\\\u{1f}\");\n-    let s = string('\\x7f');\n-    assert_eq!(s, \"\\\\u{7f}\");\n-    let s = string('\\u{80}');\n-    assert_eq!(s, \"\\\\u{80}\");\n-    let s = string('\\u{ff}');\n-    assert_eq!(s, \"\\\\u{ff}\");\n-    let s = string('\\u{11b}');\n-    assert_eq!(s, \"\\\\u{11b}\");\n-    let s = string('\\u{1d4b6}');\n-    assert_eq!(s, \"\\\\u{1d4b6}\");\n-    let s = string('\\u{200b}'); // zero width space\n-    assert_eq!(s, \"\\\\u{200b}\");\n-    let s = string('\\u{e000}'); // private use 1\n-    assert_eq!(s, \"\\\\u{e000}\");\n-    let s = string('\\u{100000}'); // private use 2\n-    assert_eq!(s, \"\\\\u{100000}\");\n+    assert_eq!(string('\\n'), \"\\\\n\");\n+    assert_eq!(string('\\r'), \"\\\\r\");\n+    assert_eq!(string('\\''), \"\\\\'\");\n+    assert_eq!(string('\"'), \"\\\\\\\"\");\n+    assert_eq!(string(' '), \" \");\n+    assert_eq!(string('a'), \"a\");\n+    assert_eq!(string('~'), \"~\");\n+    assert_eq!(string('\u00e9'), \"\\\\u{e9}\");\n+    assert_eq!(string('\\x00'), \"\\\\u{0}\");\n+    assert_eq!(string('\\x1f'), \"\\\\u{1f}\");\n+    assert_eq!(string('\\x7f'), \"\\\\u{7f}\");\n+    assert_eq!(string('\\u{80}'), \"\\\\u{80}\");\n+    assert_eq!(string('\\u{ff}'), \"\\\\u{ff}\");\n+    assert_eq!(string('\\u{11b}'), \"\\\\u{11b}\");\n+    assert_eq!(string('\\u{1d4b6}'), \"\\\\u{1d4b6}\");\n+    assert_eq!(string('\\u{200b}'), \"\\\\u{200b}\"); // zero width space\n+    assert_eq!(string('\\u{e000}'), \"\\\\u{e000}\"); // private use 1\n+    assert_eq!(string('\\u{100000}'), \"\\\\u{100000}\"); // private use 2\n }\n \n #[test]\n fn test_escape_unicode() {\n-    fn string(c: char) -> String { c.escape_unicode().collect() }\n-\n-    let s = string('\\x00');\n-    assert_eq!(s, \"\\\\u{0}\");\n-    let s = string('\\n');\n-    assert_eq!(s, \"\\\\u{a}\");\n-    let s = string(' ');\n-    assert_eq!(s, \"\\\\u{20}\");\n-    let s = string('a');\n-    assert_eq!(s, \"\\\\u{61}\");\n-    let s = string('\\u{11b}');\n-    assert_eq!(s, \"\\\\u{11b}\");\n-    let s = string('\\u{1d4b6}');\n-    assert_eq!(s, \"\\\\u{1d4b6}\");\n+    fn string(c: char) -> String {\n+        let iter: String = c.escape_unicode().collect();\n+        let disp: String = c.escape_unicode().to_string();\n+        assert_eq!(iter, disp);\n+        iter\n+    }\n+\n+    assert_eq!(string('\\x00'), \"\\\\u{0}\");\n+    assert_eq!(string('\\n'), \"\\\\u{a}\");\n+    assert_eq!(string(' '), \"\\\\u{20}\");\n+    assert_eq!(string('a'), \"\\\\u{61}\");\n+    assert_eq!(string('\\u{11b}'), \"\\\\u{11b}\");\n+    assert_eq!(string('\\u{1d4b6}'), \"\\\\u{1d4b6}\");\n }\n \n #[test]"}, {"sha": "f2c53efda173700e9e00e5c03151d4b66654aabf", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 150, "deletions": 49, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/b0c52c587fe9ba287053359fff5ed886b7edb27c/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0c52c587fe9ba287053359fff5ed886b7edb27c/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=b0c52c587fe9ba287053359fff5ed886b7edb27c", "patch": "@@ -30,7 +30,7 @@\n \n use core::char::CharExt as C;\n use core::iter::FusedIterator;\n-use core::fmt;\n+use core::fmt::{self, Write};\n use tables::{conversions, derived_property, general_category, property};\n \n // stable reexports\n@@ -131,6 +131,41 @@ impl Iterator for CaseMappingIter {\n     }\n }\n \n+#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+impl fmt::Display for CaseMappingIter {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            CaseMappingIter::Three(a, b, c) => {\n+                f.write_char(a)?;\n+                f.write_char(b)?;\n+                f.write_char(c)\n+            }\n+            CaseMappingIter::Two(b, c) => {\n+                f.write_char(b)?;\n+                f.write_char(c)\n+            }\n+            CaseMappingIter::One(c) => {\n+                f.write_char(c)\n+            }\n+            CaseMappingIter::Zero => Ok(()),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+impl fmt::Display for ToLowercase {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+impl fmt::Display for ToUppercase {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n #[lang = \"char\"]\n impl char {\n     /// Checks if a `char` is a digit in the given radix.\n@@ -240,77 +275,90 @@ impl char {\n     }\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a\n-    /// character, as `char`s.\n+    /// character as `char`s.\n     ///\n-    /// All characters are escaped with Rust syntax of the form `\\u{NNNNNN}`\n-    /// where `NNNNNN` is the shortest hexadecimal representation.\n+    /// This will escape characters with the Rust syntax of the form\n+    /// `\\u{NNNNNN}` where `NNNNNN` is a hexadecimal representation.\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n+    /// As an iterator:\n     ///\n     /// ```\n     /// for c in '\u2764'.escape_unicode() {\n     ///     print!(\"{}\", c);\n     /// }\n-    /// println!(\"\");\n+    /// println!();\n     /// ```\n     ///\n-    /// This prints:\n+    /// Using `println!` directly:\n     ///\n-    /// ```text\n-    /// \\u{2764}\n+    /// ```\n+    /// println!(\"{}\", '\u2764'.escape_unicode());\n     /// ```\n     ///\n-    /// Collecting into a `String`:\n+    /// Both are equivalent to:\n     ///\n     /// ```\n-    /// let heart: String = '\u2764'.escape_unicode().collect();\n+    /// println!(\"\\\\u{{2764}}\");\n+    /// ```\n     ///\n-    /// assert_eq!(heart, r\"\\u{2764}\");\n+    /// Using `to_string`:\n+    ///\n+    /// ```\n+    /// assert_eq!('\u2764'.escape_unicode().to_string(), \"\\\\u{2764}\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn escape_unicode(self) -> EscapeUnicode {\n         C::escape_unicode(self)\n     }\n \n-    /// Returns an iterator that yields the literal escape code of a `char`.\n+    /// Returns an iterator that yields the literal escape code of a character\n+    /// as `char`s.\n     ///\n     /// This will escape the characters similar to the `Debug` implementations\n     /// of `str` or `char`.\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n+    /// As an iterator:\n     ///\n     /// ```\n-    /// for i in '\\n'.escape_default() {\n-    ///     println!(\"{}\", i);\n+    /// # #![feature(char_escape_debug)]\n+    /// for c in '\\n'.escape_debug() {\n+    ///     print!(\"{}\", c);\n     /// }\n+    /// println!();\n     /// ```\n     ///\n-    /// This prints:\n+    /// Using `println!` directly:\n     ///\n-    /// ```text\n-    /// \\\n-    /// n\n+    /// ```\n+    /// # #![feature(char_escape_debug)]\n+    /// println!(\"{}\", '\\n'.escape_debug());\n     /// ```\n     ///\n-    /// Collecting into a `String`:\n+    /// Both are equivalent to:\n     ///\n     /// ```\n-    /// let quote: String = '\\n'.escape_default().collect();\n+    /// println!(\"\\\\n\");\n+    /// ```\n     ///\n-    /// assert_eq!(quote, \"\\\\n\");\n+    /// Using `to_string`:\n+    ///\n+    /// ```\n+    /// # #![feature(char_escape_debug)]\n+    /// assert_eq!('\\n'.escape_debug().to_string(), \"\\\\n\");\n     /// ```\n     #[unstable(feature = \"char_escape_debug\", issue = \"35068\")]\n     #[inline]\n     pub fn escape_debug(self) -> EscapeDebug {\n         C::escape_debug(self)\n     }\n \n-    /// Returns an iterator that yields the literal escape code of a `char`.\n+    /// Returns an iterator that yields the literal escape code of a character\n+    /// as `char`s.\n     ///\n     /// The default is chosen with a bias toward producing literals that are\n     /// legal in a variety of languages, including C++11 and similar C-family\n@@ -331,27 +379,32 @@ impl char {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n+    /// As an iterator:\n     ///\n     /// ```\n-    /// for i in '\"'.escape_default() {\n-    ///     println!(\"{}\", i);\n+    /// for c in '\"'.escape_default() {\n+    ///     print!(\"{}\", c);\n     /// }\n+    /// println!();\n     /// ```\n     ///\n-    /// This prints:\n+    /// Using `println!` directly:\n     ///\n-    /// ```text\n-    /// \\\n-    /// \"\n     /// ```\n+    /// println!(\"{}\", '\"'.escape_default());\n+    /// ```\n+    ///\n     ///\n-    /// Collecting into a `String`:\n+    /// Both are equivalent to:\n     ///\n     /// ```\n-    /// let quote: String = '\"'.escape_default().collect();\n+    /// println!(\"\\\\\\\"\");\n+    /// ```\n+    ///\n+    /// Using `to_string`:\n     ///\n-    /// assert_eq!(quote, \"\\\\\\\"\");\n+    /// ```\n+    /// assert_eq!('\"'.escape_default().to_string(), \"\\\\\\\"\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -726,9 +779,11 @@ impl char {\n         }\n     }\n \n-    /// Returns an iterator that yields the lowercase equivalent of a `char`.\n+    /// Returns an iterator that yields the lowercase equivalent of a `char`\n+    /// as one or more `char`s.\n     ///\n-    /// If no conversion is possible then an iterator with just the input character is returned.\n+    /// If a character does not have a lowercase equivalent, the same character\n+    /// will be returned back by the iterator.\n     ///\n     /// This performs complex unconditional mappings with no tailoring: it maps\n     /// one Unicode character to its lowercase equivalent according to the\n@@ -746,29 +801,52 @@ impl char {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n+    /// As an iterator:\n+    ///\n+    /// ```\n+    /// for c in '\u0130'.to_lowercase() {\n+    ///     print!(\"{}\", c);\n+    /// }\n+    /// println!();\n+    /// ```\n+    ///\n+    /// Using `println!` directly:\n+    ///\n+    /// ```\n+    /// println!(\"{}\", '\u0130'.to_lowercase());\n+    /// ```\n+    ///\n+    /// Both are equivalent to:\n+    ///\n+    /// ```\n+    /// println!(\"i\\u{307}\");\n+    /// ```\n+    ///\n+    /// Using `to_string`:\n     ///\n     /// ```\n-    /// assert_eq!('C'.to_lowercase().collect::<String>(), \"c\");\n+    /// assert_eq!('C'.to_lowercase().to_string(), \"c\");\n     ///\n     /// // Sometimes the result is more than one character:\n-    /// assert_eq!('\u0130'.to_lowercase().collect::<String>(), \"i\\u{307}\");\n+    /// assert_eq!('\u0130'.to_lowercase().to_string(), \"i\\u{307}\");\n     ///\n     /// // Japanese scripts do not have case, and so:\n-    /// assert_eq!('\u5c71'.to_lowercase().collect::<String>(), \"\u5c71\");\n+    /// assert_eq!('\u5c71'.to_lowercase().to_string(), \"\u5c71\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_lowercase(self) -> ToLowercase {\n         ToLowercase(CaseMappingIter::new(conversions::to_lower(self)))\n     }\n \n-    /// Returns an iterator that yields the uppercase equivalent of a `char`.\n+    /// Returns an iterator that yields the uppercase equivalent of a `char`\n+    /// as one or more `char`s.\n     ///\n-    /// If no conversion is possible then an iterator with just the input character is returned.\n+    /// If a character does not have a uppercase equivalent, the same character\n+    /// will be returned back by the iterator.\n     ///\n     /// This performs complex unconditional mappings with no tailoring: it maps\n-    /// one Unicode character to its uppercase equivalent according to the\n+    /// one Unicode character to its lowercase equivalent according to the\n     /// [Unicode database] and the additional complex mappings\n     /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n     /// language) are not considered here.\n@@ -783,18 +861,41 @@ impl char {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n+    /// As an iterator:\n     ///\n     /// ```\n-    /// assert_eq!('c'.to_uppercase().collect::<String>(), \"C\");\n+    /// for c in '\u00df'.to_uppercase() {\n+    ///     print!(\"{}\", c);\n+    /// }\n+    /// println!();\n+    /// ```\n+    ///\n+    /// Using `println!` directly:\n+    ///\n+    /// ```\n+    /// println!(\"{}\", '\u00df'.to_uppercase());\n+    /// ```\n+    ///\n+    /// Both are equivalent to:\n+    ///\n+    /// ```\n+    /// println!(\"SS\");\n+    /// ```\n+    ///\n+    /// Using `to_string`:\n+    ///\n+    /// ```\n+    /// assert_eq!('c'.to_uppercase().to_string(), \"C\");\n     ///\n     /// // Sometimes the result is more than one character:\n-    /// assert_eq!('\u00df'.to_uppercase().collect::<String>(), \"SS\");\n+    /// assert_eq!('\u00df'.to_uppercase().to_string(), \"SS\");\n     ///\n     /// // Japanese does not have case, and so:\n-    /// assert_eq!('\u5c71'.to_uppercase().collect::<String>(), \"\u5c71\");\n+    /// assert_eq!('\u5c71'.to_uppercase().to_string(), \"\u5c71\");\n     /// ```\n     ///\n+    /// # Note on locale\n+    ///\n     /// In Turkish, the equivalent of 'i' in Latin has five forms instead of two:\n     ///\n     /// * 'Dotless': I / \u0131, sometimes written \u00ef\n@@ -803,15 +904,15 @@ impl char {\n     /// Note that the lowercase dotted 'i' is the same as the Latin. Therefore:\n     ///\n     /// ```\n-    /// let upper_i: String = 'i'.to_uppercase().collect();\n+    /// let upper_i = 'i'.to_uppercase().to_string();\n     /// ```\n     ///\n     /// The value of `upper_i` here relies on the language of the text: if we're\n     /// in `en-US`, it should be `\"I\"`, but if we're in `tr_TR`, it should\n     /// be `\"\u0130\"`. `to_uppercase()` does not take this into account, and so:\n     ///\n     /// ```\n-    /// let upper_i: String = 'i'.to_uppercase().collect();\n+    /// let upper_i = 'i'.to_uppercase().to_string();\n     ///\n     /// assert_eq!(upper_i, \"I\");\n     /// ```"}]}