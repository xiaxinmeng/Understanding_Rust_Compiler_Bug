{"sha": "69689625ce4465f2d008d6543553d0d91d53dca4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5Njg5NjI1Y2U0NDY1ZjJkMDA4ZDY1NDM1NTNkMGQ5MWQ1M2RjYTQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-25T11:35:26Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-25T11:35:26Z"}, "message": "move ast builder to a separate file", "tree": {"sha": "3e3f08ada8011f300faae3966cbe61a4a7dd7377", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e3f08ada8011f300faae3966cbe61a4a7dd7377"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69689625ce4465f2d008d6543553d0d91d53dca4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69689625ce4465f2d008d6543553d0d91d53dca4", "html_url": "https://github.com/rust-lang/rust/commit/69689625ce4465f2d008d6543553d0d91d53dca4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69689625ce4465f2d008d6543553d0d91d53dca4/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f32081fa185b3a9df021f277c2c27fbd123d0951", "url": "https://api.github.com/repos/rust-lang/rust/commits/f32081fa185b3a9df021f277c2c27fbd123d0951", "html_url": "https://github.com/rust-lang/rust/commit/f32081fa185b3a9df021f277c2c27fbd123d0951"}], "stats": {"total": 472, "additions": 237, "deletions": 235}, "files": [{"sha": "2894bdd8a1e759b1c04cd7e2f87a767c7cce2693", "filename": "crates/ra_assists/src/assists/add_missing_impl_members.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs?ref=69689625ce4465f2d008d6543553d0d91d53dca4", "patch": "@@ -4,10 +4,7 @@ use ra_syntax::{\n     SmolStr,\n };\n \n-use crate::{\n-    ast_editor::{AstBuilder, AstEditor},\n-    Assist, AssistCtx, AssistId,\n-};\n+use crate::{ast_builder::AstBuilder, ast_editor::AstEditor, Assist, AssistCtx, AssistId};\n \n #[derive(PartialEq)]\n enum AddMissingImplMembersMode {"}, {"sha": "771aa625fc91a3e5c8c14fe39a728079a31ee85c", "filename": "crates/ra_assists/src/assists/fill_match_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs?ref=69689625ce4465f2d008d6543553d0d91d53dca4", "patch": "@@ -3,7 +3,7 @@ use std::iter;\n use hir::{db::HirDatabase, Adt, HasSource};\n use ra_syntax::ast::{self, AstNode, NameOwner};\n \n-use crate::{ast_editor::AstBuilder, Assist, AssistCtx, AssistId};\n+use crate::{ast_builder::AstBuilder, Assist, AssistCtx, AssistId};\n \n pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let match_expr = ctx.node_at_offset::<ast::MatchExpr>()?;"}, {"sha": "aa9036feda0e2da8d924e25f90bdcce703c662b1", "filename": "crates/ra_assists/src/assists/move_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs?ref=69689625ce4465f2d008d6543553d0d91d53dca4", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::{\n     TextRange,\n };\n \n-use crate::{ast_editor::AstBuilder, Assist, AssistCtx, AssistId};\n+use crate::{ast_builder::AstBuilder, Assist, AssistCtx, AssistId};\n \n pub(crate) fn move_bounds_to_where_clause(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let type_param_list = ctx.node_at_offset::<ast::TypeParamList>()?;"}, {"sha": "e4ea1fca9dbfa18dc2ed11dd73f0ae662eeb6eb8", "filename": "crates/ra_assists/src/ast_builder.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_assists%2Fsrc%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_assists%2Fsrc%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_builder.rs?ref=69689625ce4465f2d008d6543553d0d91d53dca4", "patch": "@@ -0,0 +1,229 @@\n+use itertools::Itertools;\n+\n+use hir::Name;\n+use ra_syntax::{ast, AstNode, SourceFile};\n+\n+pub struct AstBuilder<N: AstNode> {\n+    _phantom: std::marker::PhantomData<N>,\n+}\n+\n+impl AstBuilder<ast::RecordField> {\n+    pub fn from_name(name: &Name) -> ast::RecordField {\n+        ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}: (), }} }}\", name))\n+    }\n+\n+    fn from_text(text: &str) -> ast::RecordField {\n+        ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n+    }\n+\n+    pub fn from_pieces(name: &ast::NameRef, expr: Option<&ast::Expr>) -> ast::RecordField {\n+        match expr {\n+            Some(expr) => Self::from_text(&format!(\"{}: {}\", name.syntax(), expr.syntax())),\n+            None => Self::from_text(&name.syntax().to_string()),\n+        }\n+    }\n+}\n+\n+impl AstBuilder<ast::Block> {\n+    fn from_text(text: &str) -> ast::Block {\n+        ast_node_from_file_text(&format!(\"fn f() {}\", text))\n+    }\n+\n+    pub fn single_expr(e: &ast::Expr) -> ast::Block {\n+        Self::from_text(&format!(\"{{ {} }}\", e.syntax()))\n+    }\n+}\n+\n+impl AstBuilder<ast::Expr> {\n+    fn from_text(text: &str) -> ast::Expr {\n+        ast_node_from_file_text(&format!(\"const C: () = {};\", text))\n+    }\n+\n+    pub fn unit() -> ast::Expr {\n+        Self::from_text(\"()\")\n+    }\n+\n+    pub fn unimplemented() -> ast::Expr {\n+        Self::from_text(\"unimplemented!()\")\n+    }\n+}\n+\n+impl AstBuilder<ast::NameRef> {\n+    pub fn new(text: &str) -> ast::NameRef {\n+        ast_node_from_file_text(&format!(\"fn f() {{ {}; }}\", text))\n+    }\n+}\n+\n+impl AstBuilder<ast::Path> {\n+    fn from_text(text: &str) -> ast::Path {\n+        ast_node_from_file_text(text)\n+    }\n+\n+    pub fn from_name(name: ast::Name) -> ast::Path {\n+        let name = name.syntax().to_string();\n+        Self::from_text(name.as_str())\n+    }\n+\n+    pub fn from_pieces(enum_name: ast::Name, var_name: ast::Name) -> ast::Path {\n+        Self::from_text(&format!(\"{}::{}\", enum_name.syntax(), var_name.syntax()))\n+    }\n+}\n+\n+impl AstBuilder<ast::BindPat> {\n+    fn from_text(text: &str) -> ast::BindPat {\n+        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n+    }\n+\n+    pub fn from_name(name: &ast::Name) -> ast::BindPat {\n+        Self::from_text(name.text())\n+    }\n+}\n+\n+impl AstBuilder<ast::PlaceholderPat> {\n+    fn from_text(text: &str) -> ast::PlaceholderPat {\n+        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n+    }\n+\n+    pub fn placeholder() -> ast::PlaceholderPat {\n+        Self::from_text(\"_\")\n+    }\n+}\n+\n+impl AstBuilder<ast::TupleStructPat> {\n+    fn from_text(text: &str) -> ast::TupleStructPat {\n+        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n+    }\n+\n+    pub fn from_pieces(\n+        path: &ast::Path,\n+        pats: impl Iterator<Item = ast::Pat>,\n+    ) -> ast::TupleStructPat {\n+        let pats_str = pats.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n+        Self::from_text(&format!(\"{}({})\", path.syntax(), pats_str))\n+    }\n+}\n+\n+impl AstBuilder<ast::RecordPat> {\n+    fn from_text(text: &str) -> ast::RecordPat {\n+        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n+    }\n+\n+    pub fn from_pieces(path: &ast::Path, pats: impl Iterator<Item = ast::Pat>) -> ast::RecordPat {\n+        let pats_str = pats.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n+        Self::from_text(&format!(\"{}{{ {} }}\", path.syntax(), pats_str))\n+    }\n+}\n+\n+impl AstBuilder<ast::PathPat> {\n+    fn from_text(text: &str) -> ast::PathPat {\n+        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n+    }\n+\n+    pub fn from_path(path: &ast::Path) -> ast::PathPat {\n+        let path_str = path.syntax().text().to_string();\n+        Self::from_text(path_str.as_str())\n+    }\n+}\n+\n+impl AstBuilder<ast::MatchArm> {\n+    fn from_text(text: &str) -> ast::MatchArm {\n+        ast_node_from_file_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n+    }\n+\n+    pub fn from_pieces(pats: impl Iterator<Item = ast::Pat>, expr: &ast::Expr) -> ast::MatchArm {\n+        let pats_str = pats.map(|p| p.syntax().to_string()).join(\" | \");\n+        Self::from_text(&format!(\"{} => {}\", pats_str, expr.syntax()))\n+    }\n+}\n+\n+impl AstBuilder<ast::MatchArmList> {\n+    fn from_text(text: &str) -> ast::MatchArmList {\n+        ast_node_from_file_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n+    }\n+\n+    pub fn from_arms(arms: impl Iterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n+        let arms_str = arms.map(|arm| format!(\"\\n    {}\", arm.syntax())).join(\",\");\n+        Self::from_text(&format!(\"{},\\n\", arms_str))\n+    }\n+}\n+\n+impl AstBuilder<ast::WherePred> {\n+    fn from_text(text: &str) -> ast::WherePred {\n+        ast_node_from_file_text(&format!(\"fn f() where {} {{ }}\", text))\n+    }\n+\n+    pub fn from_pieces(\n+        path: ast::Path,\n+        bounds: impl Iterator<Item = ast::TypeBound>,\n+    ) -> ast::WherePred {\n+        let bounds = bounds.map(|b| b.syntax().to_string()).collect::<Vec<_>>().join(\" + \");\n+        Self::from_text(&format!(\"{}: {}\", path.syntax(), bounds))\n+    }\n+}\n+\n+impl AstBuilder<ast::WhereClause> {\n+    fn from_text(text: &str) -> ast::WhereClause {\n+        ast_node_from_file_text(&format!(\"fn f() where {} {{ }}\", text))\n+    }\n+\n+    pub fn from_predicates(preds: impl Iterator<Item = ast::WherePred>) -> ast::WhereClause {\n+        let preds = preds.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n+        Self::from_text(preds.as_str())\n+    }\n+}\n+\n+fn ast_node_from_file_text<N: AstNode>(text: &str) -> N {\n+    let parse = SourceFile::parse(text);\n+    let res = parse.tree().syntax().descendants().find_map(N::cast).unwrap();\n+    res\n+}\n+\n+pub(crate) mod tokens {\n+    use once_cell::sync::Lazy;\n+    use ra_syntax::{AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken, T};\n+\n+    static SOURCE_FILE: Lazy<Parse<SourceFile>> = Lazy::new(|| SourceFile::parse(\",\\n; ;\"));\n+\n+    pub(crate) fn comma() -> SyntaxToken {\n+        SOURCE_FILE\n+            .tree()\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.into_token())\n+            .find(|it| it.kind() == T![,])\n+            .unwrap()\n+    }\n+\n+    pub(crate) fn single_space() -> SyntaxToken {\n+        SOURCE_FILE\n+            .tree()\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.into_token())\n+            .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \" \")\n+            .unwrap()\n+    }\n+\n+    #[allow(unused)]\n+    pub(crate) fn single_newline() -> SyntaxToken {\n+        SOURCE_FILE\n+            .tree()\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.into_token())\n+            .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \"\\n\")\n+            .unwrap()\n+    }\n+\n+    pub(crate) struct WsBuilder(SourceFile);\n+\n+    impl WsBuilder {\n+        pub(crate) fn new(text: &str) -> WsBuilder {\n+            WsBuilder(SourceFile::parse(text).ok().unwrap())\n+        }\n+        pub(crate) fn ws(&self) -> SyntaxToken {\n+            self.0.syntax().first_child_or_token().unwrap().into_token().unwrap()\n+        }\n+    }\n+\n+}"}, {"sha": "81621afef8f63495b19ac48b3085ae6677e0641b", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "modified", "additions": 3, "deletions": 228, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=69689625ce4465f2d008d6543553d0d91d53dca4", "patch": "@@ -1,18 +1,18 @@\n use std::{iter, ops::RangeInclusive};\n \n use arrayvec::ArrayVec;\n-use itertools::Itertools;\n \n-use hir::Name;\n use ra_fmt::leading_indent;\n use ra_syntax::{\n     algo::{insert_children, replace_children},\n-    ast, AstNode, Direction, InsertPosition, SourceFile, SyntaxElement,\n+    ast, AstNode, Direction, InsertPosition, SyntaxElement,\n     SyntaxKind::*,\n     T,\n };\n use ra_text_edit::TextEditBuilder;\n \n+use crate::ast_builder::tokens;\n+\n pub struct AstEditor<N: AstNode> {\n     original_ast: N,\n     ast: N,\n@@ -240,228 +240,3 @@ impl AstEditor<ast::FnDef> {\n         self.ast = self.replace_children(replace_range, to_insert.into_iter())\n     }\n }\n-\n-pub struct AstBuilder<N: AstNode> {\n-    _phantom: std::marker::PhantomData<N>,\n-}\n-\n-impl AstBuilder<ast::RecordField> {\n-    pub fn from_name(name: &Name) -> ast::RecordField {\n-        ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}: (), }} }}\", name))\n-    }\n-\n-    fn from_text(text: &str) -> ast::RecordField {\n-        ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n-    }\n-\n-    pub fn from_pieces(name: &ast::NameRef, expr: Option<&ast::Expr>) -> ast::RecordField {\n-        match expr {\n-            Some(expr) => Self::from_text(&format!(\"{}: {}\", name.syntax(), expr.syntax())),\n-            None => Self::from_text(&name.syntax().to_string()),\n-        }\n-    }\n-}\n-\n-impl AstBuilder<ast::Block> {\n-    fn from_text(text: &str) -> ast::Block {\n-        ast_node_from_file_text(&format!(\"fn f() {}\", text))\n-    }\n-\n-    pub fn single_expr(e: &ast::Expr) -> ast::Block {\n-        Self::from_text(&format!(\"{{ {} }}\", e.syntax()))\n-    }\n-}\n-\n-impl AstBuilder<ast::Expr> {\n-    fn from_text(text: &str) -> ast::Expr {\n-        ast_node_from_file_text(&format!(\"const C: () = {};\", text))\n-    }\n-\n-    pub fn unit() -> ast::Expr {\n-        Self::from_text(\"()\")\n-    }\n-\n-    pub fn unimplemented() -> ast::Expr {\n-        Self::from_text(\"unimplemented!()\")\n-    }\n-}\n-\n-impl AstBuilder<ast::NameRef> {\n-    pub fn new(text: &str) -> ast::NameRef {\n-        ast_node_from_file_text(&format!(\"fn f() {{ {}; }}\", text))\n-    }\n-}\n-\n-impl AstBuilder<ast::Path> {\n-    fn from_text(text: &str) -> ast::Path {\n-        ast_node_from_file_text(text)\n-    }\n-\n-    pub fn from_name(name: ast::Name) -> ast::Path {\n-        let name = name.syntax().to_string();\n-        Self::from_text(name.as_str())\n-    }\n-\n-    pub fn from_pieces(enum_name: ast::Name, var_name: ast::Name) -> ast::Path {\n-        Self::from_text(&format!(\"{}::{}\", enum_name.syntax(), var_name.syntax()))\n-    }\n-}\n-\n-impl AstBuilder<ast::BindPat> {\n-    fn from_text(text: &str) -> ast::BindPat {\n-        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n-    }\n-\n-    pub fn from_name(name: &ast::Name) -> ast::BindPat {\n-        Self::from_text(name.text())\n-    }\n-}\n-\n-impl AstBuilder<ast::PlaceholderPat> {\n-    fn from_text(text: &str) -> ast::PlaceholderPat {\n-        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n-    }\n-\n-    pub fn placeholder() -> ast::PlaceholderPat {\n-        Self::from_text(\"_\")\n-    }\n-}\n-\n-impl AstBuilder<ast::TupleStructPat> {\n-    fn from_text(text: &str) -> ast::TupleStructPat {\n-        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n-    }\n-\n-    pub fn from_pieces(\n-        path: &ast::Path,\n-        pats: impl Iterator<Item = ast::Pat>,\n-    ) -> ast::TupleStructPat {\n-        let pats_str = pats.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n-        Self::from_text(&format!(\"{}({})\", path.syntax(), pats_str))\n-    }\n-}\n-\n-impl AstBuilder<ast::RecordPat> {\n-    fn from_text(text: &str) -> ast::RecordPat {\n-        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n-    }\n-\n-    pub fn from_pieces(path: &ast::Path, pats: impl Iterator<Item = ast::Pat>) -> ast::RecordPat {\n-        let pats_str = pats.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n-        Self::from_text(&format!(\"{}{{ {} }}\", path.syntax(), pats_str))\n-    }\n-}\n-\n-impl AstBuilder<ast::PathPat> {\n-    fn from_text(text: &str) -> ast::PathPat {\n-        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n-    }\n-\n-    pub fn from_path(path: &ast::Path) -> ast::PathPat {\n-        let path_str = path.syntax().text().to_string();\n-        Self::from_text(path_str.as_str())\n-    }\n-}\n-\n-impl AstBuilder<ast::MatchArm> {\n-    fn from_text(text: &str) -> ast::MatchArm {\n-        ast_node_from_file_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n-    }\n-\n-    pub fn from_pieces(pats: impl Iterator<Item = ast::Pat>, expr: &ast::Expr) -> ast::MatchArm {\n-        let pats_str = pats.map(|p| p.syntax().to_string()).join(\" | \");\n-        Self::from_text(&format!(\"{} => {}\", pats_str, expr.syntax()))\n-    }\n-}\n-\n-impl AstBuilder<ast::MatchArmList> {\n-    fn from_text(text: &str) -> ast::MatchArmList {\n-        ast_node_from_file_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n-    }\n-\n-    pub fn from_arms(arms: impl Iterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n-        let arms_str = arms.map(|arm| format!(\"\\n    {}\", arm.syntax())).join(\",\");\n-        Self::from_text(&format!(\"{},\\n\", arms_str))\n-    }\n-}\n-\n-impl AstBuilder<ast::WherePred> {\n-    fn from_text(text: &str) -> ast::WherePred {\n-        ast_node_from_file_text(&format!(\"fn f() where {} {{ }}\", text))\n-    }\n-\n-    pub fn from_pieces(\n-        path: ast::Path,\n-        bounds: impl Iterator<Item = ast::TypeBound>,\n-    ) -> ast::WherePred {\n-        let bounds = bounds.map(|b| b.syntax().to_string()).collect::<Vec<_>>().join(\" + \");\n-        Self::from_text(&format!(\"{}: {}\", path.syntax(), bounds))\n-    }\n-}\n-\n-impl AstBuilder<ast::WhereClause> {\n-    fn from_text(text: &str) -> ast::WhereClause {\n-        ast_node_from_file_text(&format!(\"fn f() where {} {{ }}\", text))\n-    }\n-\n-    pub fn from_predicates(preds: impl Iterator<Item = ast::WherePred>) -> ast::WhereClause {\n-        let preds = preds.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n-        Self::from_text(preds.as_str())\n-    }\n-}\n-\n-fn ast_node_from_file_text<N: AstNode>(text: &str) -> N {\n-    let parse = SourceFile::parse(text);\n-    let res = parse.tree().syntax().descendants().find_map(N::cast).unwrap();\n-    res\n-}\n-\n-mod tokens {\n-    use once_cell::sync::Lazy;\n-    use ra_syntax::{AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken, T};\n-\n-    static SOURCE_FILE: Lazy<Parse<SourceFile>> = Lazy::new(|| SourceFile::parse(\",\\n; ;\"));\n-\n-    pub(crate) fn comma() -> SyntaxToken {\n-        SOURCE_FILE\n-            .tree()\n-            .syntax()\n-            .descendants_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == T![,])\n-            .unwrap()\n-    }\n-\n-    pub(crate) fn single_space() -> SyntaxToken {\n-        SOURCE_FILE\n-            .tree()\n-            .syntax()\n-            .descendants_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \" \")\n-            .unwrap()\n-    }\n-\n-    #[allow(unused)]\n-    pub(crate) fn single_newline() -> SyntaxToken {\n-        SOURCE_FILE\n-            .tree()\n-            .syntax()\n-            .descendants_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \"\\n\")\n-            .unwrap()\n-    }\n-\n-    pub(crate) struct WsBuilder(SourceFile);\n-\n-    impl WsBuilder {\n-        pub(crate) fn new(text: &str) -> WsBuilder {\n-            WsBuilder(SourceFile::parse(text).ok().unwrap())\n-        }\n-        pub(crate) fn ws(&self) -> SyntaxToken {\n-            self.0.syntax().first_child_or_token().unwrap().into_token().unwrap()\n-        }\n-    }\n-\n-}"}, {"sha": "71b01707693b568412d024812156ad7519b1672b", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=69689625ce4465f2d008d6543553d0d91d53dca4", "patch": "@@ -8,6 +8,7 @@\n mod assist_ctx;\n mod marks;\n pub mod ast_editor;\n+pub mod ast_builder;\n \n use itertools::Itertools;\n "}, {"sha": "30b95a21506d11b0df41202ca462c86ded3882d7", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69689625ce4465f2d008d6543553d0d91d53dca4/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=69689625ce4465f2d008d6543553d0d91d53dca4", "patch": "@@ -2,7 +2,7 @@ use std::cell::RefCell;\n \n use hir::diagnostics::{AstDiagnostic, Diagnostic as _, DiagnosticSink};\n use itertools::Itertools;\n-use ra_assists::ast_editor::{AstBuilder, AstEditor};\n+use ra_assists::{ast_builder::AstBuilder, ast_editor::AstEditor};\n use ra_db::SourceDatabase;\n use ra_prof::profile;\n use ra_syntax::{"}]}