{"sha": "dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNmU4NzdlYWQwMDA0YmQ5MGY1ODkxYTE1NTZlY2RjN2EyYjFhYTk=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-24T13:19:32Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-01T07:56:21Z"}, "message": "Split \"new\" miri crate into modules", "tree": {"sha": "ffbf830853f23e80aca04f427e3119a32befc2fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffbf830853f23e80aca04f427e3119a32befc2fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmANCUACgkQpp+NIls6\n19mNuA/9H3gw0Q6ahe0knB1L7IbqTdUXmr94KQpL4q9cVG6sjvp+rel9Jr1aWys9\nyJKYepDX+sHFiRNvhX44W+4VaX/ByWd0x+ReHDCJIv4qXHDTLdyfxdUly1St8bmf\nVCIU01Vrm4ZXDuBdr0/QmBccIqJhEQD3stc/As/Cayb3LRQs41QKJ9rCPPW1NLKH\n0PMONnAP0LEsZrsi8a+ljOARl12FfPYKccVRUqZ2cDn7MF+WBCFPEKaXC6Za0cGj\nfPRE4GwANrZkNCFjbr1vOGjSK8NZawaUsG56BUVwjBlK5hRTOBbmTszpj999Op8d\nhy02Y7EtMbZ3mvhQ0zOgv5GRwhz6luy0SFxyWYHFT4c+Srz8oWEP+bkwa+QT6jFW\nnTLAHcpb3jrIeJos2wHq2BTy5pPulPnrqfMUfIsvzny5ddwtAnQWGuHE9QnCQb4Q\n+PglIH3H7w3iaj7ccnoWItbyDWqwVRDEdJe371FfsD39XXefALXmakPw7rAW9fU9\nCjAty19+GzniLjyE+JSrDixvi0XanTR84d980npq9Qd1QopOQF8FYoZVoD/HFnNt\n/IHGHCcfX6wePm4UpQdz+4gMj3I7VCAM4BgxqVXu8rSLfce8zUc1JL/CIuk6gMaB\n2ZEQMkFnVLwca5VBi4uJSYIzM7NsUQonXDsvsPxPMILXcJloNsk=\n=JTTt\n-----END PGP SIGNATURE-----", "payload": "tree ffbf830853f23e80aca04f427e3119a32befc2fc\nparent 36502a32b0c916cb2abef987d69e2740320715b7\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1500902372 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501574181 +0200\n\nSplit \"new\" miri crate into modules\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9", "html_url": "https://github.com/rust-lang/rust/commit/dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36502a32b0c916cb2abef987d69e2740320715b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/36502a32b0c916cb2abef987d69e2740320715b7", "html_url": "https://github.com/rust-lang/rust/commit/36502a32b0c916cb2abef987d69e2740320715b7"}], "stats": {"total": 1028, "additions": 524, "deletions": 504}, "files": [{"sha": "ef2b65cf1e361717327e659a1f89e9a8efbd08f1", "filename": "miri/lib.rs", "status": "modified", "additions": 6, "deletions": 504, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9", "patch": "@@ -12,13 +12,10 @@ extern crate rustc_const_math;\n extern crate rustc_data_structures;\n extern crate syntax;\n \n-use rustc::ty::{self, TyCtxt, Ty};\n-use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc::ty::{self, TyCtxt};\n+use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use syntax::attr;\n-use syntax::abi::Abi;\n \n-use std::mem;\n use std::collections::{\n     HashMap,\n     BTreeMap,\n@@ -27,6 +24,10 @@ use std::collections::{\n extern crate rustc_miri;\n pub use rustc_miri::interpret::*;\n \n+mod missing_fns;\n+\n+use missing_fns::EvalContextExt as MissingFnsEvalContextExt;\n+\n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n@@ -145,357 +146,10 @@ struct MemoryData<'tcx> {\n }\n \n trait EvalContextExt<'tcx> {\n-    fn call_c_abi(\n-        &mut self,\n-        def_id: DefId,\n-        arg_operands: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n-        dest_ty: Ty<'tcx>,\n-        dest_block: mir::BasicBlock,\n-    ) -> EvalResult<'tcx>;\n     fn finish(&mut self) -> EvalResult<'tcx>;\n-\n-    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>>;\n-\n-    fn call_missing_fn(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n-        arg_operands: &[mir::Operand<'tcx>],\n-        sig: ty::FnSig<'tcx>,\n-        path: String,\n-    ) -> EvalResult<'tcx>;\n }\n \n impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator> {\n-    fn call_c_abi(\n-        &mut self,\n-        def_id: DefId,\n-        arg_operands: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n-        dest_ty: Ty<'tcx>,\n-        dest_block: mir::BasicBlock,\n-    ) -> EvalResult<'tcx> {\n-        let name = self.tcx.item_name(def_id);\n-        let attrs = self.tcx.get_attrs(def_id);\n-        let link_name = attr::first_attr_value_str_by_name(&attrs, \"link_name\")\n-            .unwrap_or(name)\n-            .as_str();\n-\n-        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n-            .map(|arg| self.eval_operand(arg))\n-            .collect();\n-        let args = args_res?;\n-\n-        let usize = self.tcx.types.usize;\n-\n-        match &link_name[..] {\n-            \"malloc\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                if size == 0 {\n-                    self.write_null(dest, dest_ty)?;\n-                } else {\n-                    let align = self.memory.pointer_size();\n-                    let ptr = self.memory.allocate(size, align, Kind::C)?;\n-                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-                }\n-            }\n-\n-            \"free\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?;\n-                if !ptr.is_null()? {\n-                    self.memory.deallocate(ptr.to_ptr()?, None, Kind::C)?;\n-                }\n-            }\n-\n-            \"syscall\" => {\n-                match self.value_to_primval(args[0], usize)?.to_u64()? {\n-                    511 => return Err(EvalError::Unimplemented(\"miri does not support random number generators\".to_owned())),\n-                    id => return Err(EvalError::Unimplemented(format!(\"miri does not support syscall id {}\", id))),\n-                }\n-            }\n-\n-            \"dlsym\" => {\n-                let _handle = args[0].into_ptr(&mut self.memory)?;\n-                let symbol = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let symbol_name = self.memory.read_c_str(symbol)?;\n-                let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n-                let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n-                return Err(EvalError::Unimplemented(format!(\"miri does not support dynamically loading libraries (requested symbol: {})\", symbol_name)));\n-            }\n-\n-            \"__rust_maybe_catch_panic\" => {\n-                // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n-                // We abort on panic, so not much is going on here, but we still have to call the closure\n-                let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                let f = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let data = args[1].into_ptr(&mut self.memory)?;\n-                let f_instance = self.memory.get_fn(f)?;\n-                self.write_null(dest, dest_ty)?;\n-\n-                // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n-                // and of course eval_main.\n-                let mir = self.load_mir(f_instance.def)?;\n-                self.push_stack_frame(\n-                    f_instance,\n-                    mir.span,\n-                    mir,\n-                    Lvalue::undef(),\n-                    StackPopCleanup::Goto(dest_block),\n-                )?;\n-\n-                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n-                let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                self.write_ptr(arg_dest, data, u8_ptr_ty)?;\n-\n-                // We ourselves return 0\n-                self.write_null(dest, dest_ty)?;\n-\n-                // Don't fall through\n-                return Ok(());\n-            }\n-\n-            \"__rust_start_panic\" => {\n-                return Err(EvalError::Panic);\n-            }\n-\n-            \"memcmp\" => {\n-                let left = args[0].into_ptr(&mut self.memory)?;\n-                let right = args[1].into_ptr(&mut self.memory)?;\n-                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n-\n-                let result = {\n-                    let left_bytes = self.memory.read_bytes(left, n)?;\n-                    let right_bytes = self.memory.read_bytes(right, n)?;\n-\n-                    use std::cmp::Ordering::*;\n-                    match left_bytes.cmp(right_bytes) {\n-                        Less => -1i8,\n-                        Equal => 0,\n-                        Greater => 1,\n-                    }\n-                };\n-\n-                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n-            }\n-\n-            \"memrchr\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?;\n-                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(num - idx as u64 - 1, &self)?;\n-                    self.write_ptr(dest, new_ptr, dest_ty)?;\n-                } else {\n-                    self.write_null(dest, dest_ty)?;\n-                }\n-            }\n-\n-            \"memchr\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?;\n-                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(idx as u64, &self)?;\n-                    self.write_ptr(dest, new_ptr, dest_ty)?;\n-                } else {\n-                    self.write_null(dest, dest_ty)?;\n-                }\n-            }\n-\n-            \"getenv\" => {\n-                let result = {\n-                    let name_ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                    let name = self.memory.read_c_str(name_ptr)?;\n-                    match self.machine_data.env_vars.get(name) {\n-                        Some(&var) => PrimVal::Ptr(var),\n-                        None => PrimVal::Bytes(0),\n-                    }\n-                };\n-                self.write_primval(dest, result, dest_ty)?;\n-            }\n-\n-            \"unsetenv\" => {\n-                let mut success = None;\n-                {\n-                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n-                    if !name_ptr.is_null()? {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n-                        if !name.is_empty() && !name.contains(&b'=') {\n-                            success = Some(self.machine_data.env_vars.remove(name));\n-                        }\n-                    }\n-                }\n-                if let Some(old) = success {\n-                    if let Some(var) = old {\n-                        self.memory.deallocate(var, None, Kind::Env)?;\n-                    }\n-                    self.write_null(dest, dest_ty)?;\n-                } else {\n-                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n-                }\n-            }\n-\n-            \"setenv\" => {\n-                let mut new = None;\n-                {\n-                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n-                    let value_ptr = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n-                    let value = self.memory.read_c_str(value_ptr)?;\n-                    if !name_ptr.is_null()? {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n-                        if !name.is_empty() && !name.contains(&b'=') {\n-                            new = Some((name.to_owned(), value.to_owned()));\n-                        }\n-                    }\n-                }\n-                if let Some((name, value)) = new {\n-                    // +1 for the null terminator\n-                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env)?;\n-                    self.memory.write_bytes(value_copy.into(), &value)?;\n-                    let trailing_zero_ptr = value_copy.offset(value.len() as u64, &self)?.into();\n-                    self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n-                    if let Some(var) = self.machine_data.env_vars.insert(name.to_owned(), value_copy) {\n-                        self.memory.deallocate(var, None, Kind::Env)?;\n-                    }\n-                    self.write_null(dest, dest_ty)?;\n-                } else {\n-                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n-                }\n-            }\n-\n-            \"write\" => {\n-                let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let buf = args[1].into_ptr(&mut self.memory)?;\n-                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n-                let result = if fd == 1 || fd == 2 { // stdout/stderr\n-                    use std::io::{self, Write};\n-                \n-                    let buf_cont = self.memory.read_bytes(buf, n)?;\n-                    let res = if fd == 1 { io::stdout().write(buf_cont) } else { io::stderr().write(buf_cont) };\n-                    match res { Ok(n) => n as isize, Err(_) => -1 }\n-                } else {\n-                    info!(\"Ignored output to FD {}\", fd);\n-                    n as isize // pretend it all went well\n-                }; // now result is the value we return back to the program\n-                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n-            }\n-\n-            \"strlen\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let n = self.memory.read_c_str(ptr)?.len();\n-                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n-            }\n-\n-            // Some things needed for sys::thread initialization to go through\n-            \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n-                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n-            }\n-\n-            \"sysconf\" => {\n-                let name = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                trace!(\"sysconf() called with name {}\", name);\n-                // cache the sysconf integers via miri's global cache\n-                let paths = &[\n-                    (&[\"libc\", \"_SC_PAGESIZE\"], PrimVal::Bytes(4096)),\n-                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], PrimVal::from_i128(-1)),\n-                ];\n-                let mut result = None;\n-                for &(path, path_value) in paths {\n-                    if let Ok(instance) = self.resolve_path(path) {\n-                        let cid = GlobalId { instance, promoted: None };\n-                        // compute global if not cached\n-                        let val = match self.globals.get(&cid).map(|glob| glob.value) {\n-                            Some(value) => self.value_to_primval(value, usize)?.to_u64()?,\n-                            None => eval_body_as_primval(self.tcx, instance)?.0.to_u64()?,\n-                        };\n-                        if val == name {\n-                            result = Some(path_value);\n-                            break;\n-                        }\n-                    }\n-                }\n-                if let Some(result) = result {\n-                    self.write_primval(dest, result, dest_ty)?;\n-                } else {\n-                    return Err(EvalError::Unimplemented(format!(\"Unimplemented sysconf name: {}\", name)));\n-                }\n-            }\n-\n-            // Hook pthread calls that go to the thread-local storage memory subsystem\n-            \"pthread_key_create\" => {\n-                let key_ptr = args[0].into_ptr(&mut self.memory)?;\n-\n-                // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor = match args[1].into_ptr(&mut self.memory)?.into_inner_primval() {\n-                    PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n-                    PrimVal::Bytes(0) => None,\n-                    PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n-                    PrimVal::Undef => return Err(EvalError::ReadUndefBytes),\n-                };\n-\n-                // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n-                let key_type = self.operand_ty(&arg_operands[0]).builtin_deref(true, ty::LvaluePreference::NoPreference)\n-                                   .ok_or(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n-                let key_size = {\n-                    let layout = self.type_layout(key_type)?;\n-                    layout.size(&self.tcx.data_layout)\n-                };\n-\n-                // Create key and write it into the memory where key_ptr wants it\n-                let key = self.memory.create_tls_key(dtor) as u128;\n-                if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n-                    return Err(EvalError::OutOfTls);\n-                }\n-                // TODO: Does this need checking for alignment?\n-                self.memory.write_uint(key_ptr.to_ptr()?, key, key_size.bytes())?;\n-\n-                // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n-            }\n-            \"pthread_key_delete\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n-                self.memory.delete_tls_key(key)?;\n-                // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n-            }\n-            \"pthread_getspecific\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n-                let ptr = self.memory.load_tls(key)?;\n-                self.write_ptr(dest, ptr, dest_ty)?;\n-            }\n-            \"pthread_setspecific\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n-                let new_ptr = args[1].into_ptr(&mut self.memory)?;\n-                self.memory.store_tls(key, new_ptr)?;\n-                \n-                // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n-            }\n-\n-            // Stub out all the other pthread calls to just return 0\n-            link_name if link_name.starts_with(\"pthread_\") => {\n-                warn!(\"ignoring C ABI call: {}\", link_name);\n-                self.write_null(dest, dest_ty)?;\n-            },\n-\n-            _ => {\n-                return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n-            }\n-        }\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        self.dump_local(dest);\n-        self.goto_block(dest_block);\n-        Ok(())\n-    }\n-\n     fn finish(&mut self) -> EvalResult<'tcx> {\n         let mut dtor = self.memory.fetch_tls_dtor(None)?;\n         // FIXME: replace loop by some structure that works with stepping\n@@ -525,158 +179,6 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator> {\n         }\n         Ok(())\n     }\n-\n-    /// Get an instance for a path.\n-    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n-        let cstore = &self.tcx.sess.cstore;\n-\n-        let crates = cstore.crates();\n-        crates.iter()\n-            .find(|&&krate| cstore.crate_name(krate) == path[0])\n-            .and_then(|krate| {\n-                let krate = DefId {\n-                    krate: *krate,\n-                    index: CRATE_DEF_INDEX,\n-                };\n-                let mut items = cstore.item_children(krate, self.tcx.sess);\n-                let mut path_it = path.iter().skip(1).peekable();\n-\n-                while let Some(segment) = path_it.next() {\n-                    for item in &mem::replace(&mut items, vec![]) {\n-                        if item.ident.name == *segment {\n-                            if path_it.peek().is_none() {\n-                                return Some(ty::Instance::mono(self.tcx, item.def.def_id()));\n-                            }\n-\n-                            items = cstore.item_children(item.def.def_id(), self.tcx.sess);\n-                            break;\n-                        }\n-                    }\n-                }\n-                None\n-            })\n-            .ok_or_else(|| {\n-                let path = path.iter()\n-                    .map(|&s| s.to_owned())\n-                    .collect();\n-                EvalError::PathNotFound(path)\n-            })\n-    }\n-\n-    fn call_missing_fn(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n-        arg_operands: &[mir::Operand<'tcx>],\n-        sig: ty::FnSig<'tcx>,\n-        path: String,\n-    ) -> EvalResult<'tcx> {\n-        // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n-        match &path[..] {\n-            \"std::panicking::rust_panic_with_hook\" |\n-            \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n-            _ => {},\n-        }\n-\n-        let dest_ty = sig.output();\n-        let (dest, dest_block) = destination.ok_or_else(|| EvalError::NoMirFor(path.clone()))?;\n-\n-        if sig.abi == Abi::C {\n-            // An external C function\n-            // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n-            // unify these two mechanisms for \"hooking into missing functions\".\n-            self.call_c_abi(instance.def_id(), arg_operands, dest, dest_ty, dest_block)?;\n-            return Ok(());\n-        }\n-\n-        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n-            .map(|arg| self.eval_operand(arg))\n-            .collect();\n-        let args = args_res?;\n-\n-        let usize = self.tcx.types.usize;\n-    \n-        match &path[..] {\n-            // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n-            \"alloc::heap::::__rust_alloc\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                if size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-            \"alloc::heap::::__rust_alloc_zeroed\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                if size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n-                self.memory.write_repeat(ptr.into(), 0, size)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-            \"alloc::heap::::__rust_dealloc\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                if old_size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust)?;\n-            }\n-            \"alloc::heap::::__rust_realloc\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n-                let new_align = self.value_to_primval(args[4], usize)?.to_u64()?;\n-                if old_size == 0 || new_size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !old_align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(old_align));\n-                }\n-                if !new_align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(new_align));\n-                }\n-                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust)?;\n-                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n-            }\n-\n-            // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n-            // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n-            \"std::io::_print\" => {\n-                trace!(\"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\");\n-            }\n-            \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n-            \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n-            \"std::panicking::panicking\" |\n-            \"std::rt::panicking\" => {\n-                // we abort on panic -> `std::rt::panicking` always returns false\n-                let bool = self.tcx.types.bool;\n-                self.write_primval(dest, PrimVal::from_bool(false), bool)?;\n-            }\n-            _ => return Err(EvalError::NoMirFor(path)),\n-        }\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        self.dump_local(dest);\n-        self.goto_block(dest_block);\n-        return Ok(());\n-    }\n }\n \n trait MemoryExt<'tcx> {"}, {"sha": "6d1e5a505f4b51ab386399e2c9e794ffb1b31d38", "filename": "miri/missing_fns.rs", "status": "added", "additions": 518, "deletions": 0, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9/miri%2Fmissing_fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9/miri%2Fmissing_fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fmissing_fns.rs?ref=dc6e877ead0004bd90f5891a1556ecdc7a2b1aa9", "patch": "@@ -0,0 +1,518 @@\n+use rustc::ty::{self, Ty};\n+use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc::mir;\n+use syntax::attr;\n+use syntax::abi::Abi;\n+\n+use std::mem;\n+\n+use rustc_miri::interpret::*;\n+\n+use super::{\n+    TlsKey,\n+    EvalContext,\n+    MemoryExt,\n+    Evaluator,\n+};\n+\n+pub trait EvalContextExt<'tcx> {\n+    fn call_c_abi(\n+        &mut self,\n+        def_id: DefId,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+        dest_block: mir::BasicBlock,\n+    ) -> EvalResult<'tcx>;\n+\n+    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>>;\n+\n+    fn call_missing_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        sig: ty::FnSig<'tcx>,\n+        path: String,\n+    ) -> EvalResult<'tcx>;\n+}\n+\n+impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator> {\n+    fn call_c_abi(\n+        &mut self,\n+        def_id: DefId,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+        dest_block: mir::BasicBlock,\n+    ) -> EvalResult<'tcx> {\n+        let name = self.tcx.item_name(def_id);\n+        let attrs = self.tcx.get_attrs(def_id);\n+        let link_name = attr::first_attr_value_str_by_name(&attrs, \"link_name\")\n+            .unwrap_or(name)\n+            .as_str();\n+\n+        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n+            .map(|arg| self.eval_operand(arg))\n+            .collect();\n+        let args = args_res?;\n+\n+        let usize = self.tcx.types.usize;\n+\n+        match &link_name[..] {\n+            \"malloc\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                if size == 0 {\n+                    self.write_null(dest, dest_ty)?;\n+                } else {\n+                    let align = self.memory.pointer_size();\n+                    let ptr = self.memory.allocate(size, align, Kind::C)?;\n+                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+                }\n+            }\n+\n+            \"free\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                if !ptr.is_null()? {\n+                    self.memory.deallocate(ptr.to_ptr()?, None, Kind::C)?;\n+                }\n+            }\n+\n+            \"syscall\" => {\n+                match self.value_to_primval(args[0], usize)?.to_u64()? {\n+                    511 => return Err(EvalError::Unimplemented(\"miri does not support random number generators\".to_owned())),\n+                    id => return Err(EvalError::Unimplemented(format!(\"miri does not support syscall id {}\", id))),\n+                }\n+            }\n+\n+            \"dlsym\" => {\n+                let _handle = args[0].into_ptr(&mut self.memory)?;\n+                let symbol = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let symbol_name = self.memory.read_c_str(symbol)?;\n+                let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n+                let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n+                return Err(EvalError::Unimplemented(format!(\"miri does not support dynamically loading libraries (requested symbol: {})\", symbol_name)));\n+            }\n+\n+            \"__rust_maybe_catch_panic\" => {\n+                // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n+                // We abort on panic, so not much is going on here, but we still have to call the closure\n+                let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n+                let f = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let data = args[1].into_ptr(&mut self.memory)?;\n+                let f_instance = self.memory.get_fn(f)?;\n+                self.write_null(dest, dest_ty)?;\n+\n+                // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n+                // and of course eval_main.\n+                let mir = self.load_mir(f_instance.def)?;\n+                self.push_stack_frame(\n+                    f_instance,\n+                    mir.span,\n+                    mir,\n+                    Lvalue::undef(),\n+                    StackPopCleanup::Goto(dest_block),\n+                )?;\n+\n+                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n+                let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                self.write_ptr(arg_dest, data, u8_ptr_ty)?;\n+\n+                // We ourselves return 0\n+                self.write_null(dest, dest_ty)?;\n+\n+                // Don't fall through\n+                return Ok(());\n+            }\n+\n+            \"__rust_start_panic\" => {\n+                return Err(EvalError::Panic);\n+            }\n+\n+            \"memcmp\" => {\n+                let left = args[0].into_ptr(&mut self.memory)?;\n+                let right = args[1].into_ptr(&mut self.memory)?;\n+                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n+\n+                let result = {\n+                    let left_bytes = self.memory.read_bytes(left, n)?;\n+                    let right_bytes = self.memory.read_bytes(right, n)?;\n+\n+                    use std::cmp::Ordering::*;\n+                    match left_bytes.cmp(right_bytes) {\n+                        Less => -1i8,\n+                        Equal => 0,\n+                        Greater => 1,\n+                    }\n+                };\n+\n+                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n+            }\n+\n+            \"memrchr\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n+                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n+                    let new_ptr = ptr.offset(num - idx as u64 - 1, &self)?;\n+                    self.write_ptr(dest, new_ptr, dest_ty)?;\n+                } else {\n+                    self.write_null(dest, dest_ty)?;\n+                }\n+            }\n+\n+            \"memchr\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n+                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n+                    let new_ptr = ptr.offset(idx as u64, &self)?;\n+                    self.write_ptr(dest, new_ptr, dest_ty)?;\n+                } else {\n+                    self.write_null(dest, dest_ty)?;\n+                }\n+            }\n+\n+            \"getenv\" => {\n+                let result = {\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                    let name = self.memory.read_c_str(name_ptr)?;\n+                    match self.machine_data.env_vars.get(name) {\n+                        Some(&var) => PrimVal::Ptr(var),\n+                        None => PrimVal::Bytes(0),\n+                    }\n+                };\n+                self.write_primval(dest, result, dest_ty)?;\n+            }\n+\n+            \"unsetenv\" => {\n+                let mut success = None;\n+                {\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n+                    if !name_ptr.is_null()? {\n+                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n+                        if !name.is_empty() && !name.contains(&b'=') {\n+                            success = Some(self.machine_data.env_vars.remove(name));\n+                        }\n+                    }\n+                }\n+                if let Some(old) = success {\n+                    if let Some(var) = old {\n+                        self.memory.deallocate(var, None, Kind::Env)?;\n+                    }\n+                    self.write_null(dest, dest_ty)?;\n+                } else {\n+                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n+                }\n+            }\n+\n+            \"setenv\" => {\n+                let mut new = None;\n+                {\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n+                    let value_ptr = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n+                    let value = self.memory.read_c_str(value_ptr)?;\n+                    if !name_ptr.is_null()? {\n+                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n+                        if !name.is_empty() && !name.contains(&b'=') {\n+                            new = Some((name.to_owned(), value.to_owned()));\n+                        }\n+                    }\n+                }\n+                if let Some((name, value)) = new {\n+                    // +1 for the null terminator\n+                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env)?;\n+                    self.memory.write_bytes(value_copy.into(), &value)?;\n+                    let trailing_zero_ptr = value_copy.offset(value.len() as u64, &self)?.into();\n+                    self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n+                    if let Some(var) = self.machine_data.env_vars.insert(name.to_owned(), value_copy) {\n+                        self.memory.deallocate(var, None, Kind::Env)?;\n+                    }\n+                    self.write_null(dest, dest_ty)?;\n+                } else {\n+                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n+                }\n+            }\n+\n+            \"write\" => {\n+                let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let buf = args[1].into_ptr(&mut self.memory)?;\n+                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n+                let result = if fd == 1 || fd == 2 { // stdout/stderr\n+                    use std::io::{self, Write};\n+                \n+                    let buf_cont = self.memory.read_bytes(buf, n)?;\n+                    let res = if fd == 1 { io::stdout().write(buf_cont) } else { io::stderr().write(buf_cont) };\n+                    match res { Ok(n) => n as isize, Err(_) => -1 }\n+                } else {\n+                    info!(\"Ignored output to FD {}\", fd);\n+                    n as isize // pretend it all went well\n+                }; // now result is the value we return back to the program\n+                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n+            }\n+\n+            \"strlen\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let n = self.memory.read_c_str(ptr)?.len();\n+                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n+            }\n+\n+            // Some things needed for sys::thread initialization to go through\n+            \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+            }\n+\n+            \"sysconf\" => {\n+                let name = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                trace!(\"sysconf() called with name {}\", name);\n+                // cache the sysconf integers via miri's global cache\n+                let paths = &[\n+                    (&[\"libc\", \"_SC_PAGESIZE\"], PrimVal::Bytes(4096)),\n+                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], PrimVal::from_i128(-1)),\n+                ];\n+                let mut result = None;\n+                for &(path, path_value) in paths {\n+                    if let Ok(instance) = self.resolve_path(path) {\n+                        let cid = GlobalId { instance, promoted: None };\n+                        // compute global if not cached\n+                        let val = match self.globals.get(&cid).map(|glob| glob.value) {\n+                            Some(value) => self.value_to_primval(value, usize)?.to_u64()?,\n+                            None => eval_body_as_primval(self.tcx, instance)?.0.to_u64()?,\n+                        };\n+                        if val == name {\n+                            result = Some(path_value);\n+                            break;\n+                        }\n+                    }\n+                }\n+                if let Some(result) = result {\n+                    self.write_primval(dest, result, dest_ty)?;\n+                } else {\n+                    return Err(EvalError::Unimplemented(format!(\"Unimplemented sysconf name: {}\", name)));\n+                }\n+            }\n+\n+            // Hook pthread calls that go to the thread-local storage memory subsystem\n+            \"pthread_key_create\" => {\n+                let key_ptr = args[0].into_ptr(&mut self.memory)?;\n+\n+                // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n+                let dtor = match args[1].into_ptr(&mut self.memory)?.into_inner_primval() {\n+                    PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n+                    PrimVal::Bytes(0) => None,\n+                    PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n+                    PrimVal::Undef => return Err(EvalError::ReadUndefBytes),\n+                };\n+\n+                // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n+                let key_type = self.operand_ty(&arg_operands[0]).builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                                   .ok_or(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n+                let key_size = {\n+                    let layout = self.type_layout(key_type)?;\n+                    layout.size(&self.tcx.data_layout)\n+                };\n+\n+                // Create key and write it into the memory where key_ptr wants it\n+                let key = self.memory.create_tls_key(dtor) as u128;\n+                if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n+                    return Err(EvalError::OutOfTls);\n+                }\n+                // TODO: Does this need checking for alignment?\n+                self.memory.write_uint(key_ptr.to_ptr()?, key, key_size.bytes())?;\n+\n+                // Return success (0)\n+                self.write_null(dest, dest_ty)?;\n+            }\n+            \"pthread_key_delete\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                self.memory.delete_tls_key(key)?;\n+                // Return success (0)\n+                self.write_null(dest, dest_ty)?;\n+            }\n+            \"pthread_getspecific\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let ptr = self.memory.load_tls(key)?;\n+                self.write_ptr(dest, ptr, dest_ty)?;\n+            }\n+            \"pthread_setspecific\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let new_ptr = args[1].into_ptr(&mut self.memory)?;\n+                self.memory.store_tls(key, new_ptr)?;\n+                \n+                // Return success (0)\n+                self.write_null(dest, dest_ty)?;\n+            }\n+\n+            // Stub out all the other pthread calls to just return 0\n+            link_name if link_name.starts_with(\"pthread_\") => {\n+                warn!(\"ignoring C ABI call: {}\", link_name);\n+                self.write_null(dest, dest_ty)?;\n+            },\n+\n+            _ => {\n+                return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n+            }\n+        }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        self.dump_local(dest);\n+        self.goto_block(dest_block);\n+        Ok(())\n+    }\n+\n+    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+        let cstore = &self.tcx.sess.cstore;\n+        let crates = cstore.crates();\n+        crates.iter()\n+            .find(|&&krate| cstore.crate_name(krate) == path[0])\n+            .and_then(|krate| {\n+                let krate = DefId {\n+                    krate: *krate,\n+                    index: CRATE_DEF_INDEX,\n+                };\n+                let mut items = cstore.item_children(krate, self.tcx.sess);\n+                let mut path_it = path.iter().skip(1).peekable();\n+\n+                while let Some(segment) = path_it.next() {\n+                    for item in &mem::replace(&mut items, vec![]) {\n+                        if item.ident.name == *segment {\n+                            if path_it.peek().is_none() {\n+                                return Some(ty::Instance::mono(self.tcx, item.def.def_id()));\n+                            }\n+\n+                            items = cstore.item_children(item.def.def_id(), self.tcx.sess);\n+                            break;\n+                        }\n+                    }\n+                }\n+                None\n+            })\n+            .ok_or_else(|| {\n+                let path = path.iter()\n+                    .map(|&s| s.to_owned())\n+                    .collect();\n+                EvalError::PathNotFound(path)\n+            })\n+    }\n+\n+    fn call_missing_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        sig: ty::FnSig<'tcx>,\n+        path: String,\n+    ) -> EvalResult<'tcx> {\n+        // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n+        match &path[..] {\n+            \"std::panicking::rust_panic_with_hook\" |\n+            \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n+            _ => {},\n+        }\n+\n+        let dest_ty = sig.output();\n+        let (dest, dest_block) = destination.ok_or_else(|| EvalError::NoMirFor(path.clone()))?;\n+\n+        if sig.abi == Abi::C {\n+            // An external C function\n+            // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n+            // unify these two mechanisms for \"hooking into missing functions\".\n+            self.call_c_abi(instance.def_id(), arg_operands, dest, dest_ty, dest_block)?;\n+            return Ok(());\n+        }\n+\n+        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n+            .map(|arg| self.eval_operand(arg))\n+            .collect();\n+        let args = args_res?;\n+\n+        let usize = self.tcx.types.usize;\n+    \n+        match &path[..] {\n+            // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n+            \"alloc::heap::::__rust_alloc\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"alloc::heap::::__rust_alloc_zeroed\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n+                self.memory.write_repeat(ptr.into(), 0, size)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"alloc::heap::::__rust_dealloc\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if old_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust)?;\n+            }\n+            \"alloc::heap::::__rust_realloc\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n+                let new_align = self.value_to_primval(args[4], usize)?.to_u64()?;\n+                if old_size == 0 || new_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !old_align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(old_align));\n+                }\n+                if !new_align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(new_align));\n+                }\n+                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust)?;\n+                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n+            }\n+\n+            // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n+            // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n+            \"std::io::_print\" => {\n+                trace!(\"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\");\n+            }\n+            \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n+            \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n+            \"std::panicking::panicking\" |\n+            \"std::rt::panicking\" => {\n+                // we abort on panic -> `std::rt::panicking` always returns false\n+                let bool = self.tcx.types.bool;\n+                self.write_primval(dest, PrimVal::from_bool(false), bool)?;\n+            }\n+            _ => return Err(EvalError::NoMirFor(path)),\n+        }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        self.dump_local(dest);\n+        self.goto_block(dest_block);\n+        return Ok(());\n+    }\n+}"}]}