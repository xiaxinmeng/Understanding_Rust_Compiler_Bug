{"sha": "d2cccd07bce0477b0fd873590299eb042bc164f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyY2NjZDA3YmNlMDQ3N2IwZmQ4NzM1OTAyOTllYjA0MmJjMTY0ZjU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-03-09T19:19:11Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-03-17T21:40:59Z"}, "message": "Fix byte string literal patterns in match", "tree": {"sha": "8fcebb6a2242e53c8e4d1064e2affea8d7885d33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fcebb6a2242e53c8e4d1064e2affea8d7885d33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2cccd07bce0477b0fd873590299eb042bc164f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2cccd07bce0477b0fd873590299eb042bc164f5", "html_url": "https://github.com/rust-lang/rust/commit/d2cccd07bce0477b0fd873590299eb042bc164f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2cccd07bce0477b0fd873590299eb042bc164f5/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c31794d31840f4a695fde45c4797c833a78b278", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c31794d31840f4a695fde45c4797c833a78b278", "html_url": "https://github.com/rust-lang/rust/commit/3c31794d31840f4a695fde45c4797c833a78b278"}], "stats": {"total": 66, "additions": 49, "deletions": 17}, "files": [{"sha": "d7bd8e3d882f4f2aa3513d07fb4c9bdfbf85e6d6", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d2cccd07bce0477b0fd873590299eb042bc164f5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2cccd07bce0477b0fd873590299eb042bc164f5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=d2cccd07bce0477b0fd873590299eb042bc164f5", "patch": "@@ -200,7 +200,7 @@ use middle::mem_categorization as mc;\n use middle::pat_util::*;\n use trans::adt;\n use trans::base::*;\n-use trans::build::{AddCase, And, BitCast, Br, CondBr, GEPi, InBoundsGEP, Load};\n+use trans::build::{AddCase, And, Br, CondBr, GEPi, InBoundsGEP, Load, PointerCast};\n use trans::build::{Not, Store, Sub, add_comment};\n use trans::build;\n use trans::callee;\n@@ -853,14 +853,31 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             ty::ty_str => compare_str(cx, lhs, rhs, rhs_t, debug_loc),\n             ty::ty_vec(ty, _) => match ty.sty {\n                 ty::ty_uint(ast::TyU8) => {\n-                    // NOTE: cast &[u8] to &str and abuse the str_eq lang item,\n+                    // NOTE: cast &[u8] and &[u8; N] to &str and abuse the str_eq lang item,\n                     // which calls memcmp().\n-                    let t = ty::mk_str_slice(cx.tcx(),\n-                                             cx.tcx().mk_region(ty::ReStatic),\n-                                             ast::MutImmutable);\n-                    let lhs = BitCast(cx, lhs, type_of::type_of(cx.ccx(), t).ptr_to());\n-                    let rhs = BitCast(cx, rhs, type_of::type_of(cx.ccx(), t).ptr_to());\n-                    compare_str(cx, lhs, rhs, rhs_t, debug_loc)\n+                    let pat_len = val_ty(rhs).element_type().array_length();\n+                    let ty_str_slice = ty::mk_str_slice(cx.tcx(),\n+                                                        cx.tcx().mk_region(ty::ReStatic),\n+                                                        ast::MutImmutable);\n+\n+                    let rhs_str = alloc_ty(cx, ty_str_slice, \"rhs_str\");\n+                    Store(cx, GEPi(cx, rhs, &[0, 0]), expr::get_dataptr(cx, rhs_str));\n+                    Store(cx, C_uint(cx.ccx(), pat_len), expr::get_len(cx, rhs_str));\n+\n+                    let lhs_str;\n+                    if val_ty(lhs) == val_ty(rhs) {\n+                        // Both the discriminant and the pattern are thin pointers\n+                        lhs_str = alloc_ty(cx, ty_str_slice, \"lhs_str\");\n+                        Store(cx, GEPi(cx, lhs, &[0, 0]), expr::get_dataptr(cx, lhs_str));\n+                        Store(cx, C_uint(cx.ccx(), pat_len), expr::get_len(cx, lhs_str));\n+                    }\n+                    else {\n+                        // The discriminant is a fat pointer\n+                        let llty_str_slice = type_of::type_of(cx.ccx(), ty_str_slice).ptr_to();\n+                        lhs_str = PointerCast(cx, lhs, llty_str_slice);\n+                    }\n+\n+                    compare_str(cx, lhs_str, rhs_str, rhs_t, debug_loc)\n                 },\n                 _ => cx.sess().bug(\"only byte strings supported in compare_values\"),\n             },"}, {"sha": "8e2f4dcefa02231db95ee7d5d576e8dc7df057b7", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2cccd07bce0477b0fd873590299eb042bc164f5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2cccd07bce0477b0fd873590299eb042bc164f5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=d2cccd07bce0477b0fd873590299eb042bc164f5", "patch": "@@ -48,7 +48,23 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         ast::PatLit(ref lt) => {\n             check_expr(fcx, &**lt);\n             let expr_ty = fcx.expr_ty(&**lt);\n-            fcx.write_ty(pat.id, expr_ty);\n+\n+            // Byte string patterns behave the same way as array patterns\n+            // They can denote both statically and dynamically sized byte arrays\n+            let mut pat_ty = expr_ty;\n+            if let ast::ExprLit(ref lt) = lt.node {\n+                if let ast::LitBinary(_) = lt.node {\n+                    let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n+                    if let ty::ty_rptr(_, mt) = expected_ty.sty {\n+                        if let ty::ty_vec(_, None) = mt.ty.sty {\n+                            pat_ty = ty::mk_slice(tcx, tcx.mk_region(ty::ReStatic),\n+                                ty::mt{ ty: tcx.types.u8, mutbl: ast::MutImmutable })\n+                        }\n+                    }\n+                }\n+            }\n+\n+            fcx.write_ty(pat.id, pat_ty);\n \n             // somewhat surprising: in this case, the subtyping\n             // relation goes the opposite way as the other\n@@ -62,7 +78,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             //     &'static str <: expected\n             //\n             // that's equivalent to there existing a LUB.\n-            demand::suptype(fcx, pat.span, expected, expr_ty);\n+            demand::suptype(fcx, pat.span, expected, pat_ty);\n         }\n         ast::PatRange(ref begin, ref end) => {\n             check_expr(fcx, &**begin);"}, {"sha": "fbe2a65bc893719e4fec693f056314704ed1aec4", "filename": "src/test/run-pass/byte-literals.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2cccd07bce0477b0fd873590299eb042bc164f5/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2cccd07bce0477b0fd873590299eb042bc164f5/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbyte-literals.rs?ref=d2cccd07bce0477b0fd873590299eb042bc164f5", "patch": "@@ -58,13 +58,12 @@ pub fn main() {\n         _ => panic!(),\n     }\n \n-    // FIXME: There are no DST coercions &[T; N] -> &[T] in patterns\n-    // let buf = vec!(97u8, 98, 99, 100);\n-    // assert_eq!(match &buf[0..3] {\n-    //      b\"def\" => 1_usize,\n-    //      b\"abc\" => 2_usize,\n-    //      _ => 3_usize\n-    // }, 2);\n+    let buf = vec!(97u8, 98, 99, 100);\n+    assert_eq!(match &buf[0..3] {\n+         b\"def\" => 1,\n+         b\"abc\" => 2,\n+         _ => 3\n+    }, 2);\n \n     let expected: &[_] = &[97u8, 92u8, 110u8];\n     assert_eq!(BAZ, expected);"}]}