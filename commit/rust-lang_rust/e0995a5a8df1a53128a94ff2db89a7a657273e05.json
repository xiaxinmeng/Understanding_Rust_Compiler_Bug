{"sha": "e0995a5a8df1a53128a94ff2db89a7a657273e05", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwOTk1YTVhOGRmMWE1MzEyOGE5NGZmMmRiODlhN2E2NTcyNzNlMDU=", "commit": {"author": {"name": "Elliot Bobrow", "email": "elliotgreybobrow@gmail.com", "date": "2021-07-24T17:58:55Z"}, "committer": {"name": "Elliot Bobrow", "email": "elliotgreybobrow@gmail.com", "date": "2021-07-24T17:58:55Z"}, "message": "fix code to suggest `;` on parse error", "tree": {"sha": "a34ac4014d66c199b29ab154dce36adcbef404b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a34ac4014d66c199b29ab154dce36adcbef404b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0995a5a8df1a53128a94ff2db89a7a657273e05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0995a5a8df1a53128a94ff2db89a7a657273e05", "html_url": "https://github.com/rust-lang/rust/commit/e0995a5a8df1a53128a94ff2db89a7a657273e05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0995a5a8df1a53128a94ff2db89a7a657273e05/comments", "author": {"login": "ebobrow", "id": 77182873, "node_id": "MDQ6VXNlcjc3MTgyODcz", "avatar_url": "https://avatars.githubusercontent.com/u/77182873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebobrow", "html_url": "https://github.com/ebobrow", "followers_url": "https://api.github.com/users/ebobrow/followers", "following_url": "https://api.github.com/users/ebobrow/following{/other_user}", "gists_url": "https://api.github.com/users/ebobrow/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebobrow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebobrow/subscriptions", "organizations_url": "https://api.github.com/users/ebobrow/orgs", "repos_url": "https://api.github.com/users/ebobrow/repos", "events_url": "https://api.github.com/users/ebobrow/events{/privacy}", "received_events_url": "https://api.github.com/users/ebobrow/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebobrow", "id": 77182873, "node_id": "MDQ6VXNlcjc3MTgyODcz", "avatar_url": "https://avatars.githubusercontent.com/u/77182873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebobrow", "html_url": "https://github.com/ebobrow", "followers_url": "https://api.github.com/users/ebobrow/followers", "following_url": "https://api.github.com/users/ebobrow/following{/other_user}", "gists_url": "https://api.github.com/users/ebobrow/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebobrow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebobrow/subscriptions", "organizations_url": "https://api.github.com/users/ebobrow/orgs", "repos_url": "https://api.github.com/users/ebobrow/repos", "events_url": "https://api.github.com/users/ebobrow/events{/privacy}", "received_events_url": "https://api.github.com/users/ebobrow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b543e0dc03193cde5538099e3996b23aeacb8eca", "url": "https://api.github.com/repos/rust-lang/rust/commits/b543e0dc03193cde5538099e3996b23aeacb8eca", "html_url": "https://github.com/rust-lang/rust/commit/b543e0dc03193cde5538099e3996b23aeacb8eca"}], "stats": {"total": 182, "additions": 118, "deletions": 64}, "files": [{"sha": "9818bd8d314690391642690b0234e965102fbf1d", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e0995a5a8df1a53128a94ff2db89a7a657273e05/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0995a5a8df1a53128a94ff2db89a7a657273e05/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=e0995a5a8df1a53128a94ff2db89a7a657273e05", "patch": "@@ -242,6 +242,63 @@ impl<'a> Parser<'a> {\n         expected.sort_by_cached_key(|x| x.to_string());\n         expected.dedup();\n \n+        let sm = self.sess.source_map();\n+        let msg = format!(\"expected `;`, found {}\", super::token_descr(&self.token));\n+        let appl = Applicability::MachineApplicable;\n+        if expected.contains(&TokenType::Token(token::Semi)) {\n+            if self.token.span == DUMMY_SP || self.prev_token.span == DUMMY_SP {\n+                // Likely inside a macro, can't provide meaningful suggestions.\n+            } else if !sm.is_multiline(self.prev_token.span.until(self.token.span)) {\n+                // The current token is in the same line as the prior token, not recoverable.\n+            } else if [token::Comma, token::Colon].contains(&self.token.kind)\n+                && self.prev_token.kind == token::CloseDelim(token::Paren)\n+            {\n+                // Likely typo: The current token is on a new line and is expected to be\n+                // `.`, `;`, `?`, or an operator after a close delimiter token.\n+                //\n+                // let a = std::process::Command::new(\"echo\")\n+                //         .arg(\"1\")\n+                //         ,arg(\"2\")\n+                //         ^\n+                // https://github.com/rust-lang/rust/issues/72253\n+            } else if self.look_ahead(1, |t| {\n+                t == &token::CloseDelim(token::Brace)\n+                    || t.can_begin_expr() && t.kind != token::Colon\n+            }) && [token::Comma, token::Colon].contains(&self.token.kind)\n+            {\n+                // Likely typo: `,` \u2192 `;` or `:` \u2192 `;`. This is triggered if the current token is\n+                // either `,` or `:`, and the next token could either start a new statement or is a\n+                // block close. For example:\n+                //\n+                //   let x = 32:\n+                //   let y = 42;\n+                self.bump();\n+                let sp = self.prev_token.span;\n+                self.struct_span_err(sp, &msg)\n+                    .span_suggestion_short(sp, \"change this to `;`\", \";\".to_string(), appl)\n+                    .emit();\n+                return Ok(false);\n+            } else if self.look_ahead(0, |t| {\n+                t == &token::CloseDelim(token::Brace)\n+                    || (\n+                        t.can_begin_expr() && t != &token::Semi && t != &token::Pound\n+                        // Avoid triggering with too many trailing `#` in raw string.\n+                    )\n+            }) {\n+                // Missing semicolon typo. This is triggered if the next token could either start a\n+                // new statement or is a block close. For example:\n+                //\n+                //   let x = 32\n+                //   let y = 42;\n+                let sp = self.prev_token.span.shrink_to_hi();\n+                self.struct_span_err(sp, &msg)\n+                    .span_label(self.token.span, \"unexpected token\")\n+                    .span_suggestion_short(sp, \"add `;` here\", \";\".to_string(), appl)\n+                    .emit();\n+                return Ok(false);\n+            }\n+        }\n+\n         let expect = tokens_to_string(&expected[..]);\n         let actual = super::token_descr(&self.token);\n         let (msg_exp, (label_sp, label_exp)) = if expected.len() > 1 {\n@@ -303,7 +360,6 @@ impl<'a> Parser<'a> {\n             return Err(err);\n         }\n \n-        let sm = self.sess.source_map();\n         if self.prev_token.span == DUMMY_SP {\n             // Account for macro context where the previous span might not be\n             // available to avoid incorrect output (#54841).\n@@ -1144,62 +1200,6 @@ impl<'a> Parser<'a> {\n         if self.eat(&token::Semi) {\n             return Ok(());\n         }\n-        let sm = self.sess.source_map();\n-        let msg = format!(\"expected `;`, found {}\", super::token_descr(&self.token));\n-        let appl = Applicability::MachineApplicable;\n-        if self.token.span == DUMMY_SP || self.prev_token.span == DUMMY_SP {\n-            // Likely inside a macro, can't provide meaningful suggestions.\n-            return self.expect(&token::Semi).map(drop);\n-        } else if !sm.is_multiline(self.prev_token.span.until(self.token.span)) {\n-            // The current token is in the same line as the prior token, not recoverable.\n-        } else if [token::Comma, token::Colon].contains(&self.token.kind)\n-            && self.prev_token.kind == token::CloseDelim(token::Paren)\n-        {\n-            // Likely typo: The current token is on a new line and is expected to be\n-            // `.`, `;`, `?`, or an operator after a close delimiter token.\n-            //\n-            // let a = std::process::Command::new(\"echo\")\n-            //         .arg(\"1\")\n-            //         ,arg(\"2\")\n-            //         ^\n-            // https://github.com/rust-lang/rust/issues/72253\n-            self.expect(&token::Semi)?;\n-            return Ok(());\n-        } else if self.look_ahead(1, |t| {\n-            t == &token::CloseDelim(token::Brace) || t.can_begin_expr() && t.kind != token::Colon\n-        }) && [token::Comma, token::Colon].contains(&self.token.kind)\n-        {\n-            // Likely typo: `,` \u2192 `;` or `:` \u2192 `;`. This is triggered if the current token is\n-            // either `,` or `:`, and the next token could either start a new statement or is a\n-            // block close. For example:\n-            //\n-            //   let x = 32:\n-            //   let y = 42;\n-            self.bump();\n-            let sp = self.prev_token.span;\n-            self.struct_span_err(sp, &msg)\n-                .span_suggestion_short(sp, \"change this to `;`\", \";\".to_string(), appl)\n-                .emit();\n-            return Ok(());\n-        } else if self.look_ahead(0, |t| {\n-            t == &token::CloseDelim(token::Brace)\n-                || (\n-                    t.can_begin_expr() && t != &token::Semi && t != &token::Pound\n-                    // Avoid triggering with too many trailing `#` in raw string.\n-                )\n-        }) {\n-            // Missing semicolon typo. This is triggered if the next token could either start a\n-            // new statement or is a block close. For example:\n-            //\n-            //   let x = 32\n-            //   let y = 42;\n-            let sp = self.prev_token.span.shrink_to_hi();\n-            self.struct_span_err(sp, &msg)\n-                .span_label(self.token.span, \"unexpected token\")\n-                .span_suggestion_short(sp, \"add `;` here\", \";\".to_string(), appl)\n-                .emit();\n-            return Ok(());\n-        }\n         self.expect(&token::Semi).map(drop) // Error unconditionally\n     }\n "}, {"sha": "53f071db7819a9b90cbdef1bd9997f212f44db69", "filename": "src/test/ui/parser/issue-87197-missing-semicolon.fixed", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0995a5a8df1a53128a94ff2db89a7a657273e05/src%2Ftest%2Fui%2Fparser%2Fissue-87197-missing-semicolon.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e0995a5a8df1a53128a94ff2db89a7a657273e05/src%2Ftest%2Fui%2Fparser%2Fissue-87197-missing-semicolon.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-87197-missing-semicolon.fixed?ref=e0995a5a8df1a53128a94ff2db89a7a657273e05", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+// Parser should know when a semicolon is missing.\n+// https://github.com/rust-lang/rust/issues/87197\n+\n+fn main() {\n+    let x = 100; //~ ERROR: expected `;`\n+    println!(\"{}\", x); //~ ERROR: expected `;`\n+    let y = 200; //~ ERROR: expected `;`\n+    println!(\"{}\", y);\n+}"}, {"sha": "db0edf4529c77c8a94d670562ea3beca13fbec77", "filename": "src/test/ui/parser/issue-87197-missing-semicolon.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0995a5a8df1a53128a94ff2db89a7a657273e05/src%2Ftest%2Fui%2Fparser%2Fissue-87197-missing-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0995a5a8df1a53128a94ff2db89a7a657273e05/src%2Ftest%2Fui%2Fparser%2Fissue-87197-missing-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-87197-missing-semicolon.rs?ref=e0995a5a8df1a53128a94ff2db89a7a657273e05", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+// Parser should know when a semicolon is missing.\n+// https://github.com/rust-lang/rust/issues/87197\n+\n+fn main() {\n+    let x = 100 //~ ERROR: expected `;`\n+    println!(\"{}\", x) //~ ERROR: expected `;`\n+    let y = 200 //~ ERROR: expected `;`\n+    println!(\"{}\", y);\n+}"}, {"sha": "57772de1e7a4bc3324fe55c4753ec57be01f357e", "filename": "src/test/ui/parser/issue-87197-missing-semicolon.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e0995a5a8df1a53128a94ff2db89a7a657273e05/src%2Ftest%2Fui%2Fparser%2Fissue-87197-missing-semicolon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0995a5a8df1a53128a94ff2db89a7a657273e05/src%2Ftest%2Fui%2Fparser%2Fissue-87197-missing-semicolon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-87197-missing-semicolon.stderr?ref=e0995a5a8df1a53128a94ff2db89a7a657273e05", "patch": "@@ -0,0 +1,26 @@\n+error: expected `;`, found `println`\n+  --> $DIR/issue-87197-missing-semicolon.rs:6:16\n+   |\n+LL |     let x = 100\n+   |                ^ help: add `;` here\n+LL |     println!(\"{}\", x)\n+   |     ------- unexpected token\n+\n+error: expected `;`, found keyword `let`\n+  --> $DIR/issue-87197-missing-semicolon.rs:7:22\n+   |\n+LL |     println!(\"{}\", x)\n+   |                      ^ help: add `;` here\n+LL |     let y = 200\n+   |     --- unexpected token\n+\n+error: expected `;`, found `println`\n+  --> $DIR/issue-87197-missing-semicolon.rs:8:16\n+   |\n+LL |     let y = 200\n+   |                ^ help: add `;` here\n+LL |     println!(\"{}\", y);\n+   |     ------- unexpected token\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "24d1ae9e6236851a48eaec549a098695e793f049", "filename": "src/test/ui/parser/macros-no-semicolon.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0995a5a8df1a53128a94ff2db89a7a657273e05/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0995a5a8df1a53128a94ff2db89a7a657273e05/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon.rs?ref=e0995a5a8df1a53128a94ff2db89a7a657273e05", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    assert_eq!(1, 2)\n-    assert_eq!(3, 4) //~ ERROR expected one of `.`, `;`, `?`, `}`, or an operator, found `assert_eq`\n+    assert_eq!(1, 2) //~ ERROR: expected `;`\n+    assert_eq!(3, 4) //~ ERROR: expected `;`\n     println!(\"hello\");\n }"}, {"sha": "f310662dbb0e790799099057c8bdc6d2f2a95016", "filename": "src/test/ui/parser/macros-no-semicolon.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0995a5a8df1a53128a94ff2db89a7a657273e05/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0995a5a8df1a53128a94ff2db89a7a657273e05/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon.stderr?ref=e0995a5a8df1a53128a94ff2db89a7a657273e05", "patch": "@@ -1,10 +1,18 @@\n-error: expected one of `.`, `;`, `?`, `}`, or an operator, found `assert_eq`\n-  --> $DIR/macros-no-semicolon.rs:3:5\n+error: expected `;`, found `assert_eq`\n+  --> $DIR/macros-no-semicolon.rs:2:21\n    |\n LL |     assert_eq!(1, 2)\n-   |                     - expected one of `.`, `;`, `?`, `}`, or an operator\n+   |                     ^ help: add `;` here\n LL |     assert_eq!(3, 4)\n-   |     ^^^^^^^^^ unexpected token\n+   |     --------- unexpected token\n \n-error: aborting due to previous error\n+error: expected `;`, found `println`\n+  --> $DIR/macros-no-semicolon.rs:3:21\n+   |\n+LL |     assert_eq!(3, 4)\n+   |                     ^ help: add `;` here\n+LL |     println!(\"hello\");\n+   |     ------- unexpected token\n+\n+error: aborting due to 2 previous errors\n "}]}