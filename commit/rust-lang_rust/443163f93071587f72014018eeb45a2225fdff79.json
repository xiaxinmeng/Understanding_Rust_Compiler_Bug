{"sha": "443163f93071587f72014018eeb45a2225fdff79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MzE2M2Y5MzA3MTU4N2Y3MjAxNDAxOGVlYjQ1YTIyMjVmZGZmNzk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-24T13:17:19Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-24T13:41:04Z"}, "message": "refactor cargo-miri a bit", "tree": {"sha": "298e1bec9bb821a2dbe9efaa1973db433aa06cc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/298e1bec9bb821a2dbe9efaa1973db433aa06cc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/443163f93071587f72014018eeb45a2225fdff79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/443163f93071587f72014018eeb45a2225fdff79", "html_url": "https://github.com/rust-lang/rust/commit/443163f93071587f72014018eeb45a2225fdff79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/443163f93071587f72014018eeb45a2225fdff79/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e530829797ed2dd0cbab0309979ad5846c69b497", "url": "https://api.github.com/repos/rust-lang/rust/commits/e530829797ed2dd0cbab0309979ad5846c69b497", "html_url": "https://github.com/rust-lang/rust/commit/e530829797ed2dd0cbab0309979ad5846c69b497"}], "stats": {"total": 170, "additions": 86, "deletions": 84}, "files": [{"sha": "17063b6ff67fcb197ee79c746cdfef0274a5773d", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 86, "deletions": 84, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/443163f93071587f72014018eeb45a2225fdff79/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/443163f93071587f72014018eeb45a2225fdff79/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=443163f93071587f72014018eeb45a2225fdff79", "patch": "@@ -23,7 +23,7 @@ Common options:\n     --features               Features to compile for the package\n     -V, --version            Print version info and exit\n \n-Other [options] are the same as `cargo rustc`.  Everything after the first \"--\" is\n+Other [options] are the same as `cargo check`.  Everything after the first \"--\" is\n passed verbatim to Miri, which will pass everything after the second \"--\" verbatim\n to the interpreted program.\n \"#;\n@@ -84,33 +84,30 @@ fn get_arg_flag_value(name: &str) -> Option<String> {\n     }\n }\n \n-\n-/// Determines if we are being invoked (as rustc) to build a runnable\n-/// executable. We run \"cargo check\", so this should only happen when\n-/// we are trying to compile a build script or build script dependency,\n-/// which actually needs to be executed on the host platform.\n-///\n-/// Currently, we detect this by checking for \"--emit=link\",\n-/// which indicates that Cargo instruced rustc to output\n-/// a native object.\n-fn is_build_dep() -> bool {\n-    std::env::args().any(|arg| arg.starts_with(\"--emit=\") && arg.contains(\"link\"))\n+/// Returns the path to the `miri` binary\n+fn find_miri() -> PathBuf {\n+    let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n+    path.set_file_name(\"miri\");\n+    path\n }\n \n-/// Returns whether or not Cargo invoked the wrapper (this binary) to compile\n-/// the final, target crate (either a test for 'cargo test', or a binary for 'cargo run')\n-/// Cargo does not give us this information directly, so we need to check\n-/// various command-line flags.\n-fn is_target_crate(is_build_script: bool) -> bool {\n-    let is_bin = get_arg_flag_value(\"--crate-type\").as_deref() == Some(\"bin\");\n-    let is_test = std::env::args().find(|arg| arg == \"--test\").is_some();\n-\n-    // The final runnable (under Miri) crate will either be a binary crate\n-    // or a test crate. We make sure to exclude build scripts here, since\n-    // they are also build with \"--crate-type bin\"\n-    (is_bin || is_test) && !is_build_script\n+fn cargo() -> Command {\n+    if let Ok(val) = std::env::var(\"CARGO\") {\n+        // Bootstrap tells us where to find cargo\n+        Command::new(val)\n+    } else {\n+        Command::new(\"cargo\")\n+    }\n }\n \n+fn xargo() -> Command {\n+    if let Ok(val) = std::env::var(\"XARGO\") {\n+        // Bootstrap tells us where to find xargo\n+        Command::new(val)\n+    } else {\n+        Command::new(\"xargo-check\")\n+    }\n+}\n \n fn list_targets() -> impl Iterator<Item = cargo_metadata::Target> {\n     // We need to get the manifest, and then the metadata, to enumerate targets.\n@@ -155,13 +152,6 @@ fn list_targets() -> impl Iterator<Item = cargo_metadata::Target> {\n     package.targets.into_iter()\n }\n \n-/// Returns the path to the `miri` binary\n-fn find_miri() -> PathBuf {\n-    let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n-    path.set_file_name(\"miri\");\n-    path\n-}\n-\n /// Make sure that the `miri` and `rustc` binary are from the same sysroot.\n /// This can be violated e.g. when miri is locally built and installed with a different\n /// toolchain than what is used when `cargo miri` is run.\n@@ -211,24 +201,6 @@ fn test_sysroot_consistency() {\n     }\n }\n \n-fn cargo() -> Command {\n-    if let Ok(val) = std::env::var(\"CARGO\") {\n-        // Bootstrap tells us where to find cargo\n-        Command::new(val)\n-    } else {\n-        Command::new(\"cargo\")\n-    }\n-}\n-\n-fn xargo() -> Command {\n-    if let Ok(val) = std::env::var(\"XARGO\") {\n-        // Bootstrap tells us where to find xargo\n-        Command::new(val)\n-    } else {\n-        Command::new(\"xargo-check\")\n-    }\n-}\n-\n fn xargo_version() -> Option<(u32, u32, u32)> {\n     let out = xargo().arg(\"--version\").output().ok()?;\n     if !out.status.success() {\n@@ -385,6 +357,7 @@ features = [\"panic_unwind\"]\n         )\n         .unwrap();\n     // The boring bits: a dummy project for xargo.\n+    // FIXME: With xargo-check, can we avoid doing this?\n     File::create(dir.join(\"Cargo.toml\"))\n         .unwrap()\n         .write_all(\n@@ -447,12 +420,12 @@ fn main() {\n     }\n \n     if let Some(\"miri\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n-        // This arm is for when `cargo miri` is called. We call `cargo rustc` for each applicable target,\n+        // This arm is for when `cargo miri` is called. We call `cargo check` for each applicable target,\n         // but with the `RUSTC` env var set to the `cargo-miri` binary so that we come back in the other branch,\n         // and dispatch the invocations to `rustc` and `miri`, respectively.\n         in_cargo_miri();\n     } else if let Some(\"rustc\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n-        // This arm is executed when `cargo-miri` runs `cargo rustc` with the `RUSTC_WRAPPER` env var set to itself:\n+        // This arm is executed when `cargo-miri` runs `cargo check` with the `RUSTC_WRAPPER` env var set to itself:\n         // dependencies get dispatched to `rustc`, the final test/binary to `miri`.\n         inside_cargo_rustc();\n     } else {\n@@ -491,7 +464,7 @@ fn in_cargo_miri() {\n             .kind\n             .get(0)\n             .expect(\"badly formatted cargo metadata: target::kind is an empty array\");\n-        // Now we run `cargo rustc $FLAGS $ARGS`, giving the user the\n+        // Now we run `cargo check $FLAGS $ARGS`, giving the user the\n         // change to add additional arguments. `FLAGS` is set to identify\n         // this target.  The user gets to control what gets actually passed to Miri.\n         let mut cmd = cargo();\n@@ -515,25 +488,29 @@ fn in_cargo_miri() {\n             // The remaining targets we do not even want to build.\n             _ => continue,\n         }\n-        // Add user-defined args until first `--`.\n+        // Forward user-defined `cargo` args until first `--`.\n         while let Some(arg) = args.next() {\n             if arg == \"--\" {\n                 break;\n             }\n             cmd.arg(arg);\n         }\n \n-        // Serialize our actual args into a special environemt variable.\n+        // Serialize the remaining args into a special environemt variable.\n         // This will be read by `inside_cargo_rustc` when we go to invoke\n         // our actual target crate (the binary or the test we are running).\n         // Since we're using \"cargo check\", we have no other way of passing\n         // these arguments.\n         let args_vec: Vec<String> = args.collect();\n-        cmd.env(\"MIRI_MAGIC_ARGS\", serde_json::to_string(&args_vec).expect(\"failed to serialize args\"));\n+        cmd.env(\"MIRI_ARGS\", serde_json::to_string(&args_vec).expect(\"failed to serialize args\"));\n \n+        // Set `RUSTC_WRAPPER` to ourselves.  Cargo will prepend that binary to its usual invocation,\n+        // i.e., the first argument is `rustc` -- which is what we use in `main` to distinguish\n+        // the two codepaths.\n         let path = std::env::current_exe().expect(\"current executable path invalid\");\n         cmd.env(\"RUSTC_WRAPPER\", path);\n         if verbose {\n+            cmd.env(\"MIRI_VERBOSE\", \"\"); // this makes `inside_cargo_rustc` verbose.\n             eprintln!(\"+ {:?}\", cmd);\n         }\n \n@@ -547,45 +524,71 @@ fn in_cargo_miri() {\n }\n \n fn inside_cargo_rustc() {\n-    let sysroot = std::env::var(\"MIRI_SYSROOT\").expect(\"The wrapper should have set MIRI_SYSROOT\");\n-\n-    let rustc_args = std::env::args().skip(2); // skip `cargo rustc`\n+    /// Determines if we are being invoked (as rustc) to build a runnable\n+    /// executable. We run \"cargo check\", so this should only happen when\n+    /// we are trying to compile a build script or build script dependency,\n+    /// which actually needs to be executed on the host platform.\n+    ///\n+    /// Currently, we detect this by checking for \"--emit=link\",\n+    /// which indicates that Cargo instruced rustc to output\n+    /// a native object.\n+    fn is_target_crate() -> bool {\n+        // `--emit` is sometimes missing, e.g. cargo calls rustc for \"--print\".\n+        // That is definitely not a target crate.\n+        // If `--emit` is present, then host crates are built (\"--emit=link,...),\n+        // while the rest is only checked.\n+        get_arg_flag_value(\"--emit\").map_or(false, |emit| !emit.contains(\"link\"))\n+    }\n \n-    let in_build_script = is_build_dep();\n+    /// Returns whether or not Cargo invoked the wrapper (this binary) to compile\n+    /// the final, target crate (either a test for 'cargo test', or a binary for 'cargo run')\n+    /// Cargo does not give us this information directly, so we need to check\n+    /// various command-line flags.\n+    fn is_runnable_crate() -> bool {\n+        let is_bin = get_arg_flag_value(\"--crate-type\").as_deref() == Some(\"bin\");\n+        let is_test = has_arg_flag(\"--test\");\n+\n+        // The final runnable (under Miri) crate will either be a binary crate\n+        // or a test crate. We make sure to exclude build scripts here, since\n+        // they are also build with \"--crate-type bin\"\n+        is_bin || is_test\n+    }\n \n-    // Build scripts need to be compiled to actual runnable executables,\n-    // and therefore completely bypass Miri. We make sure to only specify\n-    // our custom Xargo sysroot for non-build-script crate - that is,\n-    // crates which are ultimately going to get interpreted by Miri.\n-    let mut args = if in_build_script {\n-        rustc_args.collect()\n-    } else {\n-        let mut args: Vec<String> = rustc_args\n-            .chain(Some(\"--sysroot\".to_owned()))\n-            .chain(Some(sysroot))\n-            .collect();\n+    let verbose = std::env::var(\"MIRI_VERBOSE\").is_ok();\n+    let target_crate = is_target_crate();\n+\n+    // Figure out which arguments we need to pass.\n+    let mut args: Vec<String> = std::env::args().skip(2).collect(); // skip `cargo-miri rustc`\n+    // We make sure to only specify our custom Xargo sysroot and\n+    // other args for target crates - that is, crates which are ultimately\n+    // going to get interpreted by Miri.\n+    if target_crate {\n+        let sysroot = std::env::var(\"MIRI_SYSROOT\").expect(\"The wrapper should have set MIRI_SYSROOT\");\n+        args.push(\"--sysroot\".to_owned());\n+        args.push(sysroot);\n         args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n-        args\n-    };\n+    }\n \n-    let needs_miri =\n-        if is_target_crate(in_build_script) {\n-            // This is the 'target crate '- the binary or test crate that\n+    // Figure out the binary we need to call. If this is a runnable target crate, we want to call\n+    // Miri to start interpretation; otherwise we want to call rustc to build the crate as usual.\n+    let mut command =\n+        if target_crate && is_runnable_crate() {\n+            // This is the 'target crate' - the binary or test crate that\n             // we want to interpret under Miri. We deserialize the user-provided arguments\n-            // from the special environment variable \"MIRI_MAGIC_ARGS\", and feed them\n+            // from the special environment variable \"MIRI_ARGS\", and feed them\n             // to the 'miri' binary.\n-            let magic = std::env::var(\"MIRI_MAGIC_ARGS\").expect(\"missing MIRI_MAGIC_ARGS\");\n-            let mut user_args: Vec<String> = serde_json::from_str(&magic).expect(\"failed to deserialize args\");\n+            let magic = std::env::var(\"MIRI_ARGS\").expect(\"missing MIRI_ARGS\");\n+            let mut user_args: Vec<String> = serde_json::from_str(&magic).expect(\"failed to deserialize MIRI_ARGS\");\n             args.append(&mut user_args);\n             // Run this in Miri.\n-            true\n+            Command::new(find_miri())\n         } else {\n-            false\n+            Command::new(\"rustc\")\n         };\n \n-    let mut command = if needs_miri { Command::new(find_miri()) } else { Command::new(\"rustc\") };\n+    // Run it.\n     command.args(&args);\n-    if has_arg_flag(\"-v\") {\n+    if verbose {\n         eprintln!(\"+ {:?}\", command);\n     }\n \n@@ -594,7 +597,6 @@ fn inside_cargo_rustc() {\n             if !exit.success() {\n                 std::process::exit(exit.code().unwrap_or(42));\n             },\n-        Err(ref e) if needs_miri => panic!(\"error during miri run: {:?}\", e),\n-        Err(ref e) => panic!(\"error during rustc call: {:?}\", e),\n+        Err(ref e) => panic!(\"error running {:?}:\\n{:?}\", command, e),\n     }\n }"}]}