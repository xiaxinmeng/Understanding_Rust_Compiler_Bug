{"sha": "ccb54f0ce0002667fbda58cc8bafd356b39e8671", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYjU0ZjBjZTAwMDI2NjdmYmRhNThjYzhiYWZkMzU2YjM5ZTg2NzE=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-30T17:36:29Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-30T19:03:51Z"}, "message": "Move par into libstd. Closes #2441.", "tree": {"sha": "f1b1c9d9b640c8ba3a361c6d8834a8a4b650aa91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1b1c9d9b640c8ba3a361c6d8834a8a4b650aa91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccb54f0ce0002667fbda58cc8bafd356b39e8671", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccb54f0ce0002667fbda58cc8bafd356b39e8671", "html_url": "https://github.com/rust-lang/rust/commit/ccb54f0ce0002667fbda58cc8bafd356b39e8671", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccb54f0ce0002667fbda58cc8bafd356b39e8671/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5554db734e60c6c9b69c9b9a3567460b4da1f13", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5554db734e60c6c9b69c9b9a3567460b4da1f13", "html_url": "https://github.com/rust-lang/rust/commit/f5554db734e60c6c9b69c9b9a3567460b4da1f13"}], "stats": {"total": 225, "additions": 111, "deletions": 114}, "files": [{"sha": "f7d81b3fb0934956f4933e564738446ba7ab6730", "filename": "src/libstd/par.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ccb54f0ce0002667fbda58cc8bafd356b39e8671/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb54f0ce0002667fbda58cc8bafd356b39e8671/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=ccb54f0ce0002667fbda58cc8bafd356b39e8671", "patch": "@@ -0,0 +1,108 @@\n+import comm::port;\n+import comm::chan;\n+import comm::send;\n+import comm::recv;\n+import future::future;\n+\n+export map, mapi, alli, any;\n+\n+#[doc=\"The maximum number of tasks this module will spawn for a single\n+operationg.\"]\n+const max_tasks : uint = 32u;\n+\n+#[doc=\"The minimum number of elements each task will process.\"]\n+const min_granularity : uint = 1024u;\n+\n+#[doc=\"An internal helper to map a function over a large vector and\n+return the intermediate results.\n+\n+This is used to build most of the other parallel vector functions,\n+like map or alli.\"]\n+fn map_slices<A: copy send, B: copy send>(xs: [A],\n+                                          f: fn~(uint, [const A]/&) -> B)\n+    -> [B] {\n+\n+    let len = xs.len();\n+    if len < min_granularity {\n+        log(info, \"small slice\");\n+        // This is a small vector, fall back on the normal map.\n+        [f(0u, xs)]\n+    }\n+    else {\n+        let num_tasks = uint::min(max_tasks, len / min_granularity);\n+\n+        let items_per_task = len / num_tasks;\n+\n+        let mut futures = [];\n+        let mut base = 0u;\n+        log(info, \"spawning tasks\");\n+        while base < len {\n+            let end = uint::min(len, base + items_per_task);\n+            // FIXME: why is the ::<A, ()> annotation required here?\n+            vec::unpack_slice::<A, ()>(xs) {|p, _len|\n+                let f = ptr::addr_of(f);\n+                futures += [future::spawn() {|copy base|\n+                    unsafe {\n+                        let len = end - base;\n+                        let slice = (ptr::offset(p, base),\n+                                     len * sys::size_of::<A>());\n+                        log(info, #fmt(\"pre-slice: %?\", (base, slice)));\n+                        let slice : [const A]/& =\n+                            unsafe::reinterpret_cast(slice);\n+                        log(info, #fmt(\"slice: %?\",\n+                                       (base, vec::len(slice), end - base)));\n+                        assert(vec::len(slice) == end - base);\n+                        (*f)(base, slice)\n+                    }\n+                }];\n+            };\n+            base += items_per_task;\n+        }\n+        log(info, \"tasks spawned\");\n+\n+        log(info, #fmt(\"num_tasks: %?\", (num_tasks, futures.len())));\n+        assert(num_tasks == futures.len());\n+\n+        let r = futures.map() {|ys|\n+            ys.get()\n+        };\n+        assert(r.len() == futures.len());\n+        r\n+    }\n+}\n+\n+#[doc=\"A parallel version of map.\"]\n+fn map<A: copy send, B: copy send>(xs: [A], f: fn~(A) -> B) -> [B] {\n+    vec::concat(map_slices(xs) {|_base, slice|\n+        vec::map(slice, f)\n+    })\n+}\n+\n+#[doc=\"A parallel version of mapi.\"]\n+fn mapi<A: copy send, B: copy send>(xs: [A], f: fn~(uint, A) -> B) -> [B] {\n+    let slices = map_slices(xs) {|base, slice|\n+        vec::mapi(slice) {|i, x|\n+            f(i + base, x)\n+        }\n+    };\n+    let r = vec::concat(slices);\n+    log(info, (r.len(), xs.len()));\n+    assert(r.len() == xs.len());\n+    r\n+}\n+\n+#[doc=\"Returns true if the function holds for all elements in the vector.\"]\n+fn alli<A: copy send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n+    vec::all(map_slices(xs) {|base, slice|\n+        vec::alli(slice) {|i, x|\n+            f(i + base, x)\n+        }\n+    }) {|x| x }\n+}\n+\n+#[doc=\"Returns true if the function holds for any elements in the vector.\"]\n+fn any<A: copy send>(xs: [A], f: fn~(A) -> bool) -> bool {\n+    vec::any(map_slices(xs) {|_base, slice|\n+        vec::any(slice, f)\n+    }) {|x| x }\n+}"}, {"sha": "7558f57a46cfe9b1b5be7984734d7e9984c04f6b", "filename": "src/libstd/std.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ccb54f0ce0002667fbda58cc8bafd356b39e8671/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ccb54f0ce0002667fbda58cc8bafd356b39e8671/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=ccb54f0ce0002667fbda58cc8bafd356b39e8671", "patch": "@@ -17,7 +17,7 @@ export net, net_tcp;\n export uv, uv_ll, uv_iotask, uv_global_loop;\n export c_vec, util, timer;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap;\n-export rope, arena, arc;\n+export rope, arena, arc, par;\n export ebml, dbg, getopts, json, rand, sha1, term, time, prettyprint;\n export test, tempfile, serialization;\n \n@@ -67,6 +67,7 @@ mod time;\n mod prettyprint;\n mod arena;\n mod arc;\n+mod par;\n \n #[cfg(unicode)]\n mod unicode;"}, {"sha": "7f7879649085ec018520321806242e73ecee01f6", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 113, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ccb54f0ce0002667fbda58cc8bafd356b39e8671/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb54f0ce0002667fbda58cc8bafd356b39e8671/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=ccb54f0ce0002667fbda58cc8bafd356b39e8671", "patch": "@@ -11,6 +11,7 @@ import std::map::hashmap;\n import std::deque;\n import std::deque::t;\n import std::arc;\n+import std::par;\n import io::writer_util;\n import comm::*;\n import int::abs;\n@@ -515,116 +516,3 @@ fn main(args: [str]) {\n         #fmt(\"Total sequential: %? \\t Total Parallel: %? \\t Speedup: %?x\",\n              total_seq, total_par, total_seq / total_par));\n }\n-\n-\n-// par stuff /////////////////////////////////////////////////////////\n-\n-mod par {\n-import comm::port;\n-import comm::chan;\n-import comm::send;\n-import comm::recv;\n-import future::future;\n-\n-#[doc=\"The maximum number of tasks this module will spawn for a single\n- operationg.\"]\n-const max_tasks : uint = 32u;\n-\n-#[doc=\"The minimum number of elements each task will process.\"]\n-const min_granularity : uint = 1024u;\n-\n-#[doc=\"An internal helper to map a function over a large vector and\n- return the intermediate results.\n-\n-This is used to build most of the other parallel vector functions,\n-like map or alli.\"]\n-fn map_slices<A: copy send, B: copy send>(xs: [A],\n-                                          f: fn~(uint, [const A]/&) -> B) \n-    -> [B] {\n-\n-    let len = xs.len();\n-    if len < min_granularity {\n-        log(info, \"small slice\");\n-        // This is a small vector, fall back on the normal map.\n-        [f(0u, xs)]\n-    }\n-    else {\n-        let num_tasks = uint::min(max_tasks, len / min_granularity);\n-\n-        let items_per_task = len / num_tasks;\n-\n-        let mut futures = [];\n-        let mut base = 0u;\n-        log(info, \"spawning tasks\");\n-        while base < len {\n-            let end = uint::min(len, base + items_per_task);\n-            // FIXME: why is the ::<A, ()> annotation required here?\n-            vec::unpack_slice::<A, ()>(xs) {|p, _len|\n-                let f = ptr::addr_of(f);\n-                futures += [future::spawn() {|copy base|\n-                    unsafe {\n-                        let len = end - base;\n-                        let slice = (ptr::offset(p, base),\n-                                     len * sys::size_of::<A>());\n-                        log(info, #fmt(\"pre-slice: %?\", (base, slice)));\n-                        let slice : [const A]/& = \n-                            unsafe::reinterpret_cast(slice);\n-                        log(info, #fmt(\"slice: %?\",\n-                                       (base, vec::len(slice), end - base)));\n-                        assert(vec::len(slice) == end - base);\n-                        (*f)(base, slice)\n-                    }\n-                }];\n-            };\n-            base += items_per_task;\n-        }\n-        log(info, \"tasks spawned\");\n-\n-        log(info, #fmt(\"num_tasks: %?\", (num_tasks, futures.len())));\n-        assert(num_tasks == futures.len());\n-\n-        let r = futures.map() {|ys|\n-            ys.get()\n-        };\n-        assert(r.len() == futures.len());\n-        r\n-    }\n-}\n-\n-#[doc=\"A parallel version of map.\"]\n-fn map<A: copy send, B: copy send>(xs: [A], f: fn~(A) -> B) -> [B] {\n-    vec::concat(map_slices(xs) {|_base, slice|\n-        vec::map(slice, f)\n-    })\n-}\n-\n-#[doc=\"A parallel version of mapi.\"]\n-fn mapi<A: copy send, B: copy send>(xs: [A], f: fn~(uint, A) -> B) -> [B] {\n-    let slices = map_slices(xs) {|base, slice|\n-        vec::mapi(slice) {|i, x|\n-            f(i + base, x)\n-        }\n-    };\n-    let r = vec::concat(slices);\n-    log(info, (r.len(), xs.len()));\n-    assert(r.len() == xs.len());\n-    r\n-}\n-\n-#[doc=\"Returns true if the function holds for all elements in the vector.\"]\n-fn alli<A: copy send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n-    vec::all(map_slices(xs) {|base, slice|\n-        vec::alli(slice) {|i, x|\n-            f(i + base, x)\n-        }\n-    }) {|x| x }\n-}\n-\n-    #[doc=\"Returns true if the function holds for any elements in the vector.\"]\n-    fn any<A: copy send>(xs: [A], f: fn~(A) -> bool) -> bool {\n-        vec::any(map_slices(xs) {|_base, slice|\n-            vec::any(slice, f)\n-        }) {|x| x }\n-    }\n-\n-}"}]}