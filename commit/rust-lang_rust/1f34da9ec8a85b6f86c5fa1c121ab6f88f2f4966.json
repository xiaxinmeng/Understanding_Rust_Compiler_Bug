{"sha": "1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "node_id": "C_kwDOAAsO6NoAKDFmMzRkYTllYzhhODViNmY4NmM1ZmExYzEyMWFiNmY4OGYyZjQ5NjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-14T17:19:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-14T17:19:38Z"}, "message": "Auto merge of #96591 - b-naber:transition-to-valtrees-in-type-system, r=lcnr\n\nUse valtrees as the type-system representation for constant values\n\nThis is not quite ready yet, there are still some problems with pretty printing and symbol mangling and `deref_const` seems to not work correctly in all cases.\n\nMainly opening now for a perf-run (which should be good to go, despite the still existing problems).\n\nr? `@oli-obk`\n\ncc `@lcnr` `@RalfJung`", "tree": {"sha": "26035c94f6942c918a3bac5708a1cd3071bbe5e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26035c94f6942c918a3bac5708a1cd3071bbe5e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "html_url": "https://github.com/rust-lang/rust/commit/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "872503d918b2c3266d828f85e42951df74f5e303", "url": "https://api.github.com/repos/rust-lang/rust/commits/872503d918b2c3266d828f85e42951df74f5e303", "html_url": "https://github.com/rust-lang/rust/commit/872503d918b2c3266d828f85e42951df74f5e303"}, {"sha": "15c1c0652298e9dd3dee45813a2718623f6e3702", "url": "https://api.github.com/repos/rust-lang/rust/commits/15c1c0652298e9dd3dee45813a2718623f6e3702", "html_url": "https://github.com/rust-lang/rust/commit/15c1c0652298e9dd3dee45813a2718623f6e3702"}], "stats": {"total": 2617, "additions": 1610, "deletions": 1007}, "files": [{"sha": "ef72e6efb946b3cabe8a9881ea9ab2438018791e", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -127,7 +127,7 @@ pub(crate) fn codegen_constant<'tcx>(\n         ConstantKind::Val(val, ty) => return codegen_const_value(fx, val, ty),\n     };\n     let const_val = match const_.kind() {\n-        ConstKind::Value(const_val) => const_val,\n+        ConstKind::Value(valtree) => fx.tcx.valtree_to_const_val((const_.ty(), valtree)),\n         ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n             if fx.tcx.is_static(def.did) =>\n         {\n@@ -468,9 +468,10 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n ) -> Option<ConstValue<'tcx>> {\n     match operand {\n         Operand::Constant(const_) => match const_.literal {\n-            ConstantKind::Ty(const_) => {\n-                fx.monomorphize(const_).eval(fx.tcx, ParamEnv::reveal_all()).kind().try_to_value()\n-            }\n+            ConstantKind::Ty(const_) => fx\n+                .monomorphize(const_)\n+                .eval_for_mir(fx.tcx, ParamEnv::reveal_all())\n+                .try_to_value(fx.tcx),\n             ConstantKind::Val(val, _) => Some(val),\n         },\n         // FIXME(rust-lang/rust#85105): Casts like `IMM8 as u32` result in the const being stored"}, {"sha": "8755d91818d229ecf5117b054f8c3c43fb598206", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -703,15 +703,19 @@ fn push_const_param<'tcx>(tcx: TyCtxt<'tcx>, ct: ty::Const<'tcx>, output: &mut S\n                 // but we get a deterministic, virtually unique value for the constant.\n                 let hcx = &mut tcx.create_stable_hashing_context();\n                 let mut hasher = StableHasher::new();\n-                hcx.while_hashing_spans(false, |hcx| ct.kind().hash_stable(hcx, &mut hasher));\n+                let ct = ct.eval(tcx, ty::ParamEnv::reveal_all());\n+                hcx.while_hashing_spans(false, |hcx| ct.to_valtree().hash_stable(hcx, &mut hasher));\n                 // Let's only emit 64 bits of the hash value. That should be plenty for\n                 // avoiding collisions and will make the emitted type names shorter.\n-                let hash: u64 = hasher.finish();\n+                // Note: Don't use `StableHashResult` impl of `u64` here directly, since that\n+                // would lead to endianness problems.\n+                let hash: u128 = hasher.finish();\n+                let hash_short = (hash.to_le() as u64).to_le();\n \n                 if cpp_like_debuginfo(tcx) {\n-                    write!(output, \"CONST${:x}\", hash)\n+                    write!(output, \"CONST${:x}\", hash_short)\n                 } else {\n-                    write!(output, \"{{CONST#{:x}}}\", hash)\n+                    write!(output, \"{{CONST#{:x}}}\", hash_short)\n                 }\n             }\n         },"}, {"sha": "9a995fbf65ca25429a2ef91dbdaacf628d04479f", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n                     err\n                 }),\n-            ty::ConstKind::Value(value) => Ok(value),\n+            ty::ConstKind::Value(val) => Ok(self.cx.tcx().valtree_to_const_val((ct.ty(), val))),\n             err => span_bug!(\n                 constant.span,\n                 \"encountered bad ConstKind after monomorphizing: {:?}\",\n@@ -58,14 +58,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         constant\n             .map(|val| {\n                 let field_ty = ty.builtin_index().unwrap();\n-                let c = ty::Const::from_value(bx.tcx(), val, ty);\n+                let c = mir::ConstantKind::from_value(val, ty);\n                 let values: Vec<_> = bx\n                     .tcx()\n-                    .destructure_const(ty::ParamEnv::reveal_all().and(c))\n+                    .destructure_mir_constant(ty::ParamEnv::reveal_all(), c)\n                     .fields\n                     .iter()\n                     .map(|field| {\n-                        if let Some(prim) = field.kind().try_to_scalar() {\n+                        if let Some(prim) = field.try_to_scalar() {\n                             let layout = bx.layout_of(field_ty);\n                             let Abi::Scalar(scalar) = layout.abi else {\n                                 bug!(\"from_const: invalid ByVal layout: {:#?}\", layout);"}, {"sha": "3eeb0138b37f7b06dcfd14cf62811206c30e668e", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -140,6 +140,7 @@ impl<'tcx> ConstEvalErr<'tcx> {\n     ///\n     /// If `lint_root.is_some()` report it as a lint, else report it as a hard error.\n     /// (Except that for some errors, we ignore all that -- see `must_error` below.)\n+    #[instrument(skip(self, tcx, decorate, lint_root), level = \"debug\")]\n     fn struct_generic(\n         &self,\n         tcx: TyCtxtAt<'tcx>,\n@@ -190,6 +191,7 @@ impl<'tcx> ConstEvalErr<'tcx> {\n             decorate(err);\n         };\n \n+        debug!(\"self.error: {:?}\", self.error);\n         // Special handling for certain errors\n         match &self.error {\n             // Don't emit a new diagnostic for these errors"}, {"sha": "b7e5e7aea49ce5a1cdf544db80be81b02bb79d5e", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -196,7 +196,7 @@ pub(super) fn op_to_const<'tcx>(\n }\n \n #[instrument(skip(tcx), level = \"debug\")]\n-fn turn_into_const_value<'tcx>(\n+pub(crate) fn turn_into_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     constant: ConstAlloc<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n@@ -222,6 +222,7 @@ fn turn_into_const_value<'tcx>(\n     const_val\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n pub fn eval_to_const_value_raw_provider<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n@@ -256,6 +257,7 @@ pub fn eval_to_const_value_raw_provider<'tcx>(\n     tcx.eval_to_allocation_raw(key).map(|val| turn_into_const_value(tcx, val, key))\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n pub fn eval_to_allocation_raw_provider<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,"}, {"sha": "a1d2e5cf3ef1228f4754c0ab31672909f61a07ba", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 81, "deletions": 76, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,12 +1,11 @@\n // Not in interpret to make sure we do not use private implementation details\n \n-use std::convert::TryFrom;\n-\n use rustc_hir::Mutability;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{EvalToValTreeResult, GlobalId};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n+use rustc_target::abi::VariantIdx;\n \n use crate::interpret::{\n     intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MemPlaceMeta,\n@@ -40,7 +39,7 @@ pub(crate) fn const_caller_location(\n }\n \n // We forbid type-level constants that contain more than `VALTREE_MAX_NODES` nodes.\n-const VALTREE_MAX_NODES: usize = 1000;\n+const VALTREE_MAX_NODES: usize = 100000;\n \n pub(crate) enum ValTreeCreationError {\n     NodesOverflow,\n@@ -56,6 +55,8 @@ pub(crate) fn eval_to_valtree<'tcx>(\n     cid: GlobalId<'tcx>,\n ) -> EvalToValTreeResult<'tcx> {\n     let const_alloc = tcx.eval_to_allocation_raw(param_env.and(cid))?;\n+\n+    // FIXME Need to provide a span to `eval_to_valtree`\n     let ecx = mk_eval_cx(\n         tcx, DUMMY_SP, param_env,\n         // It is absolutely crucial for soundness that\n@@ -90,40 +91,81 @@ pub(crate) fn eval_to_valtree<'tcx>(\n     }\n }\n \n-/// This function should never fail for validated constants. However, it is also invoked from the\n-/// pretty printer which might attempt to format invalid constants and in that case it might fail.\n+/// Tries to destructure constants of type Array or Adt into the constants\n+/// of its fields.\n pub(crate) fn try_destructure_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    val: ty::Const<'tcx>,\n-) -> InterpResult<'tcx, mir::DestructuredConst<'tcx>> {\n-    trace!(\"destructure_const: {:?}\", val);\n-    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n-    let op = ecx.const_to_op(val, None)?;\n-    // We go to `usize` as we cannot allocate anything bigger anyway.\n-    let (field_count, variant, down) = match val.ty().kind() {\n-        ty::Array(_, len) => (usize::try_from(len.eval_usize(tcx, param_env)).unwrap(), None, op),\n-        // Checks if we have any variants, to avoid downcasting to a non-existing variant (when\n-        // there are no variants `read_discriminant` successfully returns a non-existing variant\n-        // index).\n-        ty::Adt(def, _) if def.variants().is_empty() => throw_ub!(Unreachable),\n-        ty::Adt(def, _) => {\n-            let variant = ecx.read_discriminant(&op)?.1;\n-            let down = ecx.operand_downcast(&op, variant)?;\n-            (def.variant(variant).fields.len(), Some(variant), down)\n-        }\n-        ty::Tuple(substs) => (substs.len(), None, op),\n-        _ => bug!(\"cannot destructure constant {:?}\", val),\n-    };\n-    let fields = (0..field_count)\n-        .map(|i| {\n-            let field_op = ecx.operand_field(&down, i)?;\n-            let val = op_to_const(&ecx, &field_op);\n-            Ok(ty::Const::from_value(tcx, val, field_op.layout.ty))\n-        })\n-        .collect::<InterpResult<'tcx, Vec<_>>>()?;\n-    let fields = tcx.arena.alloc_from_iter(fields);\n-    Ok(mir::DestructuredConst { variant, fields })\n+    const_: ty::Const<'tcx>,\n+) -> Option<ty::DestructuredConst<'tcx>> {\n+    if let ty::ConstKind::Value(valtree) = const_.kind() {\n+        let branches = match valtree {\n+            ty::ValTree::Branch(b) => b,\n+            _ => return None,\n+        };\n+\n+        let (fields, variant) = match const_.ty().kind() {\n+            ty::Array(inner_ty, _) | ty::Slice(inner_ty) => {\n+                // construct the consts for the elements of the array/slice\n+                let field_consts = branches\n+                    .iter()\n+                    .map(|b| {\n+                        tcx.mk_const(ty::ConstS { kind: ty::ConstKind::Value(*b), ty: *inner_ty })\n+                    })\n+                    .collect::<Vec<_>>();\n+                debug!(?field_consts);\n+\n+                (field_consts, None)\n+            }\n+            ty::Adt(def, _) if def.variants().is_empty() => bug!(\"unreachable\"),\n+            ty::Adt(def, substs) => {\n+                let variant_idx = if def.is_enum() {\n+                    VariantIdx::from_u32(branches[0].unwrap_leaf().try_to_u32().ok()?)\n+                } else {\n+                    VariantIdx::from_u32(0)\n+                };\n+                let fields = &def.variant(variant_idx).fields;\n+                let mut field_consts = Vec::with_capacity(fields.len());\n+\n+                // Note: First element inValTree corresponds to variant of enum\n+                let mut valtree_idx = if def.is_enum() { 1 } else { 0 };\n+                for field in fields {\n+                    let field_ty = field.ty(tcx, substs);\n+                    let field_valtree = branches[valtree_idx]; // first element of branches is variant\n+                    let field_const = tcx.mk_const(ty::ConstS {\n+                        kind: ty::ConstKind::Value(field_valtree),\n+                        ty: field_ty,\n+                    });\n+                    field_consts.push(field_const);\n+                    valtree_idx += 1;\n+                }\n+                debug!(?field_consts);\n+\n+                (field_consts, Some(variant_idx))\n+            }\n+            ty::Tuple(elem_tys) => {\n+                let fields = elem_tys\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, elem_ty)| {\n+                        let elem_valtree = branches[i];\n+                        tcx.mk_const(ty::ConstS {\n+                            kind: ty::ConstKind::Value(elem_valtree),\n+                            ty: elem_ty,\n+                        })\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                (fields, None)\n+            }\n+            _ => bug!(\"cannot destructure constant {:?}\", const_),\n+        };\n+\n+        let fields = tcx.arena.alloc_from_iter(fields.into_iter());\n+\n+        Some(ty::DestructuredConst { variant, fields })\n+    } else {\n+        None\n+    }\n }\n \n #[instrument(skip(tcx), level = \"debug\")]\n@@ -143,8 +185,8 @@ pub(crate) fn try_destructure_mir_constant<'tcx>(\n             throw_ub!(Unreachable)\n         }\n         ty::Adt(def, _) => {\n-            let variant = ecx.read_discriminant(&op).unwrap().1;\n-            let down = ecx.operand_downcast(&op, variant).unwrap();\n+            let variant = ecx.read_discriminant(&op)?.1;\n+            let down = ecx.operand_downcast(&op, variant)?;\n             (def.variants()[variant].fields.len(), Some(variant), down)\n         }\n         ty::Tuple(substs) => (substs.len(), None, op),\n@@ -163,43 +205,6 @@ pub(crate) fn try_destructure_mir_constant<'tcx>(\n     Ok(mir::DestructuredMirConstant { variant, fields })\n }\n \n-#[instrument(skip(tcx), level = \"debug\")]\n-pub(crate) fn deref_const<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    val: ty::Const<'tcx>,\n-) -> ty::Const<'tcx> {\n-    trace!(\"deref_const: {:?}\", val);\n-    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n-    let op = ecx.const_to_op(val, None).unwrap();\n-    let mplace = ecx.deref_operand(&op).unwrap();\n-    if let Some(alloc_id) = mplace.ptr.provenance {\n-        assert_eq!(\n-            tcx.get_global_alloc(alloc_id).unwrap().unwrap_memory().inner().mutability,\n-            Mutability::Not,\n-            \"deref_const cannot be used with mutable allocations as \\\n-            that could allow pattern matching to observe mutable statics\",\n-        );\n-    }\n-\n-    let ty = match mplace.meta {\n-        MemPlaceMeta::None => mplace.layout.ty,\n-        MemPlaceMeta::Poison => bug!(\"poison metadata in `deref_const`: {:#?}\", mplace),\n-        // In case of unsized types, figure out the real type behind.\n-        MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n-            ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n-            ty::Slice(elem_ty) => tcx.mk_array(*elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n-            _ => bug!(\n-                \"type {} should not have metadata, but had {:?}\",\n-                mplace.layout.ty,\n-                mplace.meta\n-            ),\n-        },\n-    };\n-\n-    tcx.mk_const(ty::ConstS { kind: ty::ConstKind::Value(op_to_const(&ecx, &mplace.into())), ty })\n-}\n-\n #[instrument(skip(tcx), level = \"debug\")]\n pub(crate) fn deref_mir_constant<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -213,14 +218,14 @@ pub(crate) fn deref_mir_constant<'tcx>(\n         assert_eq!(\n             tcx.get_global_alloc(alloc_id).unwrap().unwrap_memory().0.0.mutability,\n             Mutability::Not,\n-            \"deref_const cannot be used with mutable allocations as \\\n+            \"deref_mir_constant cannot be used with mutable allocations as \\\n             that could allow pattern matching to observe mutable statics\",\n         );\n     }\n \n     let ty = match mplace.meta {\n         MemPlaceMeta::None => mplace.layout.ty,\n-        MemPlaceMeta::Poison => bug!(\"poison metadata in `deref_const`: {:#?}\", mplace),\n+        MemPlaceMeta::Poison => bug!(\"poison metadata in `deref_mir_constant`: {:#?}\", mplace),\n         // In case of unsized types, figure out the real type behind.\n         MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n             ty::Str => bug!(\"there's no sized equivalent of a `str`\"),"}, {"sha": "4849a07e3b4f4a626f6a2b005f0c8cf4ff177f63", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -5,13 +5,11 @@ use crate::interpret::{\n     intern_const_alloc_recursive, ConstValue, ImmTy, Immediate, InternKind, MemPlaceMeta,\n     MemoryKind, PlaceTy, Scalar, ScalarMaybeUninit,\n };\n+use crate::interpret::{MPlaceTy, Value};\n+use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_target::abi::{Align, VariantIdx};\n \n-use crate::interpret::MPlaceTy;\n-use crate::interpret::Value;\n-use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n-\n #[instrument(skip(ecx), level = \"debug\")]\n fn branches<'tcx>(\n     ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n@@ -76,13 +74,13 @@ pub(crate) fn const_to_valtree_inner<'tcx>(\n     place: &MPlaceTy<'tcx>,\n     num_nodes: &mut usize,\n ) -> ValTreeCreationResult<'tcx> {\n+    let ty = place.layout.ty;\n+    debug!(\"ty kind: {:?}\", ty.kind());\n+\n     if *num_nodes >= VALTREE_MAX_NODES {\n         return Err(ValTreeCreationError::NodesOverflow);\n     }\n \n-    let ty = place.layout.ty;\n-    debug!(\"ty kind: {:?}\", ty.kind());\n-\n     match ty.kind() {\n         ty::FnDef(..) => {\n             *num_nodes += 1;\n@@ -234,19 +232,15 @@ fn create_pointee_place<'tcx>(\n         // Get the size of the memory behind the DST\n         let dst_size = unsized_inner_ty_size.checked_mul(num_elems as u64, &tcx).unwrap();\n \n-        let ptr = ecx\n-            .allocate_ptr(\n-                size_of_sized_part.checked_add(dst_size, &tcx).unwrap(),\n-                Align::from_bytes(1).unwrap(),\n-                MemoryKind::Stack,\n-            )\n-            .unwrap();\n+        let size = size_of_sized_part.checked_add(dst_size, &tcx).unwrap();\n+        let align = Align::from_bytes(size.bytes().next_power_of_two()).unwrap();\n+        let ptr = ecx.allocate_ptr(size, align, MemoryKind::Stack).unwrap();\n         debug!(?ptr);\n \n         let place = MPlaceTy::from_aligned_ptr_with_meta(\n             ptr.into(),\n             layout,\n-            MemPlaceMeta::Meta(Scalar::from_u64(num_elems as u64)),\n+            MemPlaceMeta::Meta(Scalar::from_machine_usize(num_elems as u64, &tcx)),\n         );\n         debug!(?place);\n \n@@ -262,7 +256,7 @@ fn create_pointee_place<'tcx>(\n #[instrument(skip(tcx), level = \"debug\")]\n pub fn valtree_to_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n+    param_env_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n     valtree: ty::ValTree<'tcx>,\n ) -> ConstValue<'tcx> {\n     // Basic idea: We directly construct `Scalar` values from trivial `ValTree`s\n@@ -272,8 +266,8 @@ pub fn valtree_to_const_value<'tcx>(\n     // create inner `MPlace`s which are filled recursively.\n     // FIXME Does this need an example?\n \n-    let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::empty(), false);\n-    let param_env_ty = ty::ParamEnv::empty().and(ty);\n+    let (param_env, ty) = param_env_ty.into_parts();\n+    let mut ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n \n     match ty.kind() {\n         ty::FnDef(..) => {\n@@ -336,7 +330,6 @@ pub fn valtree_to_const_value<'tcx>(\n     }\n }\n \n-// FIXME Needs a better/correct name\n #[instrument(skip(ecx), level = \"debug\")]\n fn valtree_into_mplace<'tcx>(\n     ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,\n@@ -377,7 +370,8 @@ fn valtree_into_mplace<'tcx>(\n             let imm = match inner_ty.kind() {\n                 ty::Slice(_) | ty::Str => {\n                     let len = valtree.unwrap_branch().len();\n-                    let len_scalar = ScalarMaybeUninit::Scalar(Scalar::from_u64(len as u64));\n+                    let len_scalar =\n+                        ScalarMaybeUninit::Scalar(Scalar::from_machine_usize(len as u64, &tcx));\n \n                     Immediate::ScalarPair(\n                         ScalarMaybeUninit::from_maybe_pointer((*pointee_place).ptr, &tcx),\n@@ -448,7 +442,10 @@ fn valtree_into_mplace<'tcx>(\n                         place\n                             .offset(\n                                 offset,\n-                                MemPlaceMeta::Meta(Scalar::from_u64(num_elems as u64)),\n+                                MemPlaceMeta::Meta(Scalar::from_machine_usize(\n+                                    num_elems as u64,\n+                                    &tcx,\n+                                )),\n                                 inner_layout,\n                                 &tcx,\n                             )"}, {"sha": "6b05a49575fd9e2cf1279a6aea7797351417bec4", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -637,7 +637,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::ConstKind::Infer(..) | ty::ConstKind::Placeholder(..) => {\n                 span_bug!(self.cur_span(), \"const_to_op: Unexpected ConstKind {:?}\", c)\n             }\n-            ty::ConstKind::Value(val) => self.const_val_to_op(val, c.ty(), layout),\n+            ty::ConstKind::Value(valtree) => {\n+                let ty = c.ty();\n+                let const_val = self.tcx.valtree_to_const_val((ty, valtree));\n+                self.const_val_to_op(const_val, ty, layout)\n+            }\n         }\n     }\n "}, {"sha": "64a74e9d7e206931ee3fe0f3309aaaca8ce4fdc4", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -34,17 +34,15 @@ pub mod interpret;\n pub mod transform;\n pub mod util;\n \n+use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n \n pub fn provide(providers: &mut Providers) {\n     const_eval::provide(providers);\n     providers.eval_to_const_value_raw = const_eval::eval_to_const_value_raw_provider;\n     providers.eval_to_allocation_raw = const_eval::eval_to_allocation_raw_provider;\n     providers.const_caller_location = const_eval::const_caller_location;\n-    providers.try_destructure_const = |tcx, param_env_and_val| {\n-        let (param_env, c) = param_env_and_val.into_parts();\n-        const_eval::try_destructure_const(tcx, param_env, c).ok()\n-    };\n+    providers.try_destructure_const = |tcx, val| const_eval::try_destructure_const(tcx, val);\n     providers.eval_to_valtree = |tcx, param_env_and_value| {\n         let (param_env, raw) = param_env_and_value.into_parts();\n         const_eval::eval_to_valtree(tcx, param_env, raw)\n@@ -53,11 +51,8 @@ pub fn provide(providers: &mut Providers) {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::try_destructure_mir_constant(tcx, param_env, value).ok()\n     };\n-    providers.valtree_to_const_val =\n-        |tcx, (ty, valtree)| const_eval::valtree_to_const_value(tcx, ty, valtree);\n-    providers.deref_const = |tcx, param_env_and_value| {\n-        let (param_env, value) = param_env_and_value.into_parts();\n-        const_eval::deref_const(tcx, param_env, value)\n+    providers.valtree_to_const_val = |tcx, (ty, valtree)| {\n+        const_eval::valtree_to_const_value(tcx, ty::ParamEnv::empty().and(ty), valtree)\n     };\n     providers.deref_mir_constant = |tcx, param_env_and_value| {\n         let (param_env, value) = param_env_and_value.into_parts();"}, {"sha": "3595a488d0c5b716f3b721147e6a2f43bfbd0b03", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -765,7 +765,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         let unit = Rvalue::Use(Operand::Constant(Box::new(Constant {\n                             span: statement.source_info.span,\n                             user_ty: None,\n-                            literal: ty::Const::zero_sized(self.tcx, self.tcx.types.unit).into(),\n+                            literal: ConstantKind::zero_sized(self.tcx.types.unit),\n                         })));\n                         mem::replace(rhs, unit)\n                     },\n@@ -835,26 +835,25 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             let mut promoted_operand = |ty, span| {\n                 promoted.span = span;\n                 promoted.local_decls[RETURN_PLACE] = LocalDecl::new(ty, span);\n+                let _const = tcx.mk_const(ty::ConstS {\n+                    ty,\n+                    kind: ty::ConstKind::Unevaluated(ty::Unevaluated {\n+                        def,\n+                        substs: InternalSubsts::for_item(tcx, def.did, |param, _| {\n+                            if let ty::GenericParamDefKind::Lifetime = param.kind {\n+                                tcx.lifetimes.re_erased.into()\n+                            } else {\n+                                tcx.mk_param_from_def(param)\n+                            }\n+                        }),\n+                        promoted: Some(promoted_id),\n+                    }),\n+                });\n \n                 Operand::Constant(Box::new(Constant {\n                     span,\n                     user_ty: None,\n-                    literal: tcx\n-                        .mk_const(ty::ConstS {\n-                            ty,\n-                            kind: ty::ConstKind::Unevaluated(ty::Unevaluated {\n-                                def,\n-                                substs: InternalSubsts::for_item(tcx, def.did, |param, _| {\n-                                    if let ty::GenericParamDefKind::Lifetime = param.kind {\n-                                        tcx.lifetimes.re_erased.into()\n-                                    } else {\n-                                        tcx.mk_param_from_def(param)\n-                                    }\n-                                }),\n-                                promoted: Some(promoted_id),\n-                            }),\n-                        })\n-                        .into(),\n+                    literal: ConstantKind::from_const(_const, tcx),\n                 }))\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();"}, {"sha": "93a067cb5160633e441a632fa43e621a1cb561a1", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n-use rustc_middle::mir::interpret::{ErrorHandled, EvalToConstValueResult};\n+use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n use rustc_middle::traits::select;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n@@ -1616,6 +1616,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         u\n     }\n \n+    pub fn try_const_eval_resolve(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        unevaluated: ty::Unevaluated<'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Option<Span>,\n+    ) -> Result<ty::Const<'tcx>, ErrorHandled> {\n+        match self.const_eval_resolve(param_env, unevaluated, span) {\n+            Ok(Some(val)) => Ok(ty::Const::from_value(self.tcx, val, ty)),\n+            Ok(None) => {\n+                let tcx = self.tcx;\n+                let def_id = unevaluated.def.did;\n+                span_bug!(\n+                    tcx.def_span(def_id),\n+                    \"unable to construct a constant value for the unevaluated constant {:?}\",\n+                    unevaluated\n+                );\n+            }\n+            Err(err) => Err(err),\n+        }\n+    }\n+\n     /// Resolves and evaluates a constant.\n     ///\n     /// The constant can be located on a trait like `<A as B>::C`, in which case the given\n@@ -1634,7 +1656,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         unevaluated: ty::Unevaluated<'tcx>,\n         span: Option<Span>,\n-    ) -> EvalToConstValueResult<'tcx> {\n+    ) -> EvalToValTreeResult<'tcx> {\n         let substs = self.resolve_vars_if_possible(unevaluated.substs);\n         debug!(?substs);\n \n@@ -1658,7 +1680,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         // The return value is the evaluated value which doesn't contain any reference to inference\n         // variables, thus we don't need to substitute back the original values.\n-        self.tcx.const_eval_resolve(param_env_erased, unevaluated, span)\n+        self.tcx.const_eval_resolve_for_typeck(param_env_erased, unevaluated, span)\n     }\n \n     /// `ty_or_const_infer_var_changed` is equivalent to one of these two:"}, {"sha": "5f32f0d5e89febbe4ebabfc375a2865c889785bb", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 54, "deletions": 8, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,4 +1,4 @@\n-use super::{ErrorHandled, EvalToConstValueResult, GlobalId};\n+use super::{ErrorHandled, EvalToConstValueResult, EvalToValTreeResult, GlobalId};\n \n use crate::mir;\n use crate::ty::fold::TypeFoldable;\n@@ -11,6 +11,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Evaluates a constant without providing any substitutions. This is useful to evaluate consts\n     /// that can't take any generic arguments like statics, const items or enum discriminants. If a\n     /// generic parameter is used within the constant `ErrorHandled::ToGeneric` will be returned.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn const_eval_poly(self, def_id: DefId) -> EvalToConstValueResult<'tcx> {\n         // In some situations def_id will have substitutions within scope, but they aren't allowed\n         // to be used. So we can't use `Instance::mono`, instead we feed unresolved substitutions\n@@ -22,7 +23,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         let param_env = self.param_env(def_id).with_reveal_all_normalized(self);\n         self.const_eval_global_id(param_env, cid, None)\n     }\n-\n     /// Resolves and evaluates a constant.\n     ///\n     /// The constant can be located on a trait like `<A as B>::C`, in which case the given\n@@ -59,6 +59,33 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n+    pub fn const_eval_resolve_for_typeck(\n+        self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ct: ty::Unevaluated<'tcx>,\n+        span: Option<Span>,\n+    ) -> EvalToValTreeResult<'tcx> {\n+        // Cannot resolve `Unevaluated` constants that contain inference\n+        // variables. We reject those here since `resolve_opt_const_arg`\n+        // would fail otherwise.\n+        //\n+        // When trying to evaluate constants containing inference variables,\n+        // use `Infcx::const_eval_resolve` instead.\n+        if ct.substs.has_infer_types_or_consts() {\n+            bug!(\"did not expect inference variables here\");\n+        }\n+\n+        match ty::Instance::resolve_opt_const_arg(self, param_env, ct.def, ct.substs) {\n+            Ok(Some(instance)) => {\n+                let cid = GlobalId { instance, promoted: ct.promoted };\n+                self.const_eval_global_id_for_typeck(param_env, cid, span)\n+            }\n+            Ok(None) => Err(ErrorHandled::TooGeneric),\n+            Err(error_reported) => Err(ErrorHandled::Reported(error_reported)),\n+        }\n+    }\n+\n     pub fn const_eval_instance(\n         self,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -68,7 +95,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.const_eval_global_id(param_env, GlobalId { instance, promoted: None }, span)\n     }\n \n-    /// Evaluate a constant.\n+    /// Evaluate a constant to a `ConstValue`.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn const_eval_global_id(\n         self,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -86,6 +114,27 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Evaluate a constant to a type-level constant.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub fn const_eval_global_id_for_typeck(\n+        self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        cid: GlobalId<'tcx>,\n+        span: Option<Span>,\n+    ) -> EvalToValTreeResult<'tcx> {\n+        let param_env = param_env.with_const();\n+        debug!(?param_env);\n+        // Const-eval shouldn't depend on lifetimes at all, so we can erase them, which should\n+        // improve caching of queries.\n+        let inputs = self.erase_regions(param_env.and(cid));\n+        debug!(?inputs);\n+        if let Some(span) = span {\n+            self.at(span).eval_to_valtree(inputs)\n+        } else {\n+            self.eval_to_valtree(inputs)\n+        }\n+    }\n+\n     /// Evaluate a static's initializer, returning the allocation of the initializer's memory.\n     #[inline(always)]\n     pub fn eval_static_initializer(\n@@ -125,11 +174,8 @@ impl<'tcx> TyCtxtAt<'tcx> {\n impl<'tcx> TyCtxt<'tcx> {\n     /// Destructure a type-level constant ADT or array into its variant index and its field values.\n     /// Panics if the destructuring fails, use `try_destructure_const` for fallible version.\n-    pub fn destructure_const(\n-        self,\n-        param_env_and_val: ty::ParamEnvAnd<'tcx, ty::Const<'tcx>>,\n-    ) -> mir::DestructuredConst<'tcx> {\n-        self.try_destructure_const(param_env_and_val).unwrap()\n+    pub fn destructure_const(self, const_: ty::Const<'tcx>) -> ty::DestructuredConst<'tcx> {\n+        self.try_destructure_const(const_).unwrap()\n     }\n \n     /// Destructure a mir constant ADT or array into its variant index and its field values."}, {"sha": "e80918d5e5d032228ee7d329f9611a742d36471a", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -111,6 +111,10 @@ impl<'tcx> ConstValue<'tcx> {\n     pub fn from_machine_usize(i: u64, cx: &impl HasDataLayout) -> Self {\n         ConstValue::Scalar(Scalar::from_machine_usize(i, cx))\n     }\n+\n+    pub fn zst() -> Self {\n+        Self::Scalar(Scalar::ZST)\n+    }\n }\n \n /// A `Scalar` represents an immediate, primitive value existing outside of a"}, {"sha": "c173d453041baf0c0549141e9592e2a951a32006", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 223, "deletions": 39, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -3,7 +3,9 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n use crate::mir::coverage::{CodeRegion, CoverageKind};\n-use crate::mir::interpret::{ConstAllocation, ConstValue, GlobalAlloc, LitToConstInput, Scalar};\n+use crate::mir::interpret::{\n+    AllocRange, ConstAllocation, ConstValue, GlobalAlloc, LitToConstInput, Scalar,\n+};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -2399,7 +2401,7 @@ impl<'tcx> Operand<'tcx> {\n         Operand::Constant(Box::new(Constant {\n             span,\n             user_ty: None,\n-            literal: ConstantKind::Ty(ty::Const::zero_sized(tcx, ty)),\n+            literal: ConstantKind::Val(ConstValue::zst(), ty),\n         }))\n     }\n \n@@ -2953,62 +2955,52 @@ impl<'tcx> Constant<'tcx> {\n     }\n }\n \n-impl<'tcx> From<ty::Const<'tcx>> for ConstantKind<'tcx> {\n-    #[inline]\n-    fn from(ct: ty::Const<'tcx>) -> Self {\n-        match ct.kind() {\n-            ty::ConstKind::Value(cv) => {\n-                // FIXME Once valtrees are introduced we need to convert those\n-                // into `ConstValue` instances here\n-                Self::Val(cv, ct.ty())\n-            }\n-            _ => Self::Ty(ct),\n-        }\n-    }\n-}\n-\n impl<'tcx> ConstantKind<'tcx> {\n     /// Returns `None` if the constant is not trivially safe for use in the type system.\n+    #[inline]\n     pub fn const_for_ty(&self) -> Option<ty::Const<'tcx>> {\n         match self {\n             ConstantKind::Ty(c) => Some(*c),\n             ConstantKind::Val(..) => None,\n         }\n     }\n \n+    #[inline(always)]\n     pub fn ty(&self) -> Ty<'tcx> {\n         match self {\n             ConstantKind::Ty(c) => c.ty(),\n             ConstantKind::Val(_, ty) => *ty,\n         }\n     }\n \n-    pub fn try_val(&self) -> Option<ConstValue<'tcx>> {\n+    #[inline]\n+    pub fn try_to_value(self, tcx: TyCtxt<'tcx>) -> Option<interpret::ConstValue<'tcx>> {\n         match self {\n             ConstantKind::Ty(c) => match c.kind() {\n-                ty::ConstKind::Value(v) => Some(v),\n+                ty::ConstKind::Value(valtree) => Some(tcx.valtree_to_const_val((c.ty(), valtree))),\n                 _ => None,\n             },\n-            ConstantKind::Val(v, _) => Some(*v),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn try_to_value(self) -> Option<interpret::ConstValue<'tcx>> {\n-        match self {\n-            ConstantKind::Ty(c) => c.kind().try_to_value(),\n             ConstantKind::Val(val, _) => Some(val),\n         }\n     }\n \n     #[inline]\n     pub fn try_to_scalar(self) -> Option<Scalar> {\n-        self.try_to_value()?.try_to_scalar()\n+        match self {\n+            ConstantKind::Ty(c) => match c.kind() {\n+                ty::ConstKind::Value(valtree) => match valtree {\n+                    ty::ValTree::Leaf(scalar_int) => Some(Scalar::Int(scalar_int)),\n+                    ty::ValTree::Branch(_) => None,\n+                },\n+                _ => None,\n+            },\n+            ConstantKind::Val(val, _) => val.try_to_scalar(),\n+        }\n     }\n \n     #[inline]\n     pub fn try_to_scalar_int(self) -> Option<ScalarInt> {\n-        Some(self.try_to_value()?.try_to_scalar()?.assert_int())\n+        Some(self.try_to_scalar()?.assert_int())\n     }\n \n     #[inline]\n@@ -3025,9 +3017,7 @@ impl<'tcx> ConstantKind<'tcx> {\n     pub fn eval(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Self {\n         match self {\n             Self::Ty(c) => {\n-                // FIXME Need to use a different evaluation function that directly returns a `ConstValue`\n-                // if evaluation succeeds and does not create a ValTree first\n-                if let Some(val) = c.kind().try_eval(tcx, param_env) {\n+                if let Some(val) = c.kind().try_eval_for_mir(tcx, param_env) {\n                     match val {\n                         Ok(val) => Self::Val(val, c.ty()),\n                         Err(_) => Self::Ty(tcx.const_error(self.ty())),\n@@ -3081,6 +3071,11 @@ impl<'tcx> ConstantKind<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    pub fn from_value(val: ConstValue<'tcx>, ty: Ty<'tcx>) -> Self {\n+        Self::Val(val, ty)\n+    }\n+\n     pub fn from_bits(\n         tcx: TyCtxt<'tcx>,\n         bits: u128,\n@@ -3097,11 +3092,13 @@ impl<'tcx> ConstantKind<'tcx> {\n         Self::Val(cv, param_env_ty.value)\n     }\n \n+    #[inline]\n     pub fn from_bool(tcx: TyCtxt<'tcx>, v: bool) -> Self {\n         let cv = ConstValue::from_bool(v);\n         Self::Val(cv, tcx.types.bool)\n     }\n \n+    #[inline]\n     pub fn zero_sized(ty: Ty<'tcx>) -> Self {\n         let cv = ConstValue::Scalar(Scalar::ZST);\n         Self::Val(cv, ty)\n@@ -3112,6 +3109,12 @@ impl<'tcx> ConstantKind<'tcx> {\n         Self::from_bits(tcx, n as u128, ty::ParamEnv::empty().and(ty))\n     }\n \n+    #[inline]\n+    pub fn from_scalar(_tcx: TyCtxt<'tcx>, s: Scalar, ty: Ty<'tcx>) -> Self {\n+        let val = ConstValue::Scalar(s);\n+        Self::Val(val, ty)\n+    }\n+\n     /// Literals are converted to `ConstantKindVal`, const generic parameters are eagerly\n     /// converted to a constant, everything else becomes `Unevaluated`.\n     pub fn from_anon_const(\n@@ -3199,8 +3202,10 @@ impl<'tcx> ConstantKind<'tcx> {\n             }\n             _ => expr,\n         };\n+        debug!(\"expr.kind: {:?}\", expr.kind);\n \n         let ty = tcx.type_of(def.def_id_for_type_of());\n+        debug!(?ty);\n \n         // FIXME(const_generics): We currently have to special case parameters because `min_const_generics`\n         // does not provide the parents generics to anonymous constants. We still allow generic const\n@@ -3224,6 +3229,7 @@ impl<'tcx> ConstantKind<'tcx> {\n                     kind: ty::ConstKind::Param(ty::ParamConst::new(index, name)),\n                     ty,\n                 });\n+                debug!(?ty_const);\n \n                 return Self::Ty(ty_const);\n             }\n@@ -3253,8 +3259,12 @@ impl<'tcx> ConstantKind<'tcx> {\n         debug!(?span, ?param_env);\n \n         match tcx.const_eval_resolve(param_env, uneval, Some(span)) {\n-            Ok(val) => Self::Val(val, ty),\n+            Ok(val) => {\n+                debug!(\"evaluated const value: {:?}\", val);\n+                Self::Val(val, ty)\n+            }\n             Err(_) => {\n+                debug!(\"error encountered during evaluation\");\n                 // Error was handled in `const_eval_resolve`. Here we just create a\n                 // new unevaluated const and error hard later in codegen\n                 let ty_const = tcx.mk_const(ty::ConstS {\n@@ -3265,11 +3275,22 @@ impl<'tcx> ConstantKind<'tcx> {\n                     }),\n                     ty,\n                 });\n+                debug!(?ty_const);\n \n                 Self::Ty(ty_const)\n             }\n         }\n     }\n+\n+    pub fn from_const(c: ty::Const<'tcx>, tcx: TyCtxt<'tcx>) -> Self {\n+        match c.kind() {\n+            ty::ConstKind::Value(valtree) => {\n+                let const_val = tcx.valtree_to_const_val((c.ty(), valtree));\n+                Self::Val(const_val, c.ty())\n+            }\n+            _ => Self::Ty(c),\n+        }\n+    }\n }\n \n /// A collection of projections into user types.\n@@ -3485,20 +3506,183 @@ fn pretty_print_const<'tcx>(\n     })\n }\n \n+fn pretty_print_byte_str(fmt: &mut Formatter<'_>, byte_str: &[u8]) -> fmt::Result {\n+    fmt.write_str(\"b\\\"\")?;\n+    for &c in byte_str {\n+        for e in std::ascii::escape_default(c) {\n+            fmt.write_char(e as char)?;\n+        }\n+    }\n+    fmt.write_str(\"\\\"\")?;\n+\n+    Ok(())\n+}\n+\n+fn comma_sep<'tcx>(fmt: &mut Formatter<'_>, elems: Vec<ConstantKind<'tcx>>) -> fmt::Result {\n+    let mut first = true;\n+    for elem in elems {\n+        if !first {\n+            fmt.write_str(\", \")?;\n+        }\n+        fmt.write_str(&format!(\"{}\", elem))?;\n+        first = false;\n+    }\n+    Ok(())\n+}\n+\n+// FIXME: Move that into `mir/pretty.rs`.\n fn pretty_print_const_value<'tcx>(\n-    val: interpret::ConstValue<'tcx>,\n+    ct: ConstValue<'tcx>,\n     ty: Ty<'tcx>,\n     fmt: &mut Formatter<'_>,\n-    print_types: bool,\n+    print_ty: bool,\n ) -> fmt::Result {\n     use crate::ty::print::PrettyPrinter;\n+\n     ty::tls::with(|tcx| {\n-        let val = tcx.lift(val).unwrap();\n+        let ct = tcx.lift(ct).unwrap();\n         let ty = tcx.lift(ty).unwrap();\n-        let mut cx = FmtPrinter::new(tcx, Namespace::ValueNS);\n-        cx.print_alloc_ids = true;\n-        let cx = cx.pretty_print_const_value(val, ty, print_types)?;\n-        fmt.write_str(&cx.into_buffer())?;\n+\n+        if tcx.sess.verbose() {\n+            fmt.write_str(&format!(\"ConstValue({:?}: {})\", ct, ty))?;\n+            return Ok(());\n+        }\n+\n+        let u8_type = tcx.types.u8;\n+        match (ct, ty.kind()) {\n+            // Byte/string slices, printed as (byte) string literals.\n+            (ConstValue::Slice { data, start, end }, ty::Ref(_, inner, _)) => {\n+                match inner.kind() {\n+                    ty::Slice(t) => {\n+                        if *t == u8_type {\n+                            // The `inspect` here is okay since we checked the bounds, and there are\n+                            // no relocations (we have an active slice reference here). We don't use\n+                            // this result to affect interpreter execution.\n+                            let byte_str = data\n+                                .inner()\n+                                .inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n+                            pretty_print_byte_str(fmt, byte_str)?;\n+                            return Ok(());\n+                        }\n+                    }\n+                    ty::Str => {\n+                        // The `inspect` here is okay since we checked the bounds, and there are no\n+                        // relocations (we have an active `str` reference here). We don't use this\n+                        // result to affect interpreter execution.\n+                        let slice = data\n+                            .inner()\n+                            .inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n+                        fmt.write_str(&format!(\"{:?}\", String::from_utf8_lossy(slice)))?;\n+                        return Ok(());\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            (ConstValue::ByRef { alloc, offset }, ty::Array(t, n)) if *t == u8_type => {\n+                let n = n.kind().try_to_bits(tcx.data_layout.pointer_size).unwrap();\n+                // cast is ok because we already checked for pointer size (32 or 64 bit) above\n+                let range = AllocRange { start: offset, size: Size::from_bytes(n) };\n+                let byte_str = alloc.inner().get_bytes(&tcx, range).unwrap();\n+                fmt.write_str(\"*\")?;\n+                pretty_print_byte_str(fmt, byte_str)?;\n+                return Ok(());\n+            }\n+            // Aggregates, printed as array/tuple/struct/variant construction syntax.\n+            //\n+            // NB: the `has_param_types_or_consts` check ensures that we can use\n+            // the `destructure_const` query with an empty `ty::ParamEnv` without\n+            // introducing ICEs (e.g. via `layout_of`) from missing bounds.\n+            // E.g. `transmute([0usize; 2]): (u8, *mut T)` needs to know `T: Sized`\n+            // to be able to destructure the tuple into `(0u8, *mut T)\n+            //\n+            // FIXME(eddyb) for `--emit=mir`/`-Z dump-mir`, we should provide the\n+            // correct `ty::ParamEnv` to allow printing *all* constant values.\n+            (_, ty::Array(..) | ty::Tuple(..) | ty::Adt(..)) if !ty.has_param_types_or_consts() => {\n+                let ct = tcx.lift(ct).unwrap();\n+                let ty = tcx.lift(ty).unwrap();\n+                if let Some(contents) = tcx.try_destructure_mir_constant(\n+                    ty::ParamEnv::reveal_all().and(ConstantKind::Val(ct, ty)),\n+                ) {\n+                    let fields = contents.fields.iter().copied().collect::<Vec<_>>();\n+                    match *ty.kind() {\n+                        ty::Array(..) => {\n+                            fmt.write_str(\"[\")?;\n+                            comma_sep(fmt, fields)?;\n+                            fmt.write_str(\"]\")?;\n+                        }\n+                        ty::Tuple(..) => {\n+                            fmt.write_str(\"(\")?;\n+                            comma_sep(fmt, fields)?;\n+                            if contents.fields.len() == 1 {\n+                                fmt.write_str(\",\")?;\n+                            }\n+                            fmt.write_str(\")\")?;\n+                        }\n+                        ty::Adt(def, _) if def.variants().is_empty() => {\n+                            fmt.write_str(&format!(\"{{unreachable(): {}}}\", ty))?;\n+                        }\n+                        ty::Adt(def, substs) => {\n+                            let variant_idx = contents\n+                                .variant\n+                                .expect(\"destructed mir constant of adt without variant idx\");\n+                            let variant_def = &def.variant(variant_idx);\n+                            let substs = tcx.lift(substs).unwrap();\n+                            let mut cx = FmtPrinter::new(tcx, Namespace::ValueNS);\n+                            cx.print_alloc_ids = true;\n+                            let cx = cx.print_value_path(variant_def.def_id, substs)?;\n+                            fmt.write_str(&cx.into_buffer())?;\n+\n+                            match variant_def.ctor_kind {\n+                                CtorKind::Const => {}\n+                                CtorKind::Fn => {\n+                                    fmt.write_str(\"(\")?;\n+                                    comma_sep(fmt, fields)?;\n+                                    fmt.write_str(\")\")?;\n+                                }\n+                                CtorKind::Fictive => {\n+                                    fmt.write_str(\" {{ \")?;\n+                                    let mut first = true;\n+                                    for (field_def, field) in iter::zip(&variant_def.fields, fields)\n+                                    {\n+                                        if !first {\n+                                            fmt.write_str(\", \")?;\n+                                        }\n+                                        fmt.write_str(&format!(\"{}: {}\", field_def.name, field))?;\n+                                        first = false;\n+                                    }\n+                                    fmt.write_str(\" }}\")?;\n+                                }\n+                            }\n+                        }\n+                        _ => unreachable!(),\n+                    }\n+                    return Ok(());\n+                } else {\n+                    // Fall back to debug pretty printing for invalid constants.\n+                    fmt.write_str(&format!(\"{:?}\", ct))?;\n+                    if print_ty {\n+                        fmt.write_str(&format!(\": {}\", ty))?;\n+                    }\n+                    return Ok(());\n+                };\n+            }\n+            (ConstValue::Scalar(scalar), _) => {\n+                let mut cx = FmtPrinter::new(tcx, Namespace::ValueNS);\n+                cx.print_alloc_ids = true;\n+                let ty = tcx.lift(ty).unwrap();\n+                cx = cx.pretty_print_const_scalar(scalar, ty, print_ty)?;\n+                fmt.write_str(&cx.into_buffer())?;\n+                return Ok(());\n+            }\n+            // FIXME(oli-obk): also pretty print arrays and other aggregate constants by reading\n+            // their fields instead of just dumping the memory.\n+            _ => {}\n+        }\n+        // fallback\n+        fmt.write_str(&format!(\"{:?}\", ct))?;\n+        if print_ty {\n+            fmt.write_str(&format!(\": {}\", ty))?;\n+        }\n         Ok(())\n     })\n }"}, {"sha": "462c0ada3cf87c2526821c7251ba2cc6e77d63df", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -454,7 +454,12 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n                 ConstValue::ByRef { .. } => format!(\"ByRef(..)\"),\n             };\n \n-            let kind = match literal {\n+            let fmt_valtree = |valtree: &ty::ValTree<'tcx>| match valtree {\n+                ty::ValTree::Leaf(leaf) => format!(\"ValTree::Leaf({:?})\", leaf),\n+                ty::ValTree::Branch(_) => format!(\"ValTree::Branch(..)\"),\n+            };\n+\n+            let val = match literal {\n                 ConstantKind::Ty(ct) => match ct.kind() {\n                     ty::ConstKind::Param(p) => format!(\"Param({})\", p),\n                     ty::ConstKind::Unevaluated(uv) => format!(\n@@ -463,7 +468,7 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n                         uv.substs,\n                         uv.promoted,\n                     ),\n-                    ty::ConstKind::Value(val) => format!(\"Value({})\", fmt_val(&val)),\n+                    ty::ConstKind::Value(val) => format!(\"Value({})\", fmt_valtree(&val)),\n                     ty::ConstKind::Error(_) => \"Error\".to_string(),\n                     // These variants shouldn't exist in the MIR.\n                     ty::ConstKind::Placeholder(_)\n@@ -479,7 +484,7 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n             // This reflects what `Const` looked liked before `val` was renamed\n             // as `kind`. We print it like this to avoid having to update\n             // expected output in a lot of tests.\n-            self.push(&format!(\"+ literal: Const {{ ty: {}, val: {} }}\", literal.ty(), kind));\n+            self.push(&format!(\"+ literal: Const {{ ty: {}, val: {} }}\", literal.ty(), val));\n         }\n     }\n \n@@ -665,7 +670,8 @@ pub fn write_allocations<'tcx>(\n     ) -> impl DoubleEndedIterator<Item = AllocId> + '_ {\n         alloc.inner().relocations().values().map(|id| *id)\n     }\n-    fn alloc_ids_from_const(val: ConstValue<'_>) -> impl Iterator<Item = AllocId> + '_ {\n+\n+    fn alloc_ids_from_const_val(val: ConstValue<'_>) -> impl Iterator<Item = AllocId> + '_ {\n         match val {\n             ConstValue::Scalar(interpret::Scalar::Ptr(ptr, _)) => {\n                 Either::Left(Either::Left(std::iter::once(ptr.provenance)))\n@@ -681,17 +687,11 @@ pub fn write_allocations<'tcx>(\n     struct CollectAllocIds(BTreeSet<AllocId>);\n \n     impl<'tcx> Visitor<'tcx> for CollectAllocIds {\n-        fn visit_const(&mut self, c: ty::Const<'tcx>, _loc: Location) {\n-            if let ty::ConstKind::Value(val) = c.kind() {\n-                self.0.extend(alloc_ids_from_const(val));\n-            }\n-        }\n-\n         fn visit_constant(&mut self, c: &Constant<'tcx>, loc: Location) {\n             match c.literal {\n                 ConstantKind::Ty(c) => self.visit_const(c, loc),\n                 ConstantKind::Val(val, _) => {\n-                    self.0.extend(alloc_ids_from_const(val));\n+                    self.0.extend(alloc_ids_from_const_val(val));\n                 }\n             }\n         }"}, {"sha": "da4793fa039d0f36be8d16495b450ae807ab6894", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,6 +1,6 @@\n //! Values computed by queries that use MIR.\n \n-use crate::mir::{self, Body, Promoted};\n+use crate::mir::{Body, ConstantKind, Promoted};\n use crate::ty::{self, OpaqueHiddenType, Ty, TyCtxt};\n use rustc_data_structures::stable_map::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n@@ -427,7 +427,7 @@ pub struct DestructuredConst<'tcx> {\n #[derive(Copy, Clone, Debug, HashStable)]\n pub struct DestructuredMirConstant<'tcx> {\n     pub variant: Option<VariantIdx>,\n-    pub fields: &'tcx [mir::ConstantKind<'tcx>],\n+    pub fields: &'tcx [ConstantKind<'tcx>],\n }\n \n /// Coverage information summarized from a MIR if instrumented for source code coverage (see"}, {"sha": "c65e79a80fb8ebf29b28595c1913466986367eb0", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,3 +1,4 @@\n+use crate::mir;\n use crate::mir::interpret::Scalar;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n@@ -676,7 +677,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                     .values\n                     .iter()\n                     .map(|&u| {\n-                        ty::Const::from_scalar(tcx, Scalar::from_uint(u, size), switch_ty)\n+                        mir::ConstantKind::from_scalar(tcx, Scalar::from_uint(u, size), switch_ty)\n                             .to_string()\n                             .into()\n                     })"}, {"sha": "caa1d4cd34eee73f36f65a2c6595a4fe92cb1ed5", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -967,36 +967,26 @@ rustc_queries! {\n     query eval_to_valtree(\n         key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>\n     ) -> EvalToValTreeResult<'tcx> {\n-        desc { \"evaluate type-level constant\" }\n-        remap_env_constness\n+        desc { \"evaluating type-level constant\" }\n     }\n \n     /// Converts a type level constant value into `ConstValue`\n     query valtree_to_const_val(key: (Ty<'tcx>, ty::ValTree<'tcx>)) -> ConstValue<'tcx> {\n-        desc { \"convert type-level constant value to mir constant value\"}\n+        desc { \"converting type-level constant value to mir constant value\"}\n     }\n \n     /// Destructure a constant ADT or array into its variant index and its\n     /// field values or return `None` if constant is invalid.\n     ///\n     /// Use infallible `TyCtxt::destructure_const` when you know that constant is valid.\n-    query try_destructure_const(key: ty::ParamEnvAnd<'tcx, ty::Const<'tcx>>) -> Option<mir::DestructuredConst<'tcx>> {\n-        desc { \"destructure type level constant\"}\n+    query try_destructure_const(key: ty::Const<'tcx>) -> Option<ty::DestructuredConst<'tcx>> {\n+        desc { \"destructuring type level constant\"}\n     }\n \n     /// Tries to destructure an `mir::ConstantKind` ADT or array into its variant index\n     /// and its field values.\n     query try_destructure_mir_constant(key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>) -> Option<mir::DestructuredMirConstant<'tcx>> {\n-        desc { \"destructure mir constant\"}\n-        remap_env_constness\n-    }\n-\n-    /// Dereference a constant reference or raw pointer and turn the result into a constant\n-    /// again.\n-    query deref_const(\n-        key: ty::ParamEnvAnd<'tcx, ty::Const<'tcx>>\n-    ) -> ty::Const<'tcx> {\n-        desc { \"deref constant\" }\n+        desc { \"destructuring mir constant\"}\n         remap_env_constness\n     }\n \n@@ -1005,7 +995,7 @@ rustc_queries! {\n     query deref_mir_constant(\n         key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>\n     ) -> mir::ConstantKind<'tcx> {\n-        desc { \"deref constant\" }\n+        desc { \"dereferencing mir constant\" }\n         remap_env_constness\n     }\n "}, {"sha": "70abdb9ab4cd7be51106e777960dc5852b829c93", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -5,7 +5,6 @@\n //! its name suggest, is to provide an abstraction boundary for creating\n //! interned Chalk types.\n \n-use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::{self, AdtDef, TyCtxt};\n \n use rustc_hir::def_id::DefId;\n@@ -62,7 +61,7 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n     type InternedType = Box<chalk_ir::TyData<Self>>;\n     type InternedLifetime = Box<chalk_ir::LifetimeData<Self>>;\n     type InternedConst = Box<chalk_ir::ConstData<Self>>;\n-    type InternedConcreteConst = ConstValue<'tcx>;\n+    type InternedConcreteConst = ty::ValTree<'tcx>;\n     type InternedGenericArg = Box<chalk_ir::GenericArgData<Self>>;\n     type InternedGoal = Box<chalk_ir::GoalData<Self>>;\n     type InternedGoals = Vec<chalk_ir::Goal<Self>>;"}, {"sha": "bc52259b151d1c6dcbc8c03cb1ed0a11bdd74997", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,5 +1,5 @@\n-use crate::mir::interpret::ConstValue;\n-use crate::mir::interpret::{LitToConstInput, Scalar};\n+use crate::mir::interpret::LitToConstInput;\n+use crate::mir::ConstantKind;\n use crate::ty::{\n     self, InlineConstSubsts, InlineConstSubstsParts, InternalSubsts, ParamEnv, ParamEnvAnd, Ty,\n     TyCtxt, TypeFoldable,\n@@ -195,14 +195,21 @@ impl<'tcx> Const<'tcx> {\n \n     /// Interns the given value as a constant.\n     #[inline]\n-    pub fn from_value(tcx: TyCtxt<'tcx>, val: ConstValue<'tcx>, ty: Ty<'tcx>) -> Self {\n+    pub fn from_value(tcx: TyCtxt<'tcx>, val: ty::ValTree<'tcx>, ty: Ty<'tcx>) -> Self {\n         tcx.mk_const(ConstS { kind: ConstKind::Value(val), ty })\n     }\n \n-    #[inline]\n-    /// Interns the given scalar as a constant.\n-    pub fn from_scalar(tcx: TyCtxt<'tcx>, val: Scalar, ty: Ty<'tcx>) -> Self {\n-        Self::from_value(tcx, ConstValue::Scalar(val), ty)\n+    /// Panics if self.kind != ty::ConstKind::Value\n+    pub fn to_valtree(self) -> ty::ValTree<'tcx> {\n+        match self.kind() {\n+            ty::ConstKind::Value(valtree) => valtree,\n+            _ => bug!(\"expected ConstKind::Value\"),\n+        }\n+    }\n+\n+    pub fn from_scalar_int(tcx: TyCtxt<'tcx>, i: ScalarInt, ty: Ty<'tcx>) -> Self {\n+        let valtree = ty::ValTree::from_scalar_int(i);\n+        Self::from_value(tcx, valtree, ty)\n     }\n \n     #[inline]\n@@ -212,13 +219,14 @@ impl<'tcx> Const<'tcx> {\n             .layout_of(ty)\n             .unwrap_or_else(|e| panic!(\"could not compute layout for {:?}: {:?}\", ty, e))\n             .size;\n-        Self::from_scalar(tcx, Scalar::from_uint(bits, size), ty.value)\n+        Self::from_scalar_int(tcx, ScalarInt::try_from_uint(bits, size).unwrap(), ty.value)\n     }\n \n     #[inline]\n     /// Creates an interned zst constant.\n     pub fn zero_sized(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Self {\n-        Self::from_scalar(tcx, Scalar::ZST, ty)\n+        let valtree = ty::ValTree::zst();\n+        Self::from_value(tcx, valtree, ty)\n     }\n \n     #[inline]\n@@ -263,16 +271,31 @@ impl<'tcx> Const<'tcx> {\n     /// Tries to evaluate the constant if it is `Unevaluated`. If that doesn't succeed, return the\n     /// unevaluated constant.\n     pub fn eval(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Const<'tcx> {\n-        if let Some(val) = self.kind().try_eval(tcx, param_env) {\n+        if let Some(val) = self.kind().try_eval_for_typeck(tcx, param_env) {\n             match val {\n                 Ok(val) => Const::from_value(tcx, val, self.ty()),\n                 Err(ErrorGuaranteed { .. }) => tcx.const_error(self.ty()),\n             }\n         } else {\n+            // Either the constant isn't evaluatable or ValTree creation failed.\n             self\n         }\n     }\n \n+    #[inline]\n+    /// Tries to evaluate the constant if it is `Unevaluated` and creates a ConstValue if the\n+    /// evaluation succeeds. If it doesn't succeed, returns the unevaluated constant.\n+    pub fn eval_for_mir(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> ConstantKind<'tcx> {\n+        if let Some(val) = self.kind().try_eval_for_mir(tcx, param_env) {\n+            match val {\n+                Ok(const_val) => ConstantKind::from_value(const_val, self.ty()),\n+                Err(ErrorGuaranteed { .. }) => ConstantKind::Ty(tcx.const_error(self.ty())),\n+            }\n+        } else {\n+            ConstantKind::Ty(self)\n+        }\n+    }\n+\n     #[inline]\n     /// Panics if the value cannot be evaluated or doesn't contain a valid integer of the given type.\n     pub fn eval_bits(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {"}, {"sha": "10d03065c795f7e5db4838a671e757b461291177", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 70, "deletions": 13, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -63,7 +63,7 @@ pub enum ConstKind<'tcx> {\n     Unevaluated(Unevaluated<'tcx>),\n \n     /// Used to hold computed value.\n-    Value(ConstValue<'tcx>),\n+    Value(ty::ValTree<'tcx>),\n \n     /// A placeholder for a const which could not be computed; this is\n     /// propagated to avoid useless error messages.\n@@ -75,7 +75,7 @@ static_assert_size!(ConstKind<'_>, 40);\n \n impl<'tcx> ConstKind<'tcx> {\n     #[inline]\n-    pub fn try_to_value(self) -> Option<ConstValue<'tcx>> {\n+    pub fn try_to_value(self) -> Option<ty::ValTree<'tcx>> {\n         if let ConstKind::Value(val) = self { Some(val) } else { None }\n     }\n \n@@ -86,7 +86,7 @@ impl<'tcx> ConstKind<'tcx> {\n \n     #[inline]\n     pub fn try_to_scalar_int(self) -> Option<ScalarInt> {\n-        Some(self.try_to_value()?.try_to_scalar()?.assert_int())\n+        self.try_to_value()?.try_to_scalar_int()\n     }\n \n     #[inline]\n@@ -115,23 +115,65 @@ pub enum InferConst<'tcx> {\n     Fresh(u32),\n }\n \n+enum EvalMode {\n+    Typeck,\n+    Mir,\n+}\n+\n+enum EvalResult<'tcx> {\n+    ValTree(ty::ValTree<'tcx>),\n+    ConstVal(ConstValue<'tcx>),\n+}\n+\n impl<'tcx> ConstKind<'tcx> {\n     #[inline]\n     /// Tries to evaluate the constant if it is `Unevaluated`. If that doesn't succeed, return the\n     /// unevaluated constant.\n     pub fn eval(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Self {\n-        self.try_eval(tcx, param_env).and_then(Result::ok).map_or(self, ConstKind::Value)\n+        self.try_eval_for_typeck(tcx, param_env).and_then(Result::ok).map_or(self, ConstKind::Value)\n     }\n \n     #[inline]\n     /// Tries to evaluate the constant if it is `Unevaluated`. If that isn't possible or necessary\n     /// return `None`.\n     // FIXME(@lcnr): Completely rework the evaluation/normalization system for `ty::Const` once valtrees are merged.\n-    pub fn try_eval(\n+    pub fn try_eval_for_mir(\n         self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ParamEnv<'tcx>,\n     ) -> Option<Result<ConstValue<'tcx>, ErrorGuaranteed>> {\n+        match self.try_eval_inner(tcx, param_env, EvalMode::Mir) {\n+            Some(Ok(EvalResult::ValTree(_))) => unreachable!(),\n+            Some(Ok(EvalResult::ConstVal(v))) => Some(Ok(v)),\n+            Some(Err(e)) => Some(Err(e)),\n+            None => None,\n+        }\n+    }\n+\n+    #[inline]\n+    /// Tries to evaluate the constant if it is `Unevaluated`. If that isn't possible or necessary\n+    /// return `None`.\n+    // FIXME(@lcnr): Completely rework the evaluation/normalization system for `ty::Const` once valtrees are merged.\n+    pub fn try_eval_for_typeck(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+    ) -> Option<Result<ty::ValTree<'tcx>, ErrorGuaranteed>> {\n+        match self.try_eval_inner(tcx, param_env, EvalMode::Typeck) {\n+            Some(Ok(EvalResult::ValTree(v))) => Some(Ok(v)),\n+            Some(Ok(EvalResult::ConstVal(_))) => unreachable!(),\n+            Some(Err(e)) => Some(Err(e)),\n+            None => None,\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_eval_inner(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        eval_mode: EvalMode,\n+    ) -> Option<Result<EvalResult<'tcx>, ErrorGuaranteed>> {\n         if let ConstKind::Unevaluated(unevaluated) = self {\n             use crate::mir::interpret::ErrorHandled;\n \n@@ -166,14 +208,29 @@ impl<'tcx> ConstKind<'tcx> {\n             let (param_env, unevaluated) = param_env_and.into_parts();\n             // try to resolve e.g. associated constants to their definition on an impl, and then\n             // evaluate the const.\n-            match tcx.const_eval_resolve(param_env, unevaluated, None) {\n-                // NOTE(eddyb) `val` contains no lifetimes/types/consts,\n-                // and we use the original type, so nothing from `substs`\n-                // (which may be identity substs, see above),\n-                // can leak through `val` into the const we return.\n-                Ok(val) => Some(Ok(val)),\n-                Err(ErrorHandled::TooGeneric | ErrorHandled::Linted) => None,\n-                Err(ErrorHandled::Reported(e)) => Some(Err(e)),\n+            match eval_mode {\n+                EvalMode::Typeck => {\n+                    match tcx.const_eval_resolve_for_typeck(param_env, unevaluated, None) {\n+                        // NOTE(eddyb) `val` contains no lifetimes/types/consts,\n+                        // and we use the original type, so nothing from `substs`\n+                        // (which may be identity substs, see above),\n+                        // can leak through `val` into the const we return.\n+                        Ok(val) => Some(Ok(EvalResult::ValTree(val?))),\n+                        Err(ErrorHandled::TooGeneric | ErrorHandled::Linted) => None,\n+                        Err(ErrorHandled::Reported(e)) => Some(Err(e)),\n+                    }\n+                }\n+                EvalMode::Mir => {\n+                    match tcx.const_eval_resolve(param_env, unevaluated, None) {\n+                        // NOTE(eddyb) `val` contains no lifetimes/types/consts,\n+                        // and we use the original type, so nothing from `substs`\n+                        // (which may be identity substs, see above),\n+                        // can leak through `val` into the const we return.\n+                        Ok(val) => Some(Ok(EvalResult::ConstVal(val))),\n+                        Err(ErrorHandled::TooGeneric | ErrorHandled::Linted) => None,\n+                        Err(ErrorHandled::Reported(e)) => Some(Err(e)),\n+                    }\n+                }\n             }\n         } else {\n             None"}, {"sha": "973dc3dd4a10ab61e1ded24e001629b6bbf0a467", "filename": "compiler/rustc_middle/src/ty/consts/valtree.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,4 +1,6 @@\n use super::ScalarInt;\n+use crate::mir::interpret::{AllocId, Scalar};\n+use crate::ty::{self, Ty, TyCtxt};\n use rustc_macros::{HashStable, TyDecodable, TyEncodable};\n \n #[derive(Copy, Clone, Debug, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]\n@@ -50,4 +52,61 @@ impl<'tcx> ValTree<'tcx> {\n             _ => bug!(\"expected branch, got {:?}\", self),\n         }\n     }\n+\n+    pub fn from_raw_bytes<'a>(tcx: TyCtxt<'tcx>, bytes: &'a [u8]) -> Self {\n+        let branches = bytes.iter().map(|b| Self::Leaf(ScalarInt::from(*b)));\n+        let interned = tcx.arena.alloc_from_iter(branches);\n+\n+        Self::Branch(interned)\n+    }\n+\n+    pub fn from_scalar_int(i: ScalarInt) -> Self {\n+        Self::Leaf(i)\n+    }\n+\n+    pub fn try_to_scalar(self) -> Option<Scalar<AllocId>> {\n+        self.try_to_scalar_int().map(Scalar::Int)\n+    }\n+\n+    pub fn try_to_scalar_int(self) -> Option<ScalarInt> {\n+        match self {\n+            Self::Leaf(s) => Some(s),\n+            Self::Branch(_) => None,\n+        }\n+    }\n+\n+    pub fn try_to_machine_usize(self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n+        self.try_to_scalar_int().map(|s| s.try_to_machine_usize(tcx).ok()).flatten()\n+    }\n+\n+    /// Get the values inside the ValTree as a slice of bytes. This only works for\n+    /// constants with types &str and &[u8].\n+    pub fn try_to_raw_bytes(self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<&'tcx [u8]> {\n+        match ty.kind() {\n+            ty::Ref(_, inner_ty, _) => match inner_ty.kind() {\n+                ty::Str => {\n+                    let leafs = self\n+                        .unwrap_branch()\n+                        .into_iter()\n+                        .map(|v| v.unwrap_leaf().try_to_u8().unwrap())\n+                        .collect::<Vec<_>>();\n+\n+                    return Some(tcx.arena.alloc_from_iter(leafs.into_iter()));\n+                }\n+                ty::Slice(slice_ty) if *slice_ty == tcx.types.u8 => {\n+                    let leafs = self\n+                        .unwrap_branch()\n+                        .into_iter()\n+                        .map(|v| v.unwrap_leaf().try_to_u8().unwrap())\n+                        .collect::<Vec<_>>();\n+\n+                    return Some(tcx.arena.alloc_from_iter(leafs.into_iter()));\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        }\n+\n+        None\n+    }\n }"}, {"sha": "4cd25a616264fd3bedaaf1db7eef6c4007f5e581", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -8,7 +8,7 @@ use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_lifetime;\n use crate::middle::stability;\n-use crate::mir::interpret::{self, Allocation, ConstAllocation, ConstValue, Scalar};\n+use crate::mir::interpret::{self, Allocation, ConstAllocation};\n use crate::mir::{\n     Body, BorrowCheckResult, Field, Local, Place, PlaceElem, ProjectionKind, Promoted,\n };\n@@ -991,7 +991,7 @@ impl<'tcx> CommonConsts<'tcx> {\n \n         CommonConsts {\n             unit: mk_const(ty::ConstS {\n-                kind: ty::ConstKind::Value(ConstValue::Scalar(Scalar::ZST)),\n+                kind: ty::ConstKind::Value(ty::ValTree::zst()),\n                 ty: types.unit,\n             }),\n         }"}, {"sha": "e8dd179eac19831c92d0bb09296bb1d8852e525f", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -369,7 +369,6 @@ impl<'tcx> Instance<'tcx> {\n     }\n \n     // This should be kept up to date with `resolve`.\n-    #[instrument(level = \"debug\", skip(tcx))]\n     pub fn resolve_opt_const_arg(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "b386ed68dd246232d828b935a830bd1cdd63f340", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -42,7 +42,7 @@ use rustc_query_system::ich::StableHashingContext;\n use rustc_session::cstore::CrateStoreDyn;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-use rustc_target::abi::Align;\n+use rustc_target::abi::{Align, VariantIdx};\n pub use subst::*;\n pub use vtable::*;\n \n@@ -2161,22 +2161,28 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns the possibly-auto-generated MIR of a `(DefId, Subst)` pair.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n         match instance {\n-            ty::InstanceDef::Item(def) => match self.def_kind(def.did) {\n-                DefKind::Const\n-                | DefKind::Static(..)\n-                | DefKind::AssocConst\n-                | DefKind::Ctor(..)\n-                | DefKind::AnonConst\n-                | DefKind::InlineConst => self.mir_for_ctfe_opt_const_arg(def),\n-                // If the caller wants `mir_for_ctfe` of a function they should not be using\n-                // `instance_mir`, so we'll assume const fn also wants the optimized version.\n-                _ => {\n-                    assert_eq!(def.const_param_did, None);\n-                    self.optimized_mir(def.did)\n+            ty::InstanceDef::Item(def) => {\n+                debug!(\"calling def_kind on def: {:?}\", def);\n+                let def_kind = self.def_kind(def.did);\n+                debug!(\"returned from def_kind: {:?}\", def_kind);\n+                match def_kind {\n+                    DefKind::Const\n+                    | DefKind::Static(..)\n+                    | DefKind::AssocConst\n+                    | DefKind::Ctor(..)\n+                    | DefKind::AnonConst\n+                    | DefKind::InlineConst => self.mir_for_ctfe_opt_const_arg(def),\n+                    // If the caller wants `mir_for_ctfe` of a function they should not be using\n+                    // `instance_mir`, so we'll assume const fn also wants the optimized version.\n+                    _ => {\n+                        assert_eq!(def.const_param_did, None);\n+                        self.optimized_mir(def.did)\n+                    }\n                 }\n-            },\n+            }\n             ty::InstanceDef::VtableShim(..)\n             | ty::InstanceDef::ReifyShim(..)\n             | ty::InstanceDef::Intrinsic(..)\n@@ -2447,3 +2453,10 @@ pub struct FoundRelationships {\n     /// _>::AssocType = ?T`\n     pub output: bool,\n }\n+\n+/// The constituent parts of a type level constant of kind ADT or array.\n+#[derive(Copy, Clone, Debug, HashStable)]\n+pub struct DestructuredConst<'tcx> {\n+    pub variant: Option<VariantIdx>,\n+    pub fields: &'tcx [ty::Const<'tcx>],\n+}"}, {"sha": "7ae23d371e59f83f44c1d1a867947bd7148465f0", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -302,6 +302,7 @@ impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for ty::Region<'_> {\n impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for Ty<'tcx> {\n     type Output = P::Type;\n     type Error = P::Error;\n+\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n         cx.print_type(*self)\n     }"}, {"sha": "58dab0f96aba576bc258b48e84e9fa67b258258e", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 42, "deletions": 67, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,4 +1,4 @@\n-use crate::mir::interpret::{AllocRange, ConstValue, GlobalAlloc, Pointer, Provenance, Scalar};\n+use crate::mir::interpret::{AllocRange, GlobalAlloc, Pointer, Provenance, Scalar};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n use crate::ty::{\n     self, ConstInt, DefIdTree, ParamConst, ScalarInt, Term, Ty, TyCtxt, TypeFoldable,\n@@ -1224,7 +1224,7 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::ConstKind::Param(ParamConst { name, .. }) => p!(write(\"{}\", name)),\n             ty::ConstKind::Value(value) => {\n-                return self.pretty_print_const_value(value, ct.ty(), print_ty);\n+                return self.pretty_print_const_valtree(value, ct.ty(), print_ty);\n             }\n \n             ty::ConstKind::Bound(debruijn, bound_var) => {\n@@ -1262,7 +1262,7 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Ref(_, inner, _) => {\n                 if let ty::Array(elem, len) = inner.kind() {\n                     if let ty::Uint(ty::UintTy::U8) = elem.kind() {\n-                        if let ty::ConstKind::Value(ConstValue::Scalar(int)) = len.kind() {\n+                        if let ty::ConstKind::Value(ty::ValTree::Leaf(int)) = len.kind() {\n                             match self.tcx().get_global_alloc(alloc_id) {\n                                 Some(GlobalAlloc::Memory(alloc)) => {\n                                     let len = int.assert_bits(self.tcx().data_layout.pointer_size);\n@@ -1408,85 +1408,62 @@ pub trait PrettyPrinter<'tcx>:\n         Ok(self)\n     }\n \n-    fn pretty_print_const_value(\n+    fn pretty_print_const_valtree(\n         mut self,\n-        ct: ConstValue<'tcx>,\n+        valtree: ty::ValTree<'tcx>,\n         ty: Ty<'tcx>,\n         print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n         if self.tcx().sess.verbose() {\n-            p!(write(\"ConstValue({:?}: \", ct), print(ty), \")\");\n+            p!(write(\"ValTree({:?}: \", valtree), print(ty), \")\");\n             return Ok(self);\n         }\n \n         let u8_type = self.tcx().types.u8;\n-\n-        match (ct, ty.kind()) {\n-            // Byte/string slices, printed as (byte) string literals.\n-            (ConstValue::Slice { data, start, end }, ty::Ref(_, inner, _)) => {\n-                match inner.kind() {\n-                    ty::Slice(t) => {\n-                        if *t == u8_type {\n-                            // The `inspect` here is okay since we checked the bounds, and there are\n-                            // no relocations (we have an active slice reference here). We don't use\n-                            // this result to affect interpreter execution.\n-                            let byte_str = data\n-                                .inner()\n-                                .inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n-                            return self.pretty_print_byte_str(byte_str);\n-                        }\n-                    }\n-                    ty::Str => {\n-                        // The `inspect` here is okay since we checked the bounds, and there are no\n-                        // relocations (we have an active `str` reference here). We don't use this\n-                        // result to affect interpreter execution.\n-                        let slice = data\n-                            .inner()\n-                            .inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n-                        p!(write(\"{:?}\", String::from_utf8_lossy(slice)));\n-                        return Ok(self);\n-                    }\n-                    _ => {}\n+        match (valtree, ty.kind()) {\n+            (ty::ValTree::Branch(_), ty::Ref(_, inner_ty, _)) => match inner_ty.kind() {\n+                ty::Slice(t) if *t == u8_type => {\n+                    let bytes = valtree.try_to_raw_bytes(self.tcx(), ty).unwrap_or_else(|| {\n+                        bug!(\n+                            \"expected to convert valtree {:?} to raw bytes for type {:?}\",\n+                            valtree,\n+                            t\n+                        )\n+                    });\n+                    return self.pretty_print_byte_str(bytes);\n                 }\n-            }\n-            (ConstValue::ByRef { alloc, offset }, ty::Array(t, n)) if *t == u8_type => {\n-                let n = n.kind().try_to_bits(self.tcx().data_layout.pointer_size).unwrap();\n-                // cast is ok because we already checked for pointer size (32 or 64 bit) above\n-                let range = AllocRange { start: offset, size: Size::from_bytes(n) };\n-\n-                let byte_str = alloc.inner().get_bytes(&self.tcx(), range).unwrap();\n+                ty::Str => {\n+                    let bytes = valtree.try_to_raw_bytes(self.tcx(), ty).unwrap_or_else(|| {\n+                        bug!(\"expected to convert valtree to raw bytes for type {:?}\", ty)\n+                    });\n+                    p!(write(\"{:?}\", String::from_utf8_lossy(bytes)));\n+                    return Ok(self);\n+                }\n+                _ => {}\n+            },\n+            (ty::ValTree::Branch(_), ty::Array(t, _)) if *t == u8_type => {\n+                let bytes = valtree.try_to_raw_bytes(self.tcx(), *t).unwrap_or_else(|| {\n+                    bug!(\"expected to convert valtree to raw bytes for type {:?}\", t)\n+                });\n                 p!(\"*\");\n-                p!(pretty_print_byte_str(byte_str));\n+                p!(pretty_print_byte_str(bytes));\n                 return Ok(self);\n             }\n-\n             // Aggregates, printed as array/tuple/struct/variant construction syntax.\n-            //\n-            // NB: the `has_param_types_or_consts` check ensures that we can use\n-            // the `destructure_const` query with an empty `ty::ParamEnv` without\n-            // introducing ICEs (e.g. via `layout_of`) from missing bounds.\n-            // E.g. `transmute([0usize; 2]): (u8, *mut T)` needs to know `T: Sized`\n-            // to be able to destructure the tuple into `(0u8, *mut T)\n-            //\n-            // FIXME(eddyb) for `--emit=mir`/`-Z dump-mir`, we should provide the\n-            // correct `ty::ParamEnv` to allow printing *all* constant values.\n-            (_, ty::Array(..) | ty::Tuple(..) | ty::Adt(..)) if !ty.has_param_types_or_consts() => {\n+            (ty::ValTree::Branch(_), ty::Array(..) | ty::Tuple(..) | ty::Adt(..)) => {\n                 let Some(contents) = self.tcx().try_destructure_const(\n-                    ty::ParamEnv::reveal_all()\n-                        .and(self.tcx().mk_const(ty::ConstS { kind: ty::ConstKind::Value(ct), ty })),\n+                    ty::Const::from_value(self.tcx(), valtree, ty)\n                 ) else {\n                     // Fall back to debug pretty printing for invalid constants.\n-                    p!(write(\"{:?}\", ct));\n+                    p!(write(\"{:?}\", valtree));\n                     if print_ty {\n                         p!(\": \", print(ty));\n                     }\n                     return Ok(self);\n                 };\n-\n                 let fields = contents.fields.iter().copied();\n-\n                 match *ty.kind() {\n                     ty::Array(..) => {\n                         p!(\"[\", comma_sep(fields), \"]\");\n@@ -1513,7 +1490,6 @@ pub trait PrettyPrinter<'tcx>:\n                             contents.variant.expect(\"destructed const of adt without variant idx\");\n                         let variant_def = &def.variant(variant_idx);\n                         p!(print_value_path(variant_def.def_id, substs));\n-\n                         match variant_def.ctor_kind {\n                             CtorKind::Const => {}\n                             CtorKind::Fn => {\n@@ -1535,21 +1511,22 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n                     _ => unreachable!(),\n                 }\n-\n                 return Ok(self);\n             }\n-\n-            (ConstValue::Scalar(scalar), _) => {\n-                return self.pretty_print_const_scalar(scalar, ty, print_ty);\n+            (ty::ValTree::Leaf(leaf), _) => {\n+                return self.pretty_print_const_scalar_int(leaf, ty, print_ty);\n             }\n-\n             // FIXME(oli-obk): also pretty print arrays and other aggregate constants by reading\n             // their fields instead of just dumping the memory.\n             _ => {}\n         }\n \n         // fallback\n-        p!(write(\"{:?}\", ct));\n+        if valtree == ty::ValTree::zst() {\n+            p!(write(\"<ZST>\"));\n+        } else {\n+            p!(write(\"{:?}\", valtree));\n+        }\n         if print_ty {\n             p!(\": \", print(ty));\n         }\n@@ -2296,7 +2273,6 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         Ok(inner)\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n     fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<'tcx, T>)\n     where\n         T: TypeFoldable<'tcx>,\n@@ -2309,7 +2285,6 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_, 'tcx> {\n             type BreakTy = ();\n \n-            #[instrument(skip(self), level = \"trace\")]\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 trace!(\"address: {:p}\", r.0.0);\n                 if let ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) = *r {\n@@ -2326,7 +2301,6 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n \n             // We collect types in order to prevent really large types from compiling for\n             // a really long time. See issue #83150 for why this is necessary.\n-            #[instrument(skip(self), level = \"trace\")]\n             fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 let not_previously_inserted = self.type_collector.insert(ty);\n                 if not_previously_inserted {\n@@ -2353,6 +2327,7 @@ where\n {\n     type Output = P;\n     type Error = P::Error;\n+\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n         cx.in_binder(self)\n     }"}, {"sha": "51980acd38f749d27d9923f747c6a31d2393ba05", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 64, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -4,7 +4,6 @@\n //! types or regions but can be other things. Examples of type relations are\n //! subtyping, type equality, etc.\n \n-use crate::mir::interpret::{get_slice_bytes, ConstValue, GlobalAlloc, Scalar};\n use crate::ty::error::{ExpectedFound, TypeError};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n use crate::ty::{self, ImplSubject, Term, Ty, TyCtxt, TypeFoldable};\n@@ -613,9 +612,7 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n \n         (ty::ConstKind::Param(a_p), ty::ConstKind::Param(b_p)) => a_p.index == b_p.index,\n         (ty::ConstKind::Placeholder(p1), ty::ConstKind::Placeholder(p2)) => p1 == p2,\n-        (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => {\n-            check_const_value_eq(relation, a_val, b_val, a, b)?\n-        }\n+        (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n \n         (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu))\n             if tcx.features().generic_const_exprs =>\n@@ -649,66 +646,6 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     if is_match { Ok(a) } else { Err(TypeError::ConstMismatch(expected_found(relation, a, b))) }\n }\n \n-fn check_const_value_eq<'tcx, R: TypeRelation<'tcx>>(\n-    relation: &mut R,\n-    a_val: ConstValue<'tcx>,\n-    b_val: ConstValue<'tcx>,\n-    // FIXME(oli-obk): these arguments should go away with valtrees\n-    a: ty::Const<'tcx>,\n-    b: ty::Const<'tcx>,\n-    // FIXME(oli-obk): this should just be `bool` with valtrees\n-) -> RelateResult<'tcx, bool> {\n-    let tcx = relation.tcx();\n-    Ok(match (a_val, b_val) {\n-        (ConstValue::Scalar(Scalar::Int(a_val)), ConstValue::Scalar(Scalar::Int(b_val))) => {\n-            a_val == b_val\n-        }\n-        (\n-            ConstValue::Scalar(Scalar::Ptr(a_val, _a_size)),\n-            ConstValue::Scalar(Scalar::Ptr(b_val, _b_size)),\n-        ) => {\n-            a_val == b_val\n-                || match (tcx.global_alloc(a_val.provenance), tcx.global_alloc(b_val.provenance)) {\n-                    (GlobalAlloc::Function(a_instance), GlobalAlloc::Function(b_instance)) => {\n-                        a_instance == b_instance\n-                    }\n-                    _ => false,\n-                }\n-        }\n-\n-        (ConstValue::Slice { .. }, ConstValue::Slice { .. }) => {\n-            get_slice_bytes(&tcx, a_val) == get_slice_bytes(&tcx, b_val)\n-        }\n-\n-        (ConstValue::ByRef { alloc: alloc_a, .. }, ConstValue::ByRef { alloc: alloc_b, .. })\n-            if a.ty().is_ref() || b.ty().is_ref() =>\n-        {\n-            if a.ty().is_ref() && b.ty().is_ref() {\n-                alloc_a == alloc_b\n-            } else {\n-                false\n-            }\n-        }\n-        (ConstValue::ByRef { .. }, ConstValue::ByRef { .. }) => {\n-            let a_destructured = tcx.destructure_const(relation.param_env().and(a));\n-            let b_destructured = tcx.destructure_const(relation.param_env().and(b));\n-\n-            // Both the variant and each field have to be equal.\n-            if a_destructured.variant == b_destructured.variant {\n-                for (a_field, b_field) in iter::zip(a_destructured.fields, b_destructured.fields) {\n-                    relation.consts(*a_field, *b_field)?;\n-                }\n-\n-                true\n-            } else {\n-                false\n-            }\n-        }\n-\n-        _ => false,\n-    })\n-}\n-\n impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,"}, {"sha": "3d6e50f0c0622ee1869e8b0feacdeb51374c9bf7", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,12 +1,16 @@\n //! See docs in build/expr/mod.rs\n \n-use crate::build::{lit_to_mir_constant, Builder};\n+use crate::build::{parse_float_into_constval, Builder};\n+use rustc_ast as ast;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::mir::interpret::{ConstValue, LitToConstError, LitToConstInput, Scalar};\n+use rustc_middle::mir::interpret::{\n+    Allocation, ConstValue, LitToConstError, LitToConstInput, Scalar,\n+};\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt};\n+use rustc_target::abi::Size;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n@@ -84,3 +88,54 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n }\n+\n+#[instrument(skip(tcx, lit_input))]\n+pub(crate) fn lit_to_mir_constant<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    lit_input: LitToConstInput<'tcx>,\n+) -> Result<ConstantKind<'tcx>, LitToConstError> {\n+    let LitToConstInput { lit, ty, neg } = lit_input;\n+    let trunc = |n| {\n+        let param_ty = ty::ParamEnv::reveal_all().and(ty);\n+        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n+        trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n+        let result = width.truncate(n);\n+        trace!(\"trunc result: {}\", result);\n+        Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n+    };\n+\n+    let value = match (lit, &ty.kind()) {\n+        (ast::LitKind::Str(s, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_str() => {\n+            let s = s.as_str();\n+            let allocation = Allocation::from_bytes_byte_aligned_immutable(s.as_bytes());\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n+        }\n+        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n+            if matches!(inner_ty.kind(), ty::Slice(_)) =>\n+        {\n+            let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n+        }\n+        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n+            let id = tcx.allocate_bytes(data);\n+            ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n+        }\n+        (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n+            ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n+        }\n+        (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n+            trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?\n+        }\n+        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n+            parse_float_into_constval(*n, *fty, neg).ok_or(LitToConstError::Reported)?\n+        }\n+        (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n+        (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n+        (ast::LitKind::Err(_), _) => return Err(LitToConstError::Reported),\n+        _ => return Err(LitToConstError::TypeError),\n+    };\n+\n+    Ok(ConstantKind::Val(value, ty))\n+}"}, {"sha": "94c71bbf56da6dd55424172f3be7a18e2730fb21", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 70, "deletions": 56, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,9 +1,10 @@\n use crate::build;\n+pub(crate) use crate::build::expr::as_constant::lit_to_mir_constant;\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n-use crate::thir::constant::parse_float;\n use crate::thir::pattern::pat_from_hir;\n-use rustc_ast as ast;\n+use rustc_apfloat::ieee::{Double, Single};\n+use rustc_apfloat::Float;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n@@ -14,15 +15,15 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::middle::region;\n-use rustc_middle::mir::interpret::Allocation;\n-use rustc_middle::mir::interpret::{ConstValue, LitToConstError, LitToConstInput, Scalar};\n+use rustc_middle::mir::interpret::ConstValue;\n+use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::*;\n use rustc_middle::thir::{BindingMode, Expr, ExprId, LintLevel, LocalVarId, PatKind, Thir};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use rustc_target::abi::Size;\n+use rustc_span::Symbol;\n use rustc_target::spec::abi::Abi;\n \n use super::lints;\n@@ -266,57 +267,6 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n     })\n }\n \n-#[instrument(skip(tcx, lit_input))]\n-pub(crate) fn lit_to_mir_constant<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    lit_input: LitToConstInput<'tcx>,\n-) -> Result<ConstantKind<'tcx>, LitToConstError> {\n-    let LitToConstInput { lit, ty, neg } = lit_input;\n-    let trunc = |n| {\n-        let param_ty = ty::ParamEnv::reveal_all().and(ty);\n-        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n-        trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n-        let result = width.truncate(n);\n-        trace!(\"trunc result: {}\", result);\n-        Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n-    };\n-\n-    let value = match (lit, &ty.kind()) {\n-        (ast::LitKind::Str(s, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_str() => {\n-            let s = s.as_str();\n-            let allocation = Allocation::from_bytes_byte_aligned_immutable(s.as_bytes());\n-            let allocation = tcx.intern_const_alloc(allocation);\n-            ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n-        }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n-            if matches!(inner_ty.kind(), ty::Slice(_)) =>\n-        {\n-            let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n-            let allocation = tcx.intern_const_alloc(allocation);\n-            ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n-        }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n-            let id = tcx.allocate_bytes(data);\n-            ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n-        }\n-        (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n-            ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n-        }\n-        (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n-            trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?\n-        }\n-        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n-            parse_float(*n, *fty, neg).ok_or(LitToConstError::Reported)?\n-        }\n-        (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n-        (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n-        (ast::LitKind::Err(_), _) => return Err(LitToConstError::Reported),\n-        _ => return Err(LitToConstError::TypeError),\n-    };\n-\n-    Ok(ConstantKind::Val(value, ty))\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n@@ -1137,6 +1087,70 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n }\n \n+fn parse_float_into_constval<'tcx>(\n+    num: Symbol,\n+    float_ty: ty::FloatTy,\n+    neg: bool,\n+) -> Option<ConstValue<'tcx>> {\n+    parse_float_into_scalar(num, float_ty, neg).map(ConstValue::Scalar)\n+}\n+\n+pub(crate) fn parse_float_into_scalar(\n+    num: Symbol,\n+    float_ty: ty::FloatTy,\n+    neg: bool,\n+) -> Option<Scalar> {\n+    let num = num.as_str();\n+    match float_ty {\n+        ty::FloatTy::F32 => {\n+            let Ok(rust_f) = num.parse::<f32>() else { return None };\n+            let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n+                panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n+            });\n+\n+            assert!(\n+                u128::from(rust_f.to_bits()) == f.to_bits(),\n+                \"apfloat::ieee::Single gave different result for `{}`: \\\n+                 {}({:#x}) vs Rust's {}({:#x})\",\n+                rust_f,\n+                f,\n+                f.to_bits(),\n+                Single::from_bits(rust_f.to_bits().into()),\n+                rust_f.to_bits()\n+            );\n+\n+            if neg {\n+                f = -f;\n+            }\n+\n+            Some(Scalar::from_f32(f))\n+        }\n+        ty::FloatTy::F64 => {\n+            let Ok(rust_f) = num.parse::<f64>() else { return None };\n+            let mut f = num.parse::<Double>().unwrap_or_else(|e| {\n+                panic!(\"apfloat::ieee::Double failed to parse `{}`: {:?}\", num, e)\n+            });\n+\n+            assert!(\n+                u128::from(rust_f.to_bits()) == f.to_bits(),\n+                \"apfloat::ieee::Double gave different result for `{}`: \\\n+                 {}({:#x}) vs Rust's {}({:#x})\",\n+                rust_f,\n+                f,\n+                f.to_bits(),\n+                Double::from_bits(rust_f.to_bits().into()),\n+                rust_f.to_bits()\n+            );\n+\n+            if neg {\n+                f = -f;\n+            }\n+\n+            Some(Scalar::from_f64(f))\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Builder methods are broken up into modules, depending on what kind\n // of thing is being lowered. Note that they use the `unpack` macro"}, {"sha": "a7e4403a242e103efca8f5589b757d1b1ae5de72", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 19, "deletions": 80, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,13 +1,7 @@\n-use rustc_apfloat::Float;\n use rustc_ast as ast;\n-use rustc_middle::mir::interpret::{\n-    Allocation, ConstValue, LitToConstError, LitToConstInput, Scalar,\n-};\n-use rustc_middle::ty::{self, ParamEnv, TyCtxt};\n-use rustc_span::symbol::Symbol;\n-use rustc_target::abi::Size;\n+use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n+use rustc_middle::ty::{self, ParamEnv, ScalarInt, TyCtxt};\n \n-// FIXME Once valtrees are available, get rid of this function and the query\n pub(crate) fn lit_to_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     lit_input: LitToConstInput<'tcx>,\n@@ -20,94 +14,39 @@ pub(crate) fn lit_to_const<'tcx>(\n         trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n         let result = width.truncate(n);\n         trace!(\"trunc result: {}\", result);\n-        Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n+\n+        Ok(ScalarInt::try_from_uint(result, width)\n+            .unwrap_or_else(|| bug!(\"expected to create ScalarInt from uint {:?}\", result)))\n     };\n \n-    let lit = match (lit, &ty.kind()) {\n+    let valtree = match (lit, &ty.kind()) {\n         (ast::LitKind::Str(s, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_str() => {\n-            let s = s.as_str();\n-            let allocation = Allocation::from_bytes_byte_aligned_immutable(s.as_bytes());\n-            let allocation = tcx.intern_const_alloc(allocation);\n-            ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n+            let str_bytes = s.as_str().as_bytes();\n+            ty::ValTree::from_raw_bytes(tcx, str_bytes)\n         }\n         (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n             if matches!(inner_ty.kind(), ty::Slice(_)) =>\n         {\n-            let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n-            let allocation = tcx.intern_const_alloc(allocation);\n-            ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n+            let bytes = data as &[u8];\n+            ty::ValTree::from_raw_bytes(tcx, bytes)\n         }\n         (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n-            let id = tcx.allocate_bytes(data);\n-            ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n+            let bytes = data as &[u8];\n+            ty::ValTree::from_raw_bytes(tcx, bytes)\n         }\n         (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n-            ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n+            ty::ValTree::from_scalar_int((*n).into())\n         }\n         (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n-            trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?\n-        }\n-        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n-            parse_float(*n, *fty, neg).ok_or(LitToConstError::Reported)?\n+            let scalar_int =\n+                trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?;\n+            ty::ValTree::from_scalar_int(scalar_int)\n         }\n-        (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n-        (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n+        (ast::LitKind::Bool(b), ty::Bool) => ty::ValTree::from_scalar_int((*b).into()),\n+        (ast::LitKind::Char(c), ty::Char) => ty::ValTree::from_scalar_int((*c).into()),\n         (ast::LitKind::Err(_), _) => return Err(LitToConstError::Reported),\n         _ => return Err(LitToConstError::TypeError),\n     };\n-    Ok(ty::Const::from_value(tcx, lit, ty))\n-}\n-\n-// FIXME move this to rustc_mir_build::build\n-pub(crate) fn parse_float<'tcx>(\n-    num: Symbol,\n-    fty: ty::FloatTy,\n-    neg: bool,\n-) -> Option<ConstValue<'tcx>> {\n-    let num = num.as_str();\n-    use rustc_apfloat::ieee::{Double, Single};\n-    let scalar = match fty {\n-        ty::FloatTy::F32 => {\n-            let Ok(rust_f) = num.parse::<f32>() else { return None };\n-            let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n-                panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n-            });\n-            assert!(\n-                u128::from(rust_f.to_bits()) == f.to_bits(),\n-                \"apfloat::ieee::Single gave different result for `{}`: \\\n-                 {}({:#x}) vs Rust's {}({:#x})\",\n-                rust_f,\n-                f,\n-                f.to_bits(),\n-                Single::from_bits(rust_f.to_bits().into()),\n-                rust_f.to_bits()\n-            );\n-            if neg {\n-                f = -f;\n-            }\n-            Scalar::from_f32(f)\n-        }\n-        ty::FloatTy::F64 => {\n-            let Ok(rust_f) = num.parse::<f64>() else { return None };\n-            let mut f = num.parse::<Double>().unwrap_or_else(|e| {\n-                panic!(\"apfloat::ieee::Double failed to parse `{}`: {:?}\", num, e)\n-            });\n-            assert!(\n-                u128::from(rust_f.to_bits()) == f.to_bits(),\n-                \"apfloat::ieee::Double gave different result for `{}`: \\\n-                 {}({:#x}) vs Rust's {}({:#x})\",\n-                rust_f,\n-                f,\n-                f.to_bits(),\n-                Double::from_bits(rust_f.to_bits().into()),\n-                rust_f.to_bits()\n-            );\n-            if neg {\n-                f = -f;\n-            }\n-            Scalar::from_f64(f)\n-        }\n-    };\n \n-    Some(ConstValue::Scalar(scalar))\n+    Ok(ty::Const::from_value(tcx, valtree, ty))\n }"}, {"sha": "845be2ab264a610b989b5615805b815fed589516", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -371,6 +371,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n                 let destructured = tcx.destructure_mir_constant(param_env, cv);\n+\n                 PatKind::Variant {\n                     adt_def: *adt_def,\n                     substs,\n@@ -502,7 +503,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // deref pattern.\n                 _ => {\n                     if !pointee_ty.is_sized(tcx.at(span), param_env) {\n-                        // `tcx.deref_const()` below will ICE with an unsized type\n+                        // `tcx.deref_mir_constant()` below will ICE with an unsized type\n                         // (except slices, which are handled in a separate arm above).\n                         let msg = format!(\"cannot use unsized non-slice type `{}` in constant patterns\", pointee_ty);\n                         if self.include_lint_checks {"}, {"sha": "f5d957e30ff09813ca8ac28de0b7338610e11af3", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -185,11 +185,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n             (Some(PatKind::Constant { value: lo }), None) => {\n                 let hi = ty.numeric_max_val(self.tcx)?;\n-                Some((*lo, hi.into()))\n+                Some((*lo, mir::ConstantKind::from_const(hi, self.tcx)))\n             }\n             (None, Some(PatKind::Constant { value: hi })) => {\n                 let lo = ty.numeric_min_val(self.tcx)?;\n-                Some((lo.into(), *hi))\n+                Some((mir::ConstantKind::from_const(lo, self.tcx), *hi))\n             }\n             _ => None,\n         }\n@@ -798,11 +798,12 @@ pub(crate) fn compare_const_vals<'tcx>(\n     if let ty::Str = ty.kind() && let (\n         Some(a_val @ ConstValue::Slice { .. }),\n         Some(b_val @ ConstValue::Slice { .. }),\n-    ) = (a.try_val(), b.try_val())\n+    ) = (a.try_to_value(tcx), b.try_to_value(tcx))\n     {\n         let a_bytes = get_slice_bytes(&tcx, a_val);\n         let b_bytes = get_slice_bytes(&tcx, b_val);\n         return from_bool(a_bytes == b_bytes);\n     }\n+\n     fallback()\n }"}, {"sha": "8d16c5f22c3f4ab31cfccfa3bf7b6fc8c9ece0b1", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1032,7 +1032,7 @@ where\n         Operand::Constant(Box::new(Constant {\n             span: self.source_info.span,\n             user_ty: None,\n-            literal: ty::Const::from_usize(self.tcx(), val.into()).into(),\n+            literal: ConstantKind::from_usize(self.tcx(), val.into()),\n         }))\n     }\n "}, {"sha": "8944ebed9a70487063c2adf9c7a38779528cc768", "filename": "compiler/rustc_mir_transform/src/const_debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_debuginfo.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -19,7 +19,7 @@ impl<'tcx> MirPass<'tcx> for ConstDebugInfo {\n         sess.opts.debugging_opts.unsound_mir_opts && sess.mir_opt_level() > 0\n     }\n \n-    fn run_pass(&self, _: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         trace!(\"running ConstDebugInfo on {:?}\", body.source);\n \n         for (local, constant) in find_optimization_oportunities(body) {"}, {"sha": "412a5b4fc9104d2d083bdd979031038ab18e6eb4", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -67,6 +67,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         true\n     }\n \n+    #[instrument(skip(self, tcx), level = \"debug\")]\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // will be evaluated by miri and produce its errors there\n         if body.source.promoted.is_some() {\n@@ -687,7 +688,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Operand::Constant(Box::new(Constant {\n             span,\n             user_ty: None,\n-            literal: ty::Const::from_scalar(self.tcx, scalar, ty).into(),\n+            literal: ConstantKind::from_scalar(self.tcx, scalar, ty),\n         }))\n     }\n \n@@ -765,20 +766,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             if let Some(Some(alloc)) = alloc {\n                                 // Assign entire constant in a single statement.\n                                 // We can't use aggregates, as we run after the aggregate-lowering `MirPhase`.\n+                                let const_val = ConstValue::ByRef { alloc, offset: Size::ZERO };\n+                                let literal = ConstantKind::Val(const_val, ty);\n                                 *rval = Rvalue::Use(Operand::Constant(Box::new(Constant {\n                                     span: source_info.span,\n                                     user_ty: None,\n-                                    literal: self\n-                                        .ecx\n-                                        .tcx\n-                                        .mk_const(ty::ConstS {\n-                                            ty,\n-                                            kind: ty::ConstKind::Value(ConstValue::ByRef {\n-                                                alloc,\n-                                                offset: Size::ZERO,\n-                                            }),\n-                                        })\n-                                        .into(),\n+                                    literal,\n                                 })));\n                             }\n                         }"}, {"sha": "e0e27c53f1822e22b7dbb11bd3cd396ed86da5bf", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -470,7 +470,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         Rvalue::Use(Operand::Constant(Box::new(Constant {\n             span,\n             user_ty: None,\n-            literal: ty::Const::from_bool(self.tcx, val).into(),\n+            literal: ConstantKind::from_bool(self.tcx, val),\n         })))\n     }\n "}, {"sha": "f3c67319596d14397e21e9db08fcf4b8aebdc51b", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -991,7 +991,7 @@ fn insert_panic_block<'tcx>(\n         cond: Operand::Constant(Box::new(Constant {\n             span: body.span,\n             user_ty: None,\n-            literal: ty::Const::from_bool(tcx, false).into(),\n+            literal: ConstantKind::from_bool(tcx, false),\n         })),\n         expected: true,\n         msg: message,"}, {"sha": "ea10ec5f25c1577282e45920e06ae824f9d14258", "filename": "compiler/rustc_mir_transform/src/instcombine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -3,8 +3,8 @@\n use crate::MirPass;\n use rustc_hir::Mutability;\n use rustc_middle::mir::{\n-    BinOp, Body, Constant, LocalDecls, Operand, Place, ProjectionElem, Rvalue, SourceInfo,\n-    Statement, StatementKind, Terminator, TerminatorKind, UnOp,\n+    BinOp, Body, Constant, ConstantKind, LocalDecls, Operand, Place, ProjectionElem, Rvalue,\n+    SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UnOp,\n };\n use rustc_middle::ty::{self, TyCtxt};\n \n@@ -129,8 +129,8 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n                     return;\n                 }\n \n-                let constant =\n-                    Constant { span: source_info.span, literal: len.into(), user_ty: None };\n+                let literal = ConstantKind::from_const(len, self.tcx);\n+                let constant = Constant { span: source_info.span, literal, user_ty: None };\n                 *rvalue = Rvalue::Use(Operand::Constant(Box::new(constant)));\n             }\n         }"}, {"sha": "b89322514657898a84fa01274c030f4867b88ecf", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -531,8 +531,10 @@ fn inner_optimized_mir(tcx: TyCtxt<'_>, did: LocalDefId) -> Body<'_> {\n         None => {}\n         Some(other) => panic!(\"do not use `optimized_mir` for constants: {:?}\", other),\n     }\n+    debug!(\"about to call mir_drops_elaborated...\");\n     let mut body =\n         tcx.mir_drops_elaborated_and_const_checked(ty::WithOptConstParam::unknown(did)).steal();\n+    debug!(\"body: {:#?}\", body);\n     run_optimization_passes(tcx, &mut body);\n \n     debug_assert!(!body.has_free_regions(), \"Free regions in optimized MIR\");"}, {"sha": "989b94b68c101443ba50c6776d270822e2eb0f7a", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                                     Rvalue::Use(Operand::Constant(Box::new(Constant {\n                                         span: terminator.source_info.span,\n                                         user_ty: None,\n-                                        literal: ty::Const::zero_sized(tcx, tcx.types.unit).into(),\n+                                        literal: ConstantKind::zero_sized(tcx.types.unit),\n                                     }))),\n                                 ))),\n                             });"}, {"sha": "89808d3d4cdbd9c9056c358806eb64daf951f34c", "filename": "compiler/rustc_mir_transform/src/remove_noop_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -15,7 +15,7 @@ impl<'tcx> MirPass<'tcx> for RemoveNoopLandingPads {\n         sess.panic_strategy() != PanicStrategy::Abort\n     }\n \n-    fn run_pass(&self, _: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"remove_noop_landing_pads({:?})\", body);\n         self.remove_nop_landing_pads(body)\n     }\n@@ -81,6 +81,8 @@ impl RemoveNoopLandingPads {\n     }\n \n     fn remove_nop_landing_pads(&self, body: &mut Body<'_>) {\n+        debug!(\"body: {:#?}\", body);\n+\n         // make sure there's a single resume block\n         let resume_block = {\n             let patch = MirPatch::new(body);"}, {"sha": "3be1783ae3389ad6b1061af775b473d6a38dab23", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -430,7 +430,7 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n         let func = Operand::Constant(Box::new(Constant {\n             span: self.span,\n             user_ty: None,\n-            literal: ty::Const::zero_sized(tcx, func_ty).into(),\n+            literal: ConstantKind::zero_sized(func_ty),\n         }));\n \n         let ref_loc = self.make_place(\n@@ -630,7 +630,7 @@ fn build_call_shim<'tcx>(\n                 Operand::Constant(Box::new(Constant {\n                     span,\n                     user_ty: None,\n-                    literal: ty::Const::zero_sized(tcx, ty).into(),\n+                    literal: ConstantKind::zero_sized(ty),\n                 })),\n                 rcvr.into_iter().collect::<Vec<_>>(),\n             )"}, {"sha": "2af22e129a5f7e67373de4020f5898bbb3c813d1", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -323,6 +323,7 @@ impl<'tcx> InliningMap<'tcx> {\n     }\n }\n \n+#[instrument(skip(tcx, mode), level = \"debug\")]\n pub fn collect_crate_mono_items(\n     tcx: TyCtxt<'_>,\n     mode: MonoItemCollectionMode,\n@@ -362,6 +363,7 @@ pub fn collect_crate_mono_items(\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n+#[instrument(skip(tcx, mode), level = \"debug\")]\n fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<'_>> {\n     debug!(\"collecting roots\");\n     let mut roots = MonoItems { compute_inlining: false, tcx, items: Vec::new() };\n@@ -400,6 +402,7 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n \n /// Collect all monomorphized items reachable from `starting_point`, and emit a note diagnostic if a\n /// post-monorphization error is encountered during a collection step.\n+#[instrument(skip(tcx, visited, recursion_depths, recursion_limit, inlining_map), level = \"debug\")]\n fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     starting_point: Spanned<MonoItem<'tcx>>,\n@@ -752,13 +755,15 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     /// This does not walk the constant, as it has been handled entirely here and trying\n     /// to walk it would attempt to evaluate the `ty::Const` inside, which doesn't necessarily\n     /// work, as some constants cannot be represented in the type system.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn visit_constant(&mut self, constant: &mir::Constant<'tcx>, location: Location) {\n         let literal = self.monomorphize(constant.literal);\n         let val = match literal {\n             mir::ConstantKind::Val(val, _) => val,\n             mir::ConstantKind::Ty(ct) => match ct.kind() {\n-                ty::ConstKind::Value(val) => val,\n+                ty::ConstKind::Value(val) => self.tcx.valtree_to_const_val((ct.ty(), val)),\n                 ty::ConstKind::Unevaluated(ct) => {\n+                    debug!(?ct);\n                     let param_env = ty::ParamEnv::reveal_all();\n                     match self.tcx.const_eval_resolve(param_env, ct, None) {\n                         // The `monomorphize` call should have evaluated that constant already.\n@@ -778,14 +783,18 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.visit_ty(literal.ty(), TyContext::Location(location));\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn visit_const(&mut self, constant: ty::Const<'tcx>, location: Location) {\n         debug!(\"visiting const {:?} @ {:?}\", constant, location);\n \n         let substituted_constant = self.monomorphize(constant);\n         let param_env = ty::ParamEnv::reveal_all();\n \n         match substituted_constant.kind() {\n-            ty::ConstKind::Value(val) => collect_const_value(self.tcx, val, self.output),\n+            ty::ConstKind::Value(val) => {\n+                let const_val = self.tcx.valtree_to_const_val((constant.ty(), val));\n+                collect_const_value(self.tcx, const_val, self.output)\n+            }\n             ty::ConstKind::Unevaluated(unevaluated) => {\n                 match self.tcx.const_eval_resolve(param_env, unevaluated, None) {\n                     // The `monomorphize` call should have evaluated that constant already.\n@@ -1120,6 +1129,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     }\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n fn create_fn_mono_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n@@ -1133,7 +1143,10 @@ fn create_fn_mono_item<'tcx>(\n         crate::util::dump_closure_profile(tcx, instance);\n     }\n \n-    respan(source, MonoItem::Fn(instance.polymorphize(tcx)))\n+    let respanned = respan(source, MonoItem::Fn(instance.polymorphize(tcx)));\n+    debug!(?respanned);\n+\n+    respanned\n }\n \n /// Creates a `MonoItem` for each method that is referenced by the vtable for\n@@ -1275,6 +1288,7 @@ impl<'v> RootCollector<'_, 'v> {\n \n     /// If `def_id` represents a root, pushes it onto the list of\n     /// outputs. (Note that all roots must be monomorphic.)\n+    #[instrument(skip(self), level = \"debug\")]\n     fn push_if_root(&mut self, def_id: LocalDefId) {\n         if self.is_root(def_id) {\n             debug!(\"RootCollector::push_if_root: found root def_id={:?}\", def_id);\n@@ -1415,17 +1429,17 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut MonoIte\n }\n \n /// Scans the MIR in order to find function calls, closures, and drop-glue.\n+#[instrument(skip(tcx, output), level = \"debug\")]\n fn collect_neighbours<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n     output: &mut MonoItems<'tcx>,\n ) {\n-    debug!(\"collect_neighbours: {:?}\", instance.def_id());\n     let body = tcx.instance_mir(instance.def);\n-\n     MirNeighborCollector { tcx, body: &body, output, instance }.visit_body(&body);\n }\n \n+#[instrument(skip(tcx, output), level = \"debug\")]\n fn collect_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     value: ConstValue<'tcx>,"}, {"sha": "f67b87a6a52b8e08d0d526ffa6d4d5c0b2ca8705", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,7 +1,6 @@\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::CrateNum;\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n-use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::print::{PrettyPrinter, Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt, TypeFoldable};\n@@ -30,6 +29,7 @@ pub(super) fn mangle<'tcx>(\n         match key.disambiguated_data.data {\n             DefPathData::TypeNs(_) | DefPathData::ValueNs(_) => {\n                 instance_ty = tcx.type_of(ty_def_id);\n+                debug!(?instance_ty);\n                 break;\n             }\n             _ => {\n@@ -261,10 +261,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolPrinter<'tcx> {\n     fn print_const(self, ct: ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n         // only print integers\n         match (ct.kind(), ct.ty().kind()) {\n-            (\n-                ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(scalar))),\n-                ty::Int(_) | ty::Uint(_),\n-            ) => {\n+            (ty::ConstKind::Value(ty::ValTree::Leaf(scalar)), ty::Int(_) | ty::Uint(_)) => {\n                 // The `pretty_print_const` formatting depends on -Zverbose\n                 // flag, so we cannot reuse it here.\n                 let signed = matches!(ct.ty().kind(), ty::Int(_));"}, {"sha": "87b844ca759a56737912e2f572dfbfadc7171019", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 51, "deletions": 40, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -5,7 +5,6 @@ use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n-use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::print::{Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n@@ -604,16 +603,18 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n         if let Some(&i) = self.consts.get(&ct) {\n             return self.print_backref(i);\n         }\n+\n         let start = self.out.len();\n+        let ty = ct.ty();\n \n-        match ct.ty().kind() {\n+        match ty.kind() {\n             ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Char => {\n-                self = ct.ty().print(self)?;\n+                self = ty.print(self)?;\n \n-                let mut bits = ct.eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ct.ty());\n+                let mut bits = ct.eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ty);\n \n                 // Negative integer values are mangled using `n` as a \"sign prefix\".\n-                if let ty::Int(ity) = ct.ty().kind() {\n+                if let ty::Int(ity) = ty.kind() {\n                     let val =\n                         Integer::from_int_ty(&self.tcx, *ity).size().sign_extend(bits) as i128;\n                     if val < 0 {\n@@ -625,46 +626,57 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                 let _ = write!(self.out, \"{:x}_\", bits);\n             }\n \n-            // HACK(eddyb) because `ty::Const` only supports sized values (for now),\n-            // we can't use `deref_const` + supporting `str`, we have to specially\n-            // handle `&str` and include both `&` (\"R\") and `str` (\"e\") prefixes.\n-            ty::Ref(_, ty, hir::Mutability::Not) if *ty == self.tcx.types.str_ => {\n-                self.push(\"R\");\n-                match ct.kind() {\n-                    ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => {\n-                        // NOTE(eddyb) the following comment was kept from `ty::print::pretty`:\n-                        // The `inspect` here is okay since we checked the bounds, and there are no\n-                        // relocations (we have an active `str` reference here). We don't use this\n-                        // result to affect interpreter execution.\n-                        let slice = data\n-                            .inner()\n-                            .inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n-                        let s = std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n-\n-                        self.push(\"e\");\n-                        // FIXME(eddyb) use a specialized hex-encoding loop.\n-                        for byte in s.bytes() {\n-                            let _ = write!(self.out, \"{:02x}\", byte);\n+            // FIXME(valtrees): Remove the special case for `str`\n+            // here and fully support unsized constants.\n+            ty::Ref(_, inner_ty, mutbl) => {\n+                self.push(match mutbl {\n+                    hir::Mutability::Not => \"R\",\n+                    hir::Mutability::Mut => \"Q\",\n+                });\n+\n+                match inner_ty.kind() {\n+                    ty::Str if *mutbl == hir::Mutability::Not => {\n+                        match ct.kind() {\n+                            ty::ConstKind::Value(valtree) => {\n+                                let slice =\n+                                    valtree.try_to_raw_bytes(self.tcx(), ty).unwrap_or_else(|| {\n+                                        bug!(\n+                                        \"expected to get raw bytes from valtree {:?} for type {:}\",\n+                                        valtree, ty\n+                                    )\n+                                    });\n+                                let s = std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n+\n+                                self.push(\"e\");\n+\n+                                // FIXME(eddyb) use a specialized hex-encoding loop.\n+                                for byte in s.bytes() {\n+                                    let _ = write!(self.out, \"{:02x}\", byte);\n+                                }\n+\n+                                self.push(\"_\");\n+                            }\n+\n+                            _ => {\n+                                bug!(\"symbol_names: unsupported `&str` constant: {:?}\", ct);\n+                            }\n                         }\n-                        self.push(\"_\");\n                     }\n-\n                     _ => {\n-                        bug!(\"symbol_names: unsupported `&str` constant: {:?}\", ct);\n+                        let pointee_ty = ct\n+                            .ty()\n+                            .builtin_deref(true)\n+                            .expect(\"tried to dereference on non-ptr type\")\n+                            .ty;\n+                        let dereferenced_const =\n+                            self.tcx.mk_const(ty::ConstS { kind: ct.kind(), ty: pointee_ty });\n+                        self = dereferenced_const.print(self)?;\n                     }\n                 }\n             }\n \n-            ty::Ref(_, _, mutbl) => {\n-                self.push(match mutbl {\n-                    hir::Mutability::Not => \"R\",\n-                    hir::Mutability::Mut => \"Q\",\n-                });\n-                self = self.tcx.deref_const(ty::ParamEnv::reveal_all().and(ct)).print(self)?;\n-            }\n-\n-            ty::Array(..) | ty::Tuple(..) | ty::Adt(..) => {\n-                let contents = self.tcx.destructure_const(ty::ParamEnv::reveal_all().and(ct));\n+            ty::Array(..) | ty::Tuple(..) | ty::Adt(..) | ty::Slice(_) => {\n+                let contents = self.tcx.destructure_const(ct);\n                 let fields = contents.fields.iter().copied();\n \n                 let print_field_list = |mut this: Self| {\n@@ -676,7 +688,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                 };\n \n                 match *ct.ty().kind() {\n-                    ty::Array(..) => {\n+                    ty::Array(..) | ty::Slice(_) => {\n                         self.push(\"A\");\n                         self = print_field_list(self)?;\n                     }\n@@ -723,7 +735,6 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                     _ => unreachable!(),\n                 }\n             }\n-\n             _ => {\n                 bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\", ct.ty(), ct);\n             }"}, {"sha": "a63790b594d83cbb982dc5418f6c305da1849d6a", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -6,6 +6,7 @@ use super::*;\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxt;\n use crate::traits::project::ProjectAndUnifyResult;\n+use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::{Region, RegionVid, Term};\n \n@@ -834,7 +835,16 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                                 unevaluated,\n                                 Some(obligation.cause.span),\n                             ) {\n-                                Ok(val) => Ok(ty::Const::from_value(select.tcx(), val, c.ty())),\n+                                Ok(Some(valtree)) => {\n+                                    Ok(ty::Const::from_value(select.tcx(), valtree, c.ty()))\n+                                }\n+                                Ok(None) => {\n+                                    let tcx = self.tcx;\n+                                    let def_id = unevaluated.def.did;\n+                                    let reported = tcx.sess.struct_span_err(tcx.def_span(def_id), &format!(\"unable to construct a constant value for the unevaluated constant {:?}\", unevaluated)).emit();\n+\n+                                    Err(ErrorHandled::Reported(reported))\n+                                }\n                                 Err(err) => Err(err),\n                             }\n                         } else {"}, {"sha": "5d08ea99ac64a2975c3917fda763de80518eae22", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -13,9 +13,7 @@ use rustc_hir::def::DefKind;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{\n-    ConstValue, ErrorHandled, LitToConstError, LitToConstInput, Scalar,\n-};\n+use rustc_middle::mir::interpret::{ErrorHandled, LitToConstError, LitToConstInput};\n use rustc_middle::thir;\n use rustc_middle::thir::abstract_const::{self, Node, NodeId, NotConstEvaluatable};\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n@@ -449,9 +447,8 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 self.nodes.push(Node::Leaf(constant))\n             }\n             &ExprKind::NonHirLiteral { lit , user_ty: _} => {\n-                // FIXME Construct a Valtree from this ScalarInt when introducing Valtrees\n-                let const_value = ConstValue::Scalar(Scalar::Int(lit));\n-                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, const_value, node.ty)))\n+                let val = ty::ValTree::from_scalar_int(lit);\n+                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n             }\n             &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n                 let uneval = ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs);"}, {"sha": "70d8fdae6514027430801b3bb62ba4f053a2bc72", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -594,22 +594,24 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n \n                     let mut evaluate = |c: Const<'tcx>| {\n                         if let ty::ConstKind::Unevaluated(unevaluated) = c.kind() {\n-                            match self.selcx.infcx().const_eval_resolve(\n+                            match self.selcx.infcx().try_const_eval_resolve(\n                                 obligation.param_env,\n                                 unevaluated,\n+                                c.ty(),\n                                 Some(obligation.cause.span),\n                             ) {\n-                                Ok(val) => Ok(Const::from_value(self.selcx.tcx(), val, c.ty())),\n-                                Err(ErrorHandled::TooGeneric) => {\n-                                    stalled_on.extend(\n-                                        unevaluated\n-                                            .substs\n-                                            .iter()\n-                                            .filter_map(TyOrConstInferVar::maybe_from_generic_arg),\n-                                    );\n-                                    Err(ErrorHandled::TooGeneric)\n-                                }\n-                                Err(err) => Err(err),\n+                                Ok(val) => Ok(val),\n+                                Err(e) => match e {\n+                                    ErrorHandled::TooGeneric => {\n+                                        stalled_on.extend(\n+                                            unevaluated.substs.iter().filter_map(\n+                                                TyOrConstInferVar::maybe_from_generic_arg,\n+                                            ),\n+                                        );\n+                                        Err(ErrorHandled::TooGeneric)\n+                                    }\n+                                    _ => Err(e),\n+                                },\n                             }\n                         } else {\n                             Ok(c)"}, {"sha": "a72f90746edfa70b0d19ab18191d5da18ddcf623", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -618,11 +618,14 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn fold_const(&mut self, constant: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         if self.selcx.tcx().lazy_normalization() || !self.eager_inference_replacement {\n             constant\n         } else {\n             let constant = constant.super_fold_with(self);\n+            debug!(?constant);\n+            debug!(\"self.param_env: {:?}\", self.param_env);\n             constant.eval(self.selcx.tcx(), self.param_env)\n         }\n     }"}, {"sha": "b80a27eb07d061373d5620dc72a4b80fe24dd29c", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -100,7 +100,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n     }\n }\n \n-/// Visitor to find the maximum escaping bound var\n+// Visitor to find the maximum escaping bound var\n struct MaxEscapingBoundVarVisitor {\n     // The index which would count as escaping\n     outer_index: ty::DebruijnIndex,\n@@ -336,12 +336,15 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n     ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         Ok(match constant {\n             mir::ConstantKind::Ty(c) => {\n-                let const_folded = c.try_fold_with(self)?;\n+                let const_folded = c.try_super_fold_with(self)?;\n                 match const_folded.kind() {\n-                    ty::ConstKind::Value(cv) => {\n-                        // FIXME With Valtrees we need to convert `cv: ValTree`\n-                        // to a `ConstValue` here.\n-                        mir::ConstantKind::Val(cv, const_folded.ty())\n+                    ty::ConstKind::Value(valtree) => {\n+                        let tcx = self.infcx.tcx;\n+                        let ty = const_folded.ty();\n+                        let const_val = tcx.valtree_to_const_val((ty, valtree));\n+                        debug!(?ty, ?valtree, ?const_val);\n+\n+                        mir::ConstantKind::Val(const_val, ty)\n                     }\n                     _ => mir::ConstantKind::Ty(const_folded),\n                 }"}, {"sha": "ee2c8da5a005df8f6e0c6ba14c48ebe9567c4e37", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -636,13 +636,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     let evaluate = |c: ty::Const<'tcx>| {\n                         if let ty::ConstKind::Unevaluated(unevaluated) = c.kind() {\n-                            self.infcx\n-                                .const_eval_resolve(\n-                                    obligation.param_env,\n-                                    unevaluated,\n-                                    Some(obligation.cause.span),\n-                                )\n-                                .map(|val| ty::Const::from_value(self.tcx(), val, c.ty()))\n+                            match self.infcx.try_const_eval_resolve(\n+                                obligation.param_env,\n+                                unevaluated,\n+                                c.ty(),\n+                                Some(obligation.cause.span),\n+                            ) {\n+                                Ok(val) => Ok(val),\n+                                Err(e) => Err(e),\n+                            }\n                         } else {\n                             Ok(c)\n                         }"}, {"sha": "5d394ed2263ffc8141c96414eb02c4675acaed62", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -25,7 +25,6 @@ pub(crate) fn provide(p: &mut Providers) {\n     };\n }\n \n-#[instrument(level = \"debug\", skip(tcx))]\n fn try_normalize_after_erasing_regions<'tcx, T: TypeFoldable<'tcx> + PartialEq + Copy>(\n     tcx: TyCtxt<'tcx>,\n     goal: ParamEnvAnd<'tcx, T>,"}, {"sha": "552db5406df8d3ac6c0c33f2c6dda3a71b8cf065", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -112,7 +112,6 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n     }\n }\n \n-#[instrument(level = \"debug\", skip(tcx))]\n fn resolve_instance<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, (DefId, SubstsRef<'tcx>)>,\n@@ -141,7 +140,6 @@ fn resolve_instance_of_const_arg<'tcx>(\n     )\n }\n \n-#[instrument(level = \"debug\", skip(tcx))]\n fn inner_resolve_instance<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>)>,"}, {"sha": "41ab0e9377df6d12445d8c37acbf2b21ece47d8c", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_middle::mir;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n@@ -270,7 +271,7 @@ pub(crate) fn print_evaluated_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<St\n             (_, &ty::Ref(..)) => None,\n             (ConstValue::Scalar(_), &ty::Adt(_, _)) => None,\n             (ConstValue::Scalar(_), _) => {\n-                let const_ = ty::Const::from_value(tcx, val, ty);\n+                let const_ = mir::ConstantKind::from_value(val, ty);\n                 Some(print_const_with_custom_print_scalar(tcx, const_))\n             }\n             _ => None,\n@@ -304,19 +305,18 @@ fn format_integer_with_underscore_sep(num: &str) -> String {\n         .collect()\n }\n \n-fn print_const_with_custom_print_scalar(tcx: TyCtxt<'_>, ct: ty::Const<'_>) -> String {\n+fn print_const_with_custom_print_scalar(tcx: TyCtxt<'_>, ct: mir::ConstantKind<'_>) -> String {\n     // Use a slightly different format for integer types which always shows the actual value.\n     // For all other types, fallback to the original `pretty_print_const`.\n-    match (ct.kind(), ct.ty().kind()) {\n-        (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Uint(ui)) => {\n+    match (ct, ct.ty().kind()) {\n+        (mir::ConstantKind::Val(ConstValue::Scalar(int), _), ty::Uint(ui)) => {\n             format!(\"{}{}\", format_integer_with_underscore_sep(&int.to_string()), ui.name_str())\n         }\n-        (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Int(i)) => {\n+        (mir::ConstantKind::Val(ConstValue::Scalar(int), _), ty::Int(i)) => {\n             let ty = tcx.lift(ct.ty()).unwrap();\n             let size = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size;\n             let data = int.assert_bits(size);\n             let sign_extended_data = size.sign_extend(data) as i128;\n-\n             format!(\n                 \"{}{}\",\n                 format_integer_with_underscore_sep(&sign_extended_data.to_string()),"}, {"sha": "60fb06d409c490b86d2ec556382a20016fde0cdd", "filename": "src/test/debuginfo/function-names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fdebuginfo%2Ffunction-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fdebuginfo%2Ffunction-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-names.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -37,7 +37,7 @@\n // Const generic parameter\n // gdb-command:info functions -q function_names::const_generic_fn.*\n // gdb-check:[...]static fn function_names::const_generic_fn_bool<false>();\n-// gdb-check:[...]static fn function_names::const_generic_fn_non_int<{CONST#3fcd7c34c1555be6}>();\n+// gdb-check:[...]static fn function_names::const_generic_fn_non_int<{CONST#6348c650c7b26618}>();\n // gdb-check:[...]static fn function_names::const_generic_fn_signed_int<-7>();\n // gdb-check:[...]static fn function_names::const_generic_fn_unsigned_int<14>();\n \n@@ -76,7 +76,7 @@\n // Const generic parameter\n // cdb-command:x a!function_names::const_generic_fn*\n // cdb-check:[...] a!function_names::const_generic_fn_bool<false> (void)\n-// cdb-check:[...] a!function_names::const_generic_fn_non_int<CONST$3fcd7c34c1555be6> (void)\n+// cdb-check:[...] a!function_names::const_generic_fn_non_int<CONST$6348c650c7b26618> (void)\n // cdb-check:[...] a!function_names::const_generic_fn_unsigned_int<14> (void)\n // cdb-check:[...] a!function_names::const_generic_fn_signed_int<-7> (void)\n "}, {"sha": "806c84152598f7007c7d751a2708ec33b0f4393c", "filename": "src/test/incremental/issue-54242.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fincremental%2Fissue-54242.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fincremental%2Fissue-54242.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-54242.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -14,7 +14,7 @@ impl Tr for str {\n     type Arr = [u8; 8];\n     #[cfg(cfail)]\n     type Arr = [u8; Self::C];\n-    //[cfail]~^ ERROR cycle detected when simplifying constant\n+    //[cfail]~^ ERROR cycle detected when evaluating type-level constant\n }\n \n fn main() {}"}, {"sha": "432aac9ccdfbb5f692e8aaec5b670055afe71dc3", "filename": "src/test/mir-opt/const_allocation2.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -21,41 +21,41 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 8, align: 4) {\n-    \u257e\u2500alloc28\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+    \u257e\u2500alloc22\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc28 (size: 48, align: 4) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc13\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc18\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc26\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+alloc22 (size: 48, align: 4) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc9\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc14\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc20\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n-alloc13 (size: 0, align: 4) {}\n+alloc9 (size: 0, align: 4) {}\n \n-alloc18 (size: 8, align: 4) {\n-    \u257e\u2500alloc16\u2500\u257c \u257e\u2500alloc17\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc14 (size: 8, align: 4) {\n+    \u257e\u2500alloc12\u2500\u257c \u257e\u2500alloc13\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc16 (size: 1, align: 1) {\n+alloc12 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc17 (size: 1, align: 1) {\n+alloc13 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc26 (size: 12, align: 4) {\n-    \u257e\u2500a22+0x3\u2500\u257c \u257e\u2500alloc23\u2500\u257c \u257e\u2500a25+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc20 (size: 12, align: 4) {\n+    \u257e\u2500a17+0x3\u2500\u257c \u257e\u2500alloc18\u2500\u257c \u257e\u2500a19+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc22 (size: 4, align: 1) {\n+alloc17 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc23 (size: 1, align: 1) {\n+alloc18 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc25 (size: 4, align: 1) {\n+alloc19 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "e2acd610b80530cf6c0e4909d089c7cd33455a19", "filename": "src/test/mir-opt/const_allocation2.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -21,44 +21,44 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc28\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc22\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc28 (size: 72, align: 8) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc22 (size: 72, align: 8) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc26\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc20\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n-alloc13 (size: 0, align: 8) {}\n+alloc9 (size: 0, align: 8) {}\n \n-alloc18 (size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc16\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc17\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc14 (size: 16, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc16 (size: 1, align: 1) {\n+alloc12 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc17 (size: 1, align: 1) {\n+alloc13 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc26 (size: 24, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc22+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc23\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc25+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc20 (size: 24, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc17+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc19+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc22 (size: 4, align: 1) {\n+alloc17 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc23 (size: 1, align: 1) {\n+alloc18 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc25 (size: 4, align: 1) {\n+alloc19 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "5b2b9f7e3a9ff7c67c8a0f232f97d72ccbf46bb4", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.32bit.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -36,7 +36,7 @@\n +         StorageLive(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         _7 = &mut (*_5);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         StorageLive(_8);                 // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         _8 = const alloc::raw_vec::RawVec::<u32> { ptr: Unique::<u32> { pointer: NonNull::<u32> { pointer: {0x4 as *const u32} }, _marker: PhantomData::<u32> }, cap: 0_usize, alloc: std::alloc::Global }; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         _8 = const alloc::raw_vec::RawVec::<u32>::NEW; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n                                            // mir::Constant\n -                                          // + span: $DIR/inline-into-box-place.rs:8:33: 8:41\n -                                          // + user_ty: UserType(1)\n@@ -46,7 +46,7 @@\n -     bb2: {\n +                                          // + span: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +                                          // + user_ty: UserType(0)\n-+                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Value(ByRef(..)) }\n++                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Unevaluated(alloc::raw_vec::RawVec::<T>::NEW, [u32], None) }\n +         Deinit((*_7));                   // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +         ((*_7).0: alloc::raw_vec::RawVec<u32>) = move _8; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +         ((*_7).1: usize) = const 0_usize; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL"}, {"sha": "5b2b9f7e3a9ff7c67c8a0f232f97d72ccbf46bb4", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.64bit.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -36,7 +36,7 @@\n +         StorageLive(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         _7 = &mut (*_5);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         StorageLive(_8);                 // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         _8 = const alloc::raw_vec::RawVec::<u32> { ptr: Unique::<u32> { pointer: NonNull::<u32> { pointer: {0x4 as *const u32} }, _marker: PhantomData::<u32> }, cap: 0_usize, alloc: std::alloc::Global }; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         _8 = const alloc::raw_vec::RawVec::<u32>::NEW; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n                                            // mir::Constant\n -                                          // + span: $DIR/inline-into-box-place.rs:8:33: 8:41\n -                                          // + user_ty: UserType(1)\n@@ -46,7 +46,7 @@\n -     bb2: {\n +                                          // + span: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +                                          // + user_ty: UserType(0)\n-+                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Value(ByRef(..)) }\n++                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Unevaluated(alloc::raw_vec::RawVec::<T>::NEW, [u32], None) }\n +         Deinit((*_7));                   // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +         ((*_7).0: alloc::raw_vec::RawVec<u32>) = move _8; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +         ((*_7).1: usize) = const 0_usize; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL"}, {"sha": "7d9e012bb296e7388bc75953206c27779e209aa8", "filename": "src/test/mir-opt/nll/region_subtyping_basic.main.nll.0.32bit.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.32bit.mir?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -23,7 +23,7 @@\n |\n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/region-subtyping-basic.rs:16:11: 16:11\n-    let mut _1: [usize; Const { ty: usize, kind: Value(Scalar(0x00000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+    let mut _1: [usize; Const { ty: usize, kind: Value(Leaf(0x00000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n     let _3: usize;                       // in scope 0 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n     let mut _4: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n     let mut _5: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n@@ -63,7 +63,7 @@ fn main() -> () {\n         FakeRead(ForLet(None), _6);      // bb1[4]: scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n         StorageLive(_7);                 // bb1[5]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n         _7 = const ConstValue(Scalar(0x01): bool); // bb1[6]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n-        switchInt(move _7) -> [Const(Value(Scalar(0x00)): bool): bb4, otherwise: bb2]; // bb1[7]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+        switchInt(move _7) -> [ConstValue(Scalar(0x00): bool): bb4, otherwise: bb2]; // bb1[7]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n     }\n \n     bb2: {"}, {"sha": "c555e0441f42325c4e8654b8f387c360d6e89eaf", "filename": "src/test/mir-opt/nll/region_subtyping_basic.main.nll.0.64bit.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.64bit.mir?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -23,7 +23,7 @@\n |\n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/region-subtyping-basic.rs:16:11: 16:11\n-    let mut _1: [usize; Const { ty: usize, kind: Value(Scalar(0x0000000000000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+    let mut _1: [usize; Const { ty: usize, kind: Value(Leaf(0x0000000000000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n     let _3: usize;                       // in scope 0 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n     let mut _4: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n     let mut _5: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n@@ -63,7 +63,7 @@ fn main() -> () {\n         FakeRead(ForLet(None), _6);      // bb1[4]: scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n         StorageLive(_7);                 // bb1[5]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n         _7 = const ConstValue(Scalar(0x01): bool); // bb1[6]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n-        switchInt(move _7) -> [Const(Value(Scalar(0x00)): bool): bb4, otherwise: bb2]; // bb1[7]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+        switchInt(move _7) -> [ConstValue(Scalar(0x00): bool): bb4, otherwise: bb2]; // bb1[7]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n     }\n \n     bb2: {"}, {"sha": "a1c6840a0f1b364e3f80035f1ce6212e94854f7d", "filename": "src/test/ui/associated-consts/defaults-cyclic-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-cyclic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-cyclic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-cyclic-fail.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,9 +1,9 @@\n // build-fail\n-//~^ ERROR cycle detected when normalizing `<() as Tr>::A` [E0391]\n \n // Cyclic assoc. const defaults don't error unless *used*\n trait Tr {\n     const A: u8 = Self::B;\n+    //~^ cycle detected when const-evaluating + checking `Tr::A`\n \n     const B: u8 = Self::A;\n }"}, {"sha": "c4cd9c2a49fd7562bee5c160cdba4580ecec8a5c", "filename": "src/test/ui/associated-consts/defaults-cyclic-fail.stderr", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-cyclic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-cyclic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-cyclic-fail.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,42 +1,20 @@\n-error[E0391]: cycle detected when normalizing `<() as Tr>::A`\n-   |\n-note: ...which requires simplifying constant for the type system `Tr::A`...\n-  --> $DIR/defaults-cyclic-fail.rs:6:5\n-   |\n-LL |     const A: u8 = Self::B;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `Tr::A`...\n-  --> $DIR/defaults-cyclic-fail.rs:6:5\n-   |\n-LL |     const A: u8 = Self::B;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires const-evaluating + checking `Tr::A`...\n-  --> $DIR/defaults-cyclic-fail.rs:6:5\n+error[E0391]: cycle detected when const-evaluating + checking `Tr::A`\n+  --> $DIR/defaults-cyclic-fail.rs:5:5\n    |\n LL |     const A: u8 = Self::B;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `<() as Tr>::B`...\n-note: ...which requires simplifying constant for the type system `Tr::B`...\n-  --> $DIR/defaults-cyclic-fail.rs:8:5\n    |\n-LL |     const B: u8 = Self::A;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `Tr::B`...\n-  --> $DIR/defaults-cyclic-fail.rs:8:5\n-   |\n-LL |     const B: u8 = Self::A;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `Tr::B`...\n   --> $DIR/defaults-cyclic-fail.rs:8:5\n    |\n LL |     const B: u8 = Self::A;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires normalizing `<() as Tr>::A`, completing the cycle\n+   = note: ...which again requires const-evaluating + checking `Tr::A`, completing the cycle\n note: cycle used when const-evaluating + checking `main::promoted[1]`\n-  --> $DIR/defaults-cyclic-fail.rs:14:1\n+  --> $DIR/defaults-cyclic-fail.rs:16:16\n    |\n-LL | fn main() {\n-   | ^^^^^^^^^\n+LL |     assert_eq!(<() as Tr>::A, 0);\n+   |                ^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b4dc730d8631fbb7ad779db2817007094298baf1", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-impl.stderr", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,16 +1,10 @@\n error[E0391]: cycle detected when elaborating drops for `<impl at $DIR/issue-24949-assoc-const-static-recursion-impl.rs:11:1: 13:2>::BAR`\n-  --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:12:5\n+  --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:12:22\n    |\n LL |     const BAR: u32 = IMPL_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: ...which requires normalizing `IMPL_REF_BAR`...\n-note: ...which requires simplifying constant for the type system `IMPL_REF_BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:7:1\n+   |                      ^^^^^^^^^^^^\n    |\n-LL | const IMPL_REF_BAR: u32 = GlobalImplRef::BAR;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `IMPL_REF_BAR`...\n+note: ...which requires const-evaluating + checking `IMPL_REF_BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:7:1\n    |\n LL | const IMPL_REF_BAR: u32 = GlobalImplRef::BAR;\n@@ -20,17 +14,6 @@ note: ...which requires const-evaluating + checking `IMPL_REF_BAR`...\n    |\n LL | const IMPL_REF_BAR: u32 = GlobalImplRef::BAR;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `<impl at $DIR/issue-24949-assoc-const-static-recursion-impl.rs:11:1: 13:2>::BAR`...\n-note: ...which requires simplifying constant for the type system `<impl at $DIR/issue-24949-assoc-const-static-recursion-impl.rs:11:1: 13:2>::BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:12:5\n-   |\n-LL |     const BAR: u32 = IMPL_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `<impl at $DIR/issue-24949-assoc-const-static-recursion-impl.rs:11:1: 13:2>::BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:12:5\n-   |\n-LL |     const BAR: u32 = IMPL_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `<impl at $DIR/issue-24949-assoc-const-static-recursion-impl.rs:11:1: 13:2>::BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:12:5\n    |"}, {"sha": "97ede6ad388f26a646a6d0621476eac43c6833d3", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-trait-default.stderr", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,16 +1,10 @@\n error[E0391]: cycle detected when elaborating drops for `FooDefault::BAR`\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:8:5\n+  --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:8:22\n    |\n LL |     const BAR: u32 = DEFAULT_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: ...which requires normalizing `DEFAULT_REF_BAR`...\n-note: ...which requires simplifying constant for the type system `DEFAULT_REF_BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:11:1\n+   |                      ^^^^^^^^^^^^^^^\n    |\n-LL | const DEFAULT_REF_BAR: u32 = <GlobalDefaultRef>::BAR;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `DEFAULT_REF_BAR`...\n+note: ...which requires const-evaluating + checking `DEFAULT_REF_BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:11:1\n    |\n LL | const DEFAULT_REF_BAR: u32 = <GlobalDefaultRef>::BAR;\n@@ -20,17 +14,6 @@ note: ...which requires const-evaluating + checking `DEFAULT_REF_BAR`...\n    |\n LL | const DEFAULT_REF_BAR: u32 = <GlobalDefaultRef>::BAR;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `<GlobalDefaultRef as FooDefault>::BAR`...\n-note: ...which requires simplifying constant for the type system `FooDefault::BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:8:5\n-   |\n-LL |     const BAR: u32 = DEFAULT_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `FooDefault::BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:8:5\n-   |\n-LL |     const BAR: u32 = DEFAULT_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `FooDefault::BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:8:5\n    |"}, {"sha": "bd97c31229ecc5a6edf18ff6b78be2759ee0bc34", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-trait.stderr", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,16 +1,10 @@\n error[E0391]: cycle detected when elaborating drops for `<impl at $DIR/issue-24949-assoc-const-static-recursion-trait.rs:11:1: 13:2>::BAR`\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:12:5\n+  --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:12:22\n    |\n LL |     const BAR: u32 = TRAIT_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: ...which requires normalizing `TRAIT_REF_BAR`...\n-note: ...which requires simplifying constant for the type system `TRAIT_REF_BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:7:1\n+   |                      ^^^^^^^^^^^^^\n    |\n-LL | const TRAIT_REF_BAR: u32 = <GlobalTraitRef>::BAR;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `TRAIT_REF_BAR`...\n+note: ...which requires const-evaluating + checking `TRAIT_REF_BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:7:1\n    |\n LL | const TRAIT_REF_BAR: u32 = <GlobalTraitRef>::BAR;\n@@ -20,17 +14,6 @@ note: ...which requires const-evaluating + checking `TRAIT_REF_BAR`...\n    |\n LL | const TRAIT_REF_BAR: u32 = <GlobalTraitRef>::BAR;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `<GlobalTraitRef as Foo>::BAR`...\n-note: ...which requires simplifying constant for the type system `<impl at $DIR/issue-24949-assoc-const-static-recursion-trait.rs:11:1: 13:2>::BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:12:5\n-   |\n-LL |     const BAR: u32 = TRAIT_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `<impl at $DIR/issue-24949-assoc-const-static-recursion-trait.rs:11:1: 13:2>::BAR`...\n-  --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:12:5\n-   |\n-LL |     const BAR: u32 = TRAIT_REF_BAR;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `<impl at $DIR/issue-24949-assoc-const-static-recursion-trait.rs:11:1: 13:2>::BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:12:5\n    |"}, {"sha": "9b60612037dd6e76d9792b3e58fe201d8cb592f6", "filename": "src/test/ui/borrowck/issue-81899.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -2,6 +2,8 @@\n // The `panic!()` below is important to trigger the fixed ICE.\n \n const _CONST: &[u8] = &f(&[], |_| {});\n+//~^ ERROR any use of this value\n+//~| WARNING this was previously\n \n const fn f<F>(_: &[u8], _: F) -> &[u8]\n where"}, {"sha": "92ebd5a220d904d0f88db711d9d60745ab9e44e4", "filename": "src/test/ui/borrowck/issue-81899.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,17 +1,29 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/issue-81899.rs:10:5\n+  --> $DIR/issue-81899.rs:12:5\n    |\n LL | const _CONST: &[u8] = &f(&[], |_| {});\n    |                        -------------- inside `_CONST` at $DIR/issue-81899.rs:4:24\n ...\n LL |     panic!()\n    |     ^^^^^^^^\n    |     |\n-   |     the evaluated program panicked at 'explicit panic', $DIR/issue-81899.rs:10:5\n+   |     the evaluated program panicked at 'explicit panic', $DIR/issue-81899.rs:12:5\n    |     inside `f::<[closure@$DIR/issue-81899.rs:4:31: 4:37]>` at $SRC_DIR/std/src/panic.rs:LL:COL\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error\n+error: any use of this value will cause an error\n+  --> $DIR/issue-81899.rs:4:23\n+   |\n+LL | const _CONST: &[u8] = &f(&[], |_| {});\n+   | ----------------------^^^^^^^^^^^^^^^-\n+   |                       |\n+   |                       referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "7618d001e86eecf3e4813714c05fd86d7f333cc8", "filename": "src/test/ui/borrowck/issue-88434-minimal-example.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,6 +1,8 @@\n // Regression test related to issue 88434\n \n const _CONST: &() = &f(&|_| {});\n+//~^ ERROR any use of this value\n+//~| WARNING this was previously\n \n const fn f<F>(_: &F)\n where"}, {"sha": "d46cd862e34aad2278e54e773e014f12917d28f8", "filename": "src/test/ui/borrowck/issue-88434-minimal-example.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,17 +1,29 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/issue-88434-minimal-example.rs:9:5\n+  --> $DIR/issue-88434-minimal-example.rs:11:5\n    |\n LL | const _CONST: &() = &f(&|_| {});\n    |                      ---------- inside `_CONST` at $DIR/issue-88434-minimal-example.rs:3:22\n ...\n LL |     panic!()\n    |     ^^^^^^^^\n    |     |\n-   |     the evaluated program panicked at 'explicit panic', $DIR/issue-88434-minimal-example.rs:9:5\n+   |     the evaluated program panicked at 'explicit panic', $DIR/issue-88434-minimal-example.rs:11:5\n    |     inside `f::<[closure@$DIR/issue-88434-minimal-example.rs:3:25: 3:31]>` at $SRC_DIR/std/src/panic.rs:LL:COL\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error\n+error: any use of this value will cause an error\n+  --> $DIR/issue-88434-minimal-example.rs:3:21\n+   |\n+LL | const _CONST: &() = &f(&|_| {});\n+   | --------------------^^^^^^^^^^^-\n+   |                     |\n+   |                     referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "b1fc1615ece7728e0c8eb4c76e18e9206a5b2cf3", "filename": "src/test/ui/borrowck/issue-88434-removal-index-should-be-less.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,6 +1,8 @@\n // Regression test for issue 88434\n \n const _CONST: &[u8] = &f(&[], |_| {});\n+//~^ ERROR any use of this value will cause an error\n+//~| WARNING this was previously\n \n const fn f<F>(_: &[u8], _: F) -> &[u8]\n where"}, {"sha": "e6b07aba74d426cdd7bc3c7705db522ae2fbc609", "filename": "src/test/ui/borrowck/issue-88434-removal-index-should-be-less.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,17 +1,29 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/issue-88434-removal-index-should-be-less.rs:9:5\n+  --> $DIR/issue-88434-removal-index-should-be-less.rs:11:5\n    |\n LL | const _CONST: &[u8] = &f(&[], |_| {});\n    |                        -------------- inside `_CONST` at $DIR/issue-88434-removal-index-should-be-less.rs:3:24\n ...\n LL |     panic!()\n    |     ^^^^^^^^\n    |     |\n-   |     the evaluated program panicked at 'explicit panic', $DIR/issue-88434-removal-index-should-be-less.rs:9:5\n+   |     the evaluated program panicked at 'explicit panic', $DIR/issue-88434-removal-index-should-be-less.rs:11:5\n    |     inside `f::<[closure@$DIR/issue-88434-removal-index-should-be-less.rs:3:31: 3:37]>` at $SRC_DIR/std/src/panic.rs:LL:COL\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error\n+error: any use of this value will cause an error\n+  --> $DIR/issue-88434-removal-index-should-be-less.rs:3:23\n+   |\n+LL | const _CONST: &[u8] = &f(&[], |_| {});\n+   | ----------------------^^^^^^^^^^^^^^^-\n+   |                       |\n+   |                       referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "f0b9035357d82fcfb9d49eb0883ff4f583e6e16b", "filename": "src/test/ui/const-generics/different_generic_args_array.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args_array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args_array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args_array.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/different_generic_args_array.rs:9:9\n    |\n LL |     x = Const::<{ [4] }> {};\n-   |         ^^^^^^^^^^^^^^^^^^^ expected `3_usize`, found `4_usize`\n+   |         ^^^^^^^^^^^^^^^^^^^ expected `[3_usize]`, found `[4_usize]`\n    |\n    = note: expected struct `Const<[3_usize]>`\n               found struct `Const<[4_usize]>`"}, {"sha": "98931a3936f52eb3fe2f4bab4715000d561d5ce8", "filename": "src/test/ui/const-generics/issues/issue-83765.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -10,7 +10,11 @@ note: ...which requires checking if `TensorDimension` fulfills its obligations..\n LL | trait TensorDimension {\n    | ^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which again requires resolving instance `<LazyUpdim<T, { T::DIM }, DIM> as TensorDimension>::DIM`, completing the cycle\n-   = note: cycle used when normalizing `<LazyUpdim<T, { T::DIM }, DIM> as TensorDimension>::DIM`\n+note: cycle used when checking if `TensorDimension` fulfills its obligations\n+  --> $DIR/issue-83765.rs:4:1\n+   |\n+LL | trait TensorDimension {\n+   | ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "52b173c4d04a8107dc522f71a8424386deb859db", "filename": "src/test/ui/const-ptr/out_of_bounds_read.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -4,7 +4,7 @@ error[E0080]: evaluation of constant value failed\n LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         memory access failed: alloc7 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   |         memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n   ::: $DIR/out_of_bounds_read.rs:12:33\n@@ -18,7 +18,7 @@ error[E0080]: evaluation of constant value failed\n LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         memory access failed: alloc7 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   |         memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n@@ -37,7 +37,7 @@ error[E0080]: evaluation of constant value failed\n LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         memory access failed: alloc7 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   |         memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL"}, {"sha": "c9460498951fda8a90aeacad17250685f733c2ef", "filename": "src/test/ui/consts/const-eval/const-eval-query-stack.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,5 +1,4 @@\n // compile-flags: -Ztreat-err-as-bug=2\n-//~^ ERROR 1:1: 1:1: ty::ConstKind::Error constructed but no error reported\n // build-fail\n // failure-status: 101\n // rustc-env:RUST_BACKTRACE=1\n@@ -23,5 +22,7 @@ const X: i32 = 1 / 0; //~WARN any use of this value will cause an error\n fn main() {\n     let x: &'static i32 = &X;\n     //~^ ERROR evaluation of constant value failed\n+    //~| ERROR erroneous constant used\n+    //~| WARNING this was previously accepted by the compiler\n     println!(\"x={}\", x);\n }"}, {"sha": "b74d5a2722bd8b2e75051d335e4941f0451cdddf", "filename": "src/test/ui/consts/const-eval/const-eval-query-stack.stderr", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,27 +1,37 @@\n warning: any use of this value will cause an error\n-  --> $DIR/const-eval-query-stack.rs:20:16\n+  --> $DIR/const-eval-query-stack.rs:19:16\n    |\n LL | const X: i32 = 1 / 0;\n    | ---------------^^^^^-\n    |                |\n    |                attempt to divide `1_i32` by zero\n    |\n note: the lint level is defined here\n-  --> $DIR/const-eval-query-stack.rs:19:8\n+  --> $DIR/const-eval-query-stack.rs:18:8\n    |\n LL | #[warn(const_err)]\n    |        ^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/const-eval-query-stack.rs:24:28\n+  --> $DIR/const-eval-query-stack.rs:23:28\n    |\n LL |     let x: &'static i32 = &X;\n    |                            ^ referenced constant has errors\n+\n+error: erroneous constant used\n+  --> $DIR/const-eval-query-stack.rs:23:27\n+   |\n+LL |     let x: &'static i32 = &X;\n+   |                           ^^ referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n query stack during panic:\n-#0 [try_normalize_mir_const_after_erasing_regions] normalizing `main::promoted[1]`\n-#1 [mir_drops_elaborated_and_const_checked] elaborating drops for `main`\n-#2 [optimized_mir] optimizing MIR for `main`\n-#3 [collect_and_partition_mono_items] collect_and_partition_mono_items\n+#0 [mir_drops_elaborated_and_const_checked] elaborating drops for `main`\n+#1 [optimized_mir] optimizing MIR for `main`\n+#2 [collect_and_partition_mono_items] collect_and_partition_mono_items\n end of query stack"}, {"sha": "a78cff11589fd35ece7a82a658a7cc0900f5d165", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.32bit.stderr", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -149,8 +149,19 @@ LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n                \u257e\u2500allocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n+error: any use of this value will cause an error\n+  --> $DIR/ub-wide-ptr.rs:87:40\n+   |\n+LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n+   | ---------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |                                        |\n+   |                                        referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:93:1\n+  --> $DIR/ub-wide-ptr.rs:95:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.0: encountered 0x03, but expected a boolean\n@@ -160,8 +171,19 @@ LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3\n                \u257eallocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n+error: any use of this value will cause an error\n+  --> $DIR/ub-wide-ptr.rs:95:42\n+   |\n+LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n+   | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |                                          |\n+   |                                          referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:96:1\n+  --> $DIR/ub-wide-ptr.rs:100:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.1[0]: encountered 0x03, but expected a boolean\n@@ -171,8 +193,19 @@ LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::tran\n                \u257eallocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n+error: any use of this value will cause an error\n+  --> $DIR/ub-wide-ptr.rs:100:42\n+   |\n+LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+   | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |                                          |\n+   |                                          referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:103:1\n+  --> $DIR/ub-wide-ptr.rs:109:1\n    |\n LL | / const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n LL | |\n@@ -187,7 +220,7 @@ LL | | };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:111:1\n+  --> $DIR/ub-wide-ptr.rs:117:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered too small vtable\n@@ -198,7 +231,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:114:1\n+  --> $DIR/ub-wide-ptr.rs:120:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered too small vtable\n@@ -209,7 +242,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:117:1\n+  --> $DIR/ub-wide-ptr.rs:123:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered dangling vtable pointer in wide pointer\n@@ -220,7 +253,7 @@ LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:119:1\n+  --> $DIR/ub-wide-ptr.rs:125:1\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned vtable pointer in wide pointer\n@@ -231,7 +264,7 @@ LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:121:1\n+  --> $DIR/ub-wide-ptr.rs:127:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -242,7 +275,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:123:1\n+  --> $DIR/ub-wide-ptr.rs:129:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -253,7 +286,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:125:1\n+  --> $DIR/ub-wide-ptr.rs:131:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -264,7 +297,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::trans\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:129:1\n+  --> $DIR/ub-wide-ptr.rs:135:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n@@ -275,7 +308,7 @@ LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_,\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:133:1\n+  --> $DIR/ub-wide-ptr.rs:139:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling vtable pointer in wide pointer\n@@ -286,7 +319,7 @@ LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:135:1\n+  --> $DIR/ub-wide-ptr.rs:141:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered too small vtable\n@@ -297,17 +330,17 @@ LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transm\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:141:5\n+  --> $DIR/ub-wide-ptr.rs:147:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: null pointer is not a valid pointer\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:145:5\n+  --> $DIR/ub-wide-ptr.rs:151:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: allocN has size N, so pointer to 12 bytes starting at offset N is out-of-bounds\n \n-error: aborting due to 29 previous errors\n+error: aborting due to 32 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "69a61d9caede632e8ffd78e55d7370fc16e11d14", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.64bit.stderr", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -149,8 +149,19 @@ LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n+error: any use of this value will cause an error\n+  --> $DIR/ub-wide-ptr.rs:87:40\n+   |\n+LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n+   | ---------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |                                        |\n+   |                                        referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:93:1\n+  --> $DIR/ub-wide-ptr.rs:95:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.0: encountered 0x03, but expected a boolean\n@@ -160,8 +171,19 @@ LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n+error: any use of this value will cause an error\n+  --> $DIR/ub-wide-ptr.rs:95:42\n+   |\n+LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n+   | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |                                          |\n+   |                                          referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:96:1\n+  --> $DIR/ub-wide-ptr.rs:100:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.1[0]: encountered 0x03, but expected a boolean\n@@ -171,8 +193,19 @@ LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::tran\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n+error: any use of this value will cause an error\n+  --> $DIR/ub-wide-ptr.rs:100:42\n+   |\n+LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+   | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |                                          |\n+   |                                          referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:103:1\n+  --> $DIR/ub-wide-ptr.rs:109:1\n    |\n LL | / const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n LL | |\n@@ -187,7 +220,7 @@ LL | | };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:111:1\n+  --> $DIR/ub-wide-ptr.rs:117:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered too small vtable\n@@ -198,7 +231,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:114:1\n+  --> $DIR/ub-wide-ptr.rs:120:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered too small vtable\n@@ -209,7 +242,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:117:1\n+  --> $DIR/ub-wide-ptr.rs:123:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered dangling vtable pointer in wide pointer\n@@ -220,7 +253,7 @@ LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:119:1\n+  --> $DIR/ub-wide-ptr.rs:125:1\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned vtable pointer in wide pointer\n@@ -231,7 +264,7 @@ LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:121:1\n+  --> $DIR/ub-wide-ptr.rs:127:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -242,7 +275,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:123:1\n+  --> $DIR/ub-wide-ptr.rs:129:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -253,7 +286,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:125:1\n+  --> $DIR/ub-wide-ptr.rs:131:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -264,7 +297,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::trans\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:129:1\n+  --> $DIR/ub-wide-ptr.rs:135:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n@@ -275,7 +308,7 @@ LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_,\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:133:1\n+  --> $DIR/ub-wide-ptr.rs:139:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling vtable pointer in wide pointer\n@@ -286,7 +319,7 @@ LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:135:1\n+  --> $DIR/ub-wide-ptr.rs:141:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered too small vtable\n@@ -297,17 +330,17 @@ LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transm\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:141:5\n+  --> $DIR/ub-wide-ptr.rs:147:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: null pointer is not a valid pointer\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:145:5\n+  --> $DIR/ub-wide-ptr.rs:151:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: allocN has size N, so pointer to 24 bytes starting at offset N is out-of-bounds\n \n-error: aborting due to 29 previous errors\n+error: aborting due to 32 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "f2e5738f88c9f7ffbd75280bf1046a290be0cdfc", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -86,15 +86,21 @@ const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n // bad data *inside* the slice\n const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n //~^ ERROR it is undefined behavior to use this value\n+//~| ERROR any use of this value will cause an error\n+//~| WARNING this was previously accepted\n \n // good MySliceBool\n const MYSLICE_GOOD: &MySliceBool = &MySlice(true, [false]);\n // bad: sized field is not okay\n const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n //~^ ERROR it is undefined behavior to use this value\n+//~| ERROR any use of this value will cause an error\n+//~| WARNING this was previously accepted\n // bad: unsized part is not okay\n const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n //~^ ERROR it is undefined behavior to use this value\n+//~| ERROR any use of this value will cause an error\n+//~| WARNING this was previously accepted\n \n // # raw slice\n const RAW_SLICE_VALID: *const [u8] = unsafe { mem::transmute((&42u8, 1usize)) }; // ok"}, {"sha": "b156ded4a6c2afc44a48ab82e1cccaff1ca17385", "filename": "src/test/ui/consts/const-float-bits-reject-conv.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -28,14 +28,22 @@ fn f32() {\n     const MASKED_NAN2: u32 = f32::NAN.to_bits() ^ 0x0055_5555;\n \n     const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+    //~^ ERROR any use of this value will cause an error\n+    //~| WARNING this was previously accepted\n     const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+    //~^ ERROR any use of this value will cause an error\n+    //~| WARNING this was previously accepted\n \n     // LLVM does not guarantee that loads and stores of NaNs preserve their exact bit pattern.\n     // In practice, this seems to only cause a problem on x86, since the most widely used calling\n     // convention mandates that floating point values are returned on the x87 FPU stack. See #73328.\n     if !cfg!(target_arch = \"x86\") {\n         const_assert!(f32::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+        //~^ ERROR any use of this value will cause an error\n+        //~| WARNING this was previously accepted\n         const_assert!(f32::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+        //~^ ERROR any use of this value will cause an error\n+        //~| WARNING this was previously accepted\n     }\n }\n \n@@ -47,12 +55,20 @@ fn f64() {\n     const MASKED_NAN2: u64 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n \n     const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+    //~^ ERROR any use of this value will cause an error\n+    //~| WARNING this was previously accepted\n     const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+    //~^ ERROR any use of this value will cause an error\n+    //~| WARNING this was previously accepted\n \n     // See comment above.\n     if !cfg!(target_arch = \"x86\") {\n         const_assert!(f64::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+        //~^ ERROR any use of this value will cause an error\n+        //~| WARNING this was previously accepted\n         const_assert!(f64::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+        //~^ ERROR any use of this value will cause an error\n+        //~| WARNING this was previously accepted\n     }\n }\n "}, {"sha": "f3fd098e848a20476875e5491fb41ed7f0eeb7c5", "filename": "src/test/ui/consts/const-float-bits-reject-conv.stderr", "status": "modified", "additions": 102, "deletions": 5, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -56,6 +56,55 @@ LL |     const MASKED_NAN2: u32 = f32::NAN.to_bits() ^ 0x0055_5555;\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:30:34\n+   |\n+LL |             const _: () = assert!($a);\n+   |             --------------------------\n+...\n+LL |     const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+   |                                  ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:33:34\n+   |\n+LL |             const _: () = assert!($a);\n+   |             --------------------------\n+...\n+LL |     const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+   |                                  ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:41:38\n+   |\n+LL |             const _: () = assert!($a == $b);\n+   |             --------------------------------\n+...\n+LL |         const_assert!(f32::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+   |                                      ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:44:38\n+   |\n+LL |             const _: () = assert!($a == $b);\n+   |             --------------------------------\n+...\n+LL |         const_assert!(f32::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+   |                                      ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/num/f64.rs:LL:COL\n    |\n@@ -78,10 +127,10 @@ LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n LL |     called_in_const.call_once(arg)\n    |     ------------------------------ inside `const_eval_select::<(f64,), fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64}, [closure@core::f64::<impl f64>::to_bits::{closure#0}], u64>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n    |\n-  ::: $DIR/const-float-bits-reject-conv.rs:46:30\n+  ::: $DIR/const-float-bits-reject-conv.rs:54:30\n    |\n LL |     const MASKED_NAN1: u64 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n-   |                              ------------------ inside `f64::MASKED_NAN1` at $DIR/const-float-bits-reject-conv.rs:46:30\n+   |                              ------------------ inside `f64::MASKED_NAN1` at $DIR/const-float-bits-reject-conv.rs:54:30\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n@@ -107,13 +156,61 @@ LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n LL |     called_in_const.call_once(arg)\n    |     ------------------------------ inside `const_eval_select::<(f64,), fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64}, [closure@core::f64::<impl f64>::to_bits::{closure#0}], u64>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n    |\n-  ::: $DIR/const-float-bits-reject-conv.rs:47:30\n+  ::: $DIR/const-float-bits-reject-conv.rs:55:30\n    |\n LL |     const MASKED_NAN2: u64 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n-   |                              ------------------ inside `f64::MASKED_NAN2` at $DIR/const-float-bits-reject-conv.rs:47:30\n+   |                              ------------------ inside `f64::MASKED_NAN2` at $DIR/const-float-bits-reject-conv.rs:55:30\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 4 previous errors\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:57:34\n+   |\n+LL |             const _: () = assert!($a);\n+   |             --------------------------\n+...\n+LL |     const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+   |                                  ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:60:34\n+   |\n+LL |             const _: () = assert!($a);\n+   |             --------------------------\n+...\n+LL |     const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+   |                                  ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:66:38\n+   |\n+LL |             const _: () = assert!($a == $b);\n+   |             --------------------------------\n+...\n+LL |         const_assert!(f64::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+   |                                      ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-float-bits-reject-conv.rs:69:38\n+   |\n+LL |             const _: () = assert!($a == $b);\n+   |             --------------------------------\n+...\n+LL |         const_assert!(f64::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+   |                                      ^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: aborting due to 12 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "6924956bdf706f174ccc7a68c4ed529d30f2ad8c", "filename": "src/test/ui/consts/const-integer-bool-ops.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-integer-bool-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-integer-bool-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-integer-bool-ops.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -6,6 +6,7 @@ const X: usize = 42 && 39;\n //~| ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARR: [i32; X] = [99; 34];\n+//~^ ERROR evaluation of constant value failed\n \n const X1: usize = 42 || 39;\n //~^ ERROR mismatched types\n@@ -15,6 +16,7 @@ const X1: usize = 42 || 39;\n //~| ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARR1: [i32; X1] = [99; 47];\n+//~^ ERROR evaluation of constant value failed\n \n const X2: usize = -42 || -39;\n //~^ ERROR mismatched types\n@@ -24,6 +26,7 @@ const X2: usize = -42 || -39;\n //~| ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARR2: [i32; X2] = [99; 18446744073709551607];\n+//~^ ERROR evaluation of constant value failed\n \n const X3: usize = -42 && -39;\n //~^ ERROR mismatched types\n@@ -33,36 +36,43 @@ const X3: usize = -42 && -39;\n //~| ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARR3: [i32; X3] = [99; 6];\n+//~^ ERROR evaluation of constant value failed\n \n const Y: usize = 42.0 == 42.0;\n //~^ ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARRR: [i32; Y] = [99; 1];\n+//~^ ERROR evaluation of constant value failed\n \n const Y1: usize = 42.0 >= 42.0;\n //~^ ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARRR1: [i32; Y1] = [99; 1];\n+//~^ ERROR evaluation of constant value failed\n \n const Y2: usize = 42.0 <= 42.0;\n //~^ ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARRR2: [i32; Y2] = [99; 1];\n+//~^ ERROR evaluation of constant value failed\n \n const Y3: usize = 42.0 > 42.0;\n //~^ ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARRR3: [i32; Y3] = [99; 0];\n+//~^ ERROR evaluation of constant value failed\n \n const Y4: usize = 42.0 < 42.0;\n //~^ ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARRR4: [i32; Y4] = [99; 0];\n+//~^ ERROR evaluation of constant value failed\n \n const Y5: usize = 42.0 != 42.0;\n //~^ ERROR mismatched types\n //~| expected `usize`, found `bool`\n const ARRR5: [i32; Y5] = [99; 0];\n+//~^ ERROR evaluation of constant value failed\n \n fn main() {\n     let _ = ARR;"}, {"sha": "9001fefd1029f314bc95f9bae48efc75a5baf0cd", "filename": "src/test/ui/consts/const-integer-bool-ops.stderr", "status": "modified", "additions": 78, "deletions": 17, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-integer-bool-ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-integer-bool-ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-integer-bool-ops.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -16,96 +16,157 @@ error[E0308]: mismatched types\n LL | const X: usize = 42 && 39;\n    |                  ^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:8:18\n+   |\n+LL | const ARR: [i32; X] = [99; 34];\n+   |                  ^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:10:19\n+  --> $DIR/const-integer-bool-ops.rs:11:19\n    |\n LL | const X1: usize = 42 || 39;\n    |                   ^^ expected `bool`, found integer\n \n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:10:25\n+  --> $DIR/const-integer-bool-ops.rs:11:25\n    |\n LL | const X1: usize = 42 || 39;\n    |                         ^^ expected `bool`, found integer\n \n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:10:19\n+  --> $DIR/const-integer-bool-ops.rs:11:19\n    |\n LL | const X1: usize = 42 || 39;\n    |                   ^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:18:19\n+   |\n+LL | const ARR1: [i32; X1] = [99; 47];\n+   |                   ^^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:19:19\n+  --> $DIR/const-integer-bool-ops.rs:21:19\n    |\n LL | const X2: usize = -42 || -39;\n    |                   ^^^ expected `bool`, found integer\n \n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:19:26\n+  --> $DIR/const-integer-bool-ops.rs:21:26\n    |\n LL | const X2: usize = -42 || -39;\n    |                          ^^^ expected `bool`, found integer\n \n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:19:19\n+  --> $DIR/const-integer-bool-ops.rs:21:19\n    |\n LL | const X2: usize = -42 || -39;\n    |                   ^^^^^^^^^^ expected `usize`, found `bool`\n \n-error[E0308]: mismatched types\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/const-integer-bool-ops.rs:28:19\n    |\n+LL | const ARR2: [i32; X2] = [99; 18446744073709551607];\n+   |                   ^^ referenced constant has errors\n+\n+error[E0308]: mismatched types\n+  --> $DIR/const-integer-bool-ops.rs:31:19\n+   |\n LL | const X3: usize = -42 && -39;\n    |                   ^^^ expected `bool`, found integer\n \n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:28:26\n+  --> $DIR/const-integer-bool-ops.rs:31:26\n    |\n LL | const X3: usize = -42 && -39;\n    |                          ^^^ expected `bool`, found integer\n \n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:28:19\n+  --> $DIR/const-integer-bool-ops.rs:31:19\n    |\n LL | const X3: usize = -42 && -39;\n    |                   ^^^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:38:19\n+   |\n+LL | const ARR3: [i32; X3] = [99; 6];\n+   |                   ^^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:37:18\n+  --> $DIR/const-integer-bool-ops.rs:41:18\n    |\n LL | const Y: usize = 42.0 == 42.0;\n    |                  ^^^^^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:44:19\n+   |\n+LL | const ARRR: [i32; Y] = [99; 1];\n+   |                   ^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:42:19\n+  --> $DIR/const-integer-bool-ops.rs:47:19\n    |\n LL | const Y1: usize = 42.0 >= 42.0;\n    |                   ^^^^^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:50:20\n+   |\n+LL | const ARRR1: [i32; Y1] = [99; 1];\n+   |                    ^^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:47:19\n+  --> $DIR/const-integer-bool-ops.rs:53:19\n    |\n LL | const Y2: usize = 42.0 <= 42.0;\n    |                   ^^^^^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:56:20\n+   |\n+LL | const ARRR2: [i32; Y2] = [99; 1];\n+   |                    ^^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:52:19\n+  --> $DIR/const-integer-bool-ops.rs:59:19\n    |\n LL | const Y3: usize = 42.0 > 42.0;\n    |                   ^^^^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:62:20\n+   |\n+LL | const ARRR3: [i32; Y3] = [99; 0];\n+   |                    ^^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:57:19\n+  --> $DIR/const-integer-bool-ops.rs:65:19\n    |\n LL | const Y4: usize = 42.0 < 42.0;\n    |                   ^^^^^^^^^^^ expected `usize`, found `bool`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:68:20\n+   |\n+LL | const ARRR4: [i32; Y4] = [99; 0];\n+   |                    ^^ referenced constant has errors\n+\n error[E0308]: mismatched types\n-  --> $DIR/const-integer-bool-ops.rs:62:19\n+  --> $DIR/const-integer-bool-ops.rs:71:19\n    |\n LL | const Y5: usize = 42.0 != 42.0;\n    |                   ^^^^^^^^^^^^ expected `usize`, found `bool`\n \n-error: aborting due to 18 previous errors\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-integer-bool-ops.rs:74:20\n+   |\n+LL | const ARRR5: [i32; Y5] = [99; 0];\n+   |                    ^^ referenced constant has errors\n+\n+error: aborting due to 28 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0080, E0308.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "0f420ae1b6b7cc6689dce73199da330bc194873f", "filename": "src/test/ui/consts/const-mut-refs/issue-76510.32bit.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.32bit.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -19,7 +19,13 @@ error[E0596]: cannot borrow data in a `&` reference as mutable\n LL | const S: &'static mut str = &mut \" hello \";\n    |                             ^^^^^^^^^^^^^^ cannot borrow as mutable\n \n-error: aborting due to 3 previous errors\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-76510.rs:11:70\n+   |\n+LL |         let s = transmute::<(*const u8, usize), &ManuallyDrop<str>>((S.as_ptr(), 3));\n+   |                                                                      ^ referenced constant has errors\n+\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0596, E0658, E0764.\n-For more information about an error, try `rustc --explain E0596`.\n+Some errors have detailed explanations: E0080, E0596, E0658, E0764.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "0f420ae1b6b7cc6689dce73199da330bc194873f", "filename": "src/test/ui/consts/const-mut-refs/issue-76510.64bit.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.64bit.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -19,7 +19,13 @@ error[E0596]: cannot borrow data in a `&` reference as mutable\n LL | const S: &'static mut str = &mut \" hello \";\n    |                             ^^^^^^^^^^^^^^ cannot borrow as mutable\n \n-error: aborting due to 3 previous errors\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-76510.rs:11:70\n+   |\n+LL |         let s = transmute::<(*const u8, usize), &ManuallyDrop<str>>((S.as_ptr(), 3));\n+   |                                                                      ^ referenced constant has errors\n+\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0596, E0658, E0764.\n-For more information about an error, try `rustc --explain E0596`.\n+Some errors have detailed explanations: E0080, E0596, E0658, E0764.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "08cf64ee330db74af03b8bc009206907bd4462bf", "filename": "src/test/ui/consts/const-mut-refs/issue-76510.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -9,6 +9,7 @@ const S: &'static mut str = &mut \" hello \";\n \n const fn trigger() -> [(); unsafe {\n         let s = transmute::<(*const u8, usize), &ManuallyDrop<str>>((S.as_ptr(), 3));\n+        //~^ ERROR evaluation of constant value failed\n         0\n     }] {\n     [(); 0]"}, {"sha": "46f02ce8a45337fc5a44f8fb52056992ea1958e3", "filename": "src/test/ui/consts/const-size_of-cycle.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `Foo::bytes::{constant#0}`\n+error[E0391]: cycle detected when evaluating type-level constant\n   --> $DIR/const-size_of-cycle.rs:4:17\n    |\n LL |     bytes: [u8; std::mem::size_of::<Foo>()]\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: ...which requires simplifying constant for the type system `Foo::bytes::{constant#0}`...\n+note: ...which requires const-evaluating + checking `Foo::bytes::{constant#0}`...\n   --> $DIR/const-size_of-cycle.rs:4:17\n    |\n LL |     bytes: [u8; std::mem::size_of::<Foo>()]\n@@ -17,7 +17,7 @@ LL |     bytes: [u8; std::mem::size_of::<Foo>()]\n    = note: ...which requires computing layout of `Foo`...\n    = note: ...which requires computing layout of `[u8; _]`...\n    = note: ...which requires normalizing `[u8; _]`...\n-   = note: ...which again requires simplifying constant for the type system `Foo::bytes::{constant#0}`, completing the cycle\n+   = note: ...which again requires evaluating type-level constant, completing the cycle\n note: cycle used when checking that `Foo` is well-formed\n   --> $DIR/const-size_of-cycle.rs:3:1\n    |"}, {"sha": "763263c6aeb4f9a86c81c99459d07590c6b06733", "filename": "src/test/ui/consts/const-tup-index-span.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-tup-index-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-tup-index-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-tup-index-span.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -4,6 +4,7 @@ const TUP: (usize,) = 5usize << 64;\n //~^ ERROR mismatched types\n //~| expected tuple, found `usize`\n const ARR: [i32; TUP.0] = [];\n+//~^ ERROR evaluation of constant value failed\n \n fn main() {\n }"}, {"sha": "b178e05e27a095b3c10102f6b0f63a3c7fb2b2a6", "filename": "src/test/ui/consts/const-tup-index-span.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-tup-index-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fconst-tup-index-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-tup-index-span.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -11,6 +11,13 @@ help: use a trailing comma to create a tuple with one element\n LL | const TUP: (usize,) = (5usize << 64,);\n    |                       +            ++\n \n-error: aborting due to previous error\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-tup-index-span.rs:6:18\n+   |\n+LL | const ARR: [i32; TUP.0] = [];\n+   |                  ^^^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0080, E0308.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "38c38d1ae673281fd05700d62afa1e2731f1baa8", "filename": "src/test/ui/consts/invalid-union.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Finvalid-union.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Finvalid-union.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Finvalid-union.32bit.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -6,7 +6,7 @@ LL | fn main() {\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc8\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc7\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error: erroneous constant used"}, {"sha": "6bfa97a2fded7875aeed1c92e698265662037f8e", "filename": "src/test/ui/consts/invalid-union.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Finvalid-union.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Finvalid-union.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Finvalid-union.64bit.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -6,7 +6,7 @@ LL | fn main() {\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: erroneous constant used"}, {"sha": "9ac6c984cb0cdd8fedb3f9883455c20c40e68d65", "filename": "src/test/ui/consts/issue-36163.stderr", "status": "modified", "additions": 6, "deletions": 34, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fissue-36163.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fissue-36163.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-36163.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,48 +1,20 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `Foo::B::{constant#0}`\n+error[E0391]: cycle detected when const-evaluating + checking `Foo::B::{constant#0}`\n   --> $DIR/issue-36163.rs:4:9\n    |\n LL |     B = A,\n    |         ^\n    |\n-note: ...which requires simplifying constant for the type system `Foo::B::{constant#0}`...\n-  --> $DIR/issue-36163.rs:4:9\n-   |\n-LL |     B = A,\n-   |         ^\n-note: ...which requires const-evaluating + checking `Foo::B::{constant#0}`...\n-  --> $DIR/issue-36163.rs:4:9\n-   |\n-LL |     B = A,\n-   |         ^\n-   = note: ...which requires normalizing `A`...\n-note: ...which requires simplifying constant for the type system `A`...\n-  --> $DIR/issue-36163.rs:1:1\n-   |\n-LL | const A: isize = Foo::B as isize;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `A`...\n-  --> $DIR/issue-36163.rs:1:1\n-   |\n-LL | const A: isize = Foo::B as isize;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `A`...\n   --> $DIR/issue-36163.rs:1:1\n    |\n LL | const A: isize = Foo::B as isize;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `A`...\n-   = note: ...which again requires simplifying constant for the type system `Foo::B::{constant#0}`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/issue-36163.rs:1:1\n+   = note: ...which again requires const-evaluating + checking `Foo::B::{constant#0}`, completing the cycle\n+note: cycle used when simplifying constant for the type system `Foo::B::{constant#0}`\n+  --> $DIR/issue-36163.rs:4:9\n    |\n-LL | / const A: isize = Foo::B as isize;\n-LL | |\n-LL | | enum Foo {\n-LL | |     B = A,\n-LL | | }\n-LL | |\n-LL | | fn main() {}\n-   | |____________^\n+LL |     B = A,\n+   |         ^\n \n error: aborting due to previous error\n "}, {"sha": "d93b451be453a2f6510a1f4229b576887ceeaf77", "filename": "src/test/ui/consts/issue-44415.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -4,7 +4,7 @@ use std::intrinsics;\n \n struct Foo {\n     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n-    //~^ ERROR cycle detected when simplifying constant for the type system\n+    //~^ ERROR cycle detected when evaluating type-level constant\n     x: usize,\n }\n "}, {"sha": "c085beb0ea5256a2a3a3d4fd9bbda3eb0ea2bba3", "filename": "src/test/ui/consts/issue-44415.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `Foo::bytes::{constant#0}`\n+error[E0391]: cycle detected when evaluating type-level constant\n   --> $DIR/issue-44415.rs:6:17\n    |\n LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n    |                 ^^^^^^\n    |\n-note: ...which requires simplifying constant for the type system `Foo::bytes::{constant#0}`...\n+note: ...which requires const-evaluating + checking `Foo::bytes::{constant#0}`...\n   --> $DIR/issue-44415.rs:6:17\n    |\n LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n@@ -17,7 +17,7 @@ LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n    = note: ...which requires computing layout of `Foo`...\n    = note: ...which requires computing layout of `[u8; _]`...\n    = note: ...which requires normalizing `[u8; _]`...\n-   = note: ...which again requires simplifying constant for the type system `Foo::bytes::{constant#0}`, completing the cycle\n+   = note: ...which again requires evaluating type-level constant, completing the cycle\n note: cycle used when checking that `Foo` is well-formed\n   --> $DIR/issue-44415.rs:5:1\n    |"}, {"sha": "4856418ed600229d153ce311781e0b01196b158c", "filename": "src/test/ui/issues/issue-17252.stderr", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,21 +1,10 @@\n-error[E0391]: cycle detected when normalizing `FOO`\n-   |\n-note: ...which requires simplifying constant for the type system `FOO`...\n-  --> $DIR/issue-17252.rs:1:1\n-   |\n-LL | const FOO: usize = FOO;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `FOO`...\n+error[E0391]: cycle detected when const-evaluating + checking `FOO`\n   --> $DIR/issue-17252.rs:1:1\n    |\n LL | const FOO: usize = FOO;\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires const-evaluating + checking `FOO`...\n-  --> $DIR/issue-17252.rs:1:1\n    |\n-LL | const FOO: usize = FOO;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires normalizing `FOO`, completing the cycle\n+   = note: ...which immediately requires const-evaluating + checking `FOO` again\n note: cycle used when const-evaluating + checking `main::{constant#0}`\n   --> $DIR/issue-17252.rs:4:18\n    |"}, {"sha": "9366050d7ecdf86f1714a4592ea579f06f331112", "filename": "src/test/ui/issues/issue-23302-1.stderr", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,26 +1,15 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `X::A::{constant#0}`\n+error[E0391]: cycle detected when const-evaluating + checking `X::A::{constant#0}`\n   --> $DIR/issue-23302-1.rs:4:9\n    |\n LL |     A = X::A as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-note: ...which requires simplifying constant for the type system `X::A::{constant#0}`...\n+   = note: ...which immediately requires const-evaluating + checking `X::A::{constant#0}` again\n+note: cycle used when simplifying constant for the type system `X::A::{constant#0}`\n   --> $DIR/issue-23302-1.rs:4:9\n    |\n LL |     A = X::A as isize,\n    |         ^^^^^^^^^^^^^\n-note: ...which requires const-evaluating + checking `X::A::{constant#0}`...\n-  --> $DIR/issue-23302-1.rs:4:9\n-   |\n-LL |     A = X::A as isize,\n-   |         ^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `X::A as isize`...\n-   = note: ...which again requires simplifying constant for the type system `X::A::{constant#0}`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/issue-23302-1.rs:3:1\n-   |\n-LL | enum X {\n-   | ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b97ae287a47a976dba3119de24dbf178abd080fd", "filename": "src/test/ui/issues/issue-23302-2.stderr", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,26 +1,15 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `Y::A::{constant#0}`\n+error[E0391]: cycle detected when const-evaluating + checking `Y::A::{constant#0}`\n   --> $DIR/issue-23302-2.rs:4:9\n    |\n LL |     A = Y::B as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-note: ...which requires simplifying constant for the type system `Y::A::{constant#0}`...\n+   = note: ...which immediately requires const-evaluating + checking `Y::A::{constant#0}` again\n+note: cycle used when simplifying constant for the type system `Y::A::{constant#0}`\n   --> $DIR/issue-23302-2.rs:4:9\n    |\n LL |     A = Y::B as isize,\n    |         ^^^^^^^^^^^^^\n-note: ...which requires const-evaluating + checking `Y::A::{constant#0}`...\n-  --> $DIR/issue-23302-2.rs:4:9\n-   |\n-LL |     A = Y::B as isize,\n-   |         ^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `Y::B as isize`...\n-   = note: ...which again requires simplifying constant for the type system `Y::A::{constant#0}`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/issue-23302-2.rs:3:1\n-   |\n-LL | enum Y {\n-   | ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "1a07d4a95bcfacca5b69d2f7d3467b211118b8ff", "filename": "src/test/ui/issues/issue-23302-3.stderr", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -1,38 +1,20 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `A`\n+error[E0391]: cycle detected when const-evaluating + checking `A`\n   --> $DIR/issue-23302-3.rs:1:1\n    |\n LL | const A: i32 = B;\n    | ^^^^^^^^^^^^^^^^^\n    |\n-note: ...which requires simplifying constant for the type system `A`...\n-  --> $DIR/issue-23302-3.rs:1:1\n-   |\n-LL | const A: i32 = B;\n-   | ^^^^^^^^^^^^^^^^^\n-note: ...which requires const-evaluating + checking `A`...\n-  --> $DIR/issue-23302-3.rs:1:1\n-   |\n-LL | const A: i32 = B;\n-   | ^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `B`...\n-note: ...which requires simplifying constant for the type system `B`...\n-  --> $DIR/issue-23302-3.rs:3:1\n-   |\n-LL | const B: i32 = A;\n-   | ^^^^^^^^^^^^^^^^^\n-note: ...which requires simplifying constant for the type system `B`...\n+note: ...which requires const-evaluating + checking `B`...\n   --> $DIR/issue-23302-3.rs:3:1\n    |\n LL | const B: i32 = A;\n    | ^^^^^^^^^^^^^^^^^\n-note: ...which requires const-evaluating + checking `B`...\n-  --> $DIR/issue-23302-3.rs:3:1\n+   = note: ...which again requires const-evaluating + checking `A`, completing the cycle\n+note: cycle used when simplifying constant for the type system `A`\n+  --> $DIR/issue-23302-3.rs:1:1\n    |\n-LL | const B: i32 = A;\n+LL | const A: i32 = B;\n    | ^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `A`...\n-   = note: ...which again requires simplifying constant for the type system `A`, completing the cycle\n-   = note: cycle used when running analysis passes on this crate\n \n error: aborting due to previous error\n "}, {"sha": "64873ac35a00213e78fc7479e75ba180f5029a34", "filename": "src/test/ui/issues/issue-41394.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-41394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-41394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41394.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -5,6 +5,7 @@ enum Foo {\n \n enum Bar {\n     A = Foo::A as isize\n+    //~^ ERROR evaluation of constant value failed\n }\n \n fn main() {}"}, {"sha": "47a24547d4533dcf333588d10315f2c42f942f7c", "filename": "src/test/ui/issues/issue-41394.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-41394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-41394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41394.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -6,6 +6,13 @@ LL |     A = \"\" + 1\n    |         |\n    |         &str\n \n-error: aborting due to previous error\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-41394.rs:7:9\n+   |\n+LL |     A = Foo::A as isize\n+   |         ^^^^^^^^^^^^^^^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0369`.\n+Some errors have detailed explanations: E0080, E0369.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "ddd391415414763bb38d0f06348458cea2ee85e6", "filename": "src/test/ui/issues/issue-54954.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-54954.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-54954.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54954.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -9,6 +9,8 @@ trait Tt {\n }\n \n fn f(z: [f32; ARR_LEN]) -> [f32; ARR_LEN] {\n+  //~^ ERROR evaluation of constant value failed\n+  //~| ERROR evaluation of constant value failed\n     z\n }\n "}, {"sha": "6e8d3cac9a7e4f365ea3b338c0d6f793157733cb", "filename": "src/test/ui/issues/issue-54954.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-54954.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-54954.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54954.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -12,7 +12,19 @@ LL | const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n    |\n    = note: cannot satisfy `_: Tt`\n \n-error: aborting due to 2 previous errors\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-54954.rs:11:15\n+   |\n+LL | fn f(z: [f32; ARR_LEN]) -> [f32; ARR_LEN] {\n+   |               ^^^^^^^ referenced constant has errors\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-54954.rs:11:34\n+   |\n+LL | fn f(z: [f32; ARR_LEN]) -> [f32; ARR_LEN] {\n+   |                                  ^^^^^^^ referenced constant has errors\n+\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0283, E0379.\n-For more information about an error, try `rustc --explain E0283`.\n+Some errors have detailed explanations: E0080, E0283, E0379.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "6851b67cb3b3aa3cfa3ac81fe21e3c3af4d4f4b5", "filename": "src/test/ui/issues/issue-69602-type-err-during-codegen-ice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -19,4 +19,5 @@ impl TraitB for B { //~ ERROR not all trait items implemented, missing: `MyA`\n \n fn main() {\n     let _ = [0; B::VALUE];\n+    //~^ ERROR evaluation of constant value failed\n }"}, {"sha": "cb5b397849c06334fd95724b85d41571ea078e79", "filename": "src/test/ui/issues/issue-69602-type-err-during-codegen-ice.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -13,7 +13,13 @@ LL |     type MyA: TraitA;\n LL | impl TraitB for B {\n    | ^^^^^^^^^^^^^^^^^ missing `MyA` in implementation\n \n-error: aborting due to 2 previous errors\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-69602-type-err-during-codegen-ice.rs:21:17\n+   |\n+LL |     let _ = [0; B::VALUE];\n+   |                 ^^^^^^^^ referenced constant has errors\n+\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0046, E0437.\n+Some errors have detailed explanations: E0046, E0080, E0437.\n For more information about an error, try `rustc --explain E0046`."}, {"sha": "78a20cf8ebb05eab5f6d74fbc37b91bbeb28c38c", "filename": "src/test/ui/resolve/issue-50599.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -2,4 +2,5 @@ fn main() {\n     const N: u32 = 1_000;\n     const M: usize = (f64::from(N) * std::f64::LOG10_2) as usize; //~ ERROR cannot find value\n     let mut digits = [0u32; M];\n+    //~^ ERROR evaluation of constant value failed\n }"}, {"sha": "f0cb784f56c48037804dfbceb84655104f6b5bda", "filename": "src/test/ui/resolve/issue-50599.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -16,6 +16,13 @@ LL -     const M: usize = (f64::from(N) * std::f64::LOG10_2) as usize;\n LL +     const M: usize = (f64::from(N) * LOG10_2) as usize;\n    | \n \n-error: aborting due to previous error\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-50599.rs:4:29\n+   |\n+LL |     let mut digits = [0u32; M];\n+   |                             ^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0425`.\n+Some errors have detailed explanations: E0080, E0425.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "f37f093d9ede7b6f07aebfdaa310efb3a58b3493", "filename": "src/test/ui/type/type-dependent-def-issue-49241.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -2,4 +2,5 @@ fn main() {\n     let v = vec![0];\n     const l: usize = v.count(); //~ ERROR attempt to use a non-constant value in a constant\n     let s: [u32; l] = v.into_iter().collect();\n+    //~^ERROR evaluation of constant value failed\n }"}, {"sha": "02f267c6c8d73419c7cb6da9f6f5c78a8109051c", "filename": "src/test/ui/type/type-dependent-def-issue-49241.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.stderr?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -6,6 +6,13 @@ LL |     const l: usize = v.count();\n    |     |\n    |     help: consider using `let` instead of `const`: `let l`\n \n-error: aborting due to previous error\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/type-dependent-def-issue-49241.rs:4:18\n+   |\n+LL |     let s: [u32; l] = v.into_iter().collect();\n+   |                  ^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0435`.\n+Some errors have detailed explanations: E0080, E0435.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "da67888827d199a31de66d410b2e5e0c8a4f27ca", "filename": "src/tools/clippy/clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -50,8 +50,8 @@ impl<'tcx> LateLintPass<'tcx> for UnportableVariant {\n                         .tcx\n                         .const_eval_poly(def_id.to_def_id())\n                         .ok()\n-                        .map(|val| rustc_middle::ty::Const::from_value(cx.tcx, val, ty));\n-                    if let Some(Constant::Int(val)) = constant.and_then(miri_to_const) {\n+                        .map(|val| rustc_middle::mir::ConstantKind::from_value(val, ty));\n+                    if let Some(Constant::Int(val)) = constant.and_then(|c| miri_to_const(cx.tcx, c)) {\n                         if let ty::Adt(adt, _) = ty.kind() {\n                             if adt.is_enum() {\n                                 ty = adt.repr().discr_type().to_ty(cx.tcx);"}, {"sha": "e10993ba7ddce0685ce140fc99547b72f2b9cd92", "filename": "src/tools/clippy/clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -3,7 +3,6 @@ use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, ConstKind};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -53,8 +52,8 @@ impl<'tcx> LateLintPass<'tcx> for LargeConstArrays {\n             if let ItemKind::Const(hir_ty, _) = &item.kind;\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             if let ty::Array(element_type, cst) = ty.kind();\n-            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.kind();\n-            if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n+            if let ConstKind::Value(ty::ValTree::Leaf(element_count)) = cst.kind();\n+            if let Ok(element_count) = element_count.try_to_machine_usize(cx.tcx);\n             if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;\n "}, {"sha": "0acbd81aec3438ab99989d2fda6c8960257045b6", "filename": "src/tools/clippy/clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -3,7 +3,6 @@ use clippy_utils::source::snippet;\n use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, ConstKind};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -43,8 +42,8 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n             if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind();\n-            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.kind();\n-            if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n+            if let ConstKind::Value(ty::ValTree::Leaf(element_count)) = cst.kind();\n+            if let Ok(element_count) = element_count.try_to_machine_usize(cx.tcx);\n             if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;\n             then {"}, {"sha": "ae69ca8a3393d57bc1ca1bee59f98cf61211afba", "filename": "src/tools/clippy/clippy_lints/src/matches/overlapping_arms.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -3,6 +3,7 @@ use clippy_utils::diagnostics::span_lint_and_note;\n use core::cmp::Ordering;\n use rustc_hir::{Arm, Expr, PatKind, RangeEnd};\n use rustc_lint::LateContext;\n+use rustc_middle::mir;\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n \n@@ -34,11 +35,25 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                 if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n                     let lhs_const = match lhs {\n                         Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n-                        None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n+                        None => {\n+                            let min_val_const = ty.numeric_min_val(cx.tcx)?;\n+                            let min_constant = mir::ConstantKind::from_value(\n+                                cx.tcx.valtree_to_const_val((ty, min_val_const.to_valtree())),\n+                                ty,\n+                            );\n+                            miri_to_const(cx.tcx, min_constant)?\n+                        },\n                     };\n                     let rhs_const = match rhs {\n                         Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n-                        None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n+                        None => {\n+                            let max_val_const = ty.numeric_max_val(cx.tcx)?;\n+                            let max_constant = mir::ConstantKind::from_value(\n+                                cx.tcx.valtree_to_const_val((ty, max_val_const.to_valtree())),\n+                                ty,\n+                            );\n+                            miri_to_const(cx.tcx, max_constant)?\n+                        },\n                     };\n                     let lhs_val = lhs_const.int_value(cx, ty)?;\n                     let rhs_val = rhs_const.int_value(cx, ty)?;"}, {"sha": "7163cfe5e3a2c774911023904da8de297ebc346a", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -13,9 +13,10 @@ use rustc_hir::{\n     BodyId, Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass, Lint};\n+use rustc_middle::mir;\n use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n use rustc_middle::ty::adjustment::Adjust;\n-use rustc_middle::ty::{self, Const, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use rustc_typeck::hir_ty_to_ty;\n@@ -136,19 +137,18 @@ fn is_value_unfrozen_raw<'tcx>(\n     result: Result<ConstValue<'tcx>, ErrorHandled>,\n     ty: Ty<'tcx>,\n ) -> bool {\n-    fn inner<'tcx>(cx: &LateContext<'tcx>, val: Const<'tcx>) -> bool {\n+    fn inner<'tcx>(cx: &LateContext<'tcx>, val: mir::ConstantKind<'tcx>) -> bool {\n         match val.ty().kind() {\n             // the fact that we have to dig into every structs to search enums\n             // leads us to the point checking `UnsafeCell` directly is the only option.\n             ty::Adt(ty_def, ..) if Some(ty_def.did()) == cx.tcx.lang_items().unsafe_cell_type() => true,\n             ty::Array(..) | ty::Adt(..) | ty::Tuple(..) => {\n-                let val = cx.tcx.destructure_const(cx.param_env.and(val));\n+                let val = cx.tcx.destructure_mir_constant(cx.param_env, val);\n                 val.fields.iter().any(|field| inner(cx, *field))\n             },\n             _ => false,\n         }\n     }\n-\n     result.map_or_else(\n         |err| {\n             // Consider `TooGeneric` cases as being unfrozen.\n@@ -174,7 +174,7 @@ fn is_value_unfrozen_raw<'tcx>(\n             // I chose this way because unfrozen enums as assoc consts are rare (or, hopefully, none).\n             err == ErrorHandled::TooGeneric\n         },\n-        |val| inner(cx, Const::from_value(cx.tcx, val, ty)),\n+        |val| inner(cx, mir::ConstantKind::from_value(val, ty)),\n     )\n }\n "}, {"sha": "5d0ce6cc620ac36a65dae2ab3399a8c20b29fafe", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "patch": "@@ -7,6 +7,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, Item, ItemKind, Node, QPath, UnOp};\n use rustc_lint::LateContext;\n+use rustc_middle::mir;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::{self, EarlyBinder, FloatTy, ScalarInt, Ty, TyCtxt};\n@@ -429,8 +430,8 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                         None,\n                     )\n                     .ok()\n-                    .map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty))?;\n-                let result = miri_to_const(result);\n+                    .map(|val| rustc_middle::mir::ConstantKind::from_value(val, ty))?;\n+                let result = miri_to_const(self.lcx.tcx, result);\n                 if result.is_some() {\n                     self.needed_resolution = true;\n                 }\n@@ -580,10 +581,10 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n     }\n }\n \n-pub fn miri_to_const(result: ty::Const<'_>) -> Option<Constant> {\n+pub fn miri_to_const<'tcx>(tcx: TyCtxt<'tcx>, result: mir::ConstantKind<'tcx>) -> Option<Constant> {\n     use rustc_middle::mir::interpret::ConstValue;\n-    match result.kind() {\n-        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(int))) => {\n+    match result {\n+        mir::ConstantKind::Val(ConstValue::Scalar(Scalar::Int(int)), _) => {\n             match result.ty().kind() {\n                 ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n                 ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),\n@@ -603,7 +604,7 @@ pub fn miri_to_const(result: ty::Const<'_>) -> Option<Constant> {\n                 _ => None,\n             }\n         },\n-        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty().kind() {\n+        mir::ConstantKind::Val(ConstValue::Slice { data, start, end }, _) => match result.ty().kind() {\n             ty::Ref(_, tam, _) => match tam.kind() {\n                 ty::Str => String::from_utf8(\n                     data.inner()\n@@ -616,10 +617,10 @@ pub fn miri_to_const(result: ty::Const<'_>) -> Option<Constant> {\n             },\n             _ => None,\n         },\n-        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty().kind() {\n+        mir::ConstantKind::Val(ConstValue::ByRef { alloc, offset: _ }, _) => match result.ty().kind() {\n             ty::Array(sub_type, len) => match sub_type.kind() {\n-                ty::Float(FloatTy::F32) => match miri_to_const(*len) {\n-                    Some(Constant::Int(len)) => alloc\n+                ty::Float(FloatTy::F32) => match len.to_valtree().try_to_machine_usize(tcx) {\n+                    Some(len) => alloc\n                         .inner()\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n                         .to_owned()\n@@ -633,8 +634,8 @@ pub fn miri_to_const(result: ty::Const<'_>) -> Option<Constant> {\n                         .map(Constant::Vec),\n                     _ => None,\n                 },\n-                ty::Float(FloatTy::F64) => match miri_to_const(*len) {\n-                    Some(Constant::Int(len)) => alloc\n+                ty::Float(FloatTy::F64) => match len.to_valtree().try_to_machine_usize(tcx) {\n+                    Some(len) => alloc\n                         .inner()\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n                         .to_owned()"}]}