{"sha": "726938f598378f6d88b6b5ee91e1cea8f323029d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNjkzOGY1OTgzNzhmNmQ4OGI2YjVlZTkxZTFjZWE4ZjMyMzAyOWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-25T17:29:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-25T17:30:00Z"}, "message": "Simplify hprof", "tree": {"sha": "eee75f7383720ef53e5e9bd34a1f6d46d0a3d6e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eee75f7383720ef53e5e9bd34a1f6d46d0a3d6e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/726938f598378f6d88b6b5ee91e1cea8f323029d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/726938f598378f6d88b6b5ee91e1cea8f323029d", "html_url": "https://github.com/rust-lang/rust/commit/726938f598378f6d88b6b5ee91e1cea8f323029d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/726938f598378f6d88b6b5ee91e1cea8f323029d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3e9f3d143b0fae970449b7c49a2daf6f966a068", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3e9f3d143b0fae970449b7c49a2daf6f966a068", "html_url": "https://github.com/rust-lang/rust/commit/b3e9f3d143b0fae970449b7c49a2daf6f966a068"}], "stats": {"total": 149, "additions": 64, "deletions": 85}, "files": [{"sha": "6d91206ae4faea8eb9d3d121138760e04fbd1ff7", "filename": "crates/ra_prof/src/hprof.rs", "status": "modified", "additions": 64, "deletions": 85, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/726938f598378f6d88b6b5ee91e1cea8f323029d/crates%2Fra_prof%2Fsrc%2Fhprof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726938f598378f6d88b6b5ee91e1cea8f323029d/crates%2Fra_prof%2Fsrc%2Fhprof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Fhprof.rs?ref=726938f598378f6d88b6b5ee91e1cea8f323029d", "patch": "@@ -23,7 +23,7 @@ pub fn init() {\n \n pub fn init_from(spec: &str) {\n     let filter = if spec.is_empty() { Filter::disabled() } else { Filter::from_spec(spec) };\n-    set_filter(filter);\n+    filter.install();\n }\n \n pub type Label = &'static str;\n@@ -57,30 +57,10 @@ pub type Label = &'static str;\n /// ```\n pub fn profile(label: Label) -> Profiler {\n     assert!(!label.is_empty());\n-    if !PROFILING_ENABLED.load(Ordering::Relaxed) {\n-        return Profiler { label: None, detail: None };\n-    }\n-\n-    PROFILE_STACK.with(|stack| {\n-        let mut stack = stack.borrow_mut();\n-        if stack.starts.is_empty() {\n-            if let Ok(f) = FILTER.try_read() {\n-                if f.version > stack.filter_data.version {\n-                    stack.filter_data = f.clone();\n-                }\n-            };\n-        }\n-        if stack.starts.len() > stack.filter_data.depth {\n-            return Profiler { label: None, detail: None };\n-        }\n-        let allowed = &stack.filter_data.allowed;\n-        if stack.starts.is_empty() && !allowed.is_empty() && !allowed.contains(label) {\n-            return Profiler { label: None, detail: None };\n-        }\n-\n-        stack.starts.push(Instant::now());\n-        Profiler { label: Some(label), detail: None }\n-    })\n+    let enabled = PROFILING_ENABLED.load(Ordering::Relaxed)\n+        && PROFILE_STACK.with(|stack| stack.borrow_mut().push(label));\n+    let label = if enabled { Some(label) } else { None };\n+    Profiler { label, detail: None }\n }\n \n pub struct Profiler {\n@@ -97,36 +77,27 @@ impl Profiler {\n     }\n }\n \n-/// Set profiling filter. It specifies descriptions allowed to profile.\n-/// This is helpful when call stack has too many nested profiling scopes.\n-/// Additionally filter can specify maximum depth of profiling scopes nesting.\n-///\n-/// #Example\n-/// ```\n-/// use ra_prof::{set_filter, Filter};\n-/// let f = Filter::from_spec(\"profile1|profile2@2\");\n-/// set_filter(f);\n-/// ```\n-fn set_filter(f: Filter) {\n-    PROFILING_ENABLED.store(f.depth > 0, Ordering::SeqCst);\n-    let set: HashSet<_> = f.allowed.iter().cloned().collect();\n-    let mut old = FILTER.write().unwrap();\n-    let filter_data = FilterData {\n-        depth: f.depth,\n-        allowed: set,\n-        longer_than: f.longer_than,\n-        version: old.version + 1,\n-    };\n-    *old = filter_data;\n-}\n+static PROFILING_ENABLED: AtomicBool = AtomicBool::new(false);\n+static FILTER: Lazy<RwLock<Filter>> = Lazy::new(Default::default);\n+thread_local!(static PROFILE_STACK: RefCell<ProfileStack> = RefCell::new(ProfileStack::new()));\n \n+#[derive(Default, Clone, Debug)]\n struct Filter {\n     depth: usize,\n-    allowed: Vec<String>,\n+    allowed: HashSet<String>,\n     longer_than: Duration,\n+    version: usize,\n }\n \n impl Filter {\n+    fn new(depth: usize, allowed: HashSet<String>, longer_than: Duration) -> Filter {\n+        Filter { depth, allowed, longer_than, version: 0 }\n+    }\n+\n+    fn disabled() -> Filter {\n+        Filter::default()\n+    }\n+\n     fn from_spec(mut spec: &str) -> Filter {\n         let longer_than = if let Some(idx) = spec.rfind('>') {\n             let longer_than = spec[idx + 1..].parse().expect(\"invalid profile longer_than\");\n@@ -144,23 +115,22 @@ impl Filter {\n             999\n         };\n         let allowed =\n-            if spec == \"*\" { Vec::new() } else { spec.split('|').map(String::from).collect() };\n+            if spec == \"*\" { HashSet::new() } else { spec.split('|').map(String::from).collect() };\n         Filter::new(depth, allowed, longer_than)\n     }\n \n-    pub fn disabled() -> Filter {\n-        Filter::new(0, Vec::new(), Duration::new(0, 0))\n-    }\n-\n-    pub fn new(depth: usize, allowed: Vec<String>, longer_than: Duration) -> Filter {\n-        Filter { depth, allowed, longer_than }\n+    fn install(mut self) {\n+        PROFILING_ENABLED.store(self.depth > 0, Ordering::SeqCst);\n+        let mut old = FILTER.write().unwrap();\n+        self.version = old.version + 1;\n+        *old = self;\n     }\n }\n \n struct ProfileStack {\n     starts: Vec<Instant>,\n     messages: Vec<Message>,\n-    filter_data: FilterData,\n+    filter: Filter,\n }\n \n struct Message {\n@@ -172,45 +142,54 @@ struct Message {\n \n impl ProfileStack {\n     fn new() -> ProfileStack {\n-        ProfileStack { starts: Vec::new(), messages: Vec::new(), filter_data: Default::default() }\n+        ProfileStack { starts: Vec::new(), messages: Vec::new(), filter: Default::default() }\n     }\n-}\n \n-#[derive(Default, Clone)]\n-struct FilterData {\n-    depth: usize,\n-    version: usize,\n-    allowed: HashSet<String>,\n-    longer_than: Duration,\n-}\n-\n-static PROFILING_ENABLED: AtomicBool = AtomicBool::new(false);\n+    fn push(&mut self, label: Label) -> bool {\n+        if self.starts.is_empty() {\n+            if let Ok(f) = FILTER.try_read() {\n+                if f.version > self.filter.version {\n+                    self.filter = f.clone();\n+                }\n+            };\n+        }\n+        if self.starts.len() > self.filter.depth {\n+            return false;\n+        }\n+        let allowed = &self.filter.allowed;\n+        if self.starts.is_empty() && !allowed.is_empty() && !allowed.contains(label) {\n+            return false;\n+        }\n \n-static FILTER: Lazy<RwLock<FilterData>> = Lazy::new(Default::default);\n+        self.starts.push(Instant::now());\n+        true\n+    }\n \n-thread_local!(static PROFILE_STACK: RefCell<ProfileStack> = RefCell::new(ProfileStack::new()));\n+    pub fn pop(&mut self, label: Label, detail: Option<String>) {\n+        let start = self.starts.pop().unwrap();\n+        let duration = start.elapsed();\n+        let level = self.starts.len();\n+        self.messages.push(Message { level, duration, label, detail });\n+        if level == 0 {\n+            let stdout = stderr();\n+            let longer_than = self.filter.longer_than;\n+            // Convert to millis for comparison to avoid problems with rounding\n+            // (otherwise we could print `0ms` despite user's `>0` filter when\n+            // `duration` is just a few nanos).\n+            if duration.as_millis() > longer_than.as_millis() {\n+                print(&self.messages, longer_than, &mut stdout.lock());\n+            }\n+            self.messages.clear();\n+        }\n+    }\n+}\n \n impl Drop for Profiler {\n     fn drop(&mut self) {\n         match self {\n             Profiler { label: Some(label), detail } => {\n                 PROFILE_STACK.with(|stack| {\n-                    let mut stack = stack.borrow_mut();\n-                    let start = stack.starts.pop().unwrap();\n-                    let duration = start.elapsed();\n-                    let level = stack.starts.len();\n-                    stack.messages.push(Message { level, duration, label, detail: detail.take() });\n-                    if level == 0 {\n-                        let stdout = stderr();\n-                        let longer_than = stack.filter_data.longer_than;\n-                        // Convert to millis for comparison to avoid problems with rounding\n-                        // (otherwise we could print `0ms` despite user's `>0` filter when\n-                        // `duration` is just a few nanos).\n-                        if duration.as_millis() > longer_than.as_millis() {\n-                            print(&stack.messages, longer_than, &mut stdout.lock());\n-                        }\n-                        stack.messages.clear();\n-                    }\n+                    stack.borrow_mut().pop(label, detail.take());\n                 });\n             }\n             Profiler { label: None, .. } => (),"}]}