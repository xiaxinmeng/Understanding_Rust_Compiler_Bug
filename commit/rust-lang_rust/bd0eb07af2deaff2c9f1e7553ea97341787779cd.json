{"sha": "bd0eb07af2deaff2c9f1e7553ea97341787779cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMGViMDdhZjJkZWFmZjJjOWYxZTc1NTNlYTk3MzQxNzg3Nzc5Y2Q=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-11-03T05:32:48Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-11-12T00:40:17Z"}, "message": "Added some unit tests as requested\n\nAs discussed in PR #78267, for example:\n\n* https://github.com/rust-lang/rust/pull/78267#discussion_r515404722\n* https://github.com/rust-lang/rust/pull/78267#discussion_r515405958", "tree": {"sha": "180d9fe6e6bec7106ccaae1fd885e5b923a24662", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/180d9fe6e6bec7106ccaae1fd885e5b923a24662"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd0eb07af2deaff2c9f1e7553ea97341787779cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd0eb07af2deaff2c9f1e7553ea97341787779cd", "html_url": "https://github.com/rust-lang/rust/commit/bd0eb07af2deaff2c9f1e7553ea97341787779cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd0eb07af2deaff2c9f1e7553ea97341787779cd/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5404efc28a0cddee103ef6396c48ea71ff9631c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5404efc28a0cddee103ef6396c48ea71ff9631c8", "html_url": "https://github.com/rust-lang/rust/commit/5404efc28a0cddee103ef6396c48ea71ff9631c8"}], "stats": {"total": 709, "additions": 687, "deletions": 22}, "files": [{"sha": "4ab46a9cc871be438dbce59bf111b027fdcd2147", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd0eb07af2deaff2c9f1e7553ea97341787779cd/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bd0eb07af2deaff2c9f1e7553ea97341787779cd/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bd0eb07af2deaff2c9f1e7553ea97341787779cd", "patch": "@@ -721,6 +721,13 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9a21fa21941700a3cd8fcb4091f361a6a712fac632f85d9f487cc892045d55c6\"\n \n+[[package]]\n+name = \"coverage_test_macros\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"proc-macro2\",\n+]\n+\n [[package]]\n name = \"cpuid-bool\"\n version = \"0.1.2\"\n@@ -3922,6 +3929,7 @@ dependencies = [\n name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n+ \"coverage_test_macros\",\n  \"either\",\n  \"itertools 0.9.0\",\n  \"polonius-engine\","}, {"sha": "9bfd1da0391203c9b5461dcbf83690c3df4fefe3", "filename": "compiler/rustc_mir/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2FCargo.toml?ref=bd0eb07af2deaff2c9f1e7553ea97341787779cd", "patch": "@@ -31,3 +31,6 @@ rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_apfloat = { path = \"../rustc_apfloat\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+\n+[dev-dependencies]\n+coverage_test_macros = { path = \"src/transform/coverage/test_macros\" }"}, {"sha": "7c4b30ca9e790c7ec7ccb4e0d80d6dd2e851c4c6", "filename": "compiler/rustc_mir/src/transform/coverage/counters.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs?ref=bd0eb07af2deaff2c9f1e7553ea97341787779cd", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::mir::coverage::*;\n \n /// Manages the counter and expression indexes/IDs to generate `CoverageKind` components for MIR\n /// `Coverage` statements.\n-pub(crate) struct CoverageCounters {\n+pub(super) struct CoverageCounters {\n     function_source_hash: u64,\n     next_counter_id: u32,\n     num_expressions: u32,\n@@ -37,7 +37,7 @@ impl CoverageCounters {\n         self.debug_counters.enable();\n     }\n \n-    /// Makes `CoverageKind` `Counter`s and `Expressions` for the `BasicCoverageBlocks` directly or\n+    /// Makes `CoverageKind` `Counter`s and `Expressions` for the `BasicCoverageBlock`s directly or\n     /// indirectly associated with `CoverageSpans`, and returns additional `Expression`s\n     /// representing intermediate values.\n     pub fn make_bcb_counters("}, {"sha": "7f1dc3844b21dc2cc1481ba310a03a6f1e4e802c", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=bd0eb07af2deaff2c9f1e7553ea97341787779cd", "patch": "@@ -127,7 +127,7 @@ pub const NESTED_INDENT: &str = \"    \";\n \n const RUSTC_COVERAGE_DEBUG_OPTIONS: &str = \"RUSTC_COVERAGE_DEBUG_OPTIONS\";\n \n-pub(crate) fn debug_options<'a>() -> &'a DebugOptions {\n+pub(super) fn debug_options<'a>() -> &'a DebugOptions {\n     static DEBUG_OPTIONS: SyncOnceCell<DebugOptions> = SyncOnceCell::new();\n \n     &DEBUG_OPTIONS.get_or_init(|| DebugOptions::from_env())\n@@ -136,7 +136,7 @@ pub(crate) fn debug_options<'a>() -> &'a DebugOptions {\n /// Parses and maintains coverage-specific debug options captured from the environment variable\n /// \"RUSTC_COVERAGE_DEBUG_OPTIONS\", if set.\n #[derive(Debug, Clone)]\n-pub(crate) struct DebugOptions {\n+pub(super) struct DebugOptions {\n     pub allow_unused_expressions: bool,\n     counter_format: ExpressionFormat,\n }\n@@ -250,7 +250,7 @@ impl Default for ExpressionFormat {\n ///\n /// `DebugCounters` supports a recursive rendering of `Expression` counters, so they can be\n /// presented as nested expressions such as `(bcb3 - (bcb0 + bcb1))`.\n-pub(crate) struct DebugCounters {\n+pub(super) struct DebugCounters {\n     some_counters: Option<FxHashMap<ExpressionOperandId, DebugCounter>>,\n }\n \n@@ -386,7 +386,7 @@ impl DebugCounter {\n \n /// If enabled, this data structure captures additional debugging information used when generating\n /// a Graphviz (.dot file) representation of the `CoverageGraph`, for debugging purposes.\n-pub(crate) struct GraphvizData {\n+pub(super) struct GraphvizData {\n     some_bcb_to_coverage_spans_with_counters:\n         Option<FxHashMap<BasicCoverageBlock, Vec<(CoverageSpan, CoverageKind)>>>,\n     some_bcb_to_dependency_counters: Option<FxHashMap<BasicCoverageBlock, Vec<CoverageKind>>>,\n@@ -496,7 +496,7 @@ impl GraphvizData {\n /// directly or indirectly, to compute the coverage counts for all `CoverageSpan`s, and any that are\n /// _not_ used are retained in the `unused_expressions` Vec, to be included in debug output (logs\n /// and/or a `CoverageGraph` graphviz output).\n-pub(crate) struct UsedExpressions {\n+pub(super) struct UsedExpressions {\n     some_used_expression_operands:\n         Option<FxHashMap<ExpressionOperandId, Vec<InjectedExpressionId>>>,\n     some_unused_expressions:\n@@ -626,7 +626,7 @@ impl UsedExpressions {\n }\n \n /// Generates the MIR pass `CoverageSpan`-specific spanview dump file.\n-pub(crate) fn dump_coverage_spanview(\n+pub(super) fn dump_coverage_spanview(\n     tcx: TyCtxt<'tcx>,\n     mir_body: &mir::Body<'tcx>,\n     basic_coverage_blocks: &CoverageGraph,\n@@ -666,7 +666,7 @@ fn span_viewables(\n }\n \n /// Generates the MIR pass coverage-specific graphviz dump file.\n-pub(crate) fn dump_coverage_graphviz(\n+pub(super) fn dump_coverage_graphviz(\n     tcx: TyCtxt<'tcx>,\n     mir_body: &mir::Body<'tcx>,\n     pass_name: &str,\n@@ -815,7 +815,7 @@ fn bcb_to_string_sections(\n \n /// Returns a simple string representation of a `TerminatorKind` variant, indenpendent of any\n /// values it might hold.\n-pub(crate) fn term_type(kind: &TerminatorKind<'tcx>) -> &'static str {\n+pub(super) fn term_type(kind: &TerminatorKind<'tcx>) -> &'static str {\n     match kind {\n         TerminatorKind::Goto { .. } => \"Goto\",\n         TerminatorKind::SwitchInt { .. } => \"SwitchInt\","}, {"sha": "9d375633dcf5108ce083c10abeb5996efe3c5e17", "filename": "compiler/rustc_mir/src/transform/coverage/graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs?ref=bd0eb07af2deaff2c9f1e7553ea97341787779cd", "patch": "@@ -17,7 +17,8 @@ const ID_SEPARATOR: &str = \",\";\n /// `CoverageKind` counter (to be added by `CoverageCounters::make_bcb_counters`), and an optional\n /// set of additional counters--if needed--to count incoming edges, if there are more than one.\n /// (These \"edge counters\" are eventually converted into new MIR `BasicBlock`s.)\n-pub(crate) struct CoverageGraph {\n+#[derive(Debug)]\n+pub(super) struct CoverageGraph {\n     bcbs: IndexVec<BasicCoverageBlock, BasicCoverageBlockData>,\n     bb_to_bcb: IndexVec<BasicBlock, Option<BasicCoverageBlock>>,\n     pub successors: IndexVec<BasicCoverageBlock, Vec<BasicCoverageBlock>>,\n@@ -275,7 +276,7 @@ impl graph::WithPredecessors for CoverageGraph {\n \n rustc_index::newtype_index! {\n     /// A node in the [control-flow graph][CFG] of CoverageGraph.\n-    pub(crate) struct BasicCoverageBlock {\n+    pub(super) struct BasicCoverageBlock {\n         DEBUG_FORMAT = \"bcb{}\",\n     }\n }\n@@ -305,7 +306,7 @@ rustc_index::newtype_index! {\n /// queries (`is_dominated_by()`, `predecessors`, `successors`, etc.) have branch (control flow)\n /// significance.\n #[derive(Debug, Clone)]\n-pub(crate) struct BasicCoverageBlockData {\n+pub(super) struct BasicCoverageBlockData {\n     pub basic_blocks: Vec<BasicBlock>,\n     pub counter_kind: Option<CoverageKind>,\n     edge_from_bcbs: Option<FxHashMap<BasicCoverageBlock, CoverageKind>>,\n@@ -431,7 +432,7 @@ impl BasicCoverageBlockData {\n /// the specific branching BCB, representing the edge between the two. The latter case\n /// distinguishes this incoming edge from other incoming edges to the same `target_bcb`.\n #[derive(Clone, Copy, PartialEq, Eq)]\n-pub(crate) struct BcbBranch {\n+pub(super) struct BcbBranch {\n     pub edge_from_bcb: Option<BasicCoverageBlock>,\n     pub target_bcb: BasicCoverageBlock,\n }\n@@ -498,9 +499,8 @@ fn bcb_filtered_successors<'a, 'tcx>(\n /// Maintains separate worklists for each loop in the BasicCoverageBlock CFG, plus one for the\n /// CoverageGraph outside all loops. This supports traversing the BCB CFG in a way that\n /// ensures a loop is completely traversed before processing Blocks after the end of the loop.\n-// FIXME(richkadel): Add unit tests for TraversalContext.\n #[derive(Debug)]\n-pub(crate) struct TraversalContext {\n+pub(super) struct TraversalContext {\n     /// From one or more backedges returning to a loop header.\n     pub loop_backedges: Option<(Vec<BasicCoverageBlock>, BasicCoverageBlock)>,\n \n@@ -510,7 +510,7 @@ pub(crate) struct TraversalContext {\n     pub worklist: Vec<BasicCoverageBlock>,\n }\n \n-pub(crate) struct TraverseCoverageGraphWithLoops {\n+pub(super) struct TraverseCoverageGraphWithLoops {\n     pub backedges: IndexVec<BasicCoverageBlock, Vec<BasicCoverageBlock>>,\n     pub context_stack: Vec<TraversalContext>,\n     visited: BitSet<BasicCoverageBlock>,\n@@ -642,7 +642,7 @@ impl TraverseCoverageGraphWithLoops {\n     }\n }\n \n-fn find_loop_backedges(\n+pub(super) fn find_loop_backedges(\n     basic_coverage_blocks: &CoverageGraph,\n ) -> IndexVec<BasicCoverageBlock, Vec<BasicCoverageBlock>> {\n     let num_bcbs = basic_coverage_blocks.num_nodes();"}, {"sha": "de37a67a1742ff68b782a51fc9e72136638a81be", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=bd0eb07af2deaff2c9f1e7553ea97341787779cd", "patch": "@@ -5,6 +5,9 @@ mod debug;\n mod graph;\n mod spans;\n \n+#[cfg(test)]\n+mod tests;\n+\n use counters::CoverageCounters;\n use graph::{BasicCoverageBlock, BasicCoverageBlockData, CoverageGraph};\n use spans::{CoverageSpan, CoverageSpans};\n@@ -31,7 +34,7 @@ use rustc_span::{CharPos, Pos, SourceFile, Span, Symbol};\n \n /// A simple error message wrapper for `coverage::Error`s.\n #[derive(Debug)]\n-pub(crate) struct Error {\n+pub(self) struct Error {\n     message: String,\n }\n "}, {"sha": "f880d69bd64f69080627325796473cd75f815e44", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=bd0eb07af2deaff2c9f1e7553ea97341787779cd", "patch": "@@ -17,7 +17,7 @@ use rustc_span::{BytePos, Span, SyntaxContext};\n use std::cmp::Ordering;\n \n #[derive(Debug, Copy, Clone)]\n-pub(crate) enum CoverageStatement {\n+pub(super) enum CoverageStatement {\n     Statement(BasicBlock, Span, usize),\n     Terminator(BasicBlock, Span),\n }\n@@ -66,7 +66,7 @@ impl CoverageStatement {\n /// or is subsumed by the `Span` associated with this `CoverageSpan`, and it's `BasicBlock`\n /// `is_dominated_by()` the `BasicBlock`s in this `CoverageSpan`.\n #[derive(Debug, Clone)]\n-pub(crate) struct CoverageSpan {\n+pub(super) struct CoverageSpan {\n     pub span: Span,\n     pub bcb: BasicCoverageBlock,\n     pub coverage_statements: Vec<CoverageStatement>,\n@@ -214,7 +214,7 @@ pub struct CoverageSpans<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n-    pub(crate) fn generate_coverage_spans(\n+    pub(super) fn generate_coverage_spans(\n         mir_body: &'a mir::Body<'tcx>,\n         body_span: Span,\n         basic_coverage_blocks: &'a CoverageGraph,"}, {"sha": "a9d6f0c803d2e2de2ff3c822663dccbcd2416b55", "filename": "compiler/rustc_mir/src/transform/coverage/test_macros/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2FCargo.toml?ref=bd0eb07af2deaff2c9f1e7553ea97341787779cd", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"coverage_test_macros\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+proc-macro = true\n+doctest = false\n+\n+[dependencies]\n+proc-macro2 = \"1\""}, {"sha": "ea551c7745556ea1c38bba73a5e810abb3575a55", "filename": "compiler/rustc_mir/src/transform/coverage/test_macros/src/lib.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2Fsrc%2Flib.rs?ref=bd0eb07af2deaff2c9f1e7553ea97341787779cd", "patch": "@@ -0,0 +1,8 @@\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn let_bcb(item: TokenStream) -> TokenStream {\n+    format!(\"let bcb{} = graph::BasicCoverageBlock::from_usize({}); let _ = {};\", item, item, item)\n+        .parse()\n+        .unwrap()\n+}"}, {"sha": "2231fe6427fa2a24887f14ee22adcc565bb257a8", "filename": "compiler/rustc_mir/src/transform/coverage/tests.rs", "status": "added", "additions": 631, "deletions": 0, "changes": 631, "blob_url": "https://github.com/rust-lang/rust/blob/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd0eb07af2deaff2c9f1e7553ea97341787779cd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs?ref=bd0eb07af2deaff2c9f1e7553ea97341787779cd", "patch": "@@ -0,0 +1,631 @@\n+use super::debug;\n+use super::graph;\n+\n+use coverage_test_macros::let_bcb;\n+\n+use rustc_data_structures::graph::WithNumNodes;\n+use rustc_data_structures::graph::WithSuccessors;\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::{self, TyS};\n+use rustc_span::DUMMY_SP;\n+\n+use std::lazy::SyncOnceCell;\n+\n+fn dummy_ty<'tcx>() -> &'static TyS<'tcx> {\n+    static DUMMY_TYS: SyncOnceCell<TyS<'_>> = SyncOnceCell::new();\n+\n+    &DUMMY_TYS.get_or_init(|| {\n+        let fake_type_bytes = vec![0 as u8; std::mem::size_of::<TyS<'_>>()];\n+        unsafe { std::ptr::read_unaligned::<TyS<'_>>(fake_type_bytes.as_ptr() as *const TyS<'_>) }\n+    })\n+}\n+\n+struct MockBlocks<'tcx> {\n+    blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    source_info: SourceInfo,\n+    dummy_place: Place<'tcx>,\n+    next_local: usize,\n+}\n+\n+impl<'tcx> MockBlocks<'tcx> {\n+    fn new() -> Self {\n+        Self {\n+            blocks: IndexVec::new(),\n+            source_info: SourceInfo::outermost(DUMMY_SP),\n+            dummy_place: Place { local: RETURN_PLACE, projection: ty::List::empty() },\n+            next_local: 0,\n+        }\n+    }\n+\n+    fn new_temp(&mut self) -> Local {\n+        let index = self.next_local;\n+        self.next_local += 1;\n+        Local::new(index)\n+    }\n+\n+    fn push(&mut self, num_nops: usize, kind: TerminatorKind<'tcx>) -> BasicBlock {\n+        let nop = Statement { source_info: self.source_info, kind: StatementKind::Nop };\n+\n+        self.blocks.push(BasicBlockData {\n+            statements: std::iter::repeat(&nop).cloned().take(num_nops).collect(),\n+            terminator: Some(Terminator { source_info: self.source_info, kind }),\n+            is_cleanup: false,\n+        })\n+    }\n+\n+    fn link(&mut self, from_block: BasicBlock, to_block: BasicBlock) {\n+        match self.blocks[from_block].terminator_mut().kind {\n+            TerminatorKind::Assert { ref mut target, .. }\n+            | TerminatorKind::Call { destination: Some((_, ref mut target)), .. }\n+            | TerminatorKind::Drop { ref mut target, .. }\n+            | TerminatorKind::DropAndReplace { ref mut target, .. }\n+            | TerminatorKind::FalseEdge { real_target: ref mut target, .. }\n+            | TerminatorKind::FalseUnwind { real_target: ref mut target, .. }\n+            | TerminatorKind::Goto { ref mut target }\n+            | TerminatorKind::InlineAsm { destination: Some(ref mut target), .. }\n+            | TerminatorKind::Yield { resume: ref mut target, .. } => *target = to_block,\n+            ref invalid => bug!(\"Invalid from_block: {:?}\", invalid),\n+        }\n+    }\n+\n+    fn add_block_from(\n+        &mut self,\n+        some_from_block: Option<BasicBlock>,\n+        to_kind: TerminatorKind<'tcx>,\n+    ) -> BasicBlock {\n+        let new_block = self.push(1, to_kind);\n+        if let Some(from_block) = some_from_block {\n+            self.link(from_block, new_block);\n+        }\n+        new_block\n+    }\n+\n+    fn set_branch(&mut self, switchint: BasicBlock, branch_index: usize, to_block: BasicBlock) {\n+        match self.blocks[switchint].terminator_mut().kind {\n+            TerminatorKind::SwitchInt { ref mut targets, .. } => {\n+                let mut branches = targets.iter().collect::<Vec<_>>();\n+                let otherwise = if branch_index == branches.len() {\n+                    to_block\n+                } else {\n+                    let old_otherwise = targets.otherwise();\n+                    if branch_index > branches.len() {\n+                        branches.push((branches.len() as u128, old_otherwise));\n+                        while branches.len() < branch_index {\n+                            branches.push((branches.len() as u128, START_BLOCK));\n+                        }\n+                        to_block\n+                    } else {\n+                        branches[branch_index] = (branch_index as u128, to_block);\n+                        old_otherwise\n+                    }\n+                };\n+                *targets = SwitchTargets::new(branches.into_iter(), otherwise);\n+            }\n+            ref invalid => bug!(\"Invalid BasicBlock kind or no to_block: {:?}\", invalid),\n+        }\n+    }\n+\n+    fn call(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n+        self.add_block_from(\n+            some_from_block,\n+            TerminatorKind::Call {\n+                func: Operand::Copy(self.dummy_place.clone()),\n+                args: vec![],\n+                destination: Some((self.dummy_place.clone(), START_BLOCK)),\n+                cleanup: None,\n+                from_hir_call: false,\n+                fn_span: DUMMY_SP,\n+            },\n+        )\n+    }\n+\n+    fn goto(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n+        self.add_block_from(some_from_block, TerminatorKind::Goto { target: START_BLOCK })\n+    }\n+\n+    fn switchint(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n+        let move_ = |place: Place<'tcx>| Operand::Move(place);\n+        let discriminant = Place::from(self.new_temp());\n+        let switchint_kind = TerminatorKind::SwitchInt {\n+            discr: move_(discriminant),\n+            switch_ty: dummy_ty(),\n+            targets: SwitchTargets::static_if(0, START_BLOCK, START_BLOCK),\n+        };\n+        self.add_block_from(some_from_block, switchint_kind)\n+    }\n+\n+    fn return_(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n+        self.add_block_from(some_from_block, TerminatorKind::Return)\n+    }\n+\n+    fn to_body(self) -> Body<'tcx> {\n+        Body::new_cfg_only(self.blocks)\n+    }\n+}\n+\n+fn debug_basic_blocks(mir_body: &Body<'tcx>) -> String {\n+    format!(\n+        \"{:?}\",\n+        mir_body\n+            .basic_blocks()\n+            .iter_enumerated()\n+            .map(|(bb, data)| {\n+                let kind = &data.terminator().kind;\n+                match kind {\n+                    TerminatorKind::Assert { target, .. }\n+                    | TerminatorKind::Call { destination: Some((_, target)), .. }\n+                    | TerminatorKind::Drop { target, .. }\n+                    | TerminatorKind::DropAndReplace { target, .. }\n+                    | TerminatorKind::FalseEdge { real_target: target, .. }\n+                    | TerminatorKind::FalseUnwind { real_target: target, .. }\n+                    | TerminatorKind::Goto { target }\n+                    | TerminatorKind::InlineAsm { destination: Some(target), .. }\n+                    | TerminatorKind::Yield { resume: target, .. } => {\n+                        format!(\"{:?}:{} -> {:?}\", bb, debug::term_type(kind), target)\n+                    }\n+                    TerminatorKind::SwitchInt { targets, .. } => {\n+                        format!(\"{:?}:{} -> {:?}\", bb, debug::term_type(kind), targets)\n+                    }\n+                    _ => format!(\"{:?}:{}\", bb, debug::term_type(kind)),\n+                }\n+            })\n+            .collect::<Vec<_>>()\n+    )\n+}\n+\n+static PRINT_GRAPHS: bool = false;\n+\n+fn print_mir_graphviz(name: &str, mir_body: &Body<'_>) {\n+    if PRINT_GRAPHS {\n+        println!(\n+            \"digraph {} {{\\n{}\\n}}\",\n+            name,\n+            mir_body\n+                .basic_blocks()\n+                .iter_enumerated()\n+                .map(|(bb, data)| {\n+                    format!(\n+                        \"    {:?} [label=\\\"{:?}: {}\\\"];\\n{}\",\n+                        bb,\n+                        bb,\n+                        debug::term_type(&data.terminator().kind),\n+                        mir_body\n+                            .successors(bb)\n+                            .map(|successor| { format!(\"    {:?} -> {:?};\", bb, successor) })\n+                            .collect::<Vec<_>>()\n+                            .join(\"\\n\")\n+                    )\n+                })\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\")\n+        );\n+    }\n+}\n+\n+fn print_coverage_graphviz(\n+    name: &str,\n+    mir_body: &Body<'_>,\n+    basic_coverage_blocks: &graph::CoverageGraph,\n+) {\n+    if PRINT_GRAPHS {\n+        println!(\n+            \"digraph {} {{\\n{}\\n}}\",\n+            name,\n+            basic_coverage_blocks\n+                .iter_enumerated()\n+                .map(|(bcb, bcb_data)| {\n+                    format!(\n+                        \"    {:?} [label=\\\"{:?}: {}\\\"];\\n{}\",\n+                        bcb,\n+                        bcb,\n+                        debug::term_type(&bcb_data.terminator(mir_body).kind),\n+                        basic_coverage_blocks\n+                            .successors(bcb)\n+                            .map(|successor| { format!(\"    {:?} -> {:?};\", bcb, successor) })\n+                            .collect::<Vec<_>>()\n+                            .join(\"\\n\")\n+                    )\n+                })\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\")\n+        );\n+    }\n+}\n+\n+/// Create a mock `Body` with a simple flow.\n+fn mir_goto_switchint() -> Body<'a> {\n+    let mut blocks = MockBlocks::new();\n+    let start = blocks.call(None);\n+    let goto = blocks.goto(Some(start));\n+    let switchint = blocks.switchint(Some(goto));\n+    let then_call = blocks.call(None);\n+    let else_call = blocks.call(None);\n+    blocks.set_branch(switchint, 0, then_call);\n+    blocks.set_branch(switchint, 1, else_call);\n+    blocks.return_(Some(then_call));\n+    blocks.return_(Some(else_call));\n+\n+    let mir_body = blocks.to_body();\n+    print_mir_graphviz(\"mir_goto_switchint\", &mir_body);\n+    /* Graphviz character plots created using: `graph-easy --as=boxart`:\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502   bb0: Call    \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502   bb1: Goto    \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502  bb4: Call  \u2502 \u25c0\u2500\u2500 \u2502 bb2: SwitchInt \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                   \u2502\n+      \u2502                   \u2502\n+      \u25bc                   \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bb6: Return \u2502     \u2502   bb3: Call    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502  bb5: Return   \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    mir_body\n+}\n+\n+fn covgraph_goto_switchint() -> graph::CoverageGraph {\n+    let mir_body = mir_goto_switchint();\n+    if false {\n+        println!(\"basic_blocks = {}\", debug_basic_blocks(&mir_body));\n+    }\n+    let covgraph = graph::CoverageGraph::from_mir(&mir_body);\n+    print_coverage_graphviz(\"covgraph_goto_switchint \", &mir_body, &covgraph);\n+    /*\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bcb2: Return \u2502 \u25c0\u2500\u2500 \u2502 bcb0: SwitchInt \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                           \u2502\n+                           \u2502\n+                           \u25bc\n+                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                         \u2502  bcb1: Return   \u2502\n+                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    covgraph\n+}\n+\n+/// Create a mock `Body` with a loop.\n+fn mir_switchint_then_loop_else_return() -> Body<'a> {\n+    let mut blocks = MockBlocks::new();\n+    let start = blocks.call(None);\n+    let switchint = blocks.switchint(Some(start));\n+    let then_call = blocks.call(None);\n+    blocks.set_branch(switchint, 0, then_call);\n+    let backedge_goto = blocks.goto(Some(then_call));\n+    blocks.link(backedge_goto, switchint);\n+    let else_return = blocks.return_(None);\n+    blocks.set_branch(switchint, 1, else_return);\n+\n+    let mir_body = blocks.to_body();\n+    print_mir_graphviz(\"mir_switchint_then_loop_else_return\", &mir_body);\n+    /*\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502   bb0: Call    \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bb4: Return \u2502 \u25c0\u2500\u2500 \u2502 bb1: SwitchInt \u2502 \u25c0\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                          \u2502                 \u2502\n+                          \u2502                 \u2502\n+                          \u25bc                 \u2502\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+                        \u2502   bb2: Call    \u2502  \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                          \u2502                 \u2502\n+                          \u2502                 \u2502\n+                          \u25bc                 \u2502\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+                        \u2502   bb3: Goto    \u2502 \u2500\u2518\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    mir_body\n+}\n+\n+fn covgraph_switchint_then_loop_else_return() -> graph::CoverageGraph {\n+    let mir_body = mir_switchint_then_loop_else_return();\n+    let covgraph = graph::CoverageGraph::from_mir(&mir_body);\n+    print_coverage_graphviz(\"covgraph_switchint_then_loop_else_return\", &mir_body, &covgraph);\n+    /*\n+                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                       \u2502   bcb0: Call    \u2502\n+                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                         \u2502\n+                         \u2502\n+                         \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bcb3: Goto \u2502 \u25c0\u2500\u2500 \u2502 bcb1: SwitchInt \u2502 \u25c0\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+      \u2502                  \u2502                  \u2502\n+      \u2502                  \u2502                  \u2502\n+      \u2502                  \u25bc                  \u2502\n+      \u2502                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+      \u2502                \u2502  bcb2: Return   \u2502  \u2502\n+      \u2502                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+      \u2502                                     \u2502\n+      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    covgraph\n+}\n+\n+/// Create a mock `Body` with nested loops.\n+fn mir_switchint_loop_then_inner_loop_else_break() -> Body<'a> {\n+    let mut blocks = MockBlocks::new();\n+    let start = blocks.call(None);\n+    let switchint = blocks.switchint(Some(start));\n+    let then_call = blocks.call(None);\n+    blocks.set_branch(switchint, 0, then_call);\n+    let else_return = blocks.return_(None);\n+    blocks.set_branch(switchint, 1, else_return);\n+\n+    let inner_start = blocks.call(Some(then_call));\n+    let inner_switchint = blocks.switchint(Some(inner_start));\n+    let inner_then_call = blocks.call(None);\n+    blocks.set_branch(inner_switchint, 0, inner_then_call);\n+    let inner_backedge_goto = blocks.goto(Some(inner_then_call));\n+    blocks.link(inner_backedge_goto, inner_switchint);\n+    let inner_else_break_goto = blocks.goto(None);\n+    blocks.set_branch(inner_switchint, 1, inner_else_break_goto);\n+\n+    let backedge_goto = blocks.goto(Some(inner_else_break_goto));\n+    blocks.link(backedge_goto, switchint);\n+\n+    let mir_body = blocks.to_body();\n+    print_mir_graphviz(\"mir_switchint_loop_then_inner_loop_else_break\", &mir_body);\n+    /*\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502   bb0: Call    \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bb3: Return \u2502 \u25c0\u2500\u2500 \u2502 bb1: SwitchInt \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+                          \u2502                      \u2502\n+                          \u2502                      \u2502\n+                          \u25bc                      \u2502\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n+                        \u2502   bb2: Call    \u2502       \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+                          \u2502                      \u2502\n+                          \u2502                      \u2502\n+                          \u25bc                      \u2502\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n+                        \u2502   bb4: Call    \u2502       \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+                          \u2502                      \u2502\n+                          \u2502                      \u2502\n+                          \u25bc                      \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n+    \u2502  bb8: Goto  \u2502 \u25c0\u2500\u2500 \u2502 bb5: SwitchInt \u2502 \u25c0\u2510    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502\n+      \u2502                   \u2502                 \u2502    \u2502\n+      \u2502                   \u2502                 \u2502    \u2502\n+      \u25bc                   \u25bc                 \u2502    \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502\n+    \u2502  bb9: Goto  \u2502 \u2500\u2510  \u2502   bb6: Call    \u2502  \u2502    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502\n+                     \u2502    \u2502                 \u2502    \u2502\n+                     \u2502    \u2502                 \u2502    \u2502\n+                     \u2502    \u25bc                 \u2502    \u2502\n+                     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502\n+                     \u2502  \u2502   bb7: Goto    \u2502 \u2500\u2518    \u2502\n+                     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+                     \u2502                           \u2502\n+                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    mir_body\n+}\n+\n+fn covgraph_switchint_loop_then_inner_loop_else_break() -> graph::CoverageGraph {\n+    let mir_body = mir_switchint_loop_then_inner_loop_else_break();\n+    let covgraph = graph::CoverageGraph::from_mir(&mir_body);\n+    print_coverage_graphviz(\n+        \"covgraph_switchint_loop_then_inner_loop_else_break\",\n+        &mir_body,\n+        &covgraph,\n+    );\n+    /*\n+                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                         \u2502   bcb0: Call    \u2502\n+                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                           \u2502\n+                           \u2502\n+                           \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bcb2: Return \u2502 \u25c0\u2500\u2500 \u2502 bcb1: SwitchInt \u2502 \u25c0\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                           \u2502                  \u2502\n+                           \u2502                  \u2502\n+                           \u25bc                  \u2502\n+                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+                         \u2502   bcb3: Call    \u2502  \u2502\n+                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                           \u2502                  \u2502\n+                           \u2502                  \u2502\n+                           \u25bc                  \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+    \u2502  bcb6: Goto  \u2502 \u25c0\u2500\u2500 \u2502 bcb4: SwitchInt \u2502 \u25c0\u253c\u2500\u2500\u2500\u2500\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502\n+      \u2502                    \u2502                  \u2502    \u2502\n+      \u2502                    \u2502                  \u2502    \u2502\n+      \u2502                    \u25bc                  \u2502    \u2502\n+      \u2502                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502\n+      \u2502                  \u2502   bcb5: Goto    \u2502 \u2500\u2518    \u2502\n+      \u2502                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+      \u2502                                            \u2502\n+      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    covgraph\n+}\n+\n+macro_rules! assert_successors {\n+    ($basic_coverage_blocks:ident, $i:ident, [$($successor:ident),*]) => {\n+        let mut successors = $basic_coverage_blocks.successors[$i].clone();\n+        successors.sort_unstable();\n+        assert_eq!(successors, vec![$($successor),*]);\n+    }\n+}\n+\n+#[test]\n+fn test_covgraph_goto_switchint() {\n+    let basic_coverage_blocks = covgraph_goto_switchint();\n+    assert_eq!(\n+        basic_coverage_blocks.num_nodes(),\n+        3,\n+        \"basic_coverage_blocks: {:?}\",\n+        basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+    );\n+\n+    let_bcb!(0);\n+    let_bcb!(1);\n+    let_bcb!(2);\n+\n+    assert_successors!(basic_coverage_blocks, bcb0, [bcb1, bcb2]);\n+    assert_successors!(basic_coverage_blocks, bcb1, []);\n+    assert_successors!(basic_coverage_blocks, bcb2, []);\n+}\n+\n+#[test]\n+fn test_find_loop_backedges_none() {\n+    let basic_coverage_blocks = covgraph_goto_switchint();\n+    if false {\n+        println!(\n+            \"basic_coverage_blocks = {:?}\",\n+            basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+        );\n+        println!(\"successors = {:?}\", basic_coverage_blocks.successors);\n+    }\n+    let backedges = graph::find_loop_backedges(&basic_coverage_blocks);\n+    assert_eq!(\n+        backedges.iter_enumerated().map(|(_bcb, backedges)| backedges.len()).sum::<usize>(),\n+        0,\n+        \"backedges: {:?}\",\n+        backedges\n+    );\n+}\n+\n+#[test]\n+fn test_covgraph_switchint_then_loop_else_return() {\n+    let basic_coverage_blocks = covgraph_switchint_then_loop_else_return();\n+    assert_eq!(\n+        basic_coverage_blocks.num_nodes(),\n+        4,\n+        \"basic_coverage_blocks: {:?}\",\n+        basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+    );\n+\n+    let_bcb!(0);\n+    let_bcb!(1);\n+    let_bcb!(2);\n+    let_bcb!(3);\n+\n+    assert_successors!(basic_coverage_blocks, bcb0, [bcb1]);\n+    assert_successors!(basic_coverage_blocks, bcb1, [bcb2, bcb3]);\n+    assert_successors!(basic_coverage_blocks, bcb2, []);\n+    assert_successors!(basic_coverage_blocks, bcb3, [bcb1]);\n+}\n+\n+#[test]\n+fn test_find_loop_backedges_one() {\n+    let basic_coverage_blocks = covgraph_switchint_then_loop_else_return();\n+    let backedges = graph::find_loop_backedges(&basic_coverage_blocks);\n+    assert_eq!(\n+        backedges.iter_enumerated().map(|(_bcb, backedges)| backedges.len()).sum::<usize>(),\n+        1,\n+        \"backedges: {:?}\",\n+        backedges\n+    );\n+\n+    let_bcb!(1);\n+    let_bcb!(3);\n+\n+    assert_eq!(backedges[bcb1], vec![bcb3]);\n+}\n+\n+#[test]\n+fn test_covgraph_switchint_loop_then_inner_loop_else_break() {\n+    let basic_coverage_blocks = covgraph_switchint_loop_then_inner_loop_else_break();\n+    assert_eq!(\n+        basic_coverage_blocks.num_nodes(),\n+        7,\n+        \"basic_coverage_blocks: {:?}\",\n+        basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+    );\n+\n+    let_bcb!(0);\n+    let_bcb!(1);\n+    let_bcb!(2);\n+    let_bcb!(3);\n+    let_bcb!(4);\n+    let_bcb!(5);\n+    let_bcb!(6);\n+\n+    assert_successors!(basic_coverage_blocks, bcb0, [bcb1]);\n+    assert_successors!(basic_coverage_blocks, bcb1, [bcb2, bcb3]);\n+    assert_successors!(basic_coverage_blocks, bcb2, []);\n+    assert_successors!(basic_coverage_blocks, bcb3, [bcb4]);\n+    assert_successors!(basic_coverage_blocks, bcb4, [bcb5, bcb6]);\n+    assert_successors!(basic_coverage_blocks, bcb5, [bcb1]);\n+    assert_successors!(basic_coverage_blocks, bcb6, [bcb4]);\n+}\n+\n+#[test]\n+fn test_find_loop_backedges_two() {\n+    let basic_coverage_blocks = covgraph_switchint_loop_then_inner_loop_else_break();\n+    let backedges = graph::find_loop_backedges(&basic_coverage_blocks);\n+    assert_eq!(\n+        backedges.iter_enumerated().map(|(_bcb, backedges)| backedges.len()).sum::<usize>(),\n+        2,\n+        \"backedges: {:?}\",\n+        backedges\n+    );\n+\n+    let_bcb!(1);\n+    let_bcb!(4);\n+    let_bcb!(5);\n+    let_bcb!(6);\n+\n+    assert_eq!(backedges[bcb1], vec![bcb5]);\n+    assert_eq!(backedges[bcb4], vec![bcb6]);\n+}\n+\n+#[test]\n+fn test_traverse_coverage_with_loops() {\n+    let basic_coverage_blocks = covgraph_switchint_loop_then_inner_loop_else_break();\n+    let mut traversed_in_order = Vec::new();\n+    let mut traversal = graph::TraverseCoverageGraphWithLoops::new(&basic_coverage_blocks);\n+    while let Some(bcb) = traversal.next(&basic_coverage_blocks) {\n+        traversed_in_order.push(bcb);\n+    }\n+\n+    let_bcb!(6);\n+\n+    // bcb0 is visited first. Then bcb1 starts the first loop, and all remaining nodes, *except*\n+    // bcb6 are inside the first loop.\n+    assert_eq!(\n+        *traversed_in_order.last().expect(\"should have elements\"),\n+        bcb6,\n+        \"bcb6 should not be visited until all nodes inside the first loop have been visited\"\n+    );\n+}"}]}