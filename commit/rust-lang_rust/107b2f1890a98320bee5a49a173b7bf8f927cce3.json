{"sha": "107b2f1890a98320bee5a49a173b7bf8f927cce3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwN2IyZjE4OTBhOTgzMjBiZWU1YTQ5YTE3M2I3YmY4ZjkyN2NjZTM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-22T14:53:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-22T14:53:41Z"}, "message": "Merge #9972\n\n9972: refactor : function generation assists r=Veykril a=mahdi-frms\n\nSeparated code generation from finding position for generated code. This will be ground work for introducing static associated function generation.\n\nCo-authored-by: mahdi-frms <mahdif1380@outlook.com>", "tree": {"sha": "618f577351b67c2e6d44ec3dc7ede4c49aa32d84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/618f577351b67c2e6d44ec3dc7ede4c49aa32d84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/107b2f1890a98320bee5a49a173b7bf8f927cce3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhImT1CRBK7hj4Ov3rIwAADLUIAG4/8pjn4a2reKfeKP4XxrVA\nbf/JvIYf2O5ZAVxhNKal56vArRxE+7KKUeqv6I/mtR643Xur4K5XooBZPMB9Yfmg\nTLAiK+yPIPEH7o2pRqx/RDtszHv3b13nI2+VVbacD71L+SmAs6c27aSUlW/pQ5vK\nImOobqXT6QsI332G0As0uFaTEgct0eAcf9uk34JcKqvYzwgN7TquUxykdfD36iiF\nw0IbPdtYV4pUldh5JfqlP4bG+UwRysKSsl0oGDmk1rVp4QdffqsHJI60M6NbOxvH\nJLhptGBe3TaLbs1PsKbpX+ImGLCbdMzSxm6pESTidt9KU+bramp+qdTxDL7RiG0=\n=+HxN\n-----END PGP SIGNATURE-----\n", "payload": "tree 618f577351b67c2e6d44ec3dc7ede4c49aa32d84\nparent c6baf3dcf8004953dcfbbef814fea3a3deed4cf1\nparent c1edbfbacce28f26e1bb5a93acc6fe5385da28c7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1629644021 +0000\ncommitter GitHub <noreply@github.com> 1629644021 +0000\n\nMerge #9972\n\n9972: refactor : function generation assists r=Veykril a=mahdi-frms\n\nSeparated code generation from finding position for generated code. This will be ground work for introducing static associated function generation.\n\nCo-authored-by: mahdi-frms <mahdif1380@outlook.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/107b2f1890a98320bee5a49a173b7bf8f927cce3", "html_url": "https://github.com/rust-lang/rust/commit/107b2f1890a98320bee5a49a173b7bf8f927cce3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/107b2f1890a98320bee5a49a173b7bf8f927cce3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6baf3dcf8004953dcfbbef814fea3a3deed4cf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6baf3dcf8004953dcfbbef814fea3a3deed4cf1", "html_url": "https://github.com/rust-lang/rust/commit/c6baf3dcf8004953dcfbbef814fea3a3deed4cf1"}, {"sha": "c1edbfbacce28f26e1bb5a93acc6fe5385da28c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1edbfbacce28f26e1bb5a93acc6fe5385da28c7", "html_url": "https://github.com/rust-lang/rust/commit/c1edbfbacce28f26e1bb5a93acc6fe5385da28c7"}], "stats": {"total": 177, "additions": 95, "deletions": 82}, "files": [{"sha": "6e5d78b1ea5814f2e152e4ef665a60dda3fb962a", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 95, "deletions": 82, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/107b2f1890a98320bee5a49a173b7bf8f927cce3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107b2f1890a98320bee5a49a173b7bf8f927cce3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=107b2f1890a98320bee5a49a173b7bf8f927cce3", "patch": "@@ -6,9 +6,9 @@ use syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n-        make, ArgListOwner, AstNode, ModuleItemOwner,\n+        make, ArgListOwner, AstNode, CallExpr, ModuleItemOwner,\n     },\n-    SyntaxKind, SyntaxNode, TextSize,\n+    SyntaxKind, SyntaxNode, TextRange, TextSize,\n };\n \n use crate::{\n@@ -85,31 +85,19 @@ fn gen_fn(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n         None => None,\n     };\n \n-    let function_builder = FunctionBuilder::from_call(ctx, &call, &path, target_module)?;\n+    let (target, file, insert_offset) = get_fn_target(ctx, &target_module, call.clone())?;\n+    let function_builder = FunctionBuilder::from_call(ctx, &call, &path, target_module, target)?;\n     let target = call.syntax().text_range();\n-\n-    acc.add(\n-        AssistId(\"generate_function\", AssistKind::Generate),\n-        format!(\"Generate `{}` function\", function_builder.fn_name),\n-        target,\n-        |builder| {\n-            let function_template = function_builder.render();\n-            builder.edit_file(function_template.file);\n-            let new_fn = function_template.to_string(ctx.config.snippet_cap);\n-            match ctx.config.snippet_cap {\n-                Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),\n-                None => builder.insert(function_template.insert_offset, new_fn),\n-            }\n-        },\n-    )\n+    let label = format!(\"Generate {} function\", function_builder.fn_name.clone());\n+    add_func_to_accumulator(acc, ctx, target, function_builder, insert_offset, file, None, label)\n }\n \n fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n     let fn_name = call.name_ref()?;\n     let adt = ctx.sema.type_of_expr(&call.receiver()?)?.original().strip_references().as_adt()?;\n \n-    let current_module = ctx.sema.scope(call.syntax()).module()?;\n+    let current_module = current_module(call.syntax(), ctx)?;\n     let target_module = adt.module(ctx.sema.db);\n \n     if current_module.krate() != target_module.krate() {\n@@ -122,44 +110,58 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n         ctx.sema.find_node_at_offset_with_macros(file.syntax(), range.range.start())?;\n     let impl_ = find_struct_impl(ctx, &adt_source, fn_name.text().as_str())?;\n \n-    let function_builder = FunctionBuilder::from_method_call(\n+    let (target, insert_offset) = get_method_target(ctx, &target_module, &impl_)?;\n+    let function_builder =\n+        FunctionBuilder::from_method_call(ctx, &call, &fn_name, target_module, target)?;\n+    let text_range = call.syntax().text_range();\n+    let adt_name = if impl_.is_none() { Some(adt.name(ctx.sema.db)) } else { None };\n+    let label = format!(\"Generate {} method\", function_builder.fn_name.clone());\n+    add_func_to_accumulator(\n+        acc,\n         ctx,\n-        &call,\n-        &fn_name,\n-        &impl_,\n+        text_range,\n+        function_builder,\n+        insert_offset,\n         range.file_id,\n-        target_module,\n-        current_module,\n-    )?;\n-    let target = call.syntax().text_range();\n-\n-    acc.add(\n-        AssistId(\"generate_function\", AssistKind::Generate),\n-        format!(\"Generate `{}` method\", function_builder.fn_name),\n-        target,\n-        |builder| {\n-            let function_template = function_builder.render();\n-            builder.edit_file(function_template.file);\n-            let mut new_fn = function_template.to_string(ctx.config.snippet_cap);\n-            if impl_.is_none() {\n-                new_fn = format!(\"\\nimpl {} {{\\n{}\\n}}\", adt.name(ctx.sema.db), new_fn,);\n-            }\n-            match ctx.config.snippet_cap {\n-                Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),\n-                None => builder.insert(function_template.insert_offset, new_fn),\n-            }\n-        },\n+        adt_name,\n+        label,\n     )\n }\n \n-struct FunctionTemplate {\n+fn add_func_to_accumulator(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+    text_range: TextRange,\n+    function_builder: FunctionBuilder,\n     insert_offset: TextSize,\n+    file: FileId,\n+    adt_name: Option<hir::Name>,\n+    label: String,\n+) -> Option<()> {\n+    acc.add(AssistId(\"generate_function\", AssistKind::Generate), label, text_range, |builder| {\n+        let function_template = function_builder.render();\n+        let mut func = function_template.to_string(ctx.config.snippet_cap);\n+        if let Some(name) = adt_name {\n+            func = format!(\"\\nimpl {} {{\\n{}\\n}}\", name, func);\n+        }\n+        builder.edit_file(file);\n+        match ctx.config.snippet_cap {\n+            Some(cap) => builder.insert_snippet(cap, insert_offset, func),\n+            None => builder.insert(insert_offset, func),\n+        }\n+    })\n+}\n+\n+fn current_module(current_node: &SyntaxNode, ctx: &AssistContext) -> Option<Module> {\n+    ctx.sema.scope(current_node).module()\n+}\n+\n+struct FunctionTemplate {\n     leading_ws: String,\n     fn_def: ast::Fn,\n     ret_type: Option<ast::RetType>,\n     should_focus_return_type: bool,\n     trailing_ws: String,\n-    file: FileId,\n     tail_expr: ast::Expr,\n }\n \n@@ -193,7 +195,6 @@ struct FunctionBuilder {\n     params: ast::ParamList,\n     ret_type: Option<ast::RetType>,\n     should_focus_return_type: bool,\n-    file: FileId,\n     needs_pub: bool,\n     is_async: bool,\n }\n@@ -206,19 +207,10 @@ impl FunctionBuilder {\n         call: &ast::CallExpr,\n         path: &ast::Path,\n         target_module: Option<hir::Module>,\n+        target: GeneratedFunctionTarget,\n     ) -> Option<Self> {\n-        let mut file = ctx.frange.file_id;\n-        let target = match &target_module {\n-            Some(target_module) => {\n-                let module_source = target_module.definition_source(ctx.db());\n-                let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, &module_source)?;\n-                file = in_file;\n-                target\n-            }\n-            None => next_space_for_fn_after_call_site(FuncExpr::Func(call.clone()))?,\n-        };\n         let needs_pub = target_module.is_some();\n-        let target_module = target_module.or_else(|| ctx.sema.scope(target.syntax()).module())?;\n+        let target_module = target_module.or_else(|| current_module(target.syntax(), ctx))?;\n         let fn_name = fn_name(path)?;\n         let (type_params, params) = fn_args(ctx, target_module, FuncExpr::Func(call.clone()))?;\n \n@@ -235,7 +227,6 @@ impl FunctionBuilder {\n             params,\n             ret_type,\n             should_focus_return_type,\n-            file,\n             needs_pub,\n             is_async,\n         })\n@@ -245,25 +236,11 @@ impl FunctionBuilder {\n         ctx: &AssistContext,\n         call: &ast::MethodCallExpr,\n         name: &ast::NameRef,\n-        impl_: &Option<ast::Impl>,\n-        file: FileId,\n         target_module: Module,\n-        current_module: Module,\n+        target: GeneratedFunctionTarget,\n     ) -> Option<Self> {\n-        // let mut file = ctx.frange.file_id;\n-        // let target_module = ctx.sema.scope(call.syntax()).module()?;\n-        let target = match impl_ {\n-            Some(impl_) => next_space_for_fn_in_impl(&impl_)?,\n-            None => {\n-                next_space_for_fn_in_module(\n-                    ctx.sema.db,\n-                    &target_module.definition_source(ctx.sema.db),\n-                )?\n-                .1\n-            }\n-        };\n-        let needs_pub = !module_is_descendant(&current_module, &target_module, ctx);\n-\n+        let needs_pub =\n+            !module_is_descendant(&current_module(call.syntax(), ctx)?, &target_module, ctx);\n         let fn_name = make::name(&name.text());\n         let (type_params, params) = fn_args(ctx, target_module, FuncExpr::Method(call.clone()))?;\n \n@@ -280,7 +257,6 @@ impl FunctionBuilder {\n             params,\n             ret_type,\n             should_focus_return_type,\n-            file,\n             needs_pub,\n             is_async,\n         })\n@@ -302,33 +278,29 @@ impl FunctionBuilder {\n         let leading_ws;\n         let trailing_ws;\n \n-        let insert_offset = match self.target {\n+        match self.target {\n             GeneratedFunctionTarget::BehindItem(it) => {\n                 let indent = IndentLevel::from_node(&it);\n                 leading_ws = format!(\"\\n\\n{}\", indent);\n                 fn_def = fn_def.indent(indent);\n                 trailing_ws = String::new();\n-                it.text_range().end()\n             }\n             GeneratedFunctionTarget::InEmptyItemList(it) => {\n                 let indent = IndentLevel::from_node(&it);\n                 leading_ws = format!(\"\\n{}\", indent + 1);\n                 fn_def = fn_def.indent(indent + 1);\n                 trailing_ws = format!(\"\\n{}\", indent);\n-                it.text_range().start() + TextSize::of('{')\n             }\n         };\n \n         FunctionTemplate {\n-            insert_offset,\n             leading_ws,\n             ret_type: fn_def.ret_type(),\n             // PANIC: we guarantee we always create a function body with a tail expr\n             tail_expr: fn_def.body().unwrap().tail_expr().unwrap(),\n             should_focus_return_type: self.should_focus_return_type,\n             fn_def,\n             trailing_ws,\n-            file: self.file,\n         }\n     }\n }\n@@ -365,6 +337,47 @@ fn make_return_type(\n     (ret_type, should_focus_return_type)\n }\n \n+fn get_fn_target(\n+    ctx: &AssistContext,\n+    target_module: &Option<Module>,\n+    call: CallExpr,\n+) -> Option<(GeneratedFunctionTarget, FileId, TextSize)> {\n+    let mut file = ctx.frange.file_id;\n+    let target = match target_module {\n+        Some(target_module) => {\n+            let module_source = target_module.definition_source(ctx.db());\n+            let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, &module_source)?;\n+            file = in_file;\n+            target\n+        }\n+        None => next_space_for_fn_after_call_site(FuncExpr::Func(call.clone()))?,\n+    };\n+    Some((target.clone(), file, get_insert_offset(&target)))\n+}\n+\n+fn get_method_target(\n+    ctx: &AssistContext,\n+    target_module: &Module,\n+    impl_: &Option<ast::Impl>,\n+) -> Option<(GeneratedFunctionTarget, TextSize)> {\n+    let target = match impl_ {\n+        Some(impl_) => next_space_for_fn_in_impl(&impl_)?,\n+        None => {\n+            next_space_for_fn_in_module(ctx.sema.db, &target_module.definition_source(ctx.sema.db))?\n+                .1\n+        }\n+    };\n+    Some((target.clone(), get_insert_offset(&target)))\n+}\n+\n+fn get_insert_offset(target: &GeneratedFunctionTarget) -> TextSize {\n+    match &target {\n+        GeneratedFunctionTarget::BehindItem(it) => it.text_range().end(),\n+        GeneratedFunctionTarget::InEmptyItemList(it) => it.text_range().start() + TextSize::of('{'),\n+    }\n+}\n+\n+#[derive(Clone)]\n enum GeneratedFunctionTarget {\n     BehindItem(SyntaxNode),\n     InEmptyItemList(SyntaxNode),"}]}