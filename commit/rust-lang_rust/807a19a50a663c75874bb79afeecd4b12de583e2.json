{"sha": "807a19a50a663c75874bb79afeecd4b12de583e2", "node_id": "C_kwDOAAsO6NoAKDgwN2ExOWE1MGE2NjNjNzU4NzRiYjc5YWZlZWNkNGIxMmRlNTgzZTI", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-15T00:44:32Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-15T00:44:32Z"}, "message": "Elaborate correctness comments", "tree": {"sha": "1e8c6e41e4bffd206b30d9abdad484bbc48a6d30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e8c6e41e4bffd206b30d9abdad484bbc48a6d30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/807a19a50a663c75874bb79afeecd4b12de583e2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKpK3AACgkQGBtJ+fOP\nM3QQOAv9HKXjPfDv1sGnUmfn0uSF9rvoft2uepfm89vktGFzC5FTomLv2u+bqizR\n5AYbDV+IXm9PSoTkY2PigOaLzb/wrO/R/yrO0okq2GRzfEvdP0b9AXCEgoAofuBt\n58ZFrOhsQr0WSRQF4zoICnnGq8UtFVqDpaV+C5FvBo926u28ffuJioOItI6sa8Ri\nfTtnNCLnkqqd5VAL78iXbJktLWdqN8d50jiUfPBykrNtIxXhgXEDkppUtr9ZtG2k\n5zgSmLLn+Ma2MYrzm2E3c6HxLxgly1DL3t+uej9Ihu5jtXTJl7KabeHu6iT/8mFg\nfBiF4/tG0uDS0C47WR4v1urfgYuT6PqvrcDcDd71PBxwipn5j9x3gWJ38kEHdUAD\nBOuNOAICQ7dda2PKZkb6pR54hWbx8V4o0y94IsNcu60L9bKLXxBfiiuvX+j+tUS/\n9pp6ZE9azMKOH45J2Zit/5GqNA5KMCS6Veoo9XQ8u92Q88d0PSvDb8sVUbiH4G8g\nz2UwLWPC\n=pJvb\n-----END PGP SIGNATURE-----", "payload": "tree 1e8c6e41e4bffd206b30d9abdad484bbc48a6d30\nparent 56a4c132b6c8661010b5a176d334fd2a0db7cf53\nauthor Andy Wang <cbeuw.andy@gmail.com> 1655253872 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1655253872 +0100\n\nElaborate correctness comments\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/807a19a50a663c75874bb79afeecd4b12de583e2", "html_url": "https://github.com/rust-lang/rust/commit/807a19a50a663c75874bb79afeecd4b12de583e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/807a19a50a663c75874bb79afeecd4b12de583e2/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56a4c132b6c8661010b5a176d334fd2a0db7cf53", "url": "https://api.github.com/repos/rust-lang/rust/commits/56a4c132b6c8661010b5a176d334fd2a0db7cf53", "html_url": "https://github.com/rust-lang/rust/commit/56a4c132b6c8661010b5a176d334fd2a0db7cf53"}], "stats": {"total": 51, "additions": 41, "deletions": 10}, "files": [{"sha": "37d694a32f80eb663f84a44a7b409e0041ebf797", "filename": "src/shims/unix/linux/sync.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/807a19a50a663c75874bb79afeecd4b12de583e2/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/807a19a50a663c75874bb79afeecd4b12de583e2/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=807a19a50a663c75874bb79afeecd4b12de583e2", "patch": "@@ -126,16 +126,47 @@ pub fn futex<'tcx>(\n                 Align::from_bytes(4).unwrap(),\n                 CheckInAllocMsg::MemoryAccessTest,\n             )?;\n-            // This SeqCst fence is paired with the SeqCst fence in futex_wake.\n-            // Together, they make sure that our read on addr observes the latest\n-            // value in modification order.\n+            // There may be a concurrent thread changing the value of addr\n+            // and then invoking the FUTEX_WAKE syscall. It is critical that the\n+            // effects of this and the other thread are correctly observed,\n+            // otherwise we will deadlock.\n             //\n-            // If there is another thread which has changed the value of\n-            // addr (to something other than expected) and called futex_wake\n-            // before we get to run, then we must not block our thread\n-            // because there'll be no one to wake us. We must see\n-            // the value changed by the other thread and return without\n-            // actually waiting.\n+            // There are two scenarios to consider:\n+            // 1. If we (FUTEX_WAIT) executes first, we'll push ourselves into\n+            //    the waiters queue and go to sleep. They (addr write & FUTEX_WAKE)\n+            //    will see us in the queue and wake us up.\n+            // 2. If they (addr write & FUTEX_WAKE) executes first, we must observe\n+            //    addr's new value. If we see an outdated value that happens to equal\n+            //    the expected val, then we'll put ourselves to sleep with no one to wake us\n+            //    up, so we end up with a deadlock. This is prevented by having a SeqCst\n+            //    fence inside FUTEX_WAKE syscall, and another SeqCst fence\n+            //    below, the atomic read on addr after the SeqCst fence is guaranteed\n+            //    not to see any value older than the addr write immediately before\n+            //    calling FUTEX_WAKE. We'll see futex_val != val and return without\n+            //    sleeping.\n+            //\n+            //    Note that the fences do not create any happens-before relationship.\n+            //    The read sees the write immediately before the fence not because\n+            //    one happens after the other, but is instead due to a guarantee unique\n+            //    to SeqCst fences that restricts what an atomic read placed AFTER the\n+            //    fence can see. The read still has to be atomic, otherwise it's a data\n+            //    race. This guarantee cannot be achieved with acquire-release fences\n+            //    since they only talk about reads placed BEFORE a fence - and places\n+            //    no restrictions on what the read itself can see, only that there is\n+            //    a happens-before between the fences IF the read happens to see the\n+            //    right value. This is useless to us, since we need the read itself\n+            //    to see an up-to-date value.\n+            //\n+            // It is also critical that the fence, the atomic load, and the comparison\n+            // altogether happen atomically. If the other thread's fence in FUTEX_WAKE\n+            // gets interleaved after our fence, then we lose the guarantee on the\n+            // atomic load being up-to-date; if the other thread's write on addr and FUTEX_WAKE\n+            // call are interleaved after the load but before the comparison, then we get a TOCTOU\n+            // race condition, and go to sleep thinking the other thread will wake us up,\n+            // even though they have already finished.\n+            //\n+            // Thankfully, preemptions cannot happen inside a Miri shim, so we do not need to\n+            // do anything special to guarantee fence-load-comparison atomicity.\n             this.atomic_fence(&[], AtomicFenceOp::SeqCst)?;\n             // Read an `i32` through the pointer, regardless of any wrapper types.\n             // It's not uncommon for `addr` to be passed as another type than `*mut i32`, such as `*const AtomicI32`.\n@@ -149,7 +180,7 @@ pub fn futex<'tcx>(\n                 )?\n                 .to_i32()?;\n             if val == futex_val {\n-                // The value still matches, so we block the trait make it wait for FUTEX_WAKE.\n+                // The value still matches, so we block the thread make it wait for FUTEX_WAKE.\n                 this.block_thread(thread);\n                 this.futex_wait(addr_usize, thread, bitset);\n                 // Succesfully waking up from FUTEX_WAIT always returns zero."}]}