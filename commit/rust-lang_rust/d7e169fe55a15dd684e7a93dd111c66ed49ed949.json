{"sha": "d7e169fe55a15dd684e7a93dd111c66ed49ed949", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZTE2OWZlNTVhMTVkZDY4NGU3YTkzZGQxMTFjNjZlZDQ5ZWQ5NDk=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-06T05:07:06Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-06T05:07:06Z"}, "message": "Borrow text from nodes of immutable syntax trees", "tree": {"sha": "5ae79079f66e095caebf1f39f5fad1be9de197dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ae79079f66e095caebf1f39f5fad1be9de197dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7e169fe55a15dd684e7a93dd111c66ed49ed949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7e169fe55a15dd684e7a93dd111c66ed49ed949", "html_url": "https://github.com/rust-lang/rust/commit/d7e169fe55a15dd684e7a93dd111c66ed49ed949", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7e169fe55a15dd684e7a93dd111c66ed49ed949/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc4fa504ea2723bd5083284cabf81b4c5806ed4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4fa504ea2723bd5083284cabf81b4c5806ed4b", "html_url": "https://github.com/rust-lang/rust/commit/dc4fa504ea2723bd5083284cabf81b4c5806ed4b"}], "stats": {"total": 74, "additions": 49, "deletions": 25}, "files": [{"sha": "8e6d7b092f144a40f25e35748cf7e57d128c2fb5", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d7e169fe55a15dd684e7a93dd111c66ed49ed949/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e169fe55a15dd684e7a93dd111c66ed49ed949/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=d7e169fe55a15dd684e7a93dd111c66ed49ed949", "patch": "@@ -1,30 +1,31 @@\n //! Various extension methods to ast Nodes, which are hard to code-generate.\n //! Extensions for various expressions live in a sibling `expr_extensions` module.\n \n-use std::{fmt, iter::successors};\n+use std::{borrow::Cow, fmt, iter::successors};\n \n use itertools::Itertools;\n use parser::SyntaxKind;\n+use rowan::{GreenNodeData, GreenTokenData, NodeOrToken};\n \n use crate::{\n     ast::{self, support, AstNode, AstToken, AttrsOwner, NameOwner, SyntaxNode},\n     SmolStr, SyntaxElement, SyntaxToken, TokenText, T,\n };\n \n impl ast::Lifetime {\n-    pub fn text(&self) -> TokenText {\n+    pub fn text(&self) -> TokenText<'_> {\n         text_of_first_token(self.syntax())\n     }\n }\n \n impl ast::Name {\n-    pub fn text(&self) -> TokenText {\n+    pub fn text(&self) -> TokenText<'_> {\n         text_of_first_token(self.syntax())\n     }\n }\n \n impl ast::NameRef {\n-    pub fn text(&self) -> TokenText {\n+    pub fn text(&self) -> TokenText<'_> {\n         text_of_first_token(self.syntax())\n     }\n \n@@ -33,11 +34,28 @@ impl ast::NameRef {\n     }\n }\n \n-fn text_of_first_token(node: &SyntaxNode) -> TokenText {\n-    let first_token =\n-        node.green().children().next().and_then(|it| it.into_token()).unwrap().to_owned();\n+fn _text_of_first_token(node: &SyntaxNode) -> Cow<'_, str> {\n+    fn cow_map<F: FnOnce(&GreenNodeData) -> &str>(green: Cow<GreenNodeData>, f: F) -> Cow<str> {\n+        match green {\n+            Cow::Borrowed(green_ref) => Cow::Borrowed(f(green_ref)),\n+            Cow::Owned(green) => Cow::Owned(f(&green).to_owned()),\n+        }\n+    }\n+\n+    cow_map(node.green(), |green_ref| {\n+        green_ref.children().next().and_then(NodeOrToken::into_token).unwrap().text()\n+    })\n+}\n \n-    TokenText(first_token)\n+fn text_of_first_token(node: &SyntaxNode) -> TokenText<'_> {\n+    fn first_token(green_ref: &GreenNodeData) -> &GreenTokenData {\n+        green_ref.children().next().and_then(NodeOrToken::into_token).unwrap()\n+    }\n+\n+    match node.green() {\n+        Cow::Borrowed(green_ref) => TokenText::Borrowed(first_token(green_ref).text()),\n+        Cow::Owned(green) => TokenText::Owned(first_token(&green).to_owned()),\n+    }\n }\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n@@ -412,7 +430,7 @@ impl fmt::Display for NameOrNameRef {\n }\n \n impl NameOrNameRef {\n-    pub fn text(&self) -> TokenText {\n+    pub fn text(&self) -> TokenText<'_> {\n         match self {\n             NameOrNameRef::Name(name) => name.text(),\n             NameOrNameRef::NameRef(name_ref) => name_ref.text(),"}, {"sha": "e29f4eea40253b221463575af86615a4d6b36416", "filename": "crates/syntax/src/token_text.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d7e169fe55a15dd684e7a93dd111c66ed49ed949/crates%2Fsyntax%2Fsrc%2Ftoken_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e169fe55a15dd684e7a93dd111c66ed49ed949/crates%2Fsyntax%2Fsrc%2Ftoken_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Ftoken_text.rs?ref=d7e169fe55a15dd684e7a93dd111c66ed49ed949", "patch": "@@ -2,75 +2,81 @@\n \n use std::{cmp::Ordering, fmt, ops};\n \n-pub struct TokenText(pub(crate) rowan::GreenToken);\n+pub enum TokenText<'a> {\n+    Borrowed(&'a str),\n+    Owned(rowan::GreenToken),\n+}\n \n-impl TokenText {\n+impl TokenText<'_> {\n     pub fn as_str(&self) -> &str {\n-        self.0.text()\n+        match self {\n+            TokenText::Borrowed(it) => *it,\n+            TokenText::Owned(green) => green.text(),\n+        }\n     }\n }\n \n-impl ops::Deref for TokenText {\n+impl ops::Deref for TokenText<'_> {\n     type Target = str;\n \n     fn deref(&self) -> &str {\n         self.as_str()\n     }\n }\n-impl AsRef<str> for TokenText {\n+impl AsRef<str> for TokenText<'_> {\n     fn as_ref(&self) -> &str {\n         self.as_str()\n     }\n }\n \n-impl From<TokenText> for String {\n+impl From<TokenText<'_>> for String {\n     fn from(token_text: TokenText) -> Self {\n         token_text.as_str().into()\n     }\n }\n \n-impl PartialEq<&'_ str> for TokenText {\n+impl PartialEq<&'_ str> for TokenText<'_> {\n     fn eq(&self, other: &&str) -> bool {\n         self.as_str() == *other\n     }\n }\n-impl PartialEq<TokenText> for &'_ str {\n+impl PartialEq<TokenText<'_>> for &'_ str {\n     fn eq(&self, other: &TokenText) -> bool {\n         other == self\n     }\n }\n-impl PartialEq<String> for TokenText {\n+impl PartialEq<String> for TokenText<'_> {\n     fn eq(&self, other: &String) -> bool {\n         self.as_str() == other.as_str()\n     }\n }\n-impl PartialEq<TokenText> for String {\n+impl PartialEq<TokenText<'_>> for String {\n     fn eq(&self, other: &TokenText) -> bool {\n         other == self\n     }\n }\n-impl PartialEq for TokenText {\n+impl PartialEq for TokenText<'_> {\n     fn eq(&self, other: &TokenText) -> bool {\n         self.as_str() == other.as_str()\n     }\n }\n-impl Eq for TokenText {}\n-impl Ord for TokenText {\n+impl Eq for TokenText<'_> {}\n+impl Ord for TokenText<'_> {\n     fn cmp(&self, other: &Self) -> Ordering {\n         self.as_str().cmp(other.as_str())\n     }\n }\n-impl PartialOrd for TokenText {\n+impl PartialOrd for TokenText<'_> {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         Some(self.cmp(other))\n     }\n }\n-impl fmt::Display for TokenText {\n+impl fmt::Display for TokenText<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self.as_str(), f)\n     }\n }\n-impl fmt::Debug for TokenText {\n+impl fmt::Debug for TokenText<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(self.as_str(), f)\n     }"}]}