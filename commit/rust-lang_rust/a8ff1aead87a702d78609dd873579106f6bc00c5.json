{"sha": "a8ff1aead87a702d78609dd873579106f6bc00c5", "node_id": "C_kwDOAAsO6NoAKGE4ZmYxYWVhZDg3YTcwMmQ3ODYwOWRkODczNTc5MTA2ZjZiYzAwYzU", "commit": {"author": {"name": "Eduardo S\u00e1nchez Mu\u00f1oz", "email": "eduardosm-dev@e64.io", "date": "2022-04-01T16:32:02Z"}, "committer": {"name": "Eduardo S\u00e1nchez Mu\u00f1oz", "email": "eduardosm-dev@e64.io", "date": "2022-04-01T16:36:53Z"}, "message": "Avoid duplication of doc comments in `std::char` constants and functions.\n\nFor those consts and functions, only the summary is kept and a reference to the `char` associated const/method is included.\n\nAdditionaly, re-exported functions have been converted to function definitions that call the previously re-exported function. This makes it easier to add a deprecated attribute to these functions in the future.", "tree": {"sha": "7168fd23afc6db382757edbccf76c10f40c73b3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7168fd23afc6db382757edbccf76c10f40c73b3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8ff1aead87a702d78609dd873579106f6bc00c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8ff1aead87a702d78609dd873579106f6bc00c5", "html_url": "https://github.com/rust-lang/rust/commit/a8ff1aead87a702d78609dd873579106f6bc00c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8ff1aead87a702d78609dd873579106f6bc00c5/comments", "author": {"login": "eduardosm", "id": 761151, "node_id": "MDQ6VXNlcjc2MTE1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/761151?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eduardosm", "html_url": "https://github.com/eduardosm", "followers_url": "https://api.github.com/users/eduardosm/followers", "following_url": "https://api.github.com/users/eduardosm/following{/other_user}", "gists_url": "https://api.github.com/users/eduardosm/gists{/gist_id}", "starred_url": "https://api.github.com/users/eduardosm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eduardosm/subscriptions", "organizations_url": "https://api.github.com/users/eduardosm/orgs", "repos_url": "https://api.github.com/users/eduardosm/repos", "events_url": "https://api.github.com/users/eduardosm/events{/privacy}", "received_events_url": "https://api.github.com/users/eduardosm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eduardosm", "id": 761151, "node_id": "MDQ6VXNlcjc2MTE1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/761151?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eduardosm", "html_url": "https://github.com/eduardosm", "followers_url": "https://api.github.com/users/eduardosm/followers", "following_url": "https://api.github.com/users/eduardosm/following{/other_user}", "gists_url": "https://api.github.com/users/eduardosm/gists{/gist_id}", "starred_url": "https://api.github.com/users/eduardosm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eduardosm/subscriptions", "organizations_url": "https://api.github.com/users/eduardosm/orgs", "repos_url": "https://api.github.com/users/eduardosm/repos", "events_url": "https://api.github.com/users/eduardosm/events{/privacy}", "received_events_url": "https://api.github.com/users/eduardosm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0677edc86e342f333d4828b0ee1ef395a4e70fe5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0677edc86e342f333d4828b0ee1ef395a4e70fe5", "html_url": "https://github.com/rust-lang/rust/commit/0677edc86e342f333d4828b0ee1ef395a4e70fe5"}], "stats": {"total": 257, "additions": 54, "deletions": 203}, "files": [{"sha": "778f06aeb63e60f37c06546349dc6fa19120f79e", "filename": "library/core/src/char/convert.rs", "status": "modified", "additions": 7, "deletions": 132, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a8ff1aead87a702d78609dd873579106f6bc00c5/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ff1aead87a702d78609dd873579106f6bc00c5/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs?ref=a8ff1aead87a702d78609dd873579106f6bc00c5", "patch": "@@ -6,97 +6,22 @@ use crate::fmt;\n use crate::mem::transmute;\n use crate::str::FromStr;\n \n-/// Converts a `u32` to a `char`.\n-///\n-/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n-/// `as`:\n-///\n-/// ```\n-/// let c = '\ud83d\udcaf';\n-/// let i = c as u32;\n-///\n-/// assert_eq!(128175, i);\n-/// ```\n-///\n-/// However, the reverse is not true: not all valid [`u32`]s are valid\n-/// [`char`]s. `from_u32()` will return `None` if the input is not a valid value\n-/// for a [`char`].\n-///\n-/// For an unsafe version of this function which ignores these checks, see\n-/// [`from_u32_unchecked`].\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_u32(0x2764);\n-///\n-/// assert_eq!(Some('\u2764'), c);\n-/// ```\n-///\n-/// Returning `None` when the input is not a valid [`char`]:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_u32(0x110000);\n-///\n-/// assert_eq!(None, c);\n-/// ```\n-#[doc(alias = \"chr\")]\n+/// Converts a `u32` to a `char`. See [`char::from_u32`].\n #[must_use]\n #[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n-pub const fn from_u32(i: u32) -> Option<char> {\n+pub(super) const fn from_u32(i: u32) -> Option<char> {\n     // FIXME: once Result::ok is const fn, use it here\n     match char_try_from_u32(i) {\n         Ok(c) => Some(c),\n         Err(_) => None,\n     }\n }\n \n-/// Converts a `u32` to a `char`, ignoring validity.\n-///\n-/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n-/// `as`:\n-///\n-/// ```\n-/// let c = '\ud83d\udcaf';\n-/// let i = c as u32;\n-///\n-/// assert_eq!(128175, i);\n-/// ```\n-///\n-/// However, the reverse is not true: not all valid [`u32`]s are valid\n-/// [`char`]s. `from_u32_unchecked()` will ignore this, and blindly cast to\n-/// [`char`], possibly creating an invalid one.\n-///\n-/// # Safety\n-///\n-/// This function is unsafe, as it may construct invalid `char` values.\n-///\n-/// For a safe version of this function, see the [`from_u32`] function.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = unsafe { char::from_u32_unchecked(0x2764) };\n-///\n-/// assert_eq!('\u2764', c);\n-/// ```\n+/// Converts a `u32` to a `char`, ignoring validity. See [`char::from_u32_unchecked`].\n+#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n #[inline]\n #[must_use]\n-#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n-#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n-pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n+pub(super) const unsafe fn from_u32_unchecked(i: u32) -> char {\n     // SAFETY: the caller must guarantee that `i` is a valid char value.\n     if cfg!(debug_assertions) { char::from_u32(i).unwrap() } else { unsafe { transmute(i) } }\n }\n@@ -317,60 +242,10 @@ impl fmt::Display for CharTryFromError {\n     }\n }\n \n-/// Converts a digit in the given radix to a `char`.\n-///\n-/// A 'radix' here is sometimes also called a 'base'. A radix of two\n-/// indicates a binary number, a radix of ten, decimal, and a radix of\n-/// sixteen, hexadecimal, to give some common values. Arbitrary\n-/// radices are supported.\n-///\n-/// `from_digit()` will return `None` if the input is not a digit in\n-/// the given radix.\n-///\n-/// # Panics\n-///\n-/// Panics if given a radix larger than 36.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_digit(4, 10);\n-///\n-/// assert_eq!(Some('4'), c);\n-///\n-/// // Decimal 11 is a single digit in base 16\n-/// let c = char::from_digit(11, 16);\n-///\n-/// assert_eq!(Some('b'), c);\n-/// ```\n-///\n-/// Returning `None` when the input is not a digit:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_digit(20, 10);\n-///\n-/// assert_eq!(None, c);\n-/// ```\n-///\n-/// Passing a large radix, causing a panic:\n-///\n-/// ```should_panic\n-/// use std::char;\n-///\n-/// // this panics\n-/// let c = char::from_digit(1, 37);\n-/// ```\n+/// Converts a digit in the given radix to a `char`. See [`char::from_digit`].\n #[inline]\n #[must_use]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n-pub const fn from_digit(num: u32, radix: u32) -> Option<char> {\n+pub(super) const fn from_digit(num: u32, radix: u32) -> Option<char> {\n     if radix > 36 {\n         panic!(\"from_digit: radix is too high (maximum 36)\");\n     }"}, {"sha": "71297acd171454d15d9be5ced4a1d78a1cdeb56b", "filename": "library/core/src/char/decode.rs", "status": "modified", "additions": 2, "deletions": 47, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a8ff1aead87a702d78609dd873579106f6bc00c5/library%2Fcore%2Fsrc%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ff1aead87a702d78609dd873579106f6bc00c5/library%2Fcore%2Fsrc%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fdecode.rs?ref=a8ff1aead87a702d78609dd873579106f6bc00c5", "patch": "@@ -30,54 +30,9 @@ pub struct DecodeUtf16Error {\n }\n \n /// Creates an iterator over the UTF-16 encoded code points in `iter`,\n-/// returning unpaired surrogates as `Err`s.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char::decode_utf16;\n-///\n-/// // \ud834\udd1emus<invalid>ic<invalid>\n-/// let v = [\n-///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n-/// ];\n-///\n-/// assert_eq!(\n-///     decode_utf16(v.iter().cloned())\n-///         .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n-///         .collect::<Vec<_>>(),\n-///     vec![\n-///         Ok('\ud834\udd1e'),\n-///         Ok('m'), Ok('u'), Ok('s'),\n-///         Err(0xDD1E),\n-///         Ok('i'), Ok('c'),\n-///         Err(0xD834)\n-///     ]\n-/// );\n-/// ```\n-///\n-/// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n-///\n-/// ```\n-/// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n-///\n-/// // \ud834\udd1emus<invalid>ic<invalid>\n-/// let v = [\n-///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n-/// ];\n-///\n-/// assert_eq!(\n-///     decode_utf16(v.iter().cloned())\n-///        .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n-///        .collect::<String>(),\n-///     \"\ud834\udd1emus\ufffdic\ufffd\"\n-/// );\n-/// ```\n-#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+/// returning unpaired surrogates as `Err`s. See [`char::decode_utf16`].\n #[inline]\n-pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n+pub(super) fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n     DecodeUtf16 { iter: iter.into_iter(), buf: None }\n }\n "}, {"sha": "0df23e7bbe695ded0602984d2afc6c2c7ac09305", "filename": "library/core/src/char/mod.rs", "status": "modified", "additions": 45, "deletions": 24, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a8ff1aead87a702d78609dd873579106f6bc00c5/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ff1aead87a702d78609dd873579106f6bc00c5/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs?ref=a8ff1aead87a702d78609dd873579106f6bc00c5", "patch": "@@ -23,18 +23,12 @@ mod decode;\n mod methods;\n \n // stable re-exports\n-#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n-pub use self::convert::from_u32_unchecked;\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub use self::convert::CharTryFromError;\n #[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n pub use self::convert::ParseCharError;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::convert::{from_digit, from_u32};\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n-#[stable(feature = \"unicode_version\", since = \"1.45.0\")]\n-pub use crate::unicode::UNICODE_VERSION;\n+pub use self::decode::{DecodeUtf16, DecodeUtf16Error};\n \n // perma-unstable re-exports\n #[unstable(feature = \"char_internals\", reason = \"exposed only for libstd\", issue = \"none\")]\n@@ -89,30 +83,57 @@ const MAX_THREE_B: u32 = 0x10000;\n     Cn  Unassigned              a reserved unassigned code point or a noncharacter\n */\n \n-/// The highest valid code point a `char` can have, `'\\u{10FFFF}'`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # fn something_which_returns_char() -> char { 'a' }\n-/// let c: char = something_which_returns_char();\n-/// assert!(c <= char::MAX);\n-///\n-/// let value_at_max = char::MAX as u32;\n-/// assert_eq!(char::from_u32(value_at_max), Some('\\u{10FFFF}'));\n-/// assert_eq!(char::from_u32(value_at_max + 1), None);\n-/// ```\n+/// The highest valid code point a `char` can have, `'\\u{10FFFF}'`. Use [`char::MAX`] instead.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: char = char::MAX;\n \n /// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a\n-/// decoding error.\n-///\n-/// It can occur, for example, when giving ill-formed UTF-8 bytes to\n-/// [`String::from_utf8_lossy`](../../std/string/struct.String.html#method.from_utf8_lossy).\n+/// decoding error. Use [`char::REPLACEMENT_CHARACTER`] instead.\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n pub const REPLACEMENT_CHARACTER: char = char::REPLACEMENT_CHARACTER;\n \n+/// The version of [Unicode](https://www.unicode.org/) that the Unicode parts of\n+/// `char` and `str` methods are based on. Use [`char::UNICODE_VERSION`] instead.\n+#[stable(feature = \"unicode_version\", since = \"1.45.0\")]\n+pub const UNICODE_VERSION: (u8, u8, u8) = char::UNICODE_VERSION;\n+\n+/// Creates an iterator over the UTF-16 encoded code points in `iter`, returning\n+/// unpaired surrogates as `Err`s. Use [`char::decode_utf16`] instead.\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+#[inline]\n+pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n+    self::decode::decode_utf16(iter)\n+}\n+\n+/// Converts a `u32` to a `char`. Use [`char::from_u32`] instead.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n+#[must_use]\n+#[inline]\n+pub const fn from_u32(i: u32) -> Option<char> {\n+    self::convert::from_u32(i)\n+}\n+\n+/// Converts a `u32` to a `char`, ignoring validity. Use [`char::from_u32_unchecked`].\n+/// instead.\n+#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n+#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n+#[must_use]\n+#[inline]\n+pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n+    // SAFETY: the safety contract must be upheld by the caller.\n+    unsafe { self::convert::from_u32_unchecked(i) }\n+}\n+\n+/// Converts a digit in the given radix to a `char`. Use [`char::from_digit`] instead.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_char_convert\", issue = \"89259\")]\n+#[must_use]\n+#[inline]\n+pub const fn from_digit(num: u32, radix: u32) -> Option<char> {\n+    self::convert::from_digit(num, radix)\n+}\n+\n /// Returns an iterator that yields the hexadecimal Unicode escape of a\n /// character, as `char`s.\n ///"}]}