{"sha": "9a1a2580fc87e5761189e93d53d51da84b281ddd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMWEyNTgwZmM4N2U1NzYxMTg5ZTkzZDUzZDUxZGE4NGIyODFkZGQ=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-10T18:48:09Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-10T19:23:16Z"}, "message": "A better HTML parser.", "tree": {"sha": "00a4102c607a72763194695552db4be2a9250989", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00a4102c607a72763194695552db4be2a9250989"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a1a2580fc87e5761189e93d53d51da84b281ddd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a1a2580fc87e5761189e93d53d51da84b281ddd", "html_url": "https://github.com/rust-lang/rust/commit/9a1a2580fc87e5761189e93d53d51da84b281ddd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a1a2580fc87e5761189e93d53d51da84b281ddd/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b354fe2a918c4821bd66996a023a7bb108bd2862", "url": "https://api.github.com/repos/rust-lang/rust/commits/b354fe2a918c4821bd66996a023a7bb108bd2862", "html_url": "https://github.com/rust-lang/rust/commit/b354fe2a918c4821bd66996a023a7bb108bd2862"}], "stats": {"total": 109, "additions": 66, "deletions": 43}, "files": [{"sha": "ef56998cdd15098b0792072032abb4b5d8470b98", "filename": "src/test/run-pass/html-literals.rs", "status": "modified", "additions": 66, "deletions": 43, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/9a1a2580fc87e5761189e93d53d51da84b281ddd/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a1a2580fc87e5761189e93d53d51da84b281ddd/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhtml-literals.rs?ref=9a1a2580fc87e5761189e93d53d51da84b281ddd", "patch": "@@ -1,42 +1,80 @@\n // A test of the macro system. Can we do HTML literals?\n \n // xfail-pretty\n-// xfail-test\n+\n+/*\n+\n+This is an HTML parser written as a macro. It's all CPS, and we have\n+to carry around a bunch of state. The arguments to macros all look like this:\n+\n+{ tag_stack* # expr* # tokens }\n+\n+The stack keeps track of where we are in the tree. The expr is a list\n+of children of the current node. The tokens are everything that's\n+left.\n+\n+*/\n \n macro_rules! html {\n-    { $($body:tt)* } => {\n-        let builder = HTMLBuilder();\n-        build_html!{builder := $($body)*};\n-        builder.getDoc()\n-    }\n+    { $($body:tt)* } => (\n+        parse_node!( []; []; $($body)* )\n+    )\n }\n \n-macro_rules! build_html {\n-    { $builder:expr := </$tag:ident> $($rest:tt)* } => {\n-        $builder.endTag(stringify!($tag));\n-        build_html!{ $builder := $($rest)* };\n-    };\n+macro_rules! parse_node {\n+    {\n+        [:$head:ident ($(:$head_nodes:expr),*)\n+         $(:$tags:ident ($(:$tag_nodes:expr),*))*];\n+        [$(:$nodes:expr),*];\n+        </$tag:ident> $($rest:tt)*\n+    } => (\n+        parse_node!(\n+            [$(: $tags ($(:$tag_nodes),*))*];\n+            [$(:$head_nodes,)* :tag(stringify!($head), ~[$($nodes),*])];\n+            $($rest)*\n+        )\n+    );\n \n-    { $builder:expr := <$tag:ident> $($rest:tt)* } => {\n-        $builder.beginTag(stringify!($tag));\n-        build_html!{ $builder := $($rest)* };\n-    };\n+    {\n+        [$(:$tags:ident ($(:$tag_nodes:expr),*) )*];\n+        [$(:$nodes:expr),*];\n+        <$tag:ident> $($rest:tt)*\n+    } => (\n+        parse_node!(\n+            [:$tag ($(:$nodes)*) $(: $tags ($(:$tag_nodes),*) )*];\n+            [];\n+            $($rest)*\n+        )\n+    );\n \n-    { $builder:expr := . $($rest:tt)* } => {\n-        $builder.addText(~\".\");\n-        build_html!{ $builder := $($rest)* };\n-    };\n+    {\n+        [$(:$tags:ident ($(:$tag_nodes:expr),*) )*];\n+        [$(:$nodes:expr),*];\n+        . $($rest:tt)*\n+    } => (\n+        parse_node!(\n+            [$(: $tags ($(:$tag_nodes),*))*];\n+            [$(:$nodes,)* :text(~\".\")];\n+            $($rest)*\n+        )\n+    );\n \n-    { $builder:expr := $word:ident $($rest:tt)* } => {\n-        $builder.addText(stringify!($word));\n-        build_html!{ $builder := $($rest)* };\n-    };\n+    {\n+        [$(:$tags:ident ($(:$tag_nodes:expr),*) )*];\n+        [$(:$nodes:expr),*];\n+        $word:ident $($rest:tt)*\n+    } => (\n+        parse_node!(\n+            [$(: $tags ($(:$tag_nodes),*))*];\n+            [$(:$nodes,)* :text(stringify!($word))];\n+            $($rest)*\n+        )\n+    );\n \n-    { $builder:expr := } => { }\n+    { []; [:$e:expr]; } => ( $e );\n }\n \n fn main() {\n-\n     let page = html! {\n         <html>\n             <head><title>This is the title.</title></head>\n@@ -45,24 +83,9 @@ fn main() {\n             </body>\n         </html>\n     };\n-\n-    // When we can do this, we are successful:\n-    //\n-    //let page = tag(~\"html\", ~[tag(~\"head\", ~[...])])\n-\n }\n \n-enum HTMLFragment {    \n+enum HTMLFragment {\n+    tag(~str, ~[HTMLFragment]),\n+    text(~str),\n }\n-\n-struct HTMLBuilder {\n-    bar: ();\n-    fn getDoc() -> HTMLFragment { fail }\n-    fn beginTag(tag: ~str) { }\n-    fn endTag(tag: ~str) { }\n-    fn addText(test: ~str) { }\n-}\n-\n-fn HTMLBuilder() -> HTMLBuilder {\n-    HTMLBuilder { bar: () }\n-}\n\\ No newline at end of file"}]}