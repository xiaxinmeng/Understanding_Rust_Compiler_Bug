{"sha": "25fb12b8a5411901675ede6b147bbc6c0b7437b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZmIxMmI4YTU0MTE5MDE2NzVlZGU2YjE0N2JiYzZjMGI3NDM3Yjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-29T08:06:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-29T08:06:20Z"}, "message": "auto merge of #19765 : luqmana/rust/nonzero-lang-item, r=nikomatsakis\n\nThis extends the nullable enum opt to traverse beyond just the first level to find possible fields to use as the discriminant. So now, it'll work through structs, tuples, and fixed sized arrays. This also introduces a new lang item, NonZero, that you can use to wrap raw pointers or integral types to indicate to rustc that the underlying value is known to never be 0/NULL. We then use this in Vec, Rc and Arc to have them also benefit from the nullable enum opt.\r\n\r\nAs per https://github.com/rust-lang/rfcs/pull/499 NonZero is not exposed via the `libstd` facade.\r\n\r\n```\r\nx86_64 Linux:\r\n                        T       Option<T> (Before)      Option<T> (After)\r\n----------------------------------------------------------------------------------\r\nVec<int>                24          32                      24\r\nString                  24          32                      24\r\nRc<int>                 8           16                      8\r\nArc<int>                8           16                      8\r\n[Box<int>, ..2]         16          24                      16\r\n(String, uint)          32          40                      32\r\n```\r\n\r\nFixes #19419.\r\nFixes #13194.\r\nFixes #9378.\r\nFixes #7576.", "tree": {"sha": "782cd6a61471a7939220ce7e9aae7cdb14536159", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/782cd6a61471a7939220ce7e9aae7cdb14536159"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25fb12b8a5411901675ede6b147bbc6c0b7437b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25fb12b8a5411901675ede6b147bbc6c0b7437b7", "html_url": "https://github.com/rust-lang/rust/commit/25fb12b8a5411901675ede6b147bbc6c0b7437b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25fb12b8a5411901675ede6b147bbc6c0b7437b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03a1188cf35b3765d8eb718d3b757c5a5d7e9497", "url": "https://api.github.com/repos/rust-lang/rust/commits/03a1188cf35b3765d8eb718d3b757c5a5d7e9497", "html_url": "https://github.com/rust-lang/rust/commit/03a1188cf35b3765d8eb718d3b757c5a5d7e9497"}, {"sha": "766a71922fcabb8e0885b372d116c07149b6bb07", "url": "https://api.github.com/repos/rust-lang/rust/commits/766a71922fcabb8e0885b372d116c07149b6bb07", "html_url": "https://github.com/rust-lang/rust/commit/766a71922fcabb8e0885b372d116c07149b6bb07"}], "stats": {"total": 525, "additions": 370, "deletions": 155}, "files": [{"sha": "3e235caab18ad1431befa20a802419cb497f1c88", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=25fb12b8a5411901675ede6b147bbc6c0b7437b7", "patch": "@@ -76,11 +76,11 @@ use core::default::Default;\n use core::kinds::{Sync, Send};\n use core::mem::{min_align_of, size_of, drop};\n use core::mem;\n+use core::nonzero::NonZero;\n use core::ops::{Drop, Deref};\n use core::option::Option;\n use core::option::Option::{Some, None};\n-use core::ptr::RawPtr;\n-use core::ptr;\n+use core::ptr::{mod, RawPtr};\n use heap::deallocate;\n \n /// An atomically reference counted wrapper for shared state.\n@@ -114,7 +114,7 @@ use heap::deallocate;\n pub struct Arc<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n-    _ptr: *mut ArcInner<T>,\n+    _ptr: NonZero<*mut ArcInner<T>>,\n }\n \n unsafe impl<T: Sync + Send> Send for Arc<T> { }\n@@ -130,7 +130,7 @@ unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n pub struct Weak<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n-    _ptr: *mut ArcInner<T>,\n+    _ptr: NonZero<*mut ArcInner<T>>,\n }\n \n unsafe impl<T: Sync + Send> Send for Weak<T> { }\n@@ -165,7 +165,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUint::new(1),\n             data: data,\n         };\n-        Arc { _ptr: unsafe { mem::transmute(x) } }\n+        Arc { _ptr: unsafe { NonZero::new(mem::transmute(x)) } }\n     }\n \n     /// Downgrades the `Arc<T>` to a `Weak<T>` reference.\n@@ -194,7 +194,7 @@ impl<T> Arc<T> {\n         // pointer is valid. Furthermore, we know that the `ArcInner` structure itself is `Sync`\n         // because the inner data is `Sync` as well, so we're ok loaning out an immutable pointer\n         // to these contents.\n-        unsafe { &*self._ptr }\n+        unsafe { &**self._ptr }\n     }\n }\n \n@@ -281,7 +281,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n         // pointer that will ever be returned to T. Our reference count is guaranteed to be 1 at\n         // this point, and we required the Arc itself to be `mut`, so we're returning the only\n         // possible reference to the inner data.\n-        let inner = unsafe { &mut *self._ptr };\n+        let inner = unsafe { &mut **self._ptr };\n         &mut inner.data\n     }\n }\n@@ -316,7 +316,8 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     fn drop(&mut self) {\n         // This structure has #[unsafe_no_drop_flag], so this drop glue may run more than once (but\n         // it is guaranteed to be zeroed after the first if it's run more than once)\n-        if self._ptr.is_null() { return }\n+        let ptr = *self._ptr;\n+        if ptr.is_null() { return }\n \n         // Because `fetch_sub` is already atomic, we do not need to synchronize with other threads\n         // unless we are going to delete the object. This same logic applies to the below\n@@ -346,7 +347,7 @@ impl<T: Sync + Send> Drop for Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, atomic::Release) == 1 {\n             atomic::fence(atomic::Acquire);\n-            unsafe { deallocate(self._ptr as *mut u8, size_of::<ArcInner<T>>(),\n+            unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),\n                                 min_align_of::<ArcInner<T>>()) }\n         }\n     }\n@@ -386,7 +387,7 @@ impl<T: Sync + Send> Weak<T> {\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // See comments above for why this is \"safe\"\n-        unsafe { &*self._ptr }\n+        unsafe { &**self._ptr }\n     }\n }\n \n@@ -442,14 +443,16 @@ impl<T: Sync + Send> Drop for Weak<T> {\n     /// } // implicit drop\n     /// ```\n     fn drop(&mut self) {\n+        let ptr = *self._ptr;\n+\n         // see comments above for why this check is here\n-        if self._ptr.is_null() { return }\n+        if ptr.is_null() { return }\n \n         // If we find out that we were the last weak pointer, then its time to deallocate the data\n         // entirely. See the discussion in Arc::drop() about the memory orderings\n         if self.inner().weak.fetch_sub(1, atomic::Release) == 1 {\n             atomic::fence(atomic::Acquire);\n-            unsafe { deallocate(self._ptr as *mut u8, size_of::<ArcInner<T>>(),\n+            unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),\n                                 min_align_of::<ArcInner<T>>()) }\n         }\n     }"}, {"sha": "13dc4474c1a193e6124f1993cac4c78237d52bac", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=25fb12b8a5411901675ede6b147bbc6c0b7437b7", "patch": "@@ -150,11 +150,11 @@ use core::fmt;\n use core::hash::{mod, Hash};\n use core::kinds::marker;\n use core::mem::{transmute, min_align_of, size_of, forget};\n+use core::nonzero::NonZero;\n use core::ops::{Deref, Drop};\n use core::option::Option;\n use core::option::Option::{Some, None};\n-use core::ptr;\n-use core::ptr::RawPtr;\n+use core::ptr::{mod, RawPtr};\n use core::result::Result;\n use core::result::Result::{Ok, Err};\n \n@@ -174,7 +174,7 @@ struct RcBox<T> {\n pub struct Rc<T> {\n     // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n     // type via Deref\n-    _ptr: *mut RcBox<T>,\n+    _ptr: NonZero<*mut RcBox<T>>,\n     _nosend: marker::NoSend,\n     _noshare: marker::NoSync\n }\n@@ -196,11 +196,11 @@ impl<T> Rc<T> {\n                 // there is an implicit weak pointer owned by all the strong pointers, which\n                 // ensures that the weak destructor never frees the allocation while the strong\n                 // destructor is running, even if the weak pointer is stored inside the strong one.\n-                _ptr: transmute(box RcBox {\n+                _ptr: NonZero::new(transmute(box RcBox {\n                     value: value,\n                     strong: Cell::new(1),\n                     weak: Cell::new(1)\n-                }),\n+                })),\n                 _nosend: marker::NoSend,\n                 _noshare: marker::NoSync\n             }\n@@ -281,7 +281,7 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n             let val = ptr::read(&*rc); // copy the contained object\n             // destruct the box and skip our Drop\n             // we can ignore the refcounts because we know we're unique\n-            deallocate(rc._ptr as *mut u8, size_of::<RcBox<T>>(),\n+            deallocate(*rc._ptr as *mut u8, size_of::<RcBox<T>>(),\n                         min_align_of::<RcBox<T>>());\n             forget(rc);\n             Ok(val)\n@@ -311,7 +311,7 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n #[experimental]\n pub fn get_mut<'a, T>(rc: &'a mut Rc<T>) -> Option<&'a mut T> {\n     if is_unique(rc) {\n-        let inner = unsafe { &mut *rc._ptr };\n+        let inner = unsafe { &mut **rc._ptr };\n         Some(&mut inner.value)\n     } else {\n         None\n@@ -343,7 +343,7 @@ impl<T: Clone> Rc<T> {\n         // pointer that will ever be returned to T. Our reference count is guaranteed to be 1 at\n         // this point, and we required the `Rc<T>` itself to be `mut`, so we're returning the only\n         // possible reference to the inner value.\n-        let inner = unsafe { &mut *self._ptr };\n+        let inner = unsafe { &mut **self._ptr };\n         &mut inner.value\n     }\n }\n@@ -391,7 +391,8 @@ impl<T> Drop for Rc<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            if !self._ptr.is_null() {\n+            let ptr = *self._ptr;\n+            if !ptr.is_null() {\n                 self.dec_strong();\n                 if self.strong() == 0 {\n                     ptr::read(&**self); // destroy the contained object\n@@ -401,7 +402,7 @@ impl<T> Drop for Rc<T> {\n                     self.dec_weak();\n \n                     if self.weak() == 0 {\n-                        deallocate(self._ptr as *mut u8, size_of::<RcBox<T>>(),\n+                        deallocate(ptr as *mut u8, size_of::<RcBox<T>>(),\n                                    min_align_of::<RcBox<T>>())\n                     }\n                 }\n@@ -618,7 +619,7 @@ impl<T: fmt::Show> fmt::Show for Rc<T> {\n pub struct Weak<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref\n-    _ptr: *mut RcBox<T>,\n+    _ptr: NonZero<*mut RcBox<T>>,\n     _nosend: marker::NoSend,\n     _noshare: marker::NoSync\n }\n@@ -682,12 +683,13 @@ impl<T> Drop for Weak<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            if !self._ptr.is_null() {\n+            let ptr = *self._ptr;\n+            if !ptr.is_null() {\n                 self.dec_weak();\n                 // the weak count starts at 1, and will only go to zero if all the strong pointers\n                 // have disappeared.\n                 if self.weak() == 0 {\n-                    deallocate(self._ptr as *mut u8, size_of::<RcBox<T>>(),\n+                    deallocate(ptr as *mut u8, size_of::<RcBox<T>>(),\n                                min_align_of::<RcBox<T>>())\n                 }\n             }\n@@ -742,12 +744,12 @@ trait RcBoxPtr<T> {\n \n impl<T> RcBoxPtr<T> for Rc<T> {\n     #[inline(always)]\n-    fn inner(&self) -> &RcBox<T> { unsafe { &(*self._ptr) } }\n+    fn inner(&self) -> &RcBox<T> { unsafe { &(**self._ptr) } }\n }\n \n impl<T> RcBoxPtr<T> for Weak<T> {\n     #[inline(always)]\n-    fn inner(&self) -> &RcBox<T> { unsafe { &(*self._ptr) } }\n+    fn inner(&self) -> &RcBox<T> { unsafe { &(**self._ptr) } }\n }\n \n #[cfg(test)]"}, {"sha": "bf69980b49c8f75a90fe0009454dd3ee4749a635", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=25fb12b8a5411901675ede6b147bbc6c0b7437b7", "patch": "@@ -56,9 +56,10 @@ use core::hash::{mod, Hash};\n use core::iter::repeat;\n use core::kinds::marker::{ContravariantLifetime, InvariantType};\n use core::mem;\n+use core::nonzero::NonZero;\n use core::num::{Int, UnsignedInt};\n use core::ops;\n-use core::ptr::{mod, Unique};\n+use core::ptr;\n use core::raw::Slice as RawSlice;\n use core::uint;\n \n@@ -133,11 +134,14 @@ use slice::CloneSliceExt;\n #[unsafe_no_drop_flag]\n #[stable]\n pub struct Vec<T> {\n-    ptr: Unique<T>,\n+    ptr: NonZero<*mut T>,\n     len: uint,\n     cap: uint,\n }\n \n+unsafe impl<T: Send> Send for Vec<T> { }\n+unsafe impl<T: Sync> Sync for Vec<T> { }\n+\n /// A clone-on-write vector\n pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n \n@@ -176,7 +180,7 @@ impl<T> Vec<T> {\n         // non-null value which is fine since we never call deallocate on the ptr\n         // if cap is 0. The reason for this is because the pointer of a slice\n         // being NULL would break the null pointer optimization for enums.\n-        Vec { ptr: Unique(EMPTY as *mut T), len: 0, cap: 0 }\n+        Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: 0 }\n     }\n \n     /// Constructs a new, empty `Vec<T>` with the specified capacity.\n@@ -209,15 +213,15 @@ impl<T> Vec<T> {\n     #[stable]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { ptr: Unique(EMPTY as *mut T), len: 0, cap: uint::MAX }\n+            Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: uint::MAX }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n             if ptr.is_null() { ::alloc::oom() }\n-            Vec { ptr: Unique(ptr as *mut T), len: 0, cap: capacity }\n+            Vec { ptr: unsafe { NonZero::new(ptr as *mut T) }, len: 0, cap: capacity }\n         }\n     }\n \n@@ -284,7 +288,7 @@ impl<T> Vec<T> {\n     #[unstable = \"needs finalization\"]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n                                  capacity: uint) -> Vec<T> {\n-        Vec { ptr: Unique(ptr), len: length, cap: capacity }\n+        Vec { ptr: NonZero::new(ptr), len: length, cap: capacity }\n     }\n \n     /// Creates a vector by copying the elements from a raw pointer.\n@@ -795,19 +799,20 @@ impl<T> Vec<T> {\n         if self.len == 0 {\n             if self.cap != 0 {\n                 unsafe {\n-                    dealloc(self.ptr.0, self.cap)\n+                    dealloc(*self.ptr, self.cap)\n                 }\n                 self.cap = 0;\n             }\n         } else {\n             unsafe {\n                 // Overflow check is unnecessary as the vector is already at\n                 // least this large.\n-                self.ptr = Unique(reallocate(self.ptr.0 as *mut u8,\n-                                               self.cap * mem::size_of::<T>(),\n-                                               self.len * mem::size_of::<T>(),\n-                                               mem::min_align_of::<T>()) as *mut T);\n-                if self.ptr.0.is_null() { ::alloc::oom() }\n+                let ptr = reallocate(*self.ptr as *mut u8,\n+                                     self.cap * mem::size_of::<T>(),\n+                                     self.len * mem::size_of::<T>(),\n+                                     mem::min_align_of::<T>()) as *mut T;\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero::new(ptr);\n             }\n             self.cap = self.len;\n         }\n@@ -867,7 +872,7 @@ impl<T> Vec<T> {\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n-                data: self.ptr.0 as *const T,\n+                data: *self.ptr as *const T,\n                 len: self.len,\n             })\n         }\n@@ -890,9 +895,9 @@ impl<T> Vec<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n-            let ptr = self.ptr.0;\n+            let ptr = *self.ptr;\n             let cap = self.cap;\n-            let begin = self.ptr.0 as *const T;\n+            let begin = ptr as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n                 (ptr as uint + self.len()) as *const T\n             } else {\n@@ -1110,14 +1115,15 @@ impl<T> Vec<T> {\n             let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n             if old_size > size { panic!(\"capacity overflow\") }\n             unsafe {\n-                self.ptr = Unique(alloc_or_realloc(self.ptr.0, old_size, size));\n-                if self.ptr.0.is_null() { ::alloc::oom() }\n+                let ptr = alloc_or_realloc(*self.ptr, old_size, size);\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero::new(ptr);\n             }\n             self.cap = max(self.cap, 2) * 2;\n         }\n \n         unsafe {\n-            let end = self.ptr.0.offset(self.len as int);\n+            let end = (*self.ptr).offset(self.len as int);\n             ptr::write(&mut *end, value);\n             self.len += 1;\n         }\n@@ -1162,11 +1168,11 @@ impl<T> Vec<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n         unsafe {\n-            let begin = self.ptr.0 as *const T;\n+            let begin = *self.ptr as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n-                (self.ptr.0 as uint + self.len()) as *const T\n+                (*self.ptr as uint + self.len()) as *const T\n             } else {\n-                self.ptr.0.offset(self.len() as int) as *const T\n+                (*self.ptr).offset(self.len() as int) as *const T\n             };\n             self.set_len(0);\n             Drain {\n@@ -1231,10 +1237,9 @@ impl<T> Vec<T> {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             unsafe {\n-                self.ptr = Unique(alloc_or_realloc(self.ptr.0,\n-                                                     self.cap * mem::size_of::<T>(),\n-                                                     size));\n-                if self.ptr.0.is_null() { ::alloc::oom() }\n+                let ptr = alloc_or_realloc(*self.ptr, self.cap * mem::size_of::<T>(), size);\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero::new(ptr);\n             }\n             self.cap = capacity;\n         }\n@@ -1357,7 +1362,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n-                data: self.ptr.0 as *const T,\n+                data: *self.ptr as *const T,\n                 len: self.len\n             })\n         }\n@@ -1382,7 +1387,7 @@ impl<T> Drop for Vec<T> {\n                 for x in self.iter() {\n                     ptr::read(x);\n                 }\n-                dealloc(self.ptr.0, self.cap)\n+                dealloc(*self.ptr, self.cap)\n             }\n         }\n     }\n@@ -1420,7 +1425,7 @@ impl<T> IntoIter<T> {\n             for _x in self { }\n             let IntoIter { allocation, cap, ptr: _ptr, end: _end } = self;\n             mem::forget(self);\n-            Vec { ptr: Unique(allocation), cap: cap, len: 0 }\n+            Vec { ptr: NonZero::new(allocation), cap: cap, len: 0 }\n         }\n     }\n "}, {"sha": "d646245510d505394c1553dff7fac7bef96f4e11", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=25fb12b8a5411901675ede6b147bbc6c0b7437b7", "patch": "@@ -93,6 +93,7 @@ pub mod prelude;\n \n pub mod intrinsics;\n pub mod mem;\n+pub mod nonzero;\n pub mod ptr;\n \n /* Core language traits */"}, {"sha": "c429e4b8212bc2e1d95db58ffa1e4d2f2c00dc3e", "filename": "src/libcore/nonzero.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=25fb12b8a5411901675ede6b147bbc6c0b7437b7", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Exposes the NonZero lang item which provides optimization hints.\n+\n+use ops::Deref;\n+\n+/// Unsafe trait to indicate what types are usable with the NonZero struct\n+pub unsafe trait Zeroable {}\n+\n+unsafe impl<T> Zeroable for *const T {}\n+unsafe impl<T> Zeroable for *mut T {}\n+unsafe impl Zeroable for int {}\n+unsafe impl Zeroable for uint {}\n+unsafe impl Zeroable for i8 {}\n+unsafe impl Zeroable for u8 {}\n+unsafe impl Zeroable for i16 {}\n+unsafe impl Zeroable for u16 {}\n+unsafe impl Zeroable for i32 {}\n+unsafe impl Zeroable for u32 {}\n+unsafe impl Zeroable for i64 {}\n+unsafe impl Zeroable for u64 {}\n+\n+/// A wrapper type for raw pointers and integers that will never be\n+/// NULL or 0 that might allow certain optimizations.\n+#[lang=\"non_zero\"]\n+#[deriving(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Show)]\n+#[experimental]\n+pub struct NonZero<T: Zeroable>(T);\n+\n+impl<T: Zeroable> NonZero<T> {\n+    /// Create an instance of NonZero with the provided value.\n+    /// You must indeed ensure that the value is actually \"non-zero\".\n+    #[inline(always)]\n+    pub unsafe fn new(inner: T) -> NonZero<T> {\n+        NonZero(inner)\n+    }\n+}\n+\n+impl<T: Zeroable> Deref<T> for NonZero<T> {\n+    #[inline]\n+    fn deref<'a>(&'a self) -> &'a T {\n+        let NonZero(ref inner) = *self;\n+        inner\n+    }\n+}"}, {"sha": "8c724b4d8521fdeec603b29edf7876ea5fa977ec", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=25fb12b8a5411901675ede6b147bbc6c0b7437b7", "patch": "@@ -90,9 +90,9 @@\n use mem;\n use clone::Clone;\n use intrinsics;\n+use kinds::{Send, Sync};\n use option::Option;\n use option::Option::{Some, None};\n-use kinds::{Send, Sync};\n \n use cmp::{PartialEq, Eq, Ord, PartialOrd, Equiv};\n use cmp::Ordering;\n@@ -109,6 +109,7 @@ pub use intrinsics::copy_memory;\n #[experimental = \"uncertain about naming and semantics\"]\n pub use intrinsics::set_memory;\n \n+\n /// Creates a null raw pointer.\n ///\n /// # Examples"}, {"sha": "e6608eee3ddfab565f6fb8f71f94705f72aa1198", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=25fb12b8a5411901675ede6b147bbc6c0b7437b7", "patch": "@@ -25,6 +25,7 @@ mod fmt;\n mod hash;\n mod iter;\n mod mem;\n+mod nonzero;\n mod num;\n mod ops;\n mod option;"}, {"sha": "ed66be3d890dc75f23a1a2ea5ac6a48e804bb90e", "filename": "src/libcoretest/nonzero.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibcoretest%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibcoretest%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnonzero.rs?ref=25fb12b8a5411901675ede6b147bbc6c0b7437b7", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::nonzero::NonZero;\n+use core::option::Option;\n+use core::option::Option::{Some, None};\n+use std::mem::size_of;\n+\n+#[test]\n+fn test_create_nonzero_instance() {\n+    let _a = unsafe {\n+        NonZero::new(21i)\n+    };\n+}\n+\n+#[test]\n+fn test_size_nonzero_in_option() {\n+    assert_eq!(size_of::<NonZero<u32>>(), size_of::<Option<NonZero<u32>>>());\n+}\n+\n+#[test]\n+fn test_match_on_nonzero_option() {\n+    let a = Some(unsafe {\n+        NonZero::new(42i)\n+    });\n+    match a {\n+        Some(val) => assert_eq!(*val, 42),\n+        None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n+    }\n+\n+    match unsafe { Some(NonZero::new(43i)) } {\n+        Some(val) => assert_eq!(*val, 43),\n+        None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n+    }\n+}\n+\n+#[test]\n+fn test_match_option_empty_vec() {\n+    let a: Option<Vec<int>> = Some(vec![]);\n+    match a {\n+        None => panic!(\"unexpected None while matching on Some(vec![])\"),\n+        _ => {}\n+    }\n+}\n+\n+#[test]\n+fn test_match_option_vec() {\n+    let a = Some(vec![1i, 2, 3, 4]);\n+    match a {\n+        Some(v) => assert_eq!(v, vec![1i, 2, 3, 4]),\n+        None => panic!(\"unexpected None while matching on Some(vec![1, 2, 3, 4])\")\n+    }\n+}\n+\n+#[test]\n+fn test_match_option_rc() {\n+    use std::rc::Rc;\n+\n+    let five = Rc::new(5i);\n+    match Some(five) {\n+        Some(r) => assert_eq!(*r, 5i),\n+        None => panic!(\"unexpected None while matching on Some(Rc::new(5))\")\n+    }\n+}\n+\n+#[test]\n+fn test_match_option_arc() {\n+    use std::sync::Arc;\n+\n+    let five = Arc::new(5i);\n+    match Some(five) {\n+        Some(a) => assert_eq!(*a, 5i),\n+        None => panic!(\"unexpected None while matching on Some(Arc::new(5))\")\n+    }\n+}\n+\n+#[test]\n+fn test_match_option_empty_string() {\n+    let a = Some(String::new());\n+    match a {\n+        None => panic!(\"unexpected None while matching on Some(String::new())\"),\n+        _ => {}\n+    }\n+}\n+\n+#[test]\n+fn test_match_option_string() {\n+    let five = \"Five\".into_string();\n+    match Some(five) {\n+        Some(s) => assert_eq!(s, \"Five\"),\n+        None => panic!(\"unexpected None while matching on Some(String { ... })\")\n+    }\n+}"}, {"sha": "90e3e2bb34aba34eaf2a951fe899ca7939f13682", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=25fb12b8a5411901675ede6b147bbc6c0b7437b7", "patch": "@@ -327,6 +327,8 @@ lets_do_this! {\n     NoSyncItem,                      \"no_sync_bound\",           no_sync_bound;\n     ManagedItem,                     \"managed_bound\",           managed_bound;\n \n+    NonZeroItem,                     \"non_zero\",                non_zero;\n+\n     IteratorItem,                    \"iterator\",                iterator;\n \n     StackExhaustedLangItem,          \"stack_exhausted\",         stack_exhausted;"}, {"sha": "cd788945d3b281c5d4bdb5df79ce14ed62e72970", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 108, "deletions": 91, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=25fb12b8a5411901675ede6b147bbc6c0b7437b7", "patch": "@@ -43,14 +43,13 @@\n \n #![allow(unsigned_negation)]\n \n-pub use self::PointerField::*;\n pub use self::Repr::*;\n \n use std::num::Int;\n use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n-use back::abi;\n+use back::abi::FAT_PTR_ADDR;\n use middle::subst;\n use middle::subst::Subst;\n use trans::_match;\n@@ -71,7 +70,6 @@ use util::ppaux::ty_to_string;\n \n type Hint = attr::ReprAttr;\n \n-\n /// Representations.\n #[deriving(Eq, PartialEq, Show)]\n pub enum Repr<'tcx> {\n@@ -101,7 +99,7 @@ pub enum Repr<'tcx> {\n         nullfields: Vec<Ty<'tcx>>\n     },\n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n-    /// `nndiscr` is represented by the struct `nonnull`, where the `ptrfield`th\n+    /// `nndiscr` is represented by the struct `nonnull`, where the `discrfield`th\n     /// field is known to be nonnull due to its type; if that field is null, then\n     /// it represents the other case, which is inhabited by at most one value\n     /// (and all other fields are undefined/unused).\n@@ -112,7 +110,7 @@ pub enum Repr<'tcx> {\n     StructWrappedNullablePointer {\n         nonnull: Struct<'tcx>,\n         nndiscr: Disr,\n-        ptrfield: PointerField,\n+        discrfield: DiscrField,\n         nullfields: Vec<Ty<'tcx>>,\n     }\n }\n@@ -230,22 +228,24 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         let st = mk_struct(cx, cases[discr].tys[],\n                                            false, t);\n                         match cases[discr].find_ptr(cx) {\n-                            Some(ThinPointer(_)) if st.fields.len() == 1 => {\n+                            Some(ref df) if df.len() == 1 && st.fields.len() == 1 => {\n                                 return RawNullablePointer {\n                                     nndiscr: discr as Disr,\n                                     nnty: st.fields[0],\n                                     nullfields: cases[1 - discr].tys.clone()\n                                 };\n                             }\n-                            Some(ptrfield) => {\n+                            Some(mut discrfield) => {\n+                                discrfield.push(0);\n+                                discrfield.reverse();\n                                 return StructWrappedNullablePointer {\n                                     nndiscr: discr as Disr,\n                                     nonnull: st,\n-                                    ptrfield: ptrfield,\n+                                    discrfield: discrfield,\n                                     nullfields: cases[1 - discr].tys.clone()\n                                 };\n                             }\n-                            None => { }\n+                            None => {}\n                         }\n                     }\n                     discr += 1;\n@@ -335,49 +335,98 @@ struct Case<'tcx> {\n     tys: Vec<Ty<'tcx>>\n }\n \n+/// This represents the (GEP) indices to follow to get to the discriminant field\n+pub type DiscrField = Vec<uint>;\n+\n+fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                    ty: Ty<'tcx>,\n+                                    mut path: DiscrField) -> Option<DiscrField> {\n+    match ty.sty {\n+        // Fat &T/&mut T/Box<T> i.e. T is [T], str, or Trait\n+        ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) if !ty::type_is_sized(tcx, ty) => {\n+            path.push(FAT_PTR_ADDR);\n+            Some(path)\n+        },\n \n-#[deriving(Copy, Eq, PartialEq, Show)]\n-pub enum PointerField {\n-    ThinPointer(uint),\n-    FatPointer(uint)\n-}\n+        // Regular thin pointer: &T/&mut T/Box<T>\n+        ty::ty_rptr(..) | ty::ty_uniq(..) => Some(path),\n \n-impl<'tcx> Case<'tcx> {\n-    fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>)\n-                      -> bool {\n-        mk_struct(cx, self.tys[], false, scapegoat).size == 0\n-    }\n+        // Functions are just pointers\n+        ty::ty_bare_fn(..) => Some(path),\n \n-    fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<PointerField> {\n-        for (i, &ty) in self.tys.iter().enumerate() {\n-            match ty.sty {\n-                // &T/&mut T/Box<T> could either be a thin or fat pointer depending on T\n-                ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) => match ty.sty {\n-                    // &[T] and &str are a pointer and length pair\n-                    ty::ty_vec(_, None) | ty::ty_str => return Some(FatPointer(i)),\n+        // Closures are a pair of pointers: the code and environment\n+        ty::ty_closure(..) => {\n+            path.push(FAT_PTR_ADDR);\n+            Some(path)\n+        },\n \n-                    // &Trait is a pair of pointers: the actual object and a vtable\n-                    ty::ty_trait(..) => return Some(FatPointer(i)),\n+        // Is this the NonZero lang item wrapping a pointer or integer type?\n+        ty::ty_struct(did, ref substs) if Some(did) == tcx.lang_items.non_zero() => {\n+            let nonzero_fields = ty::lookup_struct_fields(tcx, did);\n+            assert_eq!(nonzero_fields.len(), 1);\n+            let nonzero_field = ty::lookup_field_type(tcx, did, nonzero_fields[0].id, substs);\n+            match nonzero_field.sty {\n+                ty::ty_ptr(..) | ty::ty_int(..) | ty::ty_uint(..) => {\n+                    path.push(0);\n+                    Some(path)\n+                },\n+                _ => None\n+            }\n+        },\n \n-                    ty::ty_struct(..) if !ty::type_is_sized(cx.tcx(), ty) => {\n-                        return Some(FatPointer(i))\n-                    }\n+        // Perhaps one of the fields of this struct is non-zero\n+        // let's recurse and find out\n+        ty::ty_struct(def_id, ref substs) => {\n+            let fields = ty::lookup_struct_fields(tcx, def_id);\n+            for (j, field) in fields.iter().enumerate() {\n+                let field_ty = ty::lookup_field_type(tcx, def_id, field.id, substs);\n+                if let Some(mut fpath) = find_discr_field_candidate(tcx, field_ty, path.clone()) {\n+                    fpath.push(j);\n+                    return Some(fpath);\n+                }\n+            }\n+            None\n+        },\n \n-                    // Any other &T is just a pointer\n-                    _ => return Some(ThinPointer(i))\n-                },\n+        // Can we use one of the fields in this tuple?\n+        ty::ty_tup(ref tys) => {\n+            for (j, &ty) in tys.iter().enumerate() {\n+                if let Some(mut fpath) = find_discr_field_candidate(tcx, ty, path.clone()) {\n+                    fpath.push(j);\n+                    return Some(fpath);\n+                }\n+            }\n+            None\n+        },\n \n-                // Functions are just pointers\n-                ty::ty_bare_fn(..) => return Some(ThinPointer(i)),\n+        // Is this a fixed-size array of something non-zero\n+        // with at least one element?\n+        ty::ty_vec(ety, Some(d)) if d > 0 => {\n+            if let Some(mut vpath) = find_discr_field_candidate(tcx, ety, path) {\n+                vpath.push(0);\n+                Some(vpath)\n+            } else {\n+                None\n+            }\n+        },\n \n-                // Closures are a pair of pointers: the code and environment\n-                ty::ty_closure(..) => return Some(FatPointer(i)),\n+        // Anything else is not a pointer\n+        _ => None\n+    }\n+}\n+\n+impl<'tcx> Case<'tcx> {\n+    fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>) -> bool {\n+        mk_struct(cx, self.tys[], false, scapegoat).size == 0\n+    }\n \n-                // Anything else is not a pointer\n-                _ => continue\n+    fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<DiscrField> {\n+        for (i, &ty) in self.tys.iter().enumerate() {\n+            if let Some(mut path) = find_discr_field_candidate(cx.tcx(), ty, vec![]) {\n+                path.push(i);\n+                return Some(path);\n             }\n         }\n-\n         None\n     }\n }\n@@ -709,8 +758,8 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n             val = ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty));\n             signed = false;\n         }\n-        StructWrappedNullablePointer { nndiscr, ptrfield, .. } => {\n-            val = struct_wrapped_nullable_bitdiscr(bcx, nndiscr, ptrfield, scrutinee);\n+        StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n+            val = struct_wrapped_nullable_bitdiscr(bcx, nndiscr, discrfield, scrutinee);\n             signed = false;\n         }\n     }\n@@ -720,12 +769,9 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n     }\n }\n \n-fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, ptrfield: PointerField,\n+fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, discrfield: &DiscrField,\n                                     scrutinee: ValueRef) -> ValueRef {\n-    let llptrptr = match ptrfield {\n-        ThinPointer(field) => GEPi(bcx, scrutinee, &[0, field]),\n-        FatPointer(field) => GEPi(bcx, scrutinee, &[0, field, abi::FAT_PTR_ADDR])\n-    };\n+    let llptrptr = GEPi(bcx, scrutinee, discrfield[]);\n     let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)))\n@@ -811,17 +857,10 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n                 Store(bcx, C_null(llptrty), val)\n             }\n         }\n-        StructWrappedNullablePointer { ref nonnull, nndiscr, ptrfield, .. } => {\n+        StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             if discr != nndiscr {\n-                let (llptrptr, llptrty) = match ptrfield {\n-                    ThinPointer(field) =>\n-                        (GEPi(bcx, val, &[0, field]),\n-                         type_of::type_of(bcx.ccx(), nonnull.fields[field])),\n-                    FatPointer(field) => {\n-                        let v = GEPi(bcx, val, &[0, field, abi::FAT_PTR_ADDR]);\n-                        (v, val_ty(v).element_type())\n-                    }\n-                };\n+                let llptrptr = GEPi(bcx, val, discrfield[]);\n+                let llptrty = val_ty(llptrptr).element_type();\n                 Store(bcx, C_null(llptrty), llptrptr)\n             }\n         }\n@@ -1041,7 +1080,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n                          false)\n             } else {\n                 let vals = nonnull.fields.iter().map(|&ty| {\n-                    // Always use null even if it's not the `ptrfield`th\n+                    // Always use null even if it's not the `discrfield`th\n                     // field; see #8506.\n                     C_null(type_of::sizing_type_of(ccx, ty))\n                 }).collect::<Vec<ValueRef>>();\n@@ -1121,9 +1160,8 @@ fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n #[inline]\n fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }\n \n-/// Get the discriminant of a constant value.  (Not currently used.)\n-pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n-    -> Disr {\n+/// Get the discriminant of a constant value.\n+pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef) -> Disr {\n     match *r {\n         CEnum(ity, _, _) => {\n             match ity {\n@@ -1138,25 +1176,8 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n             }\n         }\n         Univariant(..) => 0,\n-        RawNullablePointer { nndiscr, .. } => {\n-            if is_null(val) {\n-                /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n-                (1 - nndiscr) as Disr\n-            } else {\n-                nndiscr\n-            }\n-        }\n-        StructWrappedNullablePointer { nndiscr, ptrfield, .. } => {\n-            let (idx, sub_idx) = match ptrfield {\n-                ThinPointer(field) => (field, None),\n-                FatPointer(field) => (field, Some(abi::FAT_PTR_ADDR))\n-            };\n-            if is_null(const_struct_field(ccx, val, idx, sub_idx)) {\n-                /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n-                (1 - nndiscr) as Disr\n-            } else {\n-                nndiscr\n-            }\n+        RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n+            ccx.sess().bug(\"const discrim access of non c-like enum\")\n         }\n     }\n }\n@@ -1170,29 +1191,25 @@ pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n                        _discr: Disr, ix: uint) -> ValueRef {\n     match *r {\n         CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n-        Univariant(..) => const_struct_field(ccx, val, ix, None),\n-        General(..) => const_struct_field(ccx, val, ix + 1, None),\n+        Univariant(..) => const_struct_field(ccx, val, ix),\n+        General(..) => const_struct_field(ccx, val, ix + 1),\n         RawNullablePointer { .. } => {\n             assert_eq!(ix, 0);\n             val\n-        }\n-        StructWrappedNullablePointer{ .. } => const_struct_field(ccx, val, ix, None)\n+        },\n+        StructWrappedNullablePointer{ .. } => const_struct_field(ccx, val, ix)\n     }\n }\n \n /// Extract field of struct-like const, skipping our alignment padding.\n-fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint, sub_idx: Option<uint>)\n-    -> ValueRef {\n+fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint) -> ValueRef {\n     // Get the ix-th non-undef element of the struct.\n     let mut real_ix = 0; // actual position in the struct\n     let mut ix = ix; // logical index relative to real_ix\n     let mut field;\n     loop {\n         loop {\n-            field = match sub_idx {\n-                Some(si) => const_get_elt(ccx, val, &[real_ix, si as u32]),\n-                None => const_get_elt(ccx, val, &[real_ix])\n-            };\n+            field = const_get_elt(ccx, val, &[real_ix]);\n             if !is_undef(field) {\n                 break;\n             }"}, {"sha": "d080cda4b819a8953109ed6e6c0671f79bed9af2", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=25fb12b8a5411901675ede6b147bbc6c0b7437b7", "patch": "@@ -750,6 +750,7 @@ pub fn is_undef(val: ValueRef) -> bool {\n     }\n }\n \n+#[allow(dead_code)] // potentially useful\n pub fn is_null(val: ValueRef) -> bool {\n     unsafe {\n         llvm::LLVMIsNull(val) != False"}, {"sha": "b8c4a23b87accaf1b5945a298e07aa98f34c614f", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=25fb12b8a5411901675ede6b147bbc6c0b7437b7", "patch": "@@ -2292,14 +2292,14 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n             },\n             adt::StructWrappedNullablePointer { nonnull: ref struct_def,\n                                                 nndiscr,\n-                                                ptrfield, ..} => {\n+                                                ref discrfield, ..} => {\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n                     describe_enum_variant(cx,\n                                           self.enum_type,\n                                           struct_def,\n                                           &*(*self.variants)[nndiscr as uint],\n-                                          OptimizedDiscriminant(ptrfield),\n+                                          OptimizedDiscriminant,\n                                           self.containing_scope,\n                                           self.span);\n \n@@ -2315,10 +2315,10 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // member's name.\n                 let null_variant_index = (1 - nndiscr) as uint;\n                 let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n-                let discrfield = match ptrfield {\n-                    adt::ThinPointer(field) => format!(\"{}\", field),\n-                    adt::FatPointer(field) => format!(\"{}\", field)\n-                };\n+                let discrfield = discrfield.iter()\n+                                           .skip(1)\n+                                           .map(|x| x.to_string())\n+                                           .collect::<Vec<_>>().connect(\"$\");\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 discrfield,\n                                                 null_variant_name);\n@@ -2367,7 +2367,7 @@ impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n #[deriving(Copy)]\n enum EnumDiscriminantInfo {\n     RegularDiscriminant(DIType),\n-    OptimizedDiscriminant(adt::PointerField),\n+    OptimizedDiscriminant,\n     NoDiscriminant\n }\n "}, {"sha": "d8d74c8bb45ae2eaa7cbba22f4264e378494a8be", "filename": "src/test/run-pass/enum-null-pointer-opt.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fb12b8a5411901675ede6b147bbc6c0b7437b7/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs?ref=25fb12b8a5411901675ede6b147bbc6c0b7437b7", "patch": "@@ -9,7 +9,12 @@\n // except according to those terms.\n \n \n+extern crate core;\n+\n+use core::nonzero::NonZero;\n use std::mem::size_of;\n+use std::rc::Rc;\n+use std::sync::Arc;\n \n trait Trait {}\n \n@@ -34,9 +39,33 @@ fn main() {\n     // Pointers - Box<T>\n     assert_eq!(size_of::<Box<int>>(), size_of::<Option<Box<int>>>());\n \n-\n     // The optimization can't apply to raw pointers\n     assert!(size_of::<Option<*const int>>() != size_of::<*const int>());\n     assert!(Some(0 as *const int).is_some()); // Can't collapse None to null\n \n+    struct Foo {\n+        _a: Box<int>\n+    }\n+    struct Bar(Box<int>);\n+\n+    // Should apply through structs\n+    assert_eq!(size_of::<Foo>(), size_of::<Option<Foo>>());\n+    assert_eq!(size_of::<Bar>(), size_of::<Option<Bar>>());\n+    // and tuples\n+    assert_eq!(size_of::<(u8, Box<int>)>(), size_of::<Option<(u8, Box<int>)>>());\n+    // and fixed-size arrays\n+    assert_eq!(size_of::<[Box<int>, ..1]>(), size_of::<Option<[Box<int>, ..1]>>());\n+\n+    // Should apply to NonZero\n+    assert_eq!(size_of::<NonZero<uint>>(), size_of::<Option<NonZero<uint>>>());\n+    assert_eq!(size_of::<NonZero<*mut i8>>(), size_of::<Option<NonZero<*mut i8>>>());\n+\n+    // Should apply to types that use NonZero internally\n+    assert_eq!(size_of::<Vec<int>>(), size_of::<Option<Vec<int>>>());\n+    assert_eq!(size_of::<Arc<int>>(), size_of::<Option<Arc<int>>>());\n+    assert_eq!(size_of::<Rc<int>>(), size_of::<Option<Rc<int>>>());\n+\n+    // Should apply to types that have NonZero transitively\n+    assert_eq!(size_of::<String>(), size_of::<Option<String>>());\n+\n }"}]}