{"sha": "8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNmM2ZDdjYWRjZWI3YWQ2ZmM5YzI4MDY3NGJiNjI5YjFlMzAwMDM=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-06-23T20:19:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-23T20:19:38Z"}, "message": "Merge pull request #212 from oli-obk/zero_sense_types\n\nRemove the zst allocation", "tree": {"sha": "7e68e6de63164f026f198858ef651829c2ee130c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e68e6de63164f026f198858ef651829c2ee130c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "html_url": "https://github.com/rust-lang/rust/commit/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f10dd417cb798c7fb497154ddf893be440bf0f27", "url": "https://api.github.com/repos/rust-lang/rust/commits/f10dd417cb798c7fb497154ddf893be440bf0f27", "html_url": "https://github.com/rust-lang/rust/commit/f10dd417cb798c7fb497154ddf893be440bf0f27"}, {"sha": "377fcce9b8ab548f8b42dd7b39461de2aa9ad38a", "url": "https://api.github.com/repos/rust-lang/rust/commits/377fcce9b8ab548f8b42dd7b39461de2aa9ad38a", "html_url": "https://github.com/rust-lang/rust/commit/377fcce9b8ab548f8b42dd7b39461de2aa9ad38a"}], "stats": {"total": 160, "additions": 102, "deletions": 58}, "files": [{"sha": "0c23038c3c3542730a034f9c834e2833cc1368d3", "filename": "src/error.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "patch": "@@ -59,6 +59,8 @@ pub enum EvalError<'tcx> {\n     ReallocatedStaticMemory,\n     DeallocatedStaticMemory,\n     Layout(layout::LayoutError<'tcx>),\n+    HeapAllocZeroBytes,\n+    HeapAllocNonPowerOfTwoAlignment(u64),\n     Unreachable,\n     Panic,\n }\n@@ -89,7 +91,7 @@ impl<'tcx> Error for EvalError<'tcx> {\n             EvalError::ReadBytesAsPointer =>\n                 \"a memory access tried to interpret some bytes as a pointer\",\n             EvalError::InvalidPointerMath =>\n-                \"attempted to do invalid arithmetic on pointers that would leak base addresses, e.g. compating pointers into different allocations\",\n+                \"attempted to do invalid arithmetic on pointers that would leak base addresses, e.g. comparing pointers into different allocations\",\n             EvalError::ReadUndefBytes =>\n                 \"attempted to read undefined bytes\",\n             EvalError::DeadLocal =>\n@@ -146,6 +148,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"rustc layout computation failed\",\n             EvalError::UnterminatedCString(_) =>\n                 \"attempted to get length of a null terminated string, but no null found before end of allocation\",\n+            EvalError::HeapAllocZeroBytes =>\n+                \"tried to re-, de- or allocate zero bytes on the heap\",\n+            EvalError::HeapAllocNonPowerOfTwoAlignment(_) =>\n+                \"tried to re-, de-, or allocate heap memory with alignment that is not a power of two\",\n             EvalError::Unreachable =>\n                 \"entered unreachable code\",\n             EvalError::Panic =>"}, {"sha": "7052a411f7e2c3a89fb8826cad2303fe24fe8b80", "filename": "src/eval_context.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "patch": "@@ -362,15 +362,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             StackPopCleanup::None => {},\n             StackPopCleanup::Tls(key) => {\n                 // either fetch the next dtor or start new from the beginning, if any are left with a non-null data\n-                if let Some((instance, ptr, key)) = self.memory.fetch_tls_dtor(key).or_else(|| self.memory.fetch_tls_dtor(None)) {\n+                let dtor = match self.memory.fetch_tls_dtor(key)? {\n+                    dtor @ Some(_) => dtor,\n+                    None => self.memory.fetch_tls_dtor(None)?,\n+                };\n+                if let Some((instance, ptr, key)) = dtor {\n                     trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n                     // TODO: Potentially, this has to support all the other possible instances? See eval_fn_call in terminator/mod.rs\n                     let mir = self.load_mir(instance.def)?;\n                     self.push_stack_frame(\n                         instance,\n                         mir.span,\n                         mir,\n-                        Lvalue::zst(),\n+                        Lvalue::undef(),\n                         StackPopCleanup::Tls(Some(key)),\n                     )?;\n                     let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n@@ -673,8 +677,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             NullaryOp(mir::NullOp::Box, ty) => {\n-                let ptr = self.alloc_ptr(ty)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+                // FIXME: call the `exchange_malloc` lang item if available\n+                if self.type_size(ty)?.expect(\"box only works with sized types\") == 0 {\n+                    let align = self.type_align(ty)?;\n+                    self.write_primval(dest, PrimVal::Bytes(align.into()), dest_ty)?;\n+                } else {\n+                    let ptr = self.alloc_ptr(ty)?;\n+                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+                }\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n@@ -904,11 +914,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n         return if let Some(offset) = offset.checked_mul(pointee_size) {\n             let ptr = ptr.signed_offset(offset, self.memory.layout)?;\n-            // Do not do bounds-checking for integers or ZST; they can never alias a normal pointer anyway.\n+            // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n             if let PrimVal::Ptr(ptr) = ptr {\n-                if !(ptr.points_to_zst() && (offset == 0 || pointee_size == 0)) {\n-                    self.memory.check_bounds(ptr, false)?;\n-                }\n+                self.memory.check_bounds(ptr, false)?;\n             } else if ptr.is_null()? {\n                 // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n                 return Err(EvalError::NullPointerOutOfBounds);\n@@ -1697,7 +1705,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 main_instance,\n                 main_mir.span,\n                 main_mir,\n-                Lvalue::zst(),\n+                Lvalue::undef(),\n                 StackPopCleanup::Tls(None),\n             )?;\n         }"}, {"sha": "8492019a9bf89c362c931a017f086428c1edd38e", "filename": "src/lvalue.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "patch": "@@ -8,7 +8,7 @@ use eval_context::{EvalContext};\n use memory::Pointer;\n use value::{PrimVal, Value};\n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+#[derive(Copy, Clone, Debug)]\n pub enum Lvalue<'tcx> {\n     /// An lvalue referring to a value allocated in the `Memory` system.\n     Ptr {\n@@ -73,10 +73,6 @@ impl<'tcx> Lvalue<'tcx> {\n         Lvalue::Ptr { ptr, extra: LvalueExtra::None }\n     }\n \n-    pub fn zst() -> Self {\n-        Self::from_ptr(Pointer::zst_ptr())\n-    }\n-\n     pub fn from_ptr(ptr: Pointer) -> Self {\n         Self::from_primval_ptr(PrimVal::Ptr(ptr))\n     }"}, {"sha": "5794dc783cfed9e8a87c31909c8eed6335b54b92", "filename": "src/memory.rs", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "patch": "@@ -81,14 +81,6 @@ impl Pointer {\n     pub fn offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n         Ok(Pointer::new(self.alloc_id, value::offset(self.offset, i, layout)?))\n     }\n-\n-    pub fn points_to_zst(&self) -> bool {\n-        self.alloc_id == ZST_ALLOC_ID\n-    }\n-\n-    pub fn zst_ptr() -> Self {\n-        Pointer::new(ZST_ALLOC_ID, 0)\n-    }\n }\n \n pub type TlsKey = usize;\n@@ -157,15 +149,13 @@ pub struct Memory<'a, 'tcx> {\n     next_thread_local: TlsKey,\n }\n \n-const ZST_ALLOC_ID: AllocId = AllocId(0);\n-\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn new(layout: &'a TargetDataLayout, max_memory: u64) -> Self {\n         Memory {\n             alloc_map: HashMap::new(),\n             functions: HashMap::new(),\n             function_alloc_cache: HashMap::new(),\n-            next_id: AllocId(2),\n+            next_id: AllocId(0),\n             layout,\n             memory_size: max_memory,\n             memory_usage: 0,\n@@ -206,10 +196,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn allocate(&mut self, size: u64, align: u64) -> EvalResult<'tcx, Pointer> {\n-        if size == 0 {\n-            return Ok(Pointer::zst_ptr());\n-        }\n         assert_ne!(align, 0);\n+        assert!(align.is_power_of_two());\n \n         if self.memory_size - self.memory_usage < size {\n             return Err(EvalError::OutOfMemory {\n@@ -236,13 +224,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n     pub fn reallocate(&mut self, ptr: Pointer, new_size: u64, align: u64) -> EvalResult<'tcx, Pointer> {\n+        assert!(align.is_power_of_two());\n         // TODO(solson): Report error about non-__rust_allocate'd pointer.\n         if ptr.offset != 0 {\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n-        if ptr.points_to_zst() {\n-            return self.allocate(new_size, align);\n-        }\n         if self.get(ptr.alloc_id).ok().map_or(false, |alloc| alloc.static_kind != StaticKind::NotStatic) {\n             return Err(EvalError::ReallocatedStaticMemory);\n         }\n@@ -253,13 +239,15 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             let amount = new_size - size;\n             self.memory_usage += amount;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n+            // FIXME: check alignment here\n             assert_eq!(amount as usize as u64, amount);\n             alloc.bytes.extend(iter::repeat(0).take(amount as usize));\n             alloc.undef_mask.grow(amount, false);\n         } else if size > new_size {\n             self.memory_usage -= size - new_size;\n             self.clear_relocations(ptr.offset(new_size, self.layout)?, size - new_size)?;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n+            // FIXME: check alignment here\n             // `as usize` is fine here, since it is smaller than `size`, which came from a usize\n             alloc.bytes.truncate(new_size as usize);\n             alloc.bytes.shrink_to_fit();\n@@ -271,9 +259,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     // TODO(solson): See comment on `reallocate`.\n     pub fn deallocate(&mut self, ptr: Pointer) -> EvalResult<'tcx> {\n-        if ptr.points_to_zst() {\n-            return Ok(());\n-        }\n         if ptr.offset != 0 {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n@@ -419,22 +404,22 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     /// with associated destructors, implementations may stop calling destructors,\n     /// or they may continue calling destructors until no non-NULL values with\n     /// associated destructors exist, even though this might result in an infinite loop.\n-    pub(crate) fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> Option<(ty::Instance<'tcx>, PrimVal, TlsKey)> {\n+    pub(crate) fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, PrimVal, TlsKey)>> {\n         use std::collections::Bound::*;\n         let start = match key {\n             Some(key) => Excluded(key),\n             None => Unbounded,\n         };\n         for (&key, &mut TlsEntry { ref mut data, dtor }) in self.thread_local.range_mut((start, Unbounded)) {\n-            if *data != PrimVal::Bytes(0) {\n+            if !data.is_null()? {\n                 if let Some(dtor) = dtor {\n                     let ret = Some((dtor, *data, key));\n                     *data = PrimVal::Bytes(0);\n-                    return ret;\n+                    return Ok(ret);\n                 }\n             }\n         }\n-        return None;\n+        return Ok(None);\n     }\n }\n \n@@ -459,7 +444,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n-                None if id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n                 None => Err(EvalError::DanglingPointerDeref),\n             }\n         }\n@@ -474,7 +458,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             },\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n-                None if id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n                 None => Err(EvalError::DanglingPointerDeref),\n             }\n         }\n@@ -508,7 +491,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let mut allocs_seen = HashSet::new();\n \n         while let Some(id) = allocs_to_print.pop_front() {\n-            if id == ZST_ALLOC_ID { continue; }\n             let mut msg = format!(\"Alloc {:<5} \", format!(\"{}:\", id));\n             let prefix_len = msg.len();\n             let mut relocations = vec![];\n@@ -556,10 +538,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 for (i, target_id) in relocations {\n                     // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n                     write!(msg, \"{:1$}\", \"\", ((i - pos) * 3) as usize).unwrap();\n-                    let target = match target_id {\n-                        ZST_ALLOC_ID => String::from(\"zst\"),\n-                        _ => format!(\"({})\", target_id),\n-                    };\n+                    let target = format!(\"({})\", target_id);\n                     // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n                     write!(msg, \"\u2514{0:\u2500^1$}\u2518 \", target, relocation_width as usize).unwrap();\n                     pos = i + self.pointer_size();\n@@ -637,7 +616,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     /// mark an allocation as being the entry point to a static (see `static_alloc` field)\n     pub fn mark_static(&mut self, alloc_id: AllocId) {\n         trace!(\"mark_static: {:?}\", alloc_id);\n-        if alloc_id != ZST_ALLOC_ID && !self.static_alloc.insert(alloc_id) {\n+        if !self.static_alloc.insert(alloc_id) {\n             bug!(\"tried to mark an allocation ({:?}) as static twice\", alloc_id);\n         }\n     }\n@@ -667,7 +646,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 // mark recursively\n                 mem::replace(relocations, Default::default())\n             },\n-            None if alloc_id == ZST_ALLOC_ID => return Ok(()),\n             None if !self.functions.contains_key(&alloc_id) => return Err(EvalError::DanglingPointerDeref),\n             _ => return Ok(()),\n         };"}, {"sha": "e5ed99b24341aeee2b510a9fcac0237c4fcec0b2", "filename": "src/operator.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "patch": "@@ -159,10 +159,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 },\n                 // These work on anything\n                 Eq if left_kind == right_kind => {\n-                    return Ok((PrimVal::from_bool(left == right), false));\n+                    let result = match (left, right) {\n+                        (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left == right,\n+                        (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left == right,\n+                        (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n+                        _ => false,\n+                    };\n+                    return Ok((PrimVal::from_bool(result), false));\n                 }\n                 Ne if left_kind == right_kind => {\n-                    return Ok((PrimVal::from_bool(left != right), false));\n+                    let result = match (left, right) {\n+                        (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left != right,\n+                        (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left != right,\n+                        (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n+                        _ => true,\n+                    };\n+                    return Ok((PrimVal::from_bool(result), false));\n                 }\n                 // These need both pointers to be in the same allocation\n                 Lt | Le | Gt | Ge | Sub"}, {"sha": "072a5d16a1bea2a1b85e26228ba9e00d88bf20f5", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             instance,\n             span,\n             mir,\n-            Lvalue::zst(),\n+            Lvalue::undef(),\n             StackPopCleanup::None,\n         )?;\n "}, {"sha": "c773620cbb581d827a9a5a895bd3278d774d2e74", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "patch": "@@ -596,13 +596,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"__rust_allocate\" => {\n                 let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n                 let ptr = self.memory.allocate(size, align)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n \n             \"__rust_allocate_zeroed\" => {\n                 let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n                 let ptr = self.memory.allocate(size, align)?;\n                 self.memory.write_repeat(ptr, 0, size)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n@@ -611,15 +623,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"__rust_deallocate\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n                 // FIXME: insert sanity check for size and align?\n-                let _old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let _align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if old_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n                 self.memory.deallocate(ptr)?;\n             },\n \n             \"__rust_reallocate\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n                 let size = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[3], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n                 let new_ptr = self.memory.reallocate(ptr, size, align)?;\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n@@ -640,7 +664,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     f_instance,\n                     mir.span,\n                     mir,\n-                    Lvalue::zst(),\n+                    Lvalue::undef(),\n                     StackPopCleanup::Goto(dest_block),\n                 )?;\n "}, {"sha": "85f79b7831e1850b542aa1cb22f26bceb990a395", "filename": "src/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "patch": "@@ -42,7 +42,7 @@ pub enum Value {\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `PrimVal` can either represent the raw bytes\n /// of a simple value, a pointer into another `Allocation`, or be undefined.\n-#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+#[derive(Clone, Copy, Debug)]\n pub enum PrimVal {\n     /// The raw bytes of a simple value.\n     Bytes(u128),"}, {"sha": "3439824047943c08b83493a6a0d25ed5bd90edcd", "filename": "tests/compile-fail/zst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/tests%2Fcompile-fail%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/tests%2Fcompile-fail%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst.rs?ref=8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     let x = &() as *const () as *const i32;\n-    let _ = unsafe { *x }; //~ ERROR: tried to access memory through an invalid pointer\n+    let _ = unsafe { *x }; //~ ERROR: tried to access memory with alignment 1, but alignment 4 is required\n }"}, {"sha": "1bf42062de6c24798d689968a4e727b2666e80c3", "filename": "tests/compile-fail/zst2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/tests%2Fcompile-fail%2Fzst2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/tests%2Fcompile-fail%2Fzst2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst2.rs?ref=8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "patch": "@@ -0,0 +1,11 @@\n+// error-pattern: the evaluated program panicked\n+\n+#[derive(Debug)]\n+struct A;\n+\n+fn main() {\n+    // can't use assert_eq, b/c that will try to print the pointer addresses with full MIR enabled\n+    if &A as *const A as *const () != &() as *const _ {\n+        panic!()\n+    }\n+}"}, {"sha": "55cdd661d3d4331eac3ed5712e7a975401eb691b", "filename": "tests/compile-fail/zst3.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/tests%2Fcompile-fail%2Fzst3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/tests%2Fcompile-fail%2Fzst3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst3.rs?ref=8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "patch": "@@ -0,0 +1,11 @@\n+// error-pattern: the evaluated program panicked\n+\n+#[derive(Debug)]\n+struct A;\n+\n+fn main() {\n+    // can't use assert_eq, b/c that will try to print the pointer addresses with full MIR enabled\n+    if &A as *const A != &A as *const A {\n+        panic!();\n+    }\n+}"}, {"sha": "c1c88875c5c80f8e514d64d2f1baa72f6e17d01b", "filename": "tests/run-pass/zst.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/tests%2Frun-pass%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c6d7cadceb7ad6fc9c280674bb629b1e30003/tests%2Frun-pass%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzst.rs?ref=8c6c6d7cadceb7ad6fc9c280674bb629b1e30003", "patch": "@@ -13,8 +13,6 @@ fn use_zst() -> A {\n fn main() {\n     assert_eq!(zst_ret(), A);\n     assert_eq!(use_zst(), A);\n-    assert_eq!(&A as *const A as *const (), &() as *const _);\n-    assert_eq!(&A as *const A, &A as *const A);\n     let x = 42 as *mut ();\n     unsafe { *x = (); }\n }"}]}