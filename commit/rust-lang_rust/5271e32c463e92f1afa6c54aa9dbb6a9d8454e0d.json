{"sha": "5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "node_id": "C_kwDOAAsO6NoAKDUyNzFlMzJjNDYzZTkyZjFhZmE2YzU0YWE5ZGJiNmE5ZDg0NTRlMGQ", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-06-16T21:14:38Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-07-19T15:52:24Z"}, "message": "Improve the function pointer docs\n\n* Reduce duplicate impls; show only the `fn (T)` and include a sentence\n  saying that there exists up to twelve of them.\n* Show `Copy` and `Clone`.\n* Show auto traits like `Send` and `Sync`, and blanket impls like `Any`.", "tree": {"sha": "e581e268c8ee56abea809e888571b9a41066fdee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e581e268c8ee56abea809e888571b9a41066fdee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "html_url": "https://github.com/rust-lang/rust/commit/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1169832f2ff1ce740dc3d68de2df3745ec4e1aef", "url": "https://api.github.com/repos/rust-lang/rust/commits/1169832f2ff1ce740dc3d68de2df3745ec4e1aef", "html_url": "https://github.com/rust-lang/rust/commit/1169832f2ff1ce740dc3d68de2df3745ec4e1aef"}], "stats": {"total": 291, "additions": 222, "deletions": 69}, "files": [{"sha": "cfabae1a6346d6a2d0217d4622efb5706d06ed2f", "filename": "compiler/rustc_error_codes/src/error_codes/E0118.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0118.md", "raw_url": "https://github.com/rust-lang/rust/raw/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0118.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0118.md?ref=5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "patch": "@@ -4,7 +4,7 @@ enum, union, or trait object.\n Erroneous code example:\n \n ```compile_fail,E0118\n-impl fn(u8) { // error: no nominal type found for inherent implementation\n+impl<T> T { // error: no nominal type found for inherent implementation\n     fn get_state(&self) -> String {\n         // ...\n     }\n@@ -20,8 +20,8 @@ trait LiveLongAndProsper {\n     fn get_state(&self) -> String;\n }\n \n-// and now you can implement it on fn(u8)\n-impl LiveLongAndProsper for fn(u8) {\n+// and now you can implement it on T\n+impl<T> LiveLongAndProsper for T {\n     fn get_state(&self) -> String {\n         \"He's dead, Jim!\".to_owned()\n     }\n@@ -33,9 +33,9 @@ For example, `NewType` is a newtype over `Foo` in `struct NewType(Foo)`.\n Example:\n \n ```\n-struct TypeWrapper(fn(u8));\n+struct TypeWrapper<T>(T);\n \n-impl TypeWrapper {\n+impl<T> TypeWrapper<T> {\n     fn get_state(&self) -> String {\n         \"Fascinating!\".to_owned()\n     }"}, {"sha": "52aad636fd88ac887da8d5b229c7f94ae72c6d01", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "patch": "@@ -219,8 +219,9 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::RawPtr(_)\n             | ty::Ref(..)\n             | ty::Never\n+            | ty::FnPtr(_)\n             | ty::Tuple(..) => self.check_primitive_impl(item.def_id, self_ty, items, ty.span),\n-            ty::FnPtr(_) | ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n+            ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     ty.span,"}, {"sha": "b8e5461640c0581ea4a242fb7724aea2140c01da", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "patch": "@@ -1441,11 +1441,16 @@ mod prim_ref {}\n /// Note that all of this is not portable to platforms where function pointers and data pointers\n /// have different sizes.\n ///\n-/// ### Traits\n+/// ### Trait implementations\n ///\n-/// Function pointers implement the following traits:\n+/// In this documentation the shorthand `fn (T\u2081, T\u2082, \u2026, T\u2099)` is used to represent non-variadic\n+/// function pointers of varying length. Note that this is a convenience notation to avoid\n+/// repetitive documentation, not valid Rust syntax.\n+///\n+/// Due to a temporary restriction in Rust's type system, these traits are only implemented on\n+/// functions that take 12 arguments or less, with the `\"Rust\"` and `\"C\"` ABIs. In the future, this\n+/// may change:\n ///\n-/// * [`Clone`]\n /// * [`PartialEq`]\n /// * [`Eq`]\n /// * [`PartialOrd`]\n@@ -1454,15 +1459,50 @@ mod prim_ref {}\n /// * [`Pointer`]\n /// * [`Debug`]\n ///\n+/// The following traits are implemented for function pointers with any number of arguments and\n+/// any ABI. These traits have implementations that are automatically generated by the compiler,\n+/// so are not limited by missing language features:\n+///\n+/// * [`Clone`]\n+/// * [`Copy`]\n+/// * [`Send`]\n+/// * [`Sync`]\n+/// * [`Unpin`]\n+/// * [`UnwindSafe`]\n+/// * [`RefUnwindSafe`]\n+///\n /// [`Hash`]: hash::Hash\n /// [`Pointer`]: fmt::Pointer\n+/// [`UnwindSafe`]: panic::UnwindSafe\n+/// [`RefUnwindSafe`]: panic::RefUnwindSafe\n ///\n-/// Due to a temporary restriction in Rust's type system, these traits are only implemented on\n-/// functions that take 12 arguments or less, with the `\"Rust\"` and `\"C\"` ABIs. In the future, this\n-/// may change.\n-///\n-/// In addition, function pointers of *any* signature, ABI, or safety are [`Copy`], and all *safe*\n-/// function pointers implement [`Fn`], [`FnMut`], and [`FnOnce`]. This works because these traits\n-/// are specially known to the compiler.\n+/// In addition, all *safe* function pointers implement [`Fn`], [`FnMut`], and [`FnOnce`], because\n+/// these traits are specially known to the compiler.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_fn {}\n+\n+// Required to make auto trait impls render.\n+// See src/librustdoc/passes/collect_trait_impls.rs:collect_trait_impls\n+#[doc(hidden)]\n+#[cfg(not(bootstrap))]\n+impl<Ret, T> fn(T) -> Ret {}\n+\n+// Fake impl that's only really used for docs.\n+#[cfg(doc)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(bootstrap), doc(fake_variadic))]\n+/// This trait is implemented on function pointers with any number of arguments.\n+impl<Ret, T> Clone for fn(T) -> Ret {\n+    fn clone(&self) -> Self {\n+        loop {}\n+    }\n+}\n+\n+// Fake impl that's only really used for docs.\n+#[cfg(doc)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(bootstrap), doc(fake_variadic))]\n+/// This trait is implemented on function pointers with any number of arguments.\n+impl<Ret, T> Copy for fn(T) -> Ret {\n+    // empty\n+}"}, {"sha": "caa279f0de579188b1e2cd6f35fbe9e09929670e", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 71, "deletions": 29, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "patch": "@@ -1819,6 +1819,27 @@ pub fn hash<T: ?Sized, S: hash::Hasher>(hashee: *const T, into: &mut S) {\n     hashee.hash(into);\n }\n \n+// If this is a unary fn pointer, it adds a doc comment.\n+// Otherwise, it hides the docs entirely.\n+macro_rules! maybe_fnptr_doc {\n+    (@ #[$meta:meta] $item:item) => {\n+        #[doc(hidden)]\n+        #[$meta]\n+        $item\n+    };\n+    ($a:ident @ #[$meta:meta] $item:item) => {\n+        #[cfg_attr(not(bootstrap), doc(fake_variadic))]\n+        #[doc = \"This trait is implemented for function pointers with up to twelve arguments.\"]\n+        #[$meta]\n+        $item\n+    };\n+    ($a:ident $($rest_a:ident)+ @ #[$meta:meta] $item:item) => {\n+        #[doc(hidden)]\n+        #[$meta]\n+        $item\n+    };\n+}\n+\n // FIXME(strict_provenance_magic): function pointers have buggy codegen that\n // necessitates casting to a usize to get the backend to do the right thing.\n // for now I will break AVR to silence *a billion* lints. We should probably\n@@ -1827,51 +1848,72 @@ pub fn hash<T: ?Sized, S: hash::Hasher>(hashee: *const T, into: &mut S) {\n // Impls for function pointers\n macro_rules! fnptr_impls_safety_abi {\n     ($FnTy: ty, $($Arg: ident),*) => {\n-        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n-        impl<Ret, $($Arg),*> PartialEq for $FnTy {\n-            #[inline]\n-            fn eq(&self, other: &Self) -> bool {\n-                *self as usize == *other as usize\n+        maybe_fnptr_doc! {\n+            $($Arg)* @\n+            #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+            impl<Ret, $($Arg),*> PartialEq for $FnTy {\n+                #[inline]\n+                fn eq(&self, other: &Self) -> bool {\n+                    *self as usize == *other as usize\n+                }\n             }\n         }\n \n-        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n-        impl<Ret, $($Arg),*> Eq for $FnTy {}\n+        maybe_fnptr_doc! {\n+            $($Arg)* @\n+            #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+            impl<Ret, $($Arg),*> Eq for $FnTy {}\n+        }\n \n-        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n-        impl<Ret, $($Arg),*> PartialOrd for $FnTy {\n-            #[inline]\n-            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-                (*self as usize).partial_cmp(&(*other as usize))\n+        maybe_fnptr_doc! {\n+            $($Arg)* @\n+            #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+            impl<Ret, $($Arg),*> PartialOrd for $FnTy {\n+                #[inline]\n+                fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+                    (*self as usize).partial_cmp(&(*other as usize))\n+                }\n             }\n         }\n \n-        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n-        impl<Ret, $($Arg),*> Ord for $FnTy {\n-            #[inline]\n-            fn cmp(&self, other: &Self) -> Ordering {\n-                (*self as usize).cmp(&(*other as usize))\n+        maybe_fnptr_doc! {\n+            $($Arg)* @\n+            #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+            impl<Ret, $($Arg),*> Ord for $FnTy {\n+                #[inline]\n+                fn cmp(&self, other: &Self) -> Ordering {\n+                    (*self as usize).cmp(&(*other as usize))\n+                }\n             }\n         }\n \n-        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n-        impl<Ret, $($Arg),*> hash::Hash for $FnTy {\n-            fn hash<HH: hash::Hasher>(&self, state: &mut HH) {\n-                state.write_usize(*self as usize)\n+        maybe_fnptr_doc! {\n+            $($Arg)* @\n+            #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+            impl<Ret, $($Arg),*> hash::Hash for $FnTy {\n+                fn hash<HH: hash::Hasher>(&self, state: &mut HH) {\n+                    state.write_usize(*self as usize)\n+                }\n             }\n         }\n \n-        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n-        impl<Ret, $($Arg),*> fmt::Pointer for $FnTy {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                fmt::pointer_fmt_inner(*self as usize, f)\n+        maybe_fnptr_doc! {\n+            $($Arg)* @\n+            #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+            impl<Ret, $($Arg),*> fmt::Pointer for $FnTy {\n+                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                    fmt::pointer_fmt_inner(*self as usize, f)\n+                }\n             }\n         }\n \n-        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n-        impl<Ret, $($Arg),*> fmt::Debug for $FnTy {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                fmt::pointer_fmt_inner(*self as usize, f)\n+        maybe_fnptr_doc! {\n+            $($Arg)* @\n+            #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+            impl<Ret, $($Arg),*> fmt::Debug for $FnTy {\n+                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                    fmt::pointer_fmt_inner(*self as usize, f)\n+                }\n             }\n         }\n     }"}, {"sha": "b8e5461640c0581ea4a242fb7724aea2140c01da", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "patch": "@@ -1441,11 +1441,16 @@ mod prim_ref {}\n /// Note that all of this is not portable to platforms where function pointers and data pointers\n /// have different sizes.\n ///\n-/// ### Traits\n+/// ### Trait implementations\n ///\n-/// Function pointers implement the following traits:\n+/// In this documentation the shorthand `fn (T\u2081, T\u2082, \u2026, T\u2099)` is used to represent non-variadic\n+/// function pointers of varying length. Note that this is a convenience notation to avoid\n+/// repetitive documentation, not valid Rust syntax.\n+///\n+/// Due to a temporary restriction in Rust's type system, these traits are only implemented on\n+/// functions that take 12 arguments or less, with the `\"Rust\"` and `\"C\"` ABIs. In the future, this\n+/// may change:\n ///\n-/// * [`Clone`]\n /// * [`PartialEq`]\n /// * [`Eq`]\n /// * [`PartialOrd`]\n@@ -1454,15 +1459,50 @@ mod prim_ref {}\n /// * [`Pointer`]\n /// * [`Debug`]\n ///\n+/// The following traits are implemented for function pointers with any number of arguments and\n+/// any ABI. These traits have implementations that are automatically generated by the compiler,\n+/// so are not limited by missing language features:\n+///\n+/// * [`Clone`]\n+/// * [`Copy`]\n+/// * [`Send`]\n+/// * [`Sync`]\n+/// * [`Unpin`]\n+/// * [`UnwindSafe`]\n+/// * [`RefUnwindSafe`]\n+///\n /// [`Hash`]: hash::Hash\n /// [`Pointer`]: fmt::Pointer\n+/// [`UnwindSafe`]: panic::UnwindSafe\n+/// [`RefUnwindSafe`]: panic::RefUnwindSafe\n ///\n-/// Due to a temporary restriction in Rust's type system, these traits are only implemented on\n-/// functions that take 12 arguments or less, with the `\"Rust\"` and `\"C\"` ABIs. In the future, this\n-/// may change.\n-///\n-/// In addition, function pointers of *any* signature, ABI, or safety are [`Copy`], and all *safe*\n-/// function pointers implement [`Fn`], [`FnMut`], and [`FnOnce`]. This works because these traits\n-/// are specially known to the compiler.\n+/// In addition, all *safe* function pointers implement [`Fn`], [`FnMut`], and [`FnOnce`], because\n+/// these traits are specially known to the compiler.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_fn {}\n+\n+// Required to make auto trait impls render.\n+// See src/librustdoc/passes/collect_trait_impls.rs:collect_trait_impls\n+#[doc(hidden)]\n+#[cfg(not(bootstrap))]\n+impl<Ret, T> fn(T) -> Ret {}\n+\n+// Fake impl that's only really used for docs.\n+#[cfg(doc)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(bootstrap), doc(fake_variadic))]\n+/// This trait is implemented on function pointers with any number of arguments.\n+impl<Ret, T> Clone for fn(T) -> Ret {\n+    fn clone(&self) -> Self {\n+        loop {}\n+    }\n+}\n+\n+// Fake impl that's only really used for docs.\n+#[cfg(doc)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(bootstrap), doc(fake_variadic))]\n+/// This trait is implemented on function pointers with any number of arguments.\n+impl<Ret, T> Copy for fn(T) -> Ret {\n+    // empty\n+}"}, {"sha": "8c08f77667904769c4a855f9f7ae5cd06bccda90", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "patch": "@@ -1841,7 +1841,7 @@ impl PrimitiveType {\n                 Reference => [RefSimplifiedType(Mutability::Not), RefSimplifiedType(Mutability::Mut)].into_iter().collect(),\n                 // FIXME: This will be wrong if we ever add inherent impls\n                 // for function pointers.\n-                Fn => ArrayVec::new(),\n+                Fn => single(FunctionSimplifiedType(1)),\n                 Never => single(NeverSimplifiedType),\n             }\n         })"}, {"sha": "36a47b05cb9d674b0dadd2a817fac9e35bdf7c3b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "patch": "@@ -1165,18 +1165,38 @@ impl clean::Impl {\n \n             if let clean::Type::Tuple(types) = &self.for_ &&\n                 let [clean::Type::Generic(name)] = &types[..] &&\n-                (self.kind.is_fake_variadic() || self.kind.is_auto()) {\n+                (self.kind.is_fake_variadic() || self.kind.is_auto())\n+            {\n                 // Hardcoded anchor library/core/src/primitive_docs.rs\n                 // Link should match `# Trait implementations`\n                 primitive_link_fragment(f, PrimitiveType::Tuple, &format!(\"({name}\u2081, {name}\u2082, \u2026, {name}\u2099)\"), \"#trait-implementations-1\", cx)?;\n-            } else if let clean::Type::BareFunction(bare_fn) = &self.for_ &&\n+            } else if let clean::BareFunction(bare_fn) = &self.for_ &&\n                 let [clean::Argument { type_: clean::Type::Generic(name), .. }] = &bare_fn.decl.inputs.values[..] &&\n-                (self.kind.is_fake_variadic() || self.kind.is_auto()) {\n+                (self.kind.is_fake_variadic() || self.kind.is_auto())\n+            {\n                 // Hardcoded anchor library/core/src/primitive_docs.rs\n                 // Link should match `# Trait implementations`\n-                primitive_link_fragment(f, PrimitiveType::Tuple, &format!(\"fn ({name}\u2081, {name}\u2082, \u2026, {name}\u2099)\"), \"#trait-implementations-1\", cx)?;\n-                // Not implemented.\n-                assert!(!bare_fn.decl.c_variadic);\n+\n+                let hrtb = bare_fn.print_hrtb_with_space(cx);\n+                let unsafety = bare_fn.unsafety.print_with_space();\n+                let abi = print_abi_with_space(bare_fn.abi);\n+                if f.alternate() {\n+                    write!(\n+                        f,\n+                        \"{hrtb:#}{unsafety}{abi:#}\",\n+                    )?;\n+                } else {\n+                    write!(\n+                        f,\n+                        \"{hrtb}{unsafety}{abi}\",\n+                    )?;\n+                }\n+                let ellipsis = if bare_fn.decl.c_variadic {\n+                    \", ...\"\n+                } else {\n+                    \"\"\n+                };\n+                primitive_link_fragment(f, PrimitiveType::Tuple, &format!(\"fn ({name}\u2081, {name}\u2082, \u2026, {name}\u2099{ellipsis})\"), \"#trait-implementations-1\", cx)?;\n                 // Write output.\n                 if let clean::FnRetTy::Return(ty) = &bare_fn.decl.output {\n                     write!(f, \" -> \")?;"}, {"sha": "a61ba7bbf328cee6aaaa5efde5e4e9125ec9f048", "filename": "src/test/ui/error-codes/E0118.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Ftest%2Fui%2Ferror-codes%2FE0118.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Ftest%2Fui%2Ferror-codes%2FE0118.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0118.rs?ref=5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "patch": "@@ -1,4 +1,4 @@\n-impl fn(u8) { //~ ERROR E0118\n+impl<T> T { //~ ERROR E0118\n     fn get_state(&self) -> String {\n        String::new()\n     }"}, {"sha": "8c6fa7947a8537746be07f1c35f7d2eaf8881367", "filename": "src/test/ui/error-codes/E0118.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Ftest%2Fui%2Ferror-codes%2FE0118.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Ftest%2Fui%2Ferror-codes%2FE0118.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0118.stderr?ref=5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "patch": "@@ -1,8 +1,8 @@\n error[E0118]: no nominal type found for inherent implementation\n-  --> $DIR/E0118.rs:1:6\n+  --> $DIR/E0118.rs:1:9\n    |\n-LL | impl fn(u8) {\n-   |      ^^^^^^ impl requires a nominal type\n+LL | impl<T> T {\n+   |         ^ impl requires a nominal type\n    |\n    = note: either implement a trait on it or create a newtype to wrap it instead\n "}, {"sha": "507483dec2ee263c1b99c3ecda0946131774b5b4", "filename": "src/test/ui/error-codes/E0390.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Ftest%2Fui%2Ferror-codes%2FE0390.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Ftest%2Fui%2Ferror-codes%2FE0390.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0390.rs?ref=5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "patch": "@@ -4,5 +4,7 @@ struct Foo {\n \n impl *mut Foo {} //~ ERROR E0390\n \n+impl fn(Foo) {} //~ ERROR E0390\n+\n fn main() {\n }"}, {"sha": "0e5a9ca762b768ff2bde803695dfcac6697a9108", "filename": "src/test/ui/error-codes/E0390.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Ftest%2Fui%2Ferror-codes%2FE0390.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Ftest%2Fui%2Ferror-codes%2FE0390.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0390.stderr?ref=5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "patch": "@@ -6,6 +6,14 @@ LL | impl *mut Foo {}\n    |\n    = help: consider using an extension trait instead\n \n-error: aborting due to previous error\n+error[E0390]: cannot define inherent `impl` for primitive types\n+  --> $DIR/E0390.rs:7:6\n+   |\n+LL | impl fn(Foo) {}\n+   |      ^^^^^^^\n+   |\n+   = help: consider using an extension trait instead\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0390`."}, {"sha": "7ce3dedaa887bf7f6a777d0444967c2f1412eff8", "filename": "src/test/ui/issues/issue-59488.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr?ref=5271e32c463e92f1afa6c54aa9dbb6a9d8454e0d", "patch": "@@ -96,13 +96,13 @@ LL |     assert_eq!(Foo::Bar, i);\n    = help: the trait `Debug` is not implemented for `fn(usize) -> Foo {Foo::Bar}`\n    = help: the following other types implement trait `Debug`:\n              extern \"C\" fn() -> Ret\n-             extern \"C\" fn(A) -> Ret\n-             extern \"C\" fn(A, ...) -> Ret\n              extern \"C\" fn(A, B) -> Ret\n              extern \"C\" fn(A, B, ...) -> Ret\n              extern \"C\" fn(A, B, C) -> Ret\n              extern \"C\" fn(A, B, C, ...) -> Ret\n              extern \"C\" fn(A, B, C, D) -> Ret\n+             extern \"C\" fn(A, B, C, D, ...) -> Ret\n+             extern \"C\" fn(A, B, C, D, E) -> Ret\n            and 68 others\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}]}